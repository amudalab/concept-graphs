
Search algorithm
 /firstHeading 
 bodyContent 

 tagline 
From Wikipedia, the free encyclopedia
 /tagline 
 subtitle 
(Redirected from Uninformed search)
 /subtitle 
 jumpto 

					Jump to:					navigation, 					search

 /jumpto 
 bodycontent 
In computer science, a search algorithm is an algorithm for finding an item with specified properties among a collection of items. The items may be stored individually as records in a database; or may be elements of a search space defined by a mathematical formula or procedure, such as the roots of an equation with integer variables; or a combination of the two, such as the Hamiltonian circuits of a graph.




Contents


1 Classes of search algorithms

1.1 For virtual search spaces
1.2 For sub-structures of a given structure
1.3 Search for the maximum of a function
1.4 For quantum computers


2 See also
3 References
4 External links




[edit] Classes of search algorithms
[edit] For virtual search spaces
Algorithms for searching virtual spaces are used in constraint satisfaction problem, where the goal is to find a set of value assignments to certain variables that will satisfy specific mathematical equations and inequations. They are also used when the goal is to find a variable assignment that will maximize or minimize a certain function of those variables. Algorithms for these problems include the basic brute-force search (also called "nave" or "uninformed" search), and a variety of heuristics that try to exploit partial knowledge about structure of the space, such as linear relaxation, constraint generation, and constraint propagation.
An important subclass are the local search methods, that view the elements of the search space as the vertices of a graph, with edges defined by a set of heuristics applicable to the case; and scan the space by moving from item to item along the edges, for example according to the steepest descent or best-first criterion, or in a stochastic search. This category includes a great variety of general metaheuristic methods, such as simulated annealing, tabu search, A-teams, and genetic programming, that combine arbitrary heuristics in specific ways.
This class also includes various tree search algorithms, that view the elements as vertices of a tree, and traverse that tree in some special order. Examples of the latter include the exhaustive methods such as depth-first search and breadth-first search, as well as various heuristic-based search tree pruning methods such as backtracking and branch and bound. Unlike general metaheuristics, which at best work only in a probabilistic sense, many of these tree-search methods are guaranteed to find the exact or optimal solution, if given enough time.
Another important sub-class consists of algorithms for exploring the game tree of multiple-player games, such as chess or backgammon, whose nodes consist of all possible game situations that could result from the current situation. The goal in these problems is to find the move that provides the best chance of a win, taking into account all possible moves of the opponent(s). Similar problems occur when humans or machines have to make successive decisions whose outcomes are not entirely under one's control, such as in robot guidance or in marketing, financial or military strategy planning. This kind of problem - combinatorial search - has been extensively studied in the context of artificial intelligence. Examples of algorithms for this class are the minimax algorithm, alpha-beta pruning, and the A* algorithm.
[edit] For sub-structures of a given structure
The name combinatorial search is generally used for algorithms that look for a specific sub-structure of a given discrete structure, such as a graph, a string, a finite group, and so on. The term combinatorial optimization is typically used when the goal is to find a sub-structure with a maximum (or minimum) value of some parameter. (Since the sub-structure is usually represented in the computer by a set of integer variables with constraints, these problems can be viewed as special cases of constraint satisfaction or discrete optimization; but they are usually formulated and solved in a more abstract setting where the internal representation is not explicitly mentioned.)
An important and extensively studied subclass are the graph algorithms, in particular graph traversal algorithms, for finding specific sub-structures in a given graph  such as subgraphs, paths, circuits, and so on. Examples include Dijkstra's algorithm, Kruskal's algorithm, the nearest neighbour algorithm, and Prim's algorithm.
Another important subclass of this category are the string searching algorithms, that search for patterns within strings. Two famous examples are the BoyerMoore and KnuthMorrisPratt algorithms, and several algorithms based on the suffix tree data structure.
[edit] Search for the maximum of a function
In 1953 J. Kiefer devised Fibonacci search which can be used to find the maximum of a unimodal function and has many other applications in computer science.
[edit] For quantum computers
There are also search methods designed for quantum computers, like Grover's algorithm, that are theoretically faster than linear or brute-force search even without the help of data structures or heuristics.
[edit] See also

Category:Search algorithms
Backward search
Solver
Search games
Recommender systems also use statistical methods to rank results in very large data sets
Sorting algorithms necessary for executing certain search algorithms
Selection algorithm
No free lunch in search and optimization
Search engine (computing)
Linear search problem
String searching algorithm

[edit] References

Donald Knuth. The Art of Computer Programming. Volume 3: Sorting and Searching. ISBN 0-201-89685-0.

[edit] External links

Uninformed Search Project at the Wikiversity.
Unsorted Data Searching Using Modulated Database.

 
NewPP limit report
Preprocessor visited node count: 31/1000000
Preprocessor generated node count: 36/1500000
Post-expand include size: 0/2048000 bytes
Template argument size: 0/2048000 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/500

 Saved in parser cache with key enwiki:pcache:idhash:28249-0!*!0!!en!*!* and timestamp 20130111233544 
  /bodycontent 
 printfooter 

				Retrieved from "http://en.wikipedia.org/w/index.php?title=Search_algorithm&oldid=532617491#Uninformed_search"				
 /printfooter 
 catlinks 
Categories: Search algorithms  /catlinks 

 debughtml 
 /debughtml 

 /bodyContent 

 