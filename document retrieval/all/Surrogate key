
Surrogate key
 /firstHeading 
 bodyContent 

 tagline 
From Wikipedia, the free encyclopedia
 /tagline 
 subtitle 

 /subtitle 
 jumpto 

					Jump to:					navigation, 					search

 /jumpto 
 bodycontent 





This article includes a list of references, related reading or external links, but its sources remain unclear because it lacks inline citations. Please improve this article by introducing more precise citations. (July 2009) 


A surrogate key in a database is a unique identifier for either an entity in the modeled world or an object in the database. The surrogate key is not derived from application data.




Contents


1 Definition
2 Surrogates in practice
3 Advantages

3.1 Immutability
3.2 Requirement changes
3.3 Performance
3.4 Compatibility
3.5 Uniformity
3.6 Validation


4 Disadvantages

4.1 Disassociation
4.2 Query optimization
4.3 Normalization
4.4 Business process modeling
4.5 Inadvertent disclosure
4.6 Inadvertent assumptions


5 See also
6 References




[edit] Definition
There are at least two definitions of a surrogate:

Surrogate (1)  Hall, Owlett and Codd (1976)
A surrogate represents an entity in the outside world. The surrogate is internally generated by the system but is nevertheless visible to the user or application.
Surrogate (2)  Wieringa and De Jonge (1991)
A surrogate represents an object in the database itself. The surrogate is internally generated by the system and is invisible to the user or application.

The Surrogate (1) definition relates to a data model rather than a storage model and is used throughout this article. See Date (1998).
An important distinction between a surrogate and a primary key depends on whether the database is a current database or a temporal database. Since a current database stores only currently valid data, there is a one-to-one correspondence between a surrogate in the modeled world and the primary key of the database. In this case the surrogate may be used as a primary key, resulting in the term surrogate key. In a temporal database, however, there is a many-to-one relationship between primary keys and the surrogate. Since there may be several objects in the database corresponding to a single surrogate, we cannot use the surrogate as a primary key; another attribute is required, in addition to the surrogate, to uniquely identify each object.
Although Hall et al. (1976) say nothing about this, others[specify] have argued that a surrogate should have the following characteristics:

the value is unique system-wide, hence never reused
the value is system generated
the value is not manipulable by the user or application
the value contains no semantic meaning
the value is not visible to the user or application
the value is not composed of several values from different domains.

[edit] Surrogates in practice
In a current database, the surrogate key can be the primary key, generated by the database management system and not derived from any application data in the database. The only significance of the surrogate key is to act as the primary key. It is also possible that the surrogate key exists in addition to the database-generated UUID (for example, an HR number for each employee other than the UUID of each employee).
A surrogate key is frequently a sequential number (e.g. a Sybase or SQL Server "identity column", a PostgreSQL or Informix serial, an Oracle SEQUENCE or a column defined with AUTO_INCREMENT in MySQL) but doesn't have to be. Having the key independent of all other columns insulates the database relationships from changes in data values or database design (making the database more agile) and guarantees uniqueness.
In a temporal database, it is necessary to distinguish between the surrogate key and the primary key. Typically, every row would have both a primary key and a surrogate key. The primary key identifies the unique row in the database, the surrogate key identifies the unique entity in the modelled world; these two keys are not the same. For example, table Staff may contain two rows for "John Smith", one row when he was employed between 1990 and 1999, another row when he was employed between 2001 and 2006. The surrogate key is identical (non-unique) in both rows however the primary key will be unique.
Some database designers use surrogate keys systematically regardless of the suitability of other candidate keys, while others will use a key already present in the data, if there is one.
A surrogate key may also be called a synthetic key, an entity identifier, a system-generated key, a database sequence number, a factless key, a technical key, or an arbitrary unique identifier.[citation needed] Some of these terms describe the way of generating new surrogate values rather than the nature of the surrogate concept.
Approaches to generating surrogates include:

Universally Unique Identifiers (UUIDs)
Globally Unique Identifiers (GUIDs)
Object Identifiers (OIDs)
Sybase or SQL Server identity column IDENTITY OR IDENTITY(n,n)
Oracle SEQUENCE
PostgreSQL or IBM Informix serial
MySQL AUTO_INCREMENT
AutoNumber data type in Microsoft Access
AS IDENTITY GENERATED BY DEFAULT in IBM DB2
Identity column (implemented in DDL) in Teradata

[edit] Advantages
[edit] Immutability
Surrogate keys do not change while the row exists. This has the following advantages:

Applications cannot lose their reference to a row in the database (since the identifier never changes).
The primary key data can always be modified, even with databases that do not support cascading updates across related foreign keys.

[edit] Requirement changes
Attributes that uniquely identify an entity might change, which might invalidate the suitability of the natural, compound keys. Consider the following example:

An employee's network user name is chosen as a natural key. Upon merging with another company, new employees must be inserted. Some of the new network user names create conflicts because their user names were generated independently (when the companies were separate).

In these cases, generally a new attribute must be added to the natural key (for example, an original_company column). With a surrogate key, only the table that defines the surrogate key must be changed. With natural keys, all tables (and possibly other, related software) that use the natural key will have to change.
Some problem domains do not clearly identify a suitable natural key. Surrogate key avoids choosing a natural key that might be incorrect.
[edit] Performance
Surrogate keys tend to be a compact data type, such as a four-byte integer. This allows the database to query the single key column faster than it could multiple columns. Furthermore a non-redundant distribution of keys causes the resulting b-tree index to be completely balanced. Surrogate keys are also less expensive to join (fewer columns to compare) than compound keys.
[edit] Compatibility
While using several database application development systems, drivers, and object-relational mapping systems, such as Ruby on Rails or Hibernate, it is much easier to use an integer or GUID surrogate keys for every table instead of natural keys in order to support database-system-agnostic operations and object-to-row mapping.
[edit] Uniformity
When every table has a uniform surrogate key, some tasks can be easily automated by writing the code in a table-independent way.
[edit] Validation
It is possible to design key-values that follow a well-known pattern or structure which can be automatically verified. For instance, the keys that are intended to be used in some column of some table might be designed to "look differently from" those that are intended to be used in another column or table, thereby simplifying the detection of application errors in which the keys have been misplaced. However, this characteristic of the surrogate keys should never be used to drive any of the logic of the applications themselves, as this would violate the principles of Database normalization.
[edit] Disadvantages
[edit] Disassociation
The values of generated surrogate keys have no relationship to the real-world meaning of the data held in a row. When inspecting a row holding a foreign key reference to another table using a surrogate key, the meaning of the surrogate key's row cannot be discerned from the key itself. Every foreign key must be joined to see the related data item. This can also make auditing more difficult,[citation needed] as incorrect data is not obvious.
Surrogate keys are unnatural for data that is exported and shared. A particular difficulty is that tables from two otherwise identical schemas (for example, a test schema and a development schema) can hold records that are equivalent in a business sense, but have different keys. This can be mitigated by not exporting surrogate keys, except as transient data (most obviously, in executing applications that have a "live" connection to the database).
[edit] Query optimization
Relational databases assume a unique index is applied to a table's primary key. The unique index serves two purposes: (i) to enforce entity integrity, since primary key data must be unique across rows and (ii) to quickly search for rows when queried. Since surrogate keys replace a table's identifying attributesthe natural keyand since the identifying attributes are likely to be those queried, then the query optimizer is forced to perform a full table scan when fulfilling likely queries. The remedy to the full table scan is to apply indexes on the identifying attributes, or sets of them. Where such sets are themselves a candidate key, the index can be a unique index.
These additional indexes, however, will take up disk space and slow down inserts and deletes.
[edit] Normalization
The presence of a surrogate key can result in the database administrator forgetting to establish, or accidentally removing, a secondary unique index on the natural key of the table. Without a unique index on the natural key, duplicate rows can appear and once present can be difficult to identify.
[edit] Business process modeling
Because surrogate keys are unnatural, flaws can appear when modeling the business requirements. Business requirements, relying on the natural key, then need to be translated to the surrogate key. A strategy is to draw a clear distinction between the logical model (in which surrogate keys do not appear) and the physical implementation of that model, to ensure that the logical model is correct and reasonably well normalised, and to ensure that the physical model is a correct implementation of the logical model.
[edit] Inadvertent disclosure
Proprietary information can be leaked if sequential key generators are used. By subtracting a previously generated sequential key from a recently generated sequential key, one could learn the number of rows inserted during that time period. This could expose, for example, the number of transactions or new accounts per period. There are a few ways to overcome this problem:

Increase the sequential number by a random amount.
Generate a completely random primary key. However, to prevent duplication which would cause an insert rejection, a randomly generated primary key must either be queried (to check that it is not already in use), or the key must contain enough entropy that one can be confident that collisions will not happen.

[edit] Inadvertent assumptions
Sequentially generated surrogate keys create the illusion that events with a higher primary key value occurred after events with a lower primary key value. This illusion would appear when an event is missed during the normal data entry process and is, instead, inserted after subsequent events were previously inserted. The solution to the inadvertent assumption problem is to generate a random primary key. However, a randomly generated primary key must be queried before assigned to prevent duplication and cause an insert rejection.[citation needed]
[edit] See also

Natural key
Object identifier
Persistent Object Identifier

[edit] References

This article is based on material taken from the Free On-line Dictionary of Computing prior to 1 November 2008 and incorporated under the "relicensing" terms of the GFDL, version 1.3 or later.

Nijssen, G.M. (1976). Modelling in Data Base Management Systems. North-Holland Pub. Co.. ISBN0-7204-0459-2.
Engles, R.W.: (1972), A Tutorial on Data-Base Organization, Annual Review in Automatic Programming, Vol.7, Part 1, Pergamon Press, Oxford, pp.164.
Langefors, B (1968). Elementary Files and Elementary File Records, Proceedings of File 68, an IFIP/IAG International Seminar on File Organisation, Amsterdam, November, pp.8996.
Wieringa, R.; de Jonge, W. (1991). The identification of objects and roles: Object identifiers revisited. CiteSeerX: 10.1.1.16.3195.
Date, C. J. (1998). "Chapters 11 and 12". Relational Database Writings 19941997. ASIN0201398141.
Carter, Breck. "Intelligent Versus Surrogate Keys". http://www.bcarter.com/intsurr1.htm. Retrieved 2006-12-03.
Richardson, Lee. "Create Data Disaster: Avoid Unique Indexes  (Mistake 3 of 10)". http://www.nearinfinity.com/blogs/page/lrichard?entry=create_data_disaster_avoid_unique. Retrieved 2008-01-19.
Berkus, Josh. "Database Soup: Primary Keyvil, Part I". http://blogs.ittoolbox.com/database/soup/archives/primary-keyvil-part-i-7327. Retrieved 2006-12-03.










v
t
e


Database management systems









Database models
Database normalization
Database storage
Distributed DBMS
Federated database system
Referential integrity
Relational algebra
Relational calculus
Relational database
Relational DBMS
Relational model
Object-relational database
Transaction processing








Concepts



Database
ACID
CRUD
Null
Candidate key
Foreign key
Primary key
Superkey
Surrogate key
Armstrong's axioms
NoSQL








Objects



Relation

table
column
row


View
Transaction
Log
Trigger
Index
Stored procedure
Cursor
Partition








Components



Concurrency control
Data dictionary
JDBC
XQJ
ODBC
Query language
Query optimizer
Query plan








Functions



Administration and automation
Query optimization
Replication











Database products
Object-oriented

comparison


Relational

comparison


Document-oriented
NewSQL








 
NewPP limit report
Preprocessor visited node count: 5587/1000000
Preprocessor generated node count: 32857/1500000
Post-expand include size: 45410/2048000 bytes
Template argument size: 20592/2048000 bytes
Highest expansion depth: 21/40
Expensive parser function count: 4/500

 Saved in parser cache with key enwiki:pcache:idhash:472950-0!*!0!!en!4!* and timestamp 20121211155848 
  /bodycontent 
 printfooter 

				Retrieved from "http://en.wikipedia.org/w/index.php?title=Surrogate_key&oldid=516699036"				
 /printfooter 
 catlinks 
Categories: Database management systemsData modelingHidden categories: Articles lacking in-text citations from July 2009All articles lacking in-text citationsArticles needing more detailed referencesAll articles with unsourced statementsArticles with unsourced statements from December 2010Articles with unsourced statements from October 2010Articles with unsourced statements from December 2011  /catlinks 

 debughtml 
 /debughtml 

 /bodyContent 

 