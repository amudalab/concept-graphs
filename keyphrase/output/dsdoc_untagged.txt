data structures and programming stacks and queues the first data structures we will study this semester will be lists which have the property that the order in which the items are used is determined by the order they arrive stacks are data structures which maintain the order of last-in  first-out queues are data structures which maintain the order of first-in  first-out queues might seem fairer  which is why lines at stores are organized as queues instead of stacks  but both have important applications in programs as a data structure operations on stacks the terminology associated with stacks comes from the spring loaded plate containers common in dining halls when a new plate is washed it is pushed on the stack when someone is hungry  a clean plate is popped off the stack a stack is an appropriate data structure for this task since the plates don t care about when they are used maintaining procedure calls stacks are used to maintain the return points when modula-3 procedures call other procedures which call other procedures  jacob and esau in the biblical story  jacob and esau were twin brothers where esau was born first and thus inherited issac s birthright however  jacob got esau to give it away for a bowl of soup  and so jacob went to become a patriarch of israel but why was jacob justified in so tricking his brother rashi  a famous 11th century jewish commentator  explained the problem by saying jacob was conceived first  then esau second  and jacob could not get around the narrow tube to assume his rightful place first in line abstract operations on a stack push  x,s  and pop  x,s   stack s  item x note that there is no search operation initialize  s   full  s   empty  s    the latter two are boolean queries defining these abstract operations lets us build a stack module to use and reuse without knowing the details of the implementation the easiest implementation uses an array with an index variable to represent the top of the stack an alternative implementation  using linked lists is sometimes better  for it can t ever overflow note that we can change the implementations without the rest of the program knowing declarations for a stack interface stack  stack of integer elements  type et = integer  element type  procedure push  elem et   adds element to top of stack  procedure pop   et  removes and returns top element  procedure empty   boolean  returns true if stack is empty  procedure full   boolean  returns true if stack is full  end stack stack implementation module stack  14.07.94 rm  lb   implementation of an integer stack  const max = 8  maximum number of elements on stack  type s = record info array  1  max  of et top cardinal = 0  initialize stack to empty  end  s  var stack s  instance of stack  procedure push  elem et  =  adds element to top of stack  begin inc  stack.top  stack.info  stack.top  = elem end push procedure pop   et =  removes and returns top element  begin dec  stack.top  return stack.info  stack.top + 1  end pop procedure empty   boolean =  returns true if stack is empty  begin return stack.top = 0 end empty procedure full   boolean =  returns true if stack is full  begin return stack.top = max end full begin end stack using the stack type module stackuser exports main  14.02.95 lb   example client of the integer stack  from stack import push  pop  empty  full from sio import error  getint  putint  puttext  nl < fatal error >  suppress warning  begin puttext  " stack user please enter numbers \ n "  while not full   do push  getint     add entered number to stack  end while not empty   do putint  pop     remove number from stack and return it  end nl   end stackuser fifo queues queues are more difficult to implement than stacks  because action happens at both ends the easiest implementation uses an array  adds elements at one end  and moves all elements when something is taken off the queue it is very wasteful moving all the elements on each dequeue can we do better more efficient queues suppose that we maintaining pointers to the first  head  and last  tail  elements in the array/queue note that there is no reason to explicitly clear previously unused cells now both enqueue and dequeue are fast  but they are wasteful of space we need a array bigger than the total number of enqueues  instead of the maximum number of items stored at a particular time circular queues circular queues let us reuse empty space note that the pointer to the front of the list is now behind the back pointer when the queue is full  the two pointers point to neighboring elements there are lots of possible ways to adjust the pointers for circular queues all are tricky how do you distinguish full from empty queues  since their pointer positions might be identical the easiest way to distinguish full from empty is with a counter of how many elements are in the queue fifo queue interface interface fifo  14.07.94 rm  lb   a queue of text elements  type et = text  element type  procedure enqueue  elem et   adds element to end  procedure dequeue   et  removes and returns first element  procedure empty   boolean  returns true if queue is empty  procedure full   boolean  returns true if queue is full  end fifo priority queue implementation module fifo  14.07.94 rm  lb   implementation of a fifo queue of text elements  const max = 8  maximum number of elements in fifo queue  type fifo = record info array  0  max  1  of et in  out  n cardinal = 0 end  fifo  var w fifo  contains a fifo queue  procedure enqueue  elem et  =  adds element to end  begin w.info  w.in  = elem  stores new element  w.in =  w.in + 1  mod max  increments in-pointer in ring  inc  w.n   increments number of stored elements  end enqueue procedure dequeue   et =  removes and returns first element  var e et begin e = w.info  w.out   removes oldest element  w.out =  w.out + 1  mod max  increments out-pointer in ring  dec  w.n   decrements number of stored elements  return e  returns the read element  end dequeue utility routines procedure empty   boolean =  returns true if queue is empty  begin return w.n = 0 end empty procedure full   boolean =  returns true if queue is full  begin return w.n = max end full begin end fifo user module module fifouser exports main  14.07.94 lb   example client of the text queue  from fifo import enqueue  dequeue  empty  full  operations of the queue  from sio import error  gettext  puttext  nl < fatal error >  supress warning  begin puttext  " fifo user please enter texts \ n "  while not full   do enqueue  gettext    end while not empty   do puttext  dequeue   & " "  end nl   end fifouser other queues double-ended queues  these are data structures which support both push and pop and enqueue/dequeue operations priority queues  heaps   supports insertions and remove minimum operations which useful in simulations to maintain a queue of time events in this lecture we introduce another commonly used data structure called a stack we practice again writing an interface  and then implementing the interface using linked lists as for queues we also discuss how to check whether a linked list is circular or not 2 stack interface stacks are similar to queues in that we can insert and remove items but we remove them from the same end that we add them  which makes stacks a lifo  last in first out  data structure here is our interface type elem must be defined typedef struct stack stack bool is_empty  stack s  / o  1  / stack s_new   / o  1  / void push  elem x  stack s  / o  1  / elem pop  stack s  / o  1  / we want the creation of a new  empty  stack as well as pushing and popping an item all to be constant-time operations we are being slightly more abstract here than in the case of queues in that we do not write  in this file  what type the elements of the stack have to be instead we assume that before the file is read  we have already defined a lecture notes september 16  2010 stacks l8.2 type elem for the type of stack elements we say that the implementation is generic or polymorphic in the type of the elements unfortunately  neither c nor c0 provide a good way to enforce this in the language and we have to rely on programmer discipline 3 stack implementation the idea is to reuse linked lists but since all operations work on one end of the list  we do not need two pointers but just one which we call top a typical stack then has the following form 3 2 1 top data next note that the end of the linked list is marked with the special null pointer that can not be dereferenced we define struct list  elem data struct list next  typedef struct list list struct stack  list top  to test if some structure is a valid stack  we only need to check that the list starting at top ends in null  which is the same as checking that this is a list segment  as introduced in the last lecture   bool is_stack  stack s   return is_segment  s > top  null   lecture notes september 16  2010 stacks l8.3 to check if the stack is empty  we only need to verify that top is null bool is_empty  stack s  @ requires is_stack  s   return s > top = = null  creating a new stack is very simple  since we only need to set top to null after allocating it stack s_new   @ ensures is_stack  \ result  @ ensures is_empty  \ result   stack s = alloc  struct stack  s > top = null return s  to push an element onto the stack  we create a new list item  set its data field and then its next field to the current top of the stack finally  we need to update the top field of the stack to point to the new list item while this is simple  it is still a good idea to draw a diagram we go from 3 2 1 top data next lecture notes september 16  2010 stacks l8.4 to 3 2 1 top data next 4 in code void push  elem x  stack s  @ requires is_stack  s  @ ensures is_empty  s   list first = alloc  struct list  first > data = x first > next = s > top s > top = first  finally  to pop an element from the stack we just have to move the top pointer to follow the next pointer from the top of the stack as in the case of dequeuing an element from the previous lecture  the list item that previously constituted the top of the stack will no longer be accessible and be garbage collected as needed by the runtime system we go from 3 2 1 top data next lecture notes september 16  2010 stacks l8.5 to 3 2 1 top data next in code elem pop  stack s  @ requires is_stack  s  @ ensures is_stack  s   assert  s > top = null  " can not pop empty stack "   elem x = s > top > data s > top = s > top > next return x   this completes the implementation of stacks  which are a very simple and pervasive data structure we will exercise them in the next lecture when we implement a virtual machine 4 detecting circularity checking whether a stack or a queue satisify their data structure invariant raises an interesting question what if  somehow  we created a list that lecture notes september 16  2010 stacks l8.6 contains a cycle  such as 1 2 3 4 start data next 6 5 in that case  following next pointers until we reach null actually never terminates the program for checking a segment will get into an infinite loop in general  contracts should terminate and have no effects it is marginally acceptable if a contract diverges  because it will not incorrectly claim that the contract it satisfied  but it would clearly be better if it explicitly rejected a circular list but how do we check that before you read on  you should seriously think about the problem  like our class did in lecture lecture notes september 16  2010 stacks l8.7 here is the original is_segment predicate bool is_segment  list start  list end   list p = start while  p = end   if  p = = null  return false p = p > next  return true  one the simplest solutions proposed in class keeps a copy of the start pointer then when we advance p we run through an auxiliary loop to check if the next element is already in the list the code would be something like bool is_segment  list start  list end   list p = start while  p = end   if  p = = null  return false  list q = start while  q = p   if  q = = p > next  return false circular q = q > next   p = p > next  return true  unfortunately this solution requires o  n 2  time for a list with n elements  whether it is circular or not again  consider if you can find a better solution before reading on lecture notes september 16  2010 stacks l8.8 the idea for a more efficient solution is to create two pointers  let s name them t and h t traverses the list like the pointer p before  in single steps h  on the other hand  skips two elements ahead for every step taken by p if the slower one t ever gets into a loop  the other pointer h will overtake it from behind and this is the only way that this is possible let s try it on our list we show the state of t and h on every iteration 1 2 3 4 data next 6 5 t h 1 2 3 4 data next 6 5 t h 1 2 3 4 data next 6 5 t h lecture notes september 16  2010 stacks l8.9 1 2 3 4 data next 6 5 t h in code bool is_circular  list l   if  l = = null  return false  list t = l tortoise list h = l > next hare while  t = h  @ loop_invariant is_segment  t  h   if  h = = null h > next = = null  return false t = t > next h = h > next > next  return true   a few points about this code in the condition inside the loop we exploit the short-circuiting evaluation of the logical or so we only follow the next pointer for h when we know it is not null guarding against trying to dereference a null pointer is an extremely important consideration when writing pointer manipulation code such as this this algorithm has been called the tortoise and the hare and is due to floyd we have chosen t to stand for tortoise and h to stand for hare this algorithm has complexity o  n   an easy way to see this was suggested by a student in class when there is no loop  the hare will stumble over null after o  n  steps if there is a loop  then consider the point when the tortoise enters the loop at this point  the hare must already be somewhere in the loop now for every step the tortoise takes in the loop the hare takes two  so on every iteration it comes one closer the hare will catch the tortoise after at most half the size of the loop therefore the overall complexity of o  n  the tortoise will not complete a full trip around the loop 