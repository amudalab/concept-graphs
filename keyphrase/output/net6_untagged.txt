computer networks prof sujoy ghosh department of computer science and engineering iit  kharagpur lecture-26 introduction to routing  refer slide time  00  39  today we will start our discussion on routing we have already talked about routing a little bit in different context  specifically in the context of atm of how the atm virtual path etc are set up today we will start our discussion on the major area of routing and specially with reference to the tcp/ip stack that is how packets are routed in an ip network  refer slide time  01  22  01  33 min  today we will start the introduction with routing and then we will take up the discussion about different routing protocols in the next set of lectures  refer slide time  01  34  03  46 min  let us just recollect  what is the job of the network layer or what is routing ? the job of the network layer is to carry data from end-to-end that is  from the source to destination perhaps through a number of intermediate subnets now depending on whether connection-oriented or connectionless services are used other functionalities may be incorporated at this layer we will talk about this later on right now we are talking about routing of ip packets and later on we will discuss on how you can have a virtually connection oriented system on that unlike data link layer  if you remember  is just the next hop  just the link which is immediately adjacent so that has some advantages in the sense that whatever information you require about it are locally available unlike the data link layer  the major problem with routing is that it happens over multiple networks and towards a very remote system and the packet might have to take many hops  may be 10  20 or even 30 hops to reach the end point when you take 20 hops the area you are serving becomes so large with so many machines connected to it and then how do you keep track and then switch so many machines with so many links ? the problem is some of the links may go down  some of the machines may go down  some of the machines may come up and when i may refer it actually says pcs  servers  etc  they may also refer to network boxes like other routers so the job of the router is to know which link it should take so that globally the packet will arrive nearer to its destination  refer slide time  03  47  04  12 min  this is the basic routing problem at a particular subnet node given a packet with a particular final destination determine the next subnet node or the outgoing link which is appropriate in the datagram network this is determined for individual packets but in vc networks this is determined only for setup packet for each session now we will concentrate on the datagram network  refer slide time  04  13  08  20 min  consider a router x x may not know the topology of the entire internetwork these days everybody wants to be connected to the internet so we have a giant network of networks so there is this big network of networks spanning the entire globe and then a particular network once again may be divided into so many sub networks there are billions of machines connected to this network so some user somewhere wants to connect to another user on the other part of the globe this is a huge problem that must be solved in a systematic manner but this is the objective of routing or the network layer so x needs to determine the next ? hop router for every other network in the internet we are trying to reach some particular machine  some particular server if you want to keep track of all the machines in the world it becomes really impractical we somewhat reduce the problem where all these different machines are grouped into different networks or even sub networks they are grouped into different networks so that a remote router needs to keep track of only the remote network rather than a particular server in that network of course  the idea is that  once you reach your destination network finding a particular server within that network will be very easy either through arp or some such protocol you can reach the particular server once you have reached the correct destination network the entire information that is required is structured as a routing table of router x to keep track of all the other networks what is a routing table ? given the address of a particular network in a remote location we should be able to find from the routing table that which local hop i must take next even that is not easy even if you reduce the scope of the problem from servers or pcs to networks because there are millions of networks in the world so theoretically if you do it in a very naive fashion you have to keep millions of entries so that you can match and know that this is what the mistake is of course  even this is not possible because at the same time you want to go to the correct destination for this particular packet and at the same time you want to process the packets as fast as possible people want more and more speed so the network traffic and the number of packets are increasing day by day so you have to process the packets very fast if you have a very large table then it demands time even just to look up to it and you require a lot of memory additionally it consumes lot of processing power which will thereby drive up the cost of the router so  even keeping millions of entries for most routers this is not a feasible option therefore we have to do something about it  refer slide time  08  21  10  04 min   the other issues in routing are  one is  the topology changes affect convergence  delay and stability topology of the network changes all the time because the links may go down or come up  nodes may go down or come up so the topology is changing therefore this may the change the path that a particular packet takes and the path the next packet takes in the same stream this may affect the delay and the stability the other problem is scalability to a large number of interconnected networks or routers or links and even when you come down from nodes to networks this is still a very large problem then there are other issues like what is the best path from x to y it may be that five different routes are possible from x to y now all these five routes are not equal first of all they may not be equal in the number of hops  they may not be equal in length  they may not be equal in cost  they may not be equal in the quality  some of the routes may be very unreliable that the packet has a larger probability of getting dropped and so on and so forth so we would like to have the minimum number of hops or the minimum delay or the maximum capacity therefore if possible we would also like to incorporate the quality of the path when deciding on a route for a particular packet from x to y  refer slide time  10  05 11  30 min   so routing consists of deciding the route for each packet and in order to do that the router has to have knowledge of the entire network and this knowledge has to be dynamic because the network topology keeps on changing so we have to update the knowledge of the network from time to time suppose you have a host or lans connected to some routers say a  b  c  d  e and then through the links 1  2  3  4  5 and 6 respectively then for example when the router a gets a packet from a local network which is connected to it which may be destined for the lan which is connected to router c so it has to decide whether to take link 1 or link 3 obviously it does not take this link because this is where it is coming from and obviously it is destined to some other sort of remote so it has to decide although in this particular example you may theoretically reach c both by taking link 1 and link 3 but then these links may be of different quality  may be something like a  d  b,c  e is a bit of choice  refer slide time  11  31 12  12 min  as mentioned earlier these are the routing tables we have the routing tables in routers they look somewhat like this for example  let us look at the routing from a and this may be just one form of it it may not be exactly used in this form but let us look at it suppose you want to route to the router a which is again local because we are sitting on router a  for b you take link 1  for router c link 1  for router d link 3 and for router e link 1  refer slide time  12  13 12  24 min   from a to b is link 1  may be c is also link 1 and d is link 3 and e is again link 1 and so on   refer slide time  12  25  12  59   similarly  b will have a routing table and c will have a routing table and so on suppose you take any destination a   refer slide time  13  00  15  41   now for a let us consider a tree with a root at a now b connects to a through link 1 and c connects to a through link 2 obviously link 2 is not taking c directly to a but link 2 is only taking c to b but that is the preferred path for connection from c to a if you think about it this way  for each destination we have got some kind of a tree if the network was very bigger here the network is very small so the tree is only two levels deep but the tree could be very deep may be 10 or 15 levels deep so for each destination we actually have a tree which is implicit in these routing tables which are distributed at each node we try to see the local link to be taken for that particular destination as i said  the local link may not take you directly to the ultimate destination but the local link will take you somewhere and that particular node will again have a link for the same destination this way  if everything is working fine  after some hops you will reach the final destination this means that some of the other nodes may be directly connected  some may be 2 hops away  some may be 3 hops away etc but overall there is an implicit tree for each destination and for one movable link of this tree is in one particular link of this routing table just according to the destination in other words  if there are n nodes and there are n implicit trees and these n implicit trees are distributed over n nodes so it is one link from each tree in the routing table of a particular node in that way you have a routing table of size n including the root which is the local link and somehow you need to maintain this tree and that is the job of a routing protocol later on we will see different routing protocols and also see how these implicit trees may be maintained or rather how these routing tables have to be maintained  refer slide time  15  42 16  44 min   when there is a routing table there is a question of forwarding routing is the process of building routing tables at each router forwarding is the process of looking at the destination address of a packet and sending it to appropriate next hop interface of a router this means  once through a routing protocol you have a routing table then a packet actually arrives and you have to forward it to the correct interface of that router so  you look up to this table and the interface to which the packet must be sent and forward it so this routing or forwarding are two different and distinct parts of the router actually sometimes these two are diverged even more for the time being we assume that routing and forwarding happen at the same place and the routing table itself is being used for forwarding although that may not always be the case forwarding requires access to local routing table sometimes forwarding table is structured in a different manner than routing tables  refer slide time  16  45  18  05 min   so forwarding table is optimized for packet look ups routing table is optimized for routing changes  topology changes etc a routing table may look like this  say  for net number 10 the next hop would be this ip number because the routing table is working in the ip address this ip address is version four addresses and it contains four numbers all less than 256 so it is 171.69.245.10 the link cost may be there in forwarding  we really do not care what the ip address or the next hop is we do not even care about the link cost because all these are a part of setting up the routing table in the forwarding table we just wanted to know the interface as to what is the local interface to which this packet has to be sent and what is the mac address at the next hop this is what we are more interested in basically you can just add your data-link headers and just send it over to the physical layer this is a slightly higher level and the abstract view of processing an ip datagram  refer slide time  18  06 21  09 min   in this ip module there is a routing table which is the central thing there is a routing protocol which makes this table sometimes we also use static routing  for the time being let us consider that it has been manually configured some of the entries may have come through a routing protocol while some of the entries may have been manually configured now  when a packet comes from an upper layer it will come from some transmission layer protocol two of the most common transmission layer protocols are tcp and udp we will see what they are later on but let us assume that some packet has come through udp with some destination ip address in it you look up at the routing table  the next hop and send the datagram or the same thing must have come through tcp also when we are discussing the processing of the ip datagram in the ip layer the ip layer is present in two different places in one place it is the regular host the pc and in the other place it is a router the jobs of the two places are a little different if a packet comes from outside to a pc  and is not meant for the pc  the pc is simply going to drop that packet in the case of a router  if a packet comes from outside  it looks up the destination and then actually forward it so in a pc the forwarding table may be disabled whereas in a router the forwarding table will be enabled if the packet originates from machine pc itself then it has to go out on its way it will send the packet to the router the ip datagram it is sent to the network layer this is a high level view of what is happening in the ip datagram processing  refer slide time  21  10  21  21 min  the processing of ip datagrams is very similar on an ip router and a host the main difference is ip forwarding is enabled on router and disabled on host  refer slide time  21  22  21  45 min  now when the ip forwarding is enabled  if a datagram is received but it is not for the local system  the datagram will be sent to a different system when ip forwarding is disabled  if a datagram is received it is not for the local system and the datagram will usually be ignored  refer slide time  21  46  22  03 min  the view at the data link layer is somewhat different internetwork is a collection of lans or point-to-point links or switched networks that are connected by routers so this is the data link layer view of the ip datagram  refer slide time  22  04  23  02 min  in this diagram there may be some point-to-point links or some lans  etc and they are all connected by some routers r1  r2  r3  r4 etc a particular host places an ip datagram on the local ethernet that is destined for outside it will eventually reach the local router and the router will decide whether to give it to another network such as the network of ethernet switches  token ring etc through different networks the packet proceeds through the routers to this when you look at it from a data link layer point of view all these switches become visible whereas at the ip layer only the routers and the networks will be of main concern  refer slide time  23  03 -23  26min  a view att the ip layer  an ip network is a logical entity with a network number we represent an ip network as a cloud the ip delivery service takes the view of clouds and ignores the data link layer view that means the details of these actual switches etc are in the data link layer view whereas in the ip layer view it will simply be a cloud  refer slide time  23  27  23  26 min  in this picture there are routers r1  r2  r3  r4  etc and the connecting networks are shown as clouds each network has some number  refer slide time  23  47 -27  13min  the following conditions must hold so that an ip datagram can be successfully delivered the network prefix of an ip destination address must correspond to a unique data link layer network which is equal to lan or point-to-point link or switched network the reverse need not be true this is quite fundamental you have already seen examples of ip addresses they are basically four numbers each less than 255 that is something like 144.16.192.53 this may be the ip address of a particular machine in the network layer it is not possible to handle all the machines individually because that will make the problem really big so as our first step in our reduction or scaling it  actually in the remote routers we do not usually keep track of the specific ip addresses of specific machines we just keep track of how to go to that network which contains this ip address so the ip address usually has two parts  the leading part that is the first few bits or bytes is a address of the network whereas the last few bits or bytes may be reserved for a particular machine within that network this is how a global ip addressing scheme is this is not as neat as in telephone numbering which exactly tells you the particular state  area  leca and the particular exchange finally so it is not that neat but at least the first few bits or bytes will be associated with all the ip addresses in a particular network if you just take that prefix part you know that it precisely means that particular network and no other network will have the same exact prefix the network addresses have to be globally unique because now-a-days our network is really span the entire globe therefore this is called as the network prefix of an ip destination address and this must correspond to a unique data link layer network but the reverse need not be true which means one data link layer network may have two different network prefixes  refer slide time  27  14  27  37 min  so routers and hosts that have a common network prefix must be able to exchange ip datagrams using a data link layer protocol such as ethernet  ppp etc every data link layer network must be connected to at least one other data link layer network via a router  refer slide time  27  38 -28  08 min  each router and host keeps a routing table which tells the router how to process an outgoing packet the main columns as we have already seen are  1  the destination addresses  i.e where is the ip data gram going to   2  next hop  or how to send the ip datagram and  3  interface or what is the output port next hop and interface columns can often be summarized as one column and routing tables are set so that the datagram gets closer to it is destination  refer slide time  28  09 -29  39 min  this is another example of a routing table ip datagrams can be directly delivered which means these are in the local network therefore they go through the interface called ethernet zero whereas these addresses are outside so this one had to go through a router or to a point-to-point link or this can be some other network altogether now the prefix has distinctly changed for example  10.1.0.0/24 means any number from 0 to 24 can be there so  for all these ip addresses  you just deliver the datagrams directly similarly 10.1.0.2 is also connected directly which means they are all in the same network and then there is a point-to-point connection through a serial link on this router which is also may be very closely connected to the same set of networks there may be other networks out in the wan which really starts from 20 so  for those networks you again have to go to the router and go out through some port of that router  refer slide time  29  40 -30  22 min  if you take a more global view these different routers will be having routing tables we know the details of these routing tables and what they contain and this is how one particular ip packet which originates here will go to a router then to a next router and then to another router and so on  refer slide time  30  23 -33  41 min  processing of an ip datagram at the router  first we have to receive an ip datagram then ip header validation the ip protocol is a network layer protocol previously we discussed about a lot of data link layer protocols but now we are talking about ip protocols and for these ip protocols once again you require some information to be exchanged between peers this information will be in the header called the ip header because in the network layer we are mainly concerned with ip so it is the ip header in any case the ip header has to be validated if there are some options in the ip header they have to be processed the destination ip address is parsed from this header then we do a routing table look up and we decrement ttl i.e we decrement time to leave here is a common example in this distributed fashion we are trying to capture a good and consistent and correct picture of the entire global connectivity which gives you the best connection but in practice this may not always be possible because the global picture may change from time to time so  to get the entire global picture in a very correct fashion is not possible sometimes you may have inconsistent routing table entries and that may lead to various things such that it may lead to a loop in the routing table the loop may not be in one routing table but if you take several routing tables together then you can see that the packet will go in a loop once a packet starts going in a loop it will continue in that loop because each time it comes to the router the router will see its own routing table locally and send it to the next one which was hopefully in a correct path but actually now it is in the vicious ring so this packet will just go on circulating ad infinitum to stop this we put some kind of restriction on the number of hops a packet will take may be 30 each time an intermediate router forwards a packet it will decrement this time to leave that is from 30 to 29 and from 29 to 28 and so on after 30 hops whichever router finds a packet with a ttl zero will simply drop the packet either that packet is going in a loop or the packets have gone very astray because of mistaken entries in the routing table and so on  refer slide time  33  42 -35  18 min  then perform fragmentation if necessary we will see the details of fragmentation later on fragmentation here is  what you are doing is that you are going from one network to another network to another network and so on all these different networks are on different administrative controls and different domains and they may even have different data link layer technologies some token ring may be connected to some ethernet and there can be all different kinds of networks in between now suppose the source had sent an ip packet which was quite large but inside one particular network it is not possible to handle such a large packet it would be unfortunate if you drop the packet all the time because it will never go through therefore what is done is that this big packet is broken up into small fragments and the fragments are sent later on when you are in a sort of wider area the fragments are again reassembled into a big packet and sent along when it reaches the destination then you calculate the check sum which is of error in connection as we note and transmit to the next hop and send an icmp packet if necessary icmp stands for internet control message protocol the routers may use icmp packets for communicating between each other and sending various messages if necessary we will see one example list now and the rest later  refer slide time  35  19 -35  41 min  when a router or host needs to transmit an ip datagram it performs a routing table lookup so  use the ip destination address as a key to search the routing table the result of the lookup is the ip address of the next hop of the router and/or the name of the network interface  refer slide time  35  42  37  09 min  so we have seen that therefore either you take the network prefix or host ip address or loopback address or the default route loopback address means this is meant for local consumption so it will go back to the same machine so it is coming down from a machine and it contains a loopback address then it goes back to the same machine why would somebody want to send the packet like this ? one process of the packet of the host is sending some packet to another process in the same host and it is using this network operating system part for sending that message default route is very important because you can not keep the network prefix for all possible networks in the world in this table then this table will then become very large so you will have fewer entries for the network prefixes and if your network is something else may be there is a bigger router somewhere that knows about all these networks so there is a router which is likely to know about this particular network prefix which has come so you send it to a default route and on this side you have the ip address or the name of the network interface  refer slide time  37  10  37  26 min  so the destination address is a network address  most entries are network routes for the host route the destination address is an interface address which is used to specify a separate route for certain hosts  refer slide time  37  27  38  09 min  the default route is used when no network or host route matches the router that is listed as the next hop of the default route is the default gateway we are calling it gateway because this is not a packet for a network which is close by this is a packet for some arbitrary distant destination  this is a smaller router that is connected which will send it to the gateway and the gateway will in turn send it to a bigger router to find its final destination  refer slide time  38  10  38  27 min  loopback address  routing table for the loopback address is the particular loopback address which is used in ip which is 127.0.0.1 and this is meant for local consumption the next hop lists and loopback interface as outgoing interface  refer slide time  38  28  40  04 min  to minimize the size of the routing table we use the longest prefix match  i.e we search for the routing table entry that has the longest match with the prefix of the destination ip address it means search for a match on all 32 bits the ip address contains four integers less than 256 i.e four bytes which is actually 32 bits so an ip address in ipv4 address is 32 bit long so first you try to match all the 32 bits with some entry in the table if the 32 bit does not match then you take only 31 bits and check whether they match and you keep on doing it and keep on reducing till you get a match so you have identified the first entry that matches with the longest prefix where such a match is possible the host route loopback entry is a 32 bit prefix match the default route is represented as all zeros which is a zero bit prefix match that means there is a zero entry which will give you the next hop as the gateway because now it has not matched with anything finally this is a zero bit prefix match  refer slide time  40  05  41  14 min  suppose the destination address that has come in is 128.143.71.21 then of course the 128 and 143 parts have matched with this but then here this is zero and this is 71 so this is a much better match here with the one shown in red similarly 128.143.71 is also matching here but the next number is 21 which will match better with this rather than with this range this is where the match will take place and you will send to router r4 the default router at the gateway is shown as r5 so the longest prefix match for this is for 24 bits with entry you can find this out if you actually break up 21 into its binary form and see how many bits are matching but this is matching with the 24 bits etc  so data gram will be sent to r4  refer slide time  41  15  41  32 min  the longest prefix match algorithm permits to aggregate prefixes with identical next hop address to a single entry this contributes to significantly reducing the size of the routing tables for internet routers  refer slide time  41  33  42  31 min  suppose for 20.2.0.0 to 16 i would have gone to router r2 and for 30.1.1.0 to 28 i would have gone to r2 once again now we see that the next hop is the same and what we can do is  instead of 20 and 30 if we make the entry as 20.0.0.0/8 and put it as r2 then because of longest prefix match then whenever something also comes in this range it will have a longest prefix match with this rather than with this because this is taken over here and 30 is naturally closer to 20 so instead of two entries we keep only one entry in the routing table which helps in reducing the size of the routing table  refer slide time  42  32  42  56 min  how do routing tables get updated ? one way is to add an interface and then configure the same so it adds a routing table entry this is manual configuration we can also add a default gateway that means for the destination that is the default route we can add a gateway this is once again a manual updating  refer slide time  42  57  43  32 min  so it is the static configuration of network routes or host routes if some particular route is forced then i might put in a static configuration of what they are routing tables also get updated through routing protocols there may be icmp messages from some router which may update the routing tables so these are the different ways in which a routing table may get updated  refer slide time  43  33  44  31 min  for example  for this icmp when a router detects that an ip datagram should have gone to a different router the router  here r2  forwards the ip datagram to the correct router and sends an icmp redirect message to the host the host uses the icmp message to update its routing table what is happening is that one particular host had sent the ip datagram to one router now this router sees that it need not get it from this host and that host should have sent it to that router this router will now send it to the that router anyway and send an icmp message to this host saying that from next time onwards when you have got this destination please send it to that particular router rather than sending it to this destination this is one example of how icmp may be used these are the different kinds of icmp messages  refer slide time  44  32  45  46 min  the other thing is  icmp router solicitation and icmp router advertisement when a router is switched on for the first time how will other routers know that this router has come up ? since the other routers do not know about the existence of the new router which has come up it is was not sending any message to it so  after bootstrapping a router broadcasts an icmp router solicitation it sends an icmp and advertises itself and solicits icmp messages from the neighboring routers in response the router sends an icmp router advertisement message also  routers periodically broadcast icmp router advertisement this is sometimes called router discovery protocol this has to be done periodically because some router may have gone dead in the meanwhile therefore by doing things periodically you try to keep it as current as possible  refer slide time  45  47  46  28 min  we can look at routing as some kind of a graph theory problem where  a  the nodes are the routers of a single administrative domain or different networks   b  the edges are interconnection links   c  link costs are related to physical distance  capacity  delay  etc and  d  the objective is to determine minimum cost path you can formulate it as a graph theory problem and this particular graph theory problem can be handled in different ways we will see two different ways later on  refer slide time  46  29  46  41 min  the problem has some constraints  one is to solve the minimum cost path problem in a distributed manner rather than centralized manner and constraint two is to react quickly and robustly to topology changes  refer slide time  46  42  47  26 min  there are routing protocol requirements one is to minimize routing table space  i.e with all these millions of networks working at the same time minimizing the routing table space is always very important this makes the routers smaller or cheaper or faster  minimizing or controlling messages is also important routers should be robust and not misroute packets loops and oscillations must also be avoided finally optimal paths must be used all these are different routing requirements it is not that we can get 100 % of the requirements all the time but we try to do it as best as we can  refer slide time  47  27  48  40 min  now we will quickly go through the different approaches to routing one is the centralized versus distributed approach in centralized routing one central processor collects information about the status of each link  computes the routing table for each node and distributes it this is possible only in a small number of cases and not all the time and obviously it is not possible over the entire internet because there is no such centralized routing that would handle the scale in distributed routing  routers cooperate to run a distributed protocol to create mutually consistent routing tables in distributed routing also there may be two approaches one is that you distribute the local information only and then globally try to come to a solution the other is that you distribute the information globally and then locally you simply route some kind of a centralized algorithm to know because you have now got the global picture in each of the places  refer slide time  48  41  49  53 min  routing may be source based or versus hop by hop in source based routing the packet header contains the entire route if a link or a router along the path goes down a source routed packet will not reach the destination because the route has been fixed by the source the intermediate routers do not do anything if the next hop is available it will send the packet otherwise it will drop it in hop by hop routing the packet contains only the destination address and each router will consult its own routing table and find out what is the next hop and then choose that next hop but in the source routing the route is fixed from the beginning loose source route is something in between  it is an intermediate solution in loose source route what is done is that instead of specifying the entire path you specify some sort of islands in between that means you go from one router to the next through several hops then again several hops and so on so this is something intermediate between strict source routing and pure hop by hop routing  refer slide time  49  54  52  47 min  routing may be stochastic or deterministic in stochastic routing each router maintains more than one next hop for each possible destination one of these is randomly chosen so the idea is to distribute the load evenly along the links on the other hand packets may get out of order because of this it is because the packets from the same source travels to the same destination and the first packet may be stochastically chosen to go through this path and another may be stochastically chosen to go through this path the probability of choosing either this path or that path can be based on some metric like the delay but in the end the packets may reach out of order please remember  the service the network layer is providing is just to send the packet from one end to the other part of the network here this part has been said explicitly but it is also important to understand what has not been said it has not been said that this service is going to be very reliable which means that in the interim some router may drop a packet so your packet may not reach the destination at all so reliability is not guaranteed another thing that has not been said is that all the packets you sent from destination a to b will reach the other end in the same order in which they were sent the first packet may reach later than the second packet because may be it came through two different paths or may be due to some other reason once again there is no explicit guarantee regarding the ordering of the packets obviously towards the end application this may not work at all in many cases so in such cases where this is very important you have to take precaution against this or you have to put in some corrections for this at some other layer and the network layer is not doing this this was the idea for breaking it up into layers in the first place in the physical layer it is the physical sending and in the data link layer sending is from one to one hop only and makes it as reliable as possible through checksum etc in the network layer it is just reaching the other end of the network layer through several hops now if you want to do it reliably you have to go up one level more and then try to do something there we will see how it is done  refer slide time  52  48  53  16 min  single versus multiple paths  each router maintains one primary and some alternate paths single path routing is used in internet to reduce routing table size multiple paths such as stochastic etc are not usually used in these routers in the internet because the routing table size is at a premium multiple paths are used by telephone networks as routes can easily be deciphered from the address such as telephone numbers  refer slide time  53  17  53  33 min  next is state dependent versus state independent routing state independent or static routing pre-computes the routes ignoring the network state and state dependent or dynamic routing uses the current measured network state  like loading or health of a link  to determine the current route which may change as the packet is proceeding it requires more overhead but can usually find better routes  refer slide time  53  34  53  42 min  in static routing  the next state entry does not change in response to changes in network traffic or topology in dynamic routing it does change  refer slide time  53  43  54  08 min  routing in the telephone exchange of course is very simple as we have already seen under the same exchange there is no routing and under the same short distance charging area  sdca  a central switch sets up the connection with the destination exchange for trunk calls the central switch forwards the setup request to the trunk exchange  tax  and maintains a primary and alternate path to a long distance charging area  ldca    refer slide time  54  09  54  20 min  the possible goals of routing algorithm may be to minimize average end-to-end packet delay  which is desirable from the viewpoint of network user   to maximize throughput  which is desirable from viewpoint of network operator  and to minimize average number of hops  which tends to give both low delay and high throughput  refer slide time  54  21  55  49 min  another way we do routing route is by flooding this is some kind of broadcast  so if a router wants to flood something it will send the same message to all the routers which are connected that may be a very nice and fast way of reaching somewhere because when you are flooding very soon this message will get replicated at each node and everything is running perfectly and in a synchronous manner it will reach the destination using the shortest possible route the only problem is that not one copy will reach but multiple copies will reach using different paths and then other copies will never get anywhere but they will sort of choke other parts of the networks so these overheads are there still flooding is used in some special cases this is one reason we use flooding and the other reason is that when we actually want to broadcast this to everybody then one good thing to do is to flood it every incoming packet is sent out through every outgoing line except the one it arrived on a hop count or keeping track of previously flooded packets may be used to avoid generating infinite number of packets flooding gives the shortest route and is very robust but hardly practical otherwise but in many situations they are also practical  refer slide time  55  50  56  06 min  flow based routing is a static algorithm that uses both topology and load for routing the traffic matrix and the line capacity matrix and a routing algorithm is assumed to be given the mean delay time for the entire network is calculated from this different routes from different algorithms  or all possible routes  can be evaluated  refer slide time  56  07  56  20 min  we will come to that later on when we do mpls given a particular set of routing entries  the net average traffic in each link is calculated so you can try to do some traffic optimization through this  refer slide time  56  21  56  33 min  then we have multi path routing at the router  for a given packet with particular final destination several choices for next router are enumerated  and then the actual path is chosen in some fashion  refer slide time  56  34  56  42 min  multi path routing may yield more stable traffic  refer slide time  56  43  56  46 min  alternative routes are also similarly determined  refer slide time  56  47  56  53 min  we have already talked about dynamic routing versus centralized routing  refer slide time  56  54  56  58 min  it has its own disadvantages meaning it lacks some fault tolerance if routing computer goes down  refer slide time  56  59  57  23 min  distributed routing is the most usually used it may use some distributed algorithm like distributed bellman-ford or it may use some centralized algorithm with distributed global data we will look at distributed routing in more detail in the next couple of lectures computer networks prof sujay ghosh department of computer science and engineering iit kharagpur lecture name # 22 cellular networks  refer slide time  0  55  good day so  now we will start our discussion on terrestrial wireless networks we have already seen one kind of wireless communication  which is through satellites so it is microwave repeater and we know that but there are two very important and rapidly expanding field in networking  which is terrestrial wireless networking we will have two lectures on this in the first lecture  we will discuss cellular networks the cell phone  which has become ubiquitous nowadays and in the next lecture  we will talk about wireless lans  wireless lans are may be little bit of wireless mans also so  today we will discuss about cellular networks  refer slide time  01  49-04  29  so just right away  let us learn some jargons what is a cell ? the cellular network is organized in the form of some cells and it covers a geographical region it has base station analogous to 802.11 ap ap is for access point 802.11 is the wireless lan technology we will discuss about this in the next lecture anyway  the point is that there is a base station and it will have an antenna  some transmitters and receivers it will be connected to the backbone through a line may be this could also be a wireless line  but usually this could be a fibre optic line in a circluar geographical location around this base station  mobiles will communicate with this base station and through this base station to the rest of the network so mobile users attach to network through bs and air interface is the physical and link layer protocol between mobile and bs that is called air interface between the mobile and base station now all these base stations are connected to the mobile switching center  msc   the switching is essentially done over here the msc connects cells to wide area network the mobile switching center will be referred to as msc  base station as bs ,mobile switching center as msc  ms  by the way  is a mobile station msc connects cells to wide area network and manages call setup more about that later and these mscs will be connected to each other for a particular service provider they will also connect to public telephone network and the internet etc so one service provider  their network would be connected to another service provider ? s network so somebody from this network can call the other network and so on so we have the cells ; we have the base stations ; we have the mobile stations or mss we have the mobile switching center  msc  and of course the pstn at the back of it all this part is usually wired  refer slide time  04  30 06  20  the first hop ? we are now talking about the air interface between the mobile station and the base station there are two techniques for sharing mobile to bs radio spectrum there is certain radio spectrum  which is allocated to the base station and to the particular region that it has to be shared now  this is a question of multiple access and two techniques that we talked about earlier are fdma  if you remember this is frequency division multiple access  and tdma  time division multiple access in cellular technology  what we usually do is that we combine fdma and tdma so divide the spectrum in frequency channels and divide each channel into time slots if you say that these are the different frequency channels and each channel may be divided into number of time slots we will do fdma as well as tdma on this that is one kind of scheme ? the so-called gsm utilizes this we will be talking about how fdma and tdma are combined the other technology is cdma  which was designed by a company called volcom in usa  which uses code division multiple access we have already seen what code division multiple access is so we will not get into the details of cdma systems here cdma is another popular way of transporting data to the mobile devices both gsm and cdma are used in many countries for example  in our country also some service providers provide cdma services  and few offer gsm services  some provide both  and so on  refer slide time  06  24-07  19  we will now discuss cellular standards as they stand today historically  we had only the cellular system that came from some amps in usa previously  there was only one cell from the analog system from analog system  it came down to digital system in deamps and then we have these two systems of the 2g system ? one is the gsm system and the other is the cdma version 2g systems are voice channels  is-136 is tdma  combined with fdma  which is used in north america gsm  which is more popular of these schemes  is the global system for mobile communications it has combined fdma/tdma  which is most widely deployed is -95 is the code for cdma systems  which use code division multiple access so these are the 2g or second generation systems  refer slide time  07  20-08  23  there are 2.5g systems these were introduced because the 3g was promised quite some time back but the service providers really could not deliver it or crank it up to that extent but  there was lot of demand for it voice was alright with 2g  but then the demand for data and other kind of multimedia services etc  was increasing so people had to be given some data services instead of going all the way to 3g  people went to 2.5g 2.5g systems have both voice and data channels so  for those who can not wait for 3g services  there are 2g extensions one is gprs this is general packet radio services evolved from gsm and the data is sent on multiple channels if available it has an enhanced data rate for global evolution edge ; also evolved from gsm using enhanced modulation data rates up to 384k  refer slide time  08  24-09  11  cdma has its own version called cdma 2000  that was phase 1 ; then there was phase 2 also so data rates up to 144k evolved from is-95  which is the cdma system 3g system includes both voice and data  one service it provides is umts this is the name of the standard universal mobile telecommunications service  umts   gsm is the next step  but using cdma 2000 so  all these merge into the 3g systems how exactly this merging will take place and how it will actually be deployed and become popular remains to be seen ; but today you can get these data services on your cell phones  etc  refer slide time  09  12-09  46  the protocol layering for cells is a little different we will not go too much in to this one is of course  the physical layer  which has to do with the physical channels then there is mac  medium access control we will talk about it  at least for gsm so  there are these logical channels  transport channels  and then there is radio resource control layer that is the layer 3 particularly this you might say is a protocol  but this does not go all the way that the osi 7 layer this is just for the cellular systems  refer slide time  09  47-12  04  our idea is that we have some base stations and each base station will cover some geographical area like it has been shown here different bs would be connected through a backbone network or through mscs we are trying to get the basic idea of the cell the point is that  nowadays cell phones have become very popular its rate of penetration is much faster than the original telephones  and it is much faster than pcs also so  cellular phones have become very popular  which means a lot of people want to use it and lot of people have cell phones many of them would want to talk at the same time but how do you accommodate all these people talking at the same time ? we do multiple access but then  there is a limit to what you can do using same frequency spectrum the idea was to do some kind of space division multiple access in the sense that within one particular geographical area  we use a particular frequency band and then in another geographical area  which is far removed from there  so that these two do not interfere with each other  we use the same set of frequency band at the same time for a different set of users the point is that these powers have to be controlled because  if they are very powerful  they will start interfering with each other but if this power is controlled  then within that cell  that power is enough but  it is not enough to interfere with each other so  two different groups of users can use the same frequency band at the same time this is the basic idea of breaking up a region into cells so that you can increase the number of people  who would be using this system that is the basic concept of a cell  refer slide time  12  06-13  03  in practice  cells are may be of arbitrary shape but they will be close to a circle because usually the kind of antenna used in base stations is omni directional antenna  in the sense that it gives the same power on all sides it has the same sensitivity on all sides if that is so  the area of influence would be a circle but when many circles are put together they are pulling and they will intersect with each other to solve this problem  we can use a tessellation there are only three types of tessellations  which are possible ? equilateral triangles  squares or regular hexagons out of these three  the regular hexagon is the closest to a circle that is why usually the regular hexagons are used to represent a cellular structure a hexagonal cell  the closest approximation to a circle  is used traditionally for system design  refer slide time  13  04-14  27  this is how a big geographical area may have been divided into a large number of cells ? it looks like a beehive if you notice carefully some of the cells are dark and these cells are marked as a b c d e f g so  these are seven there are seven hexagons like this and these are actually different frequency ranges these frequencies are again reused for example  you have another a b c d e f g over here this b and this b ? although they use the same frequency ranges ? are far apart so  different groups of people can use it at the same once it gets into the base station  we usually take it to the fiber optic domain  where a large number of calls  simultaneous calls can be handled this really shows you the frequency reuse a  the set of frequency bands  which are associated with a  will also be reused here  here  and there and so on that is how a hexagonal cellular structure is constructed and we do this frequency reuse  refer slide time  14  28-14  54  co-channel reuse ratio is given by dl/rl = ? 3n  where dl is the distance between co-channel cells  that means those who share the same channel rl is cell radius ; n is the cluster size the number of cells in a cluster n determines the amount of co-channel interference and the number of frequency channels available per cell this really comes from geometry  refer slide time  14  55-16  29  when the number of subscribers in a given area increases  allocation of more channels covered by that cell is necessary what happens is that in one area  say a small town  one base station could satisfy people  who had these cellular phones or mobile phones now what happens is that  the number of people who wanted to use mobile phones kept on increasing and now we can not serve them any longer the number of requests  which are denied  keeps on increasing how can we increase ? may be break it up into two cells and then break it up into four cells and break it up into many more cells  depending on the clusters of users and the cells now  the same area has been divided into smaller cells may be in the bs  you decrease the transmitter power so that they do not interfere with each other so when the number of subscribers in a given area increases  allocation of more channels covered by that cell is necessary this is done by cell splitting a single small cell midway between two co-channel cells may be introduced  refer slide time  16  30-16  53  these are the small adhoc solutions to the problem for example over here  you had a large number of cells we created a small cell over here using a  which uses the same frequency bands as the already existing ones you can not use e  f  c  or b but you can use a with other cells so that is called cell splitting these are ad hoc solutions  when a particular area has more number of users  refer slide time  16  54-17  14  we now have a cellular hierarchy  the needs of which are  extending the coverage to the areas that are difficult to cover by a large cell ; increasing the capacity of the network for those areas that have a high density of users ; increasing the number of wireless devices and the communication between them  refer slide time  17  15 18  04  so  you have a large number of cellular hierarchies one set of them are called femto cells these are the smallest unit in the hierarchy so these cells need to cover only a few meters  where all devices are in the physical range of the users this is also called personal area networking so i have something in my left pocket  something in my right pocket and something in my hand these might communicate with each other so  that is personal area networking femtocells are small cells then we have picocells  the size of their network is in the range of a few tens of meters so  you can think of a small building as picocell for example  wlan  wireless lan    refer slide time  18  05-18  34  micro cells cover a range of hundreds of meters ; for example  in urban areas to support pcs or other technologies pcs is another kind of mobile technology macro cells cover areas in the order of several kilometers  for example  a metropolitan area  or may be a small town mega cells cover nationwide areas so  mega cells possibly are being serviced by a satellite  refer slide time  18  35-19  04  this is the picture of satellite  which may service a mega cell then  we have macro cell from this tower then we have pico cells  which have some access points etc inside a building and so on microcells for covering communication so these ways of different kinds of technologies may be deployed for these different ranges of cells  refer slide time  19  05-19  32  frequency reuse  we have already talked about this radio spectrum is one of the scarcest resources available ; because  there is so much demand for it for so many applications so  employ architectures that can support as many uses as possible  theoretically  with the available spectrum same spectrum can support multiple users separated by a distance and thus efficiently be using the spectrum  refer slide time  19  33-20  46  frequency reuse has its foundations in the attenuation of the signal strength of em waves with distance so  if two points are at a distance from each other  this signal gets attenuated and does not interfere significantly with this one  although they are using the same frequency band usually  what will happen is that the service provider will be given some band of frequencies now  he has to use that and can not stray from there  as that is the license agreement so  what he will do is that  is depending on where his users are  and what the distribution is  what the density is like  he has to develop or plan a cellular infrastructure in this fashion using and reusing this frequency  the same frequency band  here and there to give the maximum amount of service the distance separating the transmitters of this frequency reuse should be sufficiently large of course  this has to do with a transmitter ? s power transmit power should be reasonably small the cellular concept is an intelligent means of employing frequency reuse  refer slide time  20  41-21  21  so what we have been talking about is something like a fixed channel allocation that means for a particular cell  the channels  that means  the frequency band associated with the cell is fixed so  total number of channels is nc = w/b  where w is the bandwidth of the available for spectrum b is the bandwidth needed by each channel the total number of channels per cell is cc = nc/n  where n is the cluster size  refer slide time  21  22-21  53  adjacent radio frequency bands are assigned to different cells as shown in analog each channel corresponds to one user while in digital each rf channel carries several time slots or codes so  you are doing either tdma or cdma so  if you are doing this  the naturally fdma tdma combine or cdma uses spread spectrum technology so  it ? s simple to implement so  fixed channel allocation is simple to implement if traffic is uniform  refer slide time  21  54-23  24  but then  sometimes traffics are not uniform ? there may be two cells  which are side by side so  this has been given one band one has been given another band of frequencies they do not interfere with each other but  we find for each cell let us say  to start with  we are given with equal bandwidth to each of the cells now  i find that in one particular cell  the user density is much higher  whereas in adjacent cell  the user density is lower so  i could use some more bandwidth in this cell and i could do with a little less bandwidth here so  what could do is that  a part of this frequency band can borrow from the adjacent cell so  that is called channel borrowing technique high traffic cells borrows channel frequencies from low traffic cells temporary channel borrowing and static channel borrowing this could be a permanent feature or this could be the feature of a day for example  in the central business district  it might become very busy during the day time so  it may borrow channels from the side  whereas after the evening the use may fall drastically in that case  one cell can give out channels to others not only sort of giving channels to other people so  this could be static as well as it could be temporary  refer slide time  23  25-26  26  this is suitably complex picture of gsm  i.e the global system for mobile communications so  this just to show you how these tdma and fdma are combined so  you see there are 124 simplex channels in the gsm system now  each of the simplex channels actually carries a series of tdma frames and each of the frames is divided into 8 parts  that is how a large number of channels can be given there are two parts  one is the uplinking and another is the downlinking  that means  from bs to ms ? base station to the mobile station or from the mobile station to the base station so you have two different frequency bands for these ? one band for this bs to ms communication and another band for ms to bs communication in each band  there are a number of frequency channels and each frequency channel is again divided into so many slots  eight slots for simultaneous communication so this one and this one are same channels  but this and this are two different channels for a particular mobile station so from base station  it may be using this particular time slot in this particular channel  that is  from the base station to the mobile station the same one  from the mobile station to the base station  will be using another channel and actually another time slot  because there is some technical problem in giving the same time slot in this channel as well as the other channel so  you give it a different time slot over here so  in this particular time slot of this particular channel  the mobile station is communicating with its base station so  that is how it goes gsm uses 124 frequency channels  each of which uses an 8-slot tdm system and there is a frequency band at which it operates ; this is also fixed this is in the 959.8 mhz range you need not remember these figures  but this is the general scheme of the way tdma and fdma are combined together  refer slide time  26  27-27  15  suppose this is s1  t  and this is the signal which comes from source 1 and this is the signal from source n  sn  t   this is some other source what is happening is that in the tm slots  the first slot ? s1 ? gets the first slot and sn gets the nth slot so  they are pushed into this in the same frequency band  and as time progresses  they function just like in a tdma system so  this is the tdma part so  gsm = fdma 200 khz ; that is the gsm system  refer slide time  27  16 27  46  this is a portion of the gsm framing structure so  how they are framed ? actually  this is a somewhat complicated scheme some of these frames are used for control purpose and others for communication  one group for base to mobile and other from mobile to base  etc so  there is a scheme for this we will not go into the details of this  refer slide time  27  47-28  17  a gsm system has 124 pairs of simplex channels they are in pairs because one goes from bs to ms and the other from bs to ms each of these is 200 kilo hertz wide and supports 8 separate connections on it  using tdm so  each active station is assigned to one time slot on one channel pair 992 channels can be supported in each cell  but many of them are not available to avoid frequency conflicts with neighboring cells  refer slide time  28  18-30  16  transmitting and receiving does not happen in the same time slot because the gsm radios can not transmit and receive at the same time and it takes time to switch from one to another that is why different time slots are given a data frame is transmitted in 547 microseconds  but a transmitter is only allowed to send one data frame every 4.615 milliseconds  since it is sharing the channel with seven other stations the gross rate of each channel is about 270 or about 271 kbps divided among eight users this gives about 33 or 34 kbps gross cc i.e  control channels are used to manage the system if somebody is getting only 33 or 34 kbps previously  we have been talking about voice channel requiring 64 kbps now  the 64 kbps happens to be if you are doing a plain vanilla pcm that means we have explained  how it is encoded by sampling it at eight samples and eight levels for each sample ? that gives us 64 kbps the point is that  it is not the only coding scheme actually  there are more advanced coding schemes we did not find time to discuss those coding schemes using those coding schemes  good quality voice transmission can be achieved  using a much lower bandwidth this 33.854 kbps is actually enough  if you are doing your coding in a smart fashion  refer slide time  30  17-32  19  as i said  apart from the user channels  there are some control channels cc is used to manage the system the broadcast control channel  bcc  is a continuous stream of output from the base station containing the bs ? s identity and the channel status all mobile stations monitor their signal strength to see when they moved into a new cell the point is that the mobile station  when it gets these broadcasts from bs  by just sensing how much transmitter power it is getting  it can identify whether it is near this particular bcc  what this particular bs is  or what its identity is  or whether it is near some other bs in some systems like cdma  this power is very crucial even for decoding purposes that is one thing which is being broadcast and to listened by all the ms the dedicated control channel is used for location updating  registration  and call setup ; in particular  each bs maintains a database of mobile stations  which are in its area so  information needed to maintain this database is sent on the dedicated control channel so  the point is that these mobile stations are moving they move from one cell to another  from the vicinity of one base station to the vicinity of another base station so  the set of ms  which are now currently under this  that information in some schemes is collected on the side from time to time and there is a database  which is associated with the bs this is centrally communicated that is important for locating a person we come to that later on  refer slide time  32  20-33  33  and then there is a common control channel which has got three logical sub channels that is the paging sub channel  paging channel  in which the bs uses to announce incoming calls each ms monitors it continuously to watch for the call it should answer the point is that  if there is a call  and ms is in the area of some bs and then somebody wants to call to this ms  that one particular ms has to be alerted so  there is a paging for that ms from the bs and the ms is always listening to it so  whenever it hears the page for itself  it gets alerted so  the other is the random access channel this allows users to request a slot on the dedicated control channel if two requests collide  they are garbled and have to be retried later on so  this is the part of the call set-up so  it is the first part of call set-up it tries to put a request in the random access channel for a slot in the dedicated control channel when it gets a slot in the dedicated control channel  it can go away with the further steps of call set-up next is the access grant channel  refer slide time  33  34-33  51  in gsm the channel multiplexing is fdm + with eight tdm slots uplink is this much and channel bandwidth is200 khz so  dcs has certain frequency range etc  refer slide time  33  52-34  03  channels are broadcast and the channel rate is 13 kbps  refer slide time  34  04-34  42  we have already seen what cdma is ? it is based on ds spread spectrum  that is  the direct sequence spread spectrum it has two frequency bands  one for forward channel and one for reverse channel and one frequency band  a wide band actually that is shared that means it uses orthogonal codes by a number of handsets or number of mobile stations so  cdma allows use of same spectrum over all cells it also gives net capacity improvement although which system is better ? cdma or gsm ? is still not clear  refer slide time  34  43-35  40  there are certain issues in the cellular infrastructure  which have to be handled we will quickly discuss each of them the most important one is handoff because you may be talking on your mobile phone while moving  may be moving in a car so  what will happen is that  the car eventually will pass out of the range of one base station and move in to the range of another base station so  you have to hand off that means previously all communication from this mobile station was being handled by this particular base station  as it moves in to the area of another base station  this call has to be handed off from one bs to the other bs handoff changes of radio connection from one base station to another will happen but this not such a simple scheme and we will see why there are two types of handoff  hard handoff and soft handoff  refer slide time  35  41-36  33  this handoff has to be managed in order to manage the handoff  we have to detect that handoff requirement has arisen because the mobile station has moved and then you have to execute the handoff  in the sense that you have to do the channel assignment and you may have to do some path rerouting and there may be problems in this section also for example  when you move into a new cell  all the channels over there may be busy and so you may not have any extra channel  which has to be given to this ongoing call so  there are various schemes for handling ? may be you drop this that is the simplest thing to do  that you do not allow it or maybe you keep some guard channels specifically for these kinds of cases but this detection of handoff requirement is a troublesome affair  refer slide time  36  34-37  04  as i said  there are two types of handoff  hard handoff and soft handoff hard handoff is break before make this is used in gsm system ? that means you break this connection and set up the new connection with the bs in whose area you are moving ms connects to base station 2 after link with base station 1 breaks  and this is the region where the handoff will take place  refer slide time  37  05-37  57  the difficulties in handoff detection are the following the signal strength fluctuates this is a very challenging area of mobile system design ? the signal area fluctuates due to various reasons  scattering  reflection and diffraction results in fading there are fast fading and slow fading of the receiving signal there are false handoff requirements at the boundary ; there is a ping pong effect at the boundary that means what might happen is that it may hand off from bs 1 to bs 2  then again from bs 2 to bs 1  again from bs 1to bs 2 this kind of ping pong might be going on so  the number of unnecessary handoffs must be reduced because handoffs have a price paid  actually  keeping both channels busy on both sides there are other kinds of overheads to this  refer slide time  37  59-38  41  let us look at a very simple model actually the situation is much more complex because  there are number of base stations ? maybe three base stations and you may be equidistant from all the three at a particular point so  you may have an even more difficult problem but let us look at a simple problem suppose d is the distance between two base stations so  ideally we would like that the signal strength from bs1 is following like this and the signal strength from bs2 is going like this as you move from bs1 to bs2  as the ms is moving at the cell boundary  it just switches from bs1 to bs2 but the actual picture is something like this  refer slide time  38  42-39  44  this is the point is that the signal strength from bs1 is varying  very fast why does it vary ? i will just tell you i had just mentioned it  but i will tell it again this is varying like this the signal strength from bs2 is also varying like this so this has been plotted from  let us say  800 to 1200 region so  there is a solid region at least from 950 to 1050 there is a region of 100 m  where you really do not know who is stronger so the signal is varying all the time what might happen is that you might now decide to move from bs1 to bs2  and then you find that bs1 has become much stronger and bs2 has become much weaker so  it might switch from bs2 to bs1 and this might go on as a ping pong effect so  this is a very difficult problem  refer slide time  39  45 -41  03  and as i said  why is it that it varies in this fashion ? there are various reasons for this  one is that you are moving this mobile station is actually moving now whatever signal it gets  it may get some direct signal  it may get some reflected signal  it may get some scattered signal and all these signals may start interfering with each other so  actually what might happen is what is called multipath fading that means  the same signal may have arrived from source to destination through two different paths ? may be through two reflections ? and they may be out of phase because of the different distances  which may be allowed if they are precisely out of say  180 ? out of phase  then you are going to have distractive interference or they may be in phase ; they may strengthen each other so  in a very short span of time  as the mobile is moving  you may find a very largely fluctuating signal there are other reasons for this fading etc we will not go into the detail of this  refer slide time  41  04-42  21  so  there is a problem of handoff so  for the handoff decision there is various algorithms which have been proposed i will just mention them one is relative signal strength  which is the simplest first thing you will think that whichever is weaker  we leave that  and whichever is stronger it will chose that one so  choose bs2 if signal from bs2 is greater than the signal from bs 1 but as we saw  with just this  there may be lot of ping pong effect and lot of unnecessary handoffs you can use this same rss  that is  received signal strength  and some threshold base that means we choose bs2 if the signal from bs2 is greater than the signal from bs1 and the signal from bs1 is less than a threshold  which means that although bs2 is stronger  if bs1 is above the threshold  which is still working  then we do not do a handoff another thing is rss plus hysteresis  that is  received signal strength just being greater is not enough ; it has to be greater by a certain amount of hysteresis the hysteresis means base1 persists as the bs2 is becoming stronger in base 1 and then there are other kinds of other combinations people have tried for getting a good handoff decision  refer slide time  42  22-42  50  as i said  this hard handoff is used in gsm  whereas in cdma system  they use soft handoff this is ? make before break ? ? that means you make a connection to that coming in the next base station  before you release the connection with the previous base station so  ms connects to bs2 before connection to bs1 breaks this is called soft handoff  refer slide time  42  51-43  14  we will now discuss the merits and demerits of soft handoff merits are  mobile station does not loose contact during handoff ; the effects of ping pong are reduced ; and it is easy to implement for cdma systems the demerits are  it is a complex process so  hardware requirement is more and that means your hardware cost may also go up ; and it utilizes extra resource during handoff  refer slide time  43  16-44  22   43  16  now  we come to the question of mobility management how do you manage mobility in a local in a ms ? that is because  one of the very fascinating thing about mobile connection i have called somebody on the mobile  who i assumed is just local that is who is in the same area as i am it just so happens  that he is in a place far away he is visiting some place may be rajasthan or something ,as he is very far away now i will expect that the system would somehow locate him in rajasthan and then allow me to talk to him so  that is again a non trivial problem there are various approaches to this problem we will just once again touch on this so  this is called mobility management one is location management access point of a mobile station changes as it moves around the network coverage area and important for effective delivery of incoming cells and other is handoff management we have already talked about it  refer slide time  44  23-45  21  now  for location management  one approach through location updates that means messages are sent by ms that is a mobile station regarding its changing points of access to the fixed network so  that is to the fixed network  that is sort of time of time it tells that ok this is where some central database is updated each time the ms makes an update to its location a database in the fixed part of the network has to be updated to reflect the new location information so  that for a particular ms  if you go to the data base and find out what is the last point  where he said  that he was of course what he might have done is that he might have switched off his mobile and then moved to somewhere else and then put it on or something  so  put it on again so  that is not still solved all the problem 100 %  but this is one approach to solve it  refer slide time  45  22-46  26  the other this thing is the paging you know what is paging ? paging means that sort of broadcast it well broadcast means broadcast it everywhere we do not want to broadcast it everywhere so  you broadcast it only to certain places so what we do is that  we broadcast that there is a call for such so  that is what we page and if that paging is being done in a cell  where the ms is actually present and that the ms will respond  that is what will happen so  that is another scheme required to deliver an incoming message to the ms response from the paged terminal enables the network to locate the ms the other thing about location management is location information dissemination procedures to store and distribute the location information related to ms are serviced by the network that is the issues over that i am not going detail in any of these  as no time  refer slide time  46  27-48  03  and for the location update  you may do static location update that means initiation of location update is decided by the topology of the network and location area based location updates which is commonly used what a location area is and distance based  which performs location update after crossing certain number of cells or timer based  performs location update after a certain time has elapsed so  the question is that how frequently do you update this ? because  if collecting all the data all the time and just updating it all the time  that will consume an enormous amount of resources you have to optimize somehow that this is the point is that if we not doing frequently enough  your data in the database going to stay and then when you want to actually search for somebody  then you might have to search around a large area ideally what would you liked is that when a call is there for somebody  we know that exactly in that particular cell that mobile station is there so  we go and page over there he responds ok that is the idea but this idea will never work because  you can not keep it updated on all the time and you can not collect and keep all the information so  you have to do some kind of optimization over there  which means that you actually looking for one particular mobile you have to search not in just one cell  but may be in several cells so  that is where location area comes in that location area is collection of cells  we will come to that  refer slide time  48  04 49  02  the other is dynamic location update it uses mobility of the user and call pattern for location update so  if you know the mobility of the user and some call pattern etc  you may be able to predict that where this particular user may be it is more likely that he will be there so  it state-based  performs location update  based on the current state information such as distance travelled  the number of las crossed  etc or user profile based  which is more difficult  not exactly used at the moment maintains a list of las that is location areas that the ms located in at different points of that time usually so  usually during office hours i will be found in my office in that particular area so  that may be known and that may be a guess but then gathering this information and keeping this information for all users  this is not a mean task  refer slide time  49  03-49  58  so,this is the location area based location update so  as you see that a bunch of cells together form a location area so  this is the location area 1 containing 1 2 3 4 5 cells this location area 2 containing 7 cells and so on so  assign a location area identifier to a group of cells la 1  la2 bs broadcasts periodically la identifier so  it is enough to trying to fill a particular cell you are trying to fill it down to a location area so  bs broadcast it  whichever location it is in ms is required to listen for la identifier and make an update to the location if necessary drawback is once again  there may be ping pong effect this fellow is moving like this so  it going from location area 1 to 2,1 to 2 etc that is always the thing you can not eliminate this completely  refer slide time  49  59-50  22  location update in gsm la identity  that is it takes the location based approach identity is used for location updates la consists of a group of cells controlled by bsc and ms performs location update under 3  1  .circumstances upon power up  compares previous la identity with the one currently being broadcast if different  performs update  refer slide time  50  22-50  52   2  when ms crosses la boundary  performs update  3  after a predetermined period of time  performs update to ensure ms is available so that you do all the three things simultaneously so that would make sort of judgment about  what is this time interval  after which it will go automatically or of course  other two are simple  refer slide time  50  53-51  21   and then in for paging schemes  you can do blanket paging  that means when you know the location you just page everything all the cells paging in all cells within an la simultaneously if the la update is current  ms responds immediately advantage is minimum delay in getting paging response and disadvantage is it needs paging in all the cells within la equidistant from the current cells a timer is used to declare the ms is unreachable  refer slide time  51  22-51  39  all it could be that closest cells approach first page the cell where ms was last seen if not successful  page subsequent rings of cells that are so  this is all trying to reduce the overhead and give the maximum response time etc so,all these different schemes are there  refer slide time  51  40-52  52  and finally we will not go in to the details of these as i said that  now everybody want news on their handsets not only news they want to access  to the internet through the handsets  which means we will have to give some data service and that is why service providers also move from  noise  2g to 2.5g systems wherein from the gsm family it,the general packet radio system gprs and cdma to cdma2000 so  gprs is a really ? packet overlay ? network that means on the same network  there is a packet service  which is going on available frequency bands network on top of the existing gsm digital circuit switched voice based network so  it is tcp/ ip based the protocol based is same as the tcp ip which we will learn later it allows data packets to be conveyed across the mobile network using packet switching and it is ? always on ?  ? always connected ? type of thing and after initial ? log-on ?  user is permanently connected to the ip services  that is the gprs  refer slide time  52  54-53  22  instant access  no further log on and usually the rates also gives a flat rate user perceived performance  fluctuates  as gprs users defer to voice users   so  voice users have a preference so  because data may delay that is may be acceptable to a maximum of  noise  50kbps network resources only used when information ready to be exchanged bandwidth on demand so  more utilization of air time that is the gprs  refer slide time  53  23-53  52  so  this provides high speed frequency so  uplink is on the particular frequency band and downlink is on particular frequency band and these are all packet services which provide high speed packet data access this uses modified gsm hardware  different phones or cards  are required that is you have particular kind of set that handle gprs several time slots can be dynamically allocated to transmit a block of data so  if the packet is large  so several time slots may be used for that  refer slide time  53  53-54  25  the uplink channel is shared by a number of mobiles  and its use is allocated by a bsc  base station stream the downlink is of course fully controlled by the serving bsc and random access is not needed in the uplink of course multiple access will still because  so many people want to send the request for data the ms requests use of the channel in ? a packet random access message ?  the bsc allocates an unused channel to the mobile and sends a ? packet access grant message ? etc  refer slide time  54  26-54  49  cdma 2000 is once again is the cdma version of it increasing voice capacity once again this is always on peak packet data rate of 153 kbps which is quite high connectivity to ansi -41and gsm-map  which we need not to bother various bands and bandwidths of operation in support of different operator needs  refer slide time  54  50 55  58  it is expected that actually that  this cdma 2000 1x rtt is backward compatible with cdma1 system  which was the previous original cdma system improved service multiplexing and qos management and variable transmission rates and it is expected that in future what is going to happen is that  as data demand is definitely going to grow  so these will sort of move from these interim 2.5g system to the 3g systems i cdma is already being employed this is part of our big network architecture this converged network architecture  which is slowly emerging and in the next lecture  what we are going to do is that we are going to discuss wireless networking in the lan setup in the sense purely in this  we are talking about voice and voice added to data next  we are going to talk about data and may be data plus wires that is a separate issue thank you computer networks prof s ghosh dept of computer science and engineering i.i.t  kharagpur lecture number ? 28 ip version 4  refer slide time  00  46  good day  we will talk about ip version 4 that is the internet protocol version 4 this internet protocol is really the network protocol of the entire stack and actually is at the heart of data communication as it turned out that it became so successful that also other kinds of communication like voice  video  etc were also coming over to ip in a big way in many segments so today  refer slide time  01  23  01  26  we will talk about the ip version 4 and  refer time slide  01  26  02  50  just a quick review of the stack that ip or the so called internet protocol is designed to connect networks that are possibly managed by multiple organizations or people the internet we see today is a connection of network of networks so it is of various networks and various networks are naturally owned by different organizations of people  managed by different people but if they have to communicate they somehow have to come together and agree to one central network layer protocol and ip is that protocol  it may have different physical connections naturally if there are different networks having different connections it may be connected via sequence of arbitrary intermediaries arbitrary intermediaries mean that when you are communicating from one computer to another these two networks also may not be directly connected they may go through other intermediate networks so there may be number of hops before your communication reaches its destination in the beginning we discussed about layered approach which is used to simplify the application  refer slide time  02  50  03  35 min  this is just an example let us say we have http which is the protocol used in the application layer  it may use a tcp connection tcp is another layer that is called the transport layer tcp communicates with the ip which then may communicate with ethernet but please note that below the ip there may be a multiplicity of different data link layer protocols like ethernet and token ring that communicates because of this integrating protocol ip which is common to both  refer slide time  03  35  03  44  so it is a single protocol at network level that insures packets will get from source to destination while allowing for flexibility  refer slide time  03  44  04  18  we have the hourglass design like ftp  http  tftp etc  are different application layer protocols at the top then we have the transport layer and their two common protocols namely tcp and udp both integrate to one single network layer protocol namely ip and this ip may connect to naturally different networks running different data link layer protocols  refer slide time  04  18  06  30  just to look at the how the encapsulation goes once again  we had discussed this earlier suppose we have the user data being fed to some application then that particular application will have its own header this header information is what is used for protocol between peers at the same layers the application layer of this host will communicate with the application layer of the other host through this application header information and is passed to the transport layer tcp the transport layer protocol which is being used here the tcp header gets added and then it is passed to the network layer when it is coming down and when something is being sent where the ip header gets added at the network layer as far as this ip protocol is concerned this entire thing containing the tcp header  application header  user data etc is the payload similarly  for tcp the application header and user data together is the payload so  whatever is inside the tcp does not really consider this similarly ip considers this entire thing as the payload and then it sends to the next layer which may be ethernet as an example ethernet adds a header as well as the trailer some of the overhead we incur in this  for example  this tcp header is 20 bytes  ip header is 20 bytes  ethernet header is 14 bytes and it has got a 4 byte trailer and then this entire thing is payload for the ethernet which has a minimum of 46 bytes  1500 bytes etc this is how it comes when data is being sent and when data is being received it is in the other way  the first layer will take out these two headers and trailers  then the ip layer will take out the ip header  look at it and pass it up the tcp header and that will get stripped and finally the user data will reach the application layer  refer slide time  06  31  07  38  by looking at it the other way  suppose we have the ethernet driver  this is really the lowest level in the tree that has been shown upwards when something comes to ethernet it has so many protocols in the next layer but these arp is the address resolution protocol which is that given an ip address then finding the mac address  this is the reverse of that as given the mac address finding the ip address ip addresses are used for communication within a same network but otherwise most of the traffic comes to ip above the ip layer this is tcp  udp  igmp used for multicasting and icmp internet control protocol mostly the applications are for control and multicasting functions but the major part of the communication comes through this tcp and udp and they connect to the various applications which may be running at the application layer and this how it is de-multiplexed  refer slide time  07  38  09  51  just to summarize this ipv4 protocol ip is the best effort connectionless protocol that means that the intermediate nodes will try to get your packet to the proper destination as best as possible but if it is not possible it will drop the packet this does not give you any guarantee about the delivery of the packet at the other end but it is understood that all the nodes in between will make its best effort suppose you consider a router which is somewhere in the network now it is receiving packets from so many sources and they are destined to many other different networks it may so happen that because of the pattern of communication the router may get congested so if it is congested as there are so many packets coming in then it can not hold them in its buffer any longer so it is force to drop some packets although it will make the best effort but then this is not a guarantee and then secondly this is connectionless you remember about connection oriented and connectionless protocols ? for example  our telephone network was a connection oriented protocol but here this is connectionless that means from the source to the destination there is no guaranteed physical or virtual connection between the two and if you are sending a stream of packets from one source to the other some of the packets may take one route and then some take another route where all of them will reach their destination but they may get out of order these are all part of the connectionless protocol with a datagram or packet oriented protocol you can get an ip packet from anyone without any setup or connection establishment packets are normally routed using destination routing that means the destination is known and how to get to the destination is what is stored in the routing tables you specify where the packet is to go now and not how it gets there  refer slide time  09  51  10  46  there are some more parts you can optionally specify source routing in internet protocol there is a provision that in the source itself you specify that this is the route through which it should reach the destination for example  if you remember our bgp uses source routing but in general for internet packets it is possible to do the source routing but this is somewhat limited because the number of hops you can specify becomes restricted because of some limitations of ip version 4 protocol structure each packet is routed independently that means they can be delivered out of order or might not be delivered at all  refer slide time  10  46  11  19  now we come to this important topic of ip addresses the ip address is a 32 bit address that is 4 bytes which identifies the network and the host on a given network it is divided into two parts  first part identifies the network and the second part identifies the host in the network the form is not the same if the format is not the same for each address so this is an important point to understand that when you are given an ip address it is a 32 bit address  these 32 bits are actually divided into 4bytes and each byte is usually read out in decimal separately you can get a ip address like 144.16.19.23 where this 144 is the decimal equivalent of the binary string which is in the first byte of the address then we have 145.16 where 16 is the next byte and next byte contains the decimal binary equivalent of 16 so  if you convert this 144161923 separately into bytes which are the binary strings and put them together that gives you the 32 bit address or in other words the 32 bit address is usually read out this way now in this 4 bytes there is some part which specifies which network you are in and there is some part which specifies which is the host in that particular network this is the same concept when you think of a postal system where you give the name of the town and then the name of the street or the house but the people outside will not really know about the streets in a distant town they will just look at the town name or the pin code and just simply send it there then those people will figure out as to where is that particular house or street in that particular town so we have a network part which is usually important for people who are outside who are trying to route into this network  and then there is a host part which is important within the network so once the packet has reached this particular network then it has to reach a particular host so this is where the host part comes  refer slide time  13  42  14  26  there are three types of addresses in one sense there are other classifications also but one is that  it is for unicast communication unicast means it is destined for a single host  so  it is originating somewhere and is destined for a particular host otherwise there is broadcast communication which is destined for all hosts on a network in a particular network if you want to send some message to everybody then you can use this broadcast communication or there may be multicast communication which is destined for a set of hosts this is a subset of hosts which are in that particular network which belong to a particular multicast group so  that is called multicast communication  refer slide time  14  26  15  18  as we have already seen  the 32 bit number is represented in the following format it is actually something something something something where xxx is the decimal representation of the binary bit string for example  144.16.7.4 so if you see the first byte it has got a place value of 128 + 16 which makes it 144 this is the binary equivalent of 144 or 144 is the decimal equivalent of this so this is the ip address 4 bytes of it and the corresponding decimal equivalent of each of the bytes is given 144.16.7.4 so this looks like a valid ip address  refer slide time  15  19 to 20  51  as for another classification of ip addresses  ip version 4 has five classes a b c d e where all class a addresses start with 0 so it has a prefix of 0  class b has a prefix of 10  class c has a prefix of 110  class d has a prefix of 1110 and class e has a prefix of 1111 so you can see that they all have unique prefixes and by looking at it you can make out what it is irrespective of what values are here you can make out which class it is an ip address contains two parts  the first part is the network id and the rest of it is the host id now just consider the class a address  the first byte is given to the network id and of course of the first byte the first bit is 0 indicating that this is a class a address and then you have 7 bits left for network id so you can have at most 127 or 126 networks as a class a because we only have 7 bits to represent it and in each of this network the host id has 24 bits for specifying the address of the host in that network so for 24 you have actually 224 which is about 16 million if your organization has a class a address which is very unlikely but if your organization does have a class a address  then this is one big network of that 127 networks world wide which has as many hosts as there in the network and how many hosts can be there ? for the host address we have kept 24 bits which means that there can be a possibility of 224 or about 16 million hosts so there could be a network with 16 million computers in it nobody has such a big network and this is very unlikely to happen this is how a class a address is specified next we go to class b which is in the same way but here instead of 1 byte for specifying the network we have 2 bytes for specifying the network out of these 2 bytes the first 2 bits are 10 so that is already gone and the rest 14 bits are for the network id so 214 is about 16,000  you can have 16,000 different class b networks and each network can contain 216 hosts which is about 64,000 hosts so these are also fairly big networks there are networks which are of that order but you have only 214 or 16,000 such networks but you can not have more for class c 3 bytes are given for the network part and only 1 byte so a class c network can have only 28 that is 256 hosts that is a real small network but you can have a large number of them namely you can have about 2 million such networks 221 class d is for multicast group and class e is really experimental so they start with 1110 so after 1110 the entire 28 bits is for specifying which group but this does not work very well so we will come to that later on so if class a ranges dotted quad so a is 000.0.0.0 of course all 0s is not a valid particular address but anyway we are giving the outer limits of it to 127.255 etc so by looking at the first decimal number which corresponds to the first byte we can immediately make out whether this is a class a  class b  class c or class d etc address because class a address can not be more than 127 and if the first digit or the first decimal number is less than 127 then you know that this must be a class a address if it is from 128 to 191 then you know that this is a class b address and so on so  by looking at the first decimal number which is the equivalent for the first the first byte is being dictated this way depending on the class of the address that is how they come to a particular range of numbers so  by looking at the first number we can know which class of address it is  refer slide time  20  52  21  21  so this class a is obviously used for very small number of networks and large number of hosts first byte represents the network address and the last three bytes represent the host address class a address have a first bit of 0 and class a network addresses range from 0 to 126 and 127 is actually reserved for something else  refer slide time  21  21  21  49  class b provides an equal number of networks and hosts first 2 bytes are network address and last two bytes are host addresses first 2 bits of a class b addresses are 1 and 0 so you can only have 16,000 such class b networks and network addresses range from 128 to 191 that is the first decimal number for the first byte  refer slide time  21  29  22  03  class c is a greater number of network addresses  fewer host addresses  the first 3 bits are 110 so network addresses range from 192  223  refer slide time  22  04  22  11  class d is used for special multicast addresses the first 4 bits of class d are 1110  refer slide time  22  12  22  21  class e is used for experimental purposes the first 4 bits of class e are 1111  refer slide time  22  21  25  42  there are some special source addresses as part of an initialization procedure for example bootp this host on this network  the net part is 0 and host id part is 0 that means when the net part is 0 depending on which class of address it is and suppose it is the class c address then the first 3 bytes are really the network part so it will be 0.0.0 and the host part is 0 so if you say 0000.0.0.0 it means that it is itself so this is sometimes required for example in bootp protocol you require referring to yourself specified host on this particular network  so you keep the network part 0 and the host id for this particular host that you want to specify  suppose this is a class c address  the host part is given only by the last byte suppose the last byte has a decimal value of whatever maybe 130 or something so if you say 0.0.0.130 that means whatever the network i may be in  in this particular network get me the host number 130 it is a specified host on this particular network wherever it is loop back address  the loop back address allows applications on the same host to communicate using tcp ip here the net id is given as 127 and host id could be anything which means the first byte is all 1 that is the loop back which is referring to this particular host why do you require this ? suppose two different applications are running on the same host and they want to communicate with each other using tcp ip but why do they require tcp ip if they are on the same host and when they could communicate directly ? the point is that these two applications could have been hosted in two different hosts also if this was the case then they would have to use tcp ip so instead of writing two different versions  one for the case where both of them are in the same host and the other in two different hosts you write the same program and use the same tcp ip stack the only thing is that you want to refer to the same host if you are trying to refer to the same host using the same tcp ip how would you know the network address and so you would not be interested to include a hardware into that particular application therefore there is a way to refer to the same host which is by using 127 that is all 1s in the first byte  refer slide time  25  43  28  41  then we were talking about three different types of addresses for unicast  broadcast and multicast we have seen about unicast communication that is the network part and the host part  both you indicate and then you are talking to that particular host we have seen multicast in class c addresses and mostly in class d so that was a multicast group and then now you talk about broadcast but here there is a caveat in the sense that you are not allowed to broadcast to the whole wide world because if everybody or even a very limited fraction of people start broadcasting some message to everybody in the world then the entire network will be swarmed with broadcast because now in this age of internet millions and may billions of people are getting connected to the internet  so if only a small fraction of them want to broadcast things to everybody that can not be allowed because then the entire network will go down so broadcasts are always limited and how they are limited and how the broadcast addresses are specified will be discussed now limited broadcast typically used for initialization only appears on local cable or collision domain with net id is ? 1 that is all 1s and host id is all 1s this means that if you give an address which is all 1s it means that you want something to be broadcast in the local network wherever you are in the net directed broadcast means you want to broadcast to a particular network so this is forwarded via router now that particular network has to be mentioned so the network address part is to be specified giving the net id  the host id is all 1s so all 1s means to every body but if you put all 1s in network part as well as all 1s in the host part it can not mean that all networks and all hosts in all networks  that is not allowed all 1s in the network part as well as all 1s in the host part means that it is for all the hosts in this particular network and then there could be subnet directed broadcast we have not talked about subnet as yet which we will do there will be a subnet id which is really carved out of the host part of the address and then host id part will be all 1s  refer slide time  28  41  29  14  so all 0s means this host and all 0s in the network part and the host part is something specific which is like a particular host on this particular network all 1s mean broadcast on the local networks if the networks part is specified and if host part is all 1s it means that broadcast is on a distant network if it is 127 then it is all 1s on the first byte and anything in the rest of it is a loop back  refer slide time  29  15  34  10  now we come to a problem a few companies got class a like xerox and some other companies got a class a address when they were actually very closely involved with designing internet in the arpanet days so people really did not know who designed this network and had no idea that their project is finally going to blossom so wildly and become greatly successful they had no idea that they had to be careful with all these addresses that they were doling out so the companies which came in got some class a addresses these class a addresses can have 16 million hosts which is really much bigger than anything that a company might want many institutions got class b networks such as 12 institutions for 14 bits you can have only 16,000 so it is not such a big number when you are talking about in the global scale so 16,000 institutions and may be 126 companies over there is really a small number but now-a-days there are millions of companies and ripped hundreds of thousands of companies who want to have their own network etc they are now reduced to accepting only class c address class c address is too big because you can not have 16 million hosts but a class c address can accommodate only 256 hosts but 256 is a very small number any institution or many institutions now-a-days have got thousands of computers in their network so this too small for them for the first one let us think of another problem suppose you have a class b network where you have 10,000 nodes now if all these 10,000 nodes is one network  the network in our parlance at this particular moment is one particular broadcast domain  so you can always broadcast in this network if you are sitting in one particular network and you communicate to some other node in that particular network then you need to know his mac address which you do not know but you know his ip address so what you will do is you will broadcast the ip address asking for the mac address now whichever machine has got that particular ip address you will get it and answer with his mac address and that is how the arp protocol works so whenever you try to communicate if you do not know the mac address of the other side naturally you will send a broadcast to the entire network now if all these 10,000 hosts start sending broadcast messages from time to time then the broadcast traffic would be too much since the network is so big we have to break it up into smaller parts so that broadcasts are limited to smaller sub networks for which you need some more bits previously we were talking about the two parts of the address  one is saying this network and then we are saying this host in this network now we have to say three things ; it is this network  this particular sub network in that network and then this particular host in that sub network it is just like instead of a town if you have a city then in a city there will be a large number of post offices in the same city from outside may be from another country they will send it to that particular city and in the city you will decide this is that particular post office in that city and that particular post office would know that it is for this particular house on this street in this region so we have a network  a sub network which is the breaking of a big network into smaller sub networks and then we have a host in that particular sub network so  as we have said that broadcast would enter a network obviously it is impractical for class a networks and even for class b networks  refer slide time  34  10  34  29  so subnets are used to divide a large network into smaller networks each address allows for one network address and many hosts that is  all hosts are on the same network subnet masks are used to create many subnets within the same network address  refer slide time  34  30  35  32  so we will look at subnet masks this is a bit string applied to an address if the bit is 1 the corresponding bit in the address is considered to be a network bit the network mask is known only locally if we have one part which is the network part and the next part which is the host part then we take some bits from the host part and use them for specifying the sub network the number of bits of the network which you take for the sub network is given by the subnet mask by placing those particular bits to be 1 and this subnet mask is known only locally  refer slide time  35  32  36  55  so this is an example suppose we have a class b network  in a class b network you know that the first two bytes is the network part and the other two bytes is the host part now in this host part these 6 bits will show my sub network address so you make the corresponding bits in the network mask to be 1 and the rest are all 0s the host part are all 0s  now  looking at the address we will know whether it is a class a  b  c just by looking at the first number and we know how much is the network part if we know the subnet mask we know how much is the network and sub network part if we take out the network part from that we get the subnet address here actually this not the address  the masks only tells you that these are the bits which are used for the subnet address and the rest of it is for the host address we will see examples of this  refer slide time  36  55  39  07  let us say we have an ip address 144.97.16.132 that is the ip address of a particular host and we are also told that we have a subnet mask of 255.255.255.192,1 etc these are all for only human communication but of course these are all individual bytes which are to be converted to the corresponding bit strings the 255 are all 1s in the byte so all 1s and 192 is 128 + 64 which means the first two bits are 1 and the rest is 0 so this is subnet mask since this is the class b address we know that if you convert 144.97.16.132 then this is the string you get 144 so the first two bytes is for the network part now we also know that the 8 + 10 bits are for the sub network part so this is the sub network address 0001000010 and the host is 100 part so the network part is the first two and then the sub network part 000100 so this is the entire network part wherever we have a 1 and beyond that the point where we have a 1 we put all 0s for the network address so network address is 144.97.16.128  the 144.97 is telling me which particular network it is and 16.128 is telling which particular sub network is within that network and the host is this 100 so the host is 4 let us just see another example  refer slide time  39  08  39  57  so we have this ip address which is 144.97.17.132 and the subnet mask is this so we see that the first seven bits so the network has been broken down into 127 different networks and then we have 9 bits for hosts so we can have may be 512 hosts in each network this is the network part up to this one so we take all the 1s there and the rest are put as 0 so network is 144.97.16 and host is 1.132  refer slide time  39  58  40  53  so how do packets get to the other end ? select router based on the ip address that is  for class b use the upper 16 bits as a network specification  for class c use the upper 24 bits as network specification and so on and naturally for class a just look at the first 8 bits route to that network using the routing tables as we have seen so depending on whether it is a class a  class b or class c you use 1 byte  2 bytes or 3 bytes as the network address route to that network using routing tables if your routers  rip or ospf etc is working properly then it will reach that particular network the point is  what happens after that ?  refer slide time  40  53  41  36  then the router uses the pre-specified subnet mask to select a subnet because looking at the subnet mask and at the ip address it knows how many bits are there for specifying the subnet so it finds the subnet mask and it just takes out the subnet part of the address which is looked up in a subnet routing table a subnet routing table is consulted and traffic is directed to that particular subnet so this gives you a more hierarchical structure and arp broadcasts are contained within the subnet if you reach that particular subnet then the host number is given and you can go to that particular host  refer slide time  41  37  46  14  now  we come to the other part of the problem as i mentioned class a is of course huge  class b is also very large so we have to break them up into the subnet the other side of the problem is that  the class c address is very small the other thing to note is that the network has grown so much there is a tremendous demand for ip addresses this ip addresses have to a global standard you can not have your local standard because other people would be looking at your address may be at a different corner of the globe and try to route packets to you so these addresses have to follow a global knob and that was used to be controlled by one central body now  if you have to give the address to somebody then you have to give internetwork address for his particular network usually and now this creates a problem in the sense that when the demand for these addresses becomes too high you run out of addresses as a matter of fact we have come to a stage today where for all practical purposes we have run out of addresses now you only have a few class c addresses left if we had been much more careful  if we could have envisaged how the networks would grow and if we had been much more careful earlier in assigning addresses and not waste big addresses like that may be we could have stretched this for by a few more years but anyway this can not be helped now so people are working on various types of solutions to overcome the shortage of ip addresses and the other side was that quite a number of years back people worked on a new protocol  you must have noticed that this lecture is titled ip version 4 possibly implying that there are other versions available and actually there is ip version 6 which was finalized quite a few years back anyway in the ip version 4 we have this problem  what are the various kinds of workarounds ? one thing could be  if you take a big address chunk let us say class b address and give it to different organizations may be some parts of it  the one problem is that  first of all you are breaking down these classes class a  b  c at the byte boundary so the point was that do not have them at the byte boundary so they no longer belong to one particular class  they are called classless and classless interdomain routing that is the cidr is the protocol which is there where you specify your starting address and then specify how many hosts you have in your particular network  so this is an example suppose some british universities like cambridge  suppose the first address is this and the last address is this that means how many nodes they can have ? you can have from 0 to 7 so that is 8 over here and of course 256 on the last byte so 8 ? 256 that is about 2048 hosts so it gives the starting address 194240.0/21 this 21 is a code which really shows that there are 2048 hosts now various such numbers are possible  22 means 1024 hosts  20 means 4096 hosts this way it goes down on one side and on the other side you can even have less than 1024 hosts so various numbers are there and there is a table here similarly 19 would mean 8000 hosts and so on  refer slide time  46  15  50  57  there is another workaround people have done and actually many organizations are now doing it and in common parlance it is called nating that is network address translation as i said earlier your ip address has to be known globally  it has to be a global standard  globally assigned now  if we make an observation that this is true only when we are communicating with somebody or only when somebody else is trying to communicate with me that is when it needs to be global so you have an entirely private address and if it is a private why not it be a class a address ? so whatever be the size of your organization may be you use a class a address inside this class a address that you have just to use it without permission means that this address is not recognized globally assuming that you are in a big organization you do all your internal communication using this private address the point is that only when you are going out to communicate with somebody you will mask your private address  keep a temporary table and tat table will be dynamic one  for the time being you want to communicate  dynamically there will be your local address which is actually a private address and not a globally legal private address and you will put it and then you will have a pool of legal addresses and you will use one of them whichever is free and then start communicating to the outside world it will be as if you are communicating with this particular legal address which you have assumed for a temporary point of time while you are communicating so that is called network address translation suppose we have this company lan that is the company router etc and then a packet arrives and suppose this has an address 10.0.0.1 then the first number is 10 which immediately tell you that this is a class a address but really this company does not have a class a address but is using it and there is a convention that when we use private address some how we use 10 but whenever somebody looks at an address that starts with 10 he knows that this is a private ip address therefore this is a private address he is using and this is going through may be a nat box or firewall now this nating could be done at a firewall the nating can be done in the router also and so all these boxes usually come with that capability so  in the nat box over here or this firewall maintains a table of this ip address it is trying to communicate  it assigns the pool of ip addresses and out of those ip addresses may be this particular ip address 198604212 is free at the moment so he will take out this particular address  put in this particular address and send it to the outside world so the outside world will know the source to be this particular address when the outside world replies back it will come back here to this particular address  it will go through the same box  the box will know this is really an address which is temporarily assigned to him so he will now take this out  put 10.0.0.1 and send the packet to the particular host in that particular network so the outside world will know that he is communicating with this fellow whereas this is not really a fellow this is just one of a pool of address which is shared by a large number of hosts and the translation is done here so that is an example of how nating is done  refer slide time  50  57  52  13  this is not entirely satisfactory but this is used quite often for example in my organization iit we have got more than 10,000 machines and we do not have a class b address you can not help  so we just have a bunch of class c address so we assign these class c addresses to all these boxes  we do the nating and that is how we communicate one problem is that if the nat box fails all the connections are lost it violates the osi layer independency because this is a workaround and we do not have so many addresses that people demand some applications insert ip addresses as a part of the message then of course that application will fail because if the ip address is some how hard coated inside the application message somewhere that is not going to work and nat changes the content of the ip datagram  this is incompatible with secured data communication if you want to do the entire thing secured including your ip addresses where you are communicating this nat will not work or wherever you are doing nating you can not encrypt that part  refer slide time  52  14  52  30  ip data is laid out in big endian order that means byte transmission order is 0  1  2  3 you know big endian or little endian or which way you go 0  1  2  3 1 or 3  2  1  0 so  in networks this is the network byte transition  refer slide time  52  31  53  23  in this ip header we have version  header length etc and the ip header is 20 bytes or more  it is minimum 20 bytes so this is 4 bytes each so that is 32 bits each the source ip address is given as 4 bytes  the destination ip address is given so that is another 4 bytes so that is 8 bytes gone these three batches of 4 bytes each which amounts to 12 bytes are used for various things later on there may be some options  refer slide time  53  23  54  36  this is version 4  then version 6 would be there  bit filled specifying the ip version currently 4 header length specified in 32 bit words and range is from 5 to 15 words or 20 to 60 bytes so what is the length of the header ? why do we need the length of the header ? if you look at the previous one there could be options  so how do you know whether just after destination ip address the data starts or the header goes some more and more options are exercised ? the header length has to be given the type of service  some kind of quality in service was expected but this did not work out very well and is mostly ignored now then the message length is in bytes the datagram identification field must be unique so there is a datagram identification field  16 bit packet identification we will talk about it when we talk about fragmentation  refer slide time  54  37  56  49  time to live field  upper limit on the number of hops that a message can go before being dropped although this is called time to live  actually this is given by the number of hops and why do you require that ? sometimes the routers work in a distributed fashion as we have seen in this rip and other protocols that they work in a distributed fashion and there may be some problem somewhere now because of that problem you may get a routing loop that means virtually since this loop is stored in a distributed fashion nobody really detects that there is a loop but actually one particular packet finds that this has gone in a loop now this packet if it does not die out naturally it will keep on circulating at infinitum and such packets will get accumulated and it will bring down the whole network so there is a mechanism and there are other reasons for this of course but there is a mechanism that if a packet has gone very much astray or if it is just circulating after some number of hops the router will see that it has already crossed so many hops and this is the time to live and the time to live has come down to 0 so drop it otherwise you just reduce the time to live by 1 and send it to the next hop now there is a protocol which identifies tcp  udp or icmp you remember that this is on the network layer now above the network layer there is a transport layer ip is a hourglass design which sort of concentrates on the ip from the various different types of networks like ethernet  token ring etc it also comes to ip  from ip it goes to various different protocols like tcp  udp and so on now in the network layer how does it decide where to go to  whether to send it to tcp in transport layer or whether to send it to udp in the transport layer  so that must also be mentioned so this protocol identifier is there whether it is tcp  udp  icmp  igmp etc header checksum  checksum of just the tcp  ip header that is this ip header and source address which is 4 bytes  32 bits destination address another ip address this is again 32 bits and options  refer slide time  56  48  57  45  data starts at total length that is the header length etc and maximum ip datagram size is 64 kilo bytes hosts are not required to receive packets greater than 576 bytes that means at least 576 bytes they have to accepted ethernet  mtu is only 1540 bytes so most implementation allowed is about 8000 bytes for ip datagrams the point is that when a particular packet has come to a network the packet may be too large for that particular network to handle  so then something has to be done one thing is of course to drop it but if you drop it then every time he wants to send the packet the packet will get dropped so what is done is  this packet is broken down into smaller parts called fragments and these fragments are then sent through the network in the next lecture we will talk about the ip version 6 and mobile ip proof computer networks prof sujay ghosh department of computer science & engineering i.i.t kharagpur lecture no  29 ip version 6 & mobile ip  refer slide time  00  00  00  40  good day  in the last lecture we discussed about ip version  4  ipv4   that is the version of internet protocol that is now ubiquitous in the sense almost everywhere it is used but as this particular version became more popular than its originated thought then some problems about ipv4 came into focus and people started discussing about what is the next generation of internet protocol that would be there and after a lot of discussion etc people came up with this ip version 6  ipv6    refer slide time  01  30 ? 01  37  we will be doing a little discussion on ipv6 today in the later part of the lecture we will be talking about mobile ip  refer slide time  01  38 ? 01  37  what was the design goal ? as i mentioned  ipv4 was very successful  but the limited addresses posed problems this was discussed earlier as how people are trying to fight with this problem using natingnetting etc because so many machines are coming into the network these days and not only machines but in certain cases people are actually deploying all kinds of gadgets which should be connected to the network if something is connected to the network and accessed from anywhere on the internet then it has to have an ip address the pool of ip addresses we have in ipv4 is very limited and this is one of the major problems  refer slide time  02  34 ? 02  47  and the second problem is  as mentioned earlier  the routing information were not inherent in addresses for example  in a postal address  we have the pin code and in the pin code if the first digit is 7 then immediately we know that it is towards the east if the first digit is 1 immediately we know that it is towards the north so just by looking at that you can simply send the material to that direction but that has not been so because these ip addresses although they were based on networks which are larger chunks than hosts they were distributed but then this could not be maintained at that time if you could have some means of geographical information inbuilt into it then routing becomes easier and the routing table becomes smaller therefore  if the routing table is smaller routing speed becomes faster and so there are many advantages  refer slide time  03  43 ? 04  07  thirdly  experience had shown that some aspects of ipv4 were problematic like option headers and fragments etc were problematic then some type of service  tos  which people never never used  options also have a very limited utility because of its limited size and fragments was a problem these were the basic issues  refer slide time  04  08 ? 04  21  the simplification for ipv6 as mentioned was that to move to a 128-bit address from 32-bits if you remember that ipv4 has as an address size of 32-bits whereas this is 128-bits so in ipv4 in a theoretical maximum it is 232  of course it is less than that but anyway the theoretical maximum is 232  addresses whereas here it is 2128 addresses which is a very huge number even  if all the devices and computers you can think of are connected and given individual address space then also you will have a huge number of addresses to spare this was done with the idea that we are not going to run into this problem of limited address space ever the other point is  if you have so many bits  as i said that even after assigning numbers to all the devices and computers you will be left with some to spare so that can be used more intelligently  refer slide time  05  15  05  25  second point was to assign a fixed format to all headers in ipv4 also  the essential part of it  the initial part of it  the compulsory part of it is fixed but there are options and these options could be of various sizes so that is also removed  refer slide time 05  37 ? 06  01  remove the header checksum which was not doing much anyway use extension header rather than options options were removed and we came to the concept of extension header that means headers followed by other headers  we will come to this later on remove hop-by-hop segmentation procedure that means you do not segment it somewhere in between a packet that is traveling and then somewhere in between you try to fragment it however  that was not a good idea  and because of this fragmentation you have to keep the fragmentation number  the packet identification etc so all these are removed although fragmentation can be handled in some way we will talk about that later  refer slide time  06  23 ? 06  44  this was the original ipv4 header which we have already discussed like version header  length  type of service etc this type of service  tos  was not very useful fragments etc came in because we allowed fragmentation which is not done here header checksum may go out but the source and destination ip addresses would be there let us come to the ipv6 header  refer slide time  06  45 ? 07  09  ipv6 header is actually much simpler than the ipv4 headers we have a few fields and then the source address assuming that this is 32  previously ipv4 address was only one line but now you have four lines i.e 128-bits for source address and 128-bits for destination address let us look at the fields  refer slide time 07  10 ? 07  27  one is the version number previously it was 4 but now it is 6 class  this is used to assign service class for real time networking if you are doing some real time networking that can be indicated here then  there is a field called flow  if you quickly look at it we have version  class  flow level  refer slide time  07  28 ? 07  32  flow  flow means given one particular source and another destination then for this particular source and destination pair there is a flow level flow means these two are likely to send large number of packets and all of them would belong to the same flow this is not a virtual circuit identifier like atm because in atm the virtual circuit identifier and intermediate switch would just look at the virtual circuit identifier and switch it that way this is not for that purpose at all rather this is for treating the packets with a particular flow level from a particular source and destination in the same way where all packets belonging to the same flow level in the intermediate router for example  there may be class of service or all kinds of quality of service requirements for one particular flow that may require bandwidth reservation in between therefore such things can be handled using the flow level  refer slide time  08  45 ? 09  31  payload length  only include the payload and not the 20-byte header this is 16-bits for that so packets are once again less than or equal to 64 k next header ; this gives rise to the possibility that there may be more than one header if there are not any more ipv6 headers then  at least the higher layer headers like tcp or udp headers could be there there is a field called hop limit this is really the ttl  time to live  which was present earlier in ipv4 but was used to just keep the count of the hop and this is just renamed as hop limit  refer slide time  09  32 ? 10  12  fragments  one of the lessons we learnt in ipv4 was that the unit of transmission should be the unit of control so no fragments created en-route in ipv6 if message is greater than mtu the maximum transferable unit then you get icmp message which is an internet control message protocol we will talk a little bit more about icmp later on but this is some kind of control message which may be sent by a router to host etc so  an icmp message should use the path mtu let us see what is meant by this mtu and path mtu and how do you avoid transmission  suppose you are the source and you want to transmit a particular packet it so happens that en route it encountered a link where such a big packet can not be accommodated in ipv6 what this router will do is that it will drop the packet and send back an icmp message saying that this mtu is so much which is for the next link now you will reduce your packet size at the source itself and try to send it again but now it will definitely cross that particular link  it may get struck again in another link so again an icmp message will come back but finally you will come to size of packet which will go through all the links now this is your path mtu now you can go on sending all your communication using this particular packet length and it will not be fragmented in between  refer slide time  11  17 ? 11  36  this is a way to fragment a datagram but it is done in an end-to-end fashion it may so happen that for some particular application all these smaller packets we have made should actually be made into bigger packets so this is fragmentation in some sense so far as the application layer is concerned so there is a way to indicate that  there is a header for that  refer slide time  11  46 ? 12  29  finally we have removed the options from the ipv4 header and we have come to this extension header that means there may be more than one header we could have this situation that ipv6 header and next header is said to be tcp the payload is the tcp header and payload itself it could be that ipv6 header  the next header is a routing header  which again is an extension header for ipv6 routing header and the next header is tcp so the tcp header and payload comes here so there may be more than one ipv6 headers and headers are of different types  refer slide time  12  29 ? 13  01  intermediate routers do not need to look at the headers unless we tell them to specifically it has to look at some headers but can ignore few other headers it does not need to process all the information it should be fast extension headers and protocols  for example  tcp shares the same 256-entry name space i.e 256-entry name space for the headers hence there are limited number of extensions but this number is a big enough  refer slide time  13  02 ? 13  33  there is a certain order suggested that these headers should occur in one particular order one is  ipv6 header the main header we talked about  an and the extension header called hop-by-hop header  destination options header  routing header  fragment header  authentication header  destination options header  upper-layer headers if any that means tcp or udp let us quickly discuss a few of them  refer slide time  13  34 ? 14  21  payload may be encapsulated,payload followed by the transport layer header then there is a tcp  then a routing header  authentication header  another two routing headers  then ip header and so on what you do is that you peel them one by one so that one routing header is peeled of because the routing header gives you information about how to route the packet something like source routing so that is peeled of may be in the next hop and this goes out the ip header remains and the routing header authentication header etc remains you peel out one header after another and finally you get to the tcp and the payload  refer slide time  14  22 ? 14  38  naming  a large part of the address space is unassigned this means  at this point of time people thought it prudent to keep provision for some future requirement which we can not envisage at this moment so a large part of the name space is simply been kept unassigned  refer slide time  14  55 -15  08  there is a way now to move away from provider based routing  based id ? s the two routing based id ? s although both are possible previously what would happen is that the service provider would take a chunk of ip addresses and it is for his network now this could be distributed in various places so  provider wise this loses the destination information whereas if you had done it geographically the routing would have been much easier  the routing table will also be smaller ipv6 keeps the option of both so you can have provider based addresses and also geographic based addresses there are various levels of aggregation like top-level aggregation which is essentially a hierarchical organization reflecting the current internet architecture  refer slide time  15  56 ? 16  09  then the next level aggregator  then site level aggregator allocated to a link or a link level or site level aggregator that is local this means  at the link of the site level the rest of it may be common it does not matter because it is strictly for local use that is something similar to a private ip and not for communication with others  refer slide time  16  15  16  20  the interface id is based on eui id  the extension of the ethernet mac address and even that can be embedded  refer slide time  16  29 16  59  there are some unspecified addresses we need not bother about all this because ipv6 as of yet is not been deployed much only thing i would like to mention is about any cast we have talked about unicast  broadcast and multicast any cast is a concept something similar to multicast but in multicast there is a group where you can send some message to all the members of the group in any cast you can send any message to any member of the group  refer slide time  17  15 ? 17  41  let us look at some of the routing extension headers it has the next header a header length  a routing type etc now we have some address 1 to address n there are some ip addresses  ipv6 addresses may be listed over here  refer slide time  17  42 ? 17  55  it plays the same role as source routing header you remember that  in ipv4 options there is a way to give the routing from the source that means you determine the routing from the source itself such a facility is very important for protocols like bgp because bgp wants to dictate the route through which the packet should be routed but the problem with ipv4 was that the header length was very limited so you can go only up to a dozen or so may be 12 to 15 hops in the source routing if it is beyond 12 to 15 hops you would run out of space in the header so you would not be able to specify that here you can have a routing header then you can have more than one routing header and this particular difficulty is obviated  refer slide time  18  42 ? 18  54  basic idea is  when a datagram reaches a destination  the destination checks for a routing header if there is at least one segment left  that address is copied from the routing header and the packet is forwarded to that address  refer slide time  18  55 ? 19  17  otherwise  the routing header is removed and the next routing header is processed you can have multiple routing headers if the 8-bit header length causes a problem there is a header length of 8-bits so you can go up to a length of 256 but then you can have multiple routing headers you can specify other source routing nodes using type  refer slide time  19  18 ? 19  46  fragment header  each fragment routed independently identification identifies the original packet that was fragmented the offset is the offset within the fragment the m field is a more fragments bit and is set to one for all but last fragment this is exactly similar to the way fragmentation was handled in ipv4 the difference over here is that the source sends it using the path mtu that means in the in between it is not fragmented and whatever fragmentation is done is done at the source and that information is carried in one header called fragment header and those would need not fragment anything they will not use this header so  all these extension headers are optional you have to have the first ipv6 header but all the extension headers are optional therefore  if you are not fragmenting then you will not use this header  refer slide time  20  23 ? 20  39  there is a destination options header  when a packet reaches its final destination  or at least when all prior routing extensions have been processed   the destination options header is processed so as an option the unknown options are discarded  refer slide time  20  40 ? 21  23  hop-by-hop options header  this is another one the destination extension header is looked at just at the end at the destination in the hop-by-hop all these at intermediate hops you need to look at this hop-by-hop options header they are processed at each hop  for example  the jumbo payload header the ip header length is 0 and the jumbo option encodes the true length as a 32-bit value this is an option that you can have a very big packet traveling down it is also used to mark spanning trees for multicast and real time protocols etc there may be things that you need to do at every hop  refer slide time  21  25 -21  56  security is another area that was in focus security association  we will talk about network security etc at length later on there is a way to put authentication and encryption requires that senders and receivers agree on a key for encryption and decryption and authentication or encryption algorithm  and set of ancillary parameters such as the lifetime etc this is called security association  refer slide time  21  57 ? 22  17  now  you have an authentication header where the security parameters may be mentioned namely the sequence number field  next header  length and reserved the spi is selected by the receiver and is used to describe the security association where everything is normally negotiated during the key exchange  refer slide time  22  18 ? 22  53  there is encrypted security payload headers entirely can not be encrypted because then the intermediate routers will not be able to handle it the last unencrypted header in the chain  this is an encrypted security so there would be encrypted data and authentication data  also the esp  encrypted security payload  header esp header will be there esp header also includes authentication to prevent tampering with encrypted data we will talk in details about security in a later lecture  refer slide time  22  54 ? 22  58  to conclude this discussion about ipv6 this is really one scheme where people will not be running out of ip addresses then a funny thing happened in the sense that many of the hardware vendors like routers etc rather modified their design in order handle ipv6 however  actually what happened was that everybody is waiting for all others to switch from ipv4 to ipv6 when you switch you may have problems with some of your software or a lot of your software if you only switch over to the other version that would not do because the rest of the world will still go with ipv4 you can still operate it through some bridge  through an ipv4  ipv6 etc but then nobody wants to do it unless other people are doing it that is how everybody is held back for quite a few years but one thing is that if there are ubiquitous kind of networking  in the sense that  not only your computers but all your devices like refrigerator  tv and air conditioner and everything in the house is networked then we will require a huge number of network addresses then people will not have any option but to actually make the move right now everybody is sort of waiting for other people to make the move next  we will come to the topic of mobile ip what is mobile ip ? mobile ip means  now there are many network attachable devices it is not only the laptop computers people are carrying everywhere even apart from laptop computers there can be all kinds of devices including hand held devices which can be connected to a network now what is the problem if all these mobile devices are connected to the network ? there is no problem as such  whenever you go there have to be some way in which a physical connection is made that connection may be wireless in the case of mobile the wireless connection is very attractive but otherwise you may go to some other place and actually connect a wire over there  it may be wired also  although wireless is more dominant but the trouble is what happens to the ip address ?  your device has a particular ip address and that would have worked fine when you were at your home base but you have moved from your home base to some other place now  if somebody wants to talk to you he will be using your ip address and that is what he is familiar with for example  all the name servers etc will have the ip address corresponding to the url if you have a url and that is not going to change they are going to try to use your old ip address but by using your old ip address they will land in your home network where you are no longer available this is the problem of mobile ip when a particular network attached device moves from one network or one sub network to another network then how would you keep communicating ? that is the problem of mobile ip  refer slide time  25  36 ? 26  59  these are the problems as i just now discussed nodes in the internet are identified by specified ip address routing is performed using that same ip address when a node ? s location or attachment changes then routing will not work with the same ip address that is a simple point  refer slide time  27  00 ? 27  18  what are the alternatives ? one is that  the node must change its ip address whenever it changes its point of attachment it requires upper level protocols to handle address changes  that is one problem this means  if it is to be made automatic then it has to be automated by a higher-level protocol which really sort of violates this layered architecture  that is one point more importantly  what would happen is that the others who want to communicate with you know your ip address they do not know that it has changed in the meanwhile so they would still try to communicate with the old ip address  refer slide time  27  43 ? 28  54  the other thing was that  host specific routes must be propagated through the network this is another possibility because from your ip address if somebody is trying to contact you from outside he first looks at the network part of the address and allows them into your network  then within the network  you have this arp and other protocols to help you to get the mac address and reach you directly so the routing table essentially keeps track of all the networks as many as they can depending on what size the router is the big routers keep track of many networks  the small routers keep track of only a few network addresses if these entries were against host then the routers might dynamically change their entry etc and route it directly to that host however  even handling so many millions of networks is becoming a problem so handling billions of hosts in the routers is simply out of question the solution to this is to use another level of indirection  that is what we do in mobile ip as i have just now shown  refer slide time  28  55 ? 29  00  mobile ip design goals  a mobile node must be able to communicate with other nodes after changing its link layer attachment changing its link layer attachment is changing the attachment to the network or sub network to which it was originally attached yet without changing its ip address where its ip address remains the same this is the problem a mobile node must be able to communicate with other nodes that do not implement mobile ip this is the other requirement it means  you may do something very sophisticated and special in your hand held device but the point is that still it should be able to communicate with millions of other hosts who do not have any special arrangement for communicating with mobile ip therefore  you can not do anything on the other end  refer slide time  29  49  31  39  another point is that  this is a sort of security concerned that mobile ip must use authentication to offer security against redirectment attacks the point is  when you are in your own network you can try to authenticate it apart from any other security arrangement that is present like your password may be at a higher layer but the point is that it is also possible that you allow communication with that particular host which is in that network  so you will set up your firewall or router policy in such a way that  that particular communication will be allowed  may be communication from others will not be allowed but the point is  if this fellow has moved to another network then you will not be able to do it using the network address  that is one aspect the other point is  other people may fake from other places for example  suppose i want to communicate with mr x  then mr y from some other place may rather try to spoof ; in the sense  they may try to show that he is actually mr x so i will think that i am communicating with mr x but actually i am communicating with mr y therefore  anything might happen and security concern is also an issue the number of administrative messages should be small to save bandwidth and power you can not have a huge overhead for doing this  mobile ip must impose no additional constraints on the assignment of ip addresses  this is another important issue  refer slide time  29  49  32  09  before describing how this mobile ip is implemented  let us discuss about some terminology one is the mobile node that is a host or router that changes its point of attachment from one network or sub network to another a mobile node may change its location without changing its ip address it may continue to communicate with other internet nodes at any location using its own constant ip address  refer slide time  32  09  32  42  home agent  this is required in order to support mobile ip home agent is a router on a mobile nodes home network that tunnels datagrams to the mobile node when it is away from home you can immediately get the idea of how it is done the point is that  this particular mobile device has a home network and that home network has a router and that supports mobile ip what that home network router would do is  whatever communication is supposed to be received by this particular mobile device will come to its home network the router will accept that communication on behalf of this mobile host that may now be away somewhere else then it would be the job of the router to send that communication back to that particular mobile host not only you require a home agent  that means  some router helping you and your home network  then you require a foreign agent a router on a mobile nodes visited network means the network to which it is currently physically connected provides routing services to the mobile node while it is registered for getting this service you must register with this foreign agent  refer slide time  32  43  34  13  the mobile node is assigned a care of address this is a new address one is the mobile nodes own ip address which is remaining constant that actually belongs to the network in its home base it also has a care of address on the foreign network this address is used to deliver the datagrams for the mobile node this address can either be the foreign agent where the foreign agents address may be this care of address or it can be co-located with the mobile node  refer slide time  34  13 to 34  50  this is the idea you have  this is the home network of the device of a now a has moved to another network so this is the visited network of a in the home network a has a home agent which will help you in this mobile communication in the visited network it looks for and finds a foreign agent that will help you for this communication this foreign agent will give that care of address and then both of them will be connected to the internet  refer slide time  34  51  35  00  suppose some source wants to send something to a  naturally it will use a ? s original ip address so it will be routed to the home network of a  refer slide time  35  01  35  15  what will happen is that then the home network will send it to the home agent the home agent knows that a is no longer here but it is somewhere else and the home agent also knows the care of address given by the foreign agent  refer slide time  35  16  35  25  he tunnels the communication to the foreign agent using the care of address  refer slide time  35  26  35  33  then the foreign agent will deliver the message to a because foreign agent knows the a ? s current location  mac address etc where it can communicate  refer slide time  35  34  35  52  now a replies to c but this can go straight this need not go in the circuitous manner because he is using the ip address of the source of the original communication so a can send this reply directly back to the source hence  this need not go through the entire process  refer slide time  35  52  36  05  this is the solution in a nutshell  from the source  it goes to the home agent  to the foreign agent  to the node and from the node it directly goes back to the source for the return communication  refer slide time  36  05  37  06  a small overview of the protocol  you have advertisement that means the mobile agents the so-called foreign agents and home agents should advertise their services that means the mobile node comes to know that this foreign agent or home agent is available  that this service is available otherwise  a mobile node can also solicit for mobility agents and that is possible registration  when a mobile node is away from home it must register its care of address with its home agent so  not only it must set up some arrangement with the foreign agent to give it an address but also that address has to be sent to the home agent so that  whatever the home agent tunnels it will tunnel it straight to that care of address  refer slide time  37  06  37  23  delivering datagrams  datagrams must be forwarded by the home agent to the foreign agent for delivery to the care-of address the delivery mechanism must handle all packets including broadcast and multicast a tunnel is used for this analogy in a little while  let us see what a tunnel means  refer slide time  37  23  38  05  advertisement and solicitation  the router discovery icmp protocol was adapted for advertisement and solicitation so not much of a change was required we will look at the details of icmp protocol later the routers broadcast or multicast every few seconds so it uses limited broadcast or all systems on this link  multicast kind of an address for giving this because they can not use the ip address directly because it is an advertisement mobile nodes also send out solicitation messages that will cause a router to broadcast or multicast their advertisement  refer slide time  38  05  38  39  registration  request forwarding services when visiting a foreign network this allocates a local foreign node address that means a care of address is required inform home agent of their current care of address this creates a binding of the foreign node address to the home address in the home agent if anything comes destined for the original home address then this can be tunneled to the care of address  refer slide time  38  05  39  16  this is one small but important point that this binding has to be renewed from time to time bindings have lifetimes this is important because mobile node may be rude and just go away without informing anybody and that registration will rather last forever  it can not last forever it is best that it dies down after sometime if the mobile agent continues in the same location for more time  it is going to renew this binding from time to time and of course you have to deregister when they return home  refer slide time  39  16  39  26  tunneling  there are various methods of tunneling we will just discuss this ip-in-ip encapsulation and minimal encapsulation  refer slide time  39  16  39  26  this is ip-in-ip  this was the original message sent from the source and this is what landed in the home network of the destination if you remember  in the diagram the destination was marked as a this ip header will contain the actual address of a and this is the datagram what it does is  when it lands into the home agent the home agent knows that this has to be sent somewhere else it keeps the inner ip header and datagram intact this whole thing is considered now as a payload and then you add another ip header with some options if necessary this ip header will have as its destination the tunnel endpoints  the tunnel destinations which is supposed to be the care of address in the packet the original packet is still there  this inner ip header and the datagram etc and this whole thing is encapsulated as if this is a payload and sent to the foreign network in the care of address it will reach the foreign agent and the foreign agent will then send this part to the mobile node who is currently connected and its mac address is known to the foreign agent the mobile agent or the mobile node will receive a whole packet including this inner ip header so you do not require any kind of change in the software which handles it just like a normal packet it is as if he was in the home network and got this is original packet  refer slide time  41  15  41  50  the outer ip header source and destination address identify the tunnel endpoints the source would be the home agent and the destination would be the foreign agent the outer protocol is 4 that is the ip protocol the inner ip header  the source address and destination address identify the original sender and recipient  this is not changed by the encapsulator except to change the time to live so for time to live you have to look at the ttl and then make the necessary changes this whole thing is put in the payload  refer slide time  41  51  42  16  other headers for authentication might be added to the outer header in order to handle all these security concerns some outer ip header fields are copied from the inner ip fields for example  type of service etc most are recomputed like checksum length etc may change based on the new datagram  refer slide time  42  17  43  09  the other option is the minimal encapsulation minimal encapsulation means that you do not keep the entire ip header intact here so  what you want to do is that  you want to retain the minimal information in the minimal header and then construct an outer ip header for the outer ip header the tunnel endpoints as the source and destination address would still be there and some of the stuff from the ip header will also come here the destination address will be there in the minimal header you have to make some deconstruction and reconstruction at both places the size is a bit smaller so the overhead may be a bit smaller but it may not be such a big deal  refer slide time  43  10  43  30  in minimal encapsulation  we copy inner header modify protocol field to be 55 for the minimal encapsulation protocol because on the other side it must know which protocol it is following if it is following minimal encapsulation then it has to do something destination address is replaced by the tunnel exit  refer slide time  43  31  43  50  if encapsulator is not the originator of message  replace source address with address of encapsulator then increment total length by the size of the additional header by 12 or 8 octets and then re-compute the checksum this is called mobile ip in one way in which mobility can be handled and your ip address can be recomputed there are other possibilities and other ways of handling mobility for example  this has an overhead that any communication from the source to the intended host that has moved  now has to go through this triangular path will it continue to do so or whether after first communication there would be some protocol to exchange their new ip addresses etc ? then  they can communicate directly  that would avoid this triangular path the other problems with triangular path may be apart from higher overhead it may exceed the hop limit  as networks are growing it may increase the hop limit and you may never reach whereas if it had gone directly then it would have reached other options could be just like you do handoffs in cellular from one base station to another in the case of cellular networks what is happening is that  you are always in connection with some base station  may be even more than one base station if you are moving away from one base station when the signal strength drops then it goes to the realm of another base station  and the other base station automatically picks up and does some kind of registration when this is done  the communication remains direct but  if you want to change the ip address in such a dynamic fashion then there has to be an integrated system running everywhere which is using this protocol mobile ip is a way of handling mobility with minimal change to others and the problem is that this has a significant overhead in the next class we will be moving into the next higher layer which is the transport layer the tcp and udp  thank you lecture 30 udp and client server goodgood day  today we will start our discussion on transport layer protocols and there are actually two dominant protocols udp and tcp we will take them up one by one let us look at udp in this lecture and tcp in the next one  refer slide time  46  56 ? 47  02  udp stands for user datagram protocol   refer slide time  47  03  47  15  this is a transport layer protocol and this has got the following responsibilities first of all it creates a process-to-process communication path till now we have talked about the network layer and the job of the network layer is to connect a distant machine to another distant machine it ? s a machine to machine communication whereas now we are talking about  process to process communication in this particular source machine  some application process is running which is trying to connect the other distant machine for some job this process has to connect to the corresponding process there which may be a particular application server on one side and the application client on the other side  whatever that application may be so this is a process to process communication path  refer slide time  47  56  48  06  this also has to provide control mechanisms at the transport level this control mechanism in the case of udp is very minimal  as we will presently see  refer slide time  48  07  48  19  udp is a connectionless  unreliable transport protocol immediately  the question that would come in your mind is that  why would we try to have an unreliable protocol ? this is not unreliable per say  the point is  it does not do anything extra for reliability making it a very lightweight protocol  the overhead cost is very low in many cases  this may be a very reasonable thing to have where you do not expect lot of errors or you do not really care if some error occurs from time to time and in such cases  you may use a udp  refer slide time  48  58  49  12  this is a connectionless protocol it only adds process-to-process communications to ip it performs very limited error checking as we have mentioned it is a very simple protocol having minimal overhead this is the main point it forms the payload for the next layer that is the ip layer and the checksum is computed over this entire body so there is some amount of error checking and error detection done by udp and that is the extent to which it will go for providing reliability beyond this if the entire packet is lost somewhere the udp can not do anything about it  refer slide time  49  43  49  50  these are the four fields of the header  source port number  destination port number  total length and the checksum  refer slide time  49  53  50  16  and regarding the udp operation this is a connectionless service this has minimal flow and error control as given by the checksum it does the encapsulation and decapsulation  forming of packets  it uses some queuing and does the multiplexing and demultiplexing let us look at the operations one by one  refer slide time  50  17  52  12  this is a connectionless service that means each user datagram sent is an independent datagram it means that  suppose some particular application has sent one udp and is going to send another one  now the layers below this application may be coming from the same source application process destined for the same destination application process which are the two datagrams they are going to be treated independently by the rest of the network layers this means a number of things first of all it may so happen that these two packets may go in two different directions  may be route differently because there is no connection this is a completely a datagram oriented service  connectionless service so these two datagrams may travel in different paths secondly  one of them may get lost thirdly  what might happen is  they may go out of order  the datagram that was sent earlier may reach later the point is that  for all mishaps udp is not going to take any responsibility it is taken for granted that whatever application takes place using this udp is resilient to such events there is no relationship between different user datagrams the user datagrams are not numbered  meaning that  the datagram which was sent later if it arises earlier and vice versa then there is no way of knowing unless you have taken some care to identify that in the application layer itself  refer slide time  52  13  52  46  no connection establishment  since it is completely a connectionless service there is no question of any connection establishment and since there is no connection establishment there is no connection termination either these are unregulated which means that up to port number1023 these are reserved and that is also again divided into two parts one part is for public applications and the other for some vendor specific applications but they are all well-known port numbers now  think of the other direction  apart from well-known port numbers you also need a whole lot of other port numbers take the previous example that we have made an http request to a web server  now the web server will send you back something may be it will send you with the content of the first page of its website this is going to be sent to the requester but to which port ? for this  another port number is temporarily assigned this is assigned from a number range from 1024-65,000 the number is randomly chosen so this is an ephemeral port and not a fixed port for the duration of this communication this port number is going to be held constant and then it will be released for use by some other process  refer slide time  53  58  54  12  source port numbers are dynamically assigned by the originating host  and are usually a number larger than 1023 port numbers in the range of 0 -1023 are controlled by iana  refer slide time  54  13  55  46  these are some examples of some well known port numbers there are a quite a good number of them but i have just mentioned some important protocols for example  ftp  a file transfer protocol uses port number 21 telnet  a terminal connection uses port number 23 there are hundreds of applications that has come up we can not talk about all of them but we will talk about a few of them towards the last part of our course .for the time being  let me just mention them telnet is the terminal connection which uses the well known port number 23 smtp is a simple mail transfer protocol that uses port number 25 tftp trivial file transfer is used when you just have to send a short message that uses 69 http is the hyper text transfer protocol used for web services that uses the well-known port number 80 pop 3 is a post office protocol that uses a port number 110 what pop 3 does is that  suppose you got some mail in your mailbox in the local mail server then on your desktop you can download all the mails from the local server to your machine through the post service protocol this is the pop3 protocol this type of server is called concurrent just to elaborate on the server part a little bit more then what i have already discussed  the client request for a connection has come to the server now what is the server in this case ? when i mention the term server i mean that software process which is running there and not the hardware box a hardware box is also called a server in a different context in our context by server i mean the process which is giving the service  so this is some kind of process which is running in a particular machine now  in the non-concurrent case what will happen is that all the user requests will come and they are sort of put in a queue and now what the server process will do is that  it will take up one from the queue  process the service  then give it back and send the result then it will take the next one out of the queue so there is a queue where all the client requests are waiting and the server  that means the service process which is giving the service is taking one request at a time out of the queue this is called a non-concurrent server non-concurrent in the sense that when you are using sock d ? gram that is a udp kind of service  it is one of its kind where you get a request  send a message and may be that is the end of the service in that case this non-concurrent servers  also called iterative servers are more efficient but it may also happen that  in a particular service the client server communication is for an extended period of time in which case one particular request may block all other requests for an unnecessarily long time in that case the concurrent server may be preferred in concurrent server what happens is  as soon as the server gets a request at the well-known port it immediately spawns or forks note  regarding video content in this video after 45 minit the next lecture is stated after that there is a switching of some other topics which is not related to each other computer networks prof s ghosh dept of computer science and engineering i.i.t kharagpur lecturer # 30 udp and client server good day  today we will start our discussion about transport layer protocols there are two dominant protocols the udp and tcp we will take them up one by one let us look at udp in this lecture and tcp in the next one slide 1 udp stands for user datagram protocol slide 2 this is a transport layer protocol and has got the following responsibilities  first of all  it creates a process to process communication path till now we have talked about the network layer and the job of the network layer is to connect a distant machine to another distant machine so it is a machine to machine communication whereas now we are talking about process to process communication so in this particular source machine may be some application process is running which is trying to connect to the other distant machine for some job so this process has to connect to a corresponding process there which may be a particular application server on one side and application client on the other side whatever the applications may be this is a process to process communication path this also provides control mechanisms at the transport level the control mechanism in the case of udp is very minimal slide 3 udp is a connectionless unreliable transport protocol but why would we try to have an unreliable protocol ? this protocol is not exactly unreliable but it does not do anything extra for reliability making it a very light weight protocol so its overhead cost is very low in many cases it may be a very reasonable thing to have where you do not expect lot of errors or you do not really care if some error occurs from time to time in such cases you may use udp functions of udp   it only adds process to process communications to ip  performs very limited error checking  very simple protocol and has minimal overhead this is the main advantage it has very minimal overhead slide 4 when you are talking about the ip protocol you are talking about the connection from one machine to another but in this particular machine a number of application programs or processes may be running this udp protocol connects one process to another process  so does tcp and that is the job of the transport layer although udp is a connectionless protocol the job of the transport layer is to make some virtual connection or some virtual communication channel available to the corresponding processes slide 5 so to summarize   ip is responsible for host to host communication  message still needs to be handed to the correct process  udp is responsible for delivery of the message to the appropriate process actually  not only you need to understand that there is some kind of multiplexing and de-multiplexing going on in the same server a number of processes may be running and out of all those processes a good number of them may be using the same udp protocol so  when sending out a packet it is alright but when receiving a packet the udp protocol has to determine as to which process it will go to and that is one of its jobs and the other job is to make connections there is a point over here and this is a common task between tcp and the udp our computer network is mostly a packet switched network whereas as far as applications are concerned mostly they do not really bother about packets they may produce a chunk of data to be communicated to the other side they may even produce a stream of data to be communicated to the other side so it does not work with packets so somebody has to take this stream of data from the application layer and chop them into small packets and that is a job of the transport layer so  both the tcp and udp do that slide 6  udp is a transport layer protocol within the tcp/ip protocol suite  it is simpler than tcp tcp has higher overhead  it is more reliable than udp if you want to have reliability and still want to use udp then you have to take care of reliability in some other layer may be application layer or something  udp lies between the application layer and the ip layer and like tcp serves as the intermediary between the application programs and the network operations slide 7 if this is your ip datagram  the ip datagram will have an ip header and the payload for the ip would be the entire udp datagram the udp datagram would have the udp data which it derives from the application and the udp header slide 8 when a particular application wants to communicate to another application or when a process is trying to communicate to another process which is in a remote machine  in that case it will want to talk to some particular machine up to whatever we have seen  a particular machine means a particular ip address now this ip address is handled by the ip layer that means by the network layer on both the machines then how does the network layer get this ip address ? as such it is supposed to get the ip address  the destination source and destination ip address from the top but there is a transport layer between the ip layer and the application layer we are talking mostly about the tcp/ip protocol stack so we are not considering talking about osi protocol stack and presentation layer for the time being the destination ip address is known to the application but it has to be communicated to the network layer the transport layer has got nothing to do with the ip addresses therefore the application layer does communicate the source and destination ip addresses to the transport layer and the transport layer passes it on to the network layer and does not do anything with it except considering it for the check sum so this is known as ip pseudo header because this is not a real header for the udp protocol or tcp slide 9 this ip pseudo header contains the 32-bit source ip address  32-bit destination ip address and then this 16-bit udp length etc so this is the header which is passed on to the ip layer and this is in the same stack in the same machine these headers are actually meant for communication between peers that means the transport layer  the udp on this machine and the udp on that machine will communicate via this udp header so this is the proper header and the pseudo header just takes that information about ip addresses etc from above and passes it below what the real udp header uses to communicate with its peer on the other machine contains a 16-bit source port number and 16-bit destination port number remember  these were 32-bit source ip address and here these are 32-bit destination ip address there is also the port number here which we will see later we have 16-bit source port number  16-bit destination port number  16-bit udp length  optional 16-bit udp checksum which may be optional and data if any  possible odd bytes and a pad slide 10 so this is the length of the header and data therefore we have the source and destination port numbers  total length and checksum slide 11 let us go through this in detail the source port number has  16-bits  range from 0 to 65,535  port number used by the process running on the source host recall the multiplexing and de-multiplexing we discussed earlier in the same machine number of processes may be communicating and out of all these processes a good number of them may be using the same transport protocol namely udp while others could be using the transfer protocol tcp when a particular packet comes  you can see whether it is a tcp packet or udp packet once you make it out  you have to decide that out of all the processes using udp for which process is this packet meant for all these different processes are associated with different port numbers and looking at the port number the udp decides the process for which it is meant for and this is the de-multiplexing part but the multiplexing part comes with the source port number hence there is a source port number and the destination port number used by udp for multiplexing and de-multiplexing at its own level this is a number which is 16-bits long which will give you from 0 to 65,535 these are the port numbers and port number is used by the process running on the source host later on let us see in detail on how this port number is obtained slide 12 similarly  there is a destination port number   it has got 16-bits  port number used by the process running on the destination host  in most cases  it is a well known port number we will what is meant by well known port number slide 13  the length is 16-bits o it defines the total length of the user datagram  header plus data o note  maximum size of data is 65,507 after subtracting 20 bytes for ip header and 8 bytes for udp header as this is the overhead slide 14  checksum is 16 bits o used to detect errors over the entire user datagram slide 15  checksum includes three sections  o pseudoheader udp header and the data * part of the header of the ip packet * ensures that if the ip header is corrupted the user datagram is not delivered to the wrong host since the pseudoheader contains the destination ip address  even if the ip header gets corrupted this does not get delivered to the wrong host the pseudoheader  udp header and the data taken together forms the payload for the next layer that is the ip layer and the checksum is computed over this entire body so there is some amount of error checking and error detection done this is done by udp and this is the extent to which it will go for providing reliability beyond this if the entire packet is lost somewhere  udp can not do anything about it o udp header  there are the four fields in the header  source port number  destination port number  total length and the checksum slide 16 udp operation   it is a connectionless service  has very minimal flow and error control as given by the checksum  performs encapsulation and decapsulation and forming of packets  queuing  multiplexing and de-multiplexing let us look at these operations one by one slide 17 connectionless service   each user datagram sent is an independent datagram if an application sends one udp and is going to send another then they are handled independently in the layers below this application these two datagrams may be coming from the same source application process meant for the same destination application process  but they are going to be treated independently by the rest of the network layers first of all  it may so happen that these two packets may go in two different directions  may be routed differently because there is no connection this is completely a datagram oriented connectionless service therefore these two datagrams may travel in different paths one of them may get lost or they may get out of order which means the datagram that was sent earlier may reach the destination quite later udp is not going to take any responsibility for all these mishaps and it is taken for granted that whatever application takes place using this udp is resilient to such things  there is no relationship between different user datagrams  user datagrams are not numbered meaning that if the datagram which was sent later arrives much earlier and the vice versa then there is no way of knowing unless in the application layer itself we have taken some care to identify that slide 18  there is no connection establishment since this is completely a connectionless service there is no question of any connection establishment  and since there is no connection establishment there is no connection termination either  each user datagram can travel on a different path only processes sending short messages should use udp usually udp is used in a case where you send one packet and that is the end of it when you are trying to the send a stream of packets or stream of bytes etc usually you do not use udp. slide 19 as far as flow and error control is concerned which may be another job of the transport layer the udp does very little  it is very simple and an unreliable transport protocol  there is no flow control  the receiver may overflow with incoming messages  there is no error control except for the checksum what happens is that  suppose the receiver is getting a large number of udp packets  and if it wants to just stop or slow down to the senders it can not do that if it overflows some of the packets will get lost and then there is no error control except for the checksum slide 20  sender does not know if a message has been lost or if it has been duplicated  an error in the checksum causes a user datagram to be silently discarded this is a very simple protocol and this is very efficient and has a very low overhead slide 21 udp does encapsulation and de-capsulation which is a fundamental job of any protocol in the transport layer it has to form the packets  the packets form from the streams of data supplied by the application layer the data is chopped into pieces  a header is added to each piece and then is passed on to send a message from one process to another the udp protocol encapsulates and decapsulates messages slide 22 this is just a standard way as it goes down the stack  the message from the process  so this is the udp data  this is the udp header  then the ip header frame header etc and it is decapsulated in a similar fashion slide 23  queuing   each port has an associated incoming queue or incoming and outgoing queue depending on which way the communication is taking place a port is not just a number along with the particular number  inside the os there will be a queue of data being communicated in the machine there will be an incoming queue and an outgoing queue  udp removes message from the outgoing queue one by one  adds the udp header  delivers them to the ip slide 24 incoming queue   udp checks to see if an incoming queue exists the first thing udp does is to check whether the incoming queue exists  if there is  udp sends the user datagram to the end of the queue the particular application process is going to consume from this incoming queue the process will consume from this incoming queue which is being fed from the udp for the outgoing queue  the application process is going to put things in the queue and udp will take out the message to be communicated from the queue  if there is no such port then udp discards the user datagram and asks icmp to send a port unreachable message this means that a particular packet has come meant for a particular port and that port does not exist in this machine so it will send them an error message saying that the port is unreachable in order to generate this icmp message sometimes a packet is sent to an improvable port number so  when you get back you know that you have reached the destination but of course there is no application over there slide 25 it does multiplexing and demultiplexing  several processes may want to use the services of udp  udp multiplexes and demultiplexes to handle this slide 26 use of udp   this is suitable for processes that require simple request-response communication suppose there is a simple request which may be sent by udp and there is just one message as response to this request then that may also be sent back as an udp this also depends on the kind of network you have suppose you are communicating only inside the lan  in that case you may not like to have an overhead since this is not going over the wan therefore this is expected to be much more reliable and you may not like to incur any extra cost for providing reliability etc because you know that the underlying network is quite reliable and secondly if your process is such that there is a simple message coming and there is a simple response  in that case a simple udp protocol may be sufficient  this may also be suitable for processes which include internal flow and error control mechanisms that means  if the application process itself is handling some flow and error control  that means if it is handled at an upper layer then you do not want to duplicate it in the transport layer  in which case you use of simple protocol like udp which is more efficient because reliability is being handled by somebody else anyway so that is another case where udp is a very suitable protocol  udp may also be suitable for multicasting and broadcasting going to some specific examples  slide 27  this is used for management processes such as snmp snmp is a simple network management protocol used for managing network for managing network we have this central network management software which from time to time may probe different network boxes to see if their health is alright  collect all kinds of statistics etc so this is a simple message response kind of system it asks for queries  manages a particular device in the network by sending a message and that device responds with some statistics or some alarm or whatever it is so that is a case where udp protocol may be quite suitable  this is used for some route updating protocols such as rip we have already discussed rip for updating the routes the routers have to communicate with each other and that uses udp these are just two examples there are many other examples and user applications which may also use udp slide 28 now let us discuss about port numbers and then i will talk about client server port numbers   local host and remote host are defined by ip addresses here the host refers to the machine  a second identifier called port number is required to identify processes because many processes may be running on the same host so just identifying the host is not enough but we have to identify the process in this host or more specifically you have to talk about this process and this host so you have to have a port number as well as an ip address  in tcp/ip port numbers are integers between 0 and 65,535 slide 29  the server process requires a well known port number  the client process defines a port number chosen randomly by udp which is known as an ephemeral port number we will discuss this in more detail when we discuss more about client server this is one of the ways you write applications in a network environment by using the client server paradigm there will be different servers giving different services like you may have a web server giving you web services or mail server etc different clients could be using these services so they use different sets of port numbers this will be clear when we talk about the client server paradigm in more detail slide 30 once again  if you think about the ip address  this selects the host and then the port number selects the process when you give the destination ip address etc it reaches a particular host and in that host it looks at the port number and then selects that process using that particular port number slide 31  port numbers work as source and destination addresses for tcp/udp segments  ports ensure packets reach appropriate service on the server  the destination port field determines which service the source is requesting  tcp/ip associate ports at the transport layer with certain applications slide 32  software developers have agreed on well known ports  for example  o a packet bound for an ftp server would use port 21 just think of some network service  a web service when you are surfing the net you will use a browser and you may click on a particular url or network address and you immediately get the opening page of that particular site displayed by your browser if you think about how did this happen ? a particular site is hosted in some remote machine somewhere you may know only its ip address now  by knowing its ip address you have to make a request to that ip address  like requesting it to show the opening page now the ip address will help you through this mace of routers who may be running some routing protocol like rip  ospf so that your request reaches the destination machine but in the destination machine how does it know the port number ? you do not know about the destination machine  number of processes running etc suppose if it is a http request that means it is a request for a web page to a web server then this request has to reach the web server now there may be ten or fifty other processes running on that same machine  it should not go to any of these other servers so  for very standard applications like ftp  file transfer protocol   smtp  simple mail transfer protocol   http  hyper text transfer protocol  and so on are all applications so  for all these protocols the port numbers are fixed so  if i make an ftp request  as it says ftp server use a well known port 21 that means if i make an ftp request to any machine anywhere in the world i am going to use a port number 21 knowing that this is a well known port number and if it is reaches the destination machine port number 21 would mean the ftp server  conversations that do not involve applications with well known ports are assigned ports randomly selected from a specific range slide 33 there is an organization iana which handles these port numbers so port numbers have the following assigned ranges   below 255  0 to 255  are reserved for public applications like ftp  smtp  http etc  from 255 to 1023 these are assigned to companies for marketable applications  above 1023 these are unregulated which means that up to 1024 these are reserved this is again divided into two parts  one part for the public applications and the other for some vendor specific applications apart from well known port numbers you also need a whole lot of other port numbers take the previous example where we made an http request to a web server now the web server will send you back something  may be the contents of the first page of its website and that is going to be sent to the requester for this another port number is temporarily assigned and this is assigned from a number range from 1024 to 65,535 and the number is randomly chosen this is an ephemeral port  it is not a fixed port and it will be held constant for the duration of this communication and then it will be released for use by some other process slide 34  source port numbers are dynamically assigned by the originating host and are usually a number larger than 1023  port numbers in the range of 0 to 1023 are controlled by iana slide 35 these are some examples of well-known port numbers there are quite a good number of them but i have just mentioned some important protocols  ftp is a file transfer protocol uses port number 21  telnet  a terminal connection uses port number 23 i will be talking more about some of these application layer protocols in a later lecture there are hundreds of applications which have come up and we can not talk about all of them but we will talk about few of them towards the last part of our course  smtp is a simple mail transfer protocol that uses port number 25  tftp is a trivial file transfer  when you just have to send a short message it uses port number 69  http is the hyper text transfer protocol which is the one used for web services that uses well-known port number 80  pop3 is a post office protocol that uses the port number 110 what pop3 does is that  suppose you got mail in your mail box in the local mail server then on your desktop you can download all the mails from the local server to your machine through the post office protocol  snmp is used for network management that uses port 161 there are a whole lot of others but i have mentioned only a few which are important slide 36 now moving on to the full description of client server programming it uses what is known as a socket address socket address   socket address is a combination of an ip address and a port number  this uniquely defines each client and server process so  this process is in this machine therefore this process is given by the port number and this machine is given by the ip number slide 37 these are some of the references for the different rfcs and the udp is described in rfc 768 then there is rfc 1122 and iana port numbers can be seen in the websites mentioned here slide 38 let us see some more about client-server paradigm which is sort of universally used for network based application  server application is listener o waits for incoming message o performs service o returns results  client application establishes connection  it sends the message to the server and then ito waits for a return message in this client-server paradigm usually what happens is that  the client would initiate the request it initiates the request for some service it has to know the address of the service and if it is a well-known service then it will use the well-known port number so in that particular machine in that particular port number it will make the request and the server will accede to the request  in the sense that it will give the service and then return the result to the client and then it goes back to listening so  the server is always in the listening mode that means it is waiting for a particular request to come in slide 39  clients and servers exchange messages through the transport protocols e.g tcp or udp  both client and server must have the same protocol stack and interact with the transport layer so you may have a client server using both tcp and udp slide 40  protocols specify general operations and the api specifies exactly how it is done for using the socket there is a socket api api stands for application program interface  so the socket api is the de facto standard  origin is in the bsd unix from university of california at berkeley as part of one of the first versions of tcp/ip  slide 41 let us see a little bit about the sockets and socket libraries   this is a vendor supplied library of procedures  they have the same name and arguments as one of the socket functions it promotes independent source code and it is  usually easier to use than original sockets the vendors also provide socket libraries with some bells and whistles slide 42  socket software interface is designed to communicate between the user program and tcp/ip protocol stack internally that is the socket all tcp/ip stacks that we talked about right from the bottom one to right up to the transport layer is already in the system now you want to develop an application which should be run over the network in such a case you have to write your application program for any service you would like to give now this user program has to communicate with this tcp/ip protocol stack which is already in the machine and the intervening layer is the api for sockets so you go to this tcp/ip layer stack through the sockets  therefore socket is a data structure inside the program  both client and server programs communicate via pair of sockets slide 43 there are several significant socket domain families   internet domain sockets implemented via ip addresses and port numbers  unix domain sockets implemented via filenames  novell ipx apple talk etc all these other vendor specific socket domains are also there but the first two are the most important slide 44 there are three types of sockets   stream  it uses a tcp protocol stream socket is a connection oriented service so  naturally you can not use stream socket with udp hence the transport layer protocol to use with this stream socket is tcp  datagram  in the datagram socket there is sock datagram that uses udp protocol the type of socket determines the type of protocol it is going to use tcp or udp but this uses the udp protocol  there are the raw sockets which may be used for testing anything internally slide 45 for creating a socket you have to have a library and for accessing the functions in the library which is specifically that socket you have to include that < sys/types.h > and < sys/socket.h > assuming that you are writing in c language so you may have a function called something like this  int socket  int domain  int type  int protocol   when you give this socket call  you have to mention its domain  its type and its protocol  domain is one of the protocol families like pf_inet  pf_unix etc so these are the socket domain families we talked about slide 46  type defines the communication protocol semantics usually it defines either  o sock_stream that means connection oriented stream like tcp or o sock_dgram which is a connectionless unreliable udp  protocol specifies a particular protocol  just set this to 0 to accept the default slide 47 what happens in the client-server is  when the client is initiating a request for a standard kind of a service it knows the destination ip address and the well-known port number and this message has reached the destination machine and in the destination machine the server program always listens to that particular well-known port number so the server program is actually in a loop listening whether any request is coming in through that port number in the case of a udp server this may be simple it gets some request  it immediately gives a very short response and goes back to listening but in such a case when the interaction with the user may be prolonged  for example  the user makes an ftp request and then downloading the file is going to take quite a bit of time similarly  the user may have made an http request which means it may have asked for a particular webpage now  sending that webpage is also going to take some time of course it is always with respect to the kind of speed people are accustomed to if the communication is always through that well-known port then during the currency of this particular session between this particular client and the server that well-known port number is going to be blocked and others will not be able to get the service which is not acceptable so usually in the client-server there is a handshake so the request comes to the well-known port number and of course there is a port address which has been sent by the client from the server side the response goes back with another ephemeral port number which is not a standard port number now  on both sides you have two ephemeral port numbers that means the port number more than 1024 and they can then communicate through these two port numbers with source and destination respectively depending on from which side it is being sent so these two different port numbers are used this is happening on one side and on the other side the original server goes back to listening to that same well-known port number ready to service the next incoming request slide 48 although we have not discussed tcp as yet but so far as this client-server part is concerned both of them are very similar tcp server   sock_init    creates the socket  register port with the system  establish the client connection  accept the client connection  read/write data  close   is for shutting down when you establish the client connection and when you accept the client connection in this part all these two ephemeral port numbers are exchanged this is on the server side on the client side it creates the socket and tries to setup a connection usually in a client-server  the initiation of the connection is always from the client side then the write/read goes on and then there is a shut down slide 49 udp clients and servers are similar except that it uses sock_dgram instead of sock_stream  connectionless clients and servers create sockets using sock_dgram  connectionless servers do not call listen   or accept   and usually do not call connect    this means you may not require any specific handshake and you may not require a special ephemeral port for prolonged communication between the client and the server because in this case usually the service is to just send only one message and ending the service slide 50  since connectionless communications lack a sustained connection several methods are available that allow you to specify a destination address with every call  o sendto  sock  buffer  buflen  flags  to_addr  tolen  ; o recvfrom  sock  buffer  buflen  flags  from_addr  fromlen  ;  there is a way to specify a destination address with every call slide 51 for udp server the sequence of calls is the following   create a socket  register the port using the bind command  receive or send data  shutdown this is somewhat simpler than the tcp server and then there is the udp client that you create  send or receive and then you shutdown slide 52 there are two types of servers several clients can request service of the server in the same time in this case a server can   service one client at one time other client requests must wait this type of server is called non-concurrent the second type is   services all client requests are handled simultaneously this type of server is called concurrent this is what happens  the client ? s request for a connection has come to the server by the term server  we mean that software process which is running there and not the hardware box the hardware is also called a server but in a different sense in our context by server we mean the process which is giving the service and which is running in a particular machine if this server is non-concurrent all the user requests come and are sort of put in a queue then the server process will take one from the queue  process the service and then send the result and take the next one out of the queue so there is a queue where all the client requests are waiting and the server process takes one request at a time out of the queue this is called a non-concurrent server when you are using udp and when using sock_dgram that means you get a request  send a message and may be that is the end of the service in that case this non-concurrent server also called as iterative server is more efficient but it may also happen that  in a particular service the client server communication is for an extended period of time in this case  one particular request may block all other requests for an unnecessarily long time in that case concurrent server may be preferred in concurrent server  as soon as the server gets the request at the well-known port it immediately spawns a new process when you execute a fork  in say unique  what you get is an exactly similar piece of code to which you make some changes what you do is that you give them a new port number and let this new process communicate with this particular client ? s request and the original process goes back to listening to the well-known port another request may come from some other client somewhere else so it will again spawn another process and the original process will go back listening to the well-known port all these child server processes use different ephemeral port numbers to communicate with different clients in the strictest sense if you have only one particular processor in the server machine then only one program can run  things can not be concurrent but have to be sequential but then  that sequentiality is imposed by the way processors are scheduled by the scheduler inside the ?  so it will give some milliseconds for one process and then it gives few more milliseconds for some other process etc so it will look as if all the clients are getting the service simultaneously so that is what is meant when we say client requests are serviced simultaneously slide 53 these are the non-concurrent server sequence of calls the only thing to note is that  there is a while loop and this loop will service each request sequentially slide 54 the concurrent server uses the fork and in the fork it creates a child process which will now communicate with the client with this we come to the end of this lecture in the next lecture we will discuss the tcp protocol slide 55 slide 56 slide 57 our topic today is tcp  the second most important transport protocol it is very widely used in many applications this is a little more complex than udp but it also has some advantages we will see what they are and look into the transport layer responsibilities slide 58 if you remember the transport layer responsibilities  they  create packets from byte stream received from the application layer  in order to multiplex and demultiplex amongst various applications it uses port numbers to create process to process communications  uses a sliding window protocol to achieve flow control  uses acknowledgement packet  time-out and retransmission to achieve error control so unlike udp which is unreliable  tcp seeks to provide a reliable communication so that it is error free it is a connection oriented protocol and it also has some kind of congestion control mechanism and of course it does the basic thing of making connection between processors amongst two distant nodes possible full duplex communication  this means a is communicating to b and b is communicating to a at the same time even if predominantly only one side is sending data to the other side the acknowledgement is coming from the other side anyway slide 59  the connection can be terminated from both sides but then somebody has to initiate the termination  if connection is terminated in one direction data can continue to be sent in the other direction slide 60 four actions are required to close the connection in both directions let us assume a bi-directional connection that has to be closed  first host a sends a segment announcing connection termination which means it sends the segment contains fin you remember all the syn  fin etc  are the flag segments in the tcp segment header  host b sends a segment acknowledging the request from a after this the connection is closed in one direction slide 61  when host b has finished sending data it sends a segment indicating connection closure  host a acknowledges the request from b  second and third steps can not be combined together because although we are sort of allowing the termination of connection from one side but from the other side he may have acknowledgements or other things to send to this side so he will not terminate the connection so these two can not be combined together the third step can be taken only when host b has finished sending data from its side and it sends a segment indicating connection closure  called four-way handshaking 