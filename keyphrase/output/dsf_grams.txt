structures and algorithms
naveen garg department
department of computer
science and engineering
engineering indian institute
institute of technology
talk about abstract
abstract data types
stacks are implemented
implemented in java
java and application
talk about growable
bit of amortized
talk about stacks
stacks in java
java virtual machine
abstract data type
basically a specification
set of axioms
axioms that define
define the semantics
types like integer
understand the notion
notion of addition
integers in mathematics
define data types
types those operations
parameters that operation
case of integers
integers as defined
defined in mathematics
add a variable
variable of type
method in java
create an instance
talking about sophisticated
sophisticated data types
lot of work
work access functions
type and manipulation
manipulate or modify
modify the data
talking about data
types ? data
identify the requirements
level of abstraction
talking in terms
terms of adding
terms of stacks
stacks or queues
advanced data type
encapsulate the data
data is organized
algorithms that work
separate the issues
issues of correctness
correctness and efficiency
start by giving
giving a simple
set a set
set is defined
collection of objects
modify that collection
add or remove
remove an object
changing the set
create data types
kinds of methods
method to create
create a dynamic
insert an element
element the result
includes the element
similarly the delete
delete method removes
removes the element
methods for updating
updating the set
set new method
creating or constructing
constructing the set
set and isin
true otherwise false
operations should behave
set is empty
define the nature
code for implementing
implementing the dynamic
talking about abstract
axioms that govern
govern those operations
simple abstract data
collection of elements
remove an element
last the operation
operation of inserting
inserting an element
operation of removing
removing an element
kind of toys
elements for instance
stack of trays
put a tray
remove or pop
define the abstract
create a stack
adds this element
type it inserts
inserts an object
pop takes stack
pop the stack
removes the top
stack is empty
flag an error
empty the top
top operation returns
returns the top
pop pop operation
pop operation removes
removes that element
empty then top
make any sense
method size tells
stack and isempty
size and isempty
methods and hope
methods are doing
governs the behavior
push an element
doing a top
stack abstract data
translate abstract data
type into code
interfaces and exceptions
methods are done
names of parameter
write a class
provide the code
write the classes
interface different people
people will write
write different classes
classes to implement
implement the interface
completely different ways
meet the interface
meets the specification
program it helps
separate the implementation
built-in stack data
stack data structure
define a stack
method called size
methods are implemented
takes a parameter
parameter of type
type object object
type in java
objects are derived
type the method
method isempty returns
isempty returns boolean
returns an object
object it throws
notion of exceptions
exceptions void means
return any object
return a stack
modifies the stack
stack thus stack
exception ? exceptions
mechanisms to handle
reach some exceptional
execution of program
throw an exception
exception the term
java is throw
exception is thrown
flow of control
occurs you delegate
delegate the responsibility
responsibility of handling
handling that exceptional
eat pizza method
method which throws
throws a stomachache
stomachacheexception the procedure
procedure public void
public void eatpizza
inside the stimulate
stimulate meeting procedure
stomachacheexception is thrown
exist this method
executed the flow
control would interrupt
interrupt the dotted
modifications are carried
enclose the method
open a bracket
include the method
calling and close
raised in ta.eatpizza
skip the catch
exception was raised
method might raise
raise many exceptions
block and execute
execute the statements
raises an exception
exception is caught
inside the catch
block any kind
kind of statements
write the catch
procedure simulate meeting
throw the exception
throws an exception
catches the exception
high level procedure
finally your procedure
procedure will stop
exception is shown
method to print
print the statement
creating an object
initializing that instance
set of parameters
object by making
making a call
statement is caught
created by stomachacheexception
procedural hierarchy stomachacheexception
stomachacheexception would throw
procedure of simulate
meeting would throw
reaches the console
written would signify
signify in java
java it signifies
invoking the constructor
method for listening
exceptions and catching
exception in turn
add a throws
wrote the method
stomachacheexception a method
method can throw
exception in java
class public class
public class stomachacheexception
class stomachacheexception extends
class name public
constructor method takes
takes a single
string super means
calling the super
catch an exception
chain of method
stomach ache exception
exception is extending
extending a run
run time exception
call the constructor
created the interface
implement the methods
ways of implementing
implementing a stack
stack the variable
push another element
out an entire
interface my implementation
array to implement
implement the stack
stack the statement
implementing the stack
stack interface public
interface public class
public class arraystack
class arraystack implements
arraystack implements stack
implements stack implement
stack implement stack
implement stack means
variable n final
value of capacity
hold the elements
array of object
means the top
call the array
stack whose capacity
call array stack
stack of size
method would return
push an object
stack already equals
throw a stack
stack full exception
put the object
stack empty exception
control would exit
exit from throw
throw new stack
save the top
element in location
removing the top
earlier was set
set to null
remove that object
object and decrement
decrement t to36
return the top
top element pop
pop also returns
null ; return
create an object
dereference the objects
remove those objects
array of objects
access the element
operations were taking
required time propositional
number of elements
stack this upper
creation of stack
stack the problem
waste of memory
run our procedure
procedure to complete
full exception stack
exception stack empty
raise a stack
grow the stack
stack when needed
application of stacks
daily stock prices
price on day
number of consecutive
make it clear
number of days
equal to day
days the price
day five equals
day following picture
picture would make
compute the span
array of numbers
numbers to compute
stock on day
moment you find
find a case
price of stock
stop the loop
done is true
exist the repeat-until
exit the repeat-until
loop if done
span of stock
computing this span
times the repeat-until
n-1 the total
number of times
statement get executed
worst case question
talking of stacks
closest day preceding
price is greater
day preceding day
greater for day
call the quantity
determine the span
quantities ? suppose
told the price
price is larger
larger than price
similarly that day
store the indices
top to determine
compare the price
suppose the price
greater than price
compare with price
first price greater
update my stack
compare that price
stack will give
remove the top
rid of 6th
done becomes true
found a price
current day price
stack becomes empty
statement if d.isempty
times while loop
loop might execute
execute a lot
lot of times
element is pushed
elements to begin
loop is executed
loop gets executed
stack it means
times the loop
inside the for-loop
for-loop if statements
remove one element
elements we pushed
give maximum size
stack can grow
pushing an element
array of length
increase the size
stack i increment
increment the top
increment the size
double the size
push the element
takes one unit
create a larger
stack and copy
copy the elements
form the earlier
created a stack
elements that cost
cost n units
element that cost
unit the total
special push operation
tight strategy behaves
initially i started
array of size
push this first
enlarge my stack
cost one unit
push the 3rd
3rd and 4th
push which costs
create an array
incrementing the size
operator in phase
cost of phase
beginning of phase
copy the previous
cost of copying
copying the elements
array gets filled
doing the total
doing c pushes
phases total cost
cost of phases
creation as order
case the analysis
analysis would change
purposes of analysis
creating an array
element i create
double this array
push this element
array and create
push while pushing
push the 5th
size of array
copy these elements
analyze the cost
cost of creating
creating the array
cost for pushing
created an array
array of cost
cost of pushing
pushing we created
pushing the element
define a phase
call it phase
array has size
elements are left
left after copying
elements ? elements
elements the total
log n phases
array is growing
strategy data structures
queues and linked
lecture we looked
looked at stacks
list and double
double ended queues
last-in first-out principle
principle whoever joins
joins the queue
queue for instance
element is inserted
element from queue
front is removed
removed the queue
queue the methods
operations the method
create a queue
queue and enqueue
method to add
add an element
queue and dequeue
dequeue a queue
differ from dequeue
remove the front
implement the queue
queue and isempty
queue is empty
define similar axioms
axioms for queues
element or enqueue
enqueue an element
suppose i create
dequeue an element
enqueued an element
means i added
added an element
added another element
front of queue
notion of front
removed an element
element the element
queue was empty
result is true
first i added
cases the queue
procedure if queue
thing in enqueue
dequeued which means
means i removed
removed the front
element of queue
queue the queue
implement a queue
fashion to implement
suppose someone tells
allocate an array
element the blue
reach the blue
blue colored part
element i inserted
delete the elements
effect the elements
element has moved
moved to right
right this implies
deleted f-1 elements
inserting the elements
elements in queue
queue i insert
insert another element
insert anymore elements
reached the end
elements your queue
started the front
front was referring
point i reach
reach a situation
empty or full
empty ? suppose
removing the elements
elements before location
adding the elements
move one step
close to location
add the element
empty and full
n-1 one elements
code for enqueue
queue is full
return the queue
queue full exception
case then add
add the rear
put the element
insert and increment
modn is required
enclosed in brackets
r-f ? r-f
r-f is negative
check this out
means the queue
return a front
removing the front
case of dequeue
increment the front
index and remove
element by setting
implement our queue
queue the disadvantage
array is fixed
essentially a linked
list the first
node is referred
tail of list
list to implement
queue the head
2nd second element
remove the torcezo
element the linked
element from linked
remove that element
accessing that pointer
remove the rome
queue the removal
remove the element
implement our methods
dequeue which means
left head part
point the head
making the head
delete the head
node and make
make the head
node thus inserting
easy the head
move the head
queue the pointer
modified to point
newly added element
difficult to remove
element in constant
remove the tail
access the previous
kind of list
beginning and move
problem in removing
last before node
make the tail
head and add
means the front
queue data type
introduce another data
type called double-ended
insert and delete
queue and remove
operations of insert
singly linked list
idea to implement
doubly linked list
implement double-ended queues
list has nodes
two sentinel nodes
nodes each node
operations of double-ended
queue in constant
delete the node
end the head
follow the pointer
element to delete
delete that node
port and set
pointer to trailer
trailer and send
send the previous
pointer of trailer
header and trailer
list these nodes
nodes or dummy
mark the start
delete san francisco
make the sentinel
sentinel node point
make that previous
node to point
node is deleted
done in constant
front or delete
meant by constant
independent of number
fairly generic data
generic data type
implement other data
types also suppose
implementation of double-ended
make a stack
implementation to implement
implement a stack
stack for instance
stack would correspond
return the last
queue the method
correspond to inserting
double ended queue
correspond to deleting
make the last
case the last
front and insert
corresponds to isempty
queue to implement
corresponds to last
removes the first
methods to implement
stack or queue
pattern thus adapter
adapter patterns implements
implements a class
class using methods
class in general
adapter classes specialize
classes specialize general
specialize general classes
implement by changing
changing some methods
queue another application
stack we define
define an interface
interface called stack
stack and implemented
array that implementation
contents of array
adapt arraystack implementation
implementation called integerarraystack
cast the type
stack or removing
circularly linked list
element is pointing
head and tail
implement both queue
structure to implement
make the first
make the pointer
make the element
node and create
node and copy
copy the element
node and copying
corresponds to removing
removing the first
remove the first
problem in doing
remove the 2nd
copy the contents
seattle to rome
rome thus rome
rome has seattle
2nd node copying
copying just means
changing the reference
discusses about queues
queues and double-ended
talk about vectors
list and general
structures like arrays
arrays and linked
lists to implement
implement these data
vector data type
type ? vector
elements that supports
notion of rank
sequence of elements
methods like elematrank
elematrank r rank
rank here corresponds
integers first element
element at rank
give the element
replace the element
delete the element
suppose the departmental
department the department
implement the data
type using arrays
element with rank
put an element
n-1 one step
n-2 is moved
moved one step
right finally element
put at position
size is increased
sores the size
shifting the entire
elements one step
left all elements
sitting at location
case ? order
left this implementation
implementation is expensive
point of view
two operations insert
rank or remove
worst case spent
case spent order
operations are faster
array and retrieve
retrieve the elements
sitting there replaceatrank
location and replace
replace that element
element with element
methods all methods
methods except inserted
inserted at rank
rank and remove
remove at rank
rank take constant
implementing this list
implement a vector
node and put
create the node
make a pointer
make the previous
previous pointer point
insert takes order
order n times
insert at rank
insert the element
code for inserting
assuming the existence
insert the node
node at rank
call the procedure
procedure with rank
previous to rank
prev i create
set its previous
prev = next.getprev
earlier at rank
manner i create
check the previous
doing here next.setprev
process of deletion
out the node
node and update
pointer will point
node and previous
code for doing
assuming the procedure
implement this procedure
incrementing my counter
reach that rank
list has hundred
point to start
vector abstract data
type is concerned
rank or insert
move the elements
insert or delete
delete linked lists
supporting node based
node based operations
delete this node
node in constant
node and insert
delete the inserted
insert a node
constant time operations
mentioned below removeatnode
give you access
implemented my list
pointers and stuff
node based operation
operation without knowing
knowing the actual
thing was done
notion of positions
captures the place
element is stored
data type position
call this method
making much sense
position as reference
pointer to update
node is implemented
type which hides
notion of position
order of positions
position is referring
similarly 1st position
define a list
list abstract datatype
methods like size
method which asks
methods like first
first will give
last would give
methods like swapelements
swaps the contents
positions it swaps
element at position
methods in constant
linked list data
list data structure
abstract datatype implementation
datatype this datatype
double linked list
sequence abstract data
type we talked
list data type
combines the vector
list abstract data
listed for vector
vector and list
two additional methods
methods which helps
identify the rank
determine the position
suppose you gave
gave me rank
follow 1st reference
create new position
element would sit
change the ranks
ranks and update
update the position
position again inserting
deleting an element
wanted to delete
delete an element
comparison of sequence
implement a sequence
case of running
out the element
update the pointers
out the rank
list to figure
rank any rank
rank based operation
find the rank
out the position
learnt about queues
essentially a concretization
looked at sequence
sequence data types
data type data
type data structures
dictionary abstract data
search is done
analysis for binary
hashing is done
collision resolution techniques
type that stores
located very quickly
store bank accounts
account has lots
lots of information
access the bank
account or data
account stores wealth
wealth of information
list of transactions
last few days
key a dictionary
stores the elements
talk of key
number that helps
information any application
application that wishes
kind of operation
provide the account
number as key
key the process
basically an abstract
store the key-element
pairs the key
key your entry
identifies particular student
dictionary is searching
searching by key
kinds of method
standard container methods
queues and stacks
dictionary is empty
find the element
kind of settings
return all elements
remove all elements
remember the notion
special element nil
search it means
return a nill
comparison of keys
keys for equality
two particular keys
doing is searching
notion of taking
taking two names
smaller or larger
operation we require
require is comparing
implementing this abstract
implement a dictionary
implement this dictionary
predecessor or successor
completely arbitrary manner
manner the nodes
throw them arbitrary
red or black
mechanisms of data
structures to implement
important data type
lectures in java
class called java.util.dictionary
java.util.dictionary which lays
out the specification
interface called java.util.map
problem of searching
sequence of numbers
database i give
return the position
number or nil
sitting at position
technique called binary
recall the technique
search is divide
divide and conquer
problems in divide
divide and search
range of elements
suppose the elements
increasing or decreasing
decreasing for binary
search to work
set of elements
order this means
low and high
element which means
compare the middle
return this information
search the procedure
read and understand
understand this quickly
notion of low
range and high
end and high
end if low
basically that means
invoking something wrong
return a null
obtained by taking
taking the average
average of low
high and check
found the key
array the left
staring location low
ending location mid-1
array which means
means the mid
high else return
search for small
pieces of code
write an iterative
low to begin
high to begin
loop and updating
high and low
first step low
low becomes mid
element was larger
element is smaller
element then high
find the key
return the location
key or low
low becomes larger
larger than high
loop and return
write a binary
two different ways
problem is halved
essentially the range
comparison the range
log n comparison
roughly require comparisons
location you desire
desire in constant
write any base
base for log
suppose the numbers
array one element
compare your key
element you searched
spend some order
array is sorted
huge difference coming
sort the element
element to begin
small pseudo code
asked to implement
implement a caller
caller id facility
large phone company
making the call
return the callers
case in delhi
delhi the range
range of phone
million phone numbers
numbers the number
numbers are present
actual different number
element ? suppose
decides to give
remove it searching
searching itself takes
removing also takes
thing in order
putting the elements
location thus inserting
implementation is good
things is faliable
maintain log files
maintain some kinds
kinds of log
file for instance
instance any kind
kind of transactions
revert the transaction
system and maintain
maintain the log
search or removals
frequent but searches
searches and deletion
case this implementation
good because insertion
takes only constant
remove and insert
operation being performed
decide what type
type of data
implement the dictionary
dictionary data type
elements were put
key searching takes
searching takes log
log n provided
kind of direct
direct access mechanism
element you wanted
inserting and removing
maintain the sorted
move it back
examples in previous
insertion take order
order n elements
recall your big-oh
lot of searching
insertions and deletions
array and put
position which corresponds
corresponds to ankur
ankur phone number
number all operations
search and delete
insert a caller
caller id capability
wasting a lot
lot of space
operations very quickly
space is turning
two much space
create a smaller
users to locations
number of users
fancy i create
compute this value
ankur at location
insertion and delete
numbers but entry
numbers of students
class your entry
numbers is huge
set of values
create a table
table of size
spend more space
function this function
previous example mod
takes the last
mapped to location
clash ? suppose
delete and search
address the problem
problem of clash
address this issue
keys which mapped
concept called chaining
ways of addressing
addressing this issue
issue and today
technique called chaining
blue color thing
put the elements
linked list starting
linked list suppose
suppose my hash
taking the key
key and computing
keys were mapped
keys getting mapped
mapped to locations
problem of collision
resolved the collision
things in constant
keys get mapped
data structure reduces
delete still insert
insert has constant
person who sits
examples of hash
kinds of hash
typically used hash
functions the last
regarded as modulo
function to find
find the position
search or insert
maintain the list
order then insertion
unordered then insertion
end of linked
traverse the entire
list to reach
reach the end
maintaining one pointer
pointer to add
notion of order
notion to order
order the elements
elements an element
element with key
value of hash
function the hash
function is mapping
mapping the universe
compute the hash
simple arithmetic operations
operations to compute
compute the value
function is independent
choice of hash
functions are concerned
choices of hash
hash function lot
lot of research
research has done
function that people
motivate the concept
good hash function
distribute the keys
keys to location
structure would start
single linked list
function which distributes
list is small
ideal hash function
pick at random
locations then throw
throw the element
function which takes
takes a key
key and puts
takes the element
element and throws
simple uniform hash
uniform hash function
number of slots
call this load
load factor alpha
search is unsuccessful
element i computed
computed the value
entire linked list
spend time propositional
computing the hash
hash function takes
function takes constant
right linked list
pointer by pointer
simple hash function
distributing the things
table the excepted
roughly a constant
ideal hash functions
create a bad
bad hash function
spent in computing
data structure relies
function we choose
good hash functions
class designing hash
designing hash function
art than science
data to design
design a good
class some principle
kind of hash
make a successful
find my element
ways of arguing
database the element
case of successful
successful search excepted
search excepted number
element was inserted
inserted and appended
compare that element
number of comparisons
hash function computation
roughly the excepted
excepted time required
required to insert
summing this quantity
elements and taking
average time computations
list or find
half the length
kind of behavior
low order term
successful and unsuccessful
taking a similar
pick the size
size of hash
size our hash
table should start
concept of growable
structures you start
elements you inserting
sizes of linked
move the entire
set of element
larger hash table
modify these things
design your hash
hash function keeping
keeping in mind
number of hash
hash table slots
slots was propositional
pick the number
table can accommodate
accommodate any number
attach any number
table would deteriorate
10,000 elements coming
average the linked
linked list length
case it make
sense to move
create a hash
wastage of space
small hash table
large hash table
bit of hashing
continue with hashing
hashing c concepts
concepts of good
ways of resolving
resolving collision data
collision data structures
continue our discussion
discussion on hashing
concept of hashing
collision in hashing
hashing using linked
list that method
method of collision
methods for collision
probing and double
performance of hashing
linked list good
list good hash
paradox called birthday
compute that probability
fairly high probability
kind of thing
thing is happening
key and put
keys would end
deal with non-integer
keys in fact
keys were telephone
returned the telephone
numbers with hyphen
treat telephone number
dropped the hyphen
techniques of converting
converting non-integers keys
hash function value
converting non-integer keys
keys into integer
integer ones hash
hash code map
function a hash
basically a mapping
mapping of keys
keys to indices
table your hash
maps the key
integer keys key
key ? integer
bring this integer
table that part
call as compression
kinds of functions
map and compression
map another important
requirement of hash
key gets mapped
map a key
maps to location
kind of randomization
retrieve or search
map equal keys
minimize the probability
probability of collisions
popular hash-code maps
maps the hash-code
part which converts
converts your key
integer one thing
pattern and interpret
reinterpret the bits
integer your key
double real number
number which takes
bits and add
bytes and add
kind of tree
integer one possibility
number of collisions
collisions be high
kind of things
convert character strings
integer one technique
polynomial whose coefficients
evaluate this polynomial
string that integer
map to map
convert a string
people have looked
technique to convert
convert your words
table one natural
taking some integer
essentially that means
taking the last
write the integer
taking some small
set of bits
simple compression map
fact it helps
strings per location
list one important
hash table close
kind of effect
effect will start
prime number things
lot of collisions
collisions happening lot
follow will improve
improve the performance
necessarily a prime
kinds of compression
first i read
out the 2nd
suppose your keys
recall now assuming
keys are integers
map to convert
integer the keys
range through times
multiply each key
first we converted
key that corresponds
multiply that number
function which means
rounded that number
key and multiplied
popular compression map
ways of doing
case the choice
thing that happened
done a lot
lot of jugglery
first we multiplied
smaller fraction part
experimental without significant
book by ronald
knuth on sorting
sorting and searching
searching which covers
covers hash functions
functions in detail
numbers then compute
avoid any kind
kind of patterns
random number generator
random number generators
generators are based
technique called linear
linear congruential generators
generators they start
seed that seed
initial k value
compute this quantity
function will give
give random number
value you return
last random number
random number generated
generate random number
number such numbers
pseudo random number
technique called universal
idea i pick
set of keys
make life difficult
spend a lot
deletion and searching
searching one solution
bunch of hash
function to put
put the keys
function for inserting
doing the search
hash table implementation
change the hash
invoke this program
set of hash
doing my implementation
collection of hash
keys the probability
function is concerned
put a linked
delete by doing
doing that operation
today which fall
class of open
open addressing differs
differs from chaining
key fact recall
recall in chaining
list the table
storing the pointers
hashing could map
elements as larger
list each entry
null which means
searching or inserting
inserting or deleting
probe the elements
modifying the hash
keys are picked
picked our hash
mapping the keys
earlier this part
case of chaining
insert the key
location is occupied
find an empty
techniques the hash
sequence of slots
set which specifies
specifies the collections
collections of keys
technique under open
location so probe
probe is incremented
location the mod
beginning your question
retrieve the keys
element already sitting
find the empty
location one advantage
memory in chaining
track of references
space is wasted
technique might end
slower than chaining
function my keys
insert these keys
point the table
table was empty
problem in inserting
table is empty
location is empty
empty we put
locations are occupied
occupied we check
elements are sitting
technique the elements
tend to aggregate
locations while searching
inserting those elements
searching for key
compute k mod
reach an empty
location that means
means the element
location and search
search the element
found the element
location till 11th
location the element
empty this means
search the search
search will terminate
finds the element
8th location suppose
suppose i removed
setting this location
location to null
null i removed
idea ? suppose
last we reached
reached the empty
set this location
mark this location
setting this 8th
place a tombstone
location which specifies
location was occupied
encounter a tombstone
search is ended
encounters a tombstone
tombstone it ignores
ignores and continues
reclaim this space
lot of tombstones
rehash just remove
elements and put
grow the table
growing the table
create empty slots
performance will increase
open addressing techniques
techniques we looked
looked at linear
piece of code
probe is set
offset is set
probe + offset
set to probe
offset which means
offset + offset
offset is determining
probing your offset
location i jumped
jumped one location
double hashing works
technique will ensure
table in linear
table where empty
divides the size
happen in fact
back and prove
advantages and disadvantages
disadvantages as linear
makes the performance
2nd hash function
place were occupied
insert the first
occupied i compute
occupied we compute
analysis of double
double hashing recall
inside the hash
random the first
pick a random
half that means
means the number
table is half
half which means
half the table
table is occupied
occupied and half
suppose my search
unsuccessful search stop
table is full
empty the expected
number of probes
hit an empty
fraction of table
excepted sense probes
probes are required
location and declare
numbers of probes
searches ? successful
search are searches
required ? suppose
suppose i search
class the average
insert those elements
location again suppose
suppose i begin
first elements size
talking of inserting
inserting the first
hit a full
insert this element
average even required
required for inserting
inserting these elements
average the total
insert this last
location to put
put this element
probes to insert
insert these elements
elements is times
insert the last
average i require
table was full
full one quarter
recall from previous
locations are empty
elements what fraction
inserted enough elements
basically minus log
point i require
fraction was empty
unsuccessful and successful
trees last class
class we discussed
discussed about hashing
double hashing linear
hashing linear programming
bit of analysis
resolution techniques today
talk about trees
structures for trees
notion of parent
parent and children
parent of node
hope you understand
understand the difference
difference between ancestor
ancestor and grandparent
children of node
great grand parent
ancestor the terms
terms we defined
tree a leaf
node we associate
associate a notion
notion of level
depth and level
thing the level
number of children
leaves have degree
children basic terminologies
represent the hierarchy
organization for instance
manufacturing is division
domestic and international
represent the organizational
tree to represent
represent the table
table of contents
book called student
chapters on overview
programming and support
code the chapter
sections called exams
homework and programs
node are ordered
ordered that means
put the left
right side suppose
draw a family
draw the eldest
move from left
left to right
reflect that order
place the left
make any difference
picture is concerned
convey any additional
notion of left
children the diagram
tree the root
child the node
children these nodes
1stlevel are ordered
change the tree
draw the left
order has meaning
ordered binary tree
change the order
define a binary
construct any binary
node and attach
attach a left
subtree through recursive
taking a node
node and attaching
and which means
means this left
introduced other terms
subtree the node
node would correspond
operations in fact
evaluate this expression
draw a tree
tree whose root
build this tree
representing arithmetic expression
arithmetic expression decision
expression decision tree
book star bucks
caf ? paragon
make much sense
decision tree corresponds
meal the answer
follow the decision
terminology and examples
define a complete
complete binary tree
tree we call
call a tree
tree every node
leaf that means
means every internal
node the root
maximum level number
tree that means
nodes that means
leaves the number
number of leaves
tree of height
number of internal
number of leaves-1
number of nodes
call this number
expression the number
nodes are leaves
doing some simple
tree is log
tree the number
half the total
node has atmost
suitably large complete
large complete binary
tree as shown
side as height
left just cut
side the picture
obtain any binary
tree at level
tree is obtained
tree by pruning
nodes at level
level i implies
nodes the last
nodes that binary
rewrite this suppose
suppose i told
height is atleast
tree which achieves
achieves this equality
tree which acquires
acquires the smallest
create a binary
nodes as close
tree i give
minimum possible height
nodes has height
height atmost n-1
nodes the minimum
height is log
height is n-1
mistake many people
assume that binary
binary tree means
tree means height
figure it out
nodes or atmost
atmost the number
leaf base case
case the right
right hand side
inequality is satisfied
statement is true
k-1 internal nodes
true for trees
trees with atmost
atmost k-1 internal
internal nodes suppose
node the minus
apply the induction
equal to k-1
subtree the number
subtree the total
wanted to prove
started a tree
proof which shows
shows the number
leaves is atmost
leaves is equal
nodes the complete
achieves the equality
sum how small
nodes is greater
half the number
trees are dry
leaves that tree
type for trees
generic container methods
tree is empty
position based container
based container methods
list or sequence
types the swapelements
positions as references
position data type
position the method
sequence the positions
node the swapelements
swapping the elements
replacing the element
external or leaf
correspond to leaf
leaf in accessor
return a position
object of type
type position isroot
root and root
returns the position
reference of type
earlier the method
returns the parent
node the children
returns the children
return a sequence
sequence of object
object type sequence
access the data
data the update
typically application specific
tree binary tree
child or give
kinds of data
reference to key
key or data
sense for instance
access the left
child by invoking
invoking the left
left child method
invoke element method
implement the position
diagram the extreme
extreme right node
right child member
referring to null
care of arbitrary
trees the root
1of the child
list each child
reached the last
node is empty
children every node
left most child
sibling the left
references the node
sense of left
right makes sense
written left child
written 1st child
access its siblings
children throughout linked
end our discussion
discussion on binary
binary trees today
reversals of trees
trees data structures
class we looked
looked at definitions
definitions of trees
discussion on trees
walk or tree
traversals a tree
visiting the nodes
visit or process
process each node
process its children
children or visit
process the node
examples of preorder
preorder tree walks
tree walks suppose
walks suppose recall
construct a tree
abstract which discusses
publication has referenced
read the paper
reading the paper
end to end
read the abstract
book are listed
tables of contents
contents are listed
chapter are listed
tree the first
referring or accessing
tree the pseudo-code
pseudo-code for preorder
call preorder traversal
visit the node
doing some computations
out the book
book as table
contents then visit
visit would correspond
correspond to print
print the title
title or print
print the heading
node for instance
instance each node
visit ? node
nodes and repeat
repeat the process
node then visit
visit the first
corresponds to visit
visit that node
visit its children
traversal i gave
reading a document
document from beginning
beginning to end
post order traversal
order traversal recall
root directory courses
file called grades
directory structure suppose
compute the total
total space occupied
center to obtain
obtain the total
total spaces required
visiting the node
center or doing
doing some computation
done the computation
computed the total
doing the node
doing a post
perform a post
post order corresponds
corresponds to finding
finding the total
total space required
sense the order
computation is done
done is reverse
disk usage command
command in unix
directory it tells
type the disk
out the total
end it list
left and right
child and fourth
child is visited
drawn the tree
drawn your trees
traversal in general
visit the children
nodes in postorder
postorder first visit
visit the nodes
case of binary
first saying visit
first say visit
pre order traversal
right child note
work by making
doing a preorder
difference between pre
order and post
visit a node
out the contents
doing a pre
left sub tree
tree and first
corresponds to printing
printing the content
node here means
printing the contents
tree is null
right sub tree
tree because first
traversal of right
tree which means
means first visit
entire sub tree
done the post
side and post
print the node
ready to print
print the content
print this content
print this node
means just print
print the root
evaluating arithmetic expression
evaluate the expressions
right a procedure
evaluate the expression
return the variable
value the leaf
corresponds to numbers
evaluate the left
return that value
value of expression
addressing that problem
problem of generating
generating this tree
incorporate the priority
rules to generate
kind of traversal
traversal so recall
traversal we visited
visited the node
tree so pseudo
first go left
understood inorder traversal
printing c out
sub tree inorder
tree inorder traversal
entire inorder traversal
traversal of left
traversing a tree
euler tour suppose
expression the tour
drawn in blue
hit a leaf
post and inorder
eulers tour traversal
traversal each node
basically getting visited
touching this node
touch any node
node of degree
print this arithmetic
out with parenthesis
draw the parenthesis
walk to print
print this thing
print a left
print the right
bracket this right
right subtree corresponds
corresponds to taking
taking this path
out the content
node was visited
touch the node
print left bracket
touch this node
print another left
left i print
brackets to begin
print a star
out this arithmetic
kind of euler
write a generic
method for tree
postorder or inorder
traverse a node
node an external
method you invoke
invoke this method
method called left
continue with right
create the traversal
traversal of choice
specialize this binary
binary tree traversal
generic tree traversal
class which means
right are left
class you leave
leave certain methods
create a sub
class which specifies
specifies these methods
specializes this generic
tree traversal procedure
class for printing
printing out arithmetic
out arithmetic expressions
usage we wanted
wanted to compute
directory we computed
computed the space
child we computed
stored in r.left
result and r.right
compute their sum
printing arithmetic expression
position just print
touch a node
out a left
out the left
print that out
out the right
bracket the printexpression
extending binarytree traversal
invoke the traversal
out the arithmetic
expression in parenthesized
class binarytree traversal
specializing these methods
slightly different manner
discussion on pre
suppose i give
preorder and inorder
necessarily the root
tree and blue
managed to identify
tree whatever argument
tree i figured
traversal and inorder
problem recursively reduces
require some thought
compute the post
computed the tree
give the result
out an error
pre and inorder
pre and in
order given post
compute the tree
tree ? recall
postorder the last
root so first
find that root
divides the thing
right sub trees
pre and post
determine the tree
order traversal preorder
suppose i gave
traversal and postorder
tree with preorder
post order traversals
order to determine
draw the root
basically it means
managed to divide
drawn the root
case of preorder
forms the right
forms the left
tree the left
case of postorder
tree has nodes
drawn that out
remains the left
level in fact
tree every internal
similarly for post
count the number
number of binary
lots and lots
lots of things
compute the close
close form expression
ways of traversing
traversal for binary
traversal for general
visiting the first
first you visit
visit the left
visit the right
preorder and postorder
traversals data structures
dictionaries in today
talking about ordered
binary search tree
implementing an ordered
dictionary functionality recall
functionality recall dictionary
key element pairs
notion of predecessor
talked about hashing
hashing and dictionary
compare two keys
student and professor
predecessor and successor
predecessor as taking
key so predecessor
key which precedes
keys in dictionary
dictionary s give
precedes the key
part of data
things are ordered
similarly the successor
two trivial ways
kind of data
dictionary ? successor
relation the order
thing to find
smallest key larger
successor and predecessor
predecessor and min
min and max
fairly an efficient
implementation an ordered
ordered the thing
constant time maximum
successor also takes
predecessor takes constant
give the node
reach that node
compute the successor
predecessor in constant
constant time inserting
inserting also takes
out the correct
position for insertion
insertion searching takes
searching takes order
searching can improve
ordered i put
search to find
element in log
insertion and deletion
place to insert
similarly for deletion
recap what binary
remember binary search
search to search
make a comparison
comparison the size
making the search
search ? halves
searching recall insertion
ways you adopt
adopt to implement
implement an ordered
talk about trivialities
binary tree binary
children a node
children no children
discussions that follow
binary search property
tree all keys
tree are larger
nodes have keys
keys which satisfy
satisfy the search
search property satisfied
tree so binary
tree plus search
search property equals
property equals binary
equals binary search
kinds of trees
binary search trees
binary and satisfy
conversation between professor
professor and student
implementation keys stored
couple of features
keys are unique
suppose your key
define total order
order of names
lexico graphic order
order or alphabetic
key is equal
assume the keys
unnecessarily complicates matters
root i compare
search property keys
done we found
find an element
child is null
write the search
procedure for binary
simplest to understand
nil which means
root or empty
return the root
begin with refers
key is larger
make recursive calls
continuing the search
dot left child
code just showed
left x pseudo
continue this search
started at level
number of levels
nodes whose height
height is order
kind of situations
large the search
order the height
finding the minimum
left most tree
tree ? left
left most node
node or left
left most leaf
leaf ? left
left most leafs
smallest one smallest
node expect left
node also doesn
sense last leaf
node ? last
last internal node
node without left
create more internal
give the half
half a sentence
give a procedural
find the smallest
smallest ? start
left till left
left becomes null
left is null
right becomes null
find the minimum
return the key
return the element
modification to compute
compute the maximum
replace the left
left by right
complete the maximum
tree ? successor
understand what successor
means ? successor
key after find
find the node
smallest key greater
greater than key
key sub tree
tree is non-empty
tree it exist
successor be lying
lots of confusion
draw this picture
sheet of paper
out the successor
parent is larger
elements slightly larger
node and proceed
tree the successor
essentially be minimum
procedure for completing
completing the minimum
tree is non
right one step
sub tree suppose
reach the node
successor you understand
understand the procedure
recall the procedure
node the right
reach an ancestor
node whose successor
find the largest
guy this ancestor
ancestor is greater
write for computing
computing the successor
return the minimum
stop the first
doing is moving
moving the pointers
takes the value
value of parent
moves one step
pair of pointers
null that means
return we return
node in case
case y hits
code and convince
code ? order
looked at search
tree we looked
looked at minimum
looked at maximum
looked at successor
essentially interchange role
role of right
right and left
care of deletion
class so insertion
insert an elements
out the place
assuming distinct keys
assuming that node
node to elements
right is null
point the search
hit a null
pointer and null
reference we put
put the node
inserting the keys
search tree suppose
insert those keys
create the chain
similar would happen
compare and put
suppose i insert
level by level
insert these nodes
insert later nodes
tree ? height
height balanced trees
height balanced tree
full binary trees
binary tree provided
operations were depended
tree the smaller
smaller the height
faster the operation
height as small
small height tree
bad order suppose
understand the random
factorial different permutation
random and insert
talk of random
variable you understand
random variable means
means ? variable
variable which takes
address this kind
code for insertion
insert this node
inserting a node
inserting this node
hit this null
child a left
essentially parent pointer
parent pointer parent
parent so parent
sequence the insertion
worst case sequence
stop our discussion
asked you today
start with deletion
minimum and maximum
search tree today
address the question
permute my elements
elements and insert
case for deletion
fairly straight forward
children then deletion
deletion is trivial
cut this length
length which means
set the right
set the left
child to null
problem is trivial
child the operation
delete a node
make its left
left child point
establishing the link
maintain the search
deleted the node
tree we find
find the predecessor
essentially the predecessor
violated by moving
moving the content
property is concerned
delete b easily
subtree and suppose
suppose i decide
decide to move
make the right
node the node
move the content
find the successor
shown the predecessor
operation ? suppose
takes to delete
update the link
giving the reference
parent and update
update the content
content to show
show the deletion
deleting the node
parent and modify
modify its left
constant time operation
find a predecessor
case time proportional
pseudo-code for deletion
right is nil
understood the delete
made some mistakes
skip this thing
first the left
node is print
out the key
out the keys
print the key
right this means
out the root
right are greater
left which means
print out things
print the keys
keys the property
keys in increasing
method of sorting
sorting a bunch
bunch of keys
search tree base
tree base sorting
base sorting procedure
keys and inserting
sorted a set
in-order tree work
traverse the nodes
tree in in-order
bst sorting procedure
sort the keys
takes to insert
set of numbers
insert this numbers
numbers is equal
place the number
levels i traverse
level either level
level or level
inserted the numbers
numbers in sorted
first i inserted
remember that kind
tree some thing
sum of levels
series which sums
backs the question
factorial different permutations
random i insert
insert the elements
required for insertion
variable it depends
elements in fact
first element inserted
insertion the total
variables we compute
random variable recall
random variable takes
variable is obtained
trials which means
compute the expectation
uniformly at random
compute the average
order and compute
3rd permutation compute
insert the keys
average the average
average is computed
denote this quantity
permutations of elements
elements are inserted
right when elements
1to the left
left when elements
nodes the levels
5th and 6th
permutations the tree
permutations and restrict
restrict our attention
permutations these keys
permutations of keys
permutation will occur
symmetric of law
elements is occurring
occurring exactly times
computing the total
previous setting recall
subtree each key
creating a left
subtree their level
round in blue
inside the triangle
triangle in blue
create this tree
creating a tree
nodes the keys
keys are coming
spending in creating
creating this part
first i compare
tree and level
permutations ? recall
creating am taking
taking one unit
taking to insert
spend in inserting
permutations is appearing
number of keys
elements are present
insert n keys
n-1 this part
relation the function
expressing the value
function at point
values at previous
relation to compute
lets also compute
recurrence to compute
obtained some kind
relation which tells
solve this recurrence
times the sum
rearrange this quantity
quantity or times
times this sum
equation were times
rearrangement to simplify
1.i just simplify
done is replacing
quantity gets decreasing
inside keeps increasing
summing a harmonic
drawn a line
atmost the area
computation we looked
log n recall
permutation which puts
puts the elements
elements in increasing
height atleast log
level has keys
leaves ? log
insert the leaves
taking n log
cases and report
trees have depth
times n log
bunch of numbers
permutations the smallest
numbers are closer
log n times
log n data
quick sort today
talk about quick
series of lectures
lectures the first
argued a worst
worst case running
today the quick
quick sort algorithm
average it takes
place ? sorting
require any additional
typically good thing
sort a large
collection of numbers
numbers this algorithm
lot of divide
idea behind divide
solve you divide
divide the problem
pieces you solve
solve the problem
pieces the divide
case of quick
partition our array
array which stores
numbers and partitioned
call the higher
part the property
sort the lower
sort the higher
put all elements
thing is sorted
sorted the lower
sorted the higher
partition is done
give an algorithm
linear time procedure
partitioning is done
partitioning it takes
takes the parameters
partition the sub
true which means
reach a location
reach a locations
reached a location
means just swap
swap these contents
swapped these contents
part and orange
swap these things
things i swapped
means our job
job is done
means they crossed
exit which means
return the procedure
returning the value
times the size
loop is done
utmost n times
increment or decrement
taking the pivot
compare every element
pivot and put
first few locations
require more memory
copy that array
additional memory space
partitioning in in-place
repeat until loop
times this step
step is executed
executed is order
complete quick sort
sort on lets
call for quick
find the partition
invoke the previous
rearranges the part
returns the demarcating
upper half separately
recursively invoke quick
invoke quick sort
condition is met
entire partition procedure
call quick sort
copy the array
create more copies
creating additional copies
taking any additional
array what element
understand the quick
partitioned the array
sort this left
sort this right
solve the left
write a quick
quick sort procedure
quick sort takes
partition procedure takes
procedure takes order
sort will depend
split is happening
sort is taking
dividing the array
two equal halves
halves which means
means that half
half the elements
half elements ended
picked a pivot
two equal parts
divide this array
procedure took order
drawn am taking
tree of mine
order n log
means i decreased
utmost m times
writing the recurrence
sort n elements
procedure was quick
sort the left
left part lets
sort the right
essentially become theta
theta is bothering
input is sorted
sorted already lets
case would happen
sorted in ascending
happen similar kind
happened in insertion
sort in insertion
recall in insertion
taking an element
element and figuring
place to put
put that element
end to find
sorted in decreasing
array was sorted
sorted in increasing
move back anymore
anymore every element
takes constant amount
comparison with insertion
increasing or sorted
elements change out
change out suppose
call this lucky
side one tenth
similarly the total
level will continue
number is smaller
level is decreasing
decrementing by half
log n base
out the math
constant times log
taking a total
levels is log
providing an upper
manner one tenth
spectacular or special
fraction of numbers
end up taking
taking n squared
fraction one tenth
millionth the height
formal analysis starting
suppose we alternate
alternate the lucky
lucky and unlucky
prove a log
log n depth
operations or comparisons
comparisons i managed
managed to split
side and lets
half and half
find a median
median element pick
pick the median
element ? sort
sort the numbers
find the median
place so finding
finding median element
procedure for doing
clear-some what close
median by dividing
number of small
array then sorting
arrays of size
log n steps
compute a median
element in linear
fairly an involved
element and declare
pick a specific
pick the last
order or increasing
call a randomized
making some kind
kind of random
analyze the running
randomized quick sort
assume all elements
elements are distinct
distinct we partition
element a pivot
pick any element
element at random
kind of splits
picked with equal
pick the tenth
tenth smallest element
versus n-10 split
probability of picking
picking the tenth
picked any element
11th smallest element
12th smallest element
element the probability
examples of randomization
tool for designing
modify the partitioned
procedure and call
call it randomized
partition the array
array between locations
generates a random
recall was taking
put my pivot
exchange the pivot
call my partition
randomized partition procedure
partition it calls
calls randomized partition
choice of pivot
pivot is crucial
choose the pivot
difference between random
lets say increasing
picking a random
element to partition
sequence as input
happen that today
today you run
run the algorithm
tomorrow you run
numbers are selected
random numbers selected
numbers selected decide
decide the pivot
crucial in deciding
splitting the things
pivots were turning
inputs ? sequence
sequence of random
numbers is generated
fix an input
change the input
today and tomorrow
tomorrow and day
sorting that specific
specific input sequence
denote the expected
required by quick
required to sort
sort n numbers
numbers will depend
recall what quick
sort does quick
sort first partitions
partition n numbers
numbers no matter
number is compared
pivot are put
require n-1 comparisons
comparisons every number
side and n-i
sort those n-i
taking to quick
sort the n-i
basically this sum
compute expectation expectations
forgetting your expectations
roll a dice
throw a dice
variable ? random
dice this random
random variable lets
variable lets call
random variables takes
values each value
takes the probability
throwing this dice
recording the outcome
outcome keep doing
doing this forever
suppose you threw
threw this dice
sufficiently many times
times your outcome
value one times
takes the random
two so probability
thinking of expectation
variable is taking
taking a set
set of discrete
times the value
taking this value
quantity also varies
means every term
write this part
randomly chosen permutation
solved this recurrence
showed the solution
required by randomized
recurrence we solved
quick sort worst
sort worst case
behavior is similar
insert n elements
sequence is sorted
roughly the median
quick sort depends
numbers were generated
input the running
random numbers generated
value it turns
input was sorted
pick my pivot
random number choice
expectation will give
make any fix
matter what input
input the adversary
beat my algorithm
sequence no matter
matter what sequence
make an algorithm
algorithm particular kind
kind of input
make it independent
making a random
knew what kinds
kinds of inputs
sense to design
design the algorithm
designing the algorithm
sequence or specific
behavior is independent
class for binary
make this difference
difference very clear
doing an average
run it today
run it tomorrow
choices being made
call an average
average case analysis
factorial different inputs
algorithm was taking
taking different times
input was fixed
expected time analysis
analysis for randomized
quick sort data
sort data structures
talk about avl
search tree data
tree data structure
structure one problem
operations of insertion
deletion and search
bad as order
create a tree
bad a height
structure called avl
tree ? avl
ignore the white
tree and inside
inside the nodes
call the height
defined this term
sub tree rooted
set of descendents
defined the height
numbers are beginning
tree has height
height the node
tree the binary
difference to talk
tree is missing
made this change
tree is absent
denote the height
shift the definition
put some keys
last node height
node height balanced
2nd node height
height balanced property
property is violated
kind of trees
trees as avl
out how bad
bad the height
minutes the height
prove this claim
slightly different argument
trees of height
nodes i defined
defined this quantity
out the quantity
implies the proposition
recall a binary
understand the quantity
counting the minimum
root node suppose
h-2 or h-1
h-1 or h-2
nodes a tree
h-1 the smallest
solving this recurrence
grows the number
thing to solve
implies the entire
suppose i pick
tree whose height
satisfy this relation
satisfy the relation
minimum possible number
nodes any avl
argued after taking
nodes its height
number of number
nodes the height
two times log
height only log
recurrences are solved
fairly crude analysis
tree the bound
bound we obtained
made a mistake
back this base
redefine the height
suppose the claim
claim is true
minute so recall
relation our induction
show this quantity
show is lager
out the terms
solve this quadratic
fibonacci number minus
thing is base
out i guess
thing to pick
make a difference
make that correction
hypothesis is h-1
quadratic in equality
equality the value
make that small
tree with smallest
smallest possible number
definition of log
h-1 this implies
prove this kind
bound this equation
equation also works
ways of solving
make a guess
essentially you verify
suppose the right
tree in detail
means whose level
suppose this leaf
2k-1 this requires
requires the proof
suppose the red
class for avl
tree we work
work with level
make a big
start with level
sub tree hanging
tree hanging out
root at level
node at level
child has height
blue this means
means this sub
height this sub
argument which means
property of avl
arbitrary binary tree
leaf at level
band whose width
largest possible height
height the tree
make another claim
1st k-2 levels
child the picture
shown a node
argument would apply
child so sub
height balance property
children at level
extends the dot
leaf is situated
situated at level
middle and provided
problem in height
children which means
k-1 are full
full it means
means the tree
nodes this implies
implies the number
proved the sharper
bound the point
constant an exponential
logarithmic height property
solving a recurrence
solving the recurrence
tree is concerned
nodes of height
half the height
require a proof
levels the avl
first half levels
starts thinning out
turn the tree
lot of nodes
tree on levels
mind about avl
nice the height
delete in log
search is easy
problem with search
search tree forget
forget the height
order h height
change the height
consequence the height
violated the first
step of insertion
tree ? first
first you find
updating the heights
nodes you encountered
nodes whose heights
doing an insertion
height change appears
inserted and move
hit the root
find the first
height imbalance property
imbalance property suppose
suppose that node
skip this part
forget this empty
balance is satisfied
forget this type
type of node
inserted a node
balance property violated
violated we call
call this node
tree to make
leave the tree
kind of rotation
operation is done
change the keys
draw the picture
out what rotation
property is retained
looked at avl
trees are defined
proved a bound
tree we spent
spent a lot
solve that recurrence
solving that recurrence
proved a similar
class data structures
discussion on avl
begin with insertion
started this discussion
discussion on insertion
class also suppose
insert a key
process of insertion
put the key
started the discussion
remain an avl
heights could change
change ? recall
recall we defined
node whose subtree
subtree has changed
changed as result
node its sub
changed it remains
heights might change
change and change
height might increase
imbalance or unbalanced
height balance problem
height problem means
height imbalanced height
imbalanced height imbalance
height imbalance means
means one left
difference in heights
node v travel
identify the node
grandparent is unbalanced
grandchild which grandchild
heights are changed
earlier the node
difference of height
1.is the node
node has changed
changed the height
path would change
grandchild means child
child so child
rebalance this tree
rebalance this sub
tree the sub
performing a rotation
changed this sub
nodes but organized
understand this process
reorganizing a binary
tree the picture
property of binary
forget these links
put the links
back what happened
search tree property
property still holds
done some local
suppose the insertion
drawn the links
out these links
avoid the clutter
root the root
thing the height
adding one node
increase in height
height of node
increased and height
increased because height
balanced after insertion
increase it remained
continue this argument
balanced the height
repeating the argument
imbalanced because original
originally imbalanced height
rotation and stuff
reduce its size
thing we argued
shown the links
heights the height
search tree properties
properties are maintained
difference in height
done a rotation
number of operations
thing is happened
happened the original
rotation the height
sub tree remains
height before insertion
symmetric case completely
repeat the argument
means the height
originally not balanced
rotation we ended
ended up making
root the middle
key we ended
making the root
remains the right
right of sub
balanced ? height
done the job
remain the right
compute heights height
original sub tree
ended up doing
middle key ended
split the thing
height imbalance happening
kind of split
uniformly the heights
ways to rotate
tree the single
doing this thing
height balanced picture
case after rotation
single and double
rotations are done
tree the difference
deleting a node
node i copied
copied the content
deleted the successor
successor the actual
node i deleted
end up deleting
ended up deleting
means this node
deleting a leaf
deleting the parent
leaf which means
deleting the leaf
leaf and copying
copying the content
leaf or parent
first unbalanced node
height could reduce
unbalanced node encountered
rotations to restore
restore the height
case of insertion
stop after doing
doing the rotation
rotation in delete
unbalanced and repeat
repeat the rotation
reach the root
tree i found
node i identified
imbalance that happened
happened here earlier
imbalance imbalance happen
height the height
height of h-2
height of h-1
slides what kind
h-1 and h-1
continue the argument
height has reduced
bigger thing height
height of sub
height and height
pick the root
rotation of mine
single rotation case
pick the left
pick the right
nodes and trees
double rotation step
step so first
nodes ? height
h-2 and height
make that argument
done single rotation
make this kind
tree you understand
tree because height
satisfied by checking
checking the parent
insertion we spent
insert why log
spent time proportional
height we argued
doing a rotation
done the entire
log n deletion
tree to find
find the place
occurs the first
satisfy the height
insertion basically requires
basically requires order
requires order log
spend order log
takes a log
log n order
order time deletion
hand also requires
requires only order
bit more work
work the reason
cases the node
delete the successor
occurs having found
solve your problem
problem of height
restore height balance
perform a rotation
number of rotations
moving one level
log n rotations
rotations only taking
taking a constant
total time required
entire delete operation
deletion in avl
trees we argued
done in log
avl tree data
tree data structures
trees in today
representing a dictionary
operation of insert
kind of performance
case in avl
kind of search
trees so recall
first point nodes
2-3-4 actually refers
children and node
children such trees
children but satisfy
multi-way search trees
multi-way search tree
two which means
children any number
two each node
tree also stores
stores a collection
collection of items
node was storing
storing one key
student entry number
d-1 such pairs
pairs or items
generalizing the binary
trees each node
children each node
left or right
d-1 different keys
children that node
instance this node
node the keys
determine what set
first sub tree
last sub tree
middle sub tree
follow the first
keys or items
two consecutive keys
follow one child
searching is similar
binary search procedure
left most sub
right most sub
sequence of steps
searching for lies
right most child
recall in order
traversal says left
print the data
child then print
left so first
print this key
key which means
means i print
printed this key
doing in order
back and print
keys in sorted
easy to prove
out this key
order of printing
children so first
multi way search
search tree multi
means every node
tree each node
forget this square
additional properties search
properties search tree
tree be maximum
tree we argued
height is log2n
height is maximum
maximum the tree
height is minimum
nodes are closer
tree is log4n
log4n so height
nodes always lies
lies between log2n
log2n and log4n
half of log2n
basically the height
2-4 tree lies
lies between half
half of log
lets say suppose
number of node
visiting order log
node you require
tree you required
keys to determine
shown the node
shown each node
node having space
found that element
empty the right
pointer we compared
space no problem
pointer which means
thing would happen
split the node
node which node
remove this node
promoted one key
parent and inserted
inserted that key
split this node
node two nodes
two nodes created
split the parent
node and promote
first two children
made the children
children the first
keys which means
root the height
split that node
two lower keys
two higher keys
node the largest
promoted up promoted
promoted up means
repeat the split
node so split
split might cascade
clear for search
doing the split
split a node
constant time independent
node split takes
split takes constant
suppose i wanted
recall deletion require
out the leaf
two child case
found the successor
successor or predecessor
found the predecessor
move the predecessor
delete the predecessor
problem in deleting
violating the property
tree we require
require each node
shown the process
swap this two
check this point
leaf node suppose
finding the predecessor
taking the right
children are null
remove that leaf
problem were arising
delete a key
leaf becomes empty
deleting a key
node becomes empty
borrow a key
manner i reach
node not permitted
borrow from sibling
disaster because search
solve our problem
node which separates
moving the key
parent node corresponds
corresponds to deleting
deleting the key
height can reduce
handled and insertion
point is doing
theta of log
deletion was concerned
looked at running
tree to search
log n step
step each step
borrowing would correspond
complicated data structure
structure called red
red black trees
fast data structure
structure for implementing
2-4 trees today
helpful in understanding
black trees functions
2-4 trees data
talking about red
discussing about red
deletion in red
slightly more involved
spending fair bit
bit of class
class on deletion
insertion in red
red black tree
color them red
red and black
black tree subject
properties so first
first the root
important a red
create the left
child by creating
call an external
create an additional
two external nodes
black we define
define the black
number of black
nodes we encounter
tree so lots
lots of definition
couple of examples
examples of red
colored the nodes
black and red
red the root
root is black
black or red
left right child
call external nodes
similarly the black
add this external
black children black
children black node
children or black
add the external
add an external
end of handing
children but red
red right child
place the external
count the black
colored this red
tree the black
ancestors are black
two black ancestors
two black ancestor
height of tree
ensure ? first
height or depth
top so black
call the black
node and height
examples of trees
call a double
double red problem
two reds occurring
tree so black
count its number
number of ancestor
tree of black
tree be small
include your red
nodes and increase
increase the number
nodes the largest
layers of black
layer then red
number of red
lies between log
-1you can figure
give you red
correspondence between red
case the number
children and combine
red children suppose
node so formed
keys furthermore black
resulting 2-4 tree
tree all leaves
nodes i encounter
matter which leaf
leaf i started
unique 2-4 node
root i encounter
two red children
create a node
create another node
giving a proof
make a red
2-4 tree node
node so first
first i put
create one red
reds consecutively happening
level the black
resulting red black
create a black
create some thing
two consecutive reds
draw the external
nodes and count
count their ancestors
understand what red
create a red
fact the operation
operation of insertion
mimic those operations
reasons for doing
mimic the operation
operation of deletion
slightly more tricky
find it successor
successor or predecessors
talking about successor
successor so successor
put an external
means the node
child we put
leaf or black
child which means
means right child
black then black
external node verses
verses this external
problem of black
case the node
deleting or leaf
red double red
case to handle
create a double
replace this entire
change the black
similarly this case
created a double
two cases corresponds
removing is part
part of node
keys the key
atleast two keys
remove this key
correspond to change
removing this reduces
reduces the black
tree whose black
height is reduced
organize the tree
reorganizing this tree
larger and larger
bunch of cases
cases as procedure
root has sub
parent the parent
two different cases
clarify this point
deleting this black
delete this entire
thing i replace
essentially this sub
two external node
external node children
child is black
two children colored
black so depending
shown them black
handle these cases
tree is hanging
two case red
children and depending
two more cases
two is red
black which means
picture to show
tree sub tree
node is red
black red node
reorganize this tree
basically a rotation
labeled these things
order will set
kind of reorganization
taking of avl
node was empty
red which means
means the parent
rotation ? student
motivation is coming
node which means
means its parent
2-4 need tree
guy was red
sibling my sibling
sibling can lend
picture so lets
parent is red
problem let check
check the height
business so black
introduced double red
restored what case
quickly now start
written so parent
parent by parent
height is decreased
case the picture
root black children
originally black height
height of entire
coloring will solve
make this red
red and make
make this black
introduced the double
made this red
2-4 tree picture
guy becomes empty
helps to clear
red next set
set of cases
black so parent
two assumption making
black this node
node has red
picture this height
entire black height
height that means
correct so first
problem is concerned
corresponds to parent
thing to decide
case we considered
considered the case
made the assumption
red that means
means this guy
two sub tree
root are black
black height check
empty the parent
merge and merge
work with assumption
red child lets
kind of combine
parents becomes empty
2-4 tree deletion
parent which means
process the parent
parent became empty
case you reduce
reduce the height
coloring a node
essentially one bit
bit of information
case the height
sub tree reduces
coloring the node
essentially one rotation
makes the process
process really fast
check this last
deletion next class
mind you don
simpler to understand
remember this process
process data structures
correspondence of red
process in red
introduce the notion
define the a-b
deletion in a-b
first the insertion
key already exist
identify the place
inserted we create
color this node
black tree differs
node is colored
obeys certain properties
begin by coloring
coloring this node
red colored node
black colored node
key and found
node i decided
decided to put
put my node
color it red
node is black
nodes that property
black tree continues
continues to hold
introduced a red
node the property
hold the problem
double red colored
side is red
node with key
key k inside
node i created
handle this problem
case of deletion
deletion the problem
problem was arising
height was changing
encountered a double
uniform the black
problem just concentrate
inserted is red
red this parent
node was red
simple rotation note
black height problem
uniform only thing
tree under node
tree was red
double red problems
problem by inserting
inserting that node
left side tree
simple rotation takes
rotation takes care
2-4 tree recall
recolor the nodes
corresponds to split
colored the node
side that corresponds
single black node
created a black
initial black height
entire sub trees
means the external
managed to move
move the double
problem one level
sub trees hanging
moves one level
case the double
red problem moves
repeat this process
rotation take care
problem will move
end up coloring
coloring the root
coloring it red
root is colored
color it black
increase the black
nodes should remain
color the root
corresponds to moving
splitting the root
split the root
move the problem
change the reds
reds to black
black and change
black to red
corresponds to recoloring
recoloring of nodes
basically the node
parent nodes sibling
node whose color
recoloring the moment
rotation the process
process very fast
fast because recoloring
change those bits
slightly more expensive
requires some pointer
tree is faster
case of avl
trees in avl
avl trees recall
deletion is log
doing only log
wanted to discuss
trees we looked
kind of operations
operations in log
changing the tree
changed the tree
tree are insert
notion of a-b
drawn an a-b
remember an a-b
a-1 to b-1
a-1 and b-1
satisfy this property
root the requirement
roughly the bounds
correct the statement
essentially a repetition
find a position
keeping in order
node gets split
talking of a-b
essentially 2-3 tree
basically 2-3 tree
2-3 tree means
means each node
made with space
space then split
key is promoted
split can cascade
node and median
remove it shortly
node had space
make it work
key gets promoted
split and move
move the median
root this property
children so root
b-1keys this property
manner and inserted
ended up splitting
permit the root
insist the root
trees to a-b
a-b tree node
space for b-1keys
node is split
remaining are split
b-1is getting split
means one side
nodes are valid
means that a-1this
creating a node
node with keys
equal to a-1
2-4tree the simple
key left suppose
empty and node
sibling the sibling
valid 2-3 tree
borrow one key
remember the reason
tree we merge
removed one key
merged which means
created one node
eventually the root
merge a node
sibling which means
minimum number a-1
merging the node
means the sibling
sibling has a-1keys
a-2keys after merging
floor means rounded
summary for insertion
trees the height
tree the reason
deletion was taking
height was log
done some number
doing the operation
first we move
borrow the key
moved one level
stop the entire
operation take order
tree was concern
today was red
rotation to complete
complete an insertion
require one rotation
rotation some number
color many nodes
rotation is required
fast in practice
faster then avl
specially in searching
searching very large
disk based data
based data structures
structures so today
talking about disk
structures in last
based data structure
fact ab trees
trees for specific
amount of data
trees were limited
limited to main
sense you build
build a binary
tree or build
objects in memory
corresponds to pointer
addresses or memory
huge amount data
kind of transaction
bank share markets
data get generate
memory of computer
stored on disk
data or insert
data or modify
modify this data
imagine the setting
huge the data
data should set
history of transaction
data to decide
account so question
make a search
sense secondary storage
storage in avl
data is stored
expect the entire
entire search tree
tree to fit
verses when thinks
typically have bunch
bunch of disk
disk in stack
read write head
disk the disk
head can decide
reading the data
write head moving
head moving determining
determining which track
disk to rotate
head is positioned
read in units
units in larger
units you don
read one byte
byte of data
disk why don
read whole lot
lot of bytes
read or write
write in units
units called pages
back and entire
organize our search
manner that first
disk based algorithm
measured in terms
number of disk
cpu is insignificant
organize the data
access the disk
main memory algorithm
entire data sets
module when part
business is concern
references to objects
knew that correspondence
access that location
structure is sitting
memory and part
references is referring
operation disk read
read to read
disk and disk
write to write
fetch that block
block of data
page of data
object so typical
read this object
omit this step
modify the object
two operation today
read and disk
reading a block
block from disk
disk and writing
back to disk
disk based access
two level trees
trees these leaves
entire two levels
two levels structure
bytes of memory
bytes of pointers
bytes per key
times a billion
kind of space
account has listed
last three years
lets says stored
data was stored
keys and pointers
kind of structure
tree this structure
lies in suppose
suppose it lies
child node suppose
access this node
disk and bring
node from disk
find your account
follow the account
tree ? increase
increase the value
nodes and page
keys is taking
taking certain amount
amount of space
page ? page
unit of transfer
keys comma pointer
pointer per taking
key comma pointer
pair is taking
lets say methods
means leaf node
node other wise
tree c sub
essentially same structure
provided a lower
node has degree
equals two times
essentially special kind
minus one keys
tree is meant
data structure meant
meant for secondary
choose large value
tree is smallest
node can fit
recursive search procedure
keys are arranging
find a first
find a key
found a key
node i fetch
continue my search
keys can sit
process of splitting
separately to understand
understand this code
procedure for splitting
splitting a node
first you copy
copy the children
moved up copied
modified this node
node we created
doing this disk
slides and understand
understand the code
split the number
moves certain keys
fairly small compared
access so today
today one variant
variant of binary
trees also works
two four trees
node getting split
two parse operation
tree one possibility
top you check
quota of keys
level we make
inserted the key
first root node
tree whatever key
node is full
promoted here note
inserted an element
happen here anymore
parent had room
straight away split
right away split
guy gets promoted
lets me accommodate
accommodate this addition
crossing ripple effect
kind of access
access every node
disk its parent
times the number
number of splits
disadvantages of doing
skip the code
code i showed
key is concern
recall the earlier
tree we deleted
deleted the key
key that node
remove one key
single pass delete
pass delete procedure
procedure which means
encounter a node
minimum of keys
make a effort
merge we bring
descending to lower
insertion we require
equals three means
encounter this node
key the minimum
action to ensure
successful in borrowing
answering the question
trees ? student
suppose i delete
lot of works
works in doing
splitting the node
lots of pointer
happening so insert
insert and deletes
block of insert
insert and block
block of delete
handle whole lots
lots of delete
delete without significant
sequence of delete
sequence of insert
things alternating vary
sibling or merging
back my sibling
sibling one key
parent gets modified
borrow or merge
back three node
two pass operation
case of disk
organize the things
make one pass
make a pass
made a single
making first pass
read in memory
reduce the type
reduce the number
end this class
specifically for disk
disk based accesses
setting data structures
searching for patterns
patterns so today
talking about pattern
searching or pattern
matching the setting
piece of text
out all occurrences
work most editors
editors will provide
facility many things
provide this kind
kind of facility
pattern so question
exact matching problem
manner that means
places it matches
solve this problem
retrieval one big
application is bio
database with sequence
sequence of nucleotides
alphabet of size
method of doing
put the pattern
matching the pattern
find the mismatch
move the pattern
step was critical
skipped this thing
suppose i moved
missed the occurrence
occurring at multiples
text so moving
out the mismatch
pattern how long
space we require
store the text
store the pattern
pattern we don
space we don
array to move
moving the pattern
increment your index
sequence of improvements
mismatch is detected
matched k-1 characters
detected at position
first two characters
last two characters
position in text
shift the pattern
pointer in shifting
implement this idea
step the mismatch
last three characters
mismatch was happening
shift will depend
wanted to shift
procedure very shortly
algorithm so key
restart the computation
pattern some information
pattern to determine
construct an array
characters to shift
right in case
store this information
position that means
matched the prefix
label these things
counting i-1 locations
matches up completely
define so recall
mismatch at position
make the smallest
smallest possible shift
amount of shift
shift is smallest
smallest or largest
smallest and largest
out any pattern
waste any comparisons
happened at position
draw a picture
shifted the pattern
comparing the pattern
draw the shift
two ? useless
matching this shift
playing this game
value to shift
longest proper suffix
matches the prefix
prefix is contiguous
finding the longest
proper suffix proper
suffix proper suffix
proper suffix means
suffix means suffix
include the entire
text like proper
proper subset means
means strictly smaller
means that matches
find out length
match the prefix
out the longest
shift without missing
longest possible match
suffix which matches
pattern has matched
matched the first
characters still continue
continue to match
happening by shifting
shifting the pattern
extent to shift
shift by huge
position which means
condition is true
last six characters
characters and first
first six characters
potential this guy
shifted pattern h11
suffix of text
position of mismatch
parts should match
suppose the pattern
longest such matching
minimum shift occurs
occurs or maximum
maximum shift occurs
shift is happening
largest possible shift
out any patterns
end up missing
pattern by doing
text the mismatch
text and position
part is beta
kmp algorithm missed
find the procedure
string of length
length alpha matches
matches the suffix
alpha and alpha
violates our definition
longer these matches
prefix yes agreed
suffix or prefix
prefix which matches
establishes the correctness
things would work
expand it out
array h suppose
amount of effort
text the first
first mismatch occurs
occurs at position
means till position
written in position
pattern will remain
units the pattern
match the first
pattern the value
units i shift
shift by additional
mismatch which means
found the match
function is designed
sound very good
comparisons is huge
call this unsuccessful
comparison ? comparisons
comparisons that result
number of unsuccessful
part of successful
compare this part
comparison is compared
back track happening
happening the number
number of successful
text the total
number of shifts
character is part
unsuccessful comparison results
shift so total
two successful comparisons
text so total
size the text
number of comparison
computing the array
call that preprocessing
required to compute
compute the array
searching is order
done in order
longest proper prefix
prefix or longest
suffix whatever longest
out the value
out the last
last three character
first three character
choose a value
summation i square
cube ; divide
idea in fact
doing this computation
computation of array
require the text
head and work
first five match
confusing my array
class so today
today we looked
looked at pattern
algorithm for doing
order m cube
3rd has trees
interested in matching
matching patterns finding
places certain pattern
preprocessed the pattern
pattern we computed
computed this failure
information to search
preprocessing the pattern
match the pattern
compute the failure
brute force method
method of matching
size of text
processing the pattern
knuth-morris-pratt algorithm searches
searches an arbitrary
text which doesn
spend time proportional
works of shakespeare
process the text
typically very small
million characters large
large you don
preprocess that text
created some data
pattern all occurrences
matter what pattern
previous kmp algorithm
processed the pattern
matter what text
taking time proportional
picture so trie
structure to maintain
maintain a set
set of strings
tree in fact
fact the number
strings are lower
lower case characters
organized ? suppose
follow a path
words here suppose
build this thing
give you set
set of words
build this trie
leaf node corresponds
search for bed
linked list ordered
search ? suppose
change the search
times the length
link list sitting
follow this pointer
pointer and repeat
repeat these things
operation of find
list of presentation
create that letter
create new nodes
create one circular
thing is bad
created ? total
number of characters
character the first
first word begins
make a long
total not total
number of words
call that double
peace of text
text and throw
trie i make
make a trie
started off today
word matching find
occurrence of word
detect by doing
operations of matching
matching is done
done by tracing
tracing the path
bunch of words
words i threw
leaf i store
bid is occurring
places perhaps starting
preprocessing the text
built this trie
stored this information
give you piece
give you pattern
pattern and find
collection of words
sequence of basis
notion of words
searching for words
search for patterns
boundaries my pattern
boundary and end
address the issue
reduce the size
remove those nodes
nodes by degree
compress those nodes
node this node
node in fact
fact this node
child and collapse
created a long
trie is smaller
children every internal
node clearly leaf
leaf nodes don
trie is order
set of string
trie this doesn
longer label inside
store that label
space to store
begins at position
ends at position
labels no matter
matter how long
necessarily a suffix
necessarily for instance
store these words
structure is number
two times number
thing you understand
doing anything sophisticated
reach the middle
delete this guy
collapse the child
simple data structure
out the implementation
google you type
type a word
word that part
part which helps
helps you retrieve
compressed trie typically
generic search engine
memory the list
imagine the number
number of urls
disk now suppose
suppose you wrote
wrote ? computer
computer and music
search for computer
search for music
two occurrence lists
intersection so boolean
boolean queries corresponds
corresponds to set
lots of techniques
thing you eliminate
eliminate stop words
computer on internet
number so type
nslookup to find
manner for instance
iit delhi address
router when packet
bunch of links
coming in links
out so packets
out which links
links to send
packet and find
match your table
tables are organized
back to pattern
doing the job
words or delimiter
started and ended
delimiter but suppose
biological data base
text and organize
create a trie
4th so put
essentially a compressed
length of text
words order number
size d stores
suppose i start
suffix whose prefix
pattern that means
pattern which means
word will match
tree and identify
word ? minimized
make the suffix
text i make
make a suffix
collapsed my nodes
make this suffix
store by numbers
starts at position
report all occurrences
trie is contained
suppose my text
node you don
special about dollar
build a suffix
breaking this edge
find the longest
root whose label
matches a prefix
create an edge
quickly one suffix
takes time order
exploiting in pattern
find all occurrences
occurrences of pattern
idea of algorithm
obtained as concatenation
labels of edges
match the characters
pattern is exhausted
found a match
means that pattern
text in case
obtained by extending
extending the path
reach a leaf
leaf each extension
pattern each extension
suffix this corresponds
order n2 algorithm
algorithm for constructing
constructing the suffix
fairly complicated algorithm
complexity of pattern
preprocessing which means
building the suffix
number of occurrences
long but occurs
occurs one thousand
side the total
size of pattern
pattern to store
decide to preprocess
preprocess the text
pattern data structures
data compression today
idea behind file
talking about huffman
doing data compression
abracadabra ? translate
stored as bits
shell and type
type < man
code which means
character is stored
number of bits
reduce the amount
required to encode
encode a piece
text but suppose
suppose i don
design a coding
text using lesser
bits using lesser
bits you understand
doing this kind
kind of compression
memory you require
transmitting the file
send less number
store less number
compress the information
call variable-length coding
represent each character
character which occur
decide to encode
suppose my alphabets
encoded were strings
string and suppose
doing fixed length
fixed length encoding
two possible values
problem with variable
variable length decoding
variable length encoding
sequence of bits
decode it uniquely
back to java
suppose for instance
problem of ambiguity
ambiguity while decoding
variable length codes
codes this problem
fixed length codes
codes you understand
ambiguities in decoding
code by code
satisfy the prefix
ambiguity in decoding
collection of code
character the sequence
code so code
code which satisfies
satisfies the prefix
trie so recall
branching each node
node the left
edge will label
leaf each character
prefix of code
represent our codes
leaf to determine
determine the code
shown this picture
drawn this trie
decoding ? suppose
decode this text
beginning you start
leaf you stop
piece of encoded
aim in doing
recall we wanted
wanted to build
suppose this trie
counting the number
totally now suppose
occur very infrequently
count the frequency
frequency of characters
compute the trie
encode the character
root is number
character has frequency
choose a tree
quantity is minimized
minimized our tree
tree will determine
pick a tree
total external weighted
external weighted path
weighted path length
talking about external
basically the number
levels ? weighted
viewing each leaf
character the weights
weighted are referring
thing is weight
weight or frequency
frequency this means
weights or frequencies
find the tree
tree whose total
total weighted external
weighted external path
external path length
length is minimum
build a tree
tree whose leaves
denote this minimum
minimum weighted external
leaves with weights
minimum total weighted
managed to translate
translate our question
question of finding
length in encoding
encoded message minimum
tree one thing
put red boxes
leaves i make
make another node
value of weight
weight of sum
two will disappear
smallest and combine
whichever you feel
reducing a node
two nodes left
difference the length
encoding was determined
minimum for abracadabra
occurring five times
build another trie
first i combined
combined these two
decide to combine
claiming is false
algorithm is computing
computing the tree
computing the minimum
compute a tree
assume the claim
characters or leaves
frequencies and combining
two characters frequencies
node of weight
point the behavior
characters with frequencies
point the algorithm
computed a tree
characters with total
minimum the tree
algorithm has weighted
algorithm has computed
path length computed
algorithm had computed
quantity that algorithm
tree whose weighted
prove this fact
suppose this factor
factor is true
suppose had proved
proved this factor
two lowest weights
weights are siblings
slightly more formal
minimum are siblings
assumed this statement
path length equal
give this node
node weight equal
tree over leaves
values or leaves
choice of weights
weights also suppose
suppose the black
red weighted external
blue total external
total external path
length is red
red external path
means blue weighted
blue weighted external
leaf is equal
algorithm is completing
increased the black
blue also differs
blue which violates
violates our optimal
two lowest frequencies
frequencies are siblings
level number suppose
swap these two
length becomes minimum
argument this leaf
swap and reduce
two smallest weights
make them siblings
siblings and continue
property being exploited
algorithm to compute
done priority queues
compute its running
leaving the bit
bit about computing
computing its running
running time today
developed the notion
notion of paradigms
paradigms data structures
priority queues today
priority queue abstract
queue abstract data
implement the priority
key thing today
introduce the concept
concept of binary
procedures for insertion
heap and procedure
procedure called heapify
find to delete
delete the minimum
operations on heap
multi user computer
user computer system
job is running
resumed one policy
policy which minimizes
minimizes the average
srpt the srpt
stands for shortest
shortest remaining processing
schedules the job
smallest remaining processing
bunch of job
bunch and schedule
job and schedule
implement this kind
maintain the remaining
maintain that collection
set of jobs
schedule the job
implement the srpt
policies one data
type to maintain
priority the priority
priority queue data
data type supports
operations the first
inserting the element
element the minimum
minimum operation returns
returns the element
smallest priority priority
bit of misnomer
sense to remove
processing time remaining
delete min operation
operation the delete
delete main operation
main operation returns
minimum and delete
delete min differs
minimum only returns
returns the minimum
element it doesn
min also deletes
queue is supposed
supposed to support
recall the priority
priority queue ranks
ranks its element
element by priority
priority every element
necessarily be unique
lets say denote
priorities these priorities
antisymmetric which means
properties of total
total order relation
satisfies the total
total order deletion
general and reusable
form of priority
queue uses comparator
element has priority
put any kind
mechanism of comparing
comparing the priorities
specifies the methods
compare to priorities
implementation of priority
implementation to store
store any kind
kind of object
compare the priorities
decide to put
collection the comparator
comparator abstract data
type would include
unsorted sequence recall
recall the items
sequence or pairs
pairs of priority
implement the insert
end this takes
find a minimum
sequences for instance
traverse the sequence
reach the element
similarly for delete
element so worst
case time complexity
complexity of minimum
insertion takes constant
implement a priority
elements are sorted
sorted with increasing
priority is straight
retrieve the minimum
similarly to delete
priority is sitting
element with priority
position and put
worst case insert
sequence priority queues
priority queues find
find many applications
discreet event simulation
lets says dijkstra
algorithm which require
require the priority
queue data structure
implement the algorithm
queue and unsorted
sequence and sorted
problems in case
case of unsorted
sequence the delete
operation and minimum
operations are constant
min and minimum
minimum very efficiently
binary heap binary
heap binary heap
tree that stores
stores the priorities
priority element pairs
show the nodes
element is sitting
storing only priorities
pairs now heap
tree all levels
levels are full
call left fill
fill which means
call a heap
property the heap
node its priority
parent this picture
manner the priority
violates the heap
violate the heap
first four nodes
heap ? suppose
heap ? recall
heap property suppose
found the minimum
priority always sits
heap the top
picture the element
sitting in top
inside the heap
priority the heap
priority just recap
priority was sitting
parent with smaller
property this larger
property the minimum
element to find
recall our discussion
minus one nodes
nodes with height
height h minus
heap is larger
quantity this inequality
equals the floor
means that log
nearest integer hope
read h equals
nodes just interchange
implement the heap
simpler to implement
two and level
put these nodes
nodes of binary
root node sitting
array my array
starting from location
level would follow
advantage of putting
putting the nodes
node at location
location five lets
out the parent
determine the parent
out this math
holding these priorities
implicitly are maintaining
maintaining the tree
links the parent
parent child relationships
maintained the children
two just corresponds
shift and multiplying
two and adding
out the children
doing one left
operation this makes
makes the operation
access the parent
heap always sits
wanted to insert
satisfy the structural
property of heap
property this node
swap this thing
manner we swap
property is satisfied
change the content
maintain the heap
parent this violates
last now coming
minimum priority element
slightly different point
first we enlarge
enlarge the heap
heap which means
root to inserted
slight colored path
find the top
top most element
path with higher
inserting is priority
view of insertion
nodes whose contents
newly inserted node
fact only changing
changing the contents
modifying this content
node is larger
two pink color
pink color nodes
newly inserted element
guy the priority
choice of path
node with higher
consequence of insertion
procedure the priority
reduce the consequence
earlier its parent
earlier the parent
reducing then earlier
guy if earlier
guy heap property
array so heapify
tree is rooted
binary trees rooted
property now heapify
makes the binary
binary tree rooted
heap by suitable
top has priority
satisfy the heap
property each node
node has priority
make this entire
thing a heap
invoke the heapify
heapify procedure heap
procedure heap property
violated at node
node with index
heap for heapify
remember we require
require that whichever
whichever node heapify
heapify is invoked
part for heapify
sub trees rooted
heapify works heapify
children and swap
heap property heap
property heap property
property is valid
heap property valid
changed the content
thing is heap
view of heapify
prove the correctness
correctness of heapify
heapify very easily
essentially is tracing
tracing a path
blue colored nodes
node whose context
context we modified
suppose i call
call it node
priority of node
path have lower
siblings ? sibling
path have priorities
constructed our path
path this statement
doing in heapify
moving these elements
sequence of step
children have probability
nodes have changed
earlier a sibling
smaller priority node
result of heapify
mechanism to rebuild
rebuild a heap
heap if due
two sub trees
two child sub
child sub trees
quick runtime analysis
height order log
move the element
element might move
require time proportional
procedure we looked
looked at today
heapify at node
looked at node
children and swapped
continued the process
case the element
element might moved
heap the height
looked today insert
insert and heapify
require only order
operation of minimum
heap without removing
heap and return
return the value
root minimum takes
minimum takes constant
insertion takes order
takes order log
heapify also takes
heapify to remove
remove the minimum
end to today
create a heap
quickly in order
efficiently.thank you data
discussion of binary
insertion and heapify
heap to recall
properties two critical
two critical properties
heap be similar
level of full
operations of deleting
deleting the minimum
heap and building
building a heap
easy to build
build a heap
heap using repeated
insertions but today
sort so recall
doing a delete
remove this element
natural to promote
element to fill
fill this empty
space would move
delete a minimum
creates an empty
two children element
element and push
two and move
moves the empty
heap the elements
structurally this heap
move this last
place and remove
adjust the contents
thing this sub
heap the heap
procedure for taking
run a heapify
last class heapify
deleted the minimum
delete min procedure
procedure to recap
right most element
element and put
procedure fairly simple
application of heapify
elements the last
simple minded method
method of creating
creating a heap
heap by repeated
repeated insertion takes
create the heap
heaps using array
create the heaps
make a heap
child and swap
four sub trees
element and make
heapify the first
thing that heapify
takes the smaller
children and swaps
heap the smaller
make the sub
node a heap
heap but note
position to run
advantage of heapify
two and swap
heapify so heapify
heapify would bubble
node the heapify
node just doesn
bubble the element
node to make
case and swap
doing the heapify
two children swapped
property is validated
nodes and swap
build heap procedure
procedure the build
elements are laid
run the heapify
order of running
single for loop
order but remember
proceed to run
entire build heap
heapify sub routine
crucially which takes
takes as parameter
parameter the location
analyze the build
rooted at locations
step and prove
procedure a simple
simple minded approach
running time computation
last class takes
worst case order
case order log
build heap takes
heap takes order
bound of order
procedure on heaps
define the height
call the leaves
leaves at height
simply the analysis
height one nodes
nodes is height
nodes at height
nodes you require
number of swaps
required by swaps
required by heapify
heapify in terms
swap the location
making n calls
done on heaps
heaps of size
size of height
heaps of height
heapify is proportional
crude upper bound
recall that summation
equal zero term
multiply both sides
analysis to show
procedure went bottom
first created smaller
created smaller heaps
heapify procedure repeatedly
heap in linear
sort using heaps
heaps so give
bunch of elements
put those elements
remove the smaller
heap becomes empty
removing n elements
delete min steps
min steps requires
steps requires order
required is order
swap the elements
sorted sequence recall
heaps are implemented
implemented using arrays
additional space starting
delete this element
heap so recall
deleting the element
move this element
location to move
swap the element
heap property validated
essentially the delete
done a delete
swapped this location
happen this location
easily be reversed
reversed in linear
sequence in increasing
continue the procedure
swap the last
ensure the heap
property by doing
swaps so smaller
heap so heap
heap by taking
taking the smaller
swapping heap property
swap the heap
swapped this element
swapped the heap
two children twenty
thirty one swap
essentially means swap
property by swapping
heap the smallest
heap by doing
remove this minimum
essentially that corresponds
min which means
means i remove
sequence in decreasing
summarize the running
sort which takes
takes a total
two step process
first we created
created a heap
operation we spent
spent order log
n-2 plus log
series is log
log n factorial
system is order
step is order
implies that heap
heap sort takes
log n building
bottom up procedure
procedure for building
ways of building
repeated insertion repeated
insertion repeated insertion
insertion we insert
insert one element
argued that takes
takes that kind
bottom up process
process of building
building the heap
made the sub
two a heap
bottom up construction
heap this takes
sorted is takes
takes only order
first we remove
implementation this corresponds
children are heaps
heapify and constant
swap of moving
moving the last
location so total
removing the minimum
wanted to find
heap procedure today
sort actually heapify
takes only log
bubbling the element
moving the element
first we decide
add an additional
log n levels
heap to implement
forget heap sort
min and delete
operations we started
min is done
constant time insert
min also don
interested in implementing
implementing a heap
implementing a priority
takes a lot
doing a lot
lot of find
find min operations
sequence so depending
sequences and unsorted
sequences and depending
operation of occurring
operation for building
sorting in order
place sorting algorithm
sorting ? today
operation that computers
love to spend
problem which requires
develop good algorithms
looked at heap
sort so today
oftenly in databases
search becomes efficient
recall the search
lot of settings
settings in computation
graphics where sorting
sorting is essential
algorithms also give
algorithm design techniques
solving a problem
techniques that people
adopt to design
design an algorithm
standard of techniques
techniques in sorting
sorting it shows
techniques so today
algorithm design technique
bound on sorting
algorithm which requires
comparisons no sorting
algorithm can sort
log n comparisons
exist any sorting
prove lower bounds
sorting is concerned
sort and selection
two sorting algorithm
written quick sort
sort actually heap
list is quick
average case running
algorithm design paradigm
solve those sub
solve the problems
parts and solving
solving the problems
algorithm to solve
combine the result
merge sort algorithm
analyzing the algorithm
put in increasing
lets say lets
step the split
dividing the problem
two sub problems
equal in size
two equal sub
equal sub problems
sub problems equal
numbers of elements
problems are equal
1contains the first
n floor elements
first n elements
combine i wanted
wanted a sorted
procedure called partition
spend in division
thing we partitioned
sort one part
first sorted sequence
put the pivot
combining there taking
taking ? constant
sort is deriving
algorithm i give
identify the part
solving the conquer
sort the first
merger sort procedure
procedure called merge
procedure the definition
definition of merge
sequences one sequence
make one sorted
algorithm is doing
top most elements
element the top
two and put
resulting sequence whichever
two the smallest
numbers i don
shown it lower
kind of doing
doing a recursive
call of merge
level of recursive
call so first
merge sort call
part now first
divisions and doing
doing recursive calls
sort this part
single element sequence
parent calling procedure
sorted first half
merge this sorted
two sort sequences
finished the merge
finished that merge
first we divide
two but first
finished this merge
doing the merge
divide trivial merge
two sorted sequences
part this merge
call has finished
merge sort calls
number of merge
made ? order
ways of thinking
apply those formulas
calls to merge
merge two sequences
two sorted sequenences
resulting sorted sequence
kind of removed
sequences and append
two sequences put
two smaller sequences
out the smaller
compared i found
smaller i write
doing ? order
comparing two elements
two front elements
two and writing
out one element
out n elements
suppose one sequence
sequence of length
compare the worst
sequences of arbitrary
understood the merge
set we understood
understood what merge
comparisons does merge
sequence we spit
kind of created
created a mirror
decided to merge
divisions of algorithmically
doing your recursive
easy to compute
doing the merges
merges we spend
spend in doing
merge two units
two units essentially
counting two length
require two unit
two such merges
elements so total
merges is taking
taking two units
sequences of length
n such merges
total time spent
recursive of algorithms
algorithms of procedure
recursive in nature
analyze their running
basically an equation
equation or inequality
inequality that describes
function in terms
values at pervious
points at smaller
solve a problem
problem of size
suppose i divide
number of pieces
problem by sub
sub problem size
problem size factor
reduced the size
required to solve
problems this part
required that times
number of sub
denote the recurrence
basically a trivial
solve the trivial
recurrence the initial
condition for instance
merge sort problem
divided the problem
sort to merge
required to merge
bunches of ways
repeated substation method
expand the recurrence
recurrence by substituting
repeatedly and noticing
noticing any patters
guess a solution
recurrence really satisfies
satisfies that guess
solving recurrence relations
remember those formulas
solve those recurrences
out a tree
ease the analysis
bit so recall
recall the recurrences
adopt repeated substitution
observe a pattern
done this thing
procedure everyone understands
merge total number
merge the number
merge is theta
log n upper
bounded and lower
times now suppose
thinking this entire
out a recursion
basically the num
sum of numbers
view this thing
out this tree
write the total
substation method substitute
doing that observe
times you observe
substitution and find
out a value
value the initial
implementation of merge
things are clear
taking a comparator
merge sorting integers
require the sort
interface called sort
implementing a method
method called sort
requires a sequence
comparator why comparator
interested in sorting
give you tow
design a comparator
true or false
basically the merge
operation called insert
similarly we create
implemented your methods
call sort sort
two sorted sequence
sequences are non-empty
compare the first
add the smaller
add the first
empty then depending
removing one element
discussion on sorting
sorting we learnt
learnt what merge
paradigm for sorting
sorting is data
sort in place
place sorting heap
sorting heap sort
bubble sort bubble
sort bubble sort
comparing the keys
keys or people
comparing two persons
people but today
collection of keys
keys are represented
base m number
essentially in binary
sorting is done
done by comparing
compare the bits
bit at position
variants on radix
radix exchange sort
examine the bit
represented in binary
examine the bits
bits from left
log n bits
bits to represent
represent that largest
numbers in log
sort the array
array with respect
leftmost bit first
bit first suppose
numbers are sitting
left most bit
left most bits
bit which means
two different values
easy the zeros
partition this array
top sub array
array and bottom
bottom sub array
sort this top
sort the top
forget this bit
sorting these numbers
number or remove
remove and subtract
subtract some number
sorting the original
makes a difference
sort this bottom
step is triviled
sub array ignoring
ignoring the leftmost
sort the bottom
ignoring the left
sort these n-bit
claim it takes
bits is log
number the largest
number of numbers
sir the number
continue this discussion
claim to sort
sort n b-bit
write a recurrence
stretch and write
ignore the left
minus i numbers
partition this numbers
kind of recurrence
talked about solving
recurrences by guessing
guessing a solution
solution and substituting
substituting that solution
weather its true
hand side equals
left hand side
reference no harm
doing a randomized
computing the expected
computing the average
bit more cumbersome
assume the maximum
solve recurrence relations
argument everyone understands
step we don
sorted this top
sorted this bottom
represent every number
worry about negative
numbers and positive
split the numbers
numbers into negatives
negatives and positives
separately and put
life more complicated
sort them separately
kind of partition
employed in quick
scan from top
finding the first
bit and swap
kind of technique
exchange these keys
scan indices exchanged
call it recursively
top to bottom
place we find
partitioning the numbers
numbers whose value
numbers with values
array i repeat
ignore the leftmost
understand the algorithm
compared to quick
sort the sub
arrays so structure
case of radix
partitioning with respect
power b minus
method of partitioning
partitioning which makes
makes the difference
divide the array
number is larger
element the difference
complexity for radix
exchange we argued
complexity is order
sort we argued
exchanging the elements
version of radix
implementing radix sort
radix sort quick
sort quick sort
larger than log
numbers of bits
bits you require
sorting is large
straight radix sort
bits from right
right to left
right most bit
stable way sort
array in table
table way means
sort these numbers
bit this corresponds
sorting them based
restrict your attention
done some rearranging
sorting with respect
spending time proportional
sorting their relative
relative order remains
order remains unchanged
remains unchanged suppose
sorting this array
blue the first
first was colored
permitted to rearrange
sort with respect
create this array
array post sorted
understands what table
understand the correctness
correct relative order
end that means
place they don
call this position
sorting this bunch
first the right
keys are put
corrective relative order
rearranged i don
key would put
sort this key
key and add
add sub sequent
sub sequent steps
preserved the smaller
larger keys appearing
right now bigger
number is appearing
continue this relative
stable sorting ensures
maintain the relative
sort is stable
changed when bits
bits at position
sacrosanct about binary
technique to decimal
first i sort
right most digit
digit which means
sorting is stable
number of digits
exchange radix sort
wanted to partition
two way partition
anymore for decimal
sorting the array
performed in order
total time complexity
completely clear provided
numbers are sorted
method of choice
bucket sort algorithm
sort ? lots
lots of buckets
stable sorting algorithm
numbers with lots
lots of duplicates
numbers are coming
number and throw
element of array
array is put
end is important
important to maintain
two and append
read the numbers
sorting you understand
radix sort takes
sort takes order
auxiliary data structures
amount of additional
updates the input
replaceelement and swap
swaps two numbers
call the algorithm
made to work
work in in-place
sort is heap
heap sort in-place
implement a heap
changing the elements
array merge sort
sort is merge
merge sort in-place
merge two list
in-place quick sort
sort is in-place
merge two lists
doing in merge
taking the first
space would increase
order one space
radix sort in-place
number of buckets
buckets is independent
modify the scheme
scheme to make
make it in-place
bucket just count
make radix sort
bound for comparison
comparison base sorting
comparison based sorting
compare two numbers
two numbers suppose
sort those elements
elements i give
compare these objects
wanted to sort
algorithm which takes
objects are sitting
array the first
compare two elements
first it asks
numbers to compare
stop it doesn
numbers this sequence
sequence of moves
numbers we pick
make certain comparison
applies for randomization
number in location
put a node
comparison it asked
back and asked
objects you don
today i feel
based on gpa
gpa then tomorrow
tomorrow i feel
feel like relative
based on height
basically the length
straight forward thing
thing to understand
kinds of permutations
permutations every permutation
generate a permutation
permutation should exist
exist as leaves
leaves that depends
algorithm should end
permutation and picked
factorial so height
sir our order
order to comparator
satisfy the symmetric
answer with respect
permutation all queries
tree decision based
point the point
roughly n log
based sorting algorithm
permitted to compare
keys radix sort
radix sort doesn
complexity n log
bits or digits
comparisons based sorting
achieve that bound
looked at bucket
understood what stable
bound on comparison
based sorting data
sorting data structures
talking about graphs
understanding the basic
definition in terminologies
graph abstract data
graph data type
data type today
call the set
set of vertices
set of edges
edges so set
picture these red
pair of vertices
vertices an edge
giving a pair
edge between vertices
giving this drawing
drawing or giving
lots and lot
lot of applications
circuits as graphs
out the path
connecting to intersections
graph so transportation
modeled as graphs
typically student day
play cs201 programming
cs201 programming sleep
dream of cs201
day before mine
call directed graph
call such graphs
graphs directed graphs
graphs whatever things
things i define
define will carry
ordering is important
fairly simple lecture
lots of terminologies
kinds of graphs
graphs a directed
graph so graph
edges are adjacent
vertex the degree
number of adjacent
vertex is degree
understands the degree
edge is incident
vertex is vertex
incident to vertices
similarly this edge
vertex so degree
number of edges
thing so question
half a line
counting this edge
stones or pebbles
understand what degree
understand what adjacent
define the notion
sequence of vertices
vertices are adjacent
easy to construct
vertex is repeated
path a cycle
read the cycle
path because vertex
graph is connected
common mistake connected
writing a minus
vertices are connected
hand side suppose
takes this edge
edge is running
edge each edge
two end points
maximal connected graph
connected graph suppose
definition of connect
maximal connected sub
connected sub graph
understood more carefully
set while retaining
retaining the property
maximal with respect
add more elements
set and retain
retain the property
add more edges
add more vertices
add this edge
add this vertex
suppose i decided
decided to add
component as simple
components more terminologies
forest ? forest
collection of trees
trees and animals
out the animals
thinking of forest
forest so forest
trees ? tree
denote the number
number of vertices
pairs of vertices
complete directed graph
two times nc2
nc2 a directed
minimum elements connected
connected in graph
recall a tree
cycle so starting
edges these vertices
tree every vertex
nodes we write
count the edges
proof by induction
two so suppose
true so number
define a leaf
vertex of degree
relating these vertices
remove this edge
removing an edge
create a cycle
apply my induction
facts are critical
proof by contradiction
follow this argument
remove an edge
thing to remember
remove any edge
make the graph
disconnected by doing
remove another edge
graph will remain
tree after removing
contradicting the earlier
number of connected
graph which means
means the sub
sub graph includes
spanning tree suppose
put the minimum
built a spanning
provide much fault
talk about bridges
city in germany
germany or austria
austria i don
edges so question
retrace the steps
problem and euler
give a simple
model this thing
graph this island
piece of land
put two edges
put one edge
define a notion
edges between pair
talked about pair
vertices the edges
form a set
form a multi
captures that problem
sets so eulerian
path that traverse
traverse every edge
traverse each bridge
picture without lifting
lifting your pencil
pencil or redrawing
redrawing an edge
vertices of odd
type the graph
container of positions
container like queues
methods called size
empty and elements
elements ; elements
elements would return
methods like swap
swap two positions
two positions replaceelement
replaceelement those kind
regular positional container
positional container swap
provide two positions
positions and swap
swap the contents
methods for positional
specific to graphs
graphs so numvertices
method which returns
vertices numedges number
returns an iterator
method next element
edges i call
edge what order
order this edge
implemented the iterator
undirected edges incident
edges incident edges
undirected graph incident
graph incident edges
kinds of edges
edges which start
vertex which end
entering a vertexv
ending at vertex
out incident edges
starting from vertex
out of vertex
objects an edge
indegree so degree
leaving the vertex
turns an iterator
notion of inadjacent
areadjacent whether vertices
vertices two vertices
return a boolean
value ; endvertices
edge is starting
edge is ending
graphs some edges
edges are directed
edges and roads
method which reverses
reverses the direction
tonnes and tonnes
tonnes of update
methods to create
create the graph
remove a vertex
set the direction
subset of method
set of methods
bunch of methods
update and modify
discussion on graphs
represent a graph
graph what kind
represent graphs data
graphs data structures
structures for graphs
discussed various things
things about graphs
graphs various terms
structures for representing
edge list data
adjacency list data
adjacency matrix data
matrix data structure
combined to give
give better performances
faster running times
simplest data structure
call an edge
data structure suppose
airports the blue
arcs are flight
airport and suppose
edges we call
call each edge
two such lists
structure the edge
structure simply stores
stores the vertices
two unsorted sequences
easy to implement
lists of vertices
edges each edge
edge recall corresponds
boston to jfk
node has references
list data structures
done very quickly
quickly for instance
operation called opposite
finding the adjacent
vertex i give
give you vertex
list of edges
find out vertices
adjacent to dfw
edge this edge
lax so lax
lax becomes adjacent
out the adjacent
size for instance
instance is constant
edges and vertices
tool list isempty
constant time number
edges takes constant
interesting thing suppose
insert a vertex
constant or order
lists similarly insertedge
vertex this last
wanted to remove
remove the edges
edges be referring
edges the list
edges is order
list to find
remove those edges
carefully and understand
understand the times
representing a graph
talking of today
represent both directed
directed and undirected
array of vertices
corresponds to vertex
link list starting
corresponded to location
lists so adjacency
data structure require
location the degree
vertex the total
part is sum
order of theta
pros and cons
adjacency matrix implementation
previous data structure
moving a vertex
two vertices adjacent
degree still degree
references of pointers
store more information
array typically indexed
number your vertices
out adjacency list
list of incoming
list of outgoing
instance the operation
mechanism of storing
storing edge information
regard to vertices
edges easily obtained
obtained what information
retrieve that information
answer that question
entire data structure
figure that out
information very quickly
out the incident
incident edges edges
edges edges incident
flight from dfw
dfw to mia
information it depends
out adjacent vertices
ways of organizing
organizing a graph
high level idea
minimum of degree
degree of worst
maximum but suppose
sense keep degree
doing this operation
vertices third representation
adjacency matrix representation
cross n matrix
basically just binary
binary entries bits
true that means
adding a vertex
adjacency matrix structure
matrix structure augments
augments the edge
edge list structure
edge list recall
telling which row
row they corresponds
augmenting an array
add new vertices
remove new vertices
structure which implements
right data structure
basically n square
vertices to determine
vertex to find
row or column
give you order
order n insertvertex
put down order
order n squared
two dimensional array
array and extend
column you understand
arrays are stored
major or column
column major form
simple edge list
operations are critical
manner if space
requires a lot
space it requires
requires n squared
space the standard
implement a graph
graph searching algorithms
graph search algorithm
basically a mechanism
mechanism of visiting
manner by systematic
vertex a graph
assuming adjacency list
adjacency list algorithm
list algorithm implementation
discussing graph searching
perform on graphs
breadth first search
first search algorithm
algorithm or bfs
bfs for short
call a breadth
first search tree
search on undirected
graph only today
first search makes
makes more sense
sense in undirected
assigned a initial
proceed in rounds
search the maze
tide one end
unroll the string
reach by unrolling
unrolling this string
call the vertices
discussing the algorithm
label will signify
element the neighbours
find its neighbours
neighbours and put
queue i color
color it gray
color of grey
sense the grey
vertices are vertices
signifies that black
vertices and white
white means undiscovered
reached those vertices
colored the vertex
neighbors and put
queue i assigned
queue and color
color them grey
grey from white
white i color
color gets colored
colored to black
element gets inserted
queue what label
label of two
white and put
grey are sitting
vertex is grey
visited and removed
queue its black
black everyone understands
queue becomes empty
empty the procedure
queue become empty
visiting the adjacent
level one vertices
search as dividing
dividing your vertices
vertices or partitioning
partitioning your set
vertices into levels
levels or sets
vertex at level
vertices at level
initially every vertex
infinite which means
put any labels
signifies the predecessor
vertex the vertex
initializing all vertices
color the vertex
starting vertex grey
process this green
grey or black
label we give
add the vertex
black to signify
operations like breadth
making the color
color ? color
giving a color
separate arrays indexed
first search procedure
spending constant amount
part ? constant
executed ? order
vertex v adjacent
statements ? order
vertex and summed
times the statement
statement is executed
times is statement
degree many times
vertices so order
order m times
enqueue a vertex
black you don
put a white
queue in fact
fact this statement
case the total
thing is order
couple of properties
properties of bfs
visited which means
visit those vertices
vertices the vertices
edge which gave
gave that vertex
vertex its label
vpi every vertex
basically the set
ignore the dotted
talking about note
graph the predecessor
vertex was discovered
queue and looked
adjacent to vertices
lines now form
form a spanning
solid line entering
eventually i hit
root basically starting
graph these solid
solid lines form
form a connected
spanning tree recall
tree this spanning
lines they form
form the breadth
darkened the line
drawn the arrows
label this vertex
darkened these lines
forms your spanning
screen to show
vertices in level
vertices of level
vertex in level
discovered this vertex
vertex and put
put it level
thing about structure
showing the tree
skip a level
edge which skips
skips a level
made a small
vertex was adjacent
vertices were adjacent
property of breadth
mind certain edges
call them tree
part of bfs
predecessor this vertex
multiple edges leading
levels zeroth level
level this vertex
picked one arbitrarily
tree the bfs
vertex why shortest
vertex of length
path of length
level which means
vertex is adjacent
level number equal
choosing the predecessor
discussion on breadth
search for finding
finding the connected
application of breadth
first search -connected
search -connected components
-connected components -bipartite
components -bipartite graphs
-bipartite graphs today
applications of breadth
search to finding
out the connected
graph is bipartite
first search recall
label these vertices
label every vertex
first connected component
procedure which returns
returns this labeling
array called label
components that number
constant time determine
connected components question
components your graph
vertex are maintained
search the first
doing our breadth
vertex and starting
doing the breadth
give each vertex
giving each vertex
vertex a label
call this component
first search starting
vertices and put
end up putting
visiting these vertices
component number equal
connected component number
pick any vertex
set then done
start a bfs
thought is required
found the last
last root vertex
vertex and continue
start a breadth
end up labeling
labeling certain vertices
turning time equal
equal to order
number is total
graph the graph
required for traversing
traversing this array
array to find
start our breadth
traverse this array
array ? order
starting when searching
number of components
made one scan
right time bound
started breadth first
started my breadth
suppose i started
vertices these vertices
array and mark
selecting the root
array and label
label that vertex
spending a constant
putting this vertex
access this vertex
spend a constant
accessing this array
array and updating
updating that information
adjacency list representation
array and make
correspondence as numbers
determine connected components
linear time algorithm
recall a graph
vertices and set
talking of undirected
exist a partition
equals u union
intersection w equals
divide the set
graph every edge
point that means
graphs actually model
model a lot
lot of things
things one standard
applicants to jobs
applicant is suitable
subset of jobs
thing such graphs
find a lot
kinds of settings
search will divide
divide the graph
layers into levels
edges which jump
bipartite ? suppose
suppose these red
suppose all edges
i.e no edge
implies the graph
graph to simplify
component is bipartite
components is non-bipartite
level the claim
solved the problem
problem here suppose
find an edge
vertex you started
started this bfs
proof is correct
out another aspect
bipartite graphs suppose
prove that fact
proved this fact
suppose the graph
happen ? suppose
suppose this vertex
side ? suppose
show the previous
found an edge
search to check
equivalent to checking
taking alternate levels
procedure to check
color we gave
vertices were colored
removed this vertex
stop the procedure
neighbor is white
reboot the graph
point is black
point being black
test for non
identify that edge
point i made
understand his question
point ? depends
edge is grey
keeping level numbers
quantity is important
important that level
level number business
business is important
keeping the level
graph is non-bipartite
thing i wanted
procedure is giving
number of vertex
started a breadth
search from vertex
bunch of levels
define what shortest
shortest path means
modify this definition
vertices the shortest
travel the minimum
reflect the number
number of hops
taking say suppose
fast on link
processed and forwarded
forwarded and stuff
pick a path
travels very quick
find the shortest
path the claim
simple i start
predecessor its predecessor
level you understand
understand what predecessor
vertex which gave
jump a level
level which violates
violates the fact
jumps a level
violates our breadth
first search property
property that shows
number would give
understood i give
define the diameter
two vertices maximum
vertices maximum distance
means ? distance
two vertices equals
vertices equals length
length of shortest
quantity to compute
impossible to compute
specifically defined maximum
defined maximum distance
find the diameter
answer ? bfs
largest level number
find the maximum
started my bfs
determining the diameter
depth first search
half the diameter
times the maximum
bfs you understand
understand ? diameter
search you understand
claim is diameter
number and diameter
diameter is greater
maximum level diameter
doing one bfs
first search data
search data structures
talking about depth
searching a graph
looked at breadth
applications where depth
meaningful than breadth
piece of cheese
squares i put
ends up doing
explore that path
mouse has photogenic
find its cheese
moved another step
south and west
west and north
doubt about left
find the cheese
south and south
sides are blocked
backtracks backtracks means
make any progress
backtracks and backtrack
easy to find
found the cheese
formalize this shortly
direction so direction
correspond to taking
taking one edge
vertex and continuing
notion of goal
mechanism of exploring
continuing our depth
basically a method
method of visiting
graph and show
including some terminology
search is applicable
graphs so small
small simple graph
case of breadth
mouse we choose
option going east
east then south
adjacency list implementation
recall an adjacency
list of adjacent
vertices the first
edge i considered
follow the procedure
reach this vertex
visited the vertices
vertices i reach
leave this vertex
things are progressing
back ? backtrack
backtrack which means
reach a vertex
increment the counter
edge i decided
finished my visit
explored all options
ready to backtrack
vertex i backtrack
reached this vertex
explored this possibility
explored all possibilities
explored this edge
explore this edge
vertex each vertex
search any questions
notion of black
grey and white
color a vertex
color it grey
leave that node
removed the node
inserted the node
queue in breadth
search i color
queue i put
put its neighbors
neighbors is white
white i put
color that node
node is white
black or grey
out the edges
search with red
red i travel
edges so number
red edges equals
equals n minus
vertex these red
red edges form
connected sub graphs
tree the red
form a tree
tree was defined
defined in terms
terms of predecessors
redraw this tree
dfs tree edges
shown are meaningless
natural parent child
parent child relationship
nodes the parent
talk in terms
terms of parent
parent child siblings
hanging the tree
properties of depth
search these green
edges the green
visited i don
edge i backtrack
vertex already visited
term back edge
option i exhausted
edges we don
visited we don
dotted red edge
drawn a dotted
visited this vertex
vertex was visited
level in breadth
collection of levels
imp very important
ancestors ? suppose
child of ancestor
backtrack before backtracking
cover that vertex
vertex that path
ready to define
ancestor with respect
search with respect
tree the notion
ancestor is coming
defined dfs tree
tree an edge
distinguish between tree
edges an ancestor
node an ancestor
search basically means
search you end
end up dividing
two classes tree
classes tree edges
edge gets classified
classifies every edge
similar to breadth
first search means
search means breadth
first search classifies
search in undirected
directed graphs things
things will change
change a bit
fairly complicated thing
complicated thing stacks
stacks or recursion
things we needed
vertex is visited
distinguish between grey
grey and black
distinguish between white
white and non-white
array called visited
means not visited
first search involve
mark this vertex
vertex as visited
visited v equals
doffs dfs dfs
visited if visited
visited w equal
trivial to understand
understand this part
suited for depth
write three line
four line program
picture i started
started a depth
vertices were considered
started my depth
vertex since visited
launched a depth
launched depth first
first search visits
bunch of vertices
visited and marks
marks them visited
consequence this guy
visit a bunch
terminates ? dfs
recursive call terminates
terminates we end
call to dfs
lot of recursive
point it terminated
terminated we made
made a call
make a call
visited another bunch
visited any vertex
vertex whose visited
launch a dfs
set to visited
means the dfs
terminates the claim
visited in dfs
reachable from dfs
continued and visited
visited all vertices
add my timestamps
modify this procedure
two other arrays
stamp and increment
change the starting
procedure to identify
identify which edge
mark its edge
wanted this information
information every edge
mark the tree
ready to launch
write that statement
equivalent to identifying
stop here today
spend a couple
couple of classes
classes in applications
applications of depth
applications of dfs
talking about applications
discussing the running
first search today
application of depth
two edge connected
edge connected recall
class we wrote
wrote a small
equals one lets
notion of children
marks the node
node as visited
start the dfs
adjacent nodes provided
dfs v corresponds
careful some careful
check the end
end is visited
doing a total
traverse this list
pointer which points
update the pointer
pointer to point
pointer becomes null
null or reference
reference becomes null
loop i advance
advance that reference
advance that pointer
start a dfs
procedure the dfs
retrieve that pointer
reached this pointer
back from dfs
retrieving the fact
pointer was pointing
recursion the fact
make a recursive
call i store
store the local
call this array
initially is pointing
equal to null
equals p dot
replace this line
note that visited
make this recursive
traversing this list
traversing the adjacency
repeat any entry
edge is visited
edge is looked
recursive call finishes
variable this local
call was made
simulate the recursion
clear what variables
stack what information
case of recursion
recursion two things
things are stored
stored the parameters
stack also stores
stores return address
address and stuff
things you don
out the details
looked at dfs
edges has tree
distinction between tree
back edges suppose
form a back
back edge suppose
information i reached
edge you reached
ancestor descendant relationship
reach the descendant
tree then first
finished a descendant
backtrack you finished
finished a node
make the difference
difference ? suppose
search to determine
write down connected
vertices and capital
minus e means
remove the edge
connected in words
words a graph
edge a graph
graph two edge
edge whose removal
disconnects the graph
bridge this edge
bridge this graph
two edge connectivity
connected to begin
matter which link
fails your network
link can call
call the network
network to break
basically measuring liability
sir each vertex
find a cycle
check this property
sir by bfs
graph remains connected
remove it check
order m square
square by removing
removing every edge
edge and checking
checking if resulting
cycle two edge
edge connected graph
edge that means
path of traversal
first search suppose
tree i obtain
explored this entire
remove one edge
pieces by removing
edge i create
pieces are connected
taking this green
node i wanted
means every pair
pair of node
node is connected
connected which means
thing is connected
removed this red
edge this red
edge is present
check everyone understands
words when backtracking
descendent so descendent
includes the node
ancestor which means
edge that node
back edges starting
spending a lot
deepest back edge
build this information
out the deepest
tree ? suppose
done this information
figured this information
run the dfs
end up running
suppose i figured
compute the deepest
compute that compare
smallest possible arrival
write our dfs
edge connectivity procedure
call the dfs
connectivity procedure eventually
procedure eventually recall
maintain my arrival
arrival counter suitably
updating this variable
smaller than dbe
dbe equal minimum
minimum of dbe
node is visited
write that minimum
thing again minimum
dbe equals minimum
running a arrival
continue if dbe
dbe equals arrival
stop your procedure
found a bridge
equal to greater
explain else part
back edge starting
track of deepest
deepest by arrival
verses the arrival
vertex with arrival
marked this edge
two minor things
important your procedure
built on top
top of dfs
solved in liner
couple of minutes
done a discrete
intersect now suppose
vertices i told
graph is complete
drew the initial
graph a planar
graph this problem
solved using depth
algorithm which runs
runs in linear
algorithm to check
graph is planar
non planar graph
shown you learn
non planar graphs
defined two edge
define two vertex
two vertex connectivity
connectivity just replace
replace the edge
two vertex connected
removing any vertex
connected this corresponds
corresponds to computer
matter which computer
vertex connected graph
graph for instance
remove this vertex
graph this graph
checked by depth
search in linear
notion is cut
application that depth
briefly two examples
graph and checking
search in directed
undirected graphs data
dfs in directed
directed graphs today
last two classes
looked at depth
directed graphs differ
differ from depth
put this edge
back here suppose
vertex the process
code for depth
search would remain
benefit so depth
quote for depth
thing adjacent means
adjacent to vertex
term out adjacent
call this vertex
talk of adjacent
edge going out
finished the procedure
give the arrival
arrival and departure
modify this graph
graph a bit
change the direction
visit all vertices
connected for instance
search you started
started the breadth
components similarly depth
similarly depth first
graph would visit
search would visit
vertex this vertex
visited and started
started out breadth
finish our depth
pick that vertex
visited and continue
continue our depth
pick this vertex
finish this depth
manner every vertex
redraw the tree
depth first breadth
breadth and depth
first search require
visit every vertex
graph was connected
visited a bunch
visited and start
start a depth
traverse the visited
make one scan
draw the back
understand what kinds
make them darker
find in dash
dash dash dotted
noise every day
day you pen
realizing its blue
red light red
sir sketch pen
sketch pen sir
watching this program
case of undirected
categories either tree
suppose this edge
continuing to follow
follow this path
point is visited
classify these edges
give them names
names our green
call that forward
forward the brown
term backward edge
edge the red
edges the brown
clear tree edge
single ten vertex
edge so cross
visiting the left
left the cross
higher to lower
left this cross
makes an edge
edge of forward
relate its arrival
verses the departure
edge so arrival
verses of arrival
departure ? departure
reached here arrival
managed to create
create a mess
first i reach
arrival and departures
departures are arranged
cross edge great
search the edges
edges get classified
categories and based
create the tree
identify the parent
ancestors descendant relationships
out these things
graph g check
basically a path
path which closes
access the starting
tree a tree
form a cycle
edge are connected
encounter a back
forms the cycle
vertex i start
retrace my path
find a back
cycle the child
child is traversed
origin of cross
question so statement
means no cycle
cycle no back
graph a cycle
means a path
streets a cycle
reach the starting
starting point great
back edge means
order the vertices
largest departure times
times are decreasing
edge the edge
edge its tail
right a forward
edge the departure
edge then departure
coming from right
worrying about departure
simple proof theorem
point you encounter
finish your depth
search without encountering
encountering a single
single back edge
declare the graph
graph is acyclic
graph we started
encounter any back
decreasing departure times
right this ordering
find a topological
produce an ordering
array i put
algorithm which performs
computed in order
talking of directed
directed acyclic graph
bit in circuits
kind of graphs
regular directed graph
application of dfs
develop the terminology
undirected graph connected
connected so connected
connected a directed
term ordered pair
graph strongly connected
path still pardon
pairs and check
strongly connected component
vertices any pair
pair i choose
choose is connected
part of cycle
daily weakly connected
weakly connected graph
ignore the directions
strongly connected graph
doing a dfs
strongly connected means
require something similar
engineering iit delhi
iit delhi lecture
directed graphs recall
talk about strong
strong connectivity means
two vertices lets
call the graph
number of dfs
making n dfs
graph if dfs
dfs v visits
visits all vertices
vertices in graph
exists a path
claim there exists
find a path
exist a path
lower most vertex
ending first starting
vertices are visited
vertex gets visited
vertex which means
change the function
out adjacency edges
reverse the graph
understands the procedure
procedure is pick
pick an arbitrary
learn the properties
properties of dfs
perfectly fine algorithm
requires two dfs
gammon of definitions
definitions and terminologies
edges which form
form the dfs
lets say backtracking
similar such thing
case of strong
kind of edges
enter the sub
root for instance
instance to vertex
stop the process
stop our dfs
check this thing
modification to make
tree the check
reach every vertex
suppose this node
reach a node
descendant this node
strictly smaller arrival
requirement to check
check this requirement
sub word sub
word sub tree
tree a bit
calling a sub
tree the generic
edge the arrival
smallest such arrival
return the deepest
dfs would return
returns the smallest
dfs v returns
tree and edge
cross edge forward
edge forward edge
four arrival times
quantity the dfs
return this thing
note that dfs
dfs from vertex
end up doing
value of dfs
out the edge
write the code
declare some variable
variable ? xyz
call it xyz
value of xyz
harm in setting
means out adjacent
dfs i set
set the visited
run this procedure
returns so xyz
xyz equals minimum
minimum of xyz
xyz equal min
min of xyz
loop if xyz
xyz equals arrival
vertex this quantity
quantity will turn
dfs are concerned
directed graphs checking
class any questions
done for undirected
graph is vertex
applications in detail
class what application
search ? finding
linear time procedures
procedures data structures
talking about minimum
minimum spanning trees
minimum spanning tree
algorithms of minimum
term is composed
two things tree
tree and panning
tree ? tree
cycles connected sub
graph without cycles
include all vertices
drew a graph
draw a spanning
pick this edge
edges ? number
tree ? minimum
tree of minimum
assume the lengths
lengths are non-negative
wires some options
length function suppose
connect these cities
cities which means
create a spanning
interested in spanning
length of wire
wire is spent
spent as small
spanning tree equals
tree equals sum
decide to pick
pick some edges
give this length
case of spanning
tree is trees
trees in graph
term free tree
edges we included
smallest possible tree
include this edge
means it form
suppose the edges
edge and drop
drop the edge
edge of length
drop this edge
remain a tree
create alternate path
face of vertices
add an edge
drop and edge
edge of longer
edge i added
reduced the cost
length or weight
drop any edge
tree has length
form the cycle
edges of length
sense to drop
draw the tree
sense to include
mst has length
include an edge
drop an edge
drop that edge
reduce the cost
reduce it anymore
analyse this algorithm
terms of running
algorithm for computing
tree and algorithm
algorithm in minimum
draw this graph
greedy to compute
compute the minimum
key thing make
write without thinking
minimize the length
pick the edge
building the minimum
edge by edge
edge i included
included the edge
choice to make
including an edge
include that edge
easy to write
step is sort
edges in increasing
order of length
length of edge
define some spanning
edges in type
including a vertex
include the vertex
dictate the running
log m algorithm
impure the tree
forms a cycle
formalize this equation
write your proofs
edges of kruskal
picked by kruskal
call those edges
give those edges
edge in kruskal
lengths are distinct
non distinct case
edges that kruskal
tree by optimum
sets of edges
found from kruskal
place they differ
point of difference
cycle ? add
formed this cycle
edges had length
edge has length
set is identical
line of argument
talking of case
distinct from g1to
g1to gi minus
kruskal not pick
edges is identical
implies optimum tree
spanning tree unique
lengths are unique
unique or distinct
unique minimum spanning
proved the correctness
correctness of kruskal
cycle in formed
cycle is formed
cycle be formed
connected component connected
component connected component
component or component
maintain the collection
collection of components
components so note
edges i pick
number of trees
prove very easily
connected components reduces
edge we include
maintain the connected
sets of vertices
give these vertices
vertices the sets
component they form
form a partition
continue the discussion
computing minimum spanning
collection of connected
union fine data
algorithm was considered
picked a set
form a forest
picked in krukal
edge being added
edge would form
end points lie
forest the tree
suffices to check
maintain our collection
connected component reduces
abstract this problem
out and capture
problem on maintaining
maintaining a collection
collection of disjoint
universe of elements
collection of disjoints
maintain a collection
case of kruskal
operation is union
operation of union
taking the union
maintain this collection
edge and determine
line same set
takes as parameters
description of find
returning the sets
returns the set
collection of sets
partition of universe
return that set
implement this operation
forming a cycle
write down kruskal
steps of kruskal
step ? sort
sort the edges
corresponds to edges
pick an edge
find u equals
equal if find
equal to find
initialised to null
initialize this collection
create this collection
maintaining the collection
operation ? number
number of unions
number of finds
moment you form
takes u times
out a good
good data structure
structure by good
suggest a data
sets ? linked
number of sets
complete this first
lists in constant
constant time union
large as log
good at data
tree ? heap
heaps ? order
show this thing
head the root
point is null
set whose root
represent a set
set is represented
elect a leader
element a lies
find b returns
takes the root
trees and links
decide to make
make b point
return a reference
taking the roots
roots and merging
find d find
make d point
find a return
returns a pointer
make c point
make e point
tracing the pointers
hits the roots
list of vertices
access the state
references of root
reference to point
union takes order
takes ? find
ways to reach
construct a sequence
sequence of unions
happen ? write
first to merge
doing the union
clever manner find
manner so recall
rule called union
union by rank
trees and suppose
make the lighter
lighter tree point
loss of generality
make this point
elements ; first
first you made
made this point
make this guy
case how high
high the tree
construct the worst
rule of union
rank will lead
lead to trees
minimum a tree
equal to log
set any point
nodes without loss
hypothesis is true
procedure that means
height of resulting
equal to max
lesser or equal
equal to number
hypothesis this height
define the tree
doing in induction
tree with larger
rank rank meaning
union by height
make the shallow
shallow tree point
place a log
log in bound
height h2 max
tree ? equals
quantity is greater
nodes is grater
node the log
takes ? constant
difficult to maintain
value is updated
maintain the height
maintaining the number
add this quantity
update this variable
graph ? log
improving the union
union find data
find data structure
required for find
technique called path
compression whose analysis
doing a find
performance of future
find this node
make this parent
guys become closer
put a dot
put a cross
continue to hang
bringing the nodes
reducing the height
reduces the number
union procedure requires
procedure requires height
height the root
tree will point
change this pointer
opting this procedure
work with height
changing the height
tree by doing
hard to recompute
tree in constant
union by number
tree has lesser
nodes the tree
tree with lesser
made to point
doing in path
traverse this link
make future easier
future finds easier
make another pass
change the pointers
doing the find
path to update
change the pointed
picture and decide
point in changing
keeping the node
create the union
kind of cross
adjutancy list data
follow that reference
reference and find
out which connected
component that vertex
discuss another algorithm
operations of union
modifying the sets
sets or modifying
modifying the collection
set it belongs
needed this data
implement the kruskal
algorithm we looked
computing a minimum
greedy algorithm today
due to prim
graph a spanning
tree is defined
cut in graph
splitting would define
define a cut
examples of cuts
power n minus
repeating each possibility
possibility is repeated
partition of vertex
cut or edges
understand which edges
denote other point
edge is length
simplify my arguments
simplify my presentation
assume edge lengths
make a tree
tree or part
edges are part
choose my edge
part of minimum
cut will belong
mst is short
short for minimum
happen ? cycle
vertex any path
edges which means
edges has length
reduce the length
cycle got formed
created the cycle
edge whose length
length is larger
removing this edge
remain a spanning
removing any thing
proving a structural
cut the minimum
remove any thing
proving this statement
cycle has length
exploits this simple
essentially is built
give every edge
put down edge
length of length1
included everyone understands
done the proof
proved this claim
assumed edge lengths
run the kruskal
works very simple
implement this algorithm
step ? add
add a vertex
call this set
collection of vertices
easily by keeping
edges and find
maintain a minimum
single this vertex
figure out minimum
knowing the minimum
out the minimum
earlier the minimum
heap ? min
put some elements
operation called delete
heap in constant
find min takes
min takes constant
point of vertex
vertex the edges
vertex to vertices
bad data structure
structure for searching
put some information
harm in deleting
show this delete
heap in log
edges and noting
operation are required
removed these edges
added each remove
remove and add
add takes log
spending ? degree
degree times log
processes each vertex
log m number
min ? number
elements of initial
vertex to include
cut not visited
pick a vertex
vertex root equals
insert the edges
insert the edge
edge h dot
dot find min
find min equals
return in edge
find the end
edge dot insert
execute this loop
executed n minus
vertices or edges
set s complement
complement each vertex
suppose these edge
heap of vertices
minimum edge incident
find the vertex
call this labels
track of edges
update or decrease
decrease the label
decrease priority decrease
priority decrease priority
delete find min
update its priority
greater than length
label w equals
dot decease priority
running time complexity
vertex and degree
priority also takes
looked at prim
implementing it data
single source shortest
source shortest path
similar to prim
graph and today
graph is directed
edges to positive
positive ? non
ton and tons
stands for termination
stand for destination
interested in taking
taking the shortest
option fourth option
edge is directed
problem to compute
compute the length
compute the shortest
high time complexity
matter just list
out your paths
number of paths
means exponentially varying
diamonds would count
diamond i associate
associate this vertex
takes the top
path that takes
roughly how large
number of particles
graph of size
compute shortest path
shortest path system
approach to compute
figure out shortest
out shortest path
reached this point
reach this destination
shortest heap improving
improving the path
means this part
vertex any vertex
computed the shortest
vertex the graph
shortest path problem
computing the shortest
abbreviated as triple
vertices and suppose
suppose these lengths
fact that shortest
positive why negative
distance of vertex
out the distance
initially the directed
vertex have vertices
path have length
shortest path found
path found nay
found nay point
found with visited
vertex then compare
length already stored
concretize this algorithm
put down numbers
separate this out
shown those edges
correct shortest path
found another path
distance i call
call them tentative
proceeds for instance
reduce this earlier
prove its correctness
straight forward algorithm
algorithm is first
algorithm in grained
found the shortest
step of algorithm
found the correct
value of shortest
invariance the algorithm
vertex i move
move that vertex
minimum is moved
update these labels
values of distance
distance label recall
put every vertex
give every vertex
vertex distance labels
smallest distance labels
insert h dot
call it decrease
heap the minimum
case of prim
dot delete min
update its label
update the label
maintain this information
level everyone understands
dot decrease priority
carefully this implementation
out the length
version of prim
case of dijkstra
algorithm this label
label v equals
calling that label
hazard a guess
vertices are part
doing the correctness
summation degree log
calling this loop
decrease priority operation
priority operation takes
removing the vertex
mistake i made
thing will coming
coming as min
times this operation
discussion on shortest
root data structures
correctness of dijkstra
looked at dijkstra
computing the single
path the algorithm
algorithm what remains
algorithm computing minimum
algorithm is correct
done in dijkstra
negative edge length
understand the semantics
recall is infinite
step only decreases
complement the vertices
computed there actual
actual shortest path
shortest path distances
signifying the fact
make this claim
claim to argue
shortest path distance
update the distances
label were sitting
minimum that correspond
vertex in capital
path including vertices
includes only vertices
induction make sense
true the numbers
vertices do reflect
reflect this quantity
move one vertex
continue to reflect
establish this claim
end up updating
updating the distance
satisfies this thing
means the earlier
picture s complement
moment it hits
path has length
path what remains
knew the shortest
vertices of capital
make this argument
length of path
include w shortest
out the shortest
write that part
capital s complement
minus w capital
moved this thing
thing this path
smallest possible path
ignore this thing
paths are captured
quantity only smaller
takes an edge
semantic in mind
mind every thing
simple to follow
distance label reflect
reflect this kind
kind of length
justified in moving
moving the smallest
smallest label vertex
taking this vertex
label and moving
justified in doing
smallest d value
complement the claim
shorter path form
path will visit
visit some vertices
lot of crazy
path whose length
means the entire
fact that edge
drawn has length
path we started
smaller than length
moving this vertex
found the length
shortest path form
path would include
include some vertices
recap the argument
argument this clam
proving using induction
proving this induction
statement we required
found a shortest
head and figure
right induction statement
argue for vertex
vertices s complement
argue this statement
include these vertices
includes the vertex
vertices basically sub
basically sub vertices
continue to remain
changed the distance
moved one vertex
move this vertex
path which includes
provided the path
shortest path unqualified
moment we move
correct the base
case is correct
argues the correctness
algorithm this algorithm
algorithm is due
due to dijkstra
graph had edges
edges of negative
length in fact
graph has edges
path some times
instance the shortest
cycle for instance
length of minus
negative length make
length make sense
negative edge lengths
graph which represents
represents currency tradings
global currency trader
profit i incur
incur in doing
change your rupees
back into rupees
setting where negative
negative would make
path in graph
sufficiently a larger
negative length brilliant
length brilliant idea
add a delta
work ? number
lot of edges
make this path
increase every edge
track of number
graph negative cycle
part of argument
plenty of negative
make your millions
basically not discuss
discuss it today
vertex has linked
maintain a pointer
compute shortest paths
things that remain
source shortest paths
discussion on single
shortest path today
compute the path
compute the distance
edges had non
non negative lengths
negative lengths today
compute single source
path when edges
vertex is moving
updation is happening
maintain with vertex
means the shortest
vertex we maintain
maintain predecessor information
information to compute
path ? suppose
vertex which precedes
maintained this information
reach the source
update the distance
update the predecessor
transfer a vertex
updating its information
path you found
update the information
information and pred
pieces of information
find the path
set the predecessor
source to null
out the vertices
edges one suggestion
figure this out
understand what edges
predecessor vertex information
vertex information bur
connecting the predecessor
n-1 predecessor edges
ignore or forget
forget the directions
back the direction
basically a sub
specific root vertex
remember this step
context of shortest
shortest path tree
follow the unique
similarly the shortest
n-1 edges capture
compute this tree
required by dijkstras
spent any additional
class if edges
edges have negative
talking of single
kind of negatives
cycle because recall
thing is meaningless
non simple path
repeat any vertex
cycle has positive
exists a shortest
attention in finding
finding a simple
interested in finding
finding simple path
kind of algorithm
information this guys
communicate this information
source has length
found a path
change its thing
call one round
neighbors and sends
sends the information
node also gathers
gathers the information
neighbors and updates
updates its value
updated its value
transfer then updation
simultaneously a node
implement this thing
maintaining this distance
implement one round
notion of actual
degree the total
difference between length
length and number
path using edges
n-1 shortest path
lengths were positive
similarly shortest path
value which means
means the value
rounds this vertex
prove the claim
claim by induction
changing the value
vertex whose value
vertex you reach
reach the vertex
value for confusion
reduce the running
bit the worst
case will remain
round this guy
lesser this guy
give a vertex
shortest path contradiction
suppose this statement
true till round
double induction kind
modified the code
thing gets updated
assume this vertex
label in round
apply induction hypothesis
hypothesis which means
guys are worried
modify the thing
equal to min
briefly is apsp
pair shortest path
paths with positive
positive edges length
path when edge
lengths are positive
positive when edge
thing is negative
negative please remember
fact every thing
end today lecture
lecture on shortest
path in fact
discuss data structures
introduction to data
terminologies regarding data
definitions an algorithm
programming language data
language data structure
lot of data
process develop data
develop data structures
organizing the data
specification a sorted
non decreasing sequence
sequence of natural
numbers of non-zero
completely specified input
examples of input
finite length forms
forms an instance
number of instances
sequence of sorted
numbers as input
describing the actions
infinitely many input
instances and algorithms
algorithms for solving
solving certain problem
brings the notion
notion of good
algorithm ? good
efficient ? efficient
takes less memory
measures of efficiency
analyzing the running
analyzing the space
efficiency of algorithms
function of input
behavior of increase
size of input
measure the running
write a program
language you run
run the program
program with varying
varying data sets
larger data sets
kinds of varying
takes and clock
utility like system
current time millis
good your algorithms
determine how good
good your algorithm
algorithm is implementing
spend considerable amount
set of inputs
run your experiment
set of instances
algorithm is taking
comparison platform means
hardware and software
machines would make
point would make
develop the general
develop a high
high level description
describing an algorithm
description to figure
out the running
system a methodology
evaluate the efficiency
takes an array
stores an integer
array algorithm array
algorithm array max
syntax is wrong
mixture of natural
high-level programming concepts
program is doing
doing is clear
variable called current
array current max
current maximum element
update the current
return current max
max if current
conveys the idea
structured than usual
language how pseudo-code
numeric and boolean
relationship in java
parameter it takes
kinds of programming
terminates and return
call a method
object used calls
specifies the type
algorithms ? first
low level operation
call or return
operations or logical
operation ? data
arithmetic an logical
inspect the pseudo
code and count
number of primitive
sorting the input
numbers and output
non decreasing order
make an output
algorithm should sort
produce the sequence
running time depends
sorted these numbers
things the first
first sorting technique
game of cards
strategy you follow
set of cards
hand you start
card and insert
jack and queen
cards and inserted
pseudo-code for insertion
give an array
array of integers
integers as input
input and output
sorted the output
variables or indices
loop it starts
move it right
place i run
insert this loop
loop will continue
loop will terminate
shifting the element
element one step
location becomes empty
find the right
element and insert
analyze this algorithm
arrow please make
make a correction
represent the amount
operations is executed
done n times
start by assigning
roughly n times
operation ? key
times just leave
leave the comment
counts the number
shift an element
inserting the card
count that quantity
checking this condition
reach this condition
condition for times
times the total
key this statement
quantity which depends
sorting the instance
difference that makes
compare the element
times n minus
talk about asymptotic
times some constant
minus some constant
worst and average
sorting n numbers
case is defined
1size of size
give the values
compute worst case
create a plot
out the worst
monotonically increasing plots
algorithm will increase
size becomes larger
easiest to work
long your algorithm
algorithms worst case
worst case occurs
algorithm is close
worst case average
case average case
difficult to compute
instance is drawn
quantity to work
measure of interest
working with asymptotic
rid of superficial
constant times squared
constant times ,because
,because this constant
interested to distinguish
input size doubles
doubles the running
increases four fold
interested in capturing
analysis clearly explains
increases with increase
increase in input
big-oh ? o-notation
represents the input
input size increases
drawn two functions
functions the function
function in red
function the function
function in green
examples would clarify
examples the function
scale the scale
similarly on x-axis
x-axis the red
red colored line
point of crossing
straight line displaced
displaced by suitable
amount the green
blue in color
out a constant
pick a larger
simple rule suppose
drop all constants
lower order terms
order terms forget
forget the constant
drop the constant
constant and lower
drop all lower
fastest growing term
drop my constant
limit this quantity
times this quantity
error the function
provide as strong
express the number
executed during run
takes the number
increase four fold
similarly our algorithm
hierarchy of functions
order of log
word of caution
algorithm whose running
1,000,000 n algorithm
limit is achieved
achieved very late
large for small
examples of asymptotic
output an array
compute each element
taking the value
running the index
dividing the value
compute the running
n-1 this entire
thing is done
times the steps
steps are executed
kind of repeating
divide this sum
finish the iteration
doing two primitive
two primitive operations
operations that makes
makes an order
executed n times
linear and quadratic
quadratic and logarithmic
constant k algorithm
notation and big-theta
big-omega ? notation
bound the function
two more related
related asymptotic notations
little-oh ? notation
little-omega ? notation
analogs of big-oh
big-oh and big-omega
analogy of real
talk of equality
equal little-oh corresponds
part the formal
definition for little-oh
defines the difference
largest problem size
hour the largest
increases an hour
problem you solve
log n algorithm
solve for problem
millions of years
years to solve
data structures
naveen garg
garg department
computer science
engineering indian
indian institute
delhi lecture
abstract data
data types
growable stacks
amortized analysis
virtual machine
data type
real numbers
define data
operation requires
mathematics class
constructor operation
constructor method
sophisticated data
work access
access functions
access elements
manipulation procedure
building blocks
algorithmic procedure
higher level
advanced data
data structure
dynamic set
objects suppose
create data
dynamic sets
method insert
delete method
method removes
access methods
return value
type boolean
false axioms
write axioms
resulting set
previous set
operation isin
basic axioms
operations permitted
simple abstract
last-in-first-out principle
removed first
key methods
push method
pop takes
takes stack
top element
error stating
top operation
operation returns
pop pop
pop operation
operation removes
support methods
operations size
method size
size tells
axiom governs
stack abstract
axioms axioms
translate abstract
interface specification
implementation meets
programming technique
stack implementation
java java
built-in stack
stack data
stack interface
return type
type object
object object
generic type
method isempty
isempty returns
returns boolean
throws stackemptyexception
void means
handle errors
exceptional condition
exceptional case
control moves
current method
exception occurs
eat pizza
pizza method
stomachache exception
dotted code
throw stomachacheexception
procedure public
public void
void eatpizza
method eatpizza
stimulate meeting
meeting procedure
dotted point
reach ta.eatpizza
catch blocks
procedure call
procedure stomachacheexception
local variables
global variables
catch block
block start
exception raised
exception stomachacheexception
method raises
written inside
procedure simulate
simulate meeting
parent procedure
stomachacheexception throws
high level
level procedure
exception appearing
procedure stops
user system.out.println
java class
statement stomachacheexception
catch statement
propagate upwards
procedural hierarchy
hierarchy stomachacheexception
calling procedure
parameters written
listening exceptions
throws class
throws stomachacheexception
object stomachacheexception
class public
public class
class stomachacheexception
stomachacheexception extends
public stomachacheexception
string err
method takes
single parameter
string super
super means
super class
method calls
stomach ache
ache exception
method throws
catch statements
java book
maximum size
first element
entire implementation
array stack
statement mentioned
class arraystack
arraystack implements
implements stack
stack implement
implement stack
stack means
default capacity
public arraystack
int cap
constructor methods
returns false
full exception
incremented location
first increment
stack empty
empty exception
location elem
top location
element pop
return elem
private member
array implementation
operations required
virtual dependent
upper bound
default value1024
large size
small stack
exception stack
pop methods
daily stock
stock prices
stock price
maximum number
consecutive days
day price
current day
true done
repeat-until loop
reached day
worst case
total number
case question
closest day
day preceding
preceding day
first price
price greater
7th bar
6th bar
top value
loop executes
loop executed
statements inside
for-loop execute
statements execute
iteration put
element stack
give maximum
original stack
top counter
tight strategy
growth strategy
additive increment
regular push
special push
larger stack
elements form
earlier stack
total cost
push operation
strategy behaves
4th operation
regular pushes
pound symbol
multiplication operator
previous array
phases total
change slightly
array size
5th element
spent units
copy elements
copying elements
strategy data
linked lists
last lecture
implement stacks
array today
linked list
first part
ended queues
last-in first-out
first-out principle
first-in-first-out principle
rear element
front end
standard operations
front element
isempty size
return false
defined axioms
similar axioms
empty queue
written front
initially empty
statement dequeue
remaining queue
circular fashion
blue part
queue reach
colored part
0th location
3rd element
queue drift
completely accurate
anymore elements
start inserting
right side
left side
front refers
rear refers
empty location
elements starting
empty suppose
element close
pseudo code
rear location
circular indices
modn point
return r-f
r-f tells
queue r-f
correct thing
positive quantity
right number
elements check
confused isempty
algorithm isempty
dequeue method
front index
last class
size increases
first node
last node
head node
tail node
torcezo element
rome element
last place
methods suppose
left head
head part
tail part
head point
head element
head easily
first diagram
last element
rear end
added element
previous node
tail point
entire list
expensive operation
queue data
double-ended queue
delete operations
last operations
good idea
good solution
double-ended queues
previous pointer
sentinel nodes
trailer nodes
previous port
dummy nodes
data inside
san francisco
sentinel node
node point
generic data
method top
method push
method pop
ended queue
insert front
remove front
queue front
dequeue implementation
adapter pattern
adapter patterns
patterns implements
adapter classes
classes specialize
general classes
arbitrary objects
adapt arraystack
arraystack implementation
integer objects
pointers head
circular list
pointer point
big pointer
end make
element rome
node make
straight forward
queue removing
element corresponds
2nd node
node copying
general sequences
vector data
indicative methods
4th element
departmental rank
department rank
step right
entire elements
operations insert
case spent
spent order
elements sitting
1st node
insert newyork
3rd diagram
takes order
java code
procedure nodeatrank
defining shortly
previous field
node dlnode
dlnode prev
dlnode node
procedure dlnode
original list
2nd diagram
previous pointers
final node
small improvement
hundred elements
vector abstract
require order
element correspond
delete linked
supporting node
node based
based operations
inserted node
operations provided
give access
based operation
actual implementation
positions position
method element
type position
previous fields
relative order
positions jus
3rd node
2nd position
3rd position
list abstract
abstract datatype
generic methods
query method
first position
last position
excessive methods
update methods
list data
datatype implementation
sequence abstract
multiple inheritance
additional methods
method atrank
array refers
rank suppose
1st reference
element stored
cross reference
sequence suppose
sequence operations
rank based
sequence data
type data
dictionary abstract
binary search
hash table
collision resolution
resolution techniques
hashing techniques
stores elements
store bank
bank accounts
account number
bank account
account numbers
account stores
stores wealth
current balance
account holder
transactions done
additional information
abstract model
key-element pairs
case suppose
student records
natural notion
entry number
main operations
standard container
container methods
query methods
key find
standard thing
special element
element nil
unsuccessful search
require comparison
student record
comparing keys
keys dictionary
dictionary suppose
doing things
arbitrary manner
efficient today
binary tree
black trees
avl trees
important data
abstract class
subsequent discussions
numbers lets
single number
sitting index
found number
return nil
key idea
design technique
future classes
sorted order
work suppose
middle element
increasing order
entire array
2nd part
3rd part
recursive procedure
lower end
higher end
return mid
left part
staring location
ending location
location mid-1
return binarysearch
recursive call
right part
small pieces
iterative procedure
blue color
first step
mid element
do-while loop
step range
first comparison
require comparisons
entire process
decreasing order
huge difference
difference coming
small pseudo
dictionary problem
large phone
phone company
phone number
phone numbers
digit numbers
million phone
unordered sequence
arbitrary order
unordered list
person decides
data record
small modification
entire thing
first location
inserting takes
maintain log
log files
log file
system administration
add data
add insertions
insertion takes
dictionary data
ordered sequence
key searching
searching takes
takes log
direct access
access mechanism
whichever element
element insertion
similarly deletion
previous class
create space
move order
big-oh notation
make sense
subsequent discussion
huge array
ankur phone
phone connection
bad thing
previous technique
smaller array
hypothetical setting
small number
entry numbers
hash function
location number
grade shape
simple technique
color thing
list starting
list suppose
computing modulo
collision problem
structure reduces
quick recap
hash functions
key modulo
constant amount
end suppose
simple arithmetic
arithmetic operations
good choices
function lot
simple examples
good hash
distributes things
ideal hash
random location
simple uniform
uniform hash
load factor
table divided
factor alpha
function takes
takes constant
right linked
follow pointer
average size
simple hash
excepted number
total search
excepted search
bad hash
structure relies
class designing
designing hash
successful search
excepted length
search excepted
elements examined
function computation
list divided
similar kind
low order
order term
good choice
excepted sense
growable stack
entire set
larger hash
function keeping
smaller table
larger table
table slots
elements coming
list length
small hash
large hash
space today
resolving collision
collision data
resolve collision
chaining today
linear probing
double hashing
famous paradox
birthday paradox
students sitting
high probability
small probability
non-integer keys
telephone numbers
treat telephone
telephone number
converting non-integers
non-integers keys
function value
hash code
code map
compression map
integer keys
arbitrary range
important requirement
indexed location
randomization happening
equal keys
popular hash-code
hash-code maps
hash-code map
bit pattern
numeric type
double real
real number
string suppose
ascii code
bad strategy
english dictionary
ascii values
great strategy
convert character
character strings
polynomial accumulation
evaluated value
large range
non-integer data
integer evaluate
integer value
experimental stuff
observed experimentally
experimental study
small range
natural thing
table suppose
integer mod
integer write
binary representation
taking mod
last bit
small set
bits based
simple compression
prime number
important thing
table close
key mod
number things
collisions happening
happening lot
generic principles
compression maps
fractional part
fractional number
floor function
means round
nearest integer
popular compression
popular ways
small fraction
smaller fraction
fraction part
fibonacci hashing
significant theory
nice book
ronald knuth
covers hash
key multiply
fixed numbers
compute modulo
first technique
patterns happening
random number
number generator
function random
number generators
linear congruential
congruential generators
starting value
give random
last value
last random
number generated
generate random
pseudo random
universal hashing
make life
life difficult
doing insertion
process starts
table implementation
bad set
3rd year
resolve collisions
call chaining
techniques today
general class
open addressing
addressing differs
key fact
fact recall
starting element
chaining technique
suitable manner
key sets
first probe
insertion depending
determining sequence
first place
guiding principles
current location
specific location
5th location
continuous locations
8th location
11th location
respective position
elements tend
form clusters
elements suppose
element present
10th location
12th location
12th position
search terminates
6th location
location suppose
problem coming
full location
location empty
null location
insert encounters
empty locations
search degrades
empty slots
addressing techniques
offset probe
orange color
hashing works
starting location
cycle back
offset divides
small fact
rough arguments
distributes keys
hashing recall
elements divided
sit inside
random element
uniformly random
unsuccessful search.what
search stop
expected number
probes required
hit fraction
occupied location
sense probes
excepted numbers
average number
successful searches
empty table
first elements
elements size
insert element
inserted elements
upper bounding
last number
table empty
minus log
fraction empty
number smaller
successful probes
hashing linear
linear programming
binary trees
turn parent
term grandparent
great grand
grand parent
family tree
real trees
generic term
internal nodes
internal node
term depth
maximum level
basic terminologies
call electronics
divisions rnd
organizational structure
student guide
support code
chapter grading
file system
unix environment
windows environment
root directory
ordered tree
left child
side suppose
eldest child
younger child
left node
right node
right child
root node
child node
right nodes
left nodes
representing information
recursive form
single node
nodes marked
right subtree
left subtree
right subtrees
subtrees remember
extreme left
arithmetic expressions
arithmetic expression
expression suppose
last line
resulting value
expression decision
decision tree
book star
star bucks
tree corresponds
fast meal
decision trees
concrete stuff
complete binary
level number
leaf nodes
simple counting
leafy kind
large complete
atmost nodes
important fact
last level
smallest height
shortest height
minimum height
maximum height
height atmost
atmost n-1
people make
tree means
means height
base case
leaf base
right hand
hand side
nodes suppose
induction hypothesis
simple proof
leafy tree
minimum number
generic container
method elements
position based
based container
position data
method positions
positions method
element method
positions replaceelement
position isroot
position correspond
accessor method
call root
root hope
root means
type casting
method parent
position returns
parent node
object type
type sequence
children position
typically application
generic method
tree binary
derived class
position give
node structure
parent typically
root method
child method
invoke element
position interface
parent link
child member
arbitrary trees
unbounded trees
data members
2nd level
right sibling
makes sense
trees today
trees data
tree walks
things today
tree traversals
tree walk
preorder walk
postorder walk
post order
preorder tree
walks suppose
suppose recall
research paper
first section
sub sections
paper end
sub section
preorder traversal
call preorder
first visit
node corresponds
children nodes
process repeat
child nodes
recursive traversal
visit correspond
means visit
order traversal
traversal recall
directory structure
directory courses
sub directories
sub directory
structure suppose
total space
space occupied
entire directory
total spaces
spaces required
order corresponds
space required
disk usage
usage command
recursive manner
ordered trees
first child
fourth child
leftmost child
general trees
children node
generic computation
pre order
child note
calling preorder
postorder traversal
first thing
left sub
sub tree
visit corresponds
node visit
right sub
entire sub
right answer
procedure works
sub expression
operator sitting
leaf corresponds
first evaluate
priority rules
understood inorder
inorder traversal
tree inorder
entire inorder
euler tour
tour suppose
generic traversal
special case
eulers tour
tour traversal
visited thrice
euler walk
thing suppose
left bracket
right bracket
subtree corresponds
left brackets
tree traversal
external node
leaf node
generic tree
java details
init result
left unspecified
methods unspecified
class anymore
manner create
sub class
manner specializes
traversal procedure
left result
r.left result
r.right result
final value
operator present
printexpression traversal
extending binarytree
binarytree traversal
traversal method
parenthesized form
class binarytree
directories structure
order suppose
blue colored
inorder traversals
node tree
web today
arbitrary sequences
in order
tree suppose
first figure
recursively work
sub trees
traversal preorder
unique tree
order traversals
child suppose
full tree
indian tree
single element
program efficiently
huge number
power n-1
absolute minimum
finite number
close form
form expression
stop today
traversing trees
traversals data
ordered dictionaries
search tree
simplest ways
ordered dictionary
dictionary functionality
functionality recall
recall dictionary
key element
element pairs
minimum key
maximum key
total order
ordering relation
function predecessor
dictionary keys
total ordered
successor function
trivial ways
list kind
order relation
smallest key
key larger
largest key
efficient implementation
ordered list
minimum takes
pointer reference
end node
predecessor takes
correct position
insertion searching
takes lot
array location
order log
searching recall
recall insertion
search property
children means
talking out
property holds
key value
property satisfied
property equals
search trees
implementation keys
keys stored
graphic order
alphabetic order
complicates matters
assume keys
entire discussion
duplicate key
duplicate keys
implementing dictionary
property keys
right keys
search procedure
equals nil
empty tree
recursively search
iterative version
recursive calls
current node
dot left
minimum element
wrong suppose
smallest node
leftmost leaf
node expect
expect left
last leaf
last internal
left children
sentence definition
procedural definition
entire code
successor element
successor means
key greater
key sub
hindi conversation
fresh sheet
successor lies
entire tree
null conversation
minimum node
non empty
right procedure
procedure correct
largest node
hits null
means null
successor code
order edge
insertion procedure
compute predecessor
similar idea
interchange role
alpha search
assuming distinct
distinct keys
fist search
search fails
null pointer
null reference
descending order
small height
height balanced
balanced trees
balanced tree
full binary
tree provided
random permutation
ascending order
bad tree
good tree
huge height
tree height
height tree
bad order
insert elements
random variable
variable means
minimum values
expected value
random variables
modify child
essentially parent
parent pointer
pointer parent
case sequence
deletion procedure
random order
deletion today
computing successor
computing predecessor
tree today
easiest case
case node
part abd
child point
3rd case
largest element
delete operation
deletion operation
2nd case
successor predecessor
tree case
pseudocode predecessor
right tree
in-order traversal
5th node
left suppose
root key
right place
out things
print out
good method
tree base
base sorting
sorting procedure
in-order tree
tree work
atleast order
todays class
bst sorting
final diagram
sorted sequence
bring backs
element inserted
variable recall
variable takes
permutation compute
3rd permutation
huge quantity
tree obtained
expected height
induce permutations
simpler argument
permutations divided
average times
previous setting
setting recall
average call
small round
coming inside
first triangle
darker triangle
original tree
unit extra
permutations appears
inserting keys
appearing times
insert keys
first key
permutations put
recurrence relation
previous points
fairly sophisticated
previous values
sum equals
previous expression
simplify things
sum inside
harmonic series
draw line
harmonic sum
integral part
sophisticated computation
height atleast
atleast log
height log
average case
interesting part
constant times
class today
discussed today
quick sort
sort today
sorting algorithm
insertion sort
case running
sort algorithm
quick algorithm
small constants
additional memory
place sorting
good thing
large collection
algorithm falls
conquer algorithms
smaller pieces
divide step
lower part
higher part
combining part
conquer algorithm
pivot element
lower half
larger part
larger array
sub array
stopped decrementing
sense culprits
orange part
means return
left half
right half
procedure takes
taking order
done utmost
memory space
loops put
statement executed
student conversation
complete quick
initial call
previous procedure
initial part
demarcating lines
larger half
upper half
half separately
true means
loop forever
loop stop
break statement
entire partition
partition procedure
additional copies
space created
single array
sort procedure
sort takes
elements end
equal halves
median lets
elements ended
equal parts
written theta
inter change
elements equals
part lets
basically theta
half split
skewed split
n-1 elements
upper part
smallest element
thing happened
back anymore
elements change
change out
out suppose
first stage
tenth means
largest number
largest guy
base two
times log
strange manner
constant fractions
argue log
constant fraction
formal analysis
analysis starting
unlucky cases
unlucky case
lucky case
partition half
median element
element pick
odd number
small array
small arrays
involved procedure
specific element
square running
randomized algorithm
random choices
randomized quick
equal probability
11th smallest
designing algorithms
partitioned procedure
randomized partition
last location
calling partition
random choice
good question
specific input
interesting thing
randomly selected
random numbers
numbers selected
selected decide
algorithm today
input sequence
comparisons required
first partitions
partition process
partition depending
element lets
n-i elements
quantity summed
compute expectation
expectation expectations
unloaded dice
variable lets
lets call
value takes
average suppose
probability means
value two
discrete values
value summed
probability times
quantity varies
chosen permutation
sort worst
crucial difference
doing today
done today
sort depends
value today
value tomorrow
numbers generated
fixed input
pivot lets
input order
number choice
make things
fix element
specific kinds
specific amount
specific algorithm
input sequences
vast difference
case analysis
average today
times depending
end today
sort data
tree data
avl tree
white spots
tree rooted
previous classes
singleton node
level numbers
50th node
children differ
node height
balanced property
smallest number
large number
node suppose
height h-2
smaller height
smaller number
recurrence relationship
solve today
base conditions
tree grows
simple thing
taking algorithms
crude analysis
sharper bound
tighter analysis
strictly larger
quadratic equation
golden ratio
fibonacci relation
fibonacci number
number minus
worked out
wrong thing
small correction
right value
leaves suppose
root suppose
red dot
level starting
big difference
tree hanging
hanging out
level k-1
larger height
largest value
largest height
simple argument
closest leaf
arbitrary binary
shaded part
height imbalance
height balance
balance property
tree extends
means levels
shown earlier
thing nodes
older bound
exponential number
logarithmic height
height property
sharpest bound
changed things
atleast half
first levels
thinning out
full height
first edge
levels means
structural fact
logarithmic depth
times search
tree forget
wrong recall
parent pointers
height change
change appears
imbalance property
property suppose
empty node
tree originally
property violated
grand child
rotation operation
bit mysterious
class understand
ways solving
structural property
similar bound
class data
place put
large tree
insertion process
change means
balance problem
height problem
problem means
height imbalanced
imbalanced height
imbalance means
essentially travel
nodes note
grandchild means
means child
process today
term rotation
picture shown
huge tree
null tree
rotation step
links back
tree property
local reorganization
insertion suppose
relationships suppose
insertion happened
increased height
height remains
increased implies
implies height
original height
argument roughly
originally imbalanced
final thing
big piece
tree properties
imbalance happening
single rotation
constant number
tree remains
symmetric case
case completely
height moved
middle key
previous rotation
step rotation
double rotation
switches loyalties
compute heights
heights height
original sub
final tree
key ended
thing uniformly
heights reduced
rotate nodes
balanced picture
double rotations
actual node
successor node
unbalanced node
node encountered
perform rotations
ancestor nodes
valid question
imbalanced node
imbalance imbalance
imbalance happen
guy decreased
wrong statement
bigger tree
bigger thing
thing height
previous case
asked earlier
rotation case
insertion essentially
ancestors ancestors
spent log
imbalance occurs
requires order
spend order
swap contents
rotations put
entire delete
performance guarantees
first point
point nodes
search properties
multi-way search
student entry
key helps
search process
keys sitting
node determine
first sub
last sub
middle sub
consecutive keys
consecutive pairs
tree searching
last key
middle child
valid node
tree multi
important property
square boxes
numbering level
additional properties
properties search
log4n log4n
tree lies
key lets
order height
visiting order
branch out
right pointer
empty space
link out
place insertion
nodes created
sufficient space
made children
smaller node
key left
split happening
tree increases
lower keys
higher keys
split process
node split
split takes
recall deletion
deletion require
child case
problem note
point out
simple case
means suppose
sibling suppose
small catch
adjacent sibling
merge node
cascading cascading
child left
sibling key
conclude today
discussion height
operations borrowing
complicated data
fast data
implementing dictionaries
red black
trees functions
involved process
spending fair
fair bit
handle insertion
black tree
tree subject
red node
black children
additional left
external nodes
non-external node
original nodes
black depth
black ancestor
black nodes
key property
black height
nodes black
black node
red children
left right
children black
first case
children left
black ancestors
key things
red child
red problem
term quiet
reds occurring
red nodes
alternate layers
red layer
black layer
total height
figure out
turn thing
first remember
compare key
children suppose
unique node
combined structure
critical property
tree node
double red
first putting
black depths
consecutive reds
major reasons
tricky operation
predecessors suppose
red leaf
black leaf
remain consistence
node verses
entire structure
red double
easy case
tricky case
cases corresponds
simple operation
black parent
single key
door deleted
cases happening
black lets
node children
blue triangle
children colored
case red
scan structure
starting picture
tree organization
tree sub
black heights
black red
symmetric thing
height business
black child
root black
resulting tree
case first
tree picture
node sitting
clear things
assumption making
entire black
valid thing
takes care
last assumption
height check
case left
started assumption
child lets
tree deletion
thing happening
process continued
deletion process
last case
tree reduces
fast procedure
height preserving
last thing
understand conceptually
process data
extensive process
a-b tree
tree differs
coloring obeys
node red
red colored
colored node
black colored
tree continues
problem remember
left picture
previous picture
simple rotation
rotation note
red problems
right manner
side tree
rotation takes
tree recall
single black
side corresponds
initial black
trees hanging
rounded part
problem moves
remain uniform
nodes lets
parent nodes
process ends
tree rotation
trees recall
faster process
minimum means
a-b trees
generalized idea
children root
discussion proceeds
small modifications
insufficient space
median key
lines disappear
middle path
adjacent node
upper node
space put
space split
remaining b-1keys
valid nodes
a-1this quantity
deletion deletion
28th node
number a-1
floor means
symbol means
integer round
quick summary
taking log
key thing
large databases
disk based
based data
specific value
large amount
main memory
references corresponds
pointer addresses
memory addresses
huge amount
amount data
transaction data
bank share
share markets
million customers
suppose type
sense secondary
secondary storage
entire search
disk verses
big problem
disk access
read write
write head
disk rotates
starts reading
significant fraction
head moving
moving determining
seek latency
rotation latency
right sector
entire sector
typically read
larger units
computer system
kilo bytes
page setting
entire page
search structure
based algorithm
memory algorithm
entire data
data sets
data sit
data setting
pointer business
concern pointer
memory location
operation disk
disk read
disk write
key means
first fetch
typical pattern
operation today
writing block
thousand lets
based access
level trees
levels structure
data base
bytes times
giga bytes
mega bytes
account lets
actual data
top node
key lies
account data
page size
pointer pair
means leaf
lower bound
special kind
structure meant
internal memory
large value
entire node
remember things
recursive search
first find
splitting nodes
split nodes
describe operation
catch today
disk operation
input outputs
parse operation
full quota
recursively travel
lower level
first root
step split
lets show
place suppose
full lets
addition key
crossing ripple
ripple effect
splitting process
single pass
potential disadvantages
doing deletion
earlier procedure
successful merge
cascading effect
pass delete
delete procedure
tree make
keys suppose
lets skip
situation happening
bads key
spending lot
node lots
pointer moments
things happening
delete happening
significant trouble
large sequence
long sequence
things alternating
sibling node
right back
pass operation
first pass
blocks read
small extension
based accesses
setting data
case study
pattern searching
pattern matching
english alphabet
things provide
exact matching
matching problem
approximate manner
means occurrences
text editing
information retrieval
big application
bio informatics
large database
protein sequence
naive method
mismatch right
fourth position
space complexity
additional space
index appropriately
huge document
solution today
complexity today
pattern string
position text
exact procedure
complete match
split pattern
mix pattern
disjoint occurrence
knuth-morris-pratt algorithm
famous algorithm
mismatch occurs
information obtained
shift forward
location i-1
part matches
shifted pattern
part match
pattern right
right shift
largest smallest
pick suppose
mismatch happened
key observation
useless shift
reasonable value
longest proper
proper suffix
contiguous parts
suffix proper
suffix means
means suffix
entire text
proper subset
subset means
strictly smaller
out length
longest suffix
suffix match
longest match
additional congestion
1th character
mismatch happening
tricky definition
smallest extent
mismatches happening
right extent
make shift
7th position
matches happen
guy matches
pattern h11
right suppose
11th position
matching part
minimum shift
shift occurs
maximum shift
minimum amount
longest prefix
shorter prefix
argue correctness
beta suppose
kmp algorithm
algorithm missed
happen suppose
missed occurrence
guy mismatched
alpha characters
length alpha
alpha matches
definition alpha
longer prefix
longer suffix
correct value
character long
input string
first mismatch
remain matched
position note
shift function
potential match
comparisons put
unsuccessful comparisons
unsuccessful comparison
text types
successful comparisons
red line
successful comparison
back track
track happening
comparison results
compute array
proper prefix
potential value
subset proper
proper suffixes
entire string
candidate value
square roughly
taking computing
previous value
nice idea
right idea
text suppose
pattern match
pattern matches
match student
simple algorithm
modulo fact
plain version
space sufficient
last topic
suffix trees
matching patterns
patterns finding
pattern appears
failure function
pattern speeded
brute force
force method
algorithm searches
arbitrary text
good situation
large piece
small pattern
collected works
million characters
characters large
previous kmp
lower case
case characters
ordered alphabetically
first level
first characters
first character
word suppose
sitting inside
array points
waste space
list ordered
alphabetical order
first nodes
link list
list sitting
word beginning
alphabet size
smaller alphabet
larger alphabet
insert bed
square node
circular node
longer change
case total
space requirement
first word
word begins
long chain
total size
word matching
matching find
first occurrence
instance appears
distinct words
sell stock
buy stock
bear occurs
bid bid
initial text
gene database
separate notion
special character
defined boundaries
trie first
standard trie
resulting node
single thing
compressed trie
node doesn
single character
simple suppose
nodes don
problem completely
longer label
label inside
store labels
6th word
sub string
contiguous part
nodes number
times number
deletion happen
compressed type
parent edge
subtle reason
start searching
done suppose
multiple times
simple data
implementation details
things out
web search
web pages
search engine
trie typically
google doesn
generic search
occurrence list
urls pages
occurrence lists
boolean queries
queries corresponds
set operation
stop words
internet routers
32-bit number
type google.com
iit delhi
delhi address
routing done
address written
links coming
routing tables
pattern started
biological data
suffix tree
starting position
words recall
words order
order number
order length
typically small
doing suffixes
compact representation
storing labels
big labels
end position
single text
edge labels
mutual parts
common part
original alphabet
longest path
label matches
edge running
order summation
path beginning
complicated algorithm
total complexity
means building
completely essential
thousand times
entire sub-tree
last side
pattern data
data compression
compression today
file compression
doing data
unique shell
man ascii
bit code
fixed-length encoding
fixed length
idea today
bits required
fixed-length coding
characters occur
coding screen
lesser number
lesser memory
variable-length coding
longer sequences
characters java
java is1
length encoding
choose1 bit
represents java
single bit
variable length
length decoding
retrieve java
java suppose
length codes
prevent ambiguities
encoding satisfies
prefix rule
encoding arising
codes satisfy
code words
code word
left edge
right edge
ended midway
character corresponds
first statement
encoded text
code satisfies
long piece
total length
encoding abracadabra
character suppose
tree number
total external
external weighted
weighted path
path length
external path
minimum total
total weighted
minimum length
encoded message
message minimum
red boxes
smallest value
option .we
nodes left
only1 bit
right thing
final trie
previous code
algorithm compute
characters suppose
smallest frequencies
characters frequencies
algorithm behaves
minimum quantity
tree computed
length computed
optimum tree
fact suppose
lowest weights
weighted external
remaining tree
node weight
minimum weighted
green tree
blue total
previous algorithm
bigger black
bigger blue
optimal case
statement true
lowest frequencies
lowest weight
number suppose
higher weight
smallest weight
smallest weights
problem reduces
done priority
priority queues
paradigms data
queues today
priority queue
queue abstract
thing today
binary heap
subsequent classes
multi user
user computer
multiple users
submit jobs
job arrives
average waiting
srpt rule
remaining processing
processor schedules
smallest job
job finishes
smallest jobs
running job
unfinished job
completely finished
srpt policies
type supports
first operation
minimum operation
smallest priority
priority priority
largest priority
made sense
minimum processing
delete min
min operation
delete main
main operation
minimum priority
min differs
basic operations
container classes
queue ranks
totally ordered
order deletion
reusable form
comparator objects
comparator object
comparator abstract
include methods
unsorted sequence
sequence recall
insert last
insert operation
end irrespective
increasing priorities
straight sitting
case minimum
insert lets
right position
case insert
order end
sequence priority
queues find
discreet event
event simulation
building block
priority element
structure properties
node level
nodes level
last levels
left fill
heap property
case priority
lone child
left filled
larger priority
smaller priority
root element
inequality holds
integer hope
equals log
node parent
node thirteen
tree links
parent child
child relationships
implicitly maintained
left shift
equally simple
increment operation
heap suppose
lesser priority
higher priority
lower priority
move twelve
inserted last
slight colored
colored path
inserted element
priority lesser
highest element
move elements
first claim
pink color
color nodes
heap properties
guy heap
trees rooted
suitable modification
heapify procedure
procedure heap
heapify remember
whichever node
node heapify
crucial part
heapify works
works heapify
correctly violated
property heap
property valid
colored nodes
path suppose
net result
heapify step
priority node
heap heapify
node assuming
child sub
larger heap
quick runtime
runtime analysis
height order
node heap
element moved
invoking heapify
eventually satisfied
looked today
today insert
root minimum
binary heaps
class recall
critical properties
repeated insertions
build operation
heap sort
children element
empty slot
taking care
class heapify
min procedure
simple minded
minded method
repeated insertion
heap bottom
arbitrary locations
implementing heaps
individual leaves
heaps bottom
smaller child
run heapify
heapify operation
doing heapify
larger heapify
children swapped
heapify continues
build heap
heap procedure
right order
running heapify
necessarily required
entire build
heapify sub
sub routine
prove correctness
induction claim
induction statement
induction step
minded approach
class takes
case order
heap takes
swaps required
times summation
crude upper
equals half
completes analysis
smaller heaps
larger heaps
procedure repeatedly
smaller element
min steps
steps requires
place sort
space starting
initial array
order sitting
property validated
heap furnace
swapping heap
children twenty
means swap
heap anymore
remaining part
element left
running times
heap operations
step process
heap reduces
kind log
insertion repeated
takes total
leaf elements
two-step thing
root location
root heapify
recap today
element sitting
directly access
procedure today
crucial operations
additional node
insert procedure
forget heap
typical operations
find min
insert takes
min operations
insert operations
ways heap
sorted sequences
unsorted sequences
sorting sorting
computers love
sorting numbers
requires attention
requires consideration
good algorithms
sorting occur
data sorted
efficient recall
computation geometry
computer graphics
sorting algorithms
algorithm design
design techniques
people adopt
requires comparisons
lower bounds
selection sort
design paradigm
sub problems
conquer step
smaller parts
original problem
combine step
sorting problem
merge sort
division done
equal sub
floor elements
arbitrary collection
merge step
swapping elements
division step
conquer thing
merge sorted
upper index
mid point
conquer steps
array .sort
merger sort
part sorted
merge proceed
merge algorithm
resulting sequence
sequence whichever
continue building
element sequence
sort call
first half
doing divisions
parent calling
sorted list
blue oval
sort sequences
trivial case
trivial merge
merge sequence
sort calls
blocks correspond
sorted sequenences
sequences put
smaller sequences
things left
front elements
sequences finishes
copying requires
create sequences
arbitrary values
understood merge
merge set
mirror image
split part
units essentially
merges require
length two
basically sequences
search merges
recurrence relations
pervious points
smaller inputs
conquer kind
part suppose
original thing
sub problem
problem size
size factor
general denote
trivial problem
initial condition
sort problem
solving recurrences
repeated substation
substation method
substitution method
solving recurrence
master method
fourth method
recursion tree
repeated substitution
substitution step
pattern basically
simple recurrence
upper bounded
num sum
numbers written
method substitute
expand substitute
sufficient number
java implementation
sorting integers
sort object
method requires
tow objects
essentially boolean
sequence comparator
class sequence
call sort
sort sort
doing removing
conquer paradigm
sorting today
bucket sort
sorting heap
bubble sort
radix sort
actual structure
people provided
comparator function
sort people
number system
sorting first
base form
radix sorting
comparing bits
comparing numbers
alphanumeric strings
binary numbers
radix exchange
exchange sort
numbers represented
binary first
fixed representation
leftmost bit
bit first
first suppose
first number
top sub
bottom sub
bits number
original collection
combined step
array ignoring
n-bit numbers
bits log
b-bit numbers
verifying weather
side equals
left hand
quick sorting
bit numbers
distinct numbers
solve recurrence
negative numbers
positive numbers
first split
wrote order
partitioning algorithm
scan indices
indices exchanged
step suppose
first bit
significant bit
algorithms partition
recursively sort
sub arrays
fixed quantity
bottom half
array based
scheme depending
implementing radix
sort quick
huge numbers
rightmost bit
numbers based
magic happening
table sort
order remains
remains unchanged
unchanged suppose
colored blue
array post
post sorted
stable sorting
table sorting
smaller appears
leftmost position
sorting remember
corrective relative
latest step
change anymore
smaller key
larger key
add sub
sub sequent
sequent steps
larger keys
keys appearing
bigger number
sorting ensures
subsequent steps
right end
left end
decimal numbers
man passes
stable manner
exchange radix
partition anymore
binary form
bit suppose
sorting scheme
numbers essentially
works suppose
fourth number
list end
maintain stability
first bucket
straight radix
in-place sorting
auxiliary data
operations replaceelement
sort in-place
array merge
in-place quick
comparison base
comparison based
numbers suppose
comparison function
comparison operation
algorithm works
comparative functions
anymore comparison
path ends
finite criteria
deterministic algorithm
argument applies
compare lets
complicated objects
factorial permutations
factorial leaves
forward thing
transitive property
tree decision
decision based
factorial height
farthest leaf
furthest leaf
sort doesn
comparisons based
based sorting
sorting data
graphs today
start talking
basic definition
graph abstract
graph data
type today
red circles
blue lines
term connect
unordered pair
pairs mentioned
model circuits
model networks
transportation networks
communication networks
typically student
student day
play cs201
cs201 programming
programming sleep
cs201 cycles
directed graph
graphs directed
directed graphs
undirected graphs
ordered pair
first vertex
simple lecture
undirected graph
adjacent vertices
equivalent ways
vertices equals
consecutive vertices
construct examples
paths suppose
simple path
last vertices
graph connected
common mistake
mistake connected
wrong terminology
sub graph
resulting thing
end points
connected component
connected graph
graph suppose
connected components
connected sub
carefully suppose
original graph
connected anymore
connected componenent
complete graph
n22 pairs
times nc2
chose two
minimum elements
elements connected
degree two
repetition sir
edge coming
true statement
edges equals
leaf good
path relating
text books
contradiction suppose
lets remove
graph disconnected
earlier claim
question suppose
simple exercise
spanning tree
graph includes
fault tolerance
bridges koenigsberg
pragal river
nice thing
river flowing
black bar
starting point
koenigsberg problem
euler proved
edges don
multi set
multi graph
eulerian tour
starting vertex
euler theorem
fresh edge
odd degrees
uninteresting part
regular methods
positional container
regular positional
container swap
swap method
returns number
vertices numedges
numedges number
edges vertices
method returns
edges directededges
directed edges
enumerating edges
iterator undirectededges
undirected edges
edges incident
incident edges
graph incident
edges entering
out incident
end point
outdegree indegree
edges coming
vertex outdegree
edges leaving
method areadjacent
boolean value
directed edge
mixed graphs
mixed graph
problem setting
traffic network
undirected edge
update method
change remove
set direction
method depending
represent graphs
graphs data
representing graphs
edge list
adjacency list
adjacency matrix
matrix data
simplest data
blue vertices
red arcs
flight numbers
edge recall
recall corresponds
airport boston
references pointers
instance suppose
vertex suppose
vertex dfw
edges suppose
out vertices
container operations
tool list
list isempty
empty replaceelement
edges takes
method vertices
unsorted lists
similarly insertedge
remove vertex
last operation
location corresponds
location vertex
vertexes adjacent
vertices adjacent
keeping track
structure require
matrix implementation
previous data
order degree
storage location
typically number
out adjacency
incoming edges
outgoing edges
storing edges
storing edge
edge information
storing information
starting airport
information suppose
flight number
ending airports
double arrow
doubly length
arrow points
edges edges
out edges
out degree
out list
out adjacent
level idea
common degree
degree information
matrix representation
simple representation
binary entries
entries bits
round depending
false means
simple implementation
vertex means
matrix structure
structure augments
list structure
list recall
edge augmenting
static graphs
right data
frequent operation
adding vertices
times required
dimensional array
two-dimensional arrays
dimensional arrays
major form
easy task
simple edge
squared space
standard implementation
graph searching
searching algorithms
graph search
search algorithm
systematic manner
organized manner
assuming adjacency
list algorithm
algorithm implementation
discussing graph
common algorithm
typically perform
first search
discussing breadth
today breadth
search makes
initial distance
first round
unit find
simple graph
minor question
grey vertices
grey signifies
white means
means undiscovered
first picture
vertex black
color grey
grey color
colored grey
colored black
first color
queue color
right neighbours
white neighbour
white neighbours
labels signify
shortest path
manner shortly
maximum distance
predecessor vertex
vertex grey
suitable label
dequeue operation
separate arrays
arrays indexed
spending constant
degree times
executed degree
executed order
white vertex
bfs bfs
source vertex
bfs tree
vertices vpi
dotted edges
dark edges
solid edges
shortest label
predecessor information
solid lines
edge entering
solid line
line entering
lines form
previous examples
largest level
number label
tree edges
adjacent levels
small mistake
previous level
wont count
multiple edges
edges leading
levels zeroth
zeroth level
vertex lets
label level
predecessor edges
-connected components
-bipartite graphs
applying breadth
apply breadth
search recall
components question
counts vertexes
standard things
starting doing
distance label
component number
search starting
easier set
small thought
last root
root vertex
total turning
total vertices
entire graph
breadth first
array work
list representation
vertices numbered
vertices number
direct correspondence
bipartite graphs
bipartite graph
equals null
standard setting
graphs find
settings question
lines levels
arbitrary vertex
jump levels
brown edges
red edges
graph bipartite
level suppose
componental graph
simplify matters
alternate levels
edge exits
graphs suppose
odd cycle
general proof
taking alternate
non bipartiteness
valid point
simply level
keeping level
number business
number level
continue clear
formal statement
path means
computer network
information travels
predecessor means
recall predecessor
vertex sitting
simple application
vertices maximum
vertices means
equals length
hard quantity
defined maximum
right information
disconnected graph
diameter greater
level diameter
search data
depth first
photogenic memory
direction south
backtracks backtracks
option left
find cheese
call depth
graph sittings
start backtracking
options left
small simple
list implementation
label options
incrementing unnecessarily
edge left
white vertices
initial color
node black
first neighbor
forward tree
unique edge
vertices starting
start vertex
edges form
sub graphs
dfs tree
actual notion
rooted tree
graph right
natural parent
child relationship
child siblings
green edges
back edges
front edges
back edge
front edge
red edge
level difference
important point
backtrack means
defined dfs
tree edge
red dotted
graph depth
classes tree
dfs classifies
search means
means breadth
search classifies
graphs things
implement depth
complicated thing
thing stacks
search involve
doffs dfs
dfs dfs
visited dfs
sir predecessor
predecessor sir
magic right
line program
minutes telling
search visits
call terminates
dfs suppose
process terminates
juts visited
arrays arrival
previous thing
reached vertex
left vertex
start dfs
guy doesn
launch dfs
dfs today
search today
edge connected
connected recall
small piece
code depth
dfs procedure
adjacent nodes
careful analysis
assumed graph
computation finishes
local variable
longer list
pointer reached
dot data
dot node
braces ends
global array
finished dfs
doing dfs
recursive program
call finishes
implement dfs
current pointer
stores return
return address
sixth assignment
departure times
questions suppose
edge suppose
ancestor descendant
descendant relationship
picture essentially
tree path
ancestor dissonant
reason agreed
means remove
removal disconnects
bridge edge
edge connectivity
link fails
remain connected
disconnected components
measuring liability
edge sir
fast pardon
graph remains
edge remove
resulting graph
last edge
cycle connected
search suppose
backtracking means
back tacking
blue tree
remaining piece
blue edges
green edge
proper descendent
descendent includes
proper ancestor
means parent
permitted order
edges starting
information recursively
doing recursively
running dfs
minimum arrival
smallest arrival
lets give
connectivity procedure
dfs thing
procedure eventually
eventually recall
arrival times
arrival counter
counter suitably
arrival value
dfs calls
equal minimum
dbe equals
equals minimum
equals arrival
write abort
end gracefully
edge starting
arrival numbers
arrival number
minor things
total running
sophisticated procedures
graph problems
complicated problem
planar graph
discrete math
compete graph
initial thing
sophisticated algorithm
non planar
non-planar graphs
planar graphs
vertex connectivity
vertex connected
computer failures
link failures
computer breaks
cut vertex
graphs differ
interesting happening
adjacent means
thing adjacent
vertex adjacent
departure numbers
visit start
first depth
out breadth
similar thing
search require
discussing depth
clever manner
visited array
colors wow
deeper black
easy bold
dash dash
dash dotted
pointed out
pen moves
blue edge
sir sketch
sketch pen
pen sir
nice picture
forward edge
brown edge
term backward
backward edge
cross edge
clear tree
single ten
ten vertex
cross edges
draw picture
actual thing
tail first
verses departure
verses arrival
depart form
arrive oops
edge great
ancestors descendant
descendant relationships
starting node
remaining edges
cycle great
back means
cycle means
point great
edge means
order vertices
largest departure
largest side
higher departure
edge remains
proof theorem
single back
acyclic graph
lets order
decreasing departure
topological sort
linearly order
vertices right
maximum departure
total set
assigning arrival
directed acyclic
graphs arise
combinational circuits
graphs model
longer application
connected means
strongly connected
term ordered
pair pair
sufficient right
weakly connected
right definition
natural question
dfs starting
argument clear
dfs visit
borrow ideas
engineering iit
graphs recall
strong connectivity
connectivity means
vertices lets
first starting
path deepest
reverse edges
fetch change
function dfs
adjacency edges
inadjacency edges
academic exercise
undirected dfs
lower arrival
big deal
smaller arrival
easy requirement
modify dfs
sub word
word sub
generic definition
modified dfs
dfs returns
edge forward
thing note
neighboring vertices
initial value
started dfs
xyz equals
equal min
min computation
small problem
additional variable
graphs checking
switching topics
similar procedures
shortest distance
procedures data
minimum spanning
spanning trees
things tree
cycles connected
spanning means
minimum weight
term weight
terms length
length function
non-negative reals
function suppose
kilo meters
tree equals
equals sum
free tree
alternate path
longer length
tree length
longest edge
cycle found
longer cycle
arguments proving
longer edge
doing procedure
simply algorithm
graph out
minimum edge
greedy algorithm
greedy means
greedy make
thing make
smallest length
smallest edge
include edge
obtained earlier
sort edges
type greater
visited means
including edges
included edges
edges means
step takes
minimum forms
edges picked
algorithm picks
edge lengths
non distinct
distinct case
set differ
opt tree
cycle formed
quick repetition
set great
implies optimum
sets differ
algorithm finds
tree unique
mst unique
unique minimum
component connected
components reduces
vertices names
vertices sets
first class
computing minimum
complete algorithm
current set
revise part
points lie
algorithm proceeds
component reduces
disjoint sets
elements correspond
initial vertices
completed description
find return
elements lie
accurate description
unique set
operations exist
edges sort
equals find
singleton vertex
union operation
find operation
good data
good view
order size
order smaller
smaller heap
union find
data field
reference field
guys point
pointer points
tree right
parent point
vertex list
node recall
array suppose
node vertex
union takes
root nodes
long ways
manner find
linking elements
link make
lighter tree
tree point
lighter point
guy point
induction good
equals max
value equals
quantity equals
larger number
rank rank
rank meaning
shallow tree
make root
alternative ways
holds true
cretin number
height node
reference update
order replay
minimum value
things log
theta log
find data
find improves
path compression
future finds
drawing rest
nodes pointing
union procedure
procedure requires
requires height
future easier
directly point
root point
root reference
standalone entity
adjutancy list
vertex belongs
algorithm kruskal
first algorithm
discuss today
vertex set
break vertex
first cut
cut recall
necessarily distinct
assume edge
cut belongs
edge length
mst mst
edges added
smaller tree
mind game
algorithm exploits
simple fact
algorithm work
first partition
root verses
proof effectively
assumed edge
remaining vertices
complement side
adjacent edges
edge incident
find out
complement insert
min heap
remove element
min takes
bad data
information related
add takes
write log
small order
find mine
initial vertex
initial heap
vertex root
root equals
dot insert
dot empty
dot find
min equals
edge dot
loop clear
delete log
minimum label
update information
decrease priority
priority decrease
delete find
label array
dot decease
decease priority
spending degree
single source
source shortest
length corresponds
fourth option
simple problem
simple matter
ignore cycles
large means
exponentially varying
count correctly
top part
bottom part
paths roughly
path system
arbitrary numbers
clear demarcation
part form
shortest heap
heap improving
intermediate vertices
blue path
green path
path problem
adjacent vertex
non negative
denote distance
similarly distance
correct distance
actual distance
directed length
path found
found nay
nay point
vertex found
visited vertex
theses vertices
specific vertex
correct shortest
additional argument
upper bounds
tentative distances
tentative distance
infinite earlier
forward algorithm
set denote
actual values
numbers change
right distance
distance labels
lose heart
initial values
label recall
vertex distance
equals infinite
smallest distance
algorithm yesterday
mistake correct
dot delete
minimum vertex
complete clear
shorter path
dot decrease
heap priority
square log
summation degree
degree log
priority operation
operation takes
operation corresponds
computed length
root data
case today
negative edge
first understand
numbers represent
actual shortest
path distances
minimum suppose
path distance
operation shows
things moves
initial composition
shortest length
path including
including vertices
last vertex
induction make
vertices continue
vertex moves
out neighbors
earlier value
complement minus
path form
includes vertices
include vertex
path includes
covered case
blue line
path sits
longer path
smaller quantity
smallest path
label reflect
smallest label
label vertex
claim true
crazy things
reaches vertex
entire path
path drawn
right induction
path case
sub vertices
statement continues
path unqualified
basically length
negative length
length minus
negative cycle
length make
negative lengths
represents currency
currency tradings
global currency
currency trader
edge reflects
indonesian path
positive cycle
shift increase
brilliant idea
length increases
length longer
safe side
argument break
negative edges
thing breaks
thing remains
shortest paths
path today
lengths today
vertex preceding
maintain predecessor
finding find
null print
vertex information
information bur
predecessor edge
edge connecting
n-1 predecessor
previous vertex
specific root
path tree
unique path
edges capture
dijkstras algorithm
permitting edges
non simple
straight line
positive length
finding simple
gossiping kind
person talks
earlier information
original information
guy talks
first transfer
round starts
thing simultaneously
actual transmitting
edges length
property continues
hold true
correct length
things lesser
path contradiction
round r-1
double induction
induction kind
updated simultaneously
apply induction
valid doubt
pair shortest
algorithms scores
bound nodes
positive edges
factor log
today lecture
discuss data
simple definitions
computational procedure
programming language
language data
process develop
develop data
algorithmic problem
non decreasing
decreasing sequence
natural numbers
finite length
output specification
non-decreasing sequence
length forms
non-decreasing numbers
input instance
input instances
good algorithm
efficient algorithm
input size
small input
program running
varying data
larger data
varying composition
program takes
system utility
huge overhead
considerable amount
limited set
comparison platform
platform means
software environment
software environments
first lecture
general methodology
level description
earlier courses
algorithm doing
algorithm takes
maximum element
array algorithm
algorithm array
array max
natural language
high-level programming
programming concepts
if-then-else statement
current max
remaining element
current maximum
current element
loop terminates
usual prose
standard numeric
boolean expressions
assignment operator
equality operator
equality relationship
declare methods
takes algorithm
programming construct
index array
procedure terminates
value returned
function returns
object method
object specifies
analyze algorithms
primitive operations
primitive operation
low level
level operation
data movement
control statement
subroutine call
logical operations
e.g addition
non-decreasing order
output algorithm
first sorting
sorting technique
playing game
empty hand
first card
original numbers
key key
decrease index
value j-1
step location
left arrow
entire program
small errors
comment statement
problem problem
asymptotic analysis
constant minus
infinite bars
inputs size
increasing plots
input increases
algorithms worst
case occurs
case average
harder quantity
superficial details
times squared
times ,because
quadratic behavior
size doubles
algorithm increases
crucial point
non-negative functions
non-decreasing functions
exist constants
non-linear function
exponential scale
scale increases
colored line
dotted line
line displaced
suitable amount
green line
simple rule
rule suppose
lower order
order terms
terms forget
complicated function
growing term
common error
strong amount
subsequent slides
linear running
small instances
numbers sitting
executed times
dominant thing
step mentioned
last step
repeating computations
single variable
compute element
asymptotic running
linear algorithm
big-omega notation
big-theta notation
related asymptotic
asymptotic notations
non-tight analogs
equal little-oh
little-oh corresponds
little-omega corresponds
formal definition
largest problem
differences happening
huge increase
large increase
data
structures
algorithms
naveen
garg
department
computer
science
engineering
indian
institute
technology
delhi
lecture
stacks
talk
abstract
types
interfaces
exceptions
implemented
java
application
analysis
series
growable
bit
amortized
virtual
machine
type
basically
specification
instances
set
axioms
define
semantics
operations
integer
real
numbers
understand
notion
addition
add
integers
mathematics
similarly
defined
interface
signature
operation
parameters
requires
results
case
sum
variable
answer
class
clear
talking
essentially
kinds
constructor
method
create
instance
sophisticated
lot
work
access
functions
elements
manipulation
procedure
manipulate
modify
identify
requirements
building
blocks
algorithmic
language
higher
level
abstraction
terms
adding
queues
advanced
encapsulate
structure
organized
separate
issues
correctness
efficiency
start
giving
simple
dynamic
collection
objects
suppose
means
remove
object
call
changing
sets
methods
insert
element
two
result
includes
delete
removes
updating
creating
constructing
isin
telling
return
value
boolean
true
false
behave
write
form
empty
matter
resulting
previous
provided
basic
nature
functionality
algorithm
talked
code
implementing
interested
permitted
govern
familiar
queue
doing
stack
last-in-first-out
principle
inserted
last
removed
first
inserting
pushing
removing
popping
kind
toys
trays
mess
put
tray
top
pop
supported
four
key
push
adds
inserts
takes
parameter
flag
error
stating
returns
differs
make
sense
support
size
tells
isempty
hope
understood
axiom
governs
behavior
back
complete
translate
constructs
declare
done
part
implementation
right
names
fact
provide
classes
people
implement
completely
ways
program
written
meet
meets
coding
helps
programming
technique
built-in
generic
derived
throws
stackemptyexception
signal
void
executed
modifies
considered
exception
mechanisms
handle
errors
reach
exceptional
condition
execution
throw
term
thrown
flow
control
moves
current
point
idea
occurs
delegate
responsibility
handling
eat
pizza
stomachache
dotted
problem
stomachacheexception
public
eatpizza
inside
stimulate
meeting
ta.eatpizza
exist
bunches
statements
interrupt
catch
modified
depends
returning
local
variables
global
if-loop
modifications
carried
block
enclose
open
bracket
include
calling
close
raised
skip
statement
raise
execute
raises
caught
necessarily
system.out.exception
happen
simulate
parent
catches
high
finally
stop
appearing
console
manner
propagated
stops
shown
user
system.out.println
print
initializing
ouch
making
assigned
created
enclosed
propagate
upwards
procedural
hierarchy
reaches
brackets
signify
signifies
invoking
listening
catching
mentioned
turn
exit
wrote
extends
string
err
single
super
chain
calls
stomach
ache
extending
run
book
details
array
maximum
location
index
move
listed
out
entire
arraystack
implements
default
capacity
final
constant
changed
hold
initially
int
cap
number
started
equals
full
increment
incremented
give
check
save
elem
decrement
earlier
null
dereference
to36
t
deference
rid
lie
memory
private
member
taking
required
propositional
dependent
working
upper
bound
value1024
creation
allocate
large
waste
small
requirement
artifact
grow
needed
daily
stock
prices
price
day
span
consecutive
days
equal
inclusive
picture
counting
1,2,3,4
3,4,5,6
compute
i-1
i-2
moment
find
loop
incrementing
i-k
quantity
repeat-until
reached
determined
computing
repeatedly
comparing
times
worst
varying
n-1
total
running
question
closest
preceding
greater
computed
determine
5-1
quantities
easily
told
definition
larger
values
store
indices
bottom
compare
minus
bar
drawn
comparison
update
replacing
things
7th
recall
6th
found
d.isempty
d.top
computation
pushed
begin
executes
for-loop
order
iteration
filled
length
copy
original
rename
locations
increase
counter
strategies
adopt
tight
strategy
growth
additive
double
regular
space
unit
special
costs
units
copied
cost
behaves
enlarge
3rd
4th
pushes
fill
phase
pound
symbol
multiplication
operator
beginning
copying
2ci
phases
roughly
approximately
change
slightly
purposes
5th
analyze
spent
left
log
growing
linked
lists
looked
today
list
sequences
ended
differ
last-in
first-out
hand
first-in-first-out
joins
processed
rear
sitting
front
end
standard
enqueue
dequeue
similar
obtained
enqueued
added
thing
procedures
q,w
assume
remaining
cases
dequeued
circular
fashion
referring
blue
occupied
colored
0th
1st
2nd
effect
drift
moved
implies
deleted
f-1
accurate
stage
anymore
wrap
starting
side
refers
situation
located
step
ambiguity
resolve
ensure
pseudo
modn
pseudo-code
n-f
r-f
negative
setting
correct
positive
confused
disadvantage
fixed
increases
allotted
nodes
pointers
node
referred
head
tail
note
torcezo
permit
directly
pointer
accessing
rome
removal
place
connect
easy
diagram
newly
difficult
expensive
worth
introduce
double-ended
ends
singly
good
solution
doubly
sentinel
pointing
trailer
follow
port
send
header
dummy
mark
san
francisco
meant
independent
depended
fairly
correspond
deleting
corresponds
adapter
pattern
patterns
general
specialize
applications
contents
arbitrary
adapt
integerarraystack
suitably
cast
circularly
straight
forward
big
costly
reference
seattle
discusses
quickly
vectors
positions
arrays
vector
sequence
supports
indicative
rank
7,11,13,19
elematrank
replace
students
departmental
shift
moving
n-2
position
increased
sores
shifting
view
faster
retrieve
replaceatrank
chart
shows
complexity
showing
diagrams
newyork
insertion
17th
assuming
existence
nodeatrank
defining
shortly
next.getprev
prev
field
dlnode
next.setprev
prev.setnext
intimated
show
process
deletion
selected
march
improvement
hundred
concerned
implementations
require
supporting
based
efficient
removeatnode
insertafternode
stuff
hide
information
knowing
actual
intuitively
captures
stored
situated
fields
implementer
hides
relative
jus
datatype
query
asks
excessive
swapelements
swaps
replaceelement
insertfirst
insertlast
capture
linear
combines
inherits
multiple
inheritance
additional
atrank
rankof
middle
gave
cross
sit
ranks
wanted
leave
exercise
previously
zap
figure
learnt
concretization
inheriting
dictionaries
dictionary
binary
search
hashing
hash
table
collision
resolution
techniques
stores
bank
accounts
account
lots
wealth
balance
address
holder
transactions
wishes
continued
model
database
key-element
pairs
student
records
natural
entry
characters
uniquely
identifies
main
searching
container
findelem
settings
remember
crucial
nil
returned
unsuccessful
nill
mind
keys
equality
record
smaller
lectures
inefficient
predecessor
successor
organize
tree
red
black
trees
avl
b-trees
important
spending
java.util.dictionary
lays
java.util.map
subsequent
discussions
lets
5,10,7
databases
divide
conquer
design
future
applied
problems
narrow
range
sorted
increasing
decreasing
lies
lye
low
figured
repeat
recursive
read
lower
wrong
average
mid
staring
ending
mid-1
binarysearch
pieces
iterative
equivalent
happening
color
putting
do-while
halved
items
comparisons
desire
base
assumed
lucky
searched
spend
huge
difference
coming
sorting
sort
asked
caller
facility
phone
company
person
callers
digit
million
present
efficiently
unordered
traverse
decides
connection
modification
care
faliable
maintain
files
file
revert
transaction
system
administration
track
activities
rarely
removals
frequently
insertions
frequent
searches
rare
performed
decide
ordered
direct
mechanism
whichever
examples
big-oh
notation
deletions
discussion
ankur
9635-8904
capability
bad
wasting
turning
issue
excepted
users
wasted
mapped
hypothetical
friends
fancy
mod
depending
digits
infact
pick
function
2004cs10110
picks
clash
2004cs50310
arise
grade
shape
showed
deal
spot
concept
chaining
addressing
modulo
resolved
reduces
identity
sits
quick
recap
typically
regarded
reason
options
amount
points
maintaining
ordering
slot
mapping
universe
slots
m-1
rest
arithmetic
choice
choices
research
motivate
distribute
uniformly
map
collisions
distributes
ideal
random
puts
picked
randomly
probability
uniform
load
factor
divided
alpha
distributing
examined
denote
half
represents
brings
relies
critically
choose
designing
art
theorem
successful
walking
arguing
argued
appended
critical
prove
manners
summing
math
computations
ignore
intuitive
sizes
keeping
accommodate
attach
performance
deteriorate
10,000
wastage
continue
concepts
resolving
contd
probing
discussing
worse
famous
paradox
birthday
year
birthdays
non-integer
telephone
hyphen
treat
dropped
thought
converting
non-integers
convert
parts
compression
maps
1stconvert
bring
indexed
2004sa10110
randomization
minimize
popular
hash-code
converts
interpret
numeric
bits
reinterpret
long
bytes
chunks
eventually
possibility
ascii
words
english
letters
avoid
replaced
reasons
great
character
strings
polynomial
accumulation
coefficients
expression
evaluate
evaluated
1stwe
experimental
theory
observed
experimentally
study
favour
representation
forgetting
power
prime
preferably
principles
improve
experiment
non-integral
max
covert
multiply
converted
fractional
consequence
floor
round
rounded
nearest
multiplied
happened
jugglery
fraction
plotted
evidence
turns
fibonacci
significant
nice
ronald
knuth
covers
detail
multiplying
co-prime
generator
generators
congruential
seed
initial
generated
generate
universal
briefly
adversary
life
picking
imply
bunch
starts
midway
invoke
fall
storing
references
reside
residing
probe
suitable
modifying
determining
specifies
collections
guiding
rap
short
specific
advantage
slower
continuous
8th
11th
respective
tend
aggregate
clusters
checked
10th
12th
terminates
terminate
finds
tombstone
marker
encounter
encounters
ignores
continues
reclaim
tombstones
degrades
rehash
markers
offset
piece
distance
advance
jumped
orange
works
finding
cycle
divides
rough
arguments
formally
advantages
disadvantages
formed
steps
makes
trouble
continuously
8-4
8-7
unoccupied
distributed
scheme
assumptions
made
performs
schemes
search.what
probes
expected
hit
trails
expectation
praising
quarters
quarter
bounding
fractions
performances
discussed
root
children
argument
ancestor
grandparent
descendents
siblings
sibling
3three
ancestors
grand
family
leaves
upside
extremities
leaf
child
internal
associate
depth
height
degree
terminologies
represent
organization
electronics
divisions
rnd
division
purchasing
manufacturing
domestic
international
sub-division
sales
organizational
guide
chapters
overview
grading
environment
chapter
sections
exams
homework
programs
sub-sections
build
unix
windows
directory
1stlevel
sub-directories
sub-directory
assignment
definitions
draw
eldest
younger
reflect
convey
representing
meaning
attached
marked
subtree
construct
attaching
subtrees
and
introduced
2ndlevel
extreme
expressions
parenthezisation
parenthesized
line
decision
star
bucks
caf
paragon
fast
meal
coffee
terminology
concrete
count
leaves-1
leafy
atmost
cut
proof
obtain
pruning
branches
rewrite
rearranged
atleast
achieves
acquires
smallest
shortest
packing
filling
levels
minimum
zigzag
mistake
inequality
induction
satisfied
k-1
apply
hypothesis
rearrange
achieved
dry
1leaf
swapping
isroot
isinternal
isexternal
external
accessor
casting
treated
sub-class
described
center
links
link
unbounded
members
1of
1stfield
reversals
walks
traversals
walk
visiting
preorder
postorder
visit
post
clarify
paper
section
title
books
papers
publication
referenced
sub
reading
tables
8,9,10,11,12,13
traversal
listing
heading
arbitrarily
subsection
1.1.1
1.1.2
1.1.3
document
courses
directories
grades
subdirectory
spaces
perform
reverse
pervious
disk
usage
command
fourth
visited
leftmost
specializes
pre
v.leftchild
printing
printed
content
ready
evaluating
essence
arrow
direction
generating
incorporate
priority
rules
worried
visits
possibilities
inorder
traversing
euler
tour
viewed
eulers
thrice
touching
touch
touched
qualify
parenthesis
finish
path
init
unspecified
r.left
r.right
printexpression
binarytree
specializing
green
managed
recursion
plug
recursively
web
input
possibly
in
neatly
unique
worked
descendants
forms
remains
learn
combinations
rise
knowledge
suffices
sufficient
option
absolute
finite
finitely
simplest
excepting
relation
conversation
professor
precedes
trivial
largest
min
logarithmic
halves
trivialities
interesting
property
holds
hindi
satisfy
5,5,7,8
couple
features
doesn
lexico
graphic
alphabetic
permitting
unnecessarily
complicates
matters
duplicate
guy
forget
version
matching
continuing
dot
situations
leafs
expect
don
sentence
non-empty
lying
confusion
carefully
fresh
sheet
tempted
guys
easiest
claim
proceed
completing
remote
home
non
marching
pair
trailing
hits
closer
convince
edge
proportional
interchange
role
match
distinct
fist
fails
descending
harm
balanced
permutation
ascending
relevant
effort
factorial
depend
probabilities
switch
game
questions
permute
distinguish
trickier
abd
effectively
establishing
convinced
equally
preventing
violated
directed
covered
treesuccessor
mistakes
pseudocode
in-order
prints
todays
argue
treeinsert
bst
sums
backs
permutations
trials
experiments
easier
summarize
1to
cleverly
fix
restrict
attention
places
induce
occur
occurring
n-i
simpler
symmetric
law
compared
triangle
darker
.then
extra
product
appears
1through
n-3
multiplies
recurrence
expressing
substitute
equation
explained
non-zero
3-1
solve
scaled
cancel
rearrangement
cancels
simplify
simplification
dense
strictly
1.i
cancelled
n-4
n-n
denominator
n-n-1
harmonic
trick
employ
graph
rectangle
width
area
curve
limits
integral
shallow
report
logn
discuss
square
practice
constants
premium
falls
paradigm
partition
partitioned
break
combining
combine
partitioning
pivot
p-1
lop
j-1
decrementing
stopped
culprits
swap
exchange
swapped
immediately
crossed
job
boundary
decremented
utmost
in-place
pursue
loops
rearranges
demarcating
lines
separately
forever
met
copies
passing
ignoring
split
dividing
median
n
mine
theta
omega
inter
decrease
decreased
exact
squared
writing
bothering
skewed
pictorially
figuring
tenth
percent
tenths
route
providing
strange
sacrosanct
spectacular
afford
hundredth
thousandth
millionth
formal
motivation
alternate
unlucky
2n-1
worry
scenarios
clear-some
odd
involved
struck
randomized
splits
versus
n-10
tool
generates
including
pivots
tomorrow
deciding
splitting
evenly
averaging
inputs
partitions
7-1
n-7
13-1
n-13
summed
expectations
roll
dice
outcomes
unloaded
throwing
recording
outcome
threw
billion
sufficiently
event
thinking
discrete
slides
varies
chosen
solved
beat
quit
knew
vast
white
spots
rooted
singleton
purpose
parents
heights
50th
properties
missing
absent
gained
minutes
proposition
h-1
h-2
relationship
conditions
solving
grows
reduce
h-4
h-6
h-2i
logarithms
2log
confuse
recurrences
crude
sharper
tighter
proving
redefine
minute
k-2
lager
appropriately
quadratic
roots
golden
ratio
sides
guess
precisely
correction
verify
2k-1
hanging
taller
shaded
band
contradiction
contradict
imbalance
proved
older
exponential
sharpest
pretty
rewording
thinning
thins
structural
intuition
encountered
flavor
grandchild
originally
window
rotation
mysterious
automated
rotations
retained
remain
unbalanced
culprit
imbalanced
travel
traversed
grandchildren
1.is
rebalance
performing
locally
reorganizing
reorganization
pictures
clutter
relationships
20-14
remained
repeating
rotate
maintained
restored
trust
switches
loyalties
reduced
traveling
restore
valid
identified
h-3
bigger
checking
2-4
guarantees
2-3-4
multi-way
d-1
generalizing
kd-1
finishes
finished
multi
boxes
numbering
log4n
log2n
branch
careful
wondering
wait
promote
promoted
disappear
decided
cascade
cascades
knock
violating
disappeared
imagine
arising
borrow
disaster
merge
jumble
adjacent
separates
separating
lead
cascading
log4
shrink
handled
conclude
borrowing
merging
complicated
helpful
understanding
fair
subject
non-external
clearer
handing
staff
quiet
reds
consecutively
layers
layer
1and
-1you
correspondence
exceed
combination
combined
ensured
ensures
depths
related
mimic
major
tricky
predecessors
consistence
verses
,this
door
formulate
expand
scan
2.1.1
reorganize
labeled
lend
coloring
business
assumption
justified
bother
neighbor
recolor
summary
2.2.2
completed
preserving
harder
conceptually
extensive
a-b
exists
obeys
primarily
concentrate
transformation
accommodated
continuation
affect
correspondingly
recoloring
wise
generalized
a-1
b-1
b-a
context
bounds
2-3
2-5
proceeds
repetition
fit
1key
insufficient
splitted
enter
a-1keys
b-1keys
rephrase
insist
b-1is
a-1this
corrected
2-4tree
borrowed
disappears
28th
merged
a-2
a-2keys
2a-1keys
a-1has
2a-1
concern
b-tree
plays
specially
extension
limited
addresses
share
markets
customers
history
secondary
storage
thinks
slow
accessed
rotates
sectors
sector
tag
seek
latency
positioned
page
byte
pages
kilo
measured
cpu
insignificant
ported
module
bind
translated
fetch
typical
omit
thousand
illustrate
giga
mega
years
bringing
limiting
didn
transfer
arranging
excess
2t-1
coping
describe
measuring
outputs
variant
resulted
parse
pass
quota
descend
counted
room
crossing
ripple
conversation-refer
potential
supposed
deletes
successfully
proceeding
snaps
action
illustrates
bads
answering
moments
highly
interspersed
alternating
vary
optimization
specifically
accesses
text
alphabets
alphabet
editor
occurrences
editors
browser
occurrence
versions
approximate
matches
texts
editing
retrieval
bio
informatics
nucleotides
gene
dna
bases
protein
naive
mismatch
losing
skipped
missed
multiples
sized
improvements
detected
matched
erase
shifted
mismatching
mix
disjoint
knuth-morris-pratt
restart
explain
prefix
substring
label
j-i
reprocess
suffix
determines
extent
semantic
miss
useless
observation
playing
acceptable
reasonable
h11
longest
proper
contiguous
subset
congestion
1th
p12
logic
meaningless
mismatches
capturing
aligns
perfectly
understands
shorter
beta
kmp
mismatched
violates
longer
agreed
establishes
calculated
designed
calculation
sound
shifts
broke
preprocessing
suffixes
candidate
summation
cube
i-3
i-5
zeros
potentially
confusing
plain
compressed
topic
preprocessed
failure
speeded
brute
force
processing
collected
shakespeare
veronica
preprocess
trie
bear
bell
bid
bull
buy
sell
alphabetically
word
reflects
built
bed
organizing
alphabetical
presentation
letter
begins
task
peace
detect
tracing
queries
basis
blank
blanks
boundaries
compress
collapse
collapses
labels
sub-string
subtle
leaving
google
retrieves
engine
urls
music
intersection
union
speed
eliminate
internet
routers
32-bit
google.com
nslookup
iit
routing
router
packet
packets
10.27.36
10.27.34
delimiter
biological
minimized
collapsed
compact
paths
concatenation
mutual
common
pointed
contained
dollar
breaking
exploiting
aim
edges
exhausted
extensions
essential
sub-tree
huffman
abracadabra
shell
man
fixed-length
encoding
encode
encoded
exploit
screen
lesser
transmitting
variable-length
infrequently
is1
just1
choose1
and11
as110100
as11
as10
decoding
decode
codes
is00
ambiguous
prevent
ambiguities
satisfies
rule
prefixes
unambiguous
represented
branching
drew
codeword
trace
also1
strike
trie.so
frequency
5,b
1,d
4,2
totally
saving
compensate
weighted
viewing
weight
weights
frequencies
message
.we
feel
reducing
by2
11.now
only1
gap
minimums
claiming
upto
huffmen
solutions
optimum
lowest
optimal
exploited
trap
developed
paradigms
scheduling
heap
heapify
submit
jobs
arrives
preempted
schedule
processors
resumed
policy
minimizes
waiting
srpt
stands
processor
schedules
interruption
preemption
unfinished
scheduled
period
policies
misnomer
priorities
reflexive
antisymmetric
transitive
reusable
comparator
comparable
unsorted
item
irrespective
discreet
simulation
dijkstra
simply
restate
lone
violate
leads
rounding
floors
conversely
thirteen
holding
implicitly
twelve
structurally
eleven
slight
highest
bubbled
violation
pink
reaching
heaps
invoked
correctly
constructed
net
mention
rebuild
due
runtime
efficiently.thank
repeated
creates
adjust
minded
individual
bubble
validated
exchanged
laid
routine
crucially
approach
differentiate
contribute
differential
completes
free
ten
nineteen
reversed
furnace
fades
smart
drop
drops
twenty
thirty
29comes
construction
two-step
bubbling
bubbles
computers
love
estimated
consideration
develop
oftenly
geometry
graphics
selection
analyzing
1contains
.but
guarantee
helping
deriving
.sort
merger
oval
sixteen
formulas
sequenences
append
noise
opinion
spit
mirror
image
4merge
get1
algorithmically
merges
relations
refreshed
describes
denotes
sub-problems
substation
substituting
noticing
patters
substitution
master
personally
ease
substituted
observe
bounded
num
tow
radix
bucket
persons
extended
alphanumeric
variants
examine
expressed
express
respect
row
rows
independently
subtract
subtracting
triviled
n-bit
pardon
sir
duplicates
20,000
b-bit
stretch
guessing
verifying
weather
cumbersome
repetitions
target
negatives
positives
employed
scanning
coordinate
sixth
exchanging
stable
rightmost
non-sorted
magic
rearranging
unchanged
threes
corrective
latest
interchanged
stability
sequent
preserved
decimal
passes
buckets
appending
exam
auxiliary
updates
replaces
cover
charge
rupee
money
comparative
stream
criteria
deterministic
applies
s13
rate
gpa
representable
decisions
consistent
farthest
furthest
achieve
graphs
permits
tuple
vertices
circles
vertex
drawing
circuits
component
circuit
cs201
resistance
networks
city
modeled
roads
connecting
intersections
transportation
communication
wake
mediate
play
sleep
dream
cycles
idealistic
meditation
undirected
carry
origin
destination
connected
degrees
incident
stones
pebbles
peppules
included
maximal
components
retaining
retain
componenent
forest
jungle
animals
nc2
n22
directions
chose
relating
facts
switched
disconnected
contradicting
spanning
network
cities
fault
tolerance
bridges
koenigsberg
germany
austria
pragal
river
flowing
island
bridge
land
postmen
brides
retrace
multi-graph
eulerian
lifting
pencil
redrawing
uninteresting
positional
numvertices
numedges
enumeration
iterator
iterate
directededges
enumerated
enumerator
enumerating
undirectededges
enumerate
entering
vertexv
opposite
indegree
outdegree
inadjacent
outadjacentvertices
areadjacent
endvertices
mixed
traffic
reverses
tonnes
adjacency
matrix
augmented
flights
airports
arcs
flight
airport
boston
jfk
dfw
lax
enumerates
insertvertex
insertedge
insertdirectededge
overlapped
removevertex
corresponded
vertexes
pros
cons
incoming
outgoing
regard
portion
mia
hard
optimize
entries
column
augments
augmenting
static
inincidentedges
outincidentedges
dimensional
extend
two-dimensional
preferred
systematic
breadth
bfs
rounds
maze
tide
unroll
unrolling
minor
neighbours
gray
grey
discovered
undiscovered
neighbors
knocked
invariant
entered
neighbour
aspects
infinite
assign
assigning
source
discover
reachable
vpi
dark
solid
darkened
arrows
skips
covering
wont
leading
zeroth
choosing
-connected
-bipartite
applying
bipartite
labeling
counts
selecting
numbered
remind
boys
girls
married
applicants
applicant
suggestion
jump
brown
i.e
componental
non-bipartite
bipartition
exits
ultimately
aspect
reboot
cluttered
test
bipartiteness
expanded
distances
hops
travels
forwarded
jumps
diameter
impossible
interrupting
approximation
dfs
meaningful
mouse
carrot
cat
cheese
squares
mice
explore
fully
backtrack
photogenic
east
south
west
north
doubt
stuck
blocked
backtracks
sees
explored
cell
progress
homerun
clap
formalize
exploring
artificial
sittings
backtracking
goal
applicable
stamping
progressing
stamp
unvisited
circumstances
traveled
backtracked
redraw
correspondences
slash
redrawn
stick
classified
emanate
imp
concluded
classifies
non-white
involve
doffs
convenience
suited
launched
marks
terminated
ensuring
launch
timestamps
juts
arrival
departure
identifying
counters
that1
retrieving
braces
heavily
distinction
arrivals
descendant
dissonant
depart
granted
capital
one-edge
disconnects
connectivity
functioning
messages
liability
differently
tracking
tacking
descendent
interest
deepest
emanates
dbe
abort
gracefully
arr
significance
liner
planar
semester
plane
intersect
cleak
compete
crosses
runs
non-planar
failures
breaks
benefit
quote
departed
elaborate
clever
nt
colors
wow
realize
tragic
deeper
bold
dash
pen
realizing
light
sketch
watching
categories
classify
backward
subjective
relate
arrive
oops
departures
arranged
closes
acyclic
streets
worrying
encountering
topological
linearly
produce
dag
combinational
pulses
strongly
weakly
suggested
ideas
hint
strong
inadjacency
academic
gammon
remarked
happy
sufficiency
descendance
difficulty
feature
loosely
composed
neighboring
xyz
mins
switching
topics
panning
lengths
non-negative
reals
wire
wires
meters
face
reduction
mst
analyse
kruskal
greedy
greed
objective
dfso
pfso
bsfo
dictate
greedily
impure
intrusion
proofs
1,less
majors
.because
opt
identical
g1to
listen
abc
fgh
revise
existing
krukal
detecting
disjoints
reflected
belong
description
forming
initialised
initialize
initialized
unions
comfortable
suggest
qutei
singletons
elect
leader
representations
state
linking
lighter
heavier
loss
generality
scenario
login
alternative
converse
cretin
grater
updated
replay
immaterial
improving
improves
hang
opting
recompute
metric
standalone
entity
adjutancy
belongs
prim
notions
cuts
complement
connects
brought
eye
arriving
exploits
rapidly
length1
messy
hndi
noting
remembers
clean
processes
initialization
decease
strikingly
ton
tons
termination
stand
2,3
feasible
practical
impractical
exponentially
diamonds
diamond
particles
estimate
caliber
demarcation
intermediate
abbreviated
triple
sssp
nay
concretize
circle
theses
tentative
rush
grained
invariance
complements
lose
heart
clue
belonging
yesterday
notes
decreases
hazard
revising
signifying
composition
connotation
clime
establish
w,u1
captured
touches
accounting
wrongly
concentrating
accounted
claming
crazy
clam
02-35
qualified
qualification
unqualified
argues
pronounced
currency
tradings
trader
rupees
indonesian
profit
incur
brilliant
delta
safe
reconvert
plenty
millions
updation
pred
transferred
bur
20-16
dijkstras
gossiping
talks
promptly
communicates
mates
intern
communicate
gossiped
sends
gathers
simultaneously
inmates
v-s
00-43
induct
r-1
v,w
apparent
apsp
mlog
scores
nlog
introduction
notations
outline
computational
specifications
output
1,20,908,909,100000,1000000000
non-decreasing
describing
actions
infinitely
measures
measure
clock
stopwatch
utility
millis
limitations
overhead
considerable
platforms
platform
hardware
software
machines
environments
methodology
syntax
mixture
high-level
if-then-else
semicolon
colon
compiler
conveys
structured
usual
prose
param
param2
args
primitive
movement
subroutine
logical
e.g
inspect
cards
dealt
card
jack
queen
2-n
1_j-1
4,5,6,7
for3
comment
asymptotic
bars
1size
plot
monotonically
plots
differences
distribution
superficial
,because
factors
doubles
fold
limit
explains
o-notation
non-linear
scale
y-axis
x-axis
displaced
intercept
7n-3
fastest
caution
1,000,000
1,000,000n
late
0-10
accumulator
11,12,13,14
0,1,2,3
dominant
accumulating
reuse
freely
big-omega
big-theta
sandwiched
little-oh
little-omega
non-tight
analogs
analogy
defines
400n
20n
hour
3600seconds
