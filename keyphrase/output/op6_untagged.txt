introduction references  1 abraham silberschatz  greg gagne  and peter baer galvin  " operating system concepts  ninth edition "  chapter 1 just as in the blind men and the elephant  this chapter looks at operating systems from a number of different viewpoints no one view really shows the complete picture  but by looking from a number of different views  we can get a pretty good overall picture of what operating systems are all about 1.1 what operating systems do  for users  for applications  etc figure 1.1  abstract view of the components of a computer system * computer = hw + os + apps + users * os serves as interface between hw and  apps & users  * os provides services for apps & users * os manages resources  government model  it does n't produce anything  * debates about what is included in the os  just the kernel  or everything the vendor ships  consider the distinction between system applications and 3rd party or user apps  1.2 computer-system organization  what are all the parts  and how do they fit together figure 1.2  a modern computer system 1.2.1 computer-system operation * bootstrap program * shared memory between cpu and i/o cards * time slicing for multi-process operation * interrupt handling  clock  hw  sw * implementation of system calls figure 1.3  interrupt timeline for a single process doing output 1.2.2 storage structure * main memory  ram  o programs must be loaded into ram to run o instructions and data fetched from ram into registers o ram is volatile o " medium " size and speed * other electronic  volatile  memory is faster  smaller  and more expensive per bit  o registers o cpu cache * non-volatile memory  " permanent " storage  is slower  larger  and less expensive per bit  o electronic disks o magnetic disks o optical disks o magnetic tapes figure 1.4  storage-device hierarchy 1.2.3 i/o structure * typical operation involves i/o requests  direct memory access  dma   and interrupt handling figure 1.5  how a modern computer system works 1.3 computer-system architecture  different operating systems for different kinds of computer environments 1.3.1 single-processor systems * one main cpu which manages the computer and runs user apps * other specialized processors  disk controllers  gpus  etc  do not run user apps 1.3.2 multiprocessor systems 1 increased throughput  faster execution  but not 100 % linear speedup 2 economy of scale  peripherals  disks  memory  shared among processors 3 increased reliability o failure of a cpu slows system  does n't crash it o redundant processing provides system of checks and balances  e.g nasa  figure 1.6  symmetric multiprocessing architecture figure 1.7  a dual-core design with two cores placed on the same chip 1.3.3 clustered systems * independent systems  with shared common storage and connected by a high-speed lan  working together * special considerations for access to shared storage are required   distributed lock management   as are collaboration protocols figure 1.8  general structure of a clustered system 1.4 operating-system structure a time-sharing  multi-user multi-tasking  os requires  * memory management * process management * job scheduling * resource allocation strategies * swap space / virtual memory in physical memory * interrupt handling * file system management * protection and security * inter-process communications figure 1.9  memory layout for a multiprogramming system 1.5 operating-system operations interrupt-driven nature of modern oses requires that erroneous processes not be able to disturb anything else 1.5.1 dual-mode and multimode operation * user mode when executing harmless code in user applications * kernel mode  a.k.a system mode  supervisor mode  privileged mode  when executing potentially dangerous code in the system kernel * certain machine instructions  privileged instructions  can only be executed in kernel mode * kernel mode can only be entered by making system calls user code can not flip the mode switch * modern computers support dual-mode operation in hardware  and therefore most modern oses support dual-mode operation figure 1.10  transition from user to kernel mode * the concept of modes can be extended beyond two  requiring more than a single mode bit * cpus that support virtualization use one of these extra bits to indicate when the virtual machine manager  vmm  is in control of the system the vmm has more privileges than ordinary user programs  but not so many as the full kernel * system calls are typically implemented in the form of software interrupts  which causes the hardware 's interrupt handler to transfer control over to an appropriate interrupt handler  which is part of the operating system  switching the mode bit to kernel mode in the process the interrupt handler checks exactly which interrupt was generated  checks additional parameters  generally passed through registers  if appropriate  and then calls the appropriate kernel service routine to handle the service requested by the system call * user programs ' attempts to execute illegal instructions  privileged or non-existent instructions   or to access forbidden memory areas  also generate software interrupts  which are trapped by the interrupt handler and control is transferred to the os  which issues an appropriate error message  possibly dumps data to a log  core  file for later analysis  and then terminates the offending program 1.5.2 timer * before the kernel begins executing user code  a timer is set to generate an interrupt * the timer interrupt handler reverts control back to the kernel * this assures that no user process can take over the system * timer control is a privileged instruction   requiring kernel mode  1.6 process management an os is responsible for the following tasks with regards to process management  * creating and deleting both user and system processes * ensuring that each process receives its necessary resources  without interfering with other processes * suspending and resuming processes * process synchronization and communication * deadlock handling 1.7 memory management an os is responsible for the following tasks with regards to memory management  * keeping track of which blocks of memory are currently in use  and by which processes * determining which blocks of code and data to move into and out of memory  and when * allocating and deallocating memory as needed  e.g new  malloc  1.8 storage management 1.8.1 file-system management an os is responsible for the following tasks with regards to filesystem management  * creating and deleting files and directories * supporting primitives for manipulating files and directories  open  flush  etc  * mapping files onto secondary storage * backing up files onto stable permanent storage media 1.8.2 mass-storage management an os is responsible for the following tasks with regards to mass-storage management  * free disk space management * storage allocation * disk scheduling note the trade-offs regarding size  speed  longevity  security  and re-writability between different mass storage devices  including floppy disks  hard disks  tape drives  cds  dvds  etc 1.8.3 caching * there are many cases in which a smaller higher-speed storage space serves as a cache  or temporary storage  for some of the most frequently needed portions of larger slower storage areas * the hierarchy of memory storage ranges from cpu registers to hard drives and external storage  see table below  * the os is responsible for determining what information to store in what level of cache  and when to transfer data from one level to another * the proper choice of cache management can have a profound impact on system performance * data read in from disk follows a migration path from the hard drive to main memory  then to the cpu cache  and finally to the registers before it can be used  while data being written follows the reverse path each step  other than the registers  will typically fetch more data than is immediately needed  and cache the excess in order to satisfy future requests faster for writing  small amounts of data are frequently buffered until there is enough to fill an entire " block " on the next output device in the chain * the issues get more complicated when multiple processes  or worse multiple computers  access common data  as it is important to ensure that every access reaches the most up-to-date copy of the cached data 1.8.4 i/o systems the i/o subsystem consists of several components  * a memory-management component that includes buffering  caching  and spooling * a general device-driver interface * drivers for specific hardware devices *  unix implements multiple device interfaces for many types of devices  one for accessing the device character by character and one for accessing the device block by block these can be seen by doing a long listing of /dev  and looking for a " c " or " b " in the first position you will also note that the " size " field contains two numbers  known as the major and minor device numbers  instead of the normal one the major number signifies which device driver handles i/o for this device  and the minor number is a parameter passed to the driver to let it know which specific device is being accessed where a device can be accessed as either a block or character device  the minor numbers for the two options usually differ by a single bit  1.9 protection and security * protection involves ensuring that no process access or interfere with resources to which they are not entitled  either by design or by accident  e.g " protection faults " when pointer variables are misused  * security involves protecting the system from deliberate attacks  either from legitimate users of the system attempting to gain unauthorized access and privileges  or external attackers attempting to access or damage the system 1.10 kernel data structures 1.10.4 bitmaps * a string of 1s and 0s used to keep track of the boolean state of a collection of objects  such as the free state of blocks on a disk or pages in memory 1.11 computing environments 1.11.1 traditional computing 1.11.2 mobile computing * computing on small handheld devices such as smart phones or tablets  as opposed to laptops  which still fall under traditional computing  * may take advantage of additional built-in sensors  such as gps  tilt  compass  and inertial movement * typically connect to the internet using wireless networking  ieee 802.11  or cellular telephone technology * limited in storage capacity  memory capacity  and computing power relative to a pc * generally uses slower processors  that consume less battery power and produce less heat * the two dominant oses today are google android and apple ios 1.11.3 distributed systems * distributed systems consist of multiple  possibly heterogeneous  computers connected together via a network and cooperating in some way  form  or fashion * networks may range from small tight lans to broad reaching wans o wan = wide area network  such as an international corporation o man = metropolitan area network  covering a region the size of a city for example o lan = local area network  typical of a home  business  single-site corporation  or university campus o pan = personal area network  such as the bluetooth connection between your pc  phone  headset  car  etc * network access speeds  throughputs  reliabilities  are all important issues * os view of the network may range from just a special form of file access to complex well-coordinated network operating systems * shared resources may include files  cpu cycles  ram  printers  and other resources 1.11.4 client-server computing * a defined server provides services  hw or sw  to other systems which serve as clients  technically clients and servers are processes  not hw  and may co-exist on the same physical computer  * a process may act as both client and server of either the same or different resources * served resources may include disk space  cpu cycles  time of day  ip name information  graphical displays  x servers   or other resources figure 1.18  general structure of a client-server system 1.11.5 peer-to-peer computing * any computer or process on the network may provide services to any other which requests it there is no clear " leader " or overall organization * may employ a central " directory " server for looking up the location of resources  or may use peer-to-peer searching to find resources * e.g skype uses a central server to locate a desired peer  and then further communication is peer to peer figure 1.19  peer-to-peer system with no centralized service 1.11.6 virtualization * allows one or more " guest " operating systems to run on virtual machines hosted by a single physical machine and the virtual machine manager * useful for cross-platform development and support * for example  a student could run unix on a virtual machine  hosted by a virtual machine manager on a windows based personal computer the student would have full root access to the virtual machine  and if it crashed  the underlying windows machine should be unaffected * system calls have to be caught by the vmm and translated into  different  system calls made to the real underlying os * virtualization can slow down program that have to run through the vmm  but can also speed up some things if virtual hardware can be accessed through a cache instead of a physical device * depending on the implementation  programs can also run simultaneously on the native os  bypassing the virtual machines figure 1.20  vmware * to run linux on a windows system using vmware  follow these steps  1 download the free " vmware player " tool from http  //www.vmware.com/download/player and install it on your system 2 choose a linux version from among hundreds of virtual machine images at http  //www.vmware.com/appliances 3 boot the virtual machine within vmware player 1.11.7 cloud computing * delivers computing  storage  and applications as a service over a network * types of cloud computing  o public cloud  available to anyone willing to pay for the service o private cloud  run by a company for internal use only o hybrid cloud  a cloud with both public and private components o software as a service  saas  applications such as word processors available via the internet o platform as a service  paas  a software stack available for application use  such as a database server o infrastructure as a service  iaas  servers or storage available on the internet  such as backup servers  photo storage  or file storage o service providers may provide more than one type of service * clouds may contain thousands of physical computers  millions of virtual ones  and petabytes of total storage * web hosting services may offer  one or more  virtual machine  s  to each of their clients figure 1.21  cloud computing 1.11.8 real-time embedded systems * embedded into devices such as automobiles  climate control systems  process control  and even toasters and refrigerators * may involve specialized chips  or generic cpus applied to a particular task  consider the current price of 80286 or even 8086 or 8088 chips  which are still plenty powerful enough for simple electronic devices such as kids toys  * process control devices require real-time  interrupt driven  oses response time can be critical for many such devices 1.12 open-source operating systems *  for more information on the flourish conference held at uic on the subject of free libre and open source software  visit http  //www.flourishconf.com  * open-source software is published  sometimes sold  with the source code  so that anyone can see and optionally modify the code * open-source sw is often developed and maintained by a small army of loosely connected often unpaid programmers  each working towards the common good * critics argue that open-source sw can be buggy  but proponents counter that bugs are found and fixed quickly  since there are so many pairs of eyes inspecting all the code * open-source operating systems are a good resource for studying os development  since students can examine the source code and even change it and re-compile the changes 1.12.1 history * at one time  1950s  a lot of code was open-source * later  companies tried to protect the privacy of their code  particularly sensitive issues such as copyright protection algorithms * in 1983 richard stallman started the gnu project to produce an open-source unix * he later published the gnu manifesto  arguing that all software should be open-source  and founded the free software foundation to promote open-source development * fsf and gnu use the gnu general public license which essentially states that all users of the software have full rights to copy and change the sw however they wish  so long as anything they distribute further contain the same license agreement  copylefting  1.12.2 linux * developed by linus torvalds in finland in 1991 as the first full operating system developed by gnu * many different distributions of linux have evolved from linus 's original  including redhat  suse  fedora  debian  slackware  and ubuntu  each geared toward a different group of end-users and operating environments * to run linux on a windows system using vmware  follow these steps  1 download the free " vmware player " tool from http  //www.vmware.com/download/player and install it on your system 2 choose a linux version from among hundreds of virtual machine images at http  //www.vmware.com/appliances 3 boot the virtual machine within vmware player 1.12.3 bsd unix * unix was originally developed at att bell labs  and the source code made available to computer science students at many universities  including the university of california at berkeley  ucb * ucb students developed unix further  and released their product as bsd unix in both binary and source-code format * bsd unix is not open-source  however  because a license is still needed from att * in spite of various lawsuits  there are now several versions of bsd unix  including free bsd  netbsd  openbsd  and dragonflybsd * the source code is located in /usr/src * the core of the mac operating system is darwin  derived from bsd unix  and is available at http  //developer.apple.com/opensource/index.html 1.13.4 solaris * solaris is the unix operating system for computers from sun microsystems * solaris was originally based on bsd unix  and has since migrated to att systemv as its basis * parts of solaris are now open-source  and some are not because they are still covered by att copyrights * it is possible to change the open-source components of solaris  re-compile them  and then link them in with binary libraries of the copyrighted portions of solaris * open solaris is available from http  //www.opensolaris.org/os/ * solaris also allows viewing of the source code online  without having to download and unpack the entire package 1.13.5 utility * the free software movement is gaining rapidly in popularity  leading to thousands of ongoing projects involving untold numbers of programmers * sites such as http  //freshmeat.net/ and http  //distrowatch.com/ provide portals to many of these projects 1.14 summary operating-system structures references  1 abraham silberschatz  greg gagne  and peter baer galvin  " operating system concepts  ninth edition "  chapter 2 this chapter deals with how operating systems are structured and organized different design issues and choices are examined and compared  and the basic structure of several popular oses are presented 2.1 operating-system services figure 2.1  a view of operating system services oses provide environments in which programs run  and services for the users of the system  including  * user interfaces  means by which users can issue commands to the system depending on the system these may be a command-line interface  e.g sh  csh  ksh  tcsh  etc   a gui interface  e.g windows  x-windows  kde  gnome  etc   or a batch command systems the latter are generally older systems using punch cards of job-control language  jcl  but may still be used today for specialty systems designed for a single purpose * program execution  the os must be able to load a program into ram  run the program  and terminate the program  either normally or abnormally * i/o operations  the os is responsible for transferring data to and from i/o devices  including keyboards  terminals  printers  and storage devices * file-system manipulation  in addition to raw data storage  the os is also responsible for maintaining directory and subdirectory structures  mapping file names to specific blocks of data storage  and providing tools for navigating and utilizing the file system * communications  inter-process communications  ipc  either between processes running on the same processor  or between processes running on separate processors or separate machines may be implemented as either shared memory or message passing   or some systems may offer both  * error detection  both hardware and software errors must be detected and handled appropriately  with a minimum of harmful repercussions some systems may include complex error avoidance or recovery systems  including backups  raid drives  and other redundant systems debugging and diagnostic tools aid users and administrators in tracing down the cause of problems other systems aid in the efficient operation of the os itself  * resource allocation  e.g cpu cycles  main memory  storage space  and peripheral devices some resources are managed with generic systems and others with very carefully designed and specially tuned systems  customized for a particular resource and operating environment * accounting  keeping track of system activity and resource usage  either for billing purposes or for statistical record keeping that can be used to optimize future performance * protection and security  preventing harm to the system and to resources  either through wayward internal processes or malicious outsiders authentication  ownership  and restricted access are obvious parts of this system highly secure systems may log all process activity down to excruciating detail  and security regulation dictate the storage of those records on permanent non-erasable medium for extended times in secure  off-site  facilities 2.2 user operating-system interface 2.2.1 command interpreter * gets and processes the next user request  and launches the requested programs * in some systems the ci may be incorporated directly into the kernel * more commonly the ci is a separate program that launches once the user logs in or otherwise accesses the system * unix  for example  provides the user with a choice of different shells  which may either be configured to launch automatically at login  or which may be changed on the fly  each of these shells uses a different configuration file of initial settings and commands that are executed upon startup  * different shells provide different functionality  in terms of certain commands that are implemented directly by the shell without launching any external programs most provide at least a rudimentary command interpretation structure for use in shell script programming  loops  decision constructs  variables  etc  * an interesting distinction is the processing of wild card file naming and i/o re-direction on unix systems those details are handled by the shell  and the program which is launched sees only a list of filenames generated by the shell from the wild cards on a dos system  the wild cards are passed along to the programs  which can interpret the wild cards as the program sees fit figure 2.2  the bourne shell command interpreter in solaris 10 2.2.2 graphical user interface  gui * generally implemented as a desktop metaphor  with file folders  trash cans  and resource icons * icons represent some item on the system  and respond accordingly when the icon is activated * first developed in the early 1970 's at xerox parc research facility * in some systems the gui is just a front end for activating a traditional command line interpreter running in the background in others the gui is a true graphical shell in its own right * mac has traditionally provided only the gui interface with the advent of osx  based partially on unix   a command line interface has also become available * because mice and keyboards are impractical for small mobile devices  these normally use a touch-screen interface today  that responds to various patterns of swipes or " gestures "  when these first came out they often had a physical keyboard and/or a trackball of some kind built in  but today a virtual keyboard is more commonly implemented on the touch screen figure 2.3  the ipad touchscreen 2.2.3 choice of interface * most modern systems allow individual users to select their desired interface  and to customize its operation  as well as the ability to switch between different interfaces as needed system administrators generally determine which interface a user starts with when they first log in * gui interfaces usually provide an option for a terminal emulator window for entering command-line commands * command-line commands can also be entered into shell scripts  which can then be run like any other programs figure 2.4  the mac os x gui 2.3 system calls * system calls provide a means for user or application programs to call upon the services of the operating system * generally written in c or c + +  although some are written in assembly for optimal performance * figure 2.4 illustrates the sequence of system calls required to copy a file  figure 2.5  example of how system calls are used * you can use " strace " to see more examples of the large number of system calls invoked by a single simple command read the man page for strace  and try some simple examples  strace mkdir temp  strace cd temp  strace date > t.t  strace cp t.t t.2  etc  * most programmers do not use the low-level system calls directly  but instead use an " application programming interface "  api the following sidebar shows the read   call available in the api on unix based systems   the use of apis instead of direct system calls provides for greater program portability between different systems the api then makes the appropriate system calls through the system call interface  using a table lookup to access specific numbered system calls  as shown in figure 2.6  figure 2.6  the handling of a user application invoking the open   system call * parameters are generally passed to system calls via registers  or less commonly  by values pushed onto the stack large blocks of data are generally accessed indirectly  through a memory address passed in a register or on the stack  as shown in figure 2.7  figure 2.7  passing of parameters as a table 2.4 types of system calls six major categories  as outlined in figure 2.8 and the following six subsections   sixth type  protection  not shown here but described below  * standard library calls may also generate system calls  as shown here  2.4.1 process control * process control system calls include end  abort  load  execute  create process  terminate process  get/set process attributes  wait for time or event  signal event  and allocate and free memory * processes must be created  launched  monitored  paused  resumed,and eventually stopped * when one process pauses or stops  then another must be launched or resumed * when processes stop abnormally it may be necessary to provide core dumps and/or other diagnostic or recovery tools * compare dos  a single-tasking system  with unix  a multi-tasking system   o when a process is launched in dos  the command interpreter first unloads as much of itself as it can to free up memory  then loads the process and transfers control to it the interpreter does not resume until the process has completed  as shown in figure 2.9  figure 2.9  ms-dos execution  a  at system startup  b  running a program o because unix is a multi-tasking system  the command interpreter remains completely resident when executing a process  as shown in figure 2.11 below * the user can switch back to the command interpreter at any time  and can place the running process in the background even if it was not originally launched as a background process * in order to do this  the command interpreter first executes a " fork " system call  which creates a second process which is an exact duplicate  clone  of the original command interpreter the original process is known as the parent  and the cloned process is known as the child  with its own unique process id and parent id * the child process then executes an " exec " system call  which replaces its code with that of the desired process * the parent  command interpreter  normally waits for the child to complete before issuing a new command prompt  but in some cases it can also issue a new prompt right away  without waiting for the child process to complete  the child is then said to be running " in the background "  or " as a background process "   figure 2.10  freebsd running multiple programs 2.4.2 file management * file management system calls include create file  delete file  open  close  read  write  reposition  get file attributes  and set file attributes * these operations may also be supported for directories as well as ordinary files *  the actual directory structure may be implemented using ordinary files on the file system  or through other means further details will be covered in chapters 11 and 12  2.4.3 device management * device management system calls include request device  release device  read  write  reposition  get/set device attributes  and logically attach or detach devices * devices may be physical  e.g disk drives   or virtual / abstract  e.g files  partitions  and ram disks   * some systems represent devices as special files in the file system  so that accessing the " file " calls upon the appropriate device drivers in the os see for example the /dev directory on any unix system 2.4.4 information maintenance * information maintenance system calls include calls to get/set the time  date  system data  and process  file  or device attributes * systems may also provide the ability to dump memory at any time  single step programs pausing execution after each instruction  and tracing the operation of programs  all of which can help to debug programs 2.4.5 communication * communication system calls create/delete communication connection  send/receive messages  transfer status information  and attach/detach remote devices * the message passing model must support calls to  o identify a remote process and/or host with which to communicate o establish a connection between the two processes o open and close the connection as needed o transmit messages along the connection o wait for incoming messages  in either a blocking or non-blocking state o delete the connection when no longer needed * the shared memory model must support calls to  o create and access memory that is shared amongst processes  and threads  o provide locking mechanisms restricting simultaneous access o free up shared memory and/or dynamically allocate it as needed * message passing is simpler and easier   particularly for inter-computer communications   and is generally appropriate for small amounts of data * shared memory is faster  and is generally the better approach where large amounts of data are to be shared   particularly when most processes are reading the data rather than writing it  or at least when only one or a small number of processes need to change any given data item  2.4.6 protection * protection provides mechanisms for controlling which users / processes have access to which system resources * system calls allow the access mechanisms to be adjusted as needed  and for non-priveleged users to be granted elevated access permissions under carefully controlled temporary circumstances * once only of concern on multi-user systems  protection is now important on all systems  in the age of ubiquitous network connectivity 2.5 system programs * system programs provide os functionality through separate applications  which are not part of the kernel or command interpreters they are also known as system utilities or system applications * most systems also ship with useful applications such as calculators and simple editors   e.g notepad   some debate arises as to the border between system and non-system applications * system programs may be divided into these categories  o file management  programs to create  delete  copy  rename  print  list  and generally manipulate files and directories o status information  utilities to check on the date  time  number of users  processes running  data logging  etc system registries are used to store and recall configuration information for particular applications o file modification  e.g text editors and other tools which can change file contents o programming-language support  e.g compilers  linkers  debuggers  profilers  assemblers  library archive management  interpreters for common languages  and support for make o program loading and execution  loaders  dynamic loaders  overlay loaders  etc  as well as interactive debuggers o communications  programs for providing connectivity between processes and users  including mail  web browsers  remote logins  file transfers  and remote command execution o background services  system daemons are commonly started when the system is booted  and run for as long as the system is running  handling necessary services examples include network daemons  print servers  process schedulers  and system error monitoring services * most operating systems today also come complete with a set of application programs to provide additional services  such as copying files or checking the time and date * most users ' views of the system is determined by their command interpreter and the application programs most never make system calls  even through the api   with the exception of simple  file  i/o in user-written programs  2.6 operating-system design and implementation 2.6.1 design goals * requirements define properties which the finished system must have  and are a necessary first step in designing any large complex system o user requirements are features that users care about and understand  and are written in commonly understood vernacular they generally do not include any implementation details  and are written similar to the product description one might find on a sales brochure or the outside of a shrink-wrapped box o system requirements are written for the developers  and include more details about implementation specifics  performance requirements  compatibility constraints  standards compliance  etc these requirements serve as a " contract " between the customer and the developers   and between developers and subcontractors   and can get quite detailed * requirements for operating systems can vary greatly depending on the planned scope and usage of the system  single user / multi-user  specialized system / general purpose  high/low security  performance needs  operating environment  etc  2.6.2 mechanisms and policies * policies determine what is to be done mechanisms determine how it is to be implemented * if properly separated and implemented  policy changes can be easily adjusted without re-writing the code  just by adjusting parameters or possibly loading new data / configuration files for example the relative priority of background versus foreground tasks 2.6.3 implementation * traditionally oses were written in assembly language this provided direct control over hardware-related issues  but inextricably tied a particular os to a particular hw platform * recent advances in compiler efficiencies mean that most modern oses are written in c  or more recently  c + +  critical sections of code are still written in assembly language   or written in c  compiled to assembly  and then fine-tuned and optimized by hand from there  * operating systems may be developed using emulators of the target hardware  particularly if the real hardware is unavailable  e.g not built yet   or not a suitable platform for development   e.g smart phones  game consoles  or other similar devices  2.7 operating-system structure for efficient performance and implementation an os should be partitioned into separate subsystems  each with carefully defined tasks  inputs  outputs  and performance characteristics these subsystems can then be arranged in various architectural configurations  2.7.1 simple structure when dos was originally written its developers had no idea how big and important it would eventually become it was written by a few programmers in a relatively short amount of time  without the benefit of modern software engineering techniques  and then gradually grew over time to exceed its original expectations it does not break the system into subsystems  and has no distinction between user and kernel modes  allowing all programs direct access to the underlying hardware  note that user versus kernel mode was not supported by the 8088 chip set anyway  so that really was n't an option back then  figure 2.11  ms-dos layer structure the original unix os used a simple layered approach  but almost all the os was in one big layer  not really breaking the os down into layered subsystems  figure 2.12  traditional unix system structure 2.7.2 layered approach * another approach is to break the os into a number of smaller layers  each of which rests on the layer below it  and relies solely on the services provided by the next lower layer * this approach allows each layer to be developed and debugged independently  with the assumption that all lower layers have already been debugged and are trusted to deliver proper services * the problem is deciding what order in which to place the layers  as no layer can call upon the services of any higher layer  and so many chicken-and-egg situations may arise * layered approaches can also be less efficient  as a request for service from a higher layer has to filter through all lower layers before it reaches the hw  possibly with significant processing at each step figure 2.13  a layered operating system 2.7.3 microkernels * the basic idea behind micro kernels is to remove all non-essential services from the kernel  and implement them as system applications instead  thereby making the kernel as small and efficient as possible * most microkernels provide basic process and memory management  and message passing between other services  and not much more * security and protection can be enhanced  as most services are performed in user mode  not kernel mode * system expansion can also be easier  because it only involves adding more system applications  not rebuilding a new kernel * mach was the first and most widely known microkernel  and now forms a major component of mac osx * windows nt was originally microkernel  but suffered from performance problems relative to windows 95 nt 4.0 improved performance by moving more services into the kernel  and now xp is back to being more monolithic * another microkernel example is qnx  a real-time os for embedded systems figure 2.14  architecture of a typical microkernel 2.7.4 modules * modern os development is object-oriented  with a relatively small core kernel and a set of modules which can be linked in dynamically see for example the solaris structure  as shown in figure 2.13 below * modules are similar to layers in that each subsystem has clearly defined tasks and interfaces  but any module is free to contact any other module  eliminating the problems of going through multiple intermediary layers  as well as the chicken-and-egg problems * the kernel is relatively small in this architecture  similar to microkernels  but the kernel does not have to implement message passing since modules are free to contact each other directly figure 2.15  solaris loadable modules 2.7.5 hybrid systems * most oses today do not strictly adhere to one architecture  but are hybrids of several 2.7.5.1 mac os x * the max osx architecture relies on the mach microkernel for basic system management services  and the bsd kernel for additional services application services and dynamically loadable modules  kernel extensions  provide the rest of the os functionality  figure 2.16  the mac os x structure 2.7.5.2 ios * the ios operating system was developed by apple for iphones and ipads it runs with less memory and computing power needs than max os x  and supports touchscreen interface and graphics for small screens  figure 2.17  architecture of apple 's ios 2.7.5.3 android * the android os was developed for android smartphones and tablets by the open handset alliance  primarily google * android is an open-source os  as opposed to ios  which has lead to its popularity * android includes versions of linux and a java virtual machine both optimized for small platforms * android apps are developed using a special java-for-android development environment figure 2.18  architecture of google 's android 2.8 operating-system debugging kernighan 's law " debugging is twice as hard as writing the code in the first place therefore  if you write the code as cleverly as possible  you are  by definition  not smart enough to debug it " * debugging here includes both error discovery and elimination and performance tuning 2.8.1 failure analysis * debuggers allow processes to be executed stepwise  and provide for the examination of variables and expressions as the execution progresses * profilers can document program execution  to produce statistics on how much time was spent on different sections or even lines of code * if an ordinary process crashes  a memory dump of the state of that process 's memory at the time of the crash can be saved to a disk file for later analysis o the program must be specially compiled to include debugging information  which may slow down its performance * these approaches do n't really work well for os code  for several reasons  o the performance hit caused by adding the debugging  tracing  code would be unacceptable  particularly if one tried to " single-step " the os while people were trying to use it to get work done !  o many parts of the os run in kernel mode  and make direct access to the hardware o if an error occurred during one of the kernel 's file-access or direct disk-access routines  for example  then it would not be practical to try to write a crash dump into an ordinary file on the filesystem * instead the kernel crash dump might be saved to a special unallocated portion of the disk reserved for that purpose 2.8.2 performance tuning * performance tuning  debottlenecking  requires monitoring system performance * one approach is for the system to record important events into log files  which can then be analyzed by other tools these traces can also be used to evaluate how a proposed new system would perform under the same workload * another approach is to provide utilities that will report system status upon demand  such as the unix " top " command  w  uptime  ps  etc  * system utilities may provide monitoring support figure 2.19  the windows task manager 2.8.3 dtrace * dtrace is a special facility for tracing a running os  developed for solaris 10 * dtrace adds " probes " directly into the os code  which can be queried by " probe consumers "  * probes are removed when not in use  so the dtrace facility has zero impact on the system when not being used  and a proportional impact in use * consider  for example  the trace of an ioctl system call as shown in figure 2.22 below figure 2.20  solaris 10 dtrace follows a system call within the kernel * probe code is restricted to be " safe "   e.g no loops allowed   and to use a minimum of system resources * when a probe fires  enabling control blocks  ecbs  are performed  each having the structure of an if-then block * when a consumer terminates  the ecbs associated with that consumer are removed when no more ecbs remain interested in a particular probe  then that probe is also removed * for example  the following d code monitors the cpu time of each process running with user id of 101 the output is shown in figure 2.23 below sched    on-cpu uid = = 101  self > ts = timestamp ;  sched    off-cpu self > ts  @ time  execname  = sum  timestamp  self > ts  ; self > ts = 0 ;  figure 2.21 * use of dtrace is restricted  due to the direct access to  and ability to change  critical kernel data structures * because dtrace is open-source  it is being adopted by several unix distributions others are busy producing similar utilities 2.9 operating-system generation * oses may be designed and built for a specific hw configuration at a specific site  but more commonly they are designed with a number of variable parameters and components  which are then configured for a particular operating environment * systems sometimes need to be re-configured after the initial installation  to add additional resources  capabilities  or to tune performance  logging  or security * information that is needed to configure an os include  o what cpu  s  are installed on the system  and what optional characteristics does each have o how much ram is installed  this may be determined automatically  either at install or boot time  o what devices are present the os needs to determine which device drivers to include  as well as some device-specific characteristics and parameters o what os options are desired  and what values to set for particular os parameters the latter may include the size of the open file table  the number of buffers to use  process scheduling  priority  parameters  disk scheduling algorithms  number of slots in the process table  etc * at one extreme the os source code can be edited  re-compiled  and linked into a new kernel * more commonly configuration tables determine which modules to link into the new kernel  and what values to set for some key important parameters this approach may require the configuration of complicated makefiles  which can be done either automatically or through interactive configuration programs ; then make is used to actually generate the new kernel specified by the new parameters * at the other extreme a system configuration may be entirely defined by table data  in which case the " rebuilding " of the system merely requires editing data tables * once a system has been regenerated  it is usually required to reboot the system to activate the new kernel because there are possibilities for errors  most systems provide some mechanism for booting to older or alternate kernels 2.10 system boot the general approach when most computers boot up goes something like this  * when the system powers up  an interrupt is generated which loads a memory address into the program counter  and the system begins executing instructions found at that address this address points to the " bootstrap " program located in rom chips  or eprom chips  on the motherboard * the rom bootstrap program first runs hardware checks  determining what physical resources are present and doing power-on self tests  post  of all hw for which this is applicable some devices  such as controller cards may have their own on-board diagnostics  which are called by the rom bootstrap program * the user generally has the option of pressing a special key during the post process  which will launch the rom bios configuration utility if pressed this utility allows the user to specify and configure certain hardware parameters as where to look for an os and whether or not to restrict access to the utility with a password o some hardware may also provide access to additional configuration setup programs  such as for a raid disk controller or some special graphics or networking cards * assuming the utility has not been invoked  the bootstrap program then looks for a non-volatile storage device containing an os depending on configuration  it may look for a floppy drive  cd rom drive  or primary or secondary hard drives  in the order specified by the hw configuration utility * assuming it goes to a hard drive  it will find the first sector on the hard drive and load up the fdisk table  which contains information about how the physical hard drive is divided up into logical partitions  where each partition starts and ends  and which partition is the " active " partition used for booting the system * there is also a very small amount of system code in the portion of the first disk block not occupied by the fdisk table this bootstrap code is the first step that is not built into the hardware  i.e the first part which might be in any way os-specific generally this code knows just enough to access the hard drive  and to load and execute a  slightly  larger boot program * for a single-boot system  the boot program loaded off of the hard disk will then proceed to locate the kernel on the hard drive  load the kernel into memory  and then transfer control over to the kernel there may be some opportunity to specify a particular kernel to be loaded at this stage  which may be useful if a new kernel has just been generated and does n't work  or if the system has multiple kernels available with different configurations for different purposes  some systems may boot different configurations automatically  depending on what hardware has been found in earlier steps  * for dual-boot or multiple-boot systems  the boot program will give the user an opportunity to specify a particular os to load  with a default choice if the user does not pick a particular os within a given time frame the boot program then finds the boot loader for the chosen single-boot os  and runs that program as described in the previous bullet point * once the kernel is running  it may give the user the opportunity to enter into single-user mode  also known as maintenance mode this mode launches very few if any system services  and does not enable any logins other than the primary log in on the console this mode is used primarily for system maintenance and diagnostics * when the system enters full multi-user multi-tasking mode  it examines configuration files to determine which system services are to be started  and launches each of them in turn it then spawns login programs  gettys  on each of the login devices which have been configured to enable user logins o  the getty program initializes terminal i/o  issues the login prompt  accepts login names and passwords  and authenticates the user if the user 's password is authenticated  then the getty looks in system files to determine what shell is assigned to the user  and then " execs "  becomes  the user 's shell the shell program will look in system and user configuration files to initialize itself  and then issue prompts for user commands whenever the shell dies  either through logout or other means  then the system will issue a new getty for that terminal device  2.11 summary old 2.8 virtual machines  moved elsewhere in the 9th edition  * the concept of a virtual machine is to provide an interface that looks like independent hardware  to multiple different oses running simultaneously on the same physical hardware each os believes that it has access to and control over its own cpu  ram  i/o devices  hard drives  etc * one obvious use for this system is for the development and testing of software that must run on multiple platforms and/or oses * one obvious difficulty involves the sharing of hard drives  which are generally partitioned into separate smaller virtual disks for each operating os figure 16.1  system models  a  nonvirtual machine  b  virtual machine 2.8.1 history * virtual machines first appeared as the vm operating system for ibm mainframes in 1972 2.8.2 benefits * each os runs independently of all the others  offering protection and security benefits *  sharing of physical resources is not commonly implemented  but may be done as if the virtual machines were networked together  * virtual machines are a very useful tool for os development  as they allow a user full access to and control over a virtual machine  without affecting other users operating the real machine * as mentioned before  this approach can also be useful for product development and testing of sw that must run on multiple oses / hw platforms 2.8.3 simulation * an alternative to creating an entire virtual machine is to simply run an emulator  which allows a program written for one os to run on a different os * for example  a unix machine may run a dos emulator in order to run dos programs  or vice-versa * emulators tend to run considerably slower than the native os  and are also generally less than perfect 2.8.4 para-virtualization * para-virtualization is another variation on the theme  in which an environment is provided for the guest program that is similar to its native os  without trying to completely mimic it * guest programs must also be modified to run on the para-virtual os * solaris 10 uses a zone system  in which the low-level hardware is not virtualized  but the os and its devices  device drivers  are o within a zone  processes have the view of an isolated system  in which only the processes and resources within that zone are seen to exist o figure 2.18 shows a solaris system with the normal " global " operating space as well as two additional zones running on a small virtualization layer figure 16.7  solaris 10 with two zones 2.8.5 implementation * implementation may be challenging  partially due to the consequences of user versus kernel mode o each of the simultaneously running kernels needs to operate in kernel mode at some point  but the virtual machine actually runs in user mode o so the kernel mode has to be simulated for each of the loaded oses  and kernel system calls passed through the virtual machine into a true kernel mode for eventual hw access * the virtual machines may run slower  due to the increased levels of code between applications and the hw  or they may run faster  due to the benefits of caching  and virtual devices may also be faster than real devices  such as ram disks which are faster than physical disks  2.8.6 examples 2.8.6.1 vmware * abstracts the 80x86 hardware platform  allowing simultaneous operation of multiple windows and linux oses  as shown by example in figure 2.19  figure 16.9  vmware workstation architecture 2.8.6.2 the java virtual machine * java was designed from the beginning to be platform independent  by running java only on a java virtual machine  jvm  of which different implementations have been developed for numerous different underlying hw platforms * java source code is compiled into java byte code in .class files java byte code is binary instructions that will run on the jvm * the jvm implements memory management and garbage collection * java byte code may be interpreted as it runs  or compiled to native system binary code using just-in-time  jit  compilation under this scheme  the first time that a piece of java byte code is encountered  it is compiled to the appropriate native machine binary code by the java interpreter this native binary code is then cached  so that the next time that piece of code is encountered it can be used directly * some hardware chips have been developed to run java byte code directly  which is an interesting application of a real machine being developed to emulate the services of a virtual one ! figure 16.10  the java virtual machine * the .net framework also relies on the concept of compiling code for an intermediary virtual machine   common language runtime  clr   and then using jit compilation and caching to run the programs on specific hardware  as shown in figure 2.21  figure 2.21 vs 