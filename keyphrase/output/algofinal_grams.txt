design and analysis
analysis of algorithms
algorithms prof abhiram
prof abhiram ranade
abhiram ranade computer
ranade computer science
computer science engineering
science engineering department
engineering department indian
department indian institute
institute of technology
give also convey
convey a spirit
easy to design
cleverness is needed
needed and designing
algorithms which give
answers very quickly
main course goal
design of fast
defined design techniques
study these techniques
lots of exercises
apply these ideas
solve algorithm design
algorithm design problems
done some amount
amount of programming
scheme or basic
discrete mathematics background
build the model
analytical will build
build a model
build a mathematical
study their properties
properties of algorithms
reason about algorithms
mathematically prove properties
properties the emphasis
proof prove properties
properties about speed
speed say prove
number of things
give an overview
develop the basic
define the mathematical
fairly long stretch
stretch which involves
techniques for designing
designing fast algorithms
algorithms while doing
surveying many problems
problems from optimization
optimization graph theory
theory some problems
problems from geometry
algorithm design techniques
design really god
algorithms our techniques
fairly intricate theory
theory has developed
last several year
studying this theory
topic for today
today the main
convey the spirit
fairly simple problem
trouble in understanding
state that problem
find their greatest
greatest common divisor
understands this problem
learnt in school
taught in first
standard or fourth
find the greatest
study another algorithm
geometry yes euclid
euclid did invent
invent this algorithm
understand that euclid
simple school level
school level algorithm
algorithm for factoring
integer that divides
leaving a reminder
means finding primes
write it separately
identify common factors
multiply and return
return the result
invent a pseudo
write down algorithms
express your algorithms
suitable nicest syntax
calculate the remainder
set n equals
inside the loop
eventually this loop
return the value
doing some divisions
divisions and taking
taking some remainders
greatest common divisors
product of prime
thing we start
identify what factors
factors are common
common the common
school level stuff
enter the loop
calculate r equals
equals n mod
takes the value
point the iteration
iteration has ended
point our iteration
out the loop
exit the loop
return the current
collect common factors
multiply the factors
return the answer
divided it checked
found that answer
false the division
exchanged the numbers
summarize the work
level very simple
simple factoring algorithm
done less work
algorithm in fact
returning the correct
factorize these numbers
back to euclid
compute the reminder
exchange values basically
iteration of euclid
began this iteration
leaving the remainder
enter this iteration
set n equal
out r equals
matter of setting
equal the value
back and execute
execute this loop
fact does divide
point the loop
iterations what happened
division per iteration
problem m equals
divisions to calculate
correct to check
substantially many divisions
require many divisions
bigger and bigger
bigger numbers factoring
lot more work
divisions then numbers
smaller and smaller
algorithm will terminate
argue that euclid
algorithm actually works
fairly very detail
idea the main
fact about divisibility
divisibility and remainder
remainder and things
number which divides
mention the main
idea is suppose
prime having written
iteration the loop
part of euclid
calculates the fact
essentially n mod
essentially this term
argument is set
fact the proof
proof of euclid
algorithm the correctness
correctness of euclid
loop will exit
continues to remain
loop in fact
loop should terminate
fairly straight forward
loop is executing
initially the values
taking some values
step is calculating
loop the value
decrease how long
value is returned
proves that euclid
algorithm is correct
runs reasonably quick
purpose of analysis
wrote will work
make this call
exchanging these values
values the first
spent for exchanging
good as assume
assume in fact
wills the euclid
state the main
prove the main
make a distinction
euclid with values
iteration the sum
values of variables
sum will drop
drop very fast
number of iterations
iterations this establishes
iterations is equal
equal to log
theorem will put
put a good
good upper bound
iterations that euclid
prove this theorem
iterations euclid takes
beginning of iteration
value p prime
prime n takes
takes that value
value q prime
express p prime
prime in terms
computes r equals
mod old value
simply q mod
thing p prime
fact in addition
concerns p prime
remainder plus divisor
wanted p prime
prime is equal
matter of algebra
multiply this last
matter of simplifying
times p prime
sum has reduced
factor of two-thirds
halves that concludes
concludes the analysis
algorithm will execute
fairly small number
number of steps
conclude this lecture
lecture and highlight
highlight the main
algorithms the school
interesting deeper properties
deeper properties deeper
properties deeper mathematical
deeper mathematical properties
helps in designing
analysis counting iterations
marks the end
abhiram ranade department
department of computer
science engineering indian
engineering indian institute
framework for algorithms
algorithms in today
develop a framework
framework for algorithm
designing many algorithms
algorithms for solving
kinds of problems
compare these algorithms
sound mathematical bases
design a formal
lectures the framework
comparing the execution
comparing other resources
amounts of memory
compare the memory
algorithms the basic
idea in designing
kind of analysis
bit more formal
make a mathematical
execute that algorithm
involved in doing
doing the analysis
model for computer
execute our algorithm
specific real computer
mentally will imagine
mentally execute algorithm
algorithm on computer
model and evaluate
develop in order
order to develop
answer several questions
algorithm might perform
execute the algorithm
algorithms will require
data some input
extremely important question
execution in general
general will depend
make mathematical models
relate to real
apply to real
answer these questions
finish our development
start by discussing
fairly basic terms
formally some basic
present our mathematical
general overall analysis
taking a number
number of examples
examples of algorithms
mathematical model relate
discuss these points
day to day
things in scientific
important to fix
fix the meanings
first very common
give a definition
give some examples
motivate this definition
problem of computing
computing the gcd
problem of finding
finding the shortest
finding the meaning
typically certain input
city say aurangabad
supply which map
western india automobile
india automobile association
automobile association map
definition for finding
finding a word
supply the word
supply an actual
actual x ray
case the output
evolution for finding
evolution the output
constitute acceptable outputs
outputs ? acceptable
constitute valid inputs
shortest path names
constitutes a valid
input and acceptable
sense as input
sense as inputs
phrase input instance
valid input value
instance for problem
constitute an instance
gcd problem mumbai
problem mumbai aurangabad
aurangabad and map
shortest path problem
term input instance
stick with instance
number of bits
needed to represent
represent the input
specific input instance
constitutes the input
bits are needed
represented in binary
map is concerned
represent the map
general a map
inconvenient for directives
parameter which grows
roughly the growth
notion of size
definition of size
simply the sum
bits in fact
analyzed the gcd
size the sum
algorithm will increase
evaluate an algorithm
takes a long
instance of large
number of roads
number of cities
finding a shortest
involves one road
algorithm which takes
takes us takes
takes a small
map which consists
problem the size
dictionary the number
number of words
ray and convert
phrase problem size
denote the size
hear the phrase
discuss is algorithm
abstract computational procedure
procedure which takes
takes some value
value or values
values as input
input and produces
produces a value
values as output
abstract in order
order to denote
algorithm might give
languages a program
concrete and algorithms
eve for discussing
rules for syntax
convey that idea
basic our goal
description of algorithms
beings can understand
fairly great level
level of detail
abbreviate our descriptions
met the reason
reason for describing
write the program
program will execute
purpose another important
easy to analyze
analyze how long
describe our mathematical
ram and ram
stands for random
random access machine
simplified computer model
memory the memory
correction of locations
array with numbers
locations by assigning
assigning by describing
describing the number
inconvenient in general
describe the ram
program the ram
thing to notice
model contains locations
addressed by numbers
fact allow variable
value is contained
contained in variable
value we stored
variety of data
simple plain simple
plain simple variables
two as sort
primitive data types
write down simple
addition of course
things like trees
memory is concerned
store the program
program and data
number of instructions
assume for simplicity
groups of instructions
group is arithmetic
arithmetic and logical
locations from memory
add their contents
contents and deposit
friendly pleasant manner
taking two operands
put them back
jumps and conditional
allowed to write
defining our model
definition reasonably simple
make another comment
group of instructions
talking about concerns
structured programming presenting
presenting the algorithms
nice readable manner
talk about machines
basic instruction set
cycles of execution
call as pointer
style pointer notation
fetch that location
location whose value
contained that location
location whose address
address is contained
based on pointers
pointers and arrays
arrays a lot
machine our random
similar consistent manner
put down array
back to arrays
make one comment
arrays and structures
structures will assume
assume the usual
representation of arrays
array has size
array is stored
locations in memory
structure which consists
memory so coming
memory a processor
processor whose basic
memory which consists
collection of bits
matter what number
basic algorithmic actions
complex algorithmic actions
actions more complex
complex algorithmic statements
instructions or statements
times d minus
out elementary instructions
fetch the value
takes one step
fetch c equals
compute z equals
computed their sum
statement well simple
four machine instructions
steps during execution
multi dimensional arrays
two dimensional arrays
arrays are stored
arrays are built
built on top
two dimensional array
array is indexed
indexed c style
number of elements
stored row wise
wise many possibilities
accessing some element
array we access
access in order
order to access
element of array
row i column
prime which element
simply i times
number of columns
problem of accounting
equals a prime
plain indirect axis
structured computing statements
translate these instructions
write i equal
end of loop
write y equals
store it back
number these statements
out of loop
purpose of accounting
accounting is concerned
analyze this code
times will statement
executed n times
times this loop
needed to execute
steps is needed
number of arguments
equal to number
passed by reference
reference which means
passed by value
concludes the description
number of issues
relates to reality
reality are real
relevant for real
engineering indian institution
institution of technology
algorithm analysis framework
developing algorithm analysis
analysis framework part
framework part two
defined an abstract
abstract computer model
model called ram
stored in memory
memory would include
things like variables
arrays the usual
separate program memory
mention which instructions
instructions are important
basically the instruction
form a equals
kind of instructions
kind of instruction
instructions or jump
instructions or control
control transfer instructions
instructions and conditional
operations or array
array or pointer
equals b index
instruction is sort
standard array axis
instructions those algorithms
estimate the total
goal for today
outline for today
start by comparing
comparing our ram
model with real
make a difference
sake of completeness
define our general
strategy for algorithm
summary as usual
sense this differs
differs from real
unlike our random
single memory real
memory real computer
kinds of memory
call main memory
memory called cache
heard of cache
memory most computer
advertisements do talk
registers register memory
tricky complication arises
computers these days
stages of execution
essentially this means
fairly complicated idea
idea and analyzing
analyzing this idea
extent these complications
defined an instruction
machine the instruction
set for real
instructions which transfer
memory to memory
memory instructions memory
memory or memory
memory to register
register copying instructions
done in registers
ram our abstract
variable in memory
contained in register
main memory location
location just stress
main memory locations
directly with data
stored in main
differences between real
program which consists
translator would operate
extract the value
directly on array
loaded say temp
instructions in translation
statement a simple
simple minded translator
equals or temp
result a high
high level language
level language statement
sequence of high
number of statements
compiler would translate
translate the first
first statement translation
translation would require
require a fetching
require a fetch
transfer an intelligent
compiler would realize
algorithms an intelligent
compiler which sets
level language algorithm
level language program
idealized model applies
applies to real
make this application
general analysis strategy
strategy our measure
denote the maximum
instance of size
call it algorithm
solve any instance
sorting a data
set the size
number of values
algorithm is doing
instances of size
value in principle
determine that value
value by executing
executing our algorithm
measure of goodness
algorithm a notice
evaluating a single
good this algorithm
job to find
out which algorithm
definition the first
inputs of size
difficult to perform
primarily the reason
life with equal
taking that average
taking an average
introduces an extra
worst case measure
relates to real
earlier we pointed
out the differences
computers and rams
ram might correspond
arises whatever analysis
consequence for real
point the important
precise the precise
consequence of real
computers and real
function being linear
run your algorithm
interested in characterizing
characterizing the algorithm
pick a measure
measure which depends
give exact bounds
bound and lower
lower bound match
match then great
great our analysis
analysis is complete
live with incomplete
incomplete our work
work done incomplete
incomplete and bridging
bridging the difference
subject of research
solving large problems
problems become larger
larger and larger
larger which algorithm
answer that question
question very quickly
quadratic time algorithm
algorithm is worse
linear time algorithm
idea is justified
computers to solve
solve large problems
problem is small
fast these days
algorithm is good
algorithm is bad
examples to make
make these ideas
ideas more concrete
concrete the first
multiplication our input
usual matrix product
defined as summation
algorithms for matrix
size of dimension
matrices are represented
calculate the value
out how long
long this takes
access machine ram
thing to note
note in analyzing
analyzing this algorithm
typical of algorithms
chosen this algorithm
illustrate the analysis
analyzing more complex
takes b steps
remember these numbers
pretty exact analysis
exact analysis knowing
analysis is important
understood the ram
ram model completely
details is important
analyze without doing
doing without paying
stick to exact
needed from last
array an element
array it takes
ideas to analyze
analyze our program
program our algorithm
two arithmetic operations
single a single
statement itself forget
forget the loops
steps no matter
comprises the body
takes an additional
loop the total
formula for body
loop in terms
body and number
made a mistake
mistake in doing
doing this arithmetic
arithmetic the expression
times n cube
times n square
execute this algorithm
instructions could change
number of basic
change the fact
loop must execute
execute n times
compiler this fact
execute the outer
outer most loop
run this program
write down sort
form a times
precisely the level
level of exactness
analyze an algorithm
analyze a computer
make this statement
statement which sounds
sounds almost qualitative
cubic or quadratic
quadratic or linear
weak looking statement
kind of statement
computers the important
making a weak
pentium whatever computer
talk about computers
precise computer architectures
talk about algorithms
long an algorithm
illustrate this idea
idea of analysis
finding the median
median the input
out the median
element which appears
smaller than utmost
elements and larger
larger than utmost
program for finding
satisfies the median
number of smaller
elements is utmost
number of larger
element in turn
elements is equal
initialize the number
found an element
increment the count
count for larger
larger that ends
median in fact
repeat we repeat
exercise to show
executes n times
focus our attention
utmost n times
make a simple
assumption a simplifying
calculate an upper
business of calculating
calculating an upper
clever in analyzing
make this assumption
finishes the analysis
function is smaller
order to complete
complete this analysis
met or met
numbers are distinct
instance it takes
strategy this strategy
strategy is based
notion of worst
worst case analysis
equal to real
leave it leave
algorithms our topic
today is asymptotic
begin by setting
main course goals
first design algorithms
needed in understanding
order to predict
entire detailed analysis
analysis not applicable
interpretation our conclusions
computers at large
define the notion
notion of classes
classes of functions
lot more systematic
systematic and formal
goal of today
develop the notation
nicely about classes
notation to speak
speak about functions
functions and classify
classify them asymptotic
asymptotic analysis refers
question of classifying
functions or classifying
classifying the behavior
out by writing
kinds of features
nicely ignore constant
ignore constant multipliers
multipliers our class
give more importance
importance to behavior
out first property
property or first
notation a class
give an outline
outline of today
define three main
kinds of notation
define function classes
lots of examples
series of examples
non negative values
negative values functions
functions of non
non negative arguments
kind of resource
occasion when functions
non negative function
structure we defined
worried about smaller
draw a picture
plot the function
claim our requirement
occupies this region
inside anywhere inside
class theta times
essentially it behaves
belongs to theta
class n cube
developing a class
order to classify
classify a function
set of functions
find suitable constants
find these suitable
suitable a constant
properties are met
naught having found
satisfy the properties
connotation of cubic
form something times
write fully claim
functions or class
class of functions
ignoring constant factors
large this term
dominate this term
times n log
fairly easy task
slightly more complicated
asymptotic complexity class
belonging to theta
function which returns
two n cube
worry about constant
defined the first
goals we set
science and mathematics
funny style evolved
classes is concerned
suppose f belongs
common writing style
equal to theta
tradition in computer
equal to operator
english language words
rose is red
class of red
set of red
equals to theta
guess in poetic
red is rose
functions as functions
sort of understood
variable the argument
emphasize the fact
god to write
simply the theta
satisfying our basic
definition of theta
class omega relaxes
relaxes the lower
lower bound condition
condition and omega
relaxes the upper
upper bound condition
omega the lower
condition is present
count the number
satisfying this condition
make this point
point the class
put it put
put the unknown
expressing that upper
expressing this knowledge
belongs to omega
bounds in terms
function f belongs
guessed the class
simply the union
square in fact
bigger than theta
cube similar logic
class no surprise
lower order terms
main functions classes
defined these classes
plain old function
functions could denote
define a general
equal to summation
requires some amount
amount of cleverness
belongs to class
determine the class
right away puts
ignore the first
term by term
term this series
series this sum
sum is bigger
positive real number
require exceptional cleverness
evaluate a function
stated in terms
home work prove
cube the proof
make that claim
nth fibonacci number
proving this exact
takes a lot
omega of root
commonly called exponential
fibonacci number grow
number grow exponentially
involves essentially involves
essentially involves finding
out a precise
express our knowledge
knowledge or lack
notation these capture
capture the idea
ignore consider leading
estimates of algorithms
fact this notation
notation on functions
thinking about functions
functions in general
algorithms prof sunder
sunder vishwanathan department
basics we begin
begin with discussion
basic design techniques
techniques for algorithms
fairly simple problems
solutions to non
non trivial problems
finding the minimum
problem is find
min the input
scan the array
element by element
element the first
element third element
compare the array
element with temp
temp and update
solve the problem
first n minus
temp is set
loop i varies
write the full
code in fact
code the idea
variables properly etcetera
main the techniques
algorithm which solves
solves the problem
element and update
update the current
minimum as required
two things couple
couple of things
thing this design
induction both recursion
recursion and iteration
sort of thing
mind is ordering
solve a problem
problem your input
size the array
solve this problem
problem for smaller
values of input
solved for smaller
extend these solutions
extend the solution
input for instance
arrays of size
size n minus
array of size
step which takes
put this step
update the solution
algorithm design technique
crux of design
algorithms second point
make is ordering
ordering the input
order often helps
index in fact
cases where ordering
role in solving
solving the problem
store the previous
temp the temporary
induction and storing
storing whole values
order the input
design any algorithm
analyze this algorithm
analysis every algorithm
important a part
subject as design
pertain to worst
make one comparison
comparison for array
element this leads
make n minus
minus one comparison
subsequent we make
value in temp
number of times
equals the number
number of comparisons
worried about constants
bound the number
incrementing the index
array or storing
storing the value
find the minimum
sort of first
making n minus
argument is easy
made the minimum
array the minimum
compare an element
comparisons are needed
needed the reason
reason every element
element is compared
sort of satisfy
satisfy this condition
answer n minus
made any comparison
minimum each element
elements are minimum
make a comparison
elements are candidates
remains a candidate
remains the candidate
candidates to start
bit hang wavy
put a circle
draw an edge
draw this edge
compared i draw
drawing these edges
program ends terminates
surely give values
pick the global
finished all comparisons
component this means
add an edge
decrease the number
number of connected
sort of simple
wanted to find
find the maximum
maximum n minus
difficult to prove
small values supposing
found the minimum
maintaining the maximum
comparisons are repeated
two and find
minimum and maximum
left hand side
right hand side
parts recursively find
part and min
maximum and minimum
two to find
natural i divide
two parts divide
two equal parts
parts two equal
two equal halves
equal halves halves
equal i find
side the left
minimums to output
output the minimum
array i compare
write the algorithm
divide into halves
left and right
answers are max
put these things
compute final solution
written the essence
details i hope
details define procedures
procedures and write
write down recursive
comparisons and output
min on arrays
problems of half
half the size
size you solve
solve two problems
two more comparisons
call the left
ceiling and floor
open this out
difficult to guess
usual geometric series
satisfies the recurrence
refresh your memory
memory the recurrence
improved the number
divide and conquer
divide the problem
step is recurse
part and solve
step is put
put these solutions
solutions together put
blindly in fact
done it blindly
divide that divide
divide this array
arrays to size
two maximums find
array by comparing
comparing two minimums
problems of smaller
find these small
small problems varies
varies from problem
problem to problem
apply this method
minimum the minimum
minimum the usual
array and find
two temporary variables
temporary variables temp
store the current
minimum in temporary
current second minimum
element i compare
compare this first
max min case
apply our divide
array the array
paths i find
find a minimum
minimum the smaller
smaller than min
loss of generality
generality this min
minimum second minimum
side s min
sort of thrown
true then compare
two will give
minimum the left
hand side minimum
minimum the right
comparing the minimum
lost the first
two sub problems
suffices to find
set of equations
comparisons we make
half n minus
two problems behave
problems behave differently
differently for max
half n comparisons
sort of paradigm
understand a bit
unfold the recurrent
parts we divide
recurse divide recurse
divide recurse divide
avail as size
comparisons start happening
happening the recurrence
sort of bottoms
minimum is pushed
minute the maximum
works very similar
similar you put
put the max
mins are pushed
element is pushed
compare the minimum
familiar complete binary
complete binary tree
log n levels
sort of minimum
minimum element sits
sort of wins
traverse some root
minimum element resided
sort of observation
make to speed
two is minimum
elements were compared
element was compared
element the length
path is log
log n elements
array were compared
collect all elements
tree in front
tree and figure
initially you made
made n comparisons
minus one comparisons
comparisons to find
log n minus
problem a straight
straight forward application
application of divide
understand a problem
problem a bit
feel nice design
sunder viswanathan department
storing old values
first term design
term design principle
generate a solution
algorithm is clear
clear you sort
sort of recurse
smaller inputs solve
back you put
point is ordering
order for instance
order of indices
algorithms simple algorithms
algorithms for simple
absolutely anything divide
two parts solve
put the solution
divide input solve
solve each part
part and put
pays to divide
cases for instance
instance max min
min or finding
breaking at breaking
breaking the input
solve the recurrence
sort of encourage
sort of design
sort of case
array an array
sort the elements
elements in increasing
assume that elements
elements are distinct
mind less cluttered
put the first
first design principle
principle into practice
natural smaller arrays
problem of sorting
sorting the array
portion is sorted
search and identify
make essentially make
essentially make space
right every element
move one step
insert the element
sort the first
last element sits
learnt insertion sort
sort there people
people i guess
out the number
comparisons the last
comparisons is log
doing a binary
roughly order log
order n log
step the last
find this place
shift the entire
find the place
place to move
step in insertion
order n steps
order n square
sort of avoid
avoid this movement
insertion sort takes
sort takes order
paradigms into play
play into practice
divide the array
array equally work
array you divide
two halves sort
sort each piece
two pieces sort
pieces no sweat
sort each recursion
recursion you recurse
piece you sort
putting two sorted
two sorted arrays
principles to list
put a list
pieces we sort
put the solutions
algorithm is ready
big sorted array
sorted this piece
piece is sorted
two sorted pieces
big sorted piece
merging two sorted
arrays or lists
sorted in ascending
build a bigger
guess the procedure
list or array
element will occur
occur will occupy
occupy the first
compare the first
lists or arrays
arrays or sub
arrays and put
put the smaller
assign the smaller
move this pointer
merging i hope
pointers you sort
sort of compare
two values put
list and increment
increment this pointer
done and arrays
doing this work
create this merge
piece of paper
two sorted sequences
step the divide
step we sort
half the array
things together good
operation is big
times the number
moving the pointer
copying one list
bound the total
roughly equal size
worry about floors
floors and ceilings
ceilings for ease
ease of calculation
two sub arrays
lists of size
ways of figuring
figuring this out
design this algorithm
algorithm using design
step you compare
compare two elements
element gets filled
comparison one element
final sorted array
array gets filled
comparison an extra
elements get filled
comparisons you make
make is utmost
state this analysis
comparison an element
make k comparisons
fill k elements
comparisons i make
add an element
element to call
call this array
two smaller arrays
pick an element
element and add
write the recurrence
merge a bit
apply our design
merge to smaller
merge larger arrays
elements the first
input now consists
supposing i solve
solve my problem
size is smaller
smaller one element
two i merge
element i put
sort of merge
naturally use recursion
write a recurrence
comparison i make
make i make
make i compare
two elements remove
remove the smaller
equals n minus
merge two arrays
arrays the sum
write the code
unroll the recursion
iterative process back
back to merge
put a constant
make no difference
difference these constant
solve this recurrence
recurrence i guess
sort of check
sort of guess
times log base
business on arrays
arrays to sort
parts somehow work
rearranging the elements
previous case remember
left is smaller
array must occur
divided this array
two parts left
left are smaller
sort the left
separately you sort
sort the right
right this left
sorted this right
conquer the divided
parts and recursion
sort these two
two putting things
array is sorted
divide the input
sort of emphasize
sorts an array
array our emphasis
algorithm called quick
start with divide
put this paradigm
paradigm into place
split an array
array into left
pick a pivot
call the pivot
pivot left consists
array every element
element is smaller
sort in front
quick sort pick
two parts smaller
two parts recurse
recurse and put
unlike the difference
difference between merge
sort and quick
easy in merge
merge sort dividing
parts is easy
element you pick
supposing you pick
make a definition
sorted order remember
order remember recall
array is distinct
element i elements
elements are smaller
partition the array
compared each element
put the lesser
compared every element
comparisons we made
recurrence clearly sort
picked the minimum
minus i minus
minus i elements
side the pivot
side had size
chosen the minimum
picking the minimum
square for quick
reach the middle
roughly the middle
problems of equal
sort of write
initially starts falling
pick the maximum
similar to picking
minimum the array
array sizes split
manage to pick
pick the pivots
pick the middle
square this implementation
implementation of quick
element of rank
means the recursion
add a constant
give me order
find the middle
means an element
find an element
implement quick sort
pick i spend
pick this middle
element the element
array is divided
two roughly equal
roughly equal parts
takes n log
find this element
point this fact
kind of situations
split the input
recurrence these recurrences
pick this element
state this problem
find the median
sort the array
array and pick
element that takes
instance use merge
median in linear
first non trivial
non trivial algorithm
looked at algorithms
algorithms for sorting
quick sort worked
picked a pivot
pivot and split
split the array
parts those elements
pivot and elements
pick the median
make quick sort
quick sort work
set the ball
element to find
find the rank
simplicity that elements
array are distinct
distinct every element
element is distinct
distinct all algorithms
rank and rank
array how fast
output the median
done in order
array and picking
picking the middle
middle element sort
median and sorting
conquer for instance
kind of approximate
element whose rank
rank is greater
greater than equal
call approximate medians
middle element supposing
find the exact
right it sits
array it sits
parts have size
shrunk the size
find this approximate
finding the exact
find approximate median
part that part
part has size
fact is order
problem the problem
find the element
element could sit
median the element
depends the rank
supposing that rank
picture and sort
sort of explain
element x sits
procedure to find
pay careful attention
sort of important
important design principle
principle we started
find the recursive
encountered a problem
general problem finding
median a special
easier to solve
finding the element
write this problem
input is array
solve the reason
reason this problem
problem we end
find an array
array a supposing
median i split
greater than size
find a approximate
rank till linear
find the approximate
difficult as finding
present the solution
recipe for finding
algorithm that works
array a split
split the elements
elements into groups
elements approximate median
output exact median
group you find
number of questions
question second question
median we ended
median to find
initially we started
exact of median
size has reduced
smaller size remember
recurse and find
done to find
solve an exact
exact median problem
input of smaller
done by recursion
group in descending
increasing order upwards
upwards or decreasing
array is divisible
explain this picture
middle elements sort
sort them middle
lay them out
out and lay
out the entire
taking that part
arrange the elements
approximate median median
means this entire
entire portion consists
consists of elements
portion again consists
consists of larger
elements this portion
consists of smaller
4th in fact
array this portion
array are smaller
elements are larger
median and recurse
sort of vague
needed to design
algorithm to find
find a median
steps together stare
giving you code
call this find
finds an element
groups of size
group and put
return an element
left with cases
cases the first
rank r sits
sits in array
recurse on array
case is size
quickly draw picture
picture to find
find this out
distance is size
element the rank
ends the description
array a partition
medians this returns
returns an element
partition with respect
parts that depends
rank of element
rank r minus
analyze this procedure
procedure should run
run in linear
runs in linear
procedure actually works
works in linear
designed an algorithm
step and figure
times each step
step is executed
executed the step
written an algorithm
program to analyze
loop are executed
estimate the size
initially the input
totally the total
steps each takes
easily done find
sort of comparisons
group takes constant
takes constant times
spend some constant
find i recurse
problem of size
partition this array
implies that size
recurse the size
size the maximum
size an array
recursion to find
recursion we recurse
sort of share
find a right
utmost c minus
imply the previous
prove by induction
recurrence is utmost
sum is utmost
induction in fact
initially we guessed
utmost c times
induction and prove
follow your nose
helps you finish
finish the inductive
solving recurrence relations
guess the answer
out what constants
thing by induction
algorithm with quick
pick the pivot
iii surfing lower
surfing lower bounds
algorithms merge sort
algorithms n log
sort of restrict
kinds of things
things that algorithms
sort for merge
sort these things
merge two sorted
two sorted sub
sorted sub arrays
two sorted lists
move them out
move your pointers
comparing two elements
array is comparing
elements and moving
moving them out
property actually holds
quick sort term
compare every element
move these elements
array is compare
compare these two
sort of operation
operation is compared
change the order
popular sorting algorithms
log n comparisons
comparisons to sort
sort an array
minimum you needed
needed n minus
bit of work
written as flowcharts
block is comparison
build the large
large flow chart
two other elements
output the sorted
order i output
small flow chart
sorts two elements
elements an array
works on arrays
sorts these arrays
sort of fill
array in sorted
sort of run
run merge sort
branch we choose
sort of outputs
merge the lower
lower things return
two sorted orders
level of recursion
first one returns
two elements compared
lists are compared
compared for merge
draw this tree
output in fact
out into two
two elements branch
tree in fact
sort of follow
follow this tree
answer this leaf
merge sort tree
tree for merge
fix the number
order as merge
follow the tree
order of comparisons
made in merge
hit a leaf
input you make
left or right
comparisons branch etcetera
finally you hit
leaf the number
tree the worst
longest root leaf
root leaf path
ingredients in place
make certain observations
two critical observations
algorithm which sorts
sorts n numbers
node you compare
greater at leaves
leaves we output
thing the question
sort of crucial
chart does sort
order must leads
leaf different input
input orders lead
assume that inputs
input every element
order you make
make certain comparisons
trace the path
give the right
interchange the last
last two elements
elements this order
leaf i land
orders must land
tree with large
number of leaves
finish the proof
tree of height
done in discrete
leaves the number
sort of prove
give a proof
statement is true
trees of height
two sub trees
remove the root
apply the inductive
basically the number
leaves t equals
finishes the inductive
log the number
height this means
flowcharts for sorting
sorting we looked
omega n log
proved some constant
shows that merge
similarly quick sort
instance or move
algorithm for sorting
bucket sort radix
sort radix sort
sort is merge
array only thing
element is compare
compare this element
sort of divide
significant bit etcetera
sorting is concerned
discussion of algorithm
conquer paradigm sort
sort of works
tiling essentially means
number of squares
put these dominos
square is covered
square with side
case four parts
left well supposing
put my fourth
supposing the fourth
managed to sort
sort of tile
provided this square
tile the entire
region on top
leaving one squares
squares that square
sort of region
sort of domino
notice a crucial
carry this inductive
tile a region
left over square
left un tiled
tiled the entire
out my initial
apply this divide
kind of thing
tile these smaller
squares and put
tiled one piece
push the induction
induction to work
leave this square
square un tiled
entire big square
recursively and put
put one domino
domino one domino
sort of strategy
strategy to tile
algorithms or puzzles
sort of lesson
solutions to smaller
smaller sub problems
slightly more general
solve the general
technique the smaller
median we wanted
finding an element
found the element
problem of multiplying
find the product
formed the product
bits with lsb
multiply these digits
high school multiplication
school multiplication algorithm
left y right
compute the product
sort of find
find these products
order n operation
shifting and adding
two n bit
back to spending
number of multiplications
separately that gave
gave over problems
problems of size
two i compute
thing i compute
additions the number
recurrence is smaller
smaller in fact
show the solution
roughly it grows
multiplications one makes
guess the general
ease of computation
roughly some constant
writing the exact
times constant times
two things cancel
divided by log
increase the number
number of additions
expensive than additions
beauty of algorithm
sort of tackled
problems which require
design new methods
derive new methods
find new methods
rack your brain
brain and sort
multiplication is due
due to euler
multiplying complex numbers
applicable in multiplying
numbers thanks design
study of algorithm
looked at sorting
sorting the strategy
applied to sorting
sorting to give
give a lower
sorting based algorithm
algorithm we continue
meanable to divide
conquer this problem
basic is bit
algorithm design strategies
design strategies applied
input the set
set of points
pair of points
compute the distance
find the closest
find a pair
points the distance
distance is square
notion of distance
plane of points
pairs of points
pick the minimum
witness this minimum
pair a distance
pair you compute
choose to distances
takes n choosable
compute all distances
distances to find
discussing this problem
compute all pairs
bit you start
compute every pair
pair of distance
ways of thinking
remove one point
point to compute
compute a distance
adding this point
approach finally follow
reason i wanted
sort of inductive
problem is remove
remove a point
point the recurs
put the point
huge big star
find the smallest
compute n minus
lead to order
delta the minimum
recursively is delta
circle of radius
point only points
compute these points
times to extra
choose to sort
sort of distances
problem some property
sort of pushes
identify these candidates
check two distances
left to right
compute these distances
distances and choose
choose the minimum
minimum by scanning
scanning these points
sorting takes order
log n sorting
dominates this procedure
pays to first
log n question
question one asks
out the answer
proceed this fact
trick that speed
divide the point
two parts find
minimums to compute
sorted in founded
founded the minimum
divide the points
right and recurs
distance between points
left and point
right i find
left the first
find this distance
distance and check
find this minimum
check the minimum
return the minimum
find this point
find minimum distances
find the last
right most point
left most point
sort of put
splitting the input
median and divide
divided and conquered
form one set
set the right
points will form
recursively find minimum
find minimum distance
points are points
line this blob
find closest pair
closest pair points
delta r minimum
delta be minimum
minimum of delta
candidates or closest
right any candidate
recurrence in place
amount of work
pick every point
right and sort
find the distances
compute n square
usual n square
pairs of distances
bit of luck
intelligence and perseverance
small examples etcetera
pump you full
full of ideas
find reasonably simple
teacher to teach
problem the first
dividing vertical line
vertical line things
draw a straight
right is greater
greater than delta
distance is greater
points of interest
bands as bridge
problem could apply
left could lie
right could lie
back to computing
computing n square
roughly n square
thing the intuition
magnify this small
draw a circle
inside this circle
circle the reason
closer than delta
delta these points
number of points
sort of spread
draw this line
point will lie
square please strain
strain your imagination
imagination and imagine
point must lie
delta in fact
line is greater
precludes many points
points from appearing
appearing in region
region of size
intuitively one feels
inside each square
delta by delta
intuitively you feel
inside the square
square the reason
put this intuition
intuition into practice
practice often requires
requires some thought
thought the principle
pigeon hole principle
stuff these pigeons
pigeons and holes
pigeons into holes
pigeons very simple
understand the statement
difficult to figure
apply really nice
people have figured
square of size
put in inside
inside this square
maximum distance inside
inside the small
square as side
side length delta
root of delta
delta by square
distance is delta
two points sitting
points sitting inside
inside this small
point can sit
inside this big
points and compute
compute at max
ideas in place
implementation smaller implementation
smaller implementation details
points the left
size to delta
point this window
scan them upwards
scan from bottom
scan this points
points from bottom
bottom to top
scan the left
side from bottom
maintain this window
increasing y coordinates
maintain this band
sort of window
move them window
move this window
move the window
takes is linear
merge sort idea
idea the window
side the window
window could move
window can move
times the pointer
pointer here moves
moves or pointer
fixed a window
four on top
four on bottom
out one thing
sort these points
takes n logging
sorting will dominate
log n square
positive in fact
sort the points
cost i sort
make a recursive
order in place
analyze the algorithm
input a set
points first step
make an assumption
point has distinct
distinct every point
distinct x coordinate
distinct y coordinate
add a small
point it sort
sort of move
small the minimum
distance to change
change the points
line two points
algorithm i give
modify this algorithm
algorithm to work
arrays the first
array where points
points are sorted
actual procedure starts
input is points
co-ordinates points sorted
call this step
initialization phase step
halves and step
points and find
find the left
points this sort
sort this give
two arrays remember
out the recurrence
summarize and write
step is initialization
set of input
points we form
form two lists
arrays one array
store the points
points in increasing
array will store
procedure this initialization
initialization is done
start the algorithm
step will pass
median and points
arrays which sorted
business is easy
half the element
divides the input
input is divided
sorted in increasing
increasing x coordinates
shortest the distance
shortest the closest
pair on input
compute the minimum
band of size
left one point
putting the answers
thing for right
prime is sorted
coordinates our focus
points from increasing
prime these arrays
points and increasing
maintain three pointers
half the diagonal
supposing this point
prime y coordinates
range y prime
find these points
prime y prime
times the size
size of number
step is supposing
find the points
moves one step
step is move
move r appropriately
similarly you move
compute the distances
prime r small
found these distances
step is compute
min of delta
ends the algorithm
initial so analysis
initially is order
two recursive calls
number of distances
satisfies this recurrence
ends our discussion
discussion on divide
interestingly called greedy
algorithm or greedy
bit the main
main technique main
technique main sort
sort of technique
optimum solution small
solution small piece
piece by small
piece by piece
construct the optimum
first then sort
sort of enlarging
difficult to listen
output the optimum
clear cut guiding
cut guiding rules
sort of imagination
imagination and intuition
intuition hard work
ideas that build
build in solutions
sort of basic
idea the basic
step is construct
solution or output
constructed some part
optimum solution extend
crucial generic step
put the generic
amount of luck
sort of sort
point this local
local improvement trick
future i encourage
theory of matroids
linear programming duality
primary dual method
method in linear
sort of method
important algorithm design
hand wavy fashion
solution some generic
output which satisfies
respect or minimum
improve the solution
solution by adding
adding or subtracting
adding one element
subtracting one element
question will sort
sort of dictate
proceeds this question
sort have trigger
trigger our algorithms
sort of push
push the algorithms
theory behind greedy
business and solve
problems the first
define a term
set and independent
pair of vertices
complicated a graph
independent for instance
instance each vertex
collection of vertices
mobile radio stations
set can transmit
suppose i draw
roughly the motivation
motivation where independent
find an independent
independent set large
set large size
problem in fact
set of maximum
traced this problem
restrict the graphs
problem in totality
input the tree
connected and acyclic
acyclic the output
maximum sized independent
sized independent set
find maximum sized
sort of group
sort of compute
subset or vertex
independent and choose
number of subsets
pick a vertex
pick this pick
graph again pick
pick any vertex
vertex that remains
size is maximum
pick the wrong
pick this vertex
set of size
pick the right
greedy solution greedy
set is large
vertex of smallest
number of neighbors
throw up remember
out its neighbors
neighbors i throw
pick a leaf
out one vertex
vertex per leaf
case this algorithm
proof to show
produces maximum size
maximum size independent
size independent set
set the algorithm
out its neighbor
neighbor and continue
vertex of degree
proceeds just put
independent set blindly
algorithm proceeds pick
pick any leaf
leaf and put
set and continue
continue this algorithm
described actually works
start you piece
piece you put
solution together piece
piece you pick
pick a piece
sort of proceed
sort of property
build the solution
sort of throw
case we sort
pick the vertex
vertex a minimum
degree it works
examples where simple
bit more general
sort of exchange
trick i promised
tree ; tree
tree in question
pick a maximum
maximum independent set
process going supposing
sort of add
add and subtract
solution to increase
number of vertices
increase the size
leaves the sense
two and remove
question will leaves
leaves always fall
optimum independent set
put the leaf
set and put
change the set
set still remains
picked one element
put a element
proof all leaves
putting all leaves
remove their neighbors
thing with greedy
pick a part
input to deal
algorithm you move
problem we move
independent set remove
neighbors the tree
administering a system
lot of people
intervals could vary
give you sort
sort of intervals
intervals each person
spread his job
give you intervals
occupy this machine
intervals they wanted
pick these intervals
intervals some intervals
intervals essentially schedule
essentially schedule people
thing is maximum
number of people
slot your objective
objective final objective
objective is maximum
amount of money
give you etcetera
sort of origin
set of intervals
subset of non
non overlapping intervals
intervals of maximum
output a subset
intervals with maximum
overlap all kind
kind of funny
pick a subset
subset of overlapping
size our maximum
subset of maximum
subset which means
number of intervals
maximum for instance
goal our goal
numbers just numbers
technique says builds
builds a solution
build the optimum
optimum solution interval
interval by interval
first which interval
thing that sort
sort of strikes
intervals in small
span is small
pick a large
call this algorithm
pick intervals interval
interval of smallest
smallest size smallest
size smallest span
suppose the interval
pick the smallest
interval with smallest
intuition is faulty
easy to construct
intervals that intersect
algorithm says pick
form the input
input the algorithm
fellows clearly optimum
consists of picking
intervals the optimum
optimum has value
picking the interval
length not fails
thinking a bit
interval is small
small it overlaps
big they overlap
interval that overlaps
overlaps with smallest
pick the interval
overlaps the smallest
first algorithm fails
fails you construct
pick an interval
interval which overlaps
overlaps the smaller
pick this interval
interval i throw
intervals i pick
interval every interval
pick vertex throw
extremely closely related
related in fact
form a graph
problem is picking
picking an independent
vertex with smallest
interval with minimum
minimum overlap minimum
overlap minimum number
neighbors and recurse
problem this worked
bit more complicated
work for work
apply more intervals
intervals and interval
overlaps this interval
sort of mirror
image this side
overlap the smallest
overlap with smallest
overlap in fact
left with imagine
side these intervals
pair wise overlap
solution i construct
paper a bit
bit more carefully
hand optimum value
work the algorithm
kind of problem
examples become harder
harder and harder
kind of complicated
complicated counter examples
add an interval
supposing these spaces
spaces are filled
add and remove
supposing i add
adding this makes
makes no sense
exchange that sort
requires a bit
bit of thought
interval that ends
interval and ending
add the interval
first and remove
remove the first
increasing the size
first you give
ends first remove
remove the intervals
intervals that overlap
sort the algorithm
algorithm the intervals
intervals by ending
procedure you sort
sort the intervals
times and pick
pick the first
interval the interval
continue the iteration
trick that makes
makes exchange trick
makes it work
thing to prove
show the interval
back to previous
previous figure supposing
interval that first
add this remove
set by induction
induction the algorithm
algorithm will find
find the optimum
overlap the interval
first the size
added this interval
interval to remove
dropped the optimum
size the algorithm
discussing greedy strategies
strategies for algorithm
design the main
short of revise
revise the main
reviewed main point
construct the solution
things are important
answer this question
thing we solve
two obvious strategies
strategy of picking
picking and interval
interval which overlapped
field the strategy
strategy that worked
worked before last
first the interval
first to pick
intervals at overlap
set of moral
story was obvious
normal human beings
proof of correctness
correctness is important
giving in obvious
ways of writing
writing a proof
constructing the solutions
piece you find
find the first
works by induction
strategy by induction
works and added
bit more detail
write the proof
derive a proof
proof by exchange
review the algorithm
intervals that remain
ends first discard
first discard intervals
empty set start
intervals to deal
disworks the proof
written the bit
algorithm picked intervals
times or finishing
sorted by finishing
sorted by starting
intervals are disjoint
sorting by finishing
times and starting
picks these intervals
picks an interval
set the rest
optimum solution suppose
pick the optimum
number of initial
intervals in common
write this term
prove this claim
claim by contradiction
means ; suppose
suppose the statement
statement is false
pick an optimum
optimum solutions pick
optimum in fact
equal to ending
optimum and remove
pick and interval
reason the ending
smaller than equal
write the term
proof by contradiction
proof by induction
problems the idea
kinds of algorithms
algorithms are problems
problems and algorithms
follow your notes
slightly more non-trivial
feel of behinds
behinds the things
partition this set
number of parts
input is similar
intervals each interval
schedule to users
schedule to intervals
minimize the number
number of machines
interval each user
non-overlapping or disjoint
intervals into minimum
discussing greedy techniques
techniques i guess
partitioning these intervals
processor that person
looked at intervals
intervals on based
based on ending
times for interval
interval at end
looked at first
set of greedy
putting these intervals
processors this order
order these processors
sort of greedy
greedy back drop
intervals by finishing
sort by starting
intervals by starting
order these groups
top on set
increasing starting times
first ; put
group or part
part l minus
algorithms does work
run the algorithms
set of inputs
part 2nd interval
sort of scan
scan your objective
minimizing the number
parts to supposing
supposing the number
produced k parts
algorithm will produce
suppose the algorithm
partitioned a set
sort of trick
sort of mention
mention in text
trial small values
two overlapping intervals
part this interval
interval was put
interval that overlapped
optimally as usual
thing and optimum
remember we started
happen this 2nd
intervals are looked
tune your algorithm
order and put
intervals in increasing
order of starting
rank to prove
refining your algorithm
refine this algorithm
set into minimum
sort in intervals
order of sort
sort in staring
algorithm is optimum
supposing the algorithm
produce k parts
part the first
first k minus
part 2nd part
means this interval
hiding that last
produces an optimum
order of ending
increasing order sorting
order sorting times
intervals in decreasing
work same proof
thing is similar
similar i guess
intervals from left
right to left
things that work
strategy in greedy
set of paradigms
2nd is ordering
3rd was storing
reusing in greedy
two things induction
induction and ordering
lead the crucial
couple of problem
trick usually works
set of elements
elements as input
subset as output
subset to satisfy
satisfy some property
property as output
output the first
first two problems
set of vertex
set as output
maximum in size
property this 2nd
subset with maximum
wanted to partition
means and intervals
roughly this frame
candidate these things
design the algorithms
giving you algorithm
algorithm as search
telling you tips
candidate algorithm solution
design these algorithm
first two cases
put this leaf
solution may improve
put the interval
interval that ended
solution and remove
fairly the simple
set of jobs
jobs the input
input is set
jobs with processing
preemption in fact
stop a job
processor the processor
runs to completion
finishing times schedule
minimize the sum
schedule the schedule
order you put
put these jobs
supposing i put
processor the finishing
jobs by increasing
sort of pushing
greedy perspective design
algorithms ? iii
fractional knapsack problem
wanted to start
start in algorithms
enter the house
hit the jackpot
sense that houses
houses all kinds
kinds of stuff
sack has limited
cost of profit
profit and size
amount of item
sack your objective
fill this sack
sack with items
profit is maximized
items to put
put take fractions
fraction in knapsack
bugling an ordinary
bugling cake shops
kinds of cakes
fancy cakes tune
cake and select
cake and eat
sell this cakes
sort of choose
bag and make
define this problem
knapsack of capacity
size and knapsack
maximize the profit
profit and sizes
unit of item
solve the input
maximize this profit
real muff greedy
muff greedy algorithms
greedy and pick
pick these items
means pick items
items to pick
kinds of orderings
items in decreasing
profit and pick
profit by size
size or profit
squared by size
set of approaching
possibilities work remember
kind of order
sort of key
works of fails
defined exchange trick
act to design
put one item
exchange one item
design the algorithm
kind of trick
portion of item
out some amount
out with solution
solution in mind
bag is full
filling in arbitrarily
arbitrarily some items
bag still remains
sort of calculation
item t picked
assume that sigma
item or high
high an increase
increase some amount
replaced some portion
maintain the bag
epsilon prime epsilon
prime epsilon prime
epsilon prime minus
times epsilon equal
initially i started
bag being full
epsilon prime equals
guide that epsilon
prime and epsilon
times epsilon prime
fellow is greater
prime is greater
greater than epsilon
epsilon by epsilon
epsilon which means
put this bag
put this equality
increase in profit
favor i remember
remember this happen
part of item
algorithms will give
device an algorithms
divided by size
algorithm is simple
algorithm says order
order and pick
fill the knapsack
pick the item
picked these items
pick the entire
pick a fraction
first few items
pick k items
entire item unit
item with maximum
items by decreasing
output is output
output looks likes
works this algorithm
optimum and shows
set of review
review that material
order of scores
first index exit
exit ith index
index they differ
picked one unit
profit goes out
delta total sum
increase this delta
increase the profit
epsilon and epsilon
epsilon prime properly
epsilon the epsilon
items to fill
fill enough type
contradiction and calculate
calculate the profit
sort of frame
write it properly
modify the proof
sort of chose
respect that part
sort of film
finishes the proof
algorithm to fill
fill up knapsack
out this exchange
exchange two things
happened and profit
face the problem
problem this kind
exchange trick run
area of information
related to codes
sends these symbols
send this codes
sort of decoded
sort of string
left another right
sort of full
strings as scored
out the frequencies
frequencies that make
symbols for frequencies
times the 2nd
stands to resend
sends many times
send this smaller
decoding is easy
easy the reason
supposing the first
symbols from left
arrive the bits
arrive and decode
easy this code
suddenly not prefix
prefix pre codes
prefix pre code
easy to decode
write the word
construct prefix pre
minimize the average
message with send
length frequency times
frequency times length
connection to binary
things are code
words at leaves
code word left
word left branch
reach a leaf
traverse a binary
assign a code
tree with symbols
symbols at leaves
root to leaf
binary string associate
construct the binary
follow your follow
hit a pattern
set of paper
paper and write
write this entire
entire problem properly
input is frequencies
desire prefix free
prefix free codes
word a binary
things with large
height of symbol
input of frequencies
output a binary
frequency of symbol
assign these words
minimize this function
frequency as close
order of height
height saying increasing
order of frequencies
easy the heaviest
frequency must set
tree the question
number of binaries
threes we pick
pick a tree
sort of fit
fit these symbols
pick these trees
kind of exchange
construct the correct
bottom most points
frequencies will sit
compute the tree
part by part
remember the tree
exchange sub trees
pick two sub
trees and exchange
problem from information
recall the problem
frequency of occurrence
occurrence we wanted
wanted to construct
construct the code
set of symbols
symbol we read
read the binary
problem to solve
give a shorter
word are repeated
encode this file
means no codeword
file and send
file once encoded
encoded the size
word the frequency
put that put
set of frequencies
prefix free code
word for symbol
times the word
encode the file
code of prefix
free code corresponds
tree and symbols
construct the prefix
traverse a path
path from root
leaf this code
leaf by traversing
two a leaf
symbols will sit
sit on leafs
output prefix free
binary trees fixed
associate these words
two with smallest
sit at leafs
sort of balance
bottom most leafs
two the frequencies
quantity of minimizing
minimizing is sigma
put smaller frequency
smaller in frequency
larger in frequency
stands to reason
larger the frequency
sitting here call
exchange some part
twist the solutions
suppose your exchange
exchange to sub
times the frequency
root two node
length of path
compute this function
times the length
part from root
inside this sub
cost old cost
cost of elements
sigma c belongs
times h prime
sigma e belongs
cost this length
inside the tree
inside the sub
sub tree remains
tree remains fixed
add h prime
difference in cost
compute old minus
primes c cancels
subtract h minus
minus h prime
minus h times
assume is greater
done a shift
quantity is positive
quantity is negative
cost as decreased
cost as increased
cost is greater
decreased the cost
shape this fellow
greater and sigma
leads to smaller
frequencies of elements
smaller cost remember
tree is greater
exchange trick tells
tree the quantity
follow greedy approach
build this sub
initially each element
sub trees bottom
join the last
previous exchange thing
node and join
treat each element
element is treated
treated as sub
elements in side
sum of frequencies
symbols or words
two of minimum
minimum f prime
prime and join
tree for instance
number of tree
algorithm terminates ease
number of sub
sub trees decreases
write a proof
done to write
constructs as sub
algorithm for instance
algorithm had sub
prove this statement
write this proof
induction on stages
tree the base
out with trees
two you join
voice are true
branches of line
lowest sub trees
trees i clean
lowest sub tree
sub tree exchange
cost actually decreased
means the height
bottom to nodes
exchange whatever sits
merge to trees
weights of tree
tree by merging
algorithm and networks
done by huffman
summarize our discussion
discussion of greedy
piece two imagine
pulling out pieces
pieces to fit
put the right
piece and place
trick essentially start
solution and change
solution to obtain
solution a bit
theory of methorids
methorids and linear
books and linear
two may give
sort of feeling
feeling for greedy
strategies work good
work good luck
good luck design
problem called pattern
text and pattern
output is find
find an occurrence
find all occurrences
find and occurrence
intake of file
string as input
sort of facility
design and algorithm
character in check
occurrence of pattern
occur that position
scan the text
character by character
pattern i start
start matching character
shift the pattern
onwards i check
equals the first
character the pattern
shift this pattern
sort of shift
sort of pattern
character to character
found the pattern
output this index
pattern in text
sort of return
algorithm is putted
move the pattern
text we search
check for starting
make m comparisons
discover a mismatch
supposing my pattern
real exact value
pattern you sorted
algorithm have done
shifted this pattern
pattern is match
find the pattern
pattern this pattern
sort of shifted
position i move
pattern this algorithm
text in pattern
text as match
match the pattern
pattern must start
move the text
text of tool
supposing we follow
follow this algorithm
mismatch i move
text i claimed
positional the text
text i make
make anymore comparisons
match i shift
text i start
sort of comparing
starting the pattern
string of size
start the pattern
pattern to move
move the string
shifting the pattern
algorithm i shifted
started my comparisons
moving the pattern
text pointer remains
case is clear
hope the algorithm
positions i move
move this point
times is compared
text pointer moves
pointer moves forward
match text pointer
position with text
mismatch will occur
text moves forward
pattern is moved
mismatch text pointer
compare this character
pattern has moved
case the text
comparisons per text
faster for instance
information this information
portion the text
means the information
string actually match
match this portion
two line highways
pattern in fact
writing this text
pattern will miss
point and moving
portion with text
forget the text
point and shifting
pattern in general
miss and occurrence
portion must match
portion this portion
match the suffix
pattern this prefix
prefix must match
match this suffix
larger prefix matching
miss that opportunity
prefix this prefix
move it forward
matches the suffix
supposing the optimum
mismatch if shift
out the shift
minus t minus
means this prefix
missing and occurrence
supposing the mismatch
largest such string
pre-compute this value
find the largest
suffix i hope
string a prefix
initial the first
first i portion
largest proper prefix
make it proper
mention the longest
longest proper prefix
pattern of computer
mismatch at position
put the term
prefix which means
mismatches the text
right this code
pointer to text
initially my initialization
initially i set
remember my point
point next character
text and comparing
comparing the pattern
match pattern mismatches
move both pointers
pointers i move
increment the text
algorithm for searching
write the main
shifted the pattern
check for success
times these statement
statement are executed
number of successful
number of matches
matches plus number
number of mismatches
back and check
check out merge
out merge sort
comparison it increases
case x drops
case y increases
function y minus
match y minus
minus x remains
mismatch i shift
number of unsuccessful
shows that true
discussing pattern matching
lecture the problem
pattern and text
matching the pattern
pattern the worst
case was algorithm
algorithm the proof
comparing this position
find a mismatch
push the pattern
pattern the maximum
out and occurrence
text we find
search which means
means a minimum
mismatch that occurred
algorithm was clear
text the pattern
pattern which means
means your pattern
text also shift
pattern why remains
find a prefix
moves the pattern
loop the question
dictate the order
write as number
comparisons in number
close we notice
match y moves
text never moves
shift the text
text pointer remain
times a pattern
case in fact
increase why increase
case x decreases
follow initially starts
comparisons is order
wanted to show
matching in linear
computing this function
largest prefix largest
largest or longest
longest maybe longest
find the longest
means the longest
place this length
pattern a minimum
stop the first
find the match
minus j comparisons
sigma i minus
suddenly not linear
put over algorithm
algorithm design sort
design sort principles
problem on arrays
favorite inductive kind
kind of approach
approach and assuming
assuming which means
first i minus
means sometime thing
added some point
thinks just start
start to click
algorithm this matches
matches this portion
character also matches
big portion matches
portion which means
start by shifting
computed by induction
calculated l values
first shift day
shift day shift
comparing these two
match or found
patterns must match
pattern this index
pattern must match
timing this portion
put the middle
back this portion
middle part match
omit the top
initially this length
values to shifted
find the mismatch
sounds bit complicated
values of previous
previous l values
match which case
write this algorithm
note down separate
space if pattern
pointers move forward
recall this portion
first we shifted
first character match
match which means
loop this thing
match and unsuccessful
times you execute
out this entry
entry you filled
decremented which means
made will small
wrote this minus
correct the reason
written as subscripts
describe this algorithm
values and array
shift by minimum
means this length
compare start comparing
comparing the first
scanning the entire
pattern the total
compute this length
scan any text
algorithm is due
practice an algorithm
efficient and algorithm
efficient in practice
practice is due
due to boyer
boyer and moore
text the difference
difference between boyer
moore is track
boyer moore starts
moore starts comparing
upwards and boyer
windup this thing
looked at write
pattern matching algorithm
matching algorithm works
strings first string
case ? suppose
prefix proper prefix
two proper prefix
meet the algorithm
position i shift
times the string
back and compare
done this earlier
sort of match
shift that portion
examples of text
strings take examples
examples of pattern
pattern and takes
shifting a pattern
run this algorithm
search and optimization
today is combinatorial
optimization the general
find an object
set of numbers
discrete objects object
set of number
set of integers
object must satisfy
find us find
first it satisfies
satisfying those constraints
space of objects
objects to real
cost so option
object of maximum
maximum benefit find
benefit find object
addition to satisfying
numbers given note
distinct for simulations
set benefit equal
equal to negative
maximizing the benefit
minimizing the cost
usual chess board
queens on usual
row same column
diagonal we remainder
modulate as problem
problem on numbers
numbers an integer
queen in column
row in column
row number value
position the queen
giving the row
easily taken care
simply the distance
rows the vertical
distance the distance
finding a sequence
sequence of numbers
toy or game
exist such numbers
satisfy these conditions
tuples of number
value in rupees
object so implicit
addition each object
kilos in kilo
object and imagine
capacity by weight
weight the problem
exceed the capacity
picking up objects
objects of maximum
find a subset
value of objects
objects the total
value of selected
capacity while total
context of objects
objects and values
values and weights
decide which job
job to select
objects or crops
call these objects
function the objective
objects of large
travelling sales person
sales person problem
problem the input
graph that visits
visits every vertex
minimize the weight
tour the names
graph as representing
representing a map
world vertices represent
vertices represent towns
towns and edges
edges represents roads
roads and weight
represent the length
visit every city
selling his products
find the tour
tour that visits
visits every city
total distance covered
relating to sales
persons and cities
cities and roads
arises in robotics
arises in computation
computation of biology
fields before carrying
problem makes sense
man could tour
case the pointers
found the tour
minimum such cost
minimum such length
state the topic
today the idea
start a study
study of strategies
strategies for solving
solving combinatorial optimization
combinatorial optimization problems
optimization problems combinatorial
problems combinatorial optimization
optimization and search
drop the search
brute force search
force search strategy
strategy called branch
branch and bound
strategy called dynamic
requires as considerable
diff level analysis
strategy the backtrack
backtrack search strategy
bit more efficient
efficient than backtrack
backtrack search problem
search problem search
problem search strategies
search strategies dynamic
strategies dynamic programming
efficient than branch
lot more analytical
exploit the problem
case the dynamic
dynamic programming ideas
force search strategies
fairly simple minded
minded to make
correct we correctly
numerate or generate
satisfy the constraints
fact the constraints
constraints are satisfied
evaluate the cost
cost or benefit
function we evaluate
evaluate the benefit
function and check
check this benefit
benefit function found
benefit function founds
record this benefit
current object record
object record cost
satisfies the conditions
conditions this procedure
work this procedure
guaranteed to give
collection of parts
collection of slots
generating each part
filling each slot
initially the sort
slots are empty
make this idea
idea very clear
sense this page
page is small
smaller parts comprising
comprising our big
fill in values
interpret these numbers
draw the board
board that corresponds
filling the first
drawing the entire
four possible positions
four possible candidate
partially built object
built object candidate
object candidate object
four partially built
partially built candidate
built candidate objects
full arrange substance
ways of placing
queen the first
level of construction
construction higher level
higher level completion
internal at higher
level of completion
represents the ways
placing the fourth
square partially constructed
partially constructed objects
cube partially constructed
exhaustive generation method
extension will correspond
correspond to children
node their extensions
extensions will correspond
correspond to object
terminate our generation
queen position satisfy
satisfy our conditions
leaf the leaf
leaf objects satisfy
suppose in fact
find a leaf
represent our objects
four queens problem
four element array
array to represent
four queen positions
positions in case
travelling salesman problem
travelling salesperson problem
represent the tour
array of length
meaning that object
object is replaced
procedure for filling
sub sequential loss
prevalent to starting
recurse we filled
leaves so viral
procedure that checks
constraints are met
procedure for evaluating
back track search
procedure for removing
removing the last
last value filled
tree and make
procedure just give
return on object
evaluate the objective
function if constraints
return a minus
benefit function assuming
benefit is positive
object has unfiled
object has unfilled
ways of filling
filling slots filling
filling next slot
recurse on modified
recursion will give
give as value
node a cost
smallest cost function
cost function found
eventually will make
cost gets written
return in smallest
smallest v sub
sub i calculated
ways of doing
waste of generating
return this cost
return the cost
ways of filing
leaf the value
complete at description
procedure in fact
data structures scores
depth first search
search space search
space search space
set of leafs
putting a tree
tree on top
doing a depth
condition with checks
checks our constraints
queens problem suppose
queens already capture
check where condition
condition where queens
ignore this part
search tree immediately
checking the condition
valid no matter
change their position
possibility of early
early conditional checks
conditional checks condition
checks condition checks
checks can improve
give a quick
designates this vertex
back to vertex
tour is cyclic
cyclic but suppose
sort of closing
tour has proceeded
queens problem specialized
problem specialized generalized
power n leaves
implement the early
checks will improve
improve the situation
situation some part
simple very simple
simple early checks
omega n factorial
cities well starting
city the first
factorial different leaves
first the vertex
level n minus
generate this class
class of objects
typically it takes
takes time exp1ntial
defined terms likes
terms likes search
likes search space
space and tree
tree that set
end this lecture
lecture by mentioning
combinatorial optimization combinatorial
optimization combinatorial explosion
explosion this term
connection the back
search the idea
level the tree
number of children
level the number
children the grand
root will grow
enzymes your tree
tree will explore
commonly called combinatorial
improvements to backtrack
search as mention
study a technique
technique called branch
programming and greedy
important to view
simplest backtrack search
backtrack search ideas
ideas are present
strategies are present
general and applicable
combinatorial optimization problem
optimization problem design
design & analysis
start by summarizing
fairly general technique
technique called backtrack
problem or combinatorial
combinatorial search problem
out all possibilities
possibilities the problem
technique typically takes
improve upon backtrack
variation called branch
ideas called dynamic
solve combinatorial optimization
deal with dynamic
length and today
focus on branch
efficient that remains
remains the main
start by reviewing
reviewing what backtrack
expected to find
find the combinatorial
satisfy certain constraints
object x star
star must satisfy
minimize the cost
set of possibilities
consisting of slots
filled the first
partially constructed object
slot will give
constructed objects based
choose to fill
fill that slot
fully constructed object
complete object constructed
constraints are satisfy
pick the object
minimum cost object
tree is explored
depth first manner
fill the first
check the constraints
minimum cost leaf
cost leaf extra
organization of backtrack
drawn the tree
tree in parallel
drawn the entire
program would execute
execute this procedure
entire search tree
back that path
explore the entire
numbers of nodes
leaves is enormous
lot of work
prune the search
reduce our work
heuristic of pruning
found certain solution
evaluated its cost
suppose this cost
completely defined object
cost of partial
object x bar
construct our object
associate a cost
suppose this extended
extended cost function
bar is obtained
obtained by extending
bar is greater
equal to cost
cost of xij
suppose the cost
cost function satisfy
building that object
branch and boundary
implies that branch
found some solution
exploring this tree
avail you evaluate
interesting has happen
complete this object
extend this object
point in searching
idea of branch
explain how branch
edges and vertices
ridiculously small problem
explaining our ideas
find a tour
simply a sequence
sequence of vertices
search should work
extend the tour
object which represents
represents a tour
extend it edge
edge by edge
explore little bit
earlier the algorithm
algorithm will make
make a choice
edge going back
possibility in fact
back to town
straight in fact
explore this part
point onwards backtrack
onwards backtrack search
search the rest
bound would make
lengths are positive
lengths are non-negative
work of exploring
proved in fact
taking the first
edge again branch
bound will evaluate
partial tour is10
edge has cost
explore anything underneath
extending this tour
tour of cost
case in backtrack
explored everything underneath
comparison of backtrack
backtrack and branch
bound needs suitable
suitable cost function
defining this cost
tree are visited
overhead of evaluating
node in general
reasonable cost function
function will work
find a reasonable
head of maintaining
function is concerned
problem we introduce
introduce this problem
represents the value
represents the width
back of capacity
object our goal
overflow our bag
implement the branch
search will work
natural objective function
expressed as maximize
maximize total value
pick up objects
backtrack search work
define the nation
develop this idea
step by step
empty candidate object
selection of objects
essentially a subset
first decision point
make a firm
reject the first
write this separate
initially our search
characterized by writing
selected no object
set of object
made a decision
decisions about objects
reject an object
make the decision
pick that object
picked any object
set of objects
make a decision
remember the back
track search involves
include the first
building this set
first just make
ways of taking
evaluate our benefit
completely generated subset
order to apply
apply a branch
proper cost function
slightly different rule
definition of branch
vary about cost
express the knapsack
function is maximize
natural cost function
minimizing the value
value of rejected
objects i claim
two are identical
value is fixed
select large value
rejecting the small
key to applying
terms of maximizing
maximizing the value
terms of minimizing
minimizing the values
values of rejected
objects in fact
idea completely clear
consists of value
object has value
capacity is equal
make in fact
change my idea
idea little bit
left going paths
taking those objects
make the check
decide to check
first two objects
objects then taking
object would make
make the weight
question of taking
putting an empty
found the solution
found a leaf
found a solution
solution with value
focus your attention
report the benefit
evaluating the cost
reject further objects
reject more objects
include more objects
remember that right
leaf we reach
rejected an object
object of cost
makes the method
reject the entire
entire sub tree
fact has search
bound will work
give an exercise
ways of constructing
constructing these cost
constructed cost functions
case the cost
cleaver in order
order to construct
construct the cost
geographical tsp problem
euclidean tsp problem
vertices as towns
edges as roads
suppose in addition
addition to knowing
knowing the road
latitudes and longitudes
straight line distance
road code wind
road could wind
direct straight line
prove a lower
straight line distances
construct a cost
visit these towns
amount of distance
line distance information
needed in constructing
constructing cost functions
functions are constructed
back little bit
bound and backtrack
organize the search
heuristic of deciding
deciding which object
great pay offs
value to weight
weight ratio first
edge to select
first to explore
first again coming
included the object
include the object
explore this edge
object with good
lots of works
complete different viewpoint
doing combinatorial search
stop here design
today is dynamic
dynamic programming dynamic
programming dynamic programming
technique for designing
techniques finds applications
including operations research
technique for combinatorial
backtrack search technique
sense are optimization
optimization of backtrack
illustrate the technique
familiar knapsack problem
review the backtrack
backtrack search solution
dynamic programming idea
describe some details
knapsack problem involves
problem involves filling
filling a knapsack
knapsack with objects
value the inputs
object is value
first object weights
kilograms the fourth
fourth object weights
suppose to pick
objects in front
draw that node
made any decision
objects and backtrack
entire search space
space and determines
determines the value
objects are picked
picked the first
decided to pick
pick up object
object that remains
decision about object
explore the tree
generate a tree
tree with height
height with total
denotes the number
number of objects
backtrack search procedure
backtrack search view
partially constructed solution
made any decisions
decided to include
decide to include
object has weight
choice of mine
minus the weight
forget our original
weight of objects
maximize our value
value clearly solving
solving this problem
extending the solution
solving this independent
unit of capacity
sense for meet
meet to fill
set whose total
thinking of solving
solving and independent
solves this original
solve this alternate
simple new problem
introduce as simplification
sense it makes
makes programming easier
view is simpler
programming gets simplified
main important benefits
order to solve
solve the knapsack
thinking about extending
kind and solve
thinking of recursion
solve this knapsack
define that procedure
call my procedure
first undecided object
needed to solve
first object onward
similarly the value
write the procedure
first the base
asked to solve
choose any objects
concentrate on determining
filling my knapsack
object and return
interesting case appears
include this object
wise to include
include that object
cover both possibilities
ignore this current
two effects first
improve that value
form the remaining
finishes the recursive
mention just make
making the first
code could execute
state we execute
execute this case
searching the knapsack
make a call
idea is understood
thing will execute
executing recursive call
capacity is larger
side the possibility
picture is understood
popularly called recursion
call give raise
terms give raise
make a procedure
call with parameter
make procedure call
call this side
explore this search
search tree underneath
store the value
table before embarking
calculate that value
basically the idea
basically the optimization
view of things
out this optimization
returning any value
array called table
table and table
first index correspond
case actually takes
equal to capital
store our values
define the rule
denote by null
replace this code
make a check
slightly different position
done by first
checking whether case
return this expression
done by checking
check if table
equal to null
return the maximum
max of table
code will replace
replace this last
explored several times
precisely the work
work gets reduced
write recursive algorithms
write to recurrence
case of dynamic
stored these values
produce an estimate
doing that estimate
executes each line
writes the diary
call this diary
customary to call
diary a transcript
executes a line
idea is clear
number the lines
added some lines
numbers these lines
programs starts executing
making the call
write the first
things will change
number will change
first recursive call
number of triples
step the computer
make one entry
means the computer
computer is executing
two previous parameters
precisely the point
computer actually checks
execute this call
execute the call
computer never makes
definition of triples
number of lines
times the maximum
number of entries
case the number
times the capacity
allowed the program
program will require
steps of execution
times c times
summarize the main
sequence of decisions
solving smaller problem
important dynamic programming
dynamic programming step
first dynamic programming
table and save
repeating that calculation
ideas in dynamic
common to backtrack
two new important
analysis the fourth
relation to estimate
slightly different formulation
end up eliminating
eliminating the recursion
indian institute technology
longest common subsequence
lecture on design
programming the topic
start by defining
defining the problem
longest common subsequent
subsequent will abbreviated
abbreviated as lcs
lcs the input
matter the sequence
sequence of characters
string and sequence
longest possible subsequence
obtained by dropping
longest common subsequences
sequences of length
sequence of length
long common subsequence
subsequence in fact
lcs problem find
find any longest
speak of lcs
clear by context
problem the length
representing the similarity
longer this lcs
care about strings
similarity the answers
two dna sequences
measure of similarity
miss pelt word
algorithms we develop
develop a lcs
measures of similarity
brute force algorithm
algorithm for lcs
idea before embarking
discover a complicated
retain the longest
written an answer
large in fact
sequence as length
sequences the subsequences
apply dynamic programming
programming will give
express the problem
search space consists
consists of common
sense is first
determine the objective
generate this space
purposes of thinking
generate the subspace
write the recursive
recursive procedure listed
write a recursive
argument the space
typically will divide
optimizes our object
longest subsequent belonging
dynamic programming stops
characterize the calls
calls the recursive
define a table
store the results
write non recursive
non recursive procedure
assuming other entries
fills say entry
entries are filled
filled the key
small in fact
table times filling
small enough table
strategy will give
common subsequent problem
case of lcs
lcs the first
define the search
write this procedure
requires just divide
sub a union
union s sub
sub b union
consisting of common
common subsequences starting
starting with letter
programming will require
idea of dynamic
find to write
exponential time solution
define a recursive
procedure for searching
idea to write
equal to longest
consists of subsequences
case this search
search this space
adequately it helps
helps some finding
ready to find
claim that sense
longest such subsequence
defined a minute
inside p terms
claim is true
sake of contradiction
capital l equals
return r equal
constructed a procedure
find a procedure
tempt into claim
sequence of letters
longer then lcs
prove it first
first the proof
longer than lcs
define r prime
equal to lcs
generated by recursive
shorter than longest
procedure to determine
determine the longest
longest the longest
put r prime
substitute r prime
compute r prime
return the longer
ready to write
general search procedure
careful about boundary
index is bigger
index return null
longest common sequence
start by doing
equal to smallest
write it jointly
compute r equals
concatenated with lcs
explicitly will compute
compute there lengths
out some technicalities
call we wrote
moment we write
evaluated as null
passed as null
call and null
represents null strings
strings or null
basic recursive procedure
recurrence to estimate
stop dynamic programming
dynamic programming require
characterize what recursive
recursive calls happen
first the recursive
pass for first
recurs the key
recurs our calls
dynamic programming strategy
save the solution
two dimensional table
simply to fill
filling the entries
generate the procedure
filling these entries
order the entries
fill the entry
write that term
fill is suppose
suppose to written
written this entry
pass this string
string was starting
search to happen
happen from starting
null then return
interpreted in light
entry not lcs
return the fill
procedure is working
write that out
fill this entry
entries already filled
fill these entries
procedure will work
set the bottom
hand side column
column to null
equal to fill
backwards will make
find the table
long this fill
store the subsequences
computed as arrays
subsequences the entire
computing the longer
back this last
last part fill
dynamic programming algorithm
reduce the times
code for fill
prove it correctness
stop this lecture
give you faster
store the result
result being calculated
calculated the table
storing the entire
matric chain multiplication
today is matric
form this product
multiply to matrices
multiplication is associative
parenthesize this product
entire to perform
perform the entire
compute c equal
completed the simplest
algorithm for doing
definition of matrix
matrix multiplication matrix
multiplication matrix multiplication
multiplication is defined
computing the single
algorithm for simplicity
required for multiplication
issue concerns associativity
specific example involving
first compute matrix
require 8s scalar
number of multiplication
obtained by multiplying
speak of parenthesization
form the product
fashion by drawing
represents there product
early indicated earlier
matrix to mentions
multiply m matrices
ways of parenthesize
tree is grow
fast in fact
ready to give
give a formal
represent the dimensions
give the number
number of rows
rows and columns
columns of matrix
rows of matrix
supposed to represent
output is suppose
rooted binary tree
thing should give
computing the product
state as state
left sub tree
right sub tree
tree the product
call the cost
simply the number
computer this lost
simple brute force
calculate the cost
cost to represent
cost as remarked
number of trees
design an efficient
algorithm for solving
programming the first
cost the problem
clarify our thoughts
minimized or maximized
done this step
simply the search
simply the space
design an algorithm
partitions search space
partition is searched
searched to find
making several recursive
build the table
define a procedure
fill the table
entries the key
make this work
calculate the matrix
scheme for calculating
calculating the products
cost we call
minimum cost tree
require some creativity
doing this partitioning
define s sub
tree of root
call this sub
space is place
idea to characterize
characterize to design
design some property
property to define
define some property
tiger has strips
define some properties
fairly natural property
tree the interesting
tree for computing
standard dynamic programming
cost strictly bigger
construct another tree
place l prime
tree t prime
estimate the cost
bigger than cost
substitute l cost
prime plus cost
proved the cost
made a claim
optimal sub tree
ready to design
design a recursive
call our recursive
recursive algorithm mcm
algorithm mcm stands
stands for metrics
metrics chain multiplication
argument then array
return the optimal
leaves the matrices
leaves will serve
serve as place
performed the basics
basics for writing
writing this algorithm
first take care
suppose our array
array only represents
represents a single
written a tree
ready to generate
generate the algorithm
generate our algorithm
algorithm the basic
explore each subspace
code for doing
sub tree optimal
tree optimal tree
lemma the left
recursively call mcm
first i leaves
elements will define
define the rows
first i matrices
optimal right sub
remaining n minus
minus i metrics
metrics c sub
cost of multiplying
two the results
multiply the results
return the tree
extracting the cost
designed the algorithm
right sub trees
trees and make
make a tree
make the root
point to align
written a cost
attach an additional
simplify a matrix
compute the cost
written single element
written a element
written its cost
equal to mcm
cost the cost
dynamic programming procedure
calculate this expression
substitute this mcmc
step in dynamic
characterize the recursive
mcmc would progress
taking our original
taking a prefix
taking the suffix
necessarily a suffix
allocate one entry
store in table
define a non
recursive procedure fill
definition of mcmc
entire sub range
compiler will rename
rename and make
condition n equal
index n appears
return say min
return by fill
fill in fact
talk about mcmc
entries are full
pretty match ready
ready to right
right the dynamic
characterize how fill
step the first
statement and fill
entry in fact
side this side
row kth column
considers the values
simply table entries
needed for updating
put an arrow
defined then fill
fill can fill
start filling entries
fill the entries
filled these entries
fill this entries
thing that remains
fill a single
compute this product
finishes the entire
compute the exact
calculate the tree
giving your hint
store the root
update a single
construct the root
squared the total
concludes this lecture
scheduling with startup
startup and holding
nicely using dynamic
dynamic programming today
today the problem
solve is scheduling
capacity of producing
start a machine
machine a machine
pay a startup
startup cost today
start it today
warehouse to hold
produce something today
pay some rent
rupees per night
night the main
represents the demand
supposed to produce
produce a vector
machine can produce
unit per day
days the machine
produce n units
algorithm must report
illustrate this problem
delivered on day
units the holding
cost of storing
days the demand
case the demand
meet this demand
start producing earlier
producing on day
cost on day
day the machine
keeping a gap
gap on day
begun the production
begin the production
warehouse whatever unit
held in addition
yesterday the day
simply the startup
eventually this plan
question in general
plans and figure
suggests a brute
evaluate the costs
number of days
find some kind
cast our problem
important to define
design a algorithm
algorithm which searches
searches the space
typically the algorithm
partition the search
divide the search
space into spaces
space each subspace
search the first
solution which minimizes
minimizes the objective
maximization the solution
solution which maximizes
maximizes that objective
recursive solution dynamic
solution dynamic programming
point it proceeds
sense the idea
make a table
filling table entries
procedure the recursive
quantity several times
make the table
fashion our algorithm
solve the first
days will depend
recurse this information
day of recursion
pay the startup
means our recursion
include additional history
additional history information
generalize our problem
generalized scheduling problem
inputs the demand
demand as inputs
inputs the demands
days the startup
cost the holding
inputs and input
stock on day
units in stock
begin the machine
values any integer
integer the rest
rest is similar
defined earlier corresponds
range of values
values our output
produce a production
instance under instances
instance is defined
day the objective
minimum cost schedule
space s sub
put all schedules
machine is producing
space sub space
machine is idle
idle on day
search s sub
idea in devising
devising recursive algorithms
algorithms for optimization
solutions some smaller
optimal sub structure
sub structure idea
subspace s sub
smaller sub problem
show the parts
equal to true
set of schedules
vector the residual
demands for days
change the holding
inventory on day
day we produced
present on day
produced on day
day the final
schedule which satisfies
satisfies this residual
lemma this lemma
satisfy the residual
instance the argument
argument in dynamic
dynamic programming arguments
argument by contradiction
schedule which means
smaller than cost
original instance right
cost for remaining
day plus cost
remember we assume
showing there exists
exists a schedule
words our lemma
optimal for instance
instance the residual
search the space
similar idea works
component the machine
status is false
consists of schedules
accomplished the goals
ready to build
build a recursive
sorting this problem
call our algorithm
algorithm opts schedule
opts schedule arguments
arguments the entire
cost the current
find the optimal
recursive residual problem
residual problem assuming
schedule the cost
first sub space
bests and number
number of details
details the remaining
identified what kind
kind of recursion
step of dynamic
characterizing the recursive
initially opts schedule
pass the sub
sub array beginning
out the first
doing the recursion
words the argument
terminal sub range
true or false
argument can vary
store the table
construct a table
result of optschedule
point of making
making the table
make a list
dealing with schedules
simplify the problem
working with entire
cost of optschedule
planning to store
cell the entire
entire optimal schedule
similar entries similar
entries similar number
entries with similar
store the cost
dynamic programming requires
out how entries
assuming the remaining
derive some kind
kind of recurrence
wrote a minute
small smaller range
range is passed
simply be true
concatenated with optschedule
dropping the first
drop the first
false and optsched
concatenated with optimal
optimal schedule false
schedule false concatenated
understand what optimal
simply the cost
first schedule starts
starts with keeping
keeping the machine
machine on day
potential for incurring
incurring a startup
cost is incurred
false to begin
expression mark true
mark true value
true value colon
value colon false
colon false value
evaluates to false
words this bracket
represents the startup
inventory for day
case the computation
deleted the inventory
inventory gets reduced
considered the possibility
negative number true
number is infinite
taking the min
ignoring this cost
trouble of checking
checking the indices
infinite negative numbers
demand is bigger
fulfill that instance
day is bigger
problem is unsolvable
positive number earlier
case it suffices
equal to minus
words our table
large the final
last day schedule
single day schedule
satisfying the demand
left with inventory
constitute a valid
satisfy the last
value last demand
produce anymore units
hand the inventory
produce to make
run the machine
expression which evaluates
set the cost
show whatever table
case we looked
out all right
part we filled
filled it out
out this part
parts are filled
out to begin
column some value
fill each entry
filled in constant
fill the entire
table in decreasing
carefully j ranges
entry our recurrence
evaluated in constant
result the total
filled this table
cost is found
found in entry
cost of generating
generating a schedule
inventory to begin
find the schedule
costs which costs
note we noted
calculate this cost
involving some column
column some element
generated by keeping
term is equal
knowing the optimal
knowing the table
apply this argument
generate the entire
problem in today
quietly an important
important and interesting
device recursive algorithm
generalize the problem
problem of medium
device a recursive
algorithm for medium
algorithm for finding
finding the arc
issue was applicable
make a comment
comment on dynamic
simply the dynamic
recursion a basic
idea the first
first basic idea
idea is recursion
idea is make
compute every value
table essentially made
made as focus
calculated every value
draw your attention
attention to recursion
recursion in search
average case analysis
analysis of quicksort
today is average
analysis of quick
begin by discussing
discussing average case
set of instances
instances of instances
instances for algorithm
define the average
defined as sum
number of instances
reasons for doing
doing this worst
easier to compute
easier to deduce
case is easy
easy to compute
wait those instances
instances more heavily
happen in practice
case analysis worst
analysis worst case
give some guarantees
guarantees our topic
today is quick
case analysis turns
things about quick
quick sort quick
sort quick sort
popular sorting algorithm
method of choice
choice the worse
square the average
sense the excellent
performance in practice
algorithm quick sort
sort is based
based on divide
array whose length
goal of quick
end we begin
begin quick sort
case just checks
element this array
return that array
call it splitter
splitter is chosen
built three lists
lists a list
splitter a list
begin by putting
equal just single
construct a list
large and large
initialized to null
null and small
null this loop
first we check
smaller than splitter
add that element
element to small
equal to splitter
greater than splitter
simply a matter
matter of recursion
list which contained
contained all small
qsort or quick
list in large
appending three lists
turn is guaranteed
quick sort works
part is trivial
induction on size
prove it formally
wanted to analyze
size and input
input in mind
worry about average
establish the recurrence
matter what input
instance we feed
write down first
calling quick sort
sort on small
small and calling
sort on large
loop which runs
cardinality of large
evoking quick sort
invoking quick sort
draw a recursion
recurrence we break
break the problem
call quick sort
part one side
terminates and things
node has size
node the number
number of keys
start the instance
means this height
node its children
problem our algorithm
inside the body
total work done
size this problem
problem size added
level the work
bound on quick
construct an input
sort actually takes
tree has small
happen quite frequently
smaller than log
give a hint
height must decrease
case it turns
case will happen
splitter is equal
problem size halves
cases one case
middle another case
splitter was extreme
split very unevenly
pick a splitter
splitter it satisfies
satisfies a property
redraw this recursion
quickly the height
largest problem size
bad that means
force the tree
force quick sort
sort of erring
first level problem
largest problem level
problem level size
problem will split
largest problem drops
conclude that log
right most branch
branch will drop
number of levels
tree the tree
sort should work
work ? quick
derive the recurrence
derive n log
talk about average
inputs are distinct
numbers the elements
elements the keys
factorial possible permutations
terms of probabilities
constructed a set
instances at random
giving equal probability
estimated by grouping
grouping the instances
instances into separate
calculating the average
probability of picking
picking that group
case the question
taking the average
draw this picture
instances which begin
pick a group
groups are identical
group as compared
solving a problem
sorting the small
elements of integers
permutation of elements
splits into groups
sorts the first
takes the equal
sorts the last
addition to sorting
mentioning the constant
clever data structure
picked the splitter
constructed this group
numbers the order
equal to sum
case of quick
method for solving
elements into lists
key is compared
worst case input
describe a table
table which shows
table this table
keys are integers
rows are labeled
labeled i colon
left a blank
pattern of comparison
factorial possible input
factorial possible columns
column are marked
number of cells
fraction of cells
first input instance
suppose some element
element is picked
question of comparing
comparing them subsequently
picked as splitters
elements get picked
split as splitters
elements are picked
claim that probability
simple it tells
pick a row
row at random
words the number
columns the fraction
row i colon
out slightly differently
treating this sum
factorial times sum
entire table list
list n factorial
divide this total
represent the number
works for selection
select the rth
rth smallest element
bipartite maximum matching
maximum matching bipartite
matching bipartite graph
bipartite graph matching
candidates the idea
list of jobs
constraint the constraint
candidate the goal
obvious goal assign
goal assign candidates
candidates to jobs
number of jobs
jobs are filled
filled the bipartite
maximum matching problem
job and candidate
two vertex sets
set of edges
simply the graph
forms this set
set of vertices
edges which connect
connect our text
edge is incident
set of blue
matching being incident
require to output
required to output
output a matching
matching of maximum
maximum possible size
size a size
matching is defined
number of edges
matching which consists
maximum sized matching
maximum size matching
edges maximum matchings
candidates and jobs
jobs are represented
represent the fact
fact that candidate
fact the list
list of candidate
assignment of jobs
jobs to candidates
assign to candidate
maximize the number
algorithm design idea
ideas and refine
notion of augmenting
paths this turns
understanding augmenting paths
clean simple high
simple high level
high level algorithm
state and prove
prove that theorem
finally we talk
implement this algorithm
simple winded idea
largest size matching
moment you talk
talk about larger
edges and maintain
maintain a set
edge and add
produce a conflict
adding this edge
end up adding
exists a matching
matching in fact
call the kho
kho kho idea
played this game
game of kho
sitting down starts
running and starts
chasing the members
vertex is free
state that idea
throwing an edge
include that edge
include that matching
edge will sort
sort of set
increased the size
thing to check
matching are shown
shown in blue
start with vertex
candidate for inclusion
vertices two edges
two edges incident
conflict just means
remove this edge
green to show
started this entire
remember that yellow
started this procedure
matching green edges
remember this edge
removed this edge
edge this yellow
edge has entered
entered our matching
produces a conflict
eliminate that conflict
color it green
kho kho sort
adding three edges
edges we added
color those edges
stayed this edge
earlier it state
traverse this graph
executed this process
traversed a path
started at vertex
path is green
path is yellow
fact the colors
added and removed
edges in fact
path we traced
procedure has lots
lots of interest
interest in properties
path an augmenting
left the set
out the construction
construction the last
discover an extra
set e minus
minus m supposed
supposed to denote
remove the set
forward again potentially
follow an edge
operation of taking
taking an augmenting
circle plus operator
define q circle
edges the path
green edges form
form the intersection
augmenting paths play
play a big
matchings in fact
eminent computer scientist
sense of analysis
describe an algorithm
credited to edmond
idea of augmenting
finding the augmenting
perform this operation
operation and set
augment our current
matching the moment
attributed to berge
theorem says berge
graph is maximum
exist a augmenting
find an augmenting
hands a maximum
justifies or proves
proves the correctness
correctness of edmond
theorem the proof
theorem the first
required to prove
exist an augmenting
existed an augmenting
augment that path
compute m circle
case is obvious
obvious the interesting
prove this case
case by contradiction
assume the contrary
wanted to watch
composed of paths
paths and cycles
claim is equivalent
equivalent to stating
sets of edges
taking some edges
forget the symmetric
union the degree
consists of paths
two consecutive edges
defined to consist
consist of edges
incident on vertices
property will stay
inside r consist
consist of alternate
remove the intersection
minus the size
intersection but note
end we subtract
examine the implications
first each cycle
cycles this fact
exist a path
last end points
simply the definition
augmenting path exists
improve your path
find augmenting paths
augmenting path starts
starts and ends
vertex it starts
generality or vice
start an augmenting
exists a augmenting
growing the path
difference the edges
matching e minus
path must grow
backwards using edges
reach a free
grow these parts
discovered a path
package this set
set of ideas
breadth first search
slightly a graph
idea will work
vertices are free
vertex.2 and vertex
start the paths
direction and backward
make our description
nice and compact
direct these edges
kind of search
grow the path
enforce this constraint
grow the paths
put a direction
forces the search
path the augmented
path goes backwards
put backward arrows
forward using edges
path must end
put a vertex
directed graph notice
state this algebraically
define this directed
symbol g prime
consist of vertex
set v prime
minute and edge
union of set
define the edge
set e prime
supposed to end
left hand set
hand side vertices
vertices of capital
set e sub
defines our auxiliary
claim our main
claim is important
finding augmenting paths
graph g prime
claim would enable
find augmented paths
paths very quickly
transformed our original
prime by context
inside g prime
prime or inside
forward and backward
backward several times
times and terminates
edge is present
path users edges
matching the path
path is moving
forward going edges
reasoning will accomplish
defined this auxiliary
find the path
find a path
step of finding
finding an augmenting
augmenting path procedure
construct g prime
return the augmenting
path this return
augment the matching
denotes the cardinality
denote the cardinality
graphs are represented
adjacency list representation
representation in fact
purpose of simplicity
simplicity of thinking
constructing g prime
doing the breadth
construct this graph
oriented the edges
bfs bfs breadth
bfs breadth first
first search takes
step also takes
entire procedure augmenting
procedure augmenting path
done in constant
question that remains
compute m augmented
number of augmentations
completes the analysis
making the small
path essentially allowed
root n algorithm
problem for non
non bipartite graphs
non bipartite case
found in non
bounds for sorting
algorithms the topic
today is lower
designed a algorithm
solve some problem
naturally the question
proved a result
problem lower bound
equality is exact
equality is approximate
motivation for studying
problem lower bounds
question of lower
problem being sorting
sorting regarding sorting
introduce a model
model of computation
prove problem lower
bounds on decision
care about decision
good enough model
average case lower
case lower bounds
prove average case
defined the notion
notion of putting
putting the lower
bound f sub
worst case instance
stressing the worst
worst case bounds
worst case times
measure the performance
performance of algorithms
prove lower bounds
algorithm is weak
size instance size
construct this lower
lower bound function
bounds a problem
algorithm has lower
takes the minimum
minimum worst case
prove such bounds
construct bad instances
bad instances instances
instances which show
give a construction
matter what algorithm
algorithm you give
order to prove
trivial lower bounds
prove most problems
problems have omega
input the input
input has length
random access machines
access machines ram
proving non trivial
non trivial bounds
assert a problem
tricky to analyze
lots and lots
lots of algorithms
enumerating those algorithms
algorithms or analyzing
things with ram
control flow pattern
define a simpler
simpler computational model
control flow patterns
define such computational
models the space
space of programs
programs or space
space of algorithms
easier to visualize
context of algorithms
relevant for sorting
context of sorting
sorting this model
worry about inputting
inputting those numbers
model a program
node has labels
form i colon
describe the model
first each edge
relational operators leaf
operators leaf node
leaf node labels
wanted to give
program tree model
edge is labeled
labeled with greater
leaf is labeled
colon j input
compared with input
equal to branch
make the comparison
path to follow
leaf is output
root by starting
root we compare
follow this branch
perform the instruction
requires to compare
representing our conclusion
represents a sorting
sorted this input
input instance notice
complete the discussion
instance the worst
execution you follow
follow that path
end up setting
define average case
randomly with equal
leaf path length
nice graphical interpretation
decision tree model
model this claim
properly this claim
matter what tree
non trivial bound
ram sorting algorithm
operations it performs
performs on keys
keys are comparisons
comparisons and copying
based take heap
compare to keys
similarly for merge
similarly for insertion
comparison based algorithms
connected to decision
decision tree algorithms
comparison based ram
based ram sorting
exists a decision
decision tree sorting
tree sorting algorithm
instance in fact
class of algorithms
algorithms the final
comparison based sorting
based sorting algorithm
non trivial result
based sorting algorithms
algorithms for comparison
proving this first
prove that sorting
input x remember
apply the inverse
supposed to compute
compute this inverse
leaf the answer
essentially pi inverse
identified this permutation
leaves each node
accessible only passing
strict inequality branches
input is permutation
tree whose degree
out the product
times n minus
factorial is bigger
relates comparison based
tree sorting algorithms
construct a decision
insight in figuring
out the main
keys are compared
keys and base
keys to compare
inside a key
keys it compares
values of keys
determined by examining
examining the algorithm
find actual numbers
values of key
find the labels
examine the program
instance i suppose
fact in instance
first two comparisons
built this part
tree the decision
instance i prime
flow can change
comparison with keys
comparisons the comparison
outcomes have matched
constructed some super
constructed some path
extend this path
determine the label
construct a instance
satisfy this label
constructed an instance
algorithm and decide
fix the label
determine the final
final sorted order
back the label
make that leaf
constructed our decision
decision tree algorithm
finishes this claim
suppose some comparison
based ram algorithm
based ram algorithms
exist a decision
first claim tells
algorithm the first
proved this claim
proved a lower
variety of sorting
bound will apply
turn to average
average case complexity
put a lower
based on structures
properties of trees
root k leaves
complexity of sorting
imply some lower
complexity is concerned
leaves a distance
minus square root
prove something stronger
average path length
path length average
total path length
path of length
sorting on decision
leaves thus average
length is bigger
algorithms say heap
studied average case
complexity of quick
sort we proved
worse case complexity
complexity for quick
first some implications
mimics the ram
operations besides comparisons
fact a popular
algorithm called bucket
operation it performs
allowed in comparison
give the algorithm
build an array
array of buckets
compute in constant
insert this key
visit each bucket
bucket in turn
out the contents
contents in increasing
initialize the array
visit every element
visit every key
square is slight
model to study
things like finding
lecture in fact
extend this decision
study other problems
study merging problems
similar to sorting
putting lower bounds
calculate the intersections
two given sets
idea of decision
model of decision
lower bound model
made somewhat stronger
lower bound results
element distinctness lower
distinctness lower bounds
today is element
distinctness lower bound
sorting lower bounds
call the entire
supposed to output
distinct two numbers
talked about last
non trivial lower
trivial lower bound
examine the numbers
easily be solved
numbers are identical
compare adjacent numbers
numbers after sorting
subject of today
last time last
looked at lower
bounds on sorting
introduced a lower
lower bound technique
lower bounding technique
problem of element
prove the lower
extend the model
call the algebraic
algebraic decision tree
read a program
non leaf nodes
nodes are labeled
program leaf node
output ? edge
labels are relational
equal to greater
decision tree program
program for sorting
sorting three numbers
non leaf node
node is labeled
inputs is compared
branch is found
edges are found
found and execution
wanted to compute
program for size
size n equal
point we noted
access machine model
resembles our computers
applies to comparison
ram model comparison
model comparison based
compare the keys
keys to induct
sorting lower bound
bound the input
consisting of components
sort these numbers
numbers the key
thing to observe
lower bound argument
factorial possible answers
out n factorial
factorial different answers
print a single
out that entire
entire permutation constitutes
constitutes a single
capable of printing
printing n factorial
language of information
answer has high
high information content
content the answer
factorial different values
factorial in fact
information theory measures
theory measures information
number of ways
ways in fact
information theoretical lower
theoretical lower bounds
information theoretic lower
theoretic lower bound
element distinctness problem
means all elements
means some duplicate
height of value
giving yes answers
write down things
asserts a problem
interpret our input
tuple as representing
represents the first
represents the nth
entire thing represents
represents a point
call that point
restrict these instances
unit n cube
argue that things
end of execution
region is connected
coordinates are distinct
consist of distinct
alternately these coordinates
non trivial permutation
distinct yes leaves
two distinct leaves
argue in fact
leaves is bigger
restricting the points
points to unit
hard to visualize
visualize n dimensional
visualize two dimensional
two dimensional space
axis our instances
pick a point
continue the analogy
instances which lie
coordinate is equal
instances the interior
line which divides
divides the square
geometric view point
interpreting these instances
finished this part
part we interpreted
interpreted our input
restricted the instance
two main claims
claims this claim
instances will reach
defining what connected
exists a path
region the interior
define a convex
proof a region
region the straight
straight line path
making the stronger
case of connectivity
region is convex
worry about convexity
straight line paths
easy to reason
easier to argue
region is easier
easier to prove
worried about convex
examples of convex
examples of objects
joining the straight
straight line joining
kidney shaped region
cashew shaped region
describes what connected
reached on execution
wanted to argue
suppose i follow
follow this path
begin by giving
giving some intuition
equal to path
characterize the region
characterization is geometric
coordinate is smaller
putting our region
visit the root
root any instance
instance will arrive
entire unit cube
visiting the root
constitute the entire
visiting this node
node is visited
top be smaller
wedge shaped region
moment i assert
assert a condition
slice my current
shrink the set
slicing operation maintains
operation maintains convexity
roughly the idea
roughly the argument
execution the instance
reached by definition
finish this execution
reached in execution
execution with instance
instance my instance
curious looking manner
minus lambda times
case lambda equal
lambda is equal
midpoint of line
values of lambda
line segment joining
straight line segment
line segment line
segment line joining
prove in order
path must lie
analyze this execution
start with root
check that out
inequality lambda times
complete this argument
proved that execution
segment i reach
reach distinct leaves
reach yes leaves
fact the claim
consists of distinct
means the answer
prove this result
result by contradiction
exists a point
supposed to lie
claim the sub
proof almost immediately
define a function
simply the difference
path is continuous
exist a point
coordinates are equal
equal that means
proved our basic
prove this sub
define a permutation
defining this permutation
answer will hit
trace it backwards
prove the claim
supposed to find
reason for sorting
choose i smaller
property is guaranteed
sequence i change
found these two
number is greater
skip the algebra
property will hold
needed to prove
prove our original
two distinct permutations
number of distinct
finishes the claim
space no instances
partition the instance
similar to last
algorithms for element
case of algebraic
algebraic decision trees
consists of trees
trees with outgoing
longer i colon
input the components
evaluate the label
expression is equal
choose the equal
point lies inside
restricting our point
inside this region
expression is linear
results actually hold
expression is non-linear
intersection of constraints
constraints can produce
produce disconnected regions
happen if things
things are linear
problem over inputs
problem whose answer
element distinctness suppose
case for simple
simple decision trees
omega of log
inside this omega
constant of proportionality
complicated algebraic model
bound for element
distinctness in fact
degree will give
leaf can correspond
heavy duty machinery
machinery from algebraic
geometry to count
constraints are linear
constraints are high
high degree algebraic
degree algebraic expressions
quickly summarize lower
summarize lower bound
lower bound theory
last two lectures
done another interesting
deep mathematics algebraic
mathematics algebraic geometry
geometry is supposed
area of mathematics
find the heavier
lecture to formulate
formulate a decision
introduction to reductions
study this notion
effectively the first
sort of talk
land your dream
job the company
settled in software
deal with designing
give you challenging
projects the first
jobs on computers
sizes could vary
automate your boss
automate this process
write a program
input these sizes
schedule these jobs
jobs on processors
last job finished
finished is fastest
job of size
start a job
run for completion
jobs must finish
supposing i schedule
jobs are scheduled
last job completes
last job finishes
sort of distribute
distribute the jobs
jobs in order
loaded for instance
working your boss
boss is happy
day the boss
produce the schedule
produces the schedule
input is smaller
takes is smaller
boss says fix
produce a optimal
produce the optimal
back and figure
jobs are mixed
sizes are mixed
reason the algorithm
sort the jobs
jobs by size
jobs are increasing
order of size
put the last
finish all jobs
units every job
job has finished
repeat the algorithm
assign these processes
lightly loaded processor
processor you sum
choose the smaller
difficult possibly impossible
compute the size
bar s bar
two and choose
choose the maximum
subset and pick
compute these choose
ways of scheduling
give the input
list of size
running the algorithm
pass an hour
day the algorithm
boss is starting
input of size
years and years
brute force approaches
subsets of jobs
instruction a computer
computer can process
fastest computer runs
make an estimate
big over estimate
disposal to solve
hours a day
instructions per year
subsets per year
years this takes
world the fastest
number of years
number of atoms
universe per year
lot of years
algorithm to finish
fired in fact
studying np completeness
save your job
design of algorithms
find the solution
handle other problems
manages to solve
imbibe the first
concept of reduction
reduction really means
library where large
number of problems
invent the wheel
efficiently use code
algorithms to generate
generate new algorithms
thing is notion
graph g equals
set a matching
two edges share
ticked edges form
form a matching
share a end
point the end
share any end
point for instance
essentially one set
share an environment
matching is perfect
graph are end
points a perfect
vertices are end
note that size
edges will share
share an end
change this graph
two perfect matching
matching it ticks
form another perfect
problem perfect match
matching the input
graph is perfect
matching a graph
sub routine library
sub routine coded
problem maximum matching
size your job
construct an algorithm
hope the objective
objective is clear
sort of intermediate
find the size
algorithm for perfect
size of maximum
add a vertex
call this graph
things can happen
vertex this extra
draw the edges
remove this vertex
matching of size
size v minus
perfect matching fellows
write the generic
perfect matching algorithm
added one vertex
connected every single
added two vertices
encountered a graph
graph with perfect
vertices are matched
graph in fact
minus and minus
vertices i match
perfect matching matching
objective the intermediate
finding the perfect
graph by calling
times i call
call it faster
find the perfect
algorithm that finds
finds the size
call the perfect
algorithm n times
log n calls
matching it resembles
resembles binary search
essentially it shows
calling this algorithm
find this perfect
filled this intermediate
find the edges
pick any edge
remove a edge
graph at remains
put this edge
back this edge
edge is part
leave this edge
edge i remove
matching the resultant
size is fallen
back i remove
size ? size
point the graph
graph that remains
throw this edge
completes our objective
wanted to design
algorithm for maximum
algorithm for problem
exists an efficient
problem we show
design it takes
takes as input
input for problem
calls this sub
outputs an answer
solution for problem
looked at last
exist a perfect
modifying the inputs
reduced this problem
reduced the problem
efficient problem algorithm
find an efficient
construct this efficient
earlier a solution
algorithm an efficient
reasonable size inputs
size inputs finishes
finishes in reasonable
efficient to start
brute force algorithms
algorithms ? brute
algorithms are algorithms
size a brute
collection of edges
subsets of edges
out a matching
entire solution space
sort of characteristics
algorithm the input
subsets typical times
design such algorithms
algorithm is bounded
exists a constant
log n times
polynomial n square
conquer or dynamic
size n square
square n cube
cube shortest path
shortest path finding
path finding minimum
finding minimum spanning
minimum spanning trees
notion of efficiency
two different things
program an algorithm
minutes to complete
motion of efficiency
sort of reason
algorithm which runs
runs an polynomial
polynomial in input
bound the running
polynomial time algorithm
problem which means
means the running
polynomial is small
implied an algorithm
finding the size
finding a maximum
algorithm is efficient
true the reason
define a couple
couple of terms
concepts of hamiltonian
path in hamiltonian
length n minus
path which spans
spans all vertices
vertices other words
path the hamiltonian
cycle which spans
vertices one single
edge this edge
path the reverse
talking of reductions
right now related
finding the hamiltonian
confused with hewlett
put the graph
graph as hamiltonian
path or cycle
cycle that spans
vertices hamiltonian path
path that spans
hamiltonian cycle design
design a efficient
supposing the input
algorithm somehow supposing
supposing i feed
cases this fellow
added new vertex
vertex u connect
graph i feed
vertex i connect
correct which means
means this graph
prime new graph
output for instance
path which runs
add the edges
construct a path
path a hamiltonian
construction is similar
vertex u sits
path will start
statement both ways
algorithm for hamiltonian
hamiltonian path constructs
algorithm the previous
call the hamiltonian
hamiltonian cycle routine
graph the input
algorithm was sufficient
prime to distinguish
routine for hamiltonian
usual trick feed
feed this graph
cycle in fact
remove any edge
edge the hamiltonian
remove every edge
edge e call
edge e prime
prime g minus
minus e prime
removed any edge
correct the algorithm
path after removal
feels that graph
graph any edge
graph becomes disconnected
remove this middle
remove any vertex
vertex the resultant
fact be connected
draw this graph
supposing i remove
exist a hamiltonian
choose this edge
choose that edge
edge that edge
give a hamiltonian
graph are similar
instance this edge
edge is similar
right this edge
bottom is similar
two are similar
graph is symmetric
enumerate to sort
leads the graph
type the algorithm
described is wrong
wrong this fails
remove the edge
attach two additional
two additional vertices
vertices u prime
path the question
question we wanted
wanted to answer
supposing this graph
hamiltonian circuit supposing
hamiltonian circuit pass
order which means
means the edge
hamiltonian cycle passing
picked an edge
graph g edge
attached u prime
hamiltonian path supposing
vertices have degree
path u prime
points of hamiltonian
path which means
means the hamiltonian
graph we remove
remove that edge
prime v prime
prime and connect
connect u prime
lets say graph
graph g lets
two extra vertices
hamiltonian path algorithm
path algorithm runs
runs time polynomial
things to check
first you call
hamiltonian path routine
change the input
remove one edge
two more edges
two cases case
correct second case
exists an edge
removing and adding
adding these two
path here remove
edges and add
add this edge
back together hamiltonian
case is done
prove the contra
means this statement
written is equivalent
write the equivalent
cycle this implies
cycle it means
means there exist
exist an edge
two are equivalent
cycle there exists
exists a edge
edge and attach
vertices this resultant
wanted to prove
problems we looked
wrote input output
looked at problems
finding a matching
weight of finding
matching with maximum
input and output
output was edges
question the input
question the answer
problems the answer
problems the output
spend many bits
bits as output
hamiltonian cycle problem
output the hamiltonian
hamiltonian cycle input
graph g output
output every edge
choose one hamiltonian
cycle and output
output the edges
distinguish between problems
require the output
bit and problems
call decision problems
call search problems
decision and search
decide whether true
solution and output
output the solution
search problem output
output a hamiltonian
exists the input
hamiltonian cycle output
two problems relate
turns out people
graph the sub
sub routine outputs
outputs the hamiltonian
find a algorithm
feed the graph
forms a hamiltonian
trivial our job
talking of efficient
respect to matching
routine which answered
doing this supposing
remove an edge
edges you put
throw these edges
cycle you throw
edges for edges
remove those edges
present you put
remaining the claim
edges which remain
remain must form
form a hamiltonian
spurious edges floating
cycle other edge
graph is hamiltonian
cycle the answer
thrown this edge
present are hamiltonian
find out edges
cycle which means
means what remains
remains are edges
extract the hamiltonian
sort of decide
problem is easy
version is easy
version is hard
hard then social
social decision word
focus on decision
versions of problem
ready to define
define the class
sort of give
favorite hamiltonian problem
call a prover
call a verifier
prover and verifier
verifier has limited
trust anybody sort
trust the prover
sort of lets
graph in front
drawn a huge
figure these things
verifier is skeptical
graph have hamiltonian
convince the verifier
made the right
graph has hamiltonian
out the edges
graph which form
form some edges
edges which form
form some hamiltonian
out some hamiltonian
form a make
form a cycle
easy to verify
convinced the verifier
graph the verifier
prover then picks
edges they form
verifier then verifies
proved that hamiltonian
defined the class
proving things proving
proving the problems
prover verifier game
two non trivial
non trivial integers
composite which means
two are non
non trivial factors
checks the result
means the prover
prover could convince
verifies now supposing
question to answer
brute force method
prover to sort
sort of convince
prover can convince
sort of differently
pick a problem
problem we pick
discuss a game
call them prover
verifier very shortly
shortly this prover
cycle the verifier
cycle very easy
picks any hamiltonian
tells he tells
tells the verifier
sort of limited
limited in resources
write this conversation
cycle the prover
verifier then asks
prover supplies edges
form hamiltonian cycle
supplement this statement
supplies the edges
constitutes a proof
proof that hamiltonian
problem the question
string the prover
prover will give
input the answer
inputs are inputs
move over definition
prover can give
give the verifier
consists of edges
proves that hamiltonian
circuit the problem
problem hamiltonian circuit
sort of points
supply a proof
proof this proof
sort of draw
draw this diagrammatically
inputs the prover
shows the verifier
sends the proof
string and sort
sort of figures
prover can send
send some proof
verifier in polynomial
composites this problem
prover to convince
inputs which means
sort of obvious
number is composite
question i guess
sort of encounter
definition is made
sort of numbers
number that divides
number is prime
supplied right edges
edges having hamiltonian
supposing the prover
difficult thing supposing
extremely difficult thing
collections of edges
edges and sees
vertices the graph
edges and check
behave very differently
sort of note
proof to prove
verifier is convinced
fact yes inputs
hamiltonian circuit case
case for instance
sends the factorization
verifier just multiplies
checks whether equal
fact now defined
defined a class
examples in fact
define this class
occur in real
real life fall
problems in real
easier in fact
versions of real
encountering in real
sort of central
courses in computer
define the problem
make few definitions
takes two values
sort of alternate
alternate between true
bar is false
bar is true
negation some people
bar a literal
variable or negation
bar are literals
literals a clause
depending on values
evaluates to true
false for instance
true the clause
clause is true
false otherwise true
literals are false
formula in cnf
call a boolean
stands for conjunctive
conjunctive normal form
thing this formula
formula is true
write this formula
false it means
check each clause
value is true
check a clause
evaluate to true
special boolean formulae
form general boolean
general boolean formula
equivalently in cnf
ready to roll
exists an assignment
assigns a value
value either true
values either true
evaluate the boolean
call the boolean
boolean formula satisfied
satisfiable for instance
satisfy this formula
confuse with exams
stands for satisfiability
call this boolean
observe that sat
sat is empty
problem and suppose
suppose the answer
verifier be convinced
answered this question
variables the verifier
assignment and checks
true the verifier
checks the formula
easy to check
clauses are true
true all clauses
true the formula
formula is satisfiable
thing that makes
sat very special
theorem of cook
cook is steven
person steven cook
theorems in computer
efficient means polynomial
algorithm for sat
suffices to solve
solve just sat
includes hamiltonian cycle
sort of similar
notion of reduction
algorithm we showed
showed this means
efficient algorithm implies
implies every problem
means every problem
theorem has changed
changed the shape
shape of computer
ways of reading
reading this statement
attention on sat
solution for sat
make a statement
easy and difficult
prove these statements
fortunately with cook
theorem in hand
capable of doing
doing such things
sort of implication
sort of identify
identify our goal
call a clique
clique the subset
graph every edge
clique of size
find a clique
clique of maximum
find a largest
vertices it forms
forms a clique
graph for instance
define a problem
minute the question
sense the question
solve the search
algorithm to solve
solve the decision
problem just find
find the clique
clique and find
done the graph
feeding the graph
largest clique size
found this size
first the hint
hint is first
first design algorithm
find largest cliques
largest cliques size
size or size
throw away vertex
first you feed
remove a vertex
throw the vertex
retain the vertex
form a clique
similar to finding
finding the edges
throw away vertices
algorithm that solves
solves the decision
solves the search
solve all problems
problem called sat
sat the input
input was sat
sat was clauses
assignment of values
evaluate this formula
set to true
set to false
false x bar
assignment an assignment
literals these formula
cnf conjunctive normal
theorem is due
due to cook
theorem it states
exists a polynomial
identified one problem
problems in sat
sat in fact
call these problems
property which means
solves this problem
satisfy two things
require the problem
complete we require
states that sat
add many problems
set this set
begin with clique
define problem clique
prover could give
input would check
sort of entire
algorithm for clique
remove this clique
clique will show
construct a polynomial
input it takes
input as graph
collection of clause
routine to solve
problem on graph
graphs to construct
construct to determine
formula is satifiable
construct a graph
clique into clique
construct some graph
sub routine feed
output is graph
construct the graph
literal clause literal
clause literal pair
divided the vertex
bar to true
pick by picking
picking one vertex
pick one vertex
immediately become false
pick the vertices
clause is satisfied
roughly the intuition
vertex the clique
bar in clique
construction is construction
literal l belongs
belongs to clause
vertices edge set
matter what value
value i set
set of clauses
clauses i construct
construct this instance
instance of clique
clique i feed
routine for clique
supposing the formula
clause some literal
pick these vertices
picked m vertices
picked one vertex
vertex per clause
means there exists
exists one vertex
set these literals
literals to true
literals which corresponds
variable x appears
appears x bar
prove that clique
clique is empty
shown that clique
complete for instance
set a subset
clique he wanted
wanted an edge
prove the version
independent set decision
set decision version
version of independent
independent set problem
set essentially states
size the decision
similar to clique
set problem independent
problem independent set
set has input
proof or advice
out k vertices
graph and tells
vertices form independent
form independent set
set the verifier
verifiers he checks
input the advice
cases is supposing
supposing the question
answer the question
verifier can check
algorithm for independent
algorithm or clique
set we construct
algorithm for dependent
set and clique
sort of problems
problems in graphs
vertices i remove
vertices i add
sort of complement
complement the edge
independent sub routine
vertices must form
complemented the graph
essentially the complement
find or decide
decide to decide
complement the graph
routine for independent
independent set sub
set sub routine
case is correct
suppose i pick
cover this edge
covered all edges
edge this end
forms a vertex
monitor each link
pick a set
assign a link
links both ways
link is covered
chosen to monitor
pick very small
number of computers
covers of minimum
find the vertex
cover of minimum
problem is hard
solve every problem
pick up minimum
monitored this problem
mentioned the search
version of vertex
decision version remember
easier to handle
introduce this extra
extra positive integer
cover of size
cover of smaller
vertex cover input
problem and argue
finding minimum vertex
minimum vertex cover
direction is simple
find vertex cover
cover of small
cover you found
remains a vertex
form as large
large vertex cover
problem you put
complete the first
verifier can verify
edge and checks
checks he takes
takes the subset
subset of size
two end points
prover is correct
proves that vertex
show that vertex
algorithm for vertex
chosen in fact
choose the right
sort of problem
proving becomes easier
construct the polynomial
relationship between vertex
cover and independent
sort to prove
independent set supposing
supposing this portion
graph is independent
set the complement
set is subset
find independent set
call the algorithm
copy the graph
pair i feed
routine for vertex
spread into sub
prime g prime
feed into sub
added new problem
proved that vertex
started out cook
gave us sat
showed that clique
showed that independent
showed that vertex
similar to vertex
form of vertex
maximum vertex degree
cover i add
add this additional
degrees of vertices
graph and delta
focus on graphs
graphs only graphs
cover in general
problem as hard
easier to find
find vertex covers
covers in graphs
case the problem
vertex cover problem
cover problem vertex
problem vertex cover
cover is hard
complete to prove
vertex cover thing
guess vertex cover
efficient algorithm polynomial
construct efficient algorithm
write this statement
direction is easy
restrict the input
vertices with degree
minus k largest
largest n minus
decrease that decreasing
decreasing the vertex
degrees by creating
graph i construct
construct u graph
degrees are smaller
cover the vertex
reduce the degree
trick is degree
reduction while keeping
keeping the size
controlling the size
change the degree
degree i break
break this vertex
two new vertices
degrees are decreasing
two of degree
decreased vertex degree
degree of degree
graph i split
split this vertex
vertex into two
decrease the degree
vertex has degree
vertex of high
degree i split
split this degree
parts and add
add another vertex
make the connection
original graph final
graph final graph
graph has degree
degree of vertex
supposing the claim
means the size
split the vertex
vertex cover size
prove both ways
prove this supposing
call this vertex
vertex cover remain
edges are covered
edge is covered
four also covers
vertex cover remove
cover and put
graph this proves
proves one direction
cover we remember
remember this vertex
check the rest
form a vertex
edges are present
vertex cover remains
covered the case
remove and put
impede our progress
cover may rise
cover will rise
procedure is clear
clear i start
split a vertex
done it reason
split vertex cover
vertex cover rises
initial graph start
graph start splitting
graph and supposing
supposing you construct
procedure will run
run in polynomial
polynomial time design
sunder vishwanathan computer
vishwanathan computer science
cover the fact
fact that delta
suffices to prove
doing the trick
vertices of varying
degrees especially vertices
vertices with large
vertex with large
sort of split
neighbors are attached
effect of splitting
splitting a vertex
reduced the degree
construct keep splitting
done l times
vertex with degree
sort of transformation
runs in polynomial
entire thing runs
vertex get split
vertex be split
hope this argument
argument is clear
right the maximum
graphs the degree
times the vertex
vertex of degrees
times a split
occurs is summation
out and sum
times the split
split you add
equal to size
times and final
graph that results
polynomial in size
runs on polynomial
vertex of size
algorithm worked out
problem is exact
cover xc exact
collection of subsets
collection are disjoined
things the union
pick some sub
element is present
element is covered
covered and covered
covers the set
sense that union
complete the answer
problem exact cover
note first thing
prove that exact
clear what prove
prove the provers
supply the verifier
collection in fact
collection the prover
collection the verifier
takes these sets
sets he verifies
means every element
blame will prove
algorithm for exact
guess the algorithm
problem on graphs
solution to vertex
vertices to cover
cover all edges
sets to cover
cover all elements
elements by sets
edges must correspond
correspond to elements
edges and blind
convert this input
input for exact
subset must correspond
vertices each subset
sort of correspondence
correspondence for vertex
add a set
incident on vertex
cover edges corresponds
corresponds to picking
elements of edges
edges are covering
picking a vertex
picking a sub
problem first problem
vertices are picked
allowed to pick
pick k vertices
fix this problem
supposing the sets
change the collection
collection of sets
number of collections
supposing i pick
cover here supposing
occurs each set
elements must occur
right in fact
pick an exact
cover this forces
edge gets covered
pick this set
vertex not pick
pick this edge
pick these sets
pick those sets
sets those edges
remember our previous
subsets per vertex
degree k degree
vertex for vertex
subset of edges
edges adjacent incident
vertex cover consist
consist of vertices
put the set
pick the set
end point choose
smaller end point
end point supposing
case that edge
collection which covers
covers every element
occurs in set
vertex i right
cover just consists
vertices will form
shoes that exact
vertex of large
degree some degree
subsets here non
non empty subsets
subset i added
empty subsets times
graph with degree
degree for instance
instance the complete
graph as degree
degree n minus
work in polynomial
degree is bounded
reason we needed
shown that exact
complete the main
restriction of vertex
cover then show
show that exact
slightly more involved
problems where sizes
elements each element
elements e measure
put the prover
give that verifier
sum and conclude
conclude and convince
exist a subset
subset whose set
set whose size
verifier the verifier
takes this subset
subsets are measured
show that subset
algorithm for subset
input for subset
sum somehow feed
subroutine for subset
answer for exact
exact cover frame
cover frame model
frame model construct
cover into input
inputs for exact
side the input
sum ? subset
size of total
total size equal
picks up sets
correspondence between subsets
exact cover input
input and elements
subset sum input
side and elements
side must correspond
subsets sum input
sum input right
subsets will correspond
write these subsets
side must translate
pick exact cover
cover this side
subset of exact
cover that corresponds
pick these sizes
sizes to make
multi set multi
set multi set
size k distinct
times each element
give some sizes
fix this positive
pick any subset
subset this subset
remove any subset
dot dot dot
element the size
loss of general
replace a copy
guess the smallest
element case supposing
generalize this right
similarly something larger
squared which means
pick l prime
element of size
size l squared
elements i pick
pick the size
cover the input
times an element
collection the number
number of ele
ele the number
size of size
distinct elements right
number of maximum
fix the sizes
fix the size
size of elements
element i pick
input the size
first fixing sizes
sizes of elements
add the size
exact cover supposing
supposing this set
reverse direction pick
ends a discussion
sub set sum
calculating the input
input is easy
proves that subset
done in fact
partition the input
set t sizes
sizes are integers
integers positive integers
sizes for instance
things are true
element he tells
tells which part
part it belongs
takes this partition
partition he verifies
partition exactly equals
sizes are involved
algorithm for partition
partition for subset
sum the input
form this asks
solve subset sum
minus b supposing
sum i add
equal parts supposing
partitions you partition
subset sum problem
sum problem put
answer for partition
construct an answer
answer for subset
partitions the answer
side the maximum
sizes the sum
reduction that shows
shows that partition
written a formal
proof that partition
sort of reduction
complete then independence
set then vertex
show subset sum
joined a company
wanted to schedule
finishes was smallest
partition the reason
input for partition
input you feed
processors the sizes
exist a partition
sizes are equal
general than partition
sequence of reductions
constructed an algorithm
set of arguments
reasonable and intelligent
intelligent with intelligent
finishes this module
science & engineering
algorithms for np
np complete problems
today is approximation
wanted to solve
real life situation
two three lectures
complete problems arise
talk about optimization
finding an optimal
complete one wonders
solution in polynomial
approach of finding
finding fast approximation
fast approximation algorithms
lectures in finding
finding the optimal
interested in finding
approximately optimal solution
real life application
real life problem
solve has additional
features that make
polynomial time algorithms
solving such problems
algorithms another possibility
run in pseudo
difference the run
input are represented
represented in unary
definition of polynomial
numbers be represented
unary representation system
interested in devising
lot more freedom
freedom to work
numbers are represented
napes the dynamic
weights and values
value and capacity
capacity the input
necessarily the length
bit string needed
represent the capacity
capacity is represented
bit binary number
notion of good
compromise between polynomial
difficult to analyze
lots of instances
instances and check
exponential time algorithm
size is small
small or small
takes a day
run a computer
solving real life
real life problems
problems the real
life problems tend
small and today
exponential time algorithms
algorithms can work
useless our focus
running in polynomial
give the optimal
give somewhat close
close to optimal
notion of approximation
describe approximation algorithms
metric traveling salesman
traveling salesman problem
precedence constrained scheduling
constrained scheduling problem
definition of approximation
denotes an optimization
minimize this objective
objective function subject
denote the cost
objective function cost
run on instance
instance i produces
produces this objective
objective function value
function value suppose
denotes the cost
reasons will assume
assume that opt
define the approximation
approximation ratio rho
rho on instance
worse than opt
cost in general
value of rho
case by enlarge
worst case ratio
small the goal
design approximation algorithms
algorithms or algorithms
small as close
algorithm is polynomial
polynomial the algorithm
algorithm must run
maximize the objective
define rho sub
small as small
device an approximation
metric tsp problem
first the input
denotes the distance
distance between vertex
form a metric
triangle inequality constraint
draw the metric
draw the graph
vertices are embedded
simply the straight
straight euclidean distance
constraint the triangle
calculate the distances
salesman problem instance
cycle is small
special restrictions tsp
restrictions tsp remains
remains np complete
two approximation algorithm
algorithm for metric
proof in fact
simple the idea
find the lower
out a lower
construct a tour
tour of length
hard to figure
out the length
find a lower
step in turn
claim the claim
minimum weight spanning
weight spanning tree
vertex and returns
minimum spanning tree
tree whose weight
weight and length
connection with minimum
trees and length
length in connection
connection with tours
length and weight
tour is bigger
tour in fact
contained an extra
tree has beat
established a lower
tour and argue
proved our result
tour with length
first we find
dfs traversal depth
depth first traversal
doing the depth
graph the red
starting at vertex
first that appears
repeat the previous
appears several times
vertex that appears
remove these edges
doing this step
times as needed
draw another picture
picture to show
claimed final answer
step is done
takes time linear
linear in fact
eventually we modify
out some properties
edge our tour
work in general
weight and suppose
edge we deleted
picture to explain
two is bigger
repeating this step
initially every vertex
tour every vertex
done the final
nice simple observation
done in linear
delete the first
post order traversal
simply is dominated
problem is precedence
precedence constraint scheduling
find a polynomial
polynomial time approximation
parts the first
directed acyclic graph
graph g vertices
unit time tasks
arc directed edge
restriction that vertex
execute before vertex
number of tasks
output we require
minimize the length
complete for variable
allowed to change
bound i claim
find a schedule
claim the first
first lower bound
path is lower
identify a longest
suppose to measure
measure the length
executed at step
executed one step
steps are needed
bound is based
schedule at step
scheduled at step
case the upper
bound in fact
describe the algorithm
vertex is set
ready or ready
describe the scheduling
algorithm it produces
produces a schedule
scheduled we select
repeat how long
identify this ready
efficiently by doing
doing a topological
sort will suffice
number of processors
restriction about precedence
picking only ready
produce a correct
schedule a valid
sub i denote
denote the graph
vertices after iteration
denote the number
graph is equal
sub i minus
lower bound decreases
find p vertices
step3 of iteration
vertices in iteration
finds p vertices
vertices that remain
case is suppose
idea every longest
ready vertices suppose
path even longer
contradiction the longest
path must originate
including the longest
path must decrease
sub i equal
bound the length
initial lower bounds
first one drops
iteration no bound
bound can drop
path is negative
vertices is negative
steps must suffice
suffice our schedule
replace the smaller
opt the length
today we discussed
discussed various strategies
strategies for coping
problems the strategy
strategy of devising
devising approximation algorithms
defined as giving
giving nearly good
designing approximation algorithms
find lower bounds
find upper bounds
target an algorithm
succeed in meeting
lecture on approximation
two more examples
complete optimization problem
solutions the solutions
gave optimal solutions
solutions in polynomial
prove p equals
people in fact
give optimal solutions
define some notation
cost minimization problem
minimize this cost
big as optimal
optimal as opt
factor on instance
defined was defined
defined as max
produce a small
small approximation factor
words the cost
reason reasonably close
close to opt
set cover problem
describe these problems
give real life
real life examples
problems in addition
idea for solving
solving these problems
greedy strategies earlier
greedy strategies procedure
procedure for solving
make every decision
change the cost
change in cost
increase in cost
subsequently in general
work and today
framework in addition
interesting proof strategy
optimal algorithm running
consists of sets
call this collection
collection this entire
sub i belongs
collection c prime
prime a small
set of sets
minimize the cardinality
version as usual
number of sets
prime with cardinality
complete in fact
find an approximation
arise in real
suppose u denotes
denotes a set
set of villages
hospital is built
determine the smallest
number of locations
exact our sets
constitute the collection
collection as defined
pick a sub
words all villages
correspondence is exact
algorithm is greedy
basically the algorithm
collection our answer
uncovered by covering
inside a set
uncovered elements exist
maximum uncovered elements
maintain some data
elements are covered
put that set
cover those elements
set c prime
elements initially uncovered
elements get covered
end the loop
return c prime
making the decision
include a set
cover maximum elements
nice and simple
simple the analysis
defining some notation
uncovered after iteration
opt to denote
needed by optimal
algorithm to cover
state my main
sub i times
algorithm has executed
sub i elements
covered by opt
equal to opt
sets are covering
covering this region
set which covers
covers n sub
point we choose
choose a subset
covers the maximum
means that number
words n sub
opt by log
log n log
log of log
log n factor
natural the base
opt will return
suppose it runs
runs t iterations
sub t minus
repeating and note
nice little inequality
conclude n sub
opt upon opt
equals opt times
prime is opt
set cover algorithm
find a set
cover the size
handy for indices
indices and things
describe the problem
problem informally first
number of students
question in analyzing
analyzing this data
region is consists
consists of students
build this region
choosing those representatives
choose a representative
representative is chosen
decide to put
put an element
two the thing
clusters are needed
pick the cluster
centers and divide
divide the data
data into clusters
mixed and finding
representatives and defining
defining the boundary
define the boundary
boundary and find
find a center
center the representatives
measure the goodness
number of clusters
describe the output
notion of distances
distances and things
differences as usual
define the distance
two point sets
general arbitrary point
arbitrary point sets
belonging to capital
centers every point
talked about earlier
pick some centers
taking its distance
minimizing this maximum
define the radius
define each cluster
point is closest
clusters are defined
supposed to select
select the centers
select t centers
strategy for solving
select the first
arbitrary but note
interesting greedy idea
first k clusters
first k centers
reduce this radius
idea we pick
points are picked
pick the point
point the distance
point has reduced
1th clustering radius
point after picking
centers we picked
first k points
radius of clustering
change is related
algorithm the analysis
centers are related
clusters a natural
center we select
select two centers
cluster natural guesses
select our clusters
clusters our centers
centers are selected
optimal algorithm selects
call this optimal
cluster o sub
case some optimal
detail in fact
free to give
happen to choose
point is picked
cluster this distance
point in optimal
times the radius
times the max
times r sub
point is close
necessarily the center
times r opt
established the theorem
quality of clustering
clustering produces clusters
clusters of radius
call it capital
center and suppose
taking the distance
allowing a large
happen to fall
two cluster centers
optimal radius produced
centers actually lie
single optimal cluster
inside this cluster
radius of cluster
times the optimal
optimal is greater
equal to distance
turn is greater
greedy algorithm produces
algorithm produces clustering
clustering of radius
times radius produced
produced by optimal
distances i mentioned
clustering algorithm works
satisfies the metric
essentially the triangle
facility location problem
cover like problems
problem many scheduling
problems and important
variation on set
style of analysis
optimal also appears
appears quite frequently
styles of analysis
optimal and compete
design a fair
number of approximation
problems ? iii
series on approximation
algorithms a short
two factor approximation
approximation for metric
matter of fact
hard to find
find fast clustering
fast clustering algorithms
approximate clustering algorithms
tsp it turns
depend upon epsilon
smaller the epsilon
epsilon the larger
larger the running
evaluate that dependence
range of epsilons
definition an algorithm
approximation scheme abbreviated
abbreviated as ptas
return the problem
addition a single
single number epsilon
close an answer
good an answer
return a solution
solution with approximation
approximation ratio one1
one1 plus epsilon
epsilon the smaller
depend on epsilon
polynomial we change
change with epsilon
function of epsilon
family of algorithms
values of epsilon
fully polynomial approximation
polynomial approximation scheme
abbreviated as fptas
increase much faster
describe an fptas
cube upon epsilon
denote the instance
epsilon is linear
satisfies this condition
designing an algorithm
studied it earlier
earlier the input
stands for value
denote the capacity
knapsack the output
select a subset
filling this knapsack
exceed its weight
knapsack will tear
subset we pick
devised an algorithm
based on dynamic
modify the input
good approximate answers
idea the sort
idea of today
instance perhaps sort
dynamic programming formulation
remember the dynamic
basically the question
question the capacity
capacity is fixed
largest possible value
question the question
smallest capacity knapsack
interested in filling
filling all items
needed to fill
kind of question
value for fixed
questions essentially compute
knapsack for value
non decreasing sequence
value for capacity
solve this question
mobilized to solve
algorithm we looked
answer the single
answer more questions
answer different kind
kind of questions
answers as mentioned
idea to return
value of capacity
value the target
target total value
logic behind designing
designing the algorithm
natural looking algorithm
series of decisions
decisions to make
search space idea
solution contains item
set of solutions
sets with value
sets containing item
lightest capacity set
lightest weight set
wanted the optimal
picking the lighter
pick the lightest
pretty much idea
original dynamic programming
expressed in terms
solution of value
left are sets
minus the value
originally had value
remove that item
space are sets
seeking this smaller
problem instance add
add the item
value is negative
generate this part
instance is undefined
put an explicit
expression in terms
define our recurrence
give the value
derived and express
simply this left
allowing all items
add this item
start with items
expression is greater
problem is undefined
represent by putting
compactly in terms
terms of variables
solutions to problems
skip the first
adding an item
weight solution value
keeping a table
out that recurrence
kind of table
out from specific
recurrence will work
table ith column
column vth row
row vth column
entry would fall
common more interesting
entry in general
minimum capacity needed
smallest possible knapsack
entire yellow column
open the question
fill this row
row in general
denoting the capacity
kind of capacities
kind of values
entries ? suppose
value either bigger
bigger or larger
infinite is needed
things like min
values are infinites
value is impossible
impossible to accomplish
express the algorithm
entries to fill
kinds of entries
done our algorithm
call my algorithm
knapsack it takes
takes as arguments
find an answer
filled the blue
knapsack capacity needed
fill the bottom
entries were filled
needed to find
earlier the largest
call v star
wanted the items
additional data structures
return the set
set of items
compute the set
compute v star
finishes the first
allowed an error
epsilon is sort
allowed the point
calculate using low
call an approximate
approximate case approximate
case approximate knapsack
knapsack or aks
argument called delta
reflect the precision
delta and epsilon
array v prime
divided by delta
delta corresponding elements
scale down values
return delta times
job we scale
scale the values
return we scale
produce some error
case is proportional
denotes the set
original ks call
actual optimal value
full precision problem
full precision answer
case without multiplication
multiplication by delta
low precision answer
value is bigger
choosing s prime
words this value
changed the weights
relate x prime
value that aks
aks will return
return ? aks
times this value
multiplied by delta
multiply by delta
explains this part
actual value minus
value minus cardinality
ready to evaluate
evaluate the approximation
approximate solution remember
define our approximation
collect the equality
cardinality s times
evaluation has reduced
choose delta carefully
choose delta equal
equal to epsilon
denotes the maximum
include this largest
times n squared
delta i substitute
matter what epsilon
epsilon you give
input instance length
concludes the main
device another fptas
expression n log
easier np complete
sense knapsack problems
values are drawn
uniformly at random
sense the fptas
easier to approximate
average in fact
problems having pseudo
subset sub problem
algorithms prof
prof abhiram
abhiram ranade
ranade computer
computer science
science engineering
engineering department
department indian
indian institute
bombay lecture
algorithms today
main problems
fundamental question
design algorithms
designing algorithms
give answers
major challenge
fast design
fast algorithms
defined design
design techniques
solve algorithm
algorithm design
design problems
common language
data structures
discrete mathematics
mathematics background
mathematical build
mathematical model
prove properties
proof prove
prove facts
basic framework
fast algorithm
long stretch
involves techniques
designing fast
optimization graph
graph theory
god algorithms
techniques work
intricate theory
main topic
simple problem
common divisor
simple algorithm
first standard
fourth standard
greatest common
simplifying fractions
earliest algorithms
mathematician euclid
plane geometry
simple school
school level
level algorithm
largest integer
finding primes
find break
common factors
state euclid
pseudo language
suitable nicest
nicest syntax
done inside
algorithm works
common divisors
prime factors
test numbers
prime number
level stuff
algorithm back
current value
work done
answer euclid
factoring algorithm
sophisticated algorithm
correct answer
work correctly
large numbers
first step
exchange values
values basically
first iteration
divisions essentially
complicated problem
first glance
bigger numbers
numbers factoring
main idea
largest number
loop part
first argument
partially done
original values
specific value
loop executes
correct value
straight forward
remain positive
loop exits
basic idea
cost euclid
analyzing calls
loop wills
main result
theorem establishes
good upper
upper bound
iterations euclid
euclid takes
thing drops
euclid procedure
dividend divisor
last inequality
original value
small number
main points
first point
definition euclid
interesting deeper
deeper properties
properties deeper
mathematical properties
study properties
analysis counting
counting iterations
precise details
subsequent lectures
lecture design
ranade department
engineering indian
algorithms analysis
algorithm analysis
plain evaluate
mathematical bases
formal framework
evaluate algorithms
varying amounts
memory requirements
discuss today
first lecture
algorithm takes
specific real
real computer
execute algorithm
computer model
basic scheme
first question
answer questions
interesting algorithms
require data
important question
input data
mathematical models
real computers
model relate
relevant questions
basic terms
analysis strategy
discuss examples
discuss limitations
day life
scientific discussion
common term
shortest path
x-ray determine
input consists
western india
india automobile
automobile association
association map
problem definition
word evolution
oxford dictionary
last problem
actual picture
actual map
actual path
actual meaning
good sense
simple definition
valid inputs
acceptable outputs
valid input
gcd problem
constitute valid
acceptable input
path names
map constitutes
acceptable output
make sense
dictionary problem
phrase input
input instance
input value
problem mumbai
mumbai aurangabad
map constitute
path problem
important term
term input
instance instance
problem instance
formal sense
bits needed
specific input
specific size
represent numbers
first place
array bits
represent maps
formal definition
bit inconvenient
informal definition
official definition
formal notion
gcd algorithm
large instance
large size
small size
good algorithm
small instance
great algorithm
small amount
god algorithm
comparison evaluate
good indication
ray problem
phrase problem
problem size
problem directly
computational procedure
term abstract
discussing algorithms
discuss programs
strict language
strict rules
discuss algorithms
clear terms
human beings
precise syntax
describe algorithms
great level
describing algorithms
model machine
important purpose
important point
ram stands
random access
access machine
simplified computer
executing programs
locations start
last number
writing algorithms
ram model
first thing
variable names
location fifty
data types
simple plain
plain simple
simple variables
primitive data
trees lists
instruction set
instructions execute
logical operations
memory add
write programs
friendly pleasant
pleasant manner
conditions jumps
conditional jumps
step defining
structured programming
programming presenting
nice readable
readable manner
extremely important
convenient mechanism
basic instruction
pointer instructions
simply operations
equals star
style pointer
pointer notation
store based
write star
single step
algorithmic actions
step pointers
mixes pointers
treat pointers
similar consistent
consistent manner
array operations
dimensional array
contiguous locations
fixed number
modern computers
basic algorithmic
complex algorithmic
algorithmic statements
complex instructions
elementary instructions
elementary steps
primitive statement
simple statement
machine instructions
entire statement
dimensional arrays
stores elements
first row
row index
column index
stored row
row wise
index set
simple correspondence
plain indirect
indirect axis
structured computing
computing statements
basic constructions
initialization step
loop test
statement number
loop counting
total number
final answer
big letters
steps needed
functions calls
function calls
arguments passed
calling procedure
machine relates
complete analysis
lectures design
indian institution
analysis framework
developing algorithm
framework part
part two
abstract computer
fair detail
model consisted
variables structures
separate program
program memory
performing operations
equals operator
first kind
control instructions
jump instructions
control transfer
transfer instructions
pointer operations
standard array
array axis
single cycle
real compilers
general strategy
single processor
single memory
complicated architecture
standard memory
main memory
cache memory
computer advertisements
register memory
tricky complication
complication arises
tricky idea
designing computers
superscalar execution
simultaneously executed
complicated idea
ram machine
transfer data
memory instructions
instructions memory
register instructions
register copying
copying instructions
drive home
ram suppose
add register
value contained
store register
memory location
memory locations
data stored
first move
real computation
idealized memory
idealized computation
intelligent compilers
simple translator
conditional operations
array elements
first statement
minded translator
similar translation
high level
level language
language statement
statements depending
compiler intelligence
simple compiler
statement translation
intelligent transfer
intelligent compiler
present earlier
write algorithms
algorithm executes
idealized model
language algorithm
language program
big surprise
model applies
general analysis
crucial definition
last lecture
data set
input instances
single number
functions carefully
first remark
conservative definition
input size
worst case
reasonable definition
actual day
equal probability
instances taking
average introduces
extra complexity
solid guarantee
case measure
ram relates
real machines
single instruction
vice versa
compiler technology
question arises
precise value
precise numbers
great consequence
real computations
functional form
linear function
quadratic function
complex functions
precise values
crucial idea
cubic function
exact bounds
lower bound
bound match
necessarily happen
done incomplete
good estimates
large problems
precise constants
computer computers
general idea
matrices output
usual matrix
matrix product
matrix multiplication
natural algorithm
machine ram
analysis ideas
simple structure
complex structures
basic structure
analyze loops
body takes
exact analysis
analysis knowing
model completely
small detail
arithmetic operations
array accesses
cycles totally
single execution
single statement
outer loop
entire portion
loop requires
loop takes
entire program
cube term
number times
individual instructions
basic instructions
first loop
major conclusion
main conclusion
precise architecture
weak statement
strong statement
specific computer
specific pentium
architecture computer
precise computer
computer architectures
making statements
median element
simple program
successive elements
median definition
smaller elements
larger elements
conditions match
equals length
increment smaller
abbreviated style
executed utmost
simple assumption
simplifying assumption
worse case
exit early
entire algorithm
extra step
exit condition
utmost quadratic
worst instance
case analysis
last point
average case
asymptotic notation
topic today
directly applicable
care needed
bit imprecise
entire analysis
entire detailed
detailed analysis
precise number
rough statement
put functions
entire class
formal notation
asymptotic analysis
analysis refers
classifying functions
constant multipliers
constant multiplier
class notation
cube versus
first property
first feature
class definition
main kinds
notation today
theta notation
omega notation
define function
function classes
non-negative functions
negative values
values functions
negative arguments
negative function
exists constant
big definition
class structure
give importance
smaller values
function values
class theta
theta times
sandwich region
constant factor
function belongs
classed functions
suitable constants
constants satisfy
cubic polynomial
polynomial term
naught equals
definition holds
good idea
good thing
classification system
prototypical function
detailed function
constant factors
grows slower
easy task
done earlier
largest determinate
asymptotic complexity
complexity class
previous result
cube theta
write theta
first class
funny style
style evolved
writing style
common writing
assignment operator
value equality
denote inclusion
english language
language words
rose belongs
red things
poetic english
writing functions
names directly
equals theta
unbound variable
nice class
basic definition
essentially constant
minor perturbations
naught omega
non negative
class omega
omega relaxes
bound condition
cube iterations
utmost cubic
first case
unknown function
lower bounds
square belongs
similar logic
ignoring constants
lower order
order terms
main functions
functions classes
general function
mathematics courses
precise result
exact result
weaker results
exact expression
analyze algorithms
real number
positive real
case evaluating
exceptional cleverness
giving bounds
home work
work prove
fibonacci series
real result
actual result
nth fibonacci
fibonacci number
exact bound
exponential growth
easy logic
easy reasoning
number grow
grow exponentially
complicated reasoning
precise formula
nth term
tighter results
compact manner
defined theta
leading terms
general notation
partial information
nicely expressed
prof sunder
vishwanathan department
basic design
simple problems
trivial problems
minimum element
input problem
find min
first programming
standard solution
temporary variable
current minimum
first element
array element
last element
update temp
simple technique
important step
crucial step
full code
main ideas
stray cases
initialize variables
properly etcetera
programming details
things couple
point out
design technique
store value
bigger input
bigger value
fancier things
right order
increasing order
array index
ordering plays
crucial role
previous minimum
variable temp
analyze analysis
analysis pertain
small operations
first reaction
absolutely trivial
fourth element
sixth element
right answer
candidate whichever
longer remains
complete proof
bit hang
hang wavy
make comparisons
program ends
ends terminates
connected component
connected components
give values
global minimum
discrete structure
simple scan
slight variation
max min
minimum elements
algorithm makes
previous argument
small values
values supposing
temporary maximum
unnecessary comparisons
first comparison
left hand
hand side
right hand
left part
right part
maximum minimum
parts divide
equal parts
equal halves
halves halves
left half
final solution
writing details
details define
define procedures
recursive calls
minimum maximum
recursive call
recurrence behaves
usual geometric
geometric series
comparisons made
last century
main steps
equal sizes
final step
original problem
left array
right array
array comparing
maximums find
solve problems
smaller size
big problem
small problems
problems varies
smallest element
temporary variables
variables temp
min case
conquer paradigm
min left
min right
entire array
compare min
supposing min
assume min
point min
side minimum
sub problems
comparison suffices
problems behave
behave differently
conquer sort
paradigm gave
divide recurse
recurse divide
comparisons start
start happening
recurrence sort
reach arrays
maximum case
max mins
bigger tree
familiar complete
complete binary
binary tree
element sits
root node
element resided
crucial sort
absolutely crucial
means log
previous problem
forward application
smart answer
feel nice
nice design
viswanathan department
smaller inputs
larger inputs
first term
term design
design principle
larger input
inputs solve
store values
simple principle
future good
algorithms simple
simple algorithms
parts solve
divide input
input solve
previous cases
instance max
unequal pieces
design principles
simplest sort
first design
practice supposing
smaller array
bigger array
natural smaller
smaller arrays
elements supposing
first sort
right position
binary search
easily identified
make space
point onwards
right move
elements figure
insertion sort
previous courses
learnt insertion
roughly order
order log
mains step
last step
move elements
expansive step
sort takes
takes order
design paradigms
array equally
equally work
halves sort
pieces sort
sorted arrays
step entail
step entails
big sorted
sorted array
sorted pieces
sorted piece
ascending order
bigger structure
fairly natural
first position
first elements
sub arrays
generic step
pointer small
big array
write code
values put
original array
temporary array
merge list
merge step
merge sort
scribble piece
sorted sequences
big sequence
divide step
recursive step
constant times
instance moving
pointer etcetera
comparisons needed
equal size
extra element
total array
merge differently
bit differently
larger arrays
smaller input
total size
smaller element
elements remove
apply recursion
iterative process
process back
writing comparisons
simple reason
log base
times log
conquer business
divide part
start rearranging
previous case
case remember
element landing
parts left
left separately
right separately
sorted right
left portion
right portion
largest element
divided step
two putting
putting things
quick sort
xome element
pivot left
left consists
sort pick
pivot divide
pivot elements
parts recurse
sort dividing
easy putting
sorted order
order remember
remember recall
distinct rank
maximum element
side right
pivot put
pivot sits
pivot turns
middle element
initially falls
starts rising
array sizes
sizes split
usual recursion
conquer kind
recurrences work
algorithmic problem
array find
first non
non trivial
trivial algorithm
smart algorithm
solution design
median finding
sort worked
median fast
sort work
ball rolling
element sort
rank floor
array pick
sorting takes
median faster
instance supposing
exact median
approximate median
approximate medians
element supposing
lose focus
median falls
smaller part
bigger part
size utmost
small part
find depends
minus size
first problem
careful attention
important design
recursive procedure
general problem
problem finding
special case
specific problem
approx median
conquer scheme
recurrence relation
approximate medium
real recipe
finding algorithms
general recipes
problem dependent
light bulb
elements approximate
size remember
median problem
descending order
small groups
order upwards
decreasing order
middle elements
last row
elements sort
20th group
15th group
first group
portion remember
median median
middle portion
find elements
middle row
portion consists
vague disjoint
ideas needed
step put
step carefully
find rank
find element
partition array
array put
cases depending
last case
draw picture
entire distance
right half
entire procedure
procedure works
procedure runs
algorithm write
algorithm call
steps inside
normal structure
step executed
easily done
done find
bubble sort
step finding
group takes
takes constant
whichever side
maximum size
recurrence equation
recurrent recursion
last recursion
previous equation
right constant
original thing
previous statement
inductive step
induction substitute
solving recurrence
recurrence relations
right constants
square design
iii surfing
algorithms merge
sorting algorithms
good question
large family
recursively sort
sorted sub
sorted lists
out compare
sort term
favorite procedure
basic operation
two figure
usual sort
crucial operation
popular sorting
absolutely obvious
comparison trees
comparison tree
basic block
building blocks
large flow
flow chart
flow charts
order output
small flow
array size
run merge
whichever branch
lower things
things return
sorted orders
top level
side returns
list returned
elements compared
smallest elements
internal load
internal node
elements branch
comparisons etcetera
output output
sort tree
written part
entire tree
comparisons branch
branch etcetera
longest root
root leaf
leaf path
critical observations
crucial observations
input order
input orders
orders lead
factorial orders
factorial permutations
factorial leaves
large number
invoke theorems
discrete structures
decision tree
maximum number
base case
binary trees
inductive hypothesis
statement holds
sub trees
apply induction
equals number
inductive proof
taking logs
sort flowcharts
close log
takes maximum
bucket sort
sort radix
radix sort
algorithms differ
significant digit
funny things
significant bit
bit etcetera
fairly interesting
paradigm sort
empty square
left out
side length
squares put
first domino
first tile
square left
entire region
top leaving
big sort
extra sort
crucial thing
inductive process
extra square
corner square
small square
big thing
initial objective
bigger square
smaller squares
induction upwards
big square
absolutely alike
entire big
domino fill
tile squares
computer algorithms
find solutions
smaller sub
larger problem
big input
tiling problem
positive integer
familiar problem
bit integers
square multiplications
high school
school multiplication
multiplication algorithm
applying divide
adding adding
bit numbers
takes alternately
started compare
done divide
spending order
square times
conquer approach
first multiplication
earlier remember
significantly smaller
usual thing
general term
exact formula
half minus
times constant
log based
things cancel
prime times
general manipulations
initial thing
real sort
methods rack
good algorithms
multiplying complex
complex numbers
closest pair
conquer strategy
sorting based
based algorithm
computational geometry
design strategies
strategies applied
square root
usual notion
choosable distances
minimum distance
big question
inductive approach
shortest distance
classic sort
point set
huge big
big star
smallest distance
obvious thing
compute distances
square solution
entire set
radius delta
good shape
chooseful distances
things faster
candidate points
sorting dominates
simpler problem
first check
problem means
parts find
compute delta
left recursively
right recursively
minimum distances
closest set
entire thing
done fast
points line
pair points
right delta
candidate pair
side suppose
speed things
small problem
small examples
examples etcetera
general techniques
good chance
passed algorithm
analytical skills
dividing line
vertical line
line things
straight lines
distance delta
middle point
point lies
small bands
middle line
bridge delta
first observation
fairly simple
square distance
smart thing
small band
centre line
point inside
points clustered
point number
points close
size delta
point appears
points inside
delta square
pigeon hole
hole principle
nice problem
solutions based
smart people
figured out
square problem
maximum distance
distance inside
length delta
small squares
points sitting
sitting inside
sit inside
delta inside
big trick
original picture
implementation smaller
smaller implementation
implementation details
fast remember
window size
window shifts
bottom top
things altered
points altered
left side
right side
last trick
detailed left
points sorted
narrow band
sort idea
window moves
pointer moves
solution recurrence
tree sort
point sorted
coordinate suppose
onetime cost
put order
horizontal line
point lie
big assumption
initial set
small epsilon
points participate
first array
actual procedure
procedure starts
co-ordinates points
initialization phase
phase step
arrays remember
coordinate splitting
input points
coordinate business
natural rate
median value
recurse step
input capital
find points
median minus
prime sorted
similar thing
proved points
prime minus
correct range
return min
pointer manipulation
greedy algorithms
greedy algorithm
greedy techniques
main technique
technique main
main sort
optimum solution
small piece
technique works
bit difficult
optimum output
clear cut
cut guiding
guiding rules
right ideas
basic ideas
greedy approach
basic step
output piece
solution extend
crucial generic
crucial question
local improvement
improvement trick
informal idea
small tricks
bigger hint
matroids theory
linear programming
programming duality
primary dual
dual method
geometric structure
future forget
important algorithm
exchange trick
hand wavy
wavy fashion
generic output
respect optimum
question asked
algorithm proceeds
algorithms forward
partial solution
solution improves
independent set
vertex set
edge set
radio stations
mobile radio
edge showing
independent sets
problem tells
maximum sized
find maximum
group force
wrong vertex
right subset
greedy solution
solution greedy
intuition tells
smallest degree
small degree
neighbors number
produces maximum
size independent
leaf throw
set blindly
vertex exist
proceeds pick
slowly sort
word vertices
back tracking
minimum degree
simple things
maximum independent
tree supposing
thinking process
optimum independent
recursive algorithm
move part
modified input
set remove
fancy computer
hour sort
shorter intervals
entire duration
schedule people
hour slot
final objective
abstract sort
closed intervals
non overlapping
overlapping intervals
people give
funny ways
means number
pick numbers
pair wise
greedy technique
solution piece
solution interval
pick intervals
intervals interval
smallest size
size smallest
smallest span
interval suppose
smallest interval
smallest length
reasonable algorithm
intuition suggests
construct examples
algorithm fails
small interval
large intervals
intervals form
optimum consists
big fellows
big intervals
right thing
pick interval
smallest number
smallest overlaps
first algorithm
pick vertex
vertex throw
interval throw
proceed forward
closely related
intervals overlap
minimum overlap
overlap minimum
minimum number
interval overlaps
mirror image
large overlap
smallest overlap
wise overlap
solution size
first interval
picked interval
algorithm produced
hand optimum
optimum value
constructing examples
complicated algorithms
complicated counter
counter examples
algorithm work
space supposing
case adding
optimum falls
interval means
ends first
interval sends
add interval
iterative procedure
ending times
makes exchange
previous figure
figure supposing
solution remove
smaller set
optimum drops
algorithm finds
algorithm output
greedy strategies
main principle
construct solution
problem piece
main lessons
reviewed main
main point
2nd problem
obvious strategies
problem field
natural strategies
normal human
greedy strategy
strategy works
write system
obvious things
obvious solution
first piece
induction works
optimal solution
call exchange
exchange techniques
proof derive
exchange business
exchange words
algorithm first
first discard
discard intervals
empty set
set start
exchange strict
2nd proof
correctness suppose
algorithm picked
picked intervals
finishing times
starting times
thing suppose
solution suppose
initial intervals
algorithm pick
initial solutions
optimum solutions
solutions pick
optimum present
kolid interval
1th interval
opt solution
smallest ending
algorithm constructor
input set
non-overlapping intervals
scheduling problem
times overlapped
intervals putting
intervals based
first processor
greedy back
back drop
sort intervals
real intuition
choose intervals
order put
first parts
first part
overlapping interval
2nd part
parts working
fact optimum
algorithm partitioned
ends set
text books
trial small
interval put
3rd part
situation happen
2nd scenario
ordering thing
proof works
algorithm develops
3rd interval
previous algorithms
right algorithm
rest put
kth part
algorithm put
last sentence
algorithm produces
order sorting
sorting times
crucial strategy
smaller problem
bigger problem
things induction
works beautifully
frame work
candidate algorithm
algorithm solution
solution improve
memory effect
2nd case
exchange pick
processing times
scheduling problems
processor runs
times schedule
schedule means
first job
3rd job
first finishing
modules job
max minimum
increasing times
complicated problems
greedy perspective
perspective design
fractional knapsack
knapsack problem
algorithms lecture
bugler house
word knapsack
limited capacity
total amount
total profit
fractional part
ordinary house
bugling cake
cake shops
fancy cakes
cakes tune
maximize profit
real occasion
problem formally
profit work
maximize sigma
profit function
real muff
muff greedy
fractional subset
real terms
pick elements
means pick
pick items
crucial decision
order items
decreasing profit
increasing sizes
put profit
size squared
profit squared
possibilities work
work remember
right kind
strategy fails
defined exchange
exchange item
start filling
remains full
epsilon prime
minus epsilon
prime epsilon
epsilon equal
prime equals
times epsilon
profit minus
profit increase
means epsilon
replace part
favor item
calculation tells
profit divided
decreasing scores
first item
top score
entire item
item unit
kth item
last item
maximum score
optimum picks
first index
index exit
optimum increase
lower score
previous sort
first coordinate
picked exist
delta total
total sum
initial things
choose epsilon
prime properly
type size
small thing
proof slightly
exchange idea
trick run
exchange tricks
information transmission
design codes
binary codes
binary string
binary strings
send symbols
huge word
huge sort
sort strings
make things
free symbols
average frequencies
good code
smaller number
lesser number
first symbol
decode decoding
prefix pre
pre codes
pre code
code word
construct prefix
length frequency
frequency times
times length
average length
close connection
crucial things
code words
word left
left branch
right branch
string associate
leaf sets
simple fashion
entire problem
problem properly
free codes
function sigma
large frequencies
sort codes
works either1
put items
largest frequency
heaviest item
good exercise
binaries trees
correct tree
longest height
largest frequencies
tree part
exchange items
tree remains
exchange sub
average height
tree design
variable length
shorter codeword
large file
codeword appears
free code
word occurs
curve codeword
code corresponds
code codeword
traverse left
output prefix
trees fixed
smallest frequencies
smaller frequency
means things
tree things
tree sitting
output supposing
constructed solution
change twist
exchanging part
constructing trees
height times
elements remain
cost remains
contribution change
length root
path inside
sub tree
similar cost
cost sigma
length inside
remains fixed
times sigma
minus sigma
exchanging leads
smaller cost
cost remember
frequencies inside
elements inside
trick tells
trees bottom
slow increase
build slowly
bottom thing
crucial trick
bottom remember
previous exchange
exchange thing
nodes inside
frequencies remain
intermediate stage
algorithm terminates
terminates ease
trees decreases
exchange principle
proof statement
optimum tree
algorithm constructs
means optimum
first stage
optimum case
lowest sub
tree exchange
cost decreased
minimum weights
huffman coding
main thing
solution output
right piece
out pieces
change solution
solution puts
objective function
study metroids
strategies work
good luck
luck design
pattern matching
pattern occurs
text grep
operating system
basic sort
pattern starting
character starting
character onwards
pattern exist
matching character
complete match
text equals
first character
pattern etcetera
patters occurs
match character
starting point
total sort
pattern discover
lecture ends
simple pattern
real exact
exact value
pattern ends
initial shifts
start shifting
start comparing
crucial argument
anymore comparisons
pattern shifted
text matches
good possibility
start comparisons
fellow moves
text pointer
pointer remains
moves forward
match text
match occurred
mismatch occur
mismatch occurs
text moves
mismatch text
text character
earlier cases
matched information
string matches
match information
shift pattern
line highways
text pattern
first mismatch
pattern forget
original pattern
text sitting
largest prefix
larger prefix
prefix matching
pattern dependent
optimal shift
optimum shift
text sort
thing holds
smallest shift
perfect match
longest prefix
proper prefix
defined prefix
initial portions
last portion
largest proper
compute supposing
longest proper
previous step
terms out
match pattern
pattern mismatches
main loop
count number
successful comparisons
out merge
successful comparison
smallest value
largest value
unsuccessful comparisons
discussing pattern
first occurrence
finding linear
algorithm shifted
position starting
match prefix
maximum search
minimum shift
maximum length
yesterdays notes
mismatch ignore
pattern shift
pattern shifting
crucial stack
mismatch onwards
pattern shifts
pointer remain
strictly increase
pattern remains
linear timing
defined earlier
sub string
proof force
design sort
sort principles
favorite inductive
inductive kind
means assuming
thing added
matches algorithm
matches upwards
portion matches
previous character
big portion
shifting pattern
values previously
first shift
shift day
day shift
timing focus
pattern supposing
correct shift
middle part
portion correct
part match
bottom part
top part
similar phenomenon
sounds bit
bit complicated
previous values
pattern forward
input pattern
initial pattern
shifted pattern
separate things
equals pattern
pointers move
move forward
crucial part
shifted value
exceptional case
character match
successful match
unsuccessful comparison
means pattern
maximum value
perfectly correct
bottom pattern
pattern matches
compare start
entire pattern
boyer moore
growth moore
moore starts
last pattern
last character
pattern upwards
matching algorithm
prefix proper
shift value
previous things
previous thing
text strings
patterns compute
values compute
algorithms runs
combinatorial search
discrete object
discrete objects
objects object
constraints find
objects satisfying
lease cost
function defined
real numbers
alternate definition
maximum benefit
benefit find
find object
constraints benefit
set benefit
abstract definition
examples initiately
cost function
benefit function
queens problem
usual chess
chess board
place queens
queens capture
row number
number value
first condition
vertical distance
absolute value
game problem
object function
input consist
kilo grams
total value
selected objects
total weight
combinatorial object
crops call
objects items
selected items
maximization problem
large value
travelling sales
sales person
person problem
weighted graph
map map
world vertices
vertices represent
represent towns
edges represents
represents roads
weight represent
total distance
distance covered
problem relating
sales persons
problem arises
complete graph
undirected graph
problem makes
makes sense
directed case
sales man
outer tour
similar kind
idea today
combinatorial optimization
optimization problems
search problems
imply today
basic strategies
backtrack search
brute force
force search
search strategy
dynamic programming
diff level
level analysis
start talking
strategy today
restricted strategy
search problem
problem search
search strategies
analytical work
programming ideas
simple minded
answer correct
record cost
function found
function founds
current object
object record
slight amount
empty template
first slot
smaller parts
parts comprising
big object
completely empty
first queen
fourth row
entire board
empty board
candidate objects
partially built
built object
object candidate
candidate object
built candidate
full arrange
arrange substance
previous object
fully constructed
higher level
level completion
fourth queen
square bolts
constructed objects
previous level
leaf level
exhaustive generation
generation method
empty object
parent node
generation step
queen position
position satisfy
fact satisfy
leaf objects
objects satisfy
cost functions
programming idea
objects properly
data structure
element array
travelling salesman
salesman problem
travelling salesperson
salesperson problem
array denotes
empty slot
sub sequential
sequential loss
object filled
checks constraints
evaluating cost
back track
track search
last value
value filled
last slot
search procedure
partially filled
slots filled
check constraints
constraints satisfied
leaf found
useless leaf
minus infinitive
function assuming
unfiled slots
branching business
unfilled slot
unfilled slots
filling slots
slots filling
modified object
leaves underneath
smallest cost
first instance
cost values
value generated
cost leaf
structures scores
first search
search space
space search
constraints checks
problem suppose
first column
first wheel
search tree
tree immediately
early conditional
conditional checks
checks condition
condition checks
quick description
empty tour
starting vertex
complete tour
problem specialized
early checks
previous queens
first city
factorial ways
first level
city tour
general method
defined terms
terms likes
likes search
combinatorial explosion
manage level
grand children
study improvements
grand picture
simplest backtrack
search ideas
sophisticated strategies
specialized strategies
optimization problem
problem design
gave examples
general technique
obvious idea
executed systematically
main question
object techniques
constructed object
objects based
complete object
object constructed
minimum cost
cost object
first manner
leaf extra
top node
entire search
natural question
huge number
leaf coming
nodes doubles
pruning heuristic
cost turned
defined object
partial object
important idea
defined suppose
extended cost
interesting property
extending xij
xij suppose
function satisfy
point avail
full object
object found
simple graph
edges weight
outer edge
edges traverse
first explain
first edge
horizontal edge
downward edge
tour starting
diagonal edge
thing left
doing depth
first alternative
towns first
search page
onwards backtrack
total cost
edge length
important assumption
edge lengths
bound algorithm
natural assumption
cost tour
point branch
return back
essentially proved
noting underneath
partial tour
tour is10
exploring things
bound backtrack
suitable cost
fewer notes
small overhead
general branch
reasonable cost
select objects
boundary heuristics
natural cost
natural objective
natural function
maximize total
search work
construct solutions
candidate solutions
step process
empty candidate
complete solution
empty subset
first decision
decision point
first object
firm decision
additional number
beginning fill
make decisions
object whatsoever
real reason
search involves
fact interested
taking subsets
generated subset
proper cost
benefits function
original function
maximize value
rejected objects
small value
applying branch
completely clear
bound tree
selected set
decision consists
acceptable leaf
server capacity
made decisions
search reach
execute branch
exploration underneath
reach underneath
total benefit
interesting thing
method powerful
entire sub
cost subset
keeping track
case branch
good ways
constructed cost
tsp problem
geographical tsp
euclidean tsp
roads correcting
road distances
straight line
line distance
crow flies
road correcting
road code
code wind
direct straight
distance matrix
line distances
constructed earlier
distance added
distance information
final word
cleverness needed
constructing cost
substantial pruning
first issue
great pay
pay offs
highest value
weight ratio
ratio first
explore first
good object
good cost
pruning effect
interesting decision
additional heuristics
internet articles
heuristics works
powerful technique
finds applications
techniques finds
including operations
operations research
signal processing
computational biology
search technique
familiar knapsack
search solution
problem involves
fourth object
object weights
object based
last object
last parameter
first node
first brace
first vertex
similar manner
convention decided
search view
include object
alternate view
minus weight
remaining part
view encourages
original capacity
independent problem
remaining capacity
valuable objects
substantial improvement
order solves
alternate problem
first benefit
main important
important benefits
additional benefit
surprise benefit
exiting benefit
procedure first
undecided object
first thinking
object onward
global variable
global variables
value array
weight array
fairly easy
remaining object
interesting case
case appears
value form
remaining objects
full capacity
bit reduced
minus width
capacity series
recursive implementation
first call
knapsack possibilities
recursion tree
reaming capacity
objects starting
first recursive
call give
give raise
terms give
interesting parts
procedure call
make procedure
tree underneath
default idea
extending solutions
optimized version
remember value
global array
index correspond
first dimension
returning case
first checking
return max
last code
original code
recursive algorithms
recursive estimate
sharper bounds
computer executes
code suppose
line number
give numbers
programs starts
computer write
first entry
execution tree
computer takes
big deal
estimate triples
computer wrote
entry reappears
previous parameters
total length
capacity times
first idea
extending solution
important dynamic
programming step
first dynamic
important ideas
fourth idea
transcript idea
institute technology
longest common
common subsequence
common subsequent
problem consists
means sequence
characters typically
sequence interchange
common subsequences
define subsequence
dropping elements
remaining elements
hidden drop
common sequences
common sequence
long common
lcs problem
strings similarity
dna sequences
common evaluation
miss pelt
pelt word
force algorithm
complicated algorithm
algorithm good
space consists
sub space
space consisting
space explicitly
procedure listed
search spaces
longest subsequent
subsequent belonging
programming stops
results evaluated
write non
call fill
fills entries
key point
table times
entry requires
subsequent problem
subsequences starting
first letter
previous strategy
recursive strategy
longest element
define notation
degenerate case
formal plain
minute ago
longer sequence
original claim
determine smallest
find capital
equals lcs
defining property
nice conjecture
single line
written earlier
original space
general search
call lcs
boundary conditions
index return
return null
null sequence
main case
short form
null strings
basic recursive
programming require
calls happen
nice property
argument pass
first string
terminal index
key idea
form lcs
important observation
important part
programming strategy
solution answers
store lcs
dimensional table
non recursive
define fill
entries suppose
original procedure
starting element
equals smallest
table entry
fill procedure
working out
1th entry
simply done
properly set
bottom row
side column
table entries
filled properly
takes care
simply return
entire things
longer computing
last part
part fill
times max
programming algorithm
simple modification
manner analog
faster result
linked list
entire subsequence
slight trick
matric chain
chain multiplication
informal statement
issues involved
algorithm repeatedly
problem today
clear zone
entire product
simplest algorithm
multiplication matrix
single term
faster algorithm
issue concerns
concerns associativity
compute matrix
scalar multiplication
scalar multiplications
multiplication required
first form
product requires
doing things
rooted trees
usual fashion
drawing vertex
vertex represents
compute product
grows exponential
formal statement
left sub
right sub
product represented
left tree
right tree
additional term
clarify suppose
lost product
term remaining
simple brute
leaf trees
efficient algorithm
quick overview
partitions search
entire space
unusual steps
key requirement
recursive function
leaves note
design scheme
place holders
cost tree
large animal
main property
natural property
main lemma
cost trees
interesting observation
standard dynamic
made earlier
entire expression
basic statement
optimal sub
algorithm mcm
mcm stands
metrics chain
optimal tree
adequate number
matrix multiplications
base cases
single matrix
single vertex
lemma generate
tree optimal
previous lemma
call mcm
optimal right
cost required
two note
expression cost
field selector
root point
additional field
previous algorithm
single element
programming procedure
substituted mcmc
entire part
minimum fit
resulting expression
procedure mcmc
original range
sub range
call mcmc
procedure fill
return mcmc
execute mcmc
basic procedure
last index
case return
compute mcmc
reference mcmc
mcmc fill
right procedure
entry assuming
fill works
table first
simply entries
row kth
kth column
main diagonal
extremely simple
simple order
filling entries
fill entries
entry depends
entire range
single entry
exact tree
holding costs
programming today
working today
startup cost
input clarifying
cost today
machine working
hold units
delivered today
holding cost
main input
daily demand
final requirement
total demand
demand vector
delivered day
production plan
tabular form
seventh day
producing earlier
days machine
previous day
inventory cost
produced yesterday
sixth day
first plan
quick view
repulsive solution
first subspace
recursive solution
filling table
direct procedure
filled earlier
recursive fashion
day problem
typical steps
first day
additional history
history information
generalized scheduling
additional inputs
initial inventory
earlier corresponds
wider range
production schedule
instances characterized
bit vector
bit specifies
startup costs
cost schedule
space sub
sub spaces
cost element
cost solutions
smaller instance
sub structure
structure idea
sub problem
residual instance
original instance
integer vector
problem require
instance beginning
final component
machine status
residual influence
key lemma
optimal schedule
typical argument
programming arguments
remaining days
valid solution
instance right
basic assumption
similar idea
idea works
last component
original elementary
remark claims
algorithm opts
opts schedule
schedule arguments
entire demands
additional argument
current inventory
main core
recursive residual
residual problem
problem assuming
optimized schedule
first schedule
first sub
remaining details
important details
key step
entire input
sub array
array beginning
demand array
terminal sub
largest index
machine produces
last argument
good characterization
bit cumbersome
entire schedules
entire optimal
similar entries
similar number
similar indices
programming requires
table depend
remaining entries
exact computation
lower cost
small smaller
smaller range
schedule false
false concatenated
cost relationship
schedule starts
incurred depends
expression mark
mark true
true value
value colon
colon false
false value
bracket evaluates
inventory subtract
residual cost
mth entry
recurrence connecting
nice fix
simple fix
negative number
entire cost
infinite negative
negative numbers
positive number
number earlier
final problem
base keys
relate entries
last day
day schedule
single day
legal schedule
main condition
valid schedule
last demand
anymore units
nth day
style expression
inventory greater
last column
days side
filled out
simple ideas
recursion part
days calculation
entire table
optimal cost
false side
entire demand
final topic
expression involving
residual plan
entire schedule
interesting step
device recursive
problem formation
medium finding
arc smallest
similar issue
first basic
usual definition
popular definition
usual measure
inputs behave
worst input
analysis worst
analysis turns
sort quick
sorting algorithm
excellent performance
algorithm quick
smallest keys
case first
first key
single list
call large
proper lists
small elements
call qsort
elements sorted
list equal
long list
sort works
division part
interesting work
conquer part
combined part
trivial correctness
easy exercise
average cases
worst cases
calling quick
evoking quick
list large
invoking quick
list small
basic recurrence
small list
large list
large part
thing terminates
list terminates
size adds
total work
size added
sorted list
key question
unusual case
real question
large height
small height
tree height
total height
turns out
simple situation
size halves
homework exercise
artificial case
node problem
key problem
uneven distribution
terminate quickly
tree multiplied
largest problem
level problem
problem level
level size
rightmost branch
largest size
problem drops
good news
middle case
first intuition
systematic analysis
allowed inputs
taking averages
factorial instances
separate groups
input space
entire group
inputs split
small set
sorting permutation
equal elements
equal element
last group
clever data
key observation
first space
recursion induction
alternate method
write recurrences
interesting counting
comparisons performed
important operation
added elements
comparison operation
case input
complicated index
input permutation
cells blank
average number
question directly
first permutation
first input
separate lists
picked suppose
current list
bit slowly
factorial times
comparisons happen
slightly differently
good estimate
times sum
table list
factorial columns
average running
natural base
natural logarithm
matter log
rth smallest
bipartite maximum
maximum matching
matching bipartite
bipartite graph
graph matching
obvious goal
goal assign
assign candidates
matching problem
mathematical terms
first define
candidate problem
vertex sets
vertices forms
blue edges
blue edge
blue matching
sized matching
red matching
size matching
edges maximum
maximum matchings
jobs problem
first set
jobs assigned
red matchings
design idea
augmenting paths
important concept
matching area
clean simple
correctness depends
winded idea
larger size
natural thing
greedy idea
adding edges
add edges
produce conflict
kho kho
kho idea
starts running
starts chasing
opposing team
free vertex
end point
idea first
free edge
edge include
bigger matching
free vertices
case vertex
edges incident
conflict conflict
color code
color green
show edges
removed remember
yellow edges
green edges
matching earlier
matching attached
longer remember
yellow edge
yellow color
kho sort
entire process
added edge
removed edge
interesting pattern
edges alternate
removed edges
augmenting path
last vertex
extra edge
intermediate vertices
backward edge
forward edge
symmetric difference
symmetric matching
edges form
paths play
big role
eminent computer
computer scientist
previous century
empty matching
current matching
theorem attributed
theorem justifies
rule out
hands matching
first claim
union forget
interesting fact
consecutive edges
cycles inside
alternate edges
bigger size
cycles first
cycle consists
equal number
last edge
additional edge
red edge
maximal path
black edge
last end
end points
path exists
proves berge
proved berge
path starts
path started
interesting idea
grow backwards
free node
grow paths
forward direction
backward direction
description nice
earlier graph
directed graph
augmented path
graph notice
putting directions
auxiliary graph
original graph
prime consists
forward edges
hand set
side vertices
backward edges
directed backwards
directed forward
put edges
main claim
directed path
important notice
finding augmenting
augmented paths
significant claim
specific graph
part first
previous graph
previous picture
analogous edge
prime note
path users
users edges
fact present
oriented properly
path direction
proper orientation
directed edge
path procedure
return path
adjacency list
list representation
bfs bfs
bfs breadth
search takes
procedure augmenting
part deleting
matching size
concluding remarks
iterative refinement
small change
fastest algorithm
non bipartite
bipartite graphs
similar bounds
bipartite case
basic question
designed supposed
valuable result
specific algorithm
proportionality constant
form omega
main motivation
general discussion
prove problem
decision trees
case instance
case bounds
case times
inequality holds
constructing instances
construct instances
good value
size instance
instance size
bound function
algebraic statement
additional quantification
minimum worst
bad instances
instances instances
problem sizes
trivial lower
large applies
interesting problems
non-trivial bounds
access machines
machines ram
proving non
trivial bounds
single problem
algorithms enumerating
structured fashion
tricky business
instructions ram
complicated things
trigonometric functions
ram instructions
control flow
flow pattern
ram program
pretty difficult
ram programs
typically done
computational model
flow patterns
computational models
fairly small
good model
worried worry
labeled tree
non-leaf node
label means
model first
relational operators
operators leaf
leaf node
node labels
program tree
tree model
execution model
model begins
node labeled
relational label
label present
outgoing edge
unique path
follow outwards
execution arise
execution starts
instruction represented
sorting program
instance notice
longest path
setting likewise
leaf paths
average root
path length
nice graphical
graphical interpretation
main claims
trivial bound
ram sorting
comparison based
heap sort
shell sort
based algorithms
tree algorithms
based ram
tree sorting
key comparisons
final claim
trivial result
inverse permutation
holds good
key insight
algorithm tree
outgoing edges
mentioned earlier
tree node
ternary tree
keys number
equality edge
strict inequality
inequality branches
relates comparison
ram algorithm
edge labels
key values
read things
control structure
key value
peeps inside
examine first
actual numbers
start execution
comparison outcomes
general pattern
super tree
path outwards
tree algorithm
ram algorithms
claim tells
single claim
case complexity
distance log
similar arguments
prove bounds
bounds follow
power log
larger distance
minus square
easily proved
average path
length average
total path
length log
factorial drop
result shows
important application
main operation
bigger ranges
slight modification
concluding remark
finding duplicates
study merging
merging problems
study problems
general model
allowing comparison
arithmetic incident
bound model
bound results
element distinctness
previous lecture
entire sequence
individual numbers
answer means
prove today
compare adjacent
adjacent numbers
bound technique
bounding technique
nice technique
powerful model
algebraic decision
input instructions
label tree
non leaf
leaf nodes
program leaf
tree program
relational operator
execution begins
machine model
model comparison
simply algorithms
make copy
sorting problem
key thing
bound argument
sorted sequence
single leaf
single answer
entire permutation
permutation constitutes
execution arrives
print out
rough sketch
factorial possibilities
information theory
high information
information content
information quantity
theory measures
measures information
theoretical lower
theoretic lower
distinctness problem
duplicate exist
silly bound
interesting argument
dimensional geometry
algebraic argument
claim means
claim asserts
input sequence
dimensional point
nth coordinate
thing represents
sequence consist
distinct elements
trivial permutation
pre reorder
key claim
entire proof
distinct leaves
dimensional space
unit cube
entire interior
size two
diagonal simply
dimension distinct
geometric view
view point
interesting insights
unit square
connected means
connected region
convex region
line path
path passing
stronger requirement
line paths
convex regions
convex objects
sphere examples
line joining
kidney shaped
shaped region
line passes
convex means
instance belongs
condition satisfied
entire unit
instances visiting
root constitute
entire cube
wedge shaped
current set
slicing region
convex manner
slicing operation
operation maintains
maintains convexity
first execution
interesting execution
lambda times
minus lambda
remaining weights
case lambda
line segment
segment joining
segment line
key part
definition set
restrict lambda
lie inside
root label
inequality lambda
first root
distinct values
permutation sigma
previous claim
sub claim
continuous path
continuous function
value theorem
basic claim
repeated identically
increasing sequence
non increasing
distinct permutations
distinct permutation
quick summary
instance space
instances partition
quick definition
model consists
outgoing branches
algebraic expressions
square minus
label expression
lies inside
previous results
disconnected regions
deep result
algebraic geometry
decision problem
distinctness suppose
algebraic expression
fixed constant
answers partition
connected regions
simple decision
appears inside
complicated algebraic
algebraic model
algebraic tree
fixed degree
proof idea
heavy duty
duty machinery
high degree
bound theory
start searching
interesting point
deep mathematics
deep area
simple context
equal weight
ideas expressed
motivation introduction
notion effectively
dream job
company pays
software job
designing things
challenging projects
first project
scheduling jobs
positive integers
takes input
last job
job finished
odd jobs
large jobs
job completes
process finishes
job finishes
first process
lightly loaded
greater assume
break ties
boss shows
boss produces
optimal takes
job sizes
schedule takes
loaded processor
previous sizes
subsets compute
maximum pick
boss feeds
minutes pass
hour passes
small inputs
force approaches
quick calculation
fastest computer
computer runs
overestimate computers
fastest speeds
boss figures
bit intelligent
hard problems
companies handle
good programmer
sub routines
edges share
ticked edges
perfect matching
graph slightly
crosses form
problem perfect
sub routine
routine library
routine coded
problem maximum
good implementation
max matching
maximum set
intermediate objective
vertex connected
added vertex
extra vertex
matching fellows
single region
minus vertices
vertices inside
matching inside
integer right
contradiction supposing
matching matching
portion remains
define graphs
first graph
edge back
resultant graph
size falls
designed algorithm
ended design
reduction means
solved problem
graph output
problem solving
solve problem
word reduction
essential method
efficient problem
problem algorithm
problem find
efficient problems
efficient means
inefficient algorithm
reasonable size
size inputs
inputs finishes
reasonable amount
force algorithms
solution sets
entire solution
solution space
typical times
instance sorting
square bounded
cube shortest
path finding
finding minimum
minimum spanning
spanning trees
running times
life times
cube log
lets assume
times running
algorithm runs
hamiltonian path
hamiltonian cycle
hamiltonian paths
hewlett packard
clear notion
cycle design
hamiltonian circuit
bit smarter
proved statement
path constructs
cycle routine
small modification
usual trick
trick feed
hamiltonian part
similar problem
input graph
remove edges
remove edge
edge graph
middle vertex
edge supposing
edge choose
lets remove
middle edge
graph leads
reasonable thing
additional vertices
circuit supposing
circuit pass
cycle passing
notice supposing
path supposing
edge attach
fact correct
add vertices
edge add
extra vertices
path algorithm
efficient first
path routine
original running
cases case
algorithm outputs
equivalent statement
edge removal
input output
input question
maximum weight
form input
single bit
output spend
instance edges
cycle problem
cycle input
call decision
decision problems
call search
write decision
problem output
cycle output
problems relate
out people
thing output
routine outputs
original routine
output things
efficient algorithms
edges remaining
spurious edges
edges floating
out edges
decision version
search version
social decision
decision word
decision versions
favorite hamiltonian
hamiltonian problem
limited resources
limited resource
verifier sort
lets sitting
huge graph
right statement
edges make
verifier asks
proving things
things proving
prover verifier
verifier game
output factors
trivial integers
find factors
search question
decision question
trivial factors
prover sends
guy asks
sends edges
guy verifies
difficult question
force method
behave sort
differently design
forget algorithms
verifier meet
graph form
prover supplies
supplies edges
verifier verifies
form hamiltonian
input side
proof consists
problem hamiltonian
verifier verify
helps verification
prover means
problem composites
give verifier
verifier checks
people sort
recent research
difficult thing
thing supposing
graph takes
exhaustive technique
input behaves
easy proof
verifier check
verifier receives
circuit case
composites case
real life
life fall
class defined
central problem
done logic
boolean circuit
boolean variable
takes value
takes values
true false
usual logical
clause evaluates
boolean formula
usual symbol
cnf stands
conjunctive normal
normal form
clause remember
logical behavior
true evaluates
formula evaluates
negation evaluates
literals evaluates
clauses evaluate
special boolean
boolean formulae
call cnf
general boolean
assignment assigns
assigning values
assign values
formula satisfied
sat stands
prover give
input formula
satisfying assignment
special problem
steven cook
person steven
important theorems
includes factor
class empty
proved statements
algorithm implies
efficient solution
hardest problems
hand proving
bit simpler
sat supposing
small subset
output find
subset find
largest subset
largest clique
identify problems
first find
clique size
design algorithm
largest cliques
cliques size
clique problem
quick recap
defined problem
formula satisfiable
value true
problem sat
words satisfiability
solve sat
state cook
complete problems
define problem
problem clique
state input
black box
algorithm clique
routine feed
literal clause
literal pair
literal appears
end parts
clique remember
literal belongs
vertices edge
edges flow
quickly sort
satisfying assignments
vertices set
instance sat
set decision
set problem
graph find
problem independent
vertices form
form independent
step assuming
dependent set
independent sub
graph feed
set sub
vertex cover
computer network
nodes pick
vertex covers
minimum size
version remember
extra positive
cover input
minimum vertex
find vertex
adding vertices
large vertex
usual game
subset subset
edge checks
chosen clique
chosen satisfiability
right sort
set supposing
form edges
assumed remember
out cook
sat sat
restricted form
maximum vertex
vertex degree
additional constraint
max degree
maximum degree
hard problem
problem turns
cover problem
problem vertex
cover thing
guess vertex
previous construction
easy supposing
vertex degrees
degree greater
main trick
degree reduction
decreased vertex
rough idea
final graph
cover size
cover remain
cover remove
cover remains
case case
split vertex
cover rises
initial graph
graph start
start splitting
vishwanathan computer
varying degrees
large vertices
large degree
split operation
splitting vertices
thing runs
maximum times
split occurs
graph right
edges right
results size
ways supposing
algorithm worked
worked out
exact cover
sub collection
null set
sub sets
covers set
problem exact
prover tells
verifier takes
blind thing
natural sort
correspondence right
picking vertices
cover edges
edges corresponds
picking subsets
covering edges
sub set
fixed easily
extra elements
trick force
edges sum
exercise remember
distinct subsets
typical set
edges adjacent
adjacent incident
cover consist
point choose
smaller end
point supposing
collection edge
empty subsets
non empty
subsets times
large right
polynomial type
extra cover
first show
installment design
subset sum
size right
subset sums
sizes verifies
algorithm construct
cover frame
frame model
model construct
convert input
pick subsets
cover elements
sum input
subsets sum
input right
side corresponds
small switch
multi set
set multi
element occurs
assign sizes
give sizes
dot dot
general generality
element case
case supposing
good bound
exit exist
size capital
straightforward generalization
set cover
elements right
collection good
fix sizes
size sum
first fixing
fixing sizes
fix size
cover supposing
sum sum
reverse direction
direction pick
set sum
small calculation
fairly easily
reasonable values
belongs right
first partition
equals sum
solve subset
parts supposing
sum problem
partition right
problem put
set set
land land
formal proof
cook told
direct sort
independence set
smallest supposing
solve partition
original set
boss gave
complete design
approximation algorithms
np complete
complete problem
life situation
problems arise
finding fast
fast approximation
devising algorithms
life application
life problem
additional features
special cases
special features
normal definition
unary number
unary representation
representation system
bit difference
binary representation
integer capacity
description applies
weight value
bit string
bits long
bit binary
binary number
constant power
worth noting
out lots
algorithms run
discover algorithms
solving problems
good heuristic
last idea
problem takes
life problems
problems tend
today computers
device algorithms
optimal solutions
approximation ratio
approximation factor
describe approximation
metric traveling
traveling salesman
precedence constrained
function subject
minimization first
solution found
function cost
function value
value suppose
technical reasons
ratio rho
natural definition
cost found
rho sub
case ratio
design approximation
define rho
turn out
approximation algorithm
metric tsp
problem first
additional structure
final thing
triangle inequality
inequality constraint
straight distance
indirect distance
metric problem
euclidean plane
euclidean distance
shorter distances
metric property
properties mentioned
graph passing
tour length
special instance
special restrictions
restrictions tsp
tsp remains
scheme appears
length opt
optimal tour
easily computable
minimum weight
weight spanning
spanning tree
weight matrix
spanning path
case weight
synonymously weight
dfs traversal
traversal depth
sequences return
red edges
first appearance
direct edge
perfectly understandable
vertex appears
short circuit
short cut
original tour
prims algorithm
depth first
fairly straightforward
good tour
important claim
main part
previous vertex
side essentially
straight path
cross path
vertex appeared
final issue
nice simple
simple observation
last appearance
graph search
post order
order traversal
precedence constraint
constraint scheduling
acyclic graph
represent unit
arc directed
first lower
longest paths
vertex length
precedence constraints
ready vertex
scheduling algorithm
procedure sched
entire graph
ready vertices
selected vertex
topological sort
correct schedule
graph induced
unscheduled vertices
bound decreases
predecessors whatsoever
vertices suppose
hand schedules
paths starting
initial lower
first bound
bound drops
last iteration
negative starting
times opt
devising approximation
good solutions
designing approximation
studied today
upper bounds
easily identifiable
quickly today
complete optimization
give optimal
cost minimization
minimization problem
call opt
optimal algorithm
general framework
devise algorithms
small approximation
center problem
life examples
strategies earlier
strategies procedure
interesting proof
proof strategy
algorithm running
denote union
entire collection
small collection
original connection
additional target
sets allowed
simple reduction
small application
villages suppose
natural problem
build hospitals
picking sets
answer eventually
initially uncovered
basic loop
uncovered elements
elements exist
prime union
recover elements
ground set
pick sets
covering elements
cover maximum
maximum elements
basic algorithm
sets needed
simple claim
proof work
opt sets
opt elements
set covering
set covered
greedy property
elements remaining
iteration minus
minutes ago
sets returned
opt times
prime elements
return opt
factor worse
return cardinality
algorithm run
power minus
left uncovered
equals opt
words cardinality
cover algorithm
informally first
region consists
interesting statistically
entire distribution
important thing
farthest element
farthest distance
cluster centers
finding representatives
bit hard
largest radius
clustering problem
input parameter
clusters desired
good notion
coordinate differences
point sets
general arbitrary
arbitrary point
pay attention
closest center
closest centers
closest distance
point belongs
clustering algorithm
first center
interesting greedy
farthest point
simple idea
1th point
clustering radius
1th clustering
important facts
clustering change
optimal strategy
centers selected
center selected
optimal clusters
natural guesses
optimal cluster
algorithm selects
centers picked
analyze case
algorithm happen
choose center
pick point
max radius
optimal clustering
sub opt
wanted surprising
final clustering
fact established
clustering produces
produces clusters
radius produced
final radius
optimal radius
single optimal
produces clustering
times radius
main theorem
entire exercise
euclidean property
euclidean distances
metric properties
facility location
location problem
important problem
crew scheduling
fair number
short review
factor approximation
metric clustering
interesting kind
fast clustering
clustering algorithms
accurately cluster
approximate clustering
wide range
approximation schemes
study today
approximation scheme
scheme abbreviated
conditions hold
problem answer
number epsilon
ratio one1
polynomial approximation
reduce epsilon
increase polynomial
studied earlier
cube times
nth item
weight capacity
valuable subset
problem earlier
exact algorithm
good approximate
approximate answers
pseudo polynomial
exact instance
approximated instance
answers fast
programming formulation
knapsack capacity
fixed capacity
individual question
lightest knapsack
smallest capacity
capacity knapsack
capacity needed
complementary question
fixed value
non decreasing
decreasing sequence
size required
single question
target value
target total
knapsack size
include item
space idea
big instance
knapsack capacities
feasible solutions
lightest capacity
capacity set
lightest weight
weight set
lightest set
smaller weight
lightest solution
original dynamic
smaller value
add item
instance add
slight catch
explicit check
first solution
capacity solution
first expression
subscripted expressions
general case
general expression
value required
value require
weight solution
solution value
entire term
defining recurrence
recurrence means
specific entries
column vth
vth row
row vth
vth column
entry filled
bottom right
entries filled
minimum capacity
smaller knapsack
entire yellow
yellow column
pick item
single item
value larger
capacity infinite
nice thing
nice coding
yellow entries
blue entries
blue entry
older algorithm
additional pointer
additional data
nested loops
first task
approximate algorithm
low precision
approximate case
case approximate
approximate knapsack
factor delta
return delta
delta times
good solution
set returned
actual values
optimal set
actual optimal
optimal value
full precision
precision problem
precision answer
difference set
acceptable solution
feasible solution
prime problem
number minus
delta minus
aks returns
value correct
cancelled out
minus delta
constant delta
minus cardinality
times delta
value returned
actual value
value minus
returned value
approximate solution
solution remember
equality inequalities
exact evaluation
choose delta
delta carefully
clever choice
epsilon times
substitute delta
max times
max denotes
maximum item
largest item
instance length
practical situations
sense knapsack
knapsack problems
fptas result
subset sub
design
analysis
algorithms
prof
abhiram
ranade
computer
science
engineering
department
indian
institute
technology
bombay
lecture
overview
today
introduce
main
problems
give
convey
spirit
start
fundamental
question
problem
solve
easy
cleverness
needed
designing
fast
answers
quickly
major
challenge
goal
realize
computers
cars
clothes
art
sense
creative
taught
defined
techniques
evolved
purpose
study
lots
exercises
apply
ideas
hope
end
algorithm
encounter
life
prerequisites
state
familiar
programming
done
amount
common
language
scheme
basic
data
structures
discrete
mathematics
background
elementary
approach
analytical
build
model
mathematical
properties
point
reason
important
mathematically
prove
emphasis
proof
speed
facts
number
things
lectures
develop
framework
define
means
embark
fairly
long
stretch
involves
doing
surveying
optimization
graph
theory
geometry
turn
out
respond
god
work
beautifully
intricate
developed
last
year
years
completeness
studying
topic
formal
simple
trouble
understanding
right
numbers
find
greatest
divisor
understands
learnt
school
first
standard
fourth
simplifying
fractions
earliest
invented
mathematician
euclid
plane
invent
intuitively
understand
faster
level
talking
clever
makes
exciting
begin
factoring
basically
steps
write
input
integers
largest
integer
divides
leaving
reminder
step
factorize
finding
primes
call
times
break
factors
note
factor
separately
identify
multiply
return
result
minute
procedure
arguments
pseudo
picky
clear
perfect
express
suitable
nicest
syntax
meaning
detail
check
divide
calculate
remainder
mod
set
equals
inside
loop
eventually
terminate
terminates
value
fact
works
divisions
taking
remainders
factorizing
divisors
examples
small
equal
product
prime
idea
test
2.so
remains
factorized
thing
leaves
terribly
difficult
stuff
contrast
bring
back
doe
enter
words
takes
originally
iteration
ended
left
answer
exit
current
returning
compare
roughly
factorizations
collect
hand
division
divided
checked
found
false
simply
exchanged
summarize
calculated
quick
immediately
sophisticated
proved
correct
show
correctly
large
happen
suppose
written
compute
exchange
values
started
order
repeat
began
beginning
matter
setting
execute
exited
returned
happened
iterations
summary
quitting
essentially
complicated
glance
require
checking
dividing
involve
substantially
bigger
harder
lot
case
smaller
argue
divisibility
leave
exercise
mention
manner
substitute
similar
part
checks
calculates
term
sets
argument
precisely
correctness
partially
accomplished
maintain
original
invariant
specific
change
executes
preserve
established
curiously
continues
remain
notice
straight
forward
examine
executing
initially
calculating
changed
continuously
decrease
decreasing
positive
conclude
exits
proves
runs
assume
cost
wrote
make
internally
exchanging
spent
good
execution
analyzing
adds
assumption
calls
kind
wills
distinction
variables
sum
halves
stay
implication
theorem
establishes
drop
log
base
put
upper
bound
estimate
process
drops
rime
ratio
terms
computes
addition
concerns
strictly
dividend
wanted
align
algebra
add
inequality
adjust
shown
showed
reduced
two-thirds
concludes
highlight
points
difference
definition
interesting
deeper
quantities
computing
helps
counting
rest
precise
details
cover
subsequent
marks
solving
kinds
plain
evaluate
sound
bases
designed
comparing
primarily
resources
varying
amounts
memory
discuss
formally
requirements
programs
related
bit
mentally
involved
real
imagine
questions
naturally
assign
operations
comprised
required
operation
perform
giving
extremely
general
depend
models
relate
conclusions
care
relevant
answered
nicely
finish
development
talk
discussing
semi
present
strategy
finally
discussion
limitations
draw
alternate
gist
day
scientific
fix
meanings
confuse
fallacies
motivate
gcd
two
shortest
path
map
word
dictionary
x-ray
determine
disease
typically
supplied
output
generated
consists
city
mumbai
aurangabad
supply
western
india
automobile
association
evolution
oxford
actual
ray
picture
specification
valid
inputs
constitute
acceptable
outputs
looked
earlier
names
cities
constitutes
description
phrase
instance
size
necessarily
stick
bits
represent
clarify
36x
place
represented
binary
length
concerned
ways
representation
thought
matrix
array
maps
inconvenient
directives
settle
informal
informally
parameter
grows
official
growth
predicable
notion
making
analyzed
interested
expect
increase
natural
fair
potentially
roads
road
short
great
comparison
indication
convert
resolution
million
denote
hear
directly
commonly
literature
abstract
computational
produces
expressed
program
expression
rise
languages
concrete
eve
ocean
rigid
strict
rules
worrying
happy
human
beings
worry
describe
progresses
abbreviate
descriptions
met
describing
mind
machine
analyze
issues
ram
stands
random
access
simplified
parts
processor
correction
locations
convenient
minus
location
address
assigning
writing
pleasant
addressed
variable
contained
stored
fifty
variety
types
arrays
sort
primitive
course
trees
lists
built
store
separate
mix
instruction
instructions
simplicity
four
groups
group
arithmetic
logical
allowed
contents
deposit
friendly
operands
conditions
jumps
conditional
correspondingly
greater
defining
wondering
stage
comment
suggest
recommend
intended
read
structured
presenting
nice
readable
machines
mechanism
cycles
pointer
form
star
style
notation
fetch
based
pointers
executed
single
algorithmic
actions
mixes
treat
consistent
dimensional
declared
usual
contiguous
similarly
structure
components
coming
described
told
collection
fixed
modern
complex
statements
statement
rule
count
expressions
element
translated
computed
entire
multi
decide
top
rows
columns
stores
elements
row
indexed
index
column
simulate
wise
possibilities
picking
accessing
remember
correspondence
corresponds
reading
accounting
thinking
estimating
subtraction
subtract
multiplication
indirect
axis
translate
constructions
translation
initializing
initialization
fetching
discussed
jump
code
interest
body
total
extra
final
big
letters
functions
function
passed
pretty
reference
modify
modifications
calling
relates
reality
complete
features
institution
developing
remind
implicitly
understood
consisted
include
performing
operator
control
transfer
cycle
outline
compilers
sake
differs
unlike
architecture
cache
heard
advertisements
registers
register
tricky
complication
arises
days
pipelining
simultaneously
stages
superscalar
scope
extent
complications
memories
system
copying
computation
illustrate
drive
home
load
added
stress
deal
move
idealized
differences
intelligent
lines
translator
operate
extract
fragment
loaded
temp
compilation
minded
changing
noticed
high
sequence
depending
compiler
intelligence
modified
capabilities
surprise
applies
careful
application
measure
maximum
crucial
sub
noted
instances
sorting
principle
earth
goodness
evaluating
job
carefully
remarks
remark
conservative
significant
worst
average
reasonable
averaging
turns
enumerate
probability
introduces
complexity
solid
guarantee
pointed
rams
correspond
vice
versa
consequence
computations
functional
linear
quadratic
square
cubic
shape
independent
run
characterizing
pick
depends
exact
bounds
lower
match
live
incomplete
bridging
subject
research
customary
estimates
larger
worse
constants
1000x
justified
bad
matrices
summation
loops
entry
dimension
close
typical
chosen
concluded
knowing
feel
painful
completely
paying
attention
accesses
totally
forget
outer
reverse
additional
portion
comprises
assignment
formula
requires
plug
squared
cube
made
mistake
individual
storing
position
recalculate
conclusion
exactness
restrict
sounds
qualitative
weak
justify
claim
constant
strong
pentium
architectures
cubical
methodology
simpler
median
appears
middle
utmost
successive
satisfies
initialize
increment
ends
lesser
matches
abbreviated
focus
fewer
early
business
finishes
figure
condition
situation
distinct
importance
asymptotic
context
goals
results
applicable
interpret
predict
imprecise
throw
detailed
arrived
interpretation
rough
class
classes
systematic
speak
classify
refers
classifying
behavior
putting
belong
multipliers
multiplier
ignore
desire
versus
property
feature
theta
capital
omega
series
non-negative
non
negative
resource
occasion
exists
naught
true
requirement
bothered
worried
sandwiched
plot
occupies
region
caring
lie
sandwich
bracketed
multiple
behaves
belongs
reassure
enable
basis
concluding
member
classed
raise
cubes
keeping
satisfy
legitimately
illustrates
connotation
polynomial
funny
holds
fully
increases
negligible
compared
classification
representative
prototypical
ignoring
slower
dominate
exhibit
task
conversant
slightly
power
degree
difficulty
message
determinate
belonging
verify
returns
understandable
previous
surprising
nicer
intuition
badly
abused
tradition
equality
inclusion
english
rose
red
verb
guess
poetic
unbound
emphasize
satisfying
minor
perturbations
definitions
exist
refresh
relaxes
bounded
argued
imply
establishing
unknown
expressing
knowledge
guessed
union
intersection
logic
cares
surprised
serves
dominated
courses
weaker
grow
instructive
puts
implies
observe
starts
exceptional
stated
identical
persuade
fibonacci
root
nth
proving
exponential
reasoning
exponentially
tighter
lack
compact
capture
equivalent
leading
notations
partial
information
sunder
vishwanathan
basics
solutions
trivial
minimum
min
solution
temporary
updated
scan
update
technique
powerful
list
varies
full
stray
cases
properly
etcetera
solves
couple
induction
recursion
explain
ordering
supposing
solved
extend
recurse
mother
learn
fancier
crux
increasing
plays
role
future
combination
pertain
leads
comparisons
incrementing
reaction
people
logically
absolutely
easily
assuming
sixth
odd
ceiling
candidates
rid
previously
equally
whichever
candidate
longer
hang
wavy
rigorous
nodes
vertices
circle
edge
drawing
edges
connected
component
surely
global
finished
slight
variation
max
impossible
maintaining
repeated
roll
aim
unnecessary
trick
minimums
side
bother
applied
recursively
worth
half
maximums
explanation
essence
fill
procedures
recursive
maxs
floor
recurrence
easiest
open
pattern
1plus
geometric
method
mechanically
improved
drastically
conquer
british
century
sizes
blindly
smallest
paradigm
paths
loss
generality
thrown
lost
suffices
equations
asked
behave
differently
gave
unfold
recurrent
avail
happening
bottoms
reach
pushed
mins
tree
levels
portions
sits
wins
finds
traverse
node
leaf
resided
observation
win
follow
front
optimum
shows
hard
smart
viswanathan
generate
indices
vary
discard
considered
pays
breaking
unequal
pieces
encourage
principles
simplest
cluttered
practice
search
identified
sorted
insert
space
onwards
insertion
dealt
faced
mains
movement
shift
units
expansive
implemented
avoid
paradigms
play
piece
sweat
implement
entail
ready
leisure
entails
combine
merging
ascending
occur
occupy
places
pointing
generic
filling
create
merge
scribble
paper
sequences
moving
quantity
floors
ceilings
ease
calculation
figuring
filled
vociferous
shaded
removed
iteratively
decreases
remove
unroll
iterative
replaced
continue
choose
studied
rearranging
picked
arbitrarily
landing
sorts
split
pivot
xome
spend
rank
recall
partition
fits
wrong
center
expand
falls
falling
rising
manage
pivots
asks
implementation
efficiently
provided
desirable
proportionally
higher
situations
recurrences
beauty
worked
recursed
crucially
ball
rolling
objective
wall
approximate
medians
sit
lose
partitioning
shrunk
pay
encountered
special
easier
tackle
undone
approx
relation
medium
recipe
recipes
dependent
light
bulb
consisting
pull
convince
arrange
descending
bottom
upwards
divisible
lay
fashion
20th
15th
4th
purposes
vague
disjoint
stare
running
luckily
distance
respect
lies
reasons
expectation
normal
bubble
equation
portioning
share
sheet
plugging
cancels
inductive
plan
nose
relations
iii
surfing
family
reordering
favorite
switch
popular
swap
obvious
flowcharts
block
branch
building
blocks
flow
chart
charts
depicted
recurs
orders
clue
moved
internal
patience
hit
height
longest
ingredients
observations
critical
flowchart
tall
lead
firstly
copies
factorial
trace
permutation
permutations
interchange
land
incorrect
invoke
theorems
decision
hypothesis
logs
fit
covered
bucket
radix
differ
digit
tiling
squares
domino
fills
empty
cross
modulo
dominos
scene
tile
managed
corner
carry
completion
tiled
initial
push
alike
puzzles
lesson
occasions
multiplying
formed
lsb
multiplications
digits
applying
products
shifting
adding
alternately
conquered
spending
touched
additions
significantly
expanding
cancel
manipulations
promised
expensive
saved
tackled
methods
derive
rack
brain
kick
pleasure
due
euler
closest
pair
meanable
strategies
field
coordinates
coordinate
choosable
distances
pairs
witness
moral
story
face
classic
huge
dot
delta
contention
radius
reduce
cut
line
chooseful
pushes
adjacent
neighbors
scanning
dominates
morals
proceed
possibly
illustrative
founded
strengthen
splitting
blob
ideally
ingenuity
luck
teach
perseverance
formulae
pump
flavor
capability
person
chance
tricks
teacher
skills
vertical
bands
bridge
band
magnify
centre
closer
spread
clustered
strain
imagination
precludes
appearing
feels
pigeon
hole
pigeons
holes
figured
diagonal
sitting
located
neighborhood
window
shifts
altered
narrow
moves
fly
partitioned
logging
replace
effectively
onetime
horizontal
affect
pert
epsilon
participate
perturbation
co-ordinates
phase
broadly
leftmost
pass
rate
created
sides
review
range
pruning
appropriately
manipulation
incremented
greedy
interestingly
keyword
greed
construct
enlarging
listen
slowly
enlarge
guiding
constructed
identifying
extension
local
improvement
key
rely
hint
subjects
strongly
matroids
duality
primary
dual
devised
dictated
improve
subtracting
dictate
proceeds
trigger
improves
subset
vertex
labels
radio
stations
mobile
transmitting
transmit
interfere
showing
fellows
frequency
interference
motivation
motivations
traced
tells
graphs
totality
acyclic
sized
force
subsets
ensure
neighbor
forest
tracking
working
fall
lets
systems
administering
fancy
command
hour
slot
schedule
intervals
interval
shorter
duration
policy
money
origin
closed
overlapping
hours
overlap
separating
builds
strikes
span
suggests
faulty
fails
intersect
overlaps
closely
join
sentence
mirror
image
produced
constructing
counter
spaces
sends
starting
ending
recursing
dropped
revise
lessons
reviewed
2nd
overlapped
request
optimal
yesterday
mentioning
gathered
discarded
disworks
finishing
picks
contradiction
kolid
1th
opt
suddenly
replacing
constructor
notes
non-trivial
behinds
non-overlapping
scheduling
user
users
minimize
sit-down
schedules
processors
minimizing
broken
produce
text
books
trial
parameters
landed
3rd
scenario
claimed
intersects
optimally
progress
fellow
tune
develops
arise
refining
refine
staring
kth
ideal
hiding
reusing
embedded
fitted
frame
telling
tips
effect
jobs
processing
preemption
stop
lock
sigma
modules
pushing
perspective
fractional
knapsack
bugler
successful
house
bag
sack
jackpot
houses
limited
capacity
item
profit
sell
restricted
items
maximized
fraction
bugling
ordinary
cake
shops
cakes
select
eat
squish
maximize
unit
action
constraints
muff
greedily
orderings
approaching
hidden
hide
listed
mentioned
act
guide
limits
guaranteeing
hints
bust
transactions
favor
device
score
scores
likes
material
forgotten
thick
formalize
observed
type
increased
perfectly
chose
film
module
intuitaly
commit
area
transmission
codes
symbols
channel
send
string
strings
received
decoded
symbol
sending
decode
scored
frequencies
free
resend
transmitted
decoding
1,depending
arrive
prefix
pre
alphabet
connection
secret
transformation
associate
either1
leafs
tied
heaviest
binaries
threes
occurrence
codeword
coding
frequently
file
encode
encoded
occurs
curve
traversing
encouraged
balance
skew
closure
twist
contribution
shifted
attach
rewriting
achieve
decreased
mantra
slow
treated
intermediate
weight
constructs
voice
branches
lowest
clean
weights
networks
huffman
kickshaw
pulling
obtain
metroids
methorids
feeling
matching
occurrences
concentrate
grep
uniques
intake
operating
facility
extensively
characters
character
symbolically
mismatch
patters
putted
doubtful
discover
indexes
patterns
sample
searching
useless
tool
existing
positional
positions
anymore
intelligently
possibility
miss
gaining
occurred
matched
highways
stock
noting
suffix
opportunity
safely
missing
proper
pre-computed
pre-compute
mismatches
success
successfully
timed
texts
unsuccessful
determined
yesterdays
stack
head
timing
pictorially
thinks
click
omit
phenomenon
clause
decremented
subscripts
subscript
1.now
risk
efficient
boyer
moore
track
concepts
windup
meet
suffixes
lesion
learned
strangely
cook
combinatorial
object
objects
optionally
lease
option
benefit
initiately
simulations
maximizing
queens
chess
board
modulate
represents
queen
interferic
green
asserting
absolute
unsigned
formulated
toy
game
tuples
consist
rupees
implicit
kilos
kilo
grams
exceed
selected
profits
constraint
crops
maximization
travelling
sales
weighted
tour
visits
representing
country
world
towns
visit
selling
travels
relating
persons
contexts
robotics
biology
fields
carrying
meant
undirected
directed
man
occasionally
backtrack
brute
dynamic
considerable
diff
exploit
catch
systematically
numerate
satisfied
storage
record
founds
guaranteed
generating
slots
template
alternatives
page
wells
comprising
extended
substance
placing
construction
bolts
exhaustive
generation
extending
children
parent
extensions
fuller
report
print
salesman
salesperson
denotes
provide
sequential
prevalent
viral
removing
vaguely
disorder
infinitive
unfiled
branching
unfilled
underneath
visiting
waste
filing
depth
improvements
wheel
efficiency
designates
matters
cyclic
closing
proceeded
diagonally
specialized
generalized
tsp
tours
child
generates
exp1ntial
explosion
grand
believes
enzymes
explore
phenomena
view
summarizing
explained
specifically
reviewing
expected
organizing
explored
direction
organization
drawn
parallel
doubles
multiplied
enormous
saving
version
prune
heuristic
evaluated
turned
bar
xij
obtained
boundary
exploring
ridiculously
explaining
choice
downward
alternative
town
horizontally
lengths
beat
assurance
is10
visited
overhead
invariably
gain
vector
vectors
width
measured
overflow
heuristics
nation
selection
firm
reject
characterized
decisions
choices
whatsoever
exploration
benefits
insight
rejected
rejecting
numerical
adapt
server
violated
indicating
firmly
focusing
forgive
cleaver
geographical
euclidean
correcting
latitudes
longitudes
crow
flies
wind
direct
account
committed
substantial
talked
issue
organize
deciding
offs
highest
included
internet
articles
viewpoint
applications
areas
enlightening
obscure
including
signal
optimize
6and
juts
kilograms
kilogram
brace
determines
decided
examining
unpicked
undecided
convention
remaining
ago
moderately
mine
encourages
valuable
simplification
outlook
wait
agree
exiting
specifications
strike
onward
calculations
determining
overloaded
past
adequate
losing
options
effects
reaming
executions
decrement
popularly
routine
won
default
table
embarking
viewing
flush
color
optimized
capacities
plus1
null
1.and
sharper
writes
diary
transcript
triple
triples
cleaning
subsequently
reappears
entries
save
repeating
formulation
eliminating
simplify
subsequence
lcs
subsequences
dropping
underlying
generally
explicitly
similarity
dna
evaluation
pelt
measures
retain
subspace
subspaces
optimizes
stops
characterize
defines
letter
degenerate
adequately
concatenated
discovered
concatenate
2.well
tempt
conjecture
searched
undefined
jointly
technicalities
moment
passing
handle
terminal
ranging
serve
1,1
mimic
interpreted
nulls
arrow
backwards
proportional
concatenation
modification
analog
linked
matric
chain
repeatedly
associative
parenthesize
zone
completed
wake
associativity
involving
scalar
parenthesization
rooted
metrics
alternatively
superior
mentions
addresses
parenthesizations
dimensions
supposed
estimated
customer
remarked
thoughts
minimized
partitions
staying
unusual
characterization
lifetime
holders
creativity
tiger
strips
yellow
animal
lemma
connect
mcm
performed
modulation
likewise
accurately
selector
extracting
mcmc
substituted
resulting
allocate
rename
considers
ranges
updating
mark
intersome
startup
holding
costs
producing
clarifying
warehouse
hold
delivered
rent
night
daily
demand
manufactured
inventory
satisfiable
production
tabular
seventh
deliver
idle
held
incurred
gap
begun
infact
dates
startups
plans
repulsive
cast
searches
minimizes
maximizes
cell
switched
history
generalize
demands
generalization
wider
consumed
specifies
devising
residual
begins
status
influence
claims
opts
core
lemmas
bests
agenda
optschedule
dealing
cumbersome
minutes
planning
optsched
relationship
potential
incurring
colon
bracket
evaluates
mth
deleted
connecting
requiring
infinite
automatically
fulfill
unsolvable
keys
forever
doubt
legal
illegal
sheets
quietly
formation
arc
quicksort
deduce
preferable
heavily
guarantees
excellent
performance
trivially
splitter
initialized
qsort
append
appending
combined
establish
feed
cardinality
evoking
invoking
invocation
extreme
homework
unevenly
artificial
redraw
uneven
distribution
shrink
erring
rightmost
news
lopsided
balanced
elegant
averages
probabilities
grouping
splits
concatenates
biased
tedious
algebraically
label
labeled
blank
cells
marked
scrambled
splitters
treating
integral
converting
logarithm
rth
bipartite
motivating
assigned
composed
forms
incident
blue
conflict
matchings
unique
ally
augmenting
concept
berge
winded
conflicts
reached
kho
played
chaser
knocks
chasing
members
opposing
team
shortly
augment
throwing
succeed
succeeds
knocked
knock
attached
foolish
entered
eliminate
stayed
colors
traversed
drag
backward
enabled
symmetric
edmonds
eminent
scientist
founders
credited
edmond
ruled
attributed
hands
justifies
existed
contrary
watch
investigate
stating
consecutive
implications
black
continued
maximal
sufficient
knew
growing
package
breadth
derived
vertex.2
enforce
forces
augmented
arrows
directions
enforced
auxiliary
arcs
confusion
transformed
referring
analogous
oriented
coincidence
arranged
orientation
accomplish
brings
delete
adjacency
bfs
deleting
augmentation
augmentations
completes
refinement
fastest
proportionality
relevance
stressing
algebraic
quantification
indirectly
assert
enumerating
exponentiate
trigonometric
looping
visualize
introduced
inputting
non-leaf
relational
operators
printed
outgoing
deterministic
outwards
randomly
graphical
performs
heap
copy
shell
intimately
rearrangement
inverse
unscrambled
ternary
accessible
constructive
peep
peeps
compares
outcomes
super
gleaned
stronger
conceivable
limit
mimics
stuck
buckets
printing
inserted
duplicates
intersections
allowing
distinctness
continuation
continuity
bounding
outcome
resembles
induct
arrives
capable
sketch
content
theoretical
theoretic
duplicate
silly
fortunately
asserts
irrespective
tuple
insist
restriction
joined
reorder
restricting
visualization
interior
analogy
triangle
geometrically
insights
interpreting
surface
convex
passes
convexity
connectivity
regions
sphere
torus
joining
kidney
shaped
cashew
describes
assure
shade
slice
cub
wedge
facing
assertion
slicing
shrinking
maintains
curious
lambda
midpoint
segment
continuous
identically
rearrange
bear
rearranged
patient
permuted
skip
non-linear
disconnected
deep
heavy
duty
machinery
connections
coins
heavier
weighings
puzzle
formulate
introduction
reductions
deals
sufficiently
tech
interview
dream
company
settled
software
boss
challenging
projects
project
automate
reads
screen
scheduled
distribute
evenly
lightly
ties
mixed
attempt
processes
beats
threatening
dismissal
complement
feeds
week
lifetimes
approaches
overestimate
disposal
generous
speeds
particles
universe
atoms
figures
fired
companies
manages
fonda
notions
imbibe
reduction
library
coded
programmer
routines
ticked
environment
ticks
crosses
recap
smarter
resultant
fallen
np-completeness
modifying
essential
inefficient
exhaustively
characteristics
restate
spanning
motion
implied
hamiltonian
spans
confused
hewlett
packard
phases
surety
circuit
distinguish
blind
transformations
round
clears
removal
contra
spurious
floating
social
versions
players
prover
verifier
trust
room
skeptical
convinced
verifies
composite
vmultiplies
guy
np
includes
bid
trustful
conversation
supplies
supplement
advice
verified
verification
diagrammatically
zeroes
composites
factorization
recent
syllabus
collections
sees
date
receives
multiplies
encountering
central
boolean
negation
literal
literals
cnf
clauses
conjunctive
equivalently
assigns
sat
exams
satisfiability
steven
tire
effort
hardest
hook
clique
remembers
creeps
feeding
sequentially
cliques
negations
states
belonged
cooks
box
satifiable
formulas
assignments
verifiers
complemented
tick
network
monitor
link
monitors
traffic
links
covers
monitored
trip
assumed
degrees
creating
older
controlling
controlled
additionally
impede
rises
rights
disjoined
provers
blame
covering
reflect
shooting
grown
recalled
leap
shoes
installment
sums
subroutine
failing
straightforward
ele
transform
fixing
summing
thrice
independence
highly
firing
approximation
arose
cope
wonders
promising
approximately
exploited
unary
freedom
napes
exponent
compromise
tend
provably
metric
traveling
precedence
constrained
definiteness
minimization
technical
rho
parameterized
reciprocal
title
restrictions
computable
synonymously
terminology
sticking
dfs
traversal
appearance
appeared
prims
reducing
post
tasks
predecessors
sched
topological
suffice
induced
unscheduled
step3
originate
.because
coping
summarized
identifiable
target
meeting
devise
themes
sighted
compete
villages
hospitals
served
hospital
collected
uncovered
uncover
recover
ground
rescue
handy
statistics
students
heights
statistically
clusters
representatives
choosing
cluster
farthest
clustering
centers
radia
desired
arbitrary
guesses
selects
quality
crew
styles
catches
trade
dependence
captured
wide
epsilons
schemes
ptas
one1
fptas
tear
approximated
lightest
complementary
mobilized
feasible
decomposed
lighter
heading
item1
seeking
explicit
expecting
distilled
compactly
subscripted
denoted
analogously
vertically
vth
denoting
vale
infinities
infinites
crop
nested
undertook
error
low
precision
aks
tight
scaling
scale
cancelled
explains
inequalities
mere
accommodatable
practical
uniformly
