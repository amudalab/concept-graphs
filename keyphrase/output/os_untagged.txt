an operating system is a program that manages the computer hardware it also provides a basis for application programs and acts as an intermediary between the computer user and the computer hardware an amazing aspect of operating systems is how varied they are in accomplishing these tasks mainframe operating systems are designed primarily to optimize utilization of hardware personal computer  pc  operating systems support complex games  business applications  and everything in between operating systems for handheld computers are designed to provide an environment in which a user can easily interface with the computer to execute programs thus  some operating systems are designed to be convenient  others to be efficient  and others some combination of the two before we can explore the details of computer system operation  we need to know something about system structure we begin by discussing the basic functions of system startup  i/o  and storage we also describe the basic computer architecture that makes it possible to write a functional operating system because an operating system is large and complex  it must be created piece by piece each of these pieces should be a well-delineated portion of the system  with carefully defined inputs  outputs  and functions in this chapter we provide a general overview of the major components of an operating system a computer system can be divided roughly into four components  the hardware  the operating system  the application programs  and the users the hardware the central processing unit  cpu   the memory  and the input/output  i/o  devices provides the basic computing resources for the system the application programs such as word processors  spreadsheets  compilers  and web browsers define the ways in which these resources are used to solve users ' computing problems the operating system controls and coordinates the use of the hardware among the various application programs for the various users we can also view a computer system as consisting of hardware  software  and data the operating system provides the means for proper use of these resources in the operation of the computer system an operating system is similar to a government like a government  it performs no useful function by itself it simply provides an environment within which other programs can do useful work to understand more fully the operating system 's role  we next explore operating systems from two viewpoints  that of the user and that of the system the user 's view of the computer varies according to the interface being used most computer users sit in front of a pc  consisting of a monitor  keyboard  mouse  and system unit such a system is designed for one user to monopolize its resources the goal is to maximize the work  or play  that the user is performing in this case  the operating system is designed mostly for ease of use  with some attention paid to performance and none paid to resource utilization how various hardware and software resources are shared performance is  of course  important to the user ; but rather than resource utilization  such systems are optimized for the single-user experience in other cases  a user sits at a terminal connected to a mainframe or minicomputer other users are accessing the same computer through other terminals these users share resources and may exchange information the operating system in such cases is designed to maximize resource utilization to assure that all available cpu time  memory  and i/o are used efficiently and that no individual user takes more than her fair share in still other cases  users sit at workstations connected to networks of other workstations and servers these users have dedicated resources at their disposal  but they also share resources such as networking and servers file  compute  and print servers therefore  their operating system is designed to compromise between individual usability and resource utilization recently  many varieties of handheld computers have come into fashion most of these devices are standalone units for individual users some are connected to networks  either directly by wire or  more often  through wireless modems and networking because of power  speed  and interface limitations  they perform relatively few remote operations their operating systems are designed mostly for individual usability  but performance per amount of battery life is important as well some computers have little or no user view for example  embedded computers in home devices and automobiles may have numeric keypads and may turn indicator lights on or off to show status  but they and their operating systems are designed primarily to run without user intervention from the computer 's point of view  the operating system is the program most intimately involved with the hardware in this context  we can view an operating system as a resource allocator a computer system has many resources that may be required to solve a problem  cpu time  memory space  file-storage space  i/o devices  and so on the operating system acts as the manager of these resources facing numerous and possibly conflicting requests for resources  the operating system must decide how to allocate them to specific programs and users so that it can operate the computer system efficiently and fairly as we have seen  resource allocation is especially important where many users access the same mainframe or minicomputer a slightly different view of an operating system emphasizes the need to control the various i/o devices and user programs an operating system is a control program a control program manages the execution of user programs to prevent errors and improper use of the computer it is especially concerned with the operation and control of i/o devices we have looked at the operating system 's role from the views of the user and of the system how  though  can we define what an operating system is in general  we have no completely adequate definition of an operating system operating systems exist because they offer a reasonable way to solve the problem of creating a usable computing system the fundamental goal of computer systems is to execute user programs and to make solving user problems easier toward this goal  computer hardware is constructed since bare hardware alone is not particularly easy to use  application programs are developed these programs require certain common operations  such as those controlling the i/o devices the common functions of controlling and allocating resources are then brought together into one piece of software  the operating system in addition  we have no universally accepted definition of what is part of the operating system a simple viewpoint is that it includes everything a vendor ships when you order " the operating system " the features included  however  vary greatly across systems some systems take up less than 1 megabyte of space and lack even a full-screen editor  whereas others require gigabytes of space and are entirely based on graphical windowing systems  a kilobyte  or kb  is 1,024 bytes ; a megabyte  or mb  is l,0242 bytes ; and a gigabyte  or gb  is l,0243 bytes computer manufacturers often round off these numbers and say that a megabyte is 1 million bytes and a gigabyte is 1 billion bytes  a more common definition is that the operating system is the one program running at all times on the computer  usually called the kernel   with all else being systems programs and application programs this last definition is the one that we generally follow the matter of what constitutes an operating system has become increasingly important in 1998  the united states department of justice filed suit against microsoft  in essence claiming that microsoft included too much functionality in its operating systems and thus prevented application vendors from competing for example  a web browser was an integral part of the operating system as a result  microsoft was found guilty of using its operating system monopoly to limit competition an operating system is software that manages the computer hardware as well as providing an environment for application programs to run perhaps the most visible aspect of an operating system is the interface to the computer system  it provides to the human user for a computer to do its job of executing programs  the programs must be in main memory main memory is the only large storage area that the processor can access directly it is an array of words or bytes  ranging in size from millions to billions each word in memory has its own address the main memory is usually a volatile storage device that loses its contents when power is turned off or lost most computer systems provide secondary storage as an extension of main memory secondary storage provides a form of non-volatile storage that is capable of holding large quantities of data permanently the most common secondary-storage device is a magnetic disk  which provides storage of both programs and data the wide variety of storage systems in a computer system can be organized in a hierarchy according to speed and cost the higher levels are expensive  but they are fast as we move down the hierarchy  the cost per bit generallydecreases  whereas the access time generally increases there are several different strategies for designing a computer system uniprocessor systems have only a single processor while multiprocessor systems contain two or more processors that share physical memory and peripheral devices the most common multiprocessor design is symmetric multiprocessing  or smp   where all processors are considered peers and run 1.13 summary 35 independently of one another clustered systems are a specialized form of multiprocessor systems and consist of multiple computer systems connected by a local area network to best utilize the cpu  modern operating systems employ multiprogramming/ which allows several jobs to be in memory at the same time  thus ensuring the cpu always has a job to execute timesharing systems are an extension of multiprogramming whereby cpu scheduling algorithms rapidly switch between jobs  thus providing the illusion each job is running concurrently the operating system must ensure correct operation of the computer system to prevent user programs from interfering with the proper operation of the system  the hardware has two modes  user mode and kernel mode various instructions  such as i/o instructions and halt instructions  are privileged and can be executed only in kernel mode the memory in which the operating system resides must also be protected from modification by the user a timer prevents infinite loops these facilities  dual mode  privileged instructions  memory protection  and timer interrupt  are basic building blocks used by operating systems to achieve correct operation a process  or job  is the fundamental unit of work in an operating system process management includes creating and deleting processes and providing mechanisms for processes to communicate and synchronize with another an operating system manages memory by keeping track of what parts of memory are being used and by whom the operating system is also responsible for dynamically allocating and freeing memory space storage space is also managed by the operating system and this includes providing file systems for representing files and directories and managing space on mass storage devices operating systems must also be concerned with protecting and securing the operating system and users protection are mechanisms that control the access of processes or users to the resources made available by the computer system security measures are responsible for defending a computer system from external or internal attacks distributed systems allow users to share resources on geographically dispersed hosts connected via a computer network services may be provided through either the client-server model or the peer-to-peer model in a clustered system  multiple machines can perform computations on data residing on shared storage  and computing can continue even when some subset of cluster members fails lans and wans are the two basic types of networks lans enable processors distributed over a small geographical area to communicate  whereas wans allow processors distributed over a larger area to communicate lans typically are faster than wans there are several computer systems that serve specific purposes these include real-time operating systems designed for embedded environments such as consumer devices  automobiles  and robotics real-time operating systems have well defined  fixed time constraints processing must be done within the defined constraints  or the system will fail multimedia systems involve the delivery of multimedia data and often have special requirements of displaying or playing audio  video  or synchronized audio and video streams recently  the influence of the internet and the world wide web has encouraged the development of modern operating systems that include web browsers and networking and communication software as integral features operating-system services an operating system provides an environment for the execution of programs it provides certain services to programs and to the users of those programs the specific services provided  of course  differ from one operating system to another  but we can identify common classes these operating-system services are provided for the convenience of the programmer  to make the programming task easier one set of operating-system services provides functions that are helpful to the user user interface almost all operating systems have a user interface  ui   this interface can take several forms one is a command-line interface  cli   which uses text commands and a method for entering them  say  a program to allow entering and editing of commands   another is a batch interface  in which commands and directives to control those commands are entered into files  and those files are executed most commonly/ a graphical user interface  gui  is used here  the interface is a window system with a pointing device to direct i/o  choose from menus  and make selections and a keyboard to enter text some systems provide two or all three of these variations program execution the system must be able to load a program into memory and to run that program the program must be able to end its execution  either normally or abnormally  indicating error   i/o operations a running program may require i/o  which may involve a file or an i/o device for specific devices  special functions may be desired  such as recording to a cd or dvd drive or blanking a crt screen   for efficiency and protection  users usually can not control i/o devices directly therefore  the operating system must provide a means to do i/o file-system manipulation the file system is of particular interest obviously  programs need to read and write files and directories they also need to create and delete them by name  search for a given file  and list file information finally  some programs include permissions management to allow or deny access to files or directories based on file ownership communications there are many circumstances in which one process needs to exchange information with another process such communication may occur between processes that are executing on the same computer or between processes that are executing on different computer systems tied together by a computer network communications may be implemented via shared memory or through message passing  in which packets of information are moved between processes by the operating system error detection the operating system needs to be constantly aware of possible errors errors may occur in the cpu and memory hardware  such as a memory error or a power failure   in i/o devices  such as a parity error on tape  a connection failure on a network  or lack of paper in the printer   and in the user program  such as an arithmetic overflow  an attempt to access an illegal memory location  or a too-great use of cpu time   for each type of error  the operating system should take the appropriate action to ensure correct and consistent computing debugging facilities can greatly enhance the user 's and programmer 's abilities to use the system efficiently another set of operating-system functions exists not for helping the user but rather for ensuring the efficient operation of the system itself systems with multiple users can gain efficiency by sharing the computer resources among the users resource allocation when there are multiple users or multiple jobs running at the same time  resources must be allocated to each of  hem many different types of resources are managed by the operating system some  such as cpu cycles  main memory  and file storage  may have special allocation code  whereas others  such as i/o devices  may have much more general request and release code for instance  in determining how best to use the cpu  operating systems have cpu-scheduling routines that take into account the speed of the cpu  the jobs that must be executed  the number of registers available  and other factors there may also be routines to allocate printers  modems  usb storage drives  and other peripheral devices accounting we want to keep track of which users use how much and what kinds of computer resources this record keeping may be used for accounting  so that users can be billed  or simply for accumulating usage statistics usage statistics may be a valuable tool for researchers who wish to reconfigiire the system to improve computing services protection and security the owners of information stored in a multiuser or networked computer system may want to control use of that information when several separate processes execute concurrently  it should not be possible for one process to interfere with the others or with the operating system itself protection involves ensuring that all access to system resources is controlled security of the system from outsiders is also important such security starts with requiring each user to authenticate himself or herself to the system  usually by means of a password  to gain access to system resources it extends to defending external i/o devices  including modems and network adapters  from invalid access attempts and to recording all such connections for detection of break-ins if a system is to be protected and secure  precautions must be instituted throughout it a chain is only as strong as its weakest link user operating-system interface there are two fundamental approaches for users to interface with the operating system one technique is to provide a command-line interface or command interpreter that allows users to directly enter commands that are to be performed by the operating system the second approach allows the user to interface with the operating system via a graphical user interface or gui 2.2.1 command interpreter some operating systems include the command interpreter in the kernel others  such as windows xp and unix  treat the command interpreter as a special program that is running when a job is initiated or when a user first logs on  on interactive systems   on systems with multiple command interpreters to choose from  the interpreters are known as shells for example  on unix and linux systems  there are several different shells a user may choose from including the bourne shell  c shell  bourne-again shell  the korn shell  etc most shells provide similar functionality with only minor differences ; most users choose a shell based upon personal preference the main function of the command interpreter is to get and execute the next user-specified command many of the commands given at this level manipulate files  create  delete  list  print  copy  execute  and so on the ms-dos and unix shells operate in this way there are two general ways in which these commands can be implemented in one approach  the command interpreter itself contains the code to execute the command for example  a command to delete a file may cause the command interpreter to jump to a section of its code that sets up the parameters and makes the appropriate system call in this case  the number of commands that can be given determines the size of the command interpreter  since each command requires its own implementing code an alternative approach used by unix  among other operating systems implements most commands through system programs in this case  the command interpreter does not understand the command in any way ; it merely uses the command to identify a file to be loaded into memory and executed thus  the unix command to delete a file rm file.tx t would search for a file called rm  load the file into memory  and execute it with the parameter file  txt the function associated with the rm command would be defined completely by the code in the file rm in this way  programmers can add new commands to the system easily by creating new files with the proper names the command-interpreter program  which can be small  does not have to be changed for new commands to be added 2.2.2 graphical user interfaces a second strategy for interfacing with the operating system is through a userfriendly graphical user interface or gui rather than having users directly enter commands via a command-line interface  a gui allows provides a mouse-based window-and-menu system as an interface a gui provides a desktop metaphor where the mouse is moved to position its pointer on images  or icons  on the screen  the desktop  that represent programs  files  directories  and system functions depending on the mouse pointer 's location  clicking a button on the mouse can invoke a program  select a file or directory known as a folder or pull down a menu that contains commands graphical user interfaces first appeared due in part to research taking place in the early 1970s at xerox parc research facility the first gui appeared on the xerox alto computer in 1973 however  graphical interfaces became more widespread with the advent of apple macintosh computers in the 1980s the user interface to the macintosh operating system  mac os  has undergone various changes over the years  the most significant being the adoption of the aqua interface that appeared with mac os x microsoft 's first version of windows version 1.0 was based upon a gui interface to the ms-dos operating system the various versions of windows systems proceeding this initial version have made cosmetic changes to the appearance of the gui and several enhancements to its functionality  including the windows explorer traditionally  unix systems have been dominated by command-line interfaces  although there are various gui interfaces available  including the common desktop environment  cde  and x-windows systems that are common on commercial versions of unix such as solaris and ibm 's aix system however  there has been significant development in gui designs from various opensource projects such as k desktop environment  or kde  and the gnome desktop by the gnu project both the kde and gnome desktops rim on linux and various unix systems and are available under open-source licenses  which means their source code is in the public domain the choice of whether to use a command-line or gui interface is mostly one of personal preference as a very general rule  many unix users prefer a command-line interface as they often provide powerful shell interfaces alternatively  most windows users are pleased to use the windows gui environment and almost never use the ms-dos shell interface the various changes undergone by the macintosh operating systems provides a nice study in contrast historically  mac os has not provided a command line interface  always requiring its users to interface with the operating system using its gui however  with the release of mac os x  which is in part implemented using a unix kernel   the operating system now provides both a new aqua interface and command-line interface as well the user interface can vary from system to system and even from user to user within a system it typically is substantially removed from the actual system structure the design of a useful and friendly user interface is therefore not a direct function of the operating system in this book  we concentrate on the fundamental problems of providing adequate service to user programs from the point of view of the operating system  we do not distinguish between user programs and system programs system calls system calls provide an interface to the services made available by an operating system these calls are generally available as routines written in c and c + +  although certain low-level tasks  for example  tasks where hardware must be accessed directly   may need to be written using assembly-language instructions before we discuss how an operating system makes system calls available  let 's first use an example to illustrate how system calls are used  writing a simple program to read data from one file and copy them to another file the first input that the program will need is the names of the two files  the input file and the output file these names can be specified in many ways  depending on the operating-system design one approach is for the program to ask the user for the names of the two files in an interactive system  this approach will require a sequence of system calls  first to write a prompting message on the screen and then to read from the keyboard the characters that define the two files on mouse-based and icon-based systems  a menu of file names is usually displayed in a window the user can then use the mouse to select the source name  and a window can be opened for the destination name to be specified this sequence requires many i/o system calls once the two file names are obtained  the program must open the input file and create the output file each of these operations requires another system call there are also possible error conditions for each operation when the program tries to open the input file  it may find that there is no file of that name or that the file is protected against access in these cases  the program should8 print a message on the console  another sequence of system calls  and then terminate abnormally  another system call   if the input file exists  then we must create a new output file we may find that there is already an output file with the same name this situation may cause the program to abort  a system call   or we may delete the existing file  another system call  and create a new one  another system call   another option  in an interactive system  is to ask the user  via a sequence of system calls to output the prompting message and to read the response from the terminal  whether to replace the existing file or to abort the program now that both files are set up  we enter a loop that reads from the input file  a system call  and writes to the output file  another system call   each read and write must return status information regarding various possible error conditions on input  the program may find that the end of the file has been reached or that there was a hardware failure in the read  such as a parity error   the write operation may encounter various errors  depending on the output device  no more disk space  printer out of paper  and so on   finally  after the entire file is copied  the program may close both files  another system call   write a message to the console or window  more system calls   and finally terminate normally  the final system call   as we can see  even simple programs may make heavy use of the operating system frequently  systems execute thousands of system calls per second this systemcall sequence is shown in figure 2.1 most programmers never see this level of detail  however typically  application developers design programs according to an application programming interface  api   the api specifies a set of functions that are available to an application programmer  including the parameters that are passed to each function and the return values the programmer can expect three of the most common apis available to application programmers are the win32 api for windows systems  the posix api for posix-based systems  which includes virtually all versions of unix  linux  and mac os x   and the java api for designing programs that run on the java virtual machine note that the system-call names used throughout this text are generic examples each operating system has its own name for each system call behind the scenes  the functions that make up an api typically invoke the actual system calls on behalf of the application programmer for example  the win32 function createprocess    which unsurprisingly is used to create a new process  actually calls the ntcreateprocess   system call in the windows kernel why would an application programmer prefer programming according to an api rather than invoking actual system calls there are several reasons for doing so one benefit of programming according to an api concerns program portability  an application programmer designing a program using an api can expect her program to compile and run on any system that supports the same api  although in reality  architectural differences often make this more difficult than it may appear   furthermore  actual system calls can often be more detailed and difficult to work with than the api available to an application programmer regardless  there often exists a strong correlation between invoking a function in the api and its associated system call within the kernel in fact  many of the posix and win32 apis are similar to the native system calls provided by the unix  linux  and windows operating systems the run-time support system  a set of functions built into libraries included with a compiler  for most programming languages provides a system-call interface that serves as the link to system calls made available by the operating system the system-call interface intercepts function calls in the api and invokes the necessary system call within the operating system typically  a number is associated with each system call  and the system-call interface maintains a table indexed according to these numbers the system call interface then invokes the intended system call in the operating system kernel and returns the status of the system call and any return values the caller needs to know nothing about how the system call is implemented or what it does during execution rather  it just needs to obey the api and understand what the operating system will do as a result of the execution of that system call thus  most of the details of the operating-system interface are hidden from the programmer by the api and are managed by the run-time support library the relationship between an api  the system-call interface  and the operating system is shown in figure 2.3  which illustrates how the operating system handles a user application invoking the open   system call system calls occur in different ways  depending on the computer in use often  more information is required than simply the identity of the desired system call the exact type and amount of information vary according to the particular operating system and call for example  to get input  we may need to specify the file or device to use as the source  as well as the address and length of the memory buffer into which the input should be read of course  the device or file and length may be implicit in the call three general methods are used to pass parameters to the operating system the simplest approach is to pass the parameters in registers in some cases  however  there may be more parameters than registers in these cases  the parameters are generally stored in a block  or table  in memory  and the address of the block is passed as a parameter in a register  figure 2.4   this is the approach taken by linux and solaris parameters also can be placed  or pushed  onto the stack by the program and popped off the stack by the operating system some operating systems prefer the block or stack method  because those approaches do not limit the number or length of parameters being passed system calls can be grouped roughly into five major categories  process control  file manipulation  device manipulation  information maintenance  and communications in sections 2.4.1 through 2.4.5  we discuss briefly the types of system calls that may be provided by an operating system most of these system calls support  or are supported by  concepts and functions that are discussed in later chapters figure 2.5 summarizes the types of system calls normally provided by an operating system 2.4.1 process control a running program needs to be able to halt its execution either normally  end  or abnormally  abort   if a system call is made to terminate the currently running program abnormally  or if the program runs into a problem and causes an error trap  a dump of memory is sometimes taken and an error message generated the dump is written to disk and may be examined by a debugger a system program designed to aid the programmer in finding and correcting bugs to determine the cause of the problem under either normal or abnormal circumstances  the operating system must transfer control to the invoking command interpreter the command interpreter then reads the next command in an interactive system  the command interpreter simply continues with the next command ; it is assumed that the user will issue an appropriate command to respond to any error in a gui system  a pop-up window might alert the user to the error and ask for guidance in a batch system  the command interpreter usually terminates the entire job and continues with the next job computers can store information on various storage media  such as magnetic disks  magnetic tapes  and optical disks so that the computer system will be convenient to use  the operating system provides a uniform logical view of information storage the operating system abstracts from the physical properties of its storage devices to define a logical storage unit  the file files are mapped by the operating system onto physical devices these storage devices are usually nonvolatile  so the contents are persistent through power failures and system reboots a file is a named collection of related information that is recorded on secondary storage from a user 's perspective  a tile is the smallest allotment of logical secondary storage ; that is  data can not be written to secondary storage unless they are within a file commonly  files represent programs  both source and object forms  and data data files may be numeric  alphabetic  alphanumeric  or binary files may be free form  such as text files  or may be formatted rigidly in general  a file is a sequence of bits  bytes  lines  or records  the meaning of which is defined by the file 's creator and user the concept of a file is thus extremely general the information in a file is defined by its creator many different types of information may be stored in a file source programs  object programs  executable programs  numeric data  text  payroll records  graphic images  sound recordings  and so on a file has a certain defined structure  which depends on its type a text file is a sequence of characters organized into lines  and possibly pages   a source file is a sequence of subroutines and functions  each of which is further organized as declarations followed by executable statements an object file is a sequence of bytes organized into blocks understandable by the system 's linker an executable file is a series of code sections that the loader can bring into memory and execute 10.1.1 file attributes a file is named  for the convenience of its human users  and is referred to by its name a name is usually a string of characters  such as example.c some systems differentiate between uppercase and lowercase characters in names  whereas other systems do not when a file is named  it becomes independent of the process  the user  and even the system that created it for instance  one user might create the file example.c  and another user might edit that file by specifying its name the file 's owner might write the file to a floppy disk  send it in an e-mail  or copy it across a network  and it could still be called example.c on the destination system a file 's attributes vary from one operating system to another but typically consist of these  s name the symbolic file name is the only information kept in humanreadable form identifier this unique tag  usually a number  identifies the file within the file system ; it is the non-human-readable name for the file type this information is needed for systems that support different types of files location this information is a pointer to a device and to the location of the file on that device size the current size of the file  in bytes  words  or blocks  and possibly the maximum allowed size are included in this attribute protection access-control information determines who can do reading  writing  executing  and so on 10.1 file concept 375 time  date  and user identification this information may be kept for creation  last modification  and last use these data can be useful for protection  security  and usage monitoring the information about all files is kept in the directory structure  which also resides on secondary storage typically  a directory entry consists of the file 's name and its unique identifier the identifier in turn locates the other file attributes it may take more than a kilobyte to record this information for each file in a system with many files  the size of the directory itself may be megabytes because directories  like files  must be nonvolatile  they must be stored on the device and brought into memory piecemeal  as needed 10,1.2 file operations a file is an abstract data type to define a file properly  we need to consider the operations that can be performed on files the operating system can provide system calls to create  write  read  reposition  delete  and truncate files let 's examine what the operating system must do to perform each of these six basic file operations it should then be easy to see how other  similar operations  such as renaming a file  can be implemented creating a file two steps are necessary to create a file first  space in the file system must be found for the file we discuss how to allocate space for the file in chapter 11 second  an entry for the new file must be made in the directory writing a file to write a file  we make a system call specifying both the name of the file and the information to be written to the file given the name of the file  the system searches the directory to find the file 's location the system must keep a write pointer to the location in the file where the next write is to take place the write pointer must be updated whenever a write occurs reading a file to read from a file  we use a system call that specifies the name of the file and where  in memory  the next block of the file should be put again  the directory is searched for the associated entry  and the system needs to keep a read pointer to the location in the file where the next read is to take place once the read has taken place  the read pointer is updated because a process is usually either reading from or writing to a file  the current operation location can be kept as a per-process currentfile-position pointer both the read and write operations use this same pointer  saving space and reducing system complexity repositioning within a file the directory is searched for the appropriate entry  and the current-file-position pointer is repositioned to a given value repositioning within a file need not involve any actual i/o this file operation is also known as a file seek deleting a file to delete a file  we search the directory for the named file having found the associated directory entry  we release all file space  so that it can be reused bv other files  and erase the directory entry 376 chapter 10 file-system interface .truncating a file the user may want to erase the contents of a file but keep its attributes rather than forcing the user to delete the file and then recreate it  this function allows all attributes to remain unchanged except for file length but lets the tile be reset to length zero and its file space released these six basic operations comprise the minimal set of required file operations other common operations include appending new information to the end of an existing file and renaming an existing file these primitive operations can then be combined to perform other file operations for instance  we can create a copy of a file  or copy the file to another i/o device  such as a printer or a display  by creating a new file and then reading from the old and writing to the new we also want to have operations that allow a user to get and set the various attributes of a file for example  we may want to have operations that allow a user to determine the status of a file  such as the file 's length  and to set file attributes  such as the file 's owner most of the file operations mentioned involve searching the directory for the entry associated with the named file to avoid this constant searching  many systems require that an openo system call be made before a file is first used actively the operating system keeps a small table  called the open-file table  containing information about all open files when a file operation is requested  the file is specified via an index into this table  so no searching is required when the file is no longer being actively used  it is closed by the process  and the operating system removes its entry from the open-file table  create and delet e are system calls that work with closed rather than open files some systems implicitly open a file when the first reference to it is made the file is automatically closed when the job or program that opened the file terminates most systems  however  require that the programmer open a file explicitly with the openo system call before that file can be used the openo operation takes a file name and searches the directory  copying the directory entry into the open-file table the openo call can also accept accessmode information create  read-only  read write  append-only  and so on this mode is checked against the file 's permissions if the request mode is allowed  the file is opened for the process the openo system call typically returns a pointer to the entry in the open-file table this pointer  not the actual file name  is used in all i/o operations  avoiding any further searching and simplifying the system-call interface the implementation of the openo and close   operations is more complicated in an environment where several processes may open the file at the same time this may occur in a system where several different applications open the same file at the same time typically  the operating system uses two levels of internal tables  a per-process table and a system-wide table the perprocess table tracks all files that a process has open stored in this table is information regarding the use of the file by the process for instance  the current file pointer for each file is found here access rights to the file and accounting information can also be included each entry in the per-process table in turn points to a system-wide open-file table the system-wide table contains process-independent information  such as the location of the file on disk  access dates  and file size once a file has been opened by one process  the system-wide table includes an entry for the file 10.1 file concept 377 when another process executes an openq call  a new entry is simply added to the process 's open-file table pointing to the appropriate entry in the systemwide table typically  the open-file table also has an open count associated with each file to indicate how many processes have the file open each close 0 decreases this open count  and when the open count reaches zero  the file is no longer in use  and the file 's entry is removed from the open-file table in summary  several pieces of information are associated with an open file file pointer on systems that do not include a file offset as part of the reado and write   system calls  the system must track the last readwrite location as a current-file-position pointer this pointer is unique to each process operating on the file and therefore must be kept separate from the on-disk file attributes file-open count as files are closed  the operating system must reuse its open-file table entries  or it could run out of space in the table because multiple processes may have opened a file  the system must wait for the last file to close before removing the open-file table entry the file-open counter tracks the number of opens and closes and reaches zero on the last close the system can then remove the entry disk location of the file most file operations require the system to modify data within the file the information needed to locate the file on disk is kept in memory so that the system does not have to read it from disk for each operation access rights each process opens a file in an access mode this information is stored on the per-process table so the operating system can allow or deny subsequent i/o requests some operating systems provide facilities for locking an open file  or sections of a file   file " locks allow one process to lock a file and prevent other processes from gaining access to it file locks are useful for files that are shared by several processes for example  a system log file that can be accessed and modified by a number of processes in the system a process may need several resources to execute main memory  disk drives  access to files  and so on if the resources are available  they can be granted  and control can be returned to the user process otherwise  the process will have to wait until sufficient resources are available the various resources controlled by the operating sysstem can be thought of as devices some of these devices are physical devices  for example  tapes   while others can be thought of as abstract or virtual devices  for example  files   if there are multiple users of the system  the system may require us to first request the device  to ensure exclusive use of it after we are finished with the device  we release it these functions are similar to the open and close system calls for files other operating systems allow unmanaged access to devices the hazard then is the potential for device contention and perhaps deadlock once the device has been requested  and allocated to us   we can read  write  and  possibly  reposition the device  just as we can with files in fact  the similarity between i/o devices and files is so great that many operating systems  including unix  merge the two into a combined file-device structure in this case  a set of system calls is used on files and devices sometimes  i/o devices are identified by special file names  directory placement  or file attributes the ui can also make files and devices appear to be similar  even though the underlying system calls are dissimilar this is another example of the many design decisions that go into building an operating system and user interface 2.4.4 information maintenance many system calls exist simply for the purpose of transferring information between the user program and the operating system for example  most systems have a system call to return the current time and date  other system calls may return information about the system  such as the number of current users  the version number of the operating system  the amount of free memory or disk space  and so on in addition  the operating system keeps information about all its processes  and svstem calls are used to access this information generally  calls are also used to reset the process information  get process attributes and set process attributes   2.4.5 communication there are two common models of interprocess communication  the messagepassing model and the shared-memory model in the message-passing model  the communicating processes exchange messages with one another to transfer information messages can be exchanged between the processes either directly or indirectly through a common mailbox before communication can take place  a connection must be opened the name of the other communicator must be known  be it another process on the same system or a process on another computer connected by a communications network each computer in a network has a host name by which it is commonly known a host also has a network identifier  such as an ip address similarly  each process has a process name  and this name is translated into an identifier by which the operating system can refer to the process the get host id and get processid system calls do this translation the identifiers are then passed to the generalpurpose open and close calls provided by the file system or to specific open connection and close connection system calls  depending on the system 's model of communication the recipient process usually must give its permission for communication to take place with an accept connection call most processes that will be receiving connections are special-purpose daemons  which are systems programs provided for that purpose they execute a wait for c onnect ion call and are awakened when a connection is made the source of the communication  known as the client  and the receiving daemon  known as a server  then exchange messages by using read message and write message system calls the close connection call terminates the communication in the shared-memory model  processes use shared memory create and shared memory attach system calls to create and gain access to regions of memory owned by other processes recall that  normally  the operating system tries to prevent one process from accessing another process 's memory shared memory requires that two or more processes agree to remove this restriction they can then exchange information by reading and writing data in the shared areas the form of the data and the location are determined by the processes and are not under the operating system 's control the processes are also responsible for ensuring that they are not writing to the same location simultaneously such mechanisms are discussed in chapter 6 in chapter 4  we look at a variation of the process scheme threads in which memory is shared by default both of the models just discussed are common in operating systems  and most systems implement both message passing is useful for exchanging smaller amounts of data  because no conflicts need be avoided it is also easier to implement than is shared memory for intercomputer communication shared 2.5 system programs 55 memory allows maximum speed and convenience of communication  since it can be done at memory speeds when it takes place within a computer problems exist  however  in the areas of protection and synchronization between the processes sharing memory 2.5 system programs another aspect of a modern system is the collection of system programs recall figure 1.1  which depicted the logical computer hierarchy at the lowest level is hardware next is the operating system  then the system programs  and finally the application programs system programs provide a convenient environment for program development and execution some of them are simply user interfaces to system calls ; others are considerably more complex they can be divided into these categories  file management these programs create  delete  copy  rename  print  dump  list  and generally manipulate files and directories status information some programs simply ask the system for the date  time  amount of available memory or disk space  number of users  or similar status information others are more complex  providing detailed performance  logging  and debugging information typically  these programs format and print the output to the terminal or other output devices or files or display it in a window of the gui some systems also support a registry  which is used to store and retrieve configuration information file modification several text editors may be available to create and modify the content of files stored on disk or other storage devices there may also be special commands to search contents of files or perform transformations of the text programming-language support compilers  assemblers  debuggers and interpreters for common programming languages  such as c  c + +  java  visual basic  and perl  are often provided to the user with the operating system program loading and execution once a program is assembled or compiled  it must be loaded into memory to be executed the system may provide absolute loaders  relocatable loaders  linkage editors  and overlay loaders debugging systems for either higher-level languages or machine language are needed as well communications these programs provide the mechanism for creating virtual connections among processes  users  and computer systems they allow users to send messages to one another 's screens  to browse web pages  to send electronic-mail messages  to log in remotely  or to transfer files from one machine to another in addition to systems programs  most operating systems are supplied with programs that are useful in solving common problems or performing common operations such programs include web browsers  word processors and text formatters  spreadsheets  database systems  compilers  plotting and statistical-analysis packages  and games these programs are known as system utilities or application programs the view of the operating system seen by most users is defined  by the application and system programs  rather than by the actual system calls consider pcs when his computer is running the mac os x operating system  a user might see the gui  featuring a mouse and windows interface alternatively  or even in one of the windows  he might have a command-line unix shell both use the same set of system calls  but the system calls look different and act in different ways a process can be thought of as a program in execution  a process will need certain resources such as cpu time  memory  files  and i/o devices to accomplish its task these resources are allocated to the process either when it is created or while it is executing a process is the unit of work in most systems systems consist of a collection of processes  operating-system processes execute system code  and user processes execute user code all these processes may execute concurrently although traditionally a process contained only a single thread of control as it ran  most modern operating systems now support processes that have multiple threads the operating system is responsible for the following activities in connection with process and thread management  the creation and deletion of both user and system processes ; the scheduling of processes ; and the provision of mechanisms for synchronization  communication  and deadlock handling for processes process concept a question that arises in discussing operating systems involves what to call all the cpu activities a batch system executes jobs  whereas a time-shared system has user programs  or tasks even on a single-user system such as microsoft windows  a user may be able to run several programs at one time  a word processor  a web browser  and an e-mail package even if the user can execute only one program at a time  the operating system may need to suppoft its own internal programmed activities  such as memory management in many respects  all these activities are similar  so we call all of them processes the terms job and process are used almost interchangeably in this text although we personally prefer the term process  much of operating-system theory and terminology was developed during a time when the major activity of operating systems was job processing it would be misleading to avoid the use of commonly accepted terms that include the word job  such as job scheduling  simply because process has superseded job 3.1.1 the process informally  as mentioned earlier  a process is a program in execution a process is more than the program code  which is sometimes known as the text section it also includes the current activity  as represented by the value of the program counter and the contents of the processor 's registers a process generally also includes the process stack  which contains temporary data  such as function parameters  return addresses  and local variables   and a data section  which contains global variables a process may also include a heap  which is memory that is dynamically allocated during process run time the structure of a process in memory is shown in figure 3.1 we emphasize that a program by itself is not a process ; a program is a passive entity  such as a file containing a list of instructions stored on disk  often called an executable file   whereas a process is an active entity  with a program counter specifying the next instruction to execute and a set of associated resources a program becomes a process when an executable file is loaded into memory two common techniques for loading executable files are double-clicking an icon representing the executable file and entering the name of the executable file on the command line  as in prog exe or a out  although two processes may be associated with the same program  they are nevertheless considered two separate execution sequences as a process executes  it changes state the state of a process is defined in part by the current activity of that process each process may be in one of the following states  new the process is being created running instructions are being executed waiting the process is waiting for some event to occur  such as an i/o completion or reception of a signal   ready the process is waiting to be assigned to a processor terminated the process has finished execution these names are arbitrary  and they vary across operating systems the states that they represent are found all systems  however certain operating systems also more finely delineate process states it is important to realize that only one process can be running on any processor at any instant many processes may be ready and limiting  however the state diagram corresponding to these states is presented in figure 3.2 3.1.3 process control block each process is represented in the operating system by a process control block  pcb  also called a task control block a pcb is shown in figure 3.3 it contains many pieces of information associated with a specific process  including these  process state the state may be new  ready  running  waiting  halted  and so on program counter the counter indicates the address of the next instruction to be executed for this process cpu registers the registers vary in number and type  depending on the computer architecture they include accumulators  index registers  stack pointers  and general-purpose registers  plus any condition-code information along with the program counter  this state information must be saved when an interrupt occurs  to allow the process to be continued correctly afterward .cpu-scheduling information this information includes a process priority  pointers to scheduling queues  and any other scheduling parameters  chapter 5 describes process scheduling  memory-management information this information may include such information as the value of the base and limit registers  the page tables  or the segment tables  depending on the memory system used by the operating system  chapter 8   accounting information this information includes the amount of cpu and real time used  time limits  account mimbers  job or process numbers  and so on i/o status information this information includes the list of i/o devices allocated to the process  a list of open files  and so on in brief  the pcb simply serves as the repository for any information that may vary from process to process.a process is a program in execution as a process executes  it changes state the state of a process is defined by that process 's current activity each process may be in one of the following states  new  ready  running  waiting  or terminated each process is represented in the operating system by its own process-control block  pcb  .a process  when it is not executing  is placed in some waiting queue there are two major classes of queues in an operating system  i/o request queues and the ready queue the ready queue contains all the processes that areteady to execute and are waiting for the cpu each process is represented by a pcb  and the pcbs can be linked together to form a ready queue long-term  job  scheduling is the selection of processes that will be allowed to contend for the cpu normally  long-term scheduling is heavily influenced by resourceallocation considerations  especially memory management short-term  cpu  scheduling is the selection of one process from the ready queue operating systems must provide a mechanism for parent processes to create new child processes the parent may wait for its children to terminate before proceeding  or the parent and children may execute concurrently there are several reasons for allowing concurrent execution  information sharing  computation speedup  modularity  and convenience the processes executing in the operating system may be either independent processes or cooperating processes cooperating processes require an interprocess communication mechanism to communicate with each other principally  communication is achieved through two schemes  shared memory and message passing the shared-memory method requires communicating processes to share some variables the processes are expected to exchange information through the use of these shared variables in a shared-memory system  the responsibility for providing communication rests with the application programmers ; the operating system needs to provide only the shared memory the message-passing method allows the processes to exchange messages the responsibility for providing communication may rest with the operating system itself these two schemes are not mutually exclusive and can be used simultaneously within a single operating system communication in client-server systems may use  1  sockets   2  remote procedure calls  rpcs   or  3  java 's remote method invocation  rmi   a socket is defined as an endpoint for communication a connection between a pair of applications consists of a pair of sockets  one at each end of the communication channel rpcs are another form of distributed communication an rpc occurs when a process  or thread  calls a procedure on a remote application rmi is the java version of rpcs rmi allows a thread to invoke a method on a remote object just as it would invoke a method on a local object the primary distinction between rpcs and rmi is that in rpcs data are passed to a remote procedure in the form of an ordinary data structure  whereas rmi allows objects to be passed in remote method calls  