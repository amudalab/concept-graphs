talking about quick
series of lectures
lectures the first
argued a worst
worst case running
order n squared
squared so today
today the quick
quick sort algorithm
average in expectation
expectation it takes
algorithm in practice
place sorting algorithm
algorithm an algorithm
sort in place
require any additional
two more variables
sort a large
collection of numbers
divide and conquer
lot of divide
level the idea
idea behind divide
solve you divide
divide the problem
pieces you solve
solve the problem
case of quick
partition our array
numbers and partitioned
partitioned it break
call the lower
call the higher
part the property
part every number
sort the lower
sort the higher
put all elements
thing is sorted
sorted the lower
part is sorted
sorted the higher
part every elements
partition is done
give a algorithm
linear time procedure
partitioning is done
lower half lower
half lower part
takes us parameters
parameters the array
partitions the sub
pivot element t.k
value p minus
location this location
array the sub
lop while true
true which means
reach a location
reach a locations
equal to ten
reached a location
sense called prints
means just sort
sort these contents
ort these contents
contents so blue
part and orange
ten ya good
find an element
stop these things
means our job
job is done
means they crossed
return the procedure
returning the value
half my left
dos this procedure
utmost ten times
times the size
incremented at utmost
utmost the size
loop is done
utmost n times
times this loop
increment or decrement
times rite questions
slightly different manner
taking the pivot
compare every element
pivot and put
first few locations
locations rite nit
require more memory
array and copy
copy that array
additional memory space
inside by taking
taking order order
repeat until loop
statement total number
number of times
statement executed utmost
decrement only utmost
times this step
step is executed
complete quick sort
sort on lets
array rite array
call for quick
make any sense
find the partition
invoke the previous
rearranges the part
half later part
return it returns
returns the demarcating
recursively invoke quick
invoke quick sort
condition is met
entire partition procedure
replace sorting algorithm
call quick sort
recursively so note
copy the array
create more copies
creating additional copies
local these parameters
taking any additional
sir in quick
understands quick sort
element you partitioned
partitioned the array
sort this left
sort this right
solve the left
write a quick
quick sort procedure
quick sort takes
partition procedure takes
procedure takes order
order n times
sort will depend
split is happening
half but left
sort is taking
dividing the array
two equal halves
means that half
half the elements
half elements ended
picked a pivot
two parts equal
parts equal parts
taking rite lets
divide this array
two n times
array of size
divide this sort
manner am taking
tree of mine
order n log
excuse me sir
ten rite total
means i decrease
utmost m times
send the quality
minus one elements
writing the recurrence
sort n elements
procedure was quick
sort the left
left part lets
sort the right
recurrence and lets
solve this recurrence
done its sorted
two plus theta
eventually becomes theta
make it clear
four plus theta
theta is bothering
simple skewed split
skewed split split
pictorially n divided
minus one divided
two n minus
minus two divided
input is sorted
sorted already lets
case would happen
sorted in ascending
element in right
right half wil
happen rite similar
happened in insertion
remember insertion sort
recall in insertion
taking an element
element and figuring
place to put
put that element
end to find
sorted in decreasing
array was sorted
sorted in increasing
move back anymore
takes constant amount
comparison with insertion
sorted increasing sorted
increasing sorted decreasing
half an half
tenth nine tenth
side and ninety
call this lucky
ten got divided
side one tenth
number of elements
similarly the total
level were continued
number is smaller
level is decreasing
decrementing by half
log n base
out the map
constant times log
height is order
taking a total
number of levels
levels is log
moving the left
providing an upper
manner one tenth
sacrosanct one tenth
order argue log
spectacular or special
fraction of numbers
side a constant
end up taking
taking n squared
fraction one tenth
millionth the height
analysis from starting
alternate the lucky
lucky and unlucky
prove a log
log n depth
case n minus
minus one operation
minus one operations
operations or comparisons
comparisons i managed
managed to split
two n comparisons
side and lets
expected time expected
half best thing
find a median
pick the median
two equal parts
sort the numbers
find the median
finding median element
procedure for doing
..some what close
median by dividing
number of small
array then find
log n times
compute a median
element in linear
fairly a involved
pick a random
element and declare
nt want top
pick a specific
pick the last
sequence is lets
order or increasing
call a randomized
making some kind
kind of random
analyze the running
randomized quick sort
assume all elements
elements are distinct
distinct we partition
element a pivot
pick any element
element at random
kind of splits
element each element
picked with equal
pick the tens
tens smallest element
versus n minus
minus ten split
probability of picking
picking the tens
picked any element
eleven smallest element
twelve smallest element
examples of randomization
tool for designing
modify the randomize
randomize the partition
procedure and call
call it randomized
array between locations
begin by finding
generates a random
recall was taking
taking the last
put my pivot
exchange the pivot
call my partition
randomized partition procedure
partition it calls
calls randomized partition
partition the rest
choice of pivot
pivot is crucial
choose the pivot
lets say increasing
picking a random
element to partition
sequence as input
happen that today
today you run
run the algorithm
tomorrow you run
numbers are selected
random numbers selected
numbers selected decide
decide the pivot
crucial in deciding
splitting the things
pivots were turning
.all possible inputs
sequence of random
numbers is generated
fix an input
change the input
today and tomorrow
tomorrow and day
sorting that specific
specific input sequence
denote the expected
number of comparisons
required by quick
required the number
required to sort
sort n numbers
numbers will depend
sort does quick
sort first partitions
partition n numbers
numbers no matter
minus one comparisons
number is compared
pivot are put
require n minus
comparisons every number
partition rite depending
minus one lets
minus i elements
taking to quick
compute expectations expectations
forgetting your expectations
expectations i roll
roll a dice
throw a dice
dice rite throw
value so expectation
expectation is defined
random variable random
variable random variable
random variable lets
variable lets call
random variables takes
values each value
probability x equals
equals i equals
throwing this dice
recording the outcome
outcome keep doing
doing this forever
suppose you throw
throw this dice
means the probability
sufficiently many times
times your outcome
probability the random
random variable takes
takes the value
value one times
takes the random
random variable ten
two so probability
thinking of expectation
variable is taking
taking a set
set of discrete
compute the value
times the value
taking this value
quantity also varies
means every term
minus one appears
write this part
required to insert
randomly chosen permutation
binary search tree
tree some variable
class we solved
solved this recurrence
showed the solution
required by randomized
fact any questions
sort so lets
lets quickly summarize
quick sort worst
sort worst case
squared best case
behavior is similar
insert n elements
sequence is sorted
roughly the median
lets just recap
quick sort depends
numbers were generated
input the running
random numbers generated
value is tomorrow
compute this value
value it turns
input was sorted
pick my pivot
happened the running
nt really depend
random number choice
make any fix
input no matter
matter what input
beat my algorithm
sequence such sequence
matter what sequence
sequence of numbers
make an algorithm
kind of input
make it independent
making a random
.for that kind
knew what kinds
kinds of inputs
sense to design
design the algorithm
kind of inputs
designing the algorithm
sequence or specific
times of input
class for binary
make this difference
difference very clear
doing an average
run it today
run it tomorrow
choices being made
factorial different permutations
understand the difference
difference the recurrence
call an average
average case analysis
factorial different inputs
average rite today
algorithm our algorithm
algorithm was taking
taking different times
taking the average
inputs the input
input was fixed
today s lecture
expected time analysis
analysis for randomized
quick sort
sorting algorithm
insertion sort
worst case
case running
sort algorithm
quick algorithm
small constants
place sorting
place sort
additional memory
good thing
large collection
algorithm falls
conquer algorithms
high level
smaller pieces
divide step
lower part
higher part
entire thing
combining part
conquer algorithm
pivot element
lower half
larger part
larger array
sub array
element t.k
pivot ten
left part
right part
orange part
found find
first element
exit return
left half
right half
procedure takes
taking order
speaks hindi
decremented utmost
done utmost
memory space
group inside
order order
statement total
total number
lops put
statement executed
executed utmost
complete quick
initial call
previous procedure
initial part
demarcating lines
upper half
larger half
loop forever
loop stops
break statement
entire partition
partition procedure
replace sorting
additional copies
single array
random number
fixed number
sort procedure
sort takes
takes order
times linear
elements end
taking lets
point suppose
equal halves
median lets
elements ended
equal parts
partitioning takes
write theta
inter change
quality good
recurrence relation
elements equals
first step
part lets
lets solve
lets make
basically theta
constant times
skewed split
split split
last element
increasing order
upper part
ascending order
descending order
smallest element
half wil
similar kind
thing happened
remember insertion
decreasing order
constant amount
app occur
lets continue
ten percent
ninety percent
elements change
first stage
ten elements
tenth means
ten number
right num
largest number
largest guy
base ten
decreasing decrementing
order log
times log
sir moving
upper bound
strange manner
constant fraction
thirty seventh
order argue
argue log
important thing
formal analysis
unlucky cases
unlucky case
lucky case
prove lets
word expected
partition half
median element
pivot pick
first place
odd number
small array
small arrays
involved procedure
random element
top pick
specific element
square running
randomized algorithm
random choices
equal probability
minus ten
ten split
ten versus
designing algorithms
randomized quick
randomized partition
last location
calling partition
random elements
random choice
good question
specific input
sorted sequence
interesting thing
random numbers
numbers selected
selected decide
algorithm today
input sequence
expected number
comparisons required
first partitions
partition process
left side
right place
thirteen minus
minus thirteen
quantity summed
compute expectations
expectations expectations
expected value
unloaded dice
variable random
random variable
variable lets
lets call
random variables
expectation expectation
probability means
variable takes
probability ten
variable ten
discrete values
value times
value summed
lets revert
probability times
quantity varies
last class
chosen permutation
binary search
search tree
sort worst
crucial difference
doing today
done today
sort depends
value today
value tomorrow
numbers generated
fixed input
pivot lets
squared times
input order
number choice
make things
fix element
makes sense
specific times
specific amount
specific algorithm
input sequences
vast difference
average case
case analysis
times depending
end today
lecture-10
today
talking
quick
sort
sorting
algorithm
discussing
series
lectures
first
insertion
argued
worst
case
running
order
squared
argue
average
expectation
takes
log
practice
fast
small
constants
property
place
nt
require
additional
memory
assume
numbers
array
two
variables
typically
good
thing
space
premium
large
collection
falls
paradine
divide
conquer
point
lot
algorithms
high
level
idea
problem
solve
pieces
smaller
step
partition
chose
partitioned
break
parts
call
lower
part
higher
element
number
put
elements
follow
entire
sorted
combining
trivial
done
combine
examples
understand
give
partitioning
linear
procedure
pivot
half
larger
instance
parameters
limits
refers
location
partitions
sub
end
means
t.k
ten
doing
value
minus
assigned
start
interested
lop
true
continue
loop
out
repeat
equal
index
decrementing
reach
decrement
locations
counting
reached
stopped
incrementing
greater
recall
left
right
sense
prints
exchange
contents
ort
blue
denote
orange
find
found
stop
things
moving
immediately
head
nineteen
swap
marked
searching
position
crossed
job
exit
return
returning
tells
boundary
halves
stud
dos
clear
taking
speaks
hindi
times
decremented
utmost
size
incremented
increment
questions
simple
manner
slightly
compare
nit
copy
back
purse
group
inside
wait
lets
loops
statement
total
executed
run
iteration
lops
file
sum
complete
initial
length
general
equals
make
invoke
previous
rearranges
returns
demarcating
lines
upper
separately
recursively
sir
forever
stops
condition
met
replace
note
create
copies
creating
local
passing
created
track
ignoring
variab
sitting
single
random
fixed
coming
minute
understands
repeatedly
notion
write
analyze
depend
split
happening
determine
suppose
dividing
started
lucky
median
ended
picked
divided
happened
four
effect
tree
drawn
levels
mine
eventually
naveen
excuse
big
theta
omega
inter
change
increase
decrease
increased
exact
constant
send
quality
side
situation
writing
recurrence
relation
earlier
assuming
term
basically
bothering
skewed
pictorially
height
makes
scheme
last
begin
input
increasing
happen
ascending
descending
smallest
wil
similar
kind
remember
figuring
decreasing
front
move
anymore
amount
comparison
app
occur
analysis
tenth
percent
ninety
stage
hundred
tenths
guy
similarly
continued
figure
num
largest
route
factor
base
tens
work
map
providing
bound
strange
fraction
sacrosanct
thirty
seventh
spectacular
special
important
afford
bad
hundredth
thousandth
millionth
formal
starting
motivation
alternate
unlucky
cases
prove
depth
operations
operation
comparisons
managed
worry
formally
scenarios
expect
word
expected
bit
pick
great
laugh
strategy
finding
straight
forward
..some
close
odd
arrays
compute
fairly
involved
learn
declare
top
specific
sequence
struck
square
randomized
making
choices
distinct
probability
splits
kinds
versus
picking
eleven
twelve
randomization
tool
designing
modify
randomize
generates
including
calling
calls
rest
choice
crucial
choose
difference
question
gong
fact
interesting
pivots
randomly
selected
tomorrow
depends
decide
deciding
nice
splitting
roughly
evenly
turning
.all
inputs
averaging
generated
fix
day
required
function
matter
process
compared
depending
leave
thirteen
quantity
summed
expectations
forgetting
roll
dice
outcomes
equally
occurs
doubt
throw
values
appears
unloaded
defined
variable
throwing
recording
outcome
billion
experiment
sufficiently
event
written
thinking
set
discrete
revert
slides
varies
summing
class
insert
chosen
permutation
binary
search
solved
showed
solution
quickly
summarize
dint
intuitively
behavior
inserting
recap
essentially
turns
aggregate
independent
adversely
beat
quit
turn
.for
knew
design
aware
listen
carefully
made
sequences
factorial
permutations
vast
looked
computed
hand
lecture
