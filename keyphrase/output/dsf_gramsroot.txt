structures and algorithms::structures and algorithms
naveen garg department::naveen garg department
department of computer::department of computer
science and engineering::science and engineering
engineering indian institute::engineering indian institute
institute of technology::institute of technology
talk about abstract::talk about abstract
abstract data types::abstract data types
stacks are implemented::stacks are implemented
implemented in java::implemented in java
java and application::java and application
talk about growable::talk about growable
bit of amortized::bit of amortized
talk about stacks::talk about stacks
stacks in java::stacks in java
java virtual machine::java virtual machine
abstract data type::abstract data type
basically a specification::basically a specification
set of axioms::set of axioms
axioms that define::axioms that define
define the semantics::define the semantics
types like integer::types like integer
understand the notion::understand the notion
notion of addition::notion of addition
integers in mathematics::integers in mathematics
define data types::define data types
types those operations::types those operations
parameters that operation::parameters that operation
case of integers::case of integers
integers as defined::integers as defined
defined in mathematics::defined in mathematics
add a variable::add a variable
variable of type::variable of type
method in java::method in java
create an instance::create an instance
talking about sophisticated::talking about sophisticated
sophisticated data types::sophisticated data types
lot of work::lot of work
work access functions::work access functions
type and manipulation::type and manipulation
manipulate or modify::manipulate or modify
modify the data::modify the data
talking about data::talking about data
types ? data::types ? data
identify the requirements::identify the requirements
level of abstraction::level of abstraction
talking in terms::talking in terms
terms of adding::terms of adding
terms of stacks::terms of stacks
stacks or queues::stacks or queues
advanced data type::advanced data type
encapsulate the data::encapsulate the data
data is organized::data is organized
algorithms that work::algorithms that work
separate the issues::separate the issues
issues of correctness::issues of correctness
correctness and efficiency::correctness and efficiency
start by giving::start by giving
giving a simple::giving a simple
set a set::set a set
set is defined::set is defined
collection of objects::collection of objects
modify that collection::modify that collection
add or remove::add or remove
remove an object::remove an object
changing the set::changing the set
create data types::create data types
kinds of methods::kinds of methods
method to create::method to create
create a dynamic::create a dynamic
insert an element::insert an element
element the result::element the result
includes the element::includes the element
similarly the delete::similarly the delete
delete method removes::delete method removes
removes the element::removes the element
methods for updating::methods for updating
updating the set::updating the set
set new method::set new method
creating or constructing::creating or constructing
constructing the set::constructing the set
set and isin::set and isin
true otherwise false::true otherwise false
operations should behave::operations should behave
set is empty::set is empty
define the nature::define the nature
code for implementing::code for implementing
implementing the dynamic::implementing the dynamic
talking about abstract::talking about abstract
axioms that govern::axioms that govern
govern those operations::govern those operations
simple abstract data::simple abstract data
collection of elements::collection of elements
remove an element::remove an element
last the operation::last the operation
operation of inserting::operation of inserting
inserting an element::inserting an element
operation of removing::operation of removing
removing an element::removing an element
kind of toys::kind of toys
elements for instance::elements for instance
stack of trays::stack of trays
put a tray::put a tray
remove or pop::remove or pop
define the abstract::define the abstract
create a stack::create a stack
adds this element::adds this element
type it inserts::type it inserts
inserts an object::inserts an object
pop takes stack::pop takes stack
pop the stack::pop the stack
removes the top::removes the top
stack is empty::stack is empty
flag an error::flag an error
empty the top::empty the top
top operation returns::top operation returns
returns the top::returns the top
pop pop operation::pop pop operation
pop operation removes::pop operation removes
removes that element::removes that element
empty then top::empty then top
make any sense::make any sense
method size tells::method size tells
stack and isempty::stack and isempty
size and isempty::size and isempty
methods and hope::methods and hope
methods are doing::methods are doing
governs the behavior::governs the behavior
push an element::push an element
doing a top::doing a top
stack abstract data::stack abstract data
translate abstract data::translate abstract data
type into code::type into code
interfaces and exceptions::interfaces and exceptions
methods are done::methods are done
names of parameter::names of parameter
write a class::write a class
provide the code::provide the code
write the classes::write the classes
interface different people::interface different people
people will write::people will write
write different classes::write different classes
classes to implement::classes to implement
implement the interface::implement the interface
completely different ways::completely different ways
meet the interface::meet the interface
meets the specification::meets the specification
program it helps::program it helps
separate the implementation::separate the implementation
built-in stack data::built-in stack data
stack data structure::stack data structure
define a stack::define a stack
method called size::method called size
methods are implemented::methods are implemented
takes a parameter::takes a parameter
parameter of type::parameter of type
type object object::type object object
type in java::type in java
objects are derived::objects are derived
type the method::type the method
method isempty returns::method isempty returns
isempty returns boolean::isempty returns boolean
returns an object::returns an object
object it throws::object it throws
notion of exceptions::notion of exceptions
exceptions void means::exceptions void means
return any object::return any object
return a stack::return a stack
modifies the stack::modifies the stack
stack thus stack::stack thus stack
exception ? exceptions::exception ? exceptions
mechanisms to handle::mechanisms to handle
reach some exceptional::reach some exceptional
execution of program::execution of program
throw an exception::throw an exception
exception the term::exception the term
java is throw::java is throw
exception is thrown::exception is thrown
flow of control::flow of control
occurs you delegate::occurs you delegate
delegate the responsibility::delegate the responsibility
responsibility of handling::responsibility of handling
handling that exceptional::handling that exceptional
eat pizza method::eat pizza method
method which throws::method which throws
throws a stomachache::throws a stomachache
stomachacheexception the procedure::stomachacheexception the procedure
procedure public void::procedure public void
public void eatpizza::public void eatpizza
inside the stimulate::inside the stimulate
stimulate meeting procedure::stimulate meeting procedure
stomachacheexception is thrown::stomachacheexception is thrown
exist this method::exist this method
executed the flow::executed the flow
control would interrupt::control would interrupt
interrupt the dotted::interrupt the dotted
modifications are carried::modifications are carried
enclose the method::enclose the method
open a bracket::open a bracket
include the method::include the method
calling and close::calling and close
raised in ta.eatpizza::raised in ta.eatpizza
skip the catch::skip the catch
exception was raised::exception was raised
method might raise::method might raise
raise many exceptions::raise many exceptions
block and execute::block and execute
execute the statements::execute the statements
raises an exception::raises an exception
exception is caught::exception is caught
inside the catch::inside the catch
block any kind::block any kind
kind of statements::kind of statements
write the catch::write the catch
procedure simulate meeting::procedure simulate meeting
throw the exception::throw the exception
throws an exception::throws an exception
catches the exception::catches the exception
high level procedure::high level procedure
finally your procedure::finally your procedure
procedure will stop::procedure will stop
exception is shown::exception is shown
method to print::method to print
print the statement::print the statement
creating an object::creating an object
initializing that instance::initializing that instance
set of parameters::set of parameters
object by making::object by making
making a call::making a call
statement is caught::statement is caught
created by stomachacheexception::created by stomachacheexception
procedural hierarchy stomachacheexception::procedural hierarchy stomachacheexception
stomachacheexception would throw::stomachacheexception would throw
procedure of simulate::procedure of simulate
meeting would throw::meeting would throw
reaches the console::reaches the console
written would signify::written would signify
signify in java::signify in java
java it signifies::java it signifies
invoking the constructor::invoking the constructor
method for listening::method for listening
exceptions and catching::exceptions and catching
exception in turn::exception in turn
add a throws::add a throws
wrote the method::wrote the method
stomachacheexception a method::stomachacheexception a method
method can throw::method can throw
exception in java::exception in java
class public class::class public class
public class stomachacheexception::public class stomachacheexception
class stomachacheexception extends::class stomachacheexception extends
class name public::class name public
constructor method takes::constructor method takes
takes a single::takes a single
string super means::string super means
calling the super::calling the super
catch an exception::catch an exception
chain of method::chain of method
stomach ache exception::stomach ache exception
exception is extending::exception is extending
extending a run::extending a run
run time exception::run time exception
call the constructor::call the constructor
created the interface::created the interface
implement the methods::implement the methods
ways of implementing::ways of implementing
implementing a stack::implementing a stack
stack the variable::stack the variable
push another element::push another element
out an entire::out an entire
interface my implementation::interface my implementation
array to implement::array to implement
implement the stack::implement the stack
stack the statement::stack the statement
implementing the stack::implementing the stack
stack interface public::stack interface public
interface public class::interface public class
public class arraystack::public class arraystack
class arraystack implements::class arraystack implements
arraystack implements stack::arraystack implements stack
implements stack implement::implements stack implement
stack implement stack::stack implement stack
implement stack means::implement stack means
variable n final::variable n final
value of capacity::value of capacity
hold the elements::hold the elements
array of object::array of object
means the top::means the top
call the array::call the array
stack whose capacity::stack whose capacity
call array stack::call array stack
stack of size::stack of size
method would return::method would return
push an object::push an object
stack already equals::stack already equals
throw a stack::throw a stack
stack full exception::stack full exception
put the object::put the object
stack empty exception::stack empty exception
control would exit::control would exit
exit from throw::exit from throw
throw new stack::throw new stack
save the top::save the top
element in location::element in location
removing the top::removing the top
earlier was set::earlier was set
set to null::set to null
remove that object::remove that object
object and decrement::object and decrement
decrement t to36::decrement t to36
return the top::return the top
top element pop::top element pop
pop also returns::pop also returns
null ; return::null ; return
create an object::create an object
dereference the objects::dereference the objects
remove those objects::remove those objects
array of objects::array of objects
access the element::access the element
operations were taking::operations were taking
required time propositional::required time propositional
number of elements::number of elements
stack this upper::stack this upper
creation of stack::creation of stack
stack the problem::stack the problem
waste of memory::waste of memory
run our procedure::run our procedure
procedure to complete::procedure to complete
full exception stack::full exception stack
exception stack empty::exception stack empty
raise a stack::raise a stack
grow the stack::grow the stack
stack when needed::stack when needed
application of stacks::application of stacks
daily stock prices::daily stock prices
price on day::price on day
number of consecutive::number of consecutive
make it clear::make it clear
number of days::number of days
equal to day::equal to day
days the price::days the price
day five equals::day five equals
day following picture::day following picture
picture would make::picture would make
compute the span::compute the span
array of numbers::array of numbers
numbers to compute::numbers to compute
stock on day::stock on day
moment you find::moment you find
find a case::find a case
price of stock::price of stock
stop the loop::stop the loop
done is true::done is true
exist the repeat-until::exist the repeat-until
exit the repeat-until::exit the repeat-until
loop if done::loop if done
span of stock::span of stock
computing this span::computing this span
times the repeat-until::times the repeat-until
n-1 the total::n-1 the total
number of times::number of times
statement get executed::statement get executed
worst case question::worst case question
talking of stacks::talking of stacks
closest day preceding::closest day preceding
price is greater::price is greater
day preceding day::day preceding day
greater for day::greater for day
call the quantity::call the quantity
determine the span::determine the span
quantities ? suppose::quantities ? suppose
told the price::told the price
price is larger::price is larger
larger than price::larger than price
similarly that day::similarly that day
store the indices::store the indices
top to determine::top to determine
compare the price::compare the price
suppose the price::suppose the price
greater than price::greater than price
compare with price::compare with price
first price greater::first price greater
update my stack::update my stack
compare that price::compare that price
stack will give::stack will give
remove the top::remove the top
rid of 6th::rid of 6th
done becomes true::done becomes true
found a price::found a price
current day price::current day price
stack becomes empty::stack becomes empty
statement if d.isempty::statement if d.isempty
times while loop::times while loop
loop might execute::loop might execute
execute a lot::execute a lot
lot of times::lot of times
element is pushed::element is pushed
elements to begin::elements to begin
loop is executed::loop is executed
loop gets executed::loop gets executed
stack it means::stack it means
times the loop::times the loop
inside the for-loop::inside the for-loop
for-loop if statements::for-loop if statements
remove one element::remove one element
elements we pushed::elements we pushed
give maximum size::give maximum size
stack can grow::stack can grow
pushing an element::pushing an element
array of length::array of length
increase the size::increase the size
stack i increment::stack i increment
increment the top::increment the top
increment the size::increment the size
double the size::double the size
push the element::push the element
takes one unit::takes one unit
create a larger::create a larger
stack and copy::stack and copy
copy the elements::copy the elements
form the earlier::form the earlier
created a stack::created a stack
elements that cost::elements that cost
cost n units::cost n units
element that cost::element that cost
unit the total::unit the total
special push operation::special push operation
tight strategy behaves::tight strategy behaves
initially i started::initially i started
array of size::array of size
push this first::push this first
enlarge my stack::enlarge my stack
cost one unit::cost one unit
push the 3rd::push the 3rd
3rd and 4th::3rd and 4th
push which costs::push which costs
create an array::create an array
incrementing the size::incrementing the size
operator in phase::operator in phase
cost of phase::cost of phase
beginning of phase::beginning of phase
copy the previous::copy the previous
cost of copying::cost of copying
copying the elements::copying the elements
array gets filled::array gets filled
doing the total::doing the total
doing c pushes::doing c pushes
phases total cost::phases total cost
cost of phases::cost of phases
creation as order::creation as order
case the analysis::case the analysis
analysis would change::analysis would change
purposes of analysis::purposes of analysis
creating an array::creating an array
element i create::element i create
double this array::double this array
push this element::push this element
array and create::array and create
push while pushing::push while pushing
push the 5th::push the 5th
size of array::size of array
copy these elements::copy these elements
analyze the cost::analyze the cost
cost of creating::cost of creating
creating the array::creating the array
cost for pushing::cost for pushing
created an array::created an array
array of cost::array of cost
cost of pushing::cost of pushing
pushing we created::pushing we created
pushing the element::pushing the element
define a phase::define a phase
call it phase::call it phase
array has size::array has size
elements are left::elements are left
left after copying::left after copying
elements ? elements::elements ? elements
elements the total::elements the total
log n phases::log n phases
array is growing::array is growing
strategy data structures::strategy data structures
queues and linked::queues and linked
lecture we looked::lecture we looked
looked at stacks::looked at stacks
list and double::list and double
double ended queues::double ended queues
last-in first-out principle::last-in first-out principle
principle whoever joins::principle whoever joins
joins the queue::joins the queue
queue for instance::queue for instance
element is inserted::element is inserted
element from queue::element from queue
front is removed::front is removed
removed the queue::removed the queue
queue the methods::queue the methods
operations the method::operations the method
create a queue::create a queue
queue and enqueue::queue and enqueue
method to add::method to add
add an element::add an element
queue and dequeue::queue and dequeue
dequeue a queue::dequeue a queue
differ from dequeue::differ from dequeue
remove the front::remove the front
implement the queue::implement the queue
queue and isempty::queue and isempty
queue is empty::queue is empty
define similar axioms::define similar axioms
axioms for queues::axioms for queues
element or enqueue::element or enqueue
enqueue an element::enqueue an element
suppose i create::suppose i create
dequeue an element::dequeue an element
enqueued an element::enqueued an element
means i added::means i added
added an element::added an element
added another element::added another element
front of queue::front of queue
notion of front::notion of front
removed an element::removed an element
element the element::element the element
queue was empty::queue was empty
result is true::result is true
first i added::first i added
cases the queue::cases the queue
procedure if queue::procedure if queue
thing in enqueue::thing in enqueue
dequeued which means::dequeued which means
means i removed::means i removed
removed the front::removed the front
element of queue::element of queue
queue the queue::queue the queue
implement a queue::implement a queue
fashion to implement::fashion to implement
suppose someone tells::suppose someone tells
allocate an array::allocate an array
element the blue::element the blue
reach the blue::reach the blue
blue colored part::blue colored part
element i inserted::element i inserted
delete the elements::delete the elements
effect the elements::effect the elements
element has moved::element has moved
moved to right::moved to right
right this implies::right this implies
deleted f-1 elements::deleted f-1 elements
inserting the elements::inserting the elements
elements in queue::elements in queue
queue i insert::queue i insert
insert another element::insert another element
insert anymore elements::insert anymore elements
reached the end::reached the end
elements your queue::elements your queue
started the front::started the front
front was referring::front was referring
point i reach::point i reach
reach a situation::reach a situation
empty or full::empty or full
empty ? suppose::empty ? suppose
removing the elements::removing the elements
elements before location::elements before location
adding the elements::adding the elements
move one step::move one step
close to location::close to location
add the element::add the element
empty and full::empty and full
n-1 one elements::n-1 one elements
code for enqueue::code for enqueue
queue is full::queue is full
return the queue::return the queue
queue full exception::queue full exception
case then add::case then add
add the rear::add the rear
put the element::put the element
insert and increment::insert and increment
modn is required::modn is required
enclosed in brackets::enclosed in brackets
r-f ? r-f::r-f ? r-f
r-f is negative::r-f is negative
check this out::check this out
means the queue::means the queue
return a front::return a front
removing the front::removing the front
case of dequeue::case of dequeue
increment the front::increment the front
index and remove::index and remove
element by setting::element by setting
implement our queue::implement our queue
queue the disadvantage::queue the disadvantage
array is fixed::array is fixed
essentially a linked::essentially a linked
list the first::list the first
node is referred::node is referred
tail of list::tail of list
list to implement::list to implement
queue the head::queue the head
2nd second element::2nd second element
remove the torcezo::remove the torcezo
element the linked::element the linked
element from linked::element from linked
remove that element::remove that element
accessing that pointer::accessing that pointer
remove the rome::remove the rome
queue the removal::queue the removal
remove the element::remove the element
implement our methods::implement our methods
dequeue which means::dequeue which means
left head part::left head part
point the head::point the head
making the head::making the head
delete the head::delete the head
node and make::node and make
make the head::make the head
node thus inserting::node thus inserting
easy the head::easy the head
move the head::move the head
queue the pointer::queue the pointer
modified to point::modified to point
newly added element::newly added element
difficult to remove::difficult to remove
element in constant::element in constant
remove the tail::remove the tail
access the previous::access the previous
kind of list::kind of list
beginning and move::beginning and move
problem in removing::problem in removing
last before node::last before node
make the tail::make the tail
head and add::head and add
means the front::means the front
queue data type::queue data type
introduce another data::introduce another data
type called double-ended::type called double-ended
insert and delete::insert and delete
queue and remove::queue and remove
operations of insert::operations of insert
singly linked list::singly linked list
idea to implement::idea to implement
doubly linked list::doubly linked list
implement double-ended queues::implement double-ended queues
list has nodes::list has nodes
two sentinel nodes::two sentinel nodes
nodes each node::nodes each node
operations of double-ended::operations of double-ended
queue in constant::queue in constant
delete the node::delete the node
end the head::end the head
follow the pointer::follow the pointer
element to delete::element to delete
delete that node::delete that node
port and set::port and set
pointer to trailer::pointer to trailer
trailer and send::trailer and send
send the previous::send the previous
pointer of trailer::pointer of trailer
header and trailer::header and trailer
list these nodes::list these nodes
nodes or dummy::nodes or dummy
mark the start::mark the start
delete san francisco::delete san francisco
make the sentinel::make the sentinel
sentinel node point::sentinel node point
make that previous::make that previous
node to point::node to point
node is deleted::node is deleted
done in constant::done in constant
front or delete::front or delete
meant by constant::meant by constant
independent of number::independent of number
fairly generic data::fairly generic data
generic data type::generic data type
implement other data::implement other data
types also suppose::types also suppose
implementation of double-ended::implementation of double-ended
make a stack::make a stack
implementation to implement::implementation to implement
implement a stack::implement a stack
stack for instance::stack for instance
stack would correspond::stack would correspond
return the last::return the last
queue the method::queue the method
correspond to inserting::correspond to inserting
double ended queue::double ended queue
correspond to deleting::correspond to deleting
make the last::make the last
case the last::case the last
front and insert::front and insert
corresponds to isempty::corresponds to isempty
queue to implement::queue to implement
corresponds to last::corresponds to last
removes the first::removes the first
methods to implement::methods to implement
stack or queue::stack or queue
pattern thus adapter::pattern thus adapter
adapter patterns implements::adapter patterns implements
implements a class::implements a class
class using methods::class using methods
class in general::class in general
adapter classes specialize::adapter classes specialize
classes specialize general::classes specialize general
specialize general classes::specialize general classes
implement by changing::implement by changing
changing some methods::changing some methods
queue another application::queue another application
stack we define::stack we define
define an interface::define an interface
interface called stack::interface called stack
stack and implemented::stack and implemented
array that implementation::array that implementation
contents of array::contents of array
adapt arraystack implementation::adapt arraystack implementation
implementation called integerarraystack::implementation called integerarraystack
cast the type::cast the type
stack or removing::stack or removing
circularly linked list::circularly linked list
element is pointing::element is pointing
head and tail::head and tail
implement both queue::implement both queue
structure to implement::structure to implement
make the first::make the first
make the pointer::make the pointer
make the element::make the element
node and create::node and create
node and copy::node and copy
copy the element::copy the element
node and copying::node and copying
corresponds to removing::corresponds to removing
removing the first::removing the first
remove the first::remove the first
problem in doing::problem in doing
remove the 2nd::remove the 2nd
copy the contents::copy the contents
seattle to rome::seattle to rome
rome thus rome::rome thus rome
rome has seattle::rome has seattle
2nd node copying::2nd node copying
copying just means::copying just means
changing the reference::changing the reference
discusses about queues::discusses about queues
queues and double-ended::queues and double-ended
talk about vectors::talk about vectors
list and general::list and general
structures like arrays::structures like arrays
arrays and linked::arrays and linked
lists to implement::lists to implement
implement these data::implement these data
vector data type::vector data type
type ? vector::type ? vector
elements that supports::elements that supports
notion of rank::notion of rank
sequence of elements::sequence of elements
methods like elematrank::methods like elematrank
elematrank r rank::elematrank r rank
rank here corresponds::rank here corresponds
integers first element::integers first element
element at rank::element at rank
give the element::give the element
replace the element::replace the element
delete the element::delete the element
suppose the departmental::suppose the departmental
department the department::department the department
implement the data::implement the data
type using arrays::type using arrays
element with rank::element with rank
put an element::put an element
n-1 one step::n-1 one step
n-2 is moved::n-2 is moved
moved one step::moved one step
right finally element::right finally element
put at position::put at position
size is increased::size is increased
sores the size::sores the size
shifting the entire::shifting the entire
elements one step::elements one step
left all elements::left all elements
sitting at location::sitting at location
case ? order::case ? order
left this implementation::left this implementation
implementation is expensive::implementation is expensive
point of view::point of view
two operations insert::two operations insert
rank or remove::rank or remove
worst case spent::worst case spent
case spent order::case spent order
operations are faster::operations are faster
array and retrieve::array and retrieve
retrieve the elements::retrieve the elements
sitting there replaceatrank::sitting there replaceatrank
location and replace::location and replace
replace that element::replace that element
element with element::element with element
methods all methods::methods all methods
methods except inserted::methods except inserted
inserted at rank::inserted at rank
rank and remove::rank and remove
remove at rank::remove at rank
rank take constant::rank take constant
implementing this list::implementing this list
implement a vector::implement a vector
node and put::node and put
create the node::create the node
make a pointer::make a pointer
make the previous::make the previous
previous pointer point::previous pointer point
insert takes order::insert takes order
order n times::order n times
insert at rank::insert at rank
insert the element::insert the element
code for inserting::code for inserting
assuming the existence::assuming the existence
insert the node::insert the node
node at rank::node at rank
call the procedure::call the procedure
procedure with rank::procedure with rank
previous to rank::previous to rank
prev i create::prev i create
set its previous::set its previous
prev = next.getprev::prev = next.getprev
earlier at rank::earlier at rank
manner i create::manner i create
check the previous::check the previous
doing here next.setprev::doing here next.setprev
process of deletion::process of deletion
out the node::out the node
node and update::node and update
pointer will point::pointer will point
node and previous::node and previous
code for doing::code for doing
assuming the procedure::assuming the procedure
implement this procedure::implement this procedure
incrementing my counter::incrementing my counter
reach that rank::reach that rank
list has hundred::list has hundred
point to start::point to start
vector abstract data::vector abstract data
type is concerned::type is concerned
rank or insert::rank or insert
move the elements::move the elements
insert or delete::insert or delete
delete linked lists::delete linked lists
supporting node based::supporting node based
node based operations::node based operations
delete this node::delete this node
node in constant::node in constant
node and insert::node and insert
delete the inserted::delete the inserted
insert a node::insert a node
constant time operations::constant time operations
mentioned below removeatnode::mentioned below removeatnode
give you access::give you access
implemented my list::implemented my list
pointers and stuff::pointers and stuff
node based operation::node based operation
operation without knowing::operation without knowing
knowing the actual::knowing the actual
thing was done::thing was done
notion of positions::notion of positions
captures the place::captures the place
element is stored::element is stored
data type position::data type position
call this method::call this method
making much sense::making much sense
position as reference::position as reference
pointer to update::pointer to update
node is implemented::node is implemented
type which hides::type which hides
notion of position::notion of position
order of positions::order of positions
position is referring::position is referring
similarly 1st position::similarly 1st position
define a list::define a list
list abstract datatype::list abstract datatype
methods like size::methods like size
method which asks::method which asks
methods like first::methods like first
first will give::first will give
last would give::last would give
methods like swapelements::methods like swapelements
swaps the contents::swaps the contents
positions it swaps::positions it swaps
element at position::element at position
methods in constant::methods in constant
linked list data::linked list data
list data structure::list data structure
abstract datatype implementation::abstract datatype implementation
datatype this datatype::datatype this datatype
double linked list::double linked list
sequence abstract data::sequence abstract data
type we talked::type we talked
list data type::list data type
combines the vector::combines the vector
list abstract data::list abstract data
listed for vector::listed for vector
vector and list::vector and list
two additional methods::two additional methods
methods which helps::methods which helps
identify the rank::identify the rank
determine the position::determine the position
suppose you gave::suppose you gave
gave me rank::gave me rank
follow 1st reference::follow 1st reference
create new position::create new position
element would sit::element would sit
change the ranks::change the ranks
ranks and update::ranks and update
update the position::update the position
position again inserting::position again inserting
deleting an element::deleting an element
wanted to delete::wanted to delete
delete an element::delete an element
comparison of sequence::comparison of sequence
implement a sequence::implement a sequence
case of running::case of running
out the element::out the element
update the pointers::update the pointers
out the rank::out the rank
list to figure::list to figure
rank any rank::rank any rank
rank based operation::rank based operation
find the rank::find the rank
out the position::out the position
learnt about queues::learnt about queues
essentially a concretization::essentially a concretization
looked at sequence::looked at sequence
sequence data types::sequence data types
data type data::data type data
type data structures::type data structures
dictionary abstract data::dictionary abstract data
search is done::search is done
analysis for binary::analysis for binary
hashing is done::hashing is done
collision resolution techniques::collision resolution techniques
type that stores::type that stores
located very quickly::located very quickly
store bank accounts::store bank accounts
account has lots::account has lots
lots of information::lots of information
access the bank::access the bank
account or data::account or data
account stores wealth::account stores wealth
wealth of information::wealth of information
list of transactions::list of transactions
last few days::last few days
key a dictionary::key a dictionary
stores the elements::stores the elements
talk of key::talk of key
number that helps::number that helps
information any application::information any application
application that wishes::application that wishes
kind of operation::kind of operation
provide the account::provide the account
number as key::number as key
key the process::key the process
basically an abstract::basically an abstract
store the key-element::store the key-element
pairs the key::pairs the key
key your entry::key your entry
identifies particular student::identifies particular student
dictionary is searching::dictionary is searching
searching by key::searching by key
kinds of method::kinds of method
standard container methods::standard container methods
queues and stacks::queues and stacks
dictionary is empty::dictionary is empty
find the element::find the element
kind of settings::kind of settings
return all elements::return all elements
remove all elements::remove all elements
remember the notion::remember the notion
special element nil::special element nil
search it means::search it means
return a nill::return a nill
comparison of keys::comparison of keys
keys for equality::keys for equality
two particular keys::two particular keys
doing is searching::doing is searching
notion of taking::notion of taking
taking two names::taking two names
smaller or larger::smaller or larger
operation we require::operation we require
require is comparing::require is comparing
implementing this abstract::implementing this abstract
implement a dictionary::implement a dictionary
implement this dictionary::implement this dictionary
predecessor or successor::predecessor or successor
completely arbitrary manner::completely arbitrary manner
manner the nodes::manner the nodes
throw them arbitrary::throw them arbitrary
red or black::red or black
mechanisms of data::mechanisms of data
structures to implement::structures to implement
important data type::important data type
lectures in java::lectures in java
class called java.util.dictionary::class called java.util.dictionary
java.util.dictionary which lays::java.util.dictionary which lays
out the specification::out the specification
interface called java.util.map::interface called java.util.map
problem of searching::problem of searching
sequence of numbers::sequence of numbers
database i give::database i give
return the position::return the position
number or nil::number or nil
sitting at position::sitting at position
technique called binary::technique called binary
recall the technique::recall the technique
search is divide::search is divide
divide and conquer::divide and conquer
problems in divide::problems in divide
divide and search::divide and search
range of elements::range of elements
suppose the elements::suppose the elements
increasing or decreasing::increasing or decreasing
decreasing for binary::decreasing for binary
search to work::search to work
set of elements::set of elements
order this means::order this means
low and high::low and high
element which means::element which means
compare the middle::compare the middle
return this information::return this information
search the procedure::search the procedure
read and understand::read and understand
understand this quickly::understand this quickly
notion of low::notion of low
range and high::range and high
end and high::end and high
end if low::end if low
basically that means::basically that means
invoking something wrong::invoking something wrong
return a null::return a null
obtained by taking::obtained by taking
taking the average::taking the average
average of low::average of low
high and check::high and check
found the key::found the key
array the left::array the left
staring location low::staring location low
ending location mid-1::ending location mid-1
array which means::array which means
means the mid::means the mid
high else return::high else return
search for small::search for small
pieces of code::pieces of code
write an iterative::write an iterative
low to begin::low to begin
high to begin::high to begin
loop and updating::loop and updating
high and low::high and low
first step low::first step low
low becomes mid::low becomes mid
element was larger::element was larger
element is smaller::element is smaller
element then high::element then high
find the key::find the key
return the location::return the location
key or low::key or low
low becomes larger::low becomes larger
larger than high::larger than high
loop and return::loop and return
write a binary::write a binary
two different ways::two different ways
problem is halved::problem is halved
essentially the range::essentially the range
comparison the range::comparison the range
log n comparison::log n comparison
roughly require comparisons::roughly require comparisons
location you desire::location you desire
desire in constant::desire in constant
write any base::write any base
base for log::base for log
suppose the numbers::suppose the numbers
array one element::array one element
compare your key::compare your key
element you searched::element you searched
spend some order::spend some order
array is sorted::array is sorted
huge difference coming::huge difference coming
sort the element::sort the element
element to begin::element to begin
small pseudo code::small pseudo code
asked to implement::asked to implement
implement a caller::implement a caller
caller id facility::caller id facility
large phone company::large phone company
making the call::making the call
return the callers::return the callers
case in delhi::case in delhi
delhi the range::delhi the range
range of phone::range of phone
million phone numbers::million phone numbers
numbers the number::numbers the number
numbers are present::numbers are present
actual different number::actual different number
element ? suppose::element ? suppose
decides to give::decides to give
remove it searching::remove it searching
searching itself takes::searching itself takes
removing also takes::removing also takes
thing in order::thing in order
putting the elements::putting the elements
location thus inserting::location thus inserting
implementation is good::implementation is good
things is faliable::things is faliable
maintain log files::maintain log files
maintain some kinds::maintain some kinds
kinds of log::kinds of log
file for instance::file for instance
instance any kind::instance any kind
kind of transactions::kind of transactions
revert the transaction::revert the transaction
system and maintain::system and maintain
maintain the log::maintain the log
search or removals::search or removals
frequent but searches::frequent but searches
searches and deletion::searches and deletion
case this implementation::case this implementation
good because insertion::good because insertion
takes only constant::takes only constant
remove and insert::remove and insert
operation being performed::operation being performed
decide what type::decide what type
type of data::type of data
implement the dictionary::implement the dictionary
dictionary data type::dictionary data type
elements were put::elements were put
key searching takes::key searching takes
searching takes log::searching takes log
log n provided::log n provided
kind of direct::kind of direct
direct access mechanism::direct access mechanism
element you wanted::element you wanted
inserting and removing::inserting and removing
maintain the sorted::maintain the sorted
move it back::move it back
examples in previous::examples in previous
insertion take order::insertion take order
order n elements::order n elements
recall your big-oh::recall your big-oh
lot of searching::lot of searching
insertions and deletions::insertions and deletions
array and put::array and put
position which corresponds::position which corresponds
corresponds to ankur::corresponds to ankur
ankur phone number::ankur phone number
number all operations::number all operations
search and delete::search and delete
insert a caller::insert a caller
caller id capability::caller id capability
wasting a lot::wasting a lot
lot of space::lot of space
operations very quickly::operations very quickly
space is turning::space is turning
two much space::two much space
create a smaller::create a smaller
users to locations::users to locations
number of users::number of users
fancy i create::fancy i create
compute this value::compute this value
ankur at location::ankur at location
insertion and delete::insertion and delete
numbers but entry::numbers but entry
numbers of students::numbers of students
class your entry::class your entry
numbers is huge::numbers is huge
set of values::set of values
create a table::create a table
table of size::table of size
spend more space::spend more space
function this function::function this function
previous example mod::previous example mod
takes the last::takes the last
mapped to location::mapped to location
clash ? suppose::clash ? suppose
delete and search::delete and search
address the problem::address the problem
problem of clash::problem of clash
address this issue::address this issue
keys which mapped::keys which mapped
concept called chaining::concept called chaining
ways of addressing::ways of addressing
addressing this issue::addressing this issue
issue and today::issue and today
technique called chaining::technique called chaining
blue color thing::blue color thing
put the elements::put the elements
linked list starting::linked list starting
linked list suppose::linked list suppose
suppose my hash::suppose my hash
taking the key::taking the key
key and computing::key and computing
keys were mapped::keys were mapped
keys getting mapped::keys getting mapped
mapped to locations::mapped to locations
problem of collision::problem of collision
resolved the collision::resolved the collision
things in constant::things in constant
keys get mapped::keys get mapped
data structure reduces::data structure reduces
delete still insert::delete still insert
insert has constant::insert has constant
person who sits::person who sits
examples of hash::examples of hash
kinds of hash::kinds of hash
typically used hash::typically used hash
functions the last::functions the last
regarded as modulo::regarded as modulo
function to find::function to find
find the position::find the position
search or insert::search or insert
maintain the list::maintain the list
order then insertion::order then insertion
unordered then insertion::unordered then insertion
end of linked::end of linked
traverse the entire::traverse the entire
list to reach::list to reach
reach the end::reach the end
maintaining one pointer::maintaining one pointer
pointer to add::pointer to add
notion of order::notion of order
notion to order::notion to order
order the elements::order the elements
elements an element::elements an element
element with key::element with key
value of hash::value of hash
function the hash::function the hash
function is mapping::function is mapping
mapping the universe::mapping the universe
compute the hash::compute the hash
simple arithmetic operations::simple arithmetic operations
operations to compute::operations to compute
compute the value::compute the value
function is independent::function is independent
choice of hash::choice of hash
functions are concerned::functions are concerned
choices of hash::choices of hash
hash function lot::hash function lot
lot of research::lot of research
research has done::research has done
function that people::function that people
motivate the concept::motivate the concept
good hash function::good hash function
distribute the keys::distribute the keys
keys to location::keys to location
structure would start::structure would start
single linked list::single linked list
function which distributes::function which distributes
list is small::list is small
ideal hash function::ideal hash function
pick at random::pick at random
locations then throw::locations then throw
throw the element::throw the element
function which takes::function which takes
takes a key::takes a key
key and puts::key and puts
takes the element::takes the element
element and throws::element and throws
simple uniform hash::simple uniform hash
uniform hash function::uniform hash function
number of slots::number of slots
call this load::call this load
load factor alpha::load factor alpha
search is unsuccessful::search is unsuccessful
element i computed::element i computed
computed the value::computed the value
entire linked list::entire linked list
spend time propositional::spend time propositional
computing the hash::computing the hash
hash function takes::hash function takes
function takes constant::function takes constant
right linked list::right linked list
pointer by pointer::pointer by pointer
simple hash function::simple hash function
distributing the things::distributing the things
table the excepted::table the excepted
roughly a constant::roughly a constant
ideal hash functions::ideal hash functions
create a bad::create a bad
bad hash function::bad hash function
spent in computing::spent in computing
data structure relies::data structure relies
function we choose::function we choose
good hash functions::good hash functions
class designing hash::class designing hash
designing hash function::designing hash function
art than science::art than science
data to design::data to design
design a good::design a good
class some principle::class some principle
kind of hash::kind of hash
make a successful::make a successful
find my element::find my element
ways of arguing::ways of arguing
database the element::database the element
case of successful::case of successful
successful search excepted::successful search excepted
search excepted number::search excepted number
element was inserted::element was inserted
inserted and appended::inserted and appended
compare that element::compare that element
number of comparisons::number of comparisons
hash function computation::hash function computation
roughly the excepted::roughly the excepted
excepted time required::excepted time required
required to insert::required to insert
summing this quantity::summing this quantity
elements and taking::elements and taking
average time computations::average time computations
list or find::list or find
half the length::half the length
kind of behavior::kind of behavior
low order term::low order term
successful and unsuccessful::successful and unsuccessful
taking a similar::taking a similar
pick the size::pick the size
size of hash::size of hash
size our hash::size our hash
table should start::table should start
concept of growable::concept of growable
structures you start::structures you start
elements you inserting::elements you inserting
sizes of linked::sizes of linked
move the entire::move the entire
set of element::set of element
larger hash table::larger hash table
modify these things::modify these things
design your hash::design your hash
hash function keeping::hash function keeping
keeping in mind::keeping in mind
number of hash::number of hash
hash table slots::hash table slots
slots was propositional::slots was propositional
pick the number::pick the number
table can accommodate::table can accommodate
accommodate any number::accommodate any number
attach any number::attach any number
table would deteriorate::table would deteriorate
10,000 elements coming::10,000 elements coming
average the linked::average the linked
linked list length::linked list length
case it make::case it make
sense to move::sense to move
create a hash::create a hash
wastage of space::wastage of space
small hash table::small hash table
large hash table::large hash table
bit of hashing::bit of hashing
continue with hashing::continue with hashing
hashing c concepts::hashing c concepts
concepts of good::concepts of good
ways of resolving::ways of resolving
resolving collision data::resolving collision data
collision data structures::collision data structures
continue our discussion::continue our discussion
discussion on hashing::discussion on hashing
concept of hashing::concept of hashing
collision in hashing::collision in hashing
hashing using linked::hashing using linked
list that method::list that method
method of collision::method of collision
methods for collision::methods for collision
probing and double::probing and double
performance of hashing::performance of hashing
linked list good::linked list good
list good hash::list good hash
paradox called birthday::paradox called birthday
compute that probability::compute that probability
fairly high probability::fairly high probability
kind of thing::kind of thing
thing is happening::thing is happening
key and put::key and put
keys would end::keys would end
deal with non-integer::deal with non-integer
keys in fact::keys in fact
keys were telephone::keys were telephone
returned the telephone::returned the telephone
numbers with hyphen::numbers with hyphen
treat telephone number::treat telephone number
dropped the hyphen::dropped the hyphen
techniques of converting::techniques of converting
converting non-integers keys::converting non-integers keys
hash function value::hash function value
converting non-integer keys::converting non-integer keys
keys into integer::keys into integer
integer ones hash::integer ones hash
hash code map::hash code map
function a hash::function a hash
basically a mapping::basically a mapping
mapping of keys::mapping of keys
keys to indices::keys to indices
table your hash::table your hash
maps the key::maps the key
integer keys key::integer keys key
key ? integer::key ? integer
bring this integer::bring this integer
table that part::table that part
call as compression::call as compression
kinds of functions::kinds of functions
map and compression::map and compression
map another important::map another important
requirement of hash::requirement of hash
key gets mapped::key gets mapped
map a key::map a key
maps to location::maps to location
kind of randomization::kind of randomization
retrieve or search::retrieve or search
map equal keys::map equal keys
minimize the probability::minimize the probability
probability of collisions::probability of collisions
popular hash-code maps::popular hash-code maps
maps the hash-code::maps the hash-code
part which converts::part which converts
converts your key::converts your key
integer one thing::integer one thing
pattern and interpret::pattern and interpret
reinterpret the bits::reinterpret the bits
integer your key::integer your key
double real number::double real number
number which takes::number which takes
bits and add::bits and add
bytes and add::bytes and add
kind of tree::kind of tree
integer one possibility::integer one possibility
number of collisions::number of collisions
collisions be high::collisions be high
kind of things::kind of things
convert character strings::convert character strings
integer one technique::integer one technique
polynomial whose coefficients::polynomial whose coefficients
evaluate this polynomial::evaluate this polynomial
string that integer::string that integer
map to map::map to map
convert a string::convert a string
people have looked::people have looked
technique to convert::technique to convert
convert your words::convert your words
table one natural::table one natural
taking some integer::taking some integer
essentially that means::essentially that means
taking the last::taking the last
write the integer::write the integer
taking some small::taking some small
set of bits::set of bits
simple compression map::simple compression map
fact it helps::fact it helps
strings per location::strings per location
list one important::list one important
hash table close::hash table close
kind of effect::kind of effect
effect will start::effect will start
prime number things::prime number things
lot of collisions::lot of collisions
collisions happening lot::collisions happening lot
follow will improve::follow will improve
improve the performance::improve the performance
necessarily a prime::necessarily a prime
kinds of compression::kinds of compression
first i read::first i read
out the 2nd::out the 2nd
suppose your keys::suppose your keys
recall now assuming::recall now assuming
keys are integers::keys are integers
map to convert::map to convert
integer the keys::integer the keys
range through times::range through times
multiply each key::multiply each key
first we converted::first we converted
key that corresponds::key that corresponds
multiply that number::multiply that number
function which means::function which means
rounded that number::rounded that number
key and multiplied::key and multiplied
popular compression map::popular compression map
ways of doing::ways of doing
case the choice::case the choice
thing that happened::thing that happened
done a lot::done a lot
lot of jugglery::lot of jugglery
first we multiplied::first we multiplied
smaller fraction part::smaller fraction part
experimental without significant::experimental without significant
book by ronald::book by ronald
knuth on sorting::knuth on sorting
sorting and searching::sorting and searching
searching which covers::searching which covers
covers hash functions::covers hash functions
functions in detail::functions in detail
numbers then compute::numbers then compute
avoid any kind::avoid any kind
kind of patterns::kind of patterns
random number generator::random number generator
random number generators::random number generators
generators are based::generators are based
technique called linear::technique called linear
linear congruential generators::linear congruential generators
generators they start::generators they start
seed that seed::seed that seed
initial k value::initial k value
compute this quantity::compute this quantity
function will give::function will give
give random number::give random number
value you return::value you return
last random number::last random number
random number generated::random number generated
generate random number::generate random number
number such numbers::number such numbers
pseudo random number::pseudo random number
technique called universal::technique called universal
idea i pick::idea i pick
set of keys::set of keys
make life difficult::make life difficult
spend a lot::spend a lot
deletion and searching::deletion and searching
searching one solution::searching one solution
bunch of hash::bunch of hash
function to put::function to put
put the keys::put the keys
function for inserting::function for inserting
doing the search::doing the search
hash table implementation::hash table implementation
change the hash::change the hash
invoke this program::invoke this program
set of hash::set of hash
doing my implementation::doing my implementation
collection of hash::collection of hash
keys the probability::keys the probability
function is concerned::function is concerned
put a linked::put a linked
delete by doing::delete by doing
doing that operation::doing that operation
today which fall::today which fall
class of open::class of open
open addressing differs::open addressing differs
differs from chaining::differs from chaining
key fact recall::key fact recall
recall in chaining::recall in chaining
list the table::list the table
storing the pointers::storing the pointers
hashing could map::hashing could map
elements as larger::elements as larger
list each entry::list each entry
null which means::null which means
searching or inserting::searching or inserting
inserting or deleting::inserting or deleting
probe the elements::probe the elements
modifying the hash::modifying the hash
keys are picked::keys are picked
picked our hash::picked our hash
mapping the keys::mapping the keys
earlier this part::earlier this part
case of chaining::case of chaining
insert the key::insert the key
location is occupied::location is occupied
find an empty::find an empty
techniques the hash::techniques the hash
sequence of slots::sequence of slots
set which specifies::set which specifies
specifies the collections::specifies the collections
collections of keys::collections of keys
technique under open::technique under open
location so probe::location so probe
probe is incremented::probe is incremented
location the mod::location the mod
beginning your question::beginning your question
retrieve the keys::retrieve the keys
element already sitting::element already sitting
find the empty::find the empty
location one advantage::location one advantage
memory in chaining::memory in chaining
track of references::track of references
space is wasted::space is wasted
technique might end::technique might end
slower than chaining::slower than chaining
function my keys::function my keys
insert these keys::insert these keys
point the table::point the table
table was empty::table was empty
problem in inserting::problem in inserting
table is empty::table is empty
location is empty::location is empty
empty we put::empty we put
locations are occupied::locations are occupied
occupied we check::occupied we check
elements are sitting::elements are sitting
technique the elements::technique the elements
tend to aggregate::tend to aggregate
locations while searching::locations while searching
inserting those elements::inserting those elements
searching for key::searching for key
compute k mod::compute k mod
reach an empty::reach an empty
location that means::location that means
means the element::means the element
location and search::location and search
search the element::search the element
found the element::found the element
location till 11th::location till 11th
location the element::location the element
empty this means::empty this means
search the search::search the search
search will terminate::search will terminate
finds the element::finds the element
8th location suppose::8th location suppose
suppose i removed::suppose i removed
setting this location::setting this location
location to null::location to null
null i removed::null i removed
idea ? suppose::idea ? suppose
last we reached::last we reached
reached the empty::reached the empty
set this location::set this location
mark this location::mark this location
setting this 8th::setting this 8th
place a tombstone::place a tombstone
location which specifies::location which specifies
location was occupied::location was occupied
encounter a tombstone::encounter a tombstone
search is ended::search is ended
encounters a tombstone::encounters a tombstone
tombstone it ignores::tombstone it ignores
ignores and continues::ignores and continues
reclaim this space::reclaim this space
lot of tombstones::lot of tombstones
rehash just remove::rehash just remove
elements and put::elements and put
grow the table::grow the table
growing the table::growing the table
create empty slots::create empty slots
performance will increase::performance will increase
open addressing techniques::open addressing techniques
techniques we looked::techniques we looked
looked at linear::looked at linear
piece of code::piece of code
probe is set::probe is set
offset is set::offset is set
probe + offset::probe + offset
set to probe::set to probe
offset which means::offset which means
offset + offset::offset + offset
offset is determining::offset is determining
probing your offset::probing your offset
location i jumped::location i jumped
jumped one location::jumped one location
double hashing works::double hashing works
technique will ensure::technique will ensure
table in linear::table in linear
table where empty::table where empty
divides the size::divides the size
happen in fact::happen in fact
back and prove::back and prove
advantages and disadvantages::advantages and disadvantages
disadvantages as linear::disadvantages as linear
makes the performance::makes the performance
2nd hash function::2nd hash function
place were occupied::place were occupied
insert the first::insert the first
occupied i compute::occupied i compute
occupied we compute::occupied we compute
analysis of double::analysis of double
double hashing recall::double hashing recall
inside the hash::inside the hash
random the first::random the first
pick a random::pick a random
half that means::half that means
means the number::means the number
table is half::table is half
half which means::half which means
half the table::half the table
table is occupied::table is occupied
occupied and half::occupied and half
suppose my search::suppose my search
unsuccessful search stop::unsuccessful search stop
table is full::table is full
empty the expected::empty the expected
number of probes::number of probes
hit an empty::hit an empty
fraction of table::fraction of table
excepted sense probes::excepted sense probes
probes are required::probes are required
location and declare::location and declare
numbers of probes::numbers of probes
searches ? successful::searches ? successful
search are searches::search are searches
required ? suppose::required ? suppose
suppose i search::suppose i search
class the average::class the average
insert those elements::insert those elements
location again suppose::location again suppose
suppose i begin::suppose i begin
first elements size::first elements size
talking of inserting::talking of inserting
inserting the first::inserting the first
hit a full::hit a full
insert this element::insert this element
average even required::average even required
required for inserting::required for inserting
inserting these elements::inserting these elements
average the total::average the total
insert this last::insert this last
location to put::location to put
put this element::put this element
probes to insert::probes to insert
insert these elements::insert these elements
elements is times::elements is times
insert the last::insert the last
average i require::average i require
table was full::table was full
full one quarter::full one quarter
recall from previous::recall from previous
locations are empty::locations are empty
elements what fraction::elements what fraction
inserted enough elements::inserted enough elements
basically minus log::basically minus log
point i require::point i require
fraction was empty::fraction was empty
unsuccessful and successful::unsuccessful and successful
trees last class::trees last class
class we discussed::class we discussed
discussed about hashing::discussed about hashing
double hashing linear::double hashing linear
hashing linear programming::hashing linear programming
bit of analysis::bit of analysis
resolution techniques today::resolution techniques today
talk about trees::talk about trees
structures for trees::structures for trees
notion of parent::notion of parent
parent and children::parent and children
parent of node::parent of node
hope you understand::hope you understand
understand the difference::understand the difference
difference between ancestor::difference between ancestor
ancestor and grandparent::ancestor and grandparent
children of node::children of node
great grand parent::great grand parent
ancestor the terms::ancestor the terms
terms we defined::terms we defined
tree a leaf::tree a leaf
node we associate::node we associate
associate a notion::associate a notion
notion of level::notion of level
depth and level::depth and level
thing the level::thing the level
number of children::number of children
leaves have degree::leaves have degree
children basic terminologies::children basic terminologies
represent the hierarchy::represent the hierarchy
organization for instance::organization for instance
manufacturing is division::manufacturing is division
domestic and international::domestic and international
represent the organizational::represent the organizational
tree to represent::tree to represent
represent the table::represent the table
table of contents::table of contents
book called student::book called student
chapters on overview::chapters on overview
programming and support::programming and support
code the chapter::code the chapter
sections called exams::sections called exams
homework and programs::homework and programs
node are ordered::node are ordered
ordered that means::ordered that means
put the left::put the left
right side suppose::right side suppose
draw a family::draw a family
draw the eldest::draw the eldest
move from left::move from left
left to right::left to right
reflect that order::reflect that order
place the left::place the left
make any difference::make any difference
picture is concerned::picture is concerned
convey any additional::convey any additional
notion of left::notion of left
children the diagram::children the diagram
tree the root::tree the root
child the node::child the node
children these nodes::children these nodes
1stlevel are ordered::1stlevel are ordered
change the tree::change the tree
draw the left::draw the left
order has meaning::order has meaning
ordered binary tree::ordered binary tree
change the order::change the order
define a binary::define a binary
construct any binary::construct any binary
node and attach::node and attach
attach a left::attach a left
subtree through recursive::subtree through recursive
taking a node::taking a node
node and attaching::node and attaching
and which means::-NONE- which means
means this left::means this left
introduced other terms::introduced other terms
subtree the node::subtree the node
node would correspond::node would correspond
operations in fact::operations in fact
evaluate this expression::evaluate this expression
draw a tree::draw a tree
tree whose root::tree whose root
build this tree::build this tree
representing arithmetic expression::representing arithmetic expression
arithmetic expression decision::arithmetic expression decision
expression decision tree::expression decision tree
book star bucks::book star bucks
caf ? paragon::caf ? paragon
make much sense::make much sense
decision tree corresponds::decision tree corresponds
meal the answer::meal the answer
follow the decision::follow the decision
terminology and examples::terminology and examples
define a complete::define a complete
complete binary tree::complete binary tree
tree we call::tree we call
call a tree::call a tree
tree every node::tree every node
leaf that means::leaf that means
means every internal::means every internal
node the root::node the root
maximum level number::maximum level number
tree that means::tree that means
nodes that means::nodes that means
leaves the number::leaves the number
number of leaves::number of leaves
tree of height::tree of height
number of internal::number of internal
number of leaves-1::number of leaves-1
number of nodes::number of nodes
call this number::call this number
expression the number::expression the number
nodes are leaves::nodes are leaves
doing some simple::doing some simple
tree is log::tree is log
tree the number::tree the number
half the total::half the total
node has atmost::node has atmost
suitably large complete::suitably large complete
large complete binary::large complete binary
tree as shown::tree as shown
side as height::side as height
left just cut::left just cut
side the picture::side the picture
obtain any binary::obtain any binary
tree at level::tree at level
tree is obtained::tree is obtained
tree by pruning::tree by pruning
nodes at level::nodes at level
level i implies::level i implies
nodes the last::nodes the last
nodes that binary::nodes that binary
rewrite this suppose::rewrite this suppose
suppose i told::suppose i told
height is atleast::height is atleast
tree which achieves::tree which achieves
achieves this equality::achieves this equality
tree which acquires::tree which acquires
acquires the smallest::acquires the smallest
create a binary::create a binary
nodes as close::nodes as close
tree i give::tree i give
minimum possible height::minimum possible height
nodes has height::nodes has height
height atmost n-1::height atmost n-1
nodes the minimum::nodes the minimum
height is log::height is log
height is n-1::height is n-1
mistake many people::mistake many people
assume that binary::assume that binary
binary tree means::binary tree means
tree means height::tree means height
figure it out::figure it out
nodes or atmost::nodes or atmost
atmost the number::atmost the number
leaf base case::leaf base case
case the right::case the right
right hand side::right hand side
inequality is satisfied::inequality is satisfied
statement is true::statement is true
k-1 internal nodes::k-1 internal nodes
true for trees::true for trees
trees with atmost::trees with atmost
atmost k-1 internal::atmost k-1 internal
internal nodes suppose::internal nodes suppose
node the minus::node the minus
apply the induction::apply the induction
equal to k-1::equal to k-1
subtree the number::subtree the number
subtree the total::subtree the total
wanted to prove::wanted to prove
started a tree::started a tree
proof which shows::proof which shows
shows the number::shows the number
leaves is atmost::leaves is atmost
leaves is equal::leaves is equal
nodes the complete::nodes the complete
achieves the equality::achieves the equality
sum how small::sum how small
nodes is greater::nodes is greater
half the number::half the number
trees are dry::trees are dry
leaves that tree::leaves that tree
type for trees::type for trees
generic container methods::generic container methods
tree is empty::tree is empty
position based container::position based container
based container methods::based container methods
list or sequence::list or sequence
types the swapelements::types the swapelements
positions as references::positions as references
position data type::position data type
position the method::position the method
sequence the positions::sequence the positions
node the swapelements::node the swapelements
swapping the elements::swapping the elements
replacing the element::replacing the element
external or leaf::external or leaf
correspond to leaf::correspond to leaf
leaf in accessor::leaf in accessor
return a position::return a position
object of type::object of type
type position isroot::type position isroot
root and root::root and root
returns the position::returns the position
reference of type::reference of type
earlier the method::earlier the method
returns the parent::returns the parent
node the children::node the children
returns the children::returns the children
return a sequence::return a sequence
sequence of object::sequence of object
object type sequence::object type sequence
access the data::access the data
data the update::data the update
typically application specific::typically application specific
tree binary tree::tree binary tree
child or give::child or give
kinds of data::kinds of data
reference to key::reference to key
key or data::key or data
sense for instance::sense for instance
access the left::access the left
child by invoking::child by invoking
invoking the left::invoking the left
left child method::left child method
invoke element method::invoke element method
implement the position::implement the position
diagram the extreme::diagram the extreme
extreme right node::extreme right node
right child member::right child member
referring to null::referring to null
care of arbitrary::care of arbitrary
trees the root::trees the root
1of the child::1of the child
list each child::list each child
reached the last::reached the last
node is empty::node is empty
children every node::children every node
left most child::left most child
sibling the left::sibling the left
references the node::references the node
sense of left::sense of left
right makes sense::right makes sense
written left child::written left child
written 1st child::written 1st child
access its siblings::access its siblings
children throughout linked::children throughout linked
end our discussion::end our discussion
discussion on binary::discussion on binary
binary trees today::binary trees today
reversals of trees::reversals of trees
trees data structures::trees data structures
class we looked::class we looked
looked at definitions::looked at definitions
definitions of trees::definitions of trees
discussion on trees::discussion on trees
walk or tree::walk or tree
traversals a tree::traversals a tree
visiting the nodes::visiting the nodes
visit or process::visit or process
process each node::process each node
process its children::process its children
children or visit::children or visit
process the node::process the node
examples of preorder::examples of preorder
preorder tree walks::preorder tree walks
tree walks suppose::tree walks suppose
walks suppose recall::walks suppose recall
construct a tree::construct a tree
abstract which discusses::abstract which discusses
publication has referenced::publication has referenced
read the paper::read the paper
reading the paper::reading the paper
end to end::end to end
read the abstract::read the abstract
book are listed::book are listed
tables of contents::tables of contents
contents are listed::contents are listed
chapter are listed::chapter are listed
tree the first::tree the first
referring or accessing::referring or accessing
tree the pseudo-code::tree the pseudo-code
pseudo-code for preorder::pseudo-code for preorder
call preorder traversal::call preorder traversal
visit the node::visit the node
doing some computations::doing some computations
out the book::out the book
book as table::book as table
contents then visit::contents then visit
visit would correspond::visit would correspond
correspond to print::correspond to print
print the title::print the title
title or print::title or print
print the heading::print the heading
node for instance::node for instance
instance each node::instance each node
visit ? node::visit ? node
nodes and repeat::nodes and repeat
repeat the process::repeat the process
node then visit::node then visit
visit the first::visit the first
corresponds to visit::corresponds to visit
visit that node::visit that node
visit its children::visit its children
traversal i gave::traversal i gave
reading a document::reading a document
document from beginning::document from beginning
beginning to end::beginning to end
post order traversal::post order traversal
order traversal recall::order traversal recall
root directory courses::root directory courses
file called grades::file called grades
directory structure suppose::directory structure suppose
compute the total::compute the total
total space occupied::total space occupied
center to obtain::center to obtain
obtain the total::obtain the total
total spaces required::total spaces required
visiting the node::visiting the node
center or doing::center or doing
doing some computation::doing some computation
done the computation::done the computation
computed the total::computed the total
doing the node::doing the node
doing a post::doing a post
perform a post::perform a post
post order corresponds::post order corresponds
corresponds to finding::corresponds to finding
finding the total::finding the total
total space required::total space required
sense the order::sense the order
computation is done::computation is done
done is reverse::done is reverse
disk usage command::disk usage command
command in unix::command in unix
directory it tells::directory it tells
type the disk::type the disk
out the total::out the total
end it list::end it list
left and right::left and right
child and fourth::child and fourth
child is visited::child is visited
drawn the tree::drawn the tree
drawn your trees::drawn your trees
traversal in general::traversal in general
visit the children::visit the children
nodes in postorder::nodes in postorder
postorder first visit::postorder first visit
visit the nodes::visit the nodes
case of binary::case of binary
first saying visit::first saying visit
first say visit::first say visit
pre order traversal::pre order traversal
right child note::right child note
work by making::work by making
doing a preorder::doing a preorder
difference between pre::difference between pre
order and post::order and post
visit a node::visit a node
out the contents::out the contents
doing a pre::doing a pre
left sub tree::left sub tree
tree and first::tree and first
corresponds to printing::corresponds to printing
printing the content::printing the content
node here means::node here means
printing the contents::printing the contents
tree is null::tree is null
right sub tree::right sub tree
tree because first::tree because first
traversal of right::traversal of right
tree which means::tree which means
means first visit::means first visit
entire sub tree::entire sub tree
done the post::done the post
side and post::side and post
print the node::print the node
ready to print::ready to print
print the content::print the content
print this content::print this content
print this node::print this node
means just print::means just print
print the root::print the root
evaluating arithmetic expression::evaluating arithmetic expression
evaluate the expressions::evaluate the expressions
right a procedure::right a procedure
evaluate the expression::evaluate the expression
return the variable::return the variable
value the leaf::value the leaf
corresponds to numbers::corresponds to numbers
evaluate the left::evaluate the left
return that value::return that value
value of expression::value of expression
addressing that problem::addressing that problem
problem of generating::problem of generating
generating this tree::generating this tree
incorporate the priority::incorporate the priority
rules to generate::rules to generate
kind of traversal::kind of traversal
traversal so recall::traversal so recall
traversal we visited::traversal we visited
visited the node::visited the node
tree so pseudo::tree so pseudo
first go left::first go left
understood inorder traversal::understood inorder traversal
printing c out::printing c out
sub tree inorder::sub tree inorder
tree inorder traversal::tree inorder traversal
entire inorder traversal::entire inorder traversal
traversal of left::traversal of left
traversing a tree::traversing a tree
euler tour suppose::euler tour suppose
expression the tour::expression the tour
drawn in blue::drawn in blue
hit a leaf::hit a leaf
post and inorder::post and inorder
eulers tour traversal::eulers tour traversal
traversal each node::traversal each node
basically getting visited::basically getting visited
touching this node::touching this node
touch any node::touch any node
node of degree::node of degree
print this arithmetic::print this arithmetic
out with parenthesis::out with parenthesis
draw the parenthesis::draw the parenthesis
walk to print::walk to print
print this thing::print this thing
print a left::print a left
print the right::print the right
bracket this right::bracket this right
right subtree corresponds::right subtree corresponds
corresponds to taking::corresponds to taking
taking this path::taking this path
out the content::out the content
node was visited::node was visited
touch the node::touch the node
print left bracket::print left bracket
touch this node::touch this node
print another left::print another left
left i print::left i print
brackets to begin::brackets to begin
print a star::print a star
out this arithmetic::out this arithmetic
kind of euler::kind of euler
write a generic::write a generic
method for tree::method for tree
postorder or inorder::postorder or inorder
traverse a node::traverse a node
node an external::node an external
method you invoke::method you invoke
invoke this method::invoke this method
method called left::method called left
continue with right::continue with right
create the traversal::create the traversal
traversal of choice::traversal of choice
specialize this binary::specialize this binary
binary tree traversal::binary tree traversal
generic tree traversal::generic tree traversal
class which means::class which means
right are left::right are left
class you leave::class you leave
leave certain methods::leave certain methods
create a sub::create a sub
class which specifies::class which specifies
specifies these methods::specifies these methods
specializes this generic::specializes this generic
tree traversal procedure::tree traversal procedure
class for printing::class for printing
printing out arithmetic::printing out arithmetic
out arithmetic expressions::out arithmetic expressions
usage we wanted::usage we wanted
wanted to compute::wanted to compute
directory we computed::directory we computed
computed the space::computed the space
child we computed::child we computed
stored in r.left::stored in r.left
result and r.right::result and r.right
compute their sum::compute their sum
printing arithmetic expression::printing arithmetic expression
position just print::position just print
touch a node::touch a node
out a left::out a left
out the left::out the left
print that out::print that out
out the right::out the right
bracket the printexpression::bracket the printexpression
extending binarytree traversal::extending binarytree traversal
invoke the traversal::invoke the traversal
out the arithmetic::out the arithmetic
expression in parenthesized::expression in parenthesized
class binarytree traversal::class binarytree traversal
specializing these methods::specializing these methods
slightly different manner::slightly different manner
discussion on pre::discussion on pre
suppose i give::suppose i give
preorder and inorder::preorder and inorder
necessarily the root::necessarily the root
tree and blue::tree and blue
managed to identify::managed to identify
tree whatever argument::tree whatever argument
tree i figured::tree i figured
traversal and inorder::traversal and inorder
problem recursively reduces::problem recursively reduces
require some thought::require some thought
compute the post::compute the post
computed the tree::computed the tree
give the result::give the result
out an error::out an error
pre and inorder::pre and inorder
pre and in::pre- and in-
order given post::order given post
compute the tree::compute the tree
tree ? recall::tree ? recall
postorder the last::postorder the last
root so first::root so first
find that root::find that root
divides the thing::divides the thing
right sub trees::right sub trees
pre and post::pre and post
determine the tree::determine the tree
order traversal preorder::order traversal preorder
suppose i gave::suppose i gave
traversal and postorder::traversal and postorder
tree with preorder::tree with preorder
post order traversals::post order traversals
order to determine::order to determine
draw the root::draw the root
basically it means::basically it means
managed to divide::managed to divide
drawn the root::drawn the root
case of preorder::case of preorder
forms the right::forms the right
forms the left::forms the left
tree the left::tree the left
case of postorder::case of postorder
tree has nodes::tree has nodes
drawn that out::drawn that out
remains the left::remains the left
level in fact::level in fact
tree every internal::tree every internal
similarly for post::similarly for post
count the number::count the number
number of binary::number of binary
lots and lots::lots and lots
lots of things::lots of things
compute the close::compute the close
close form expression::close form expression
ways of traversing::ways of traversing
traversal for binary::traversal for binary
traversal for general::traversal for general
visiting the first::visiting the first
first you visit::first you visit
visit the left::visit the left
visit the right::visit the right
preorder and postorder::preorder and postorder
traversals data structures::traversals data structures
dictionaries in today::dictionaries in today
talking about ordered::talking about ordered
binary search tree::binary search tree
implementing an ordered::implementing an ordered
dictionary functionality recall::dictionary functionality recall
functionality recall dictionary::functionality recall dictionary
key element pairs::key element pairs
notion of predecessor::notion of predecessor
talked about hashing::talked about hashing
hashing and dictionary::hashing and dictionary
compare two keys::compare two keys
student and professor::student and professor
predecessor and successor::predecessor and successor
predecessor as taking::predecessor as taking
key so predecessor::key so predecessor
key which precedes::key which precedes
keys in dictionary::keys in dictionary
dictionary s give::dictionary s give
precedes the key::precedes the key
part of data::part of data
things are ordered::things are ordered
similarly the successor::similarly the successor
two trivial ways::two trivial ways
kind of data::kind of data
dictionary ? successor::dictionary ? successor
relation the order::relation the order
thing to find::thing to find
smallest key larger::smallest key larger
successor and predecessor::successor and predecessor
predecessor and min::predecessor and min
min and max::min and max
fairly an efficient::fairly an efficient
implementation an ordered::implementation an ordered
ordered the thing::ordered the thing
constant time maximum::constant time maximum
successor also takes::successor also takes
predecessor takes constant::predecessor takes constant
give the node::give the node
reach that node::reach that node
compute the successor::compute the successor
predecessor in constant::predecessor in constant
constant time inserting::constant time inserting
inserting also takes::inserting also takes
out the correct::out the correct
position for insertion::position for insertion
insertion searching takes::insertion searching takes
searching takes order::searching takes order
searching can improve::searching can improve
ordered i put::ordered i put
search to find::search to find
element in log::element in log
insertion and deletion::insertion and deletion
place to insert::place to insert
similarly for deletion::similarly for deletion
recap what binary::recap what binary
remember binary search::remember binary search
search to search::search to search
make a comparison::make a comparison
comparison the size::comparison the size
making the search::making the search
search ? halves::search ? halves
searching recall insertion::searching recall insertion
ways you adopt::ways you adopt
adopt to implement::adopt to implement
implement an ordered::implement an ordered
talk about trivialities::talk about trivialities
binary tree binary::binary tree binary
children a node::children a node
children no children::children no children
discussions that follow::discussions that follow
binary search property::binary search property
tree all keys::tree all keys
tree are larger::tree are larger
nodes have keys::nodes have keys
keys which satisfy::keys which satisfy
satisfy the search::satisfy the search
search property satisfied::search property satisfied
tree so binary::tree so binary
tree plus search::tree plus search
search property equals::search property equals
property equals binary::property equals binary
equals binary search::equals binary search
kinds of trees::kinds of trees
binary search trees::binary search trees
binary and satisfy::binary and satisfy
conversation between professor::conversation between professor
professor and student::professor and student
implementation keys stored::implementation keys stored
couple of features::couple of features
keys are unique::keys are unique
suppose your key::suppose your key
define total order::define total order
order of names::order of names
lexico graphic order::lexico graphic order
order or alphabetic::order or alphabetic
key is equal::key is equal
assume the keys::assume the keys
unnecessarily complicates matters::unnecessarily complicates matters
root i compare::root i compare
search property keys::search property keys
done we found::done we found
find an element::find an element
child is null::child is null
write the search::write the search
procedure for binary::procedure for binary
simplest to understand::simplest to understand
nil which means::nil which means
root or empty::root or empty
return the root::return the root
begin with refers::begin with refers
key is larger::key is larger
make recursive calls::make recursive calls
continuing the search::continuing the search
dot left child::dot left child
code just showed::code just showed
left x pseudo::left x pseudo
continue this search::continue this search
started at level::started at level
number of levels::number of levels
nodes whose height::nodes whose height
height is order::height is order
kind of situations::kind of situations
large the search::large the search
order the height::order the height
finding the minimum::finding the minimum
left most tree::left most tree
tree ? left::tree ? left
left most node::left most node
node or left::node or left
left most leaf::left most leaf
leaf ? left::leaf ? left
left most leafs::left most leafs
smallest one smallest::smallest one smallest
node expect left::node expect left
node also doesn::node also doesn
sense last leaf::sense last leaf
node ? last::node ? last
last internal node::last internal node
node without left::node without left
create more internal::create more internal
give the half::give the half
half a sentence::half a sentence
give a procedural::give a procedural
find the smallest::find the smallest
smallest ? start::smallest ? start
left till left::left till left
left becomes null::left becomes null
left is null::left is null
right becomes null::right becomes null
find the minimum::find the minimum
return the key::return the key
return the element::return the element
modification to compute::modification to compute
compute the maximum::compute the maximum
replace the left::replace the left
left by right::left by right
complete the maximum::complete the maximum
tree ? successor::tree ? successor
understand what successor::understand what successor
means ? successor::means ? successor
key after find::key after find
find the node::find the node
smallest key greater::smallest key greater
greater than key::greater than key
key sub tree::key sub tree
tree is non-empty::tree is non-empty
tree it exist::tree it exist
successor be lying::successor be lying
lots of confusion::lots of confusion
draw this picture::draw this picture
sheet of paper::sheet of paper
out the successor::out the successor
parent is larger::parent is larger
elements slightly larger::elements slightly larger
node and proceed::node and proceed
tree the successor::tree the successor
essentially be minimum::essentially be minimum
procedure for completing::procedure for completing
completing the minimum::completing the minimum
tree is non::tree is non
right one step::right one step
sub tree suppose::sub tree suppose
reach the node::reach the node
successor you understand::successor you understand
understand the procedure::understand the procedure
recall the procedure::recall the procedure
node the right::node the right
reach an ancestor::reach an ancestor
node whose successor::node whose successor
find the largest::find the largest
guy this ancestor::guy this ancestor
ancestor is greater::ancestor is greater
write for computing::write for computing
computing the successor::computing the successor
return the minimum::return the minimum
stop the first::stop the first
doing is moving::doing is moving
moving the pointers::moving the pointers
takes the value::takes the value
value of parent::value of parent
moves one step::moves one step
pair of pointers::pair of pointers
null that means::null that means
return we return::return we return
node in case::node in case
case y hits::case y hits
code and convince::code and convince
code ? order::code ? order
looked at search::looked at search
tree we looked::tree we looked
looked at minimum::looked at minimum
looked at maximum::looked at maximum
looked at successor::looked at successor
essentially interchange role::essentially interchange role
role of right::role of right
right and left::right and left
care of deletion::care of deletion
class so insertion::class so insertion
insert an elements::insert an elements
out the place::out the place
assuming distinct keys::assuming distinct keys
assuming that node::assuming that node
node to elements::node to elements
right is null::right is null
point the search::point the search
hit a null::hit a null
pointer and null::pointer and null
reference we put::reference we put
put the node::put the node
inserting the keys::inserting the keys
search tree suppose::search tree suppose
insert those keys::insert those keys
create the chain::create the chain
similar would happen::similar would happen
compare and put::compare and put
suppose i insert::suppose i insert
level by level::level by level
insert these nodes::insert these nodes
insert later nodes::insert later nodes
tree ? height::tree ? height
height balanced trees::height balanced trees
height balanced tree::height balanced tree
full binary trees::full binary trees
binary tree provided::binary tree provided
operations were depended::operations were depended
tree the smaller::tree the smaller
smaller the height::smaller the height
faster the operation::faster the operation
height as small::height as small
small height tree::small height tree
bad order suppose::bad order suppose
understand the random::understand the random
factorial different permutation::factorial different permutation
random and insert::random and insert
talk of random::talk of random
variable you understand::variable you understand
random variable means::random variable means
means ? variable::means ? variable
variable which takes::variable which takes
address this kind::address this kind
code for insertion::code for insertion
insert this node::insert this node
inserting a node::inserting a node
inserting this node::inserting this node
hit this null::hit this null
child a left::child a left
essentially parent pointer::essentially parent pointer
parent pointer parent::parent pointer parent
parent so parent::parent so parent
sequence the insertion::sequence the insertion
worst case sequence::worst case sequence
stop our discussion::stop our discussion
asked you today::asked you today
start with deletion::start with deletion
minimum and maximum::minimum and maximum
search tree today::search tree today
address the question::address the question
permute my elements::permute my elements
elements and insert::elements and insert
case for deletion::case for deletion
fairly straight forward::fairly straight forward
children then deletion::children then deletion
deletion is trivial::deletion is trivial
cut this length::cut this length
length which means::length which means
set the right::set the right
set the left::set the left
child to null::child to null
problem is trivial::problem is trivial
child the operation::child the operation
delete a node::delete a node
make its left::make its left
left child point::left child point
establishing the link::establishing the link
maintain the search::maintain the search
deleted the node::deleted the node
tree we find::tree we find
find the predecessor::find the predecessor
essentially the predecessor::essentially the predecessor
violated by moving::violated by moving
moving the content::moving the content
property is concerned::property is concerned
delete b easily::delete b easily
subtree and suppose::subtree and suppose
suppose i decide::suppose i decide
decide to move::decide to move
make the right::make the right
node the node::node the node
move the content::move the content
find the successor::find the successor
shown the predecessor::shown the predecessor
operation ? suppose::operation ? suppose
takes to delete::takes to delete
update the link::update the link
giving the reference::giving the reference
parent and update::parent and update
update the content::update the content
content to show::content to show
show the deletion::show the deletion
deleting the node::deleting the node
parent and modify::parent and modify
modify its left::modify its left
constant time operation::constant time operation
find a predecessor::find a predecessor
case time proportional::case time proportional
pseudo-code for deletion::pseudo-code for deletion
right is nil::right is nil
understood the delete::understood the delete
made some mistakes::made some mistakes
skip this thing::skip this thing
first the left::first the left
node is print::node is print
out the key::out the key
out the keys::out the keys
print the key::print the key
right this means::right this means
out the root::out the root
right are greater::right are greater
left which means::left which means
print out things::print out things
print the keys::print the keys
keys the property::keys the property
keys in increasing::keys in increasing
method of sorting::method of sorting
sorting a bunch::sorting a bunch
bunch of keys::bunch of keys
search tree base::search tree base
tree base sorting::tree base sorting
base sorting procedure::base sorting procedure
keys and inserting::keys and inserting
sorted a set::sorted a set
in-order tree work::in-order tree work
traverse the nodes::traverse the nodes
tree in in-order::tree in in-order
bst sorting procedure::bst sorting procedure
sort the keys::sort the keys
takes to insert::takes to insert
set of numbers::set of numbers
insert this numbers::insert this numbers
numbers is equal::numbers is equal
place the number::place the number
levels i traverse::levels i traverse
level either level::level either level
level or level::level or level
inserted the numbers::inserted the numbers
numbers in sorted::numbers in sorted
first i inserted::first i inserted
remember that kind::remember that kind
tree some thing::tree some thing
sum of levels::sum of levels
series which sums::series which sums
backs the question::backs the question
factorial different permutations::factorial different permutations
random i insert::random i insert
insert the elements::insert the elements
required for insertion::required for insertion
variable it depends::variable it depends
elements in fact::elements in fact
first element inserted::first element inserted
insertion the total::insertion the total
variables we compute::variables we compute
random variable recall::random variable recall
random variable takes::random variable takes
variable is obtained::variable is obtained
trials which means::trials which means
compute the expectation::compute the expectation
uniformly at random::uniformly at random
compute the average::compute the average
order and compute::order and compute
3rd permutation compute::3rd permutation compute
insert the keys::insert the keys
average the average::average the average
average is computed::average is computed
denote this quantity::denote this quantity
permutations of elements::permutations of elements
elements are inserted::elements are inserted
right when elements::right when elements
1to the left::1to the left
left when elements::left when elements
nodes the levels::nodes the levels
5th and 6th::5th and 6th
permutations the tree::permutations the tree
permutations and restrict::permutations and restrict
restrict our attention::restrict our attention
permutations these keys::permutations these keys
permutations of keys::permutations of keys
permutation will occur::permutation will occur
symmetric of law::symmetric of law
elements is occurring::elements is occurring
occurring exactly times::occurring exactly times
computing the total::computing the total
previous setting recall::previous setting recall
subtree each key::subtree each key
creating a left::creating a left
subtree their level::subtree their level
round in blue::round in blue
inside the triangle::inside the triangle
triangle in blue::triangle in blue
create this tree::create this tree
creating a tree::creating a tree
nodes the keys::nodes the keys
keys are coming::keys are coming
spending in creating::spending in creating
creating this part::creating this part
first i compare::first i compare
tree and level::tree and level
permutations ? recall::permutations ? recall
creating am taking::creating am taking
taking one unit::taking one unit
taking to insert::taking to insert
spend in inserting::spend in inserting
permutations is appearing::permutations is appearing
number of keys::number of keys
elements are present::elements are present
insert n keys::insert n keys
n-1 this part::n-1 this part
relation the function::relation the function
expressing the value::expressing the value
function at point::function at point
values at previous::values at previous
relation to compute::relation to compute
lets also compute::lets also compute
recurrence to compute::recurrence to compute
obtained some kind::obtained some kind
relation which tells::relation which tells
solve this recurrence::solve this recurrence
times the sum::times the sum
rearrange this quantity::rearrange this quantity
quantity or times::quantity or times
times this sum::times this sum
equation were times::equation were times
rearrangement to simplify::rearrangement to simplify
1.i just simplify::1.i just simplify
done is replacing::done is replacing
quantity gets decreasing::quantity gets decreasing
inside keeps increasing::inside keeps increasing
summing a harmonic::summing a harmonic
drawn a line::drawn a line
atmost the area::atmost the area
computation we looked::computation we looked
log n recall::log n recall
permutation which puts::permutation which puts
puts the elements::puts the elements
elements in increasing::elements in increasing
height atleast log::height atleast log
level has keys::level has keys
leaves ? log::leaves ? log
insert the leaves::insert the leaves
taking n log::taking n log
cases and report::cases and report
trees have depth::trees have depth
times n log::times n log
bunch of numbers::bunch of numbers
permutations the smallest::permutations the smallest
numbers are closer::numbers are closer
log n times::log n times
log n data::log n data
quick sort today::quick sort today
talk about quick::talk about quick
series of lectures::series of lectures
lectures the first::lectures the first
argued a worst::argued a worst
worst case running::worst case running
today the quick::today the quick
quick sort algorithm::quick sort algorithm
average it takes::average it takes
place ? sorting::place ? sorting
require any additional::require any additional
typically good thing::typically good thing
sort a large::sort a large
collection of numbers::collection of numbers
numbers this algorithm::numbers this algorithm
lot of divide::lot of divide
idea behind divide::idea behind divide
solve you divide::solve you divide
divide the problem::divide the problem
pieces you solve::pieces you solve
solve the problem::solve the problem
pieces the divide::pieces the divide
case of quick::case of quick
partition our array::partition our array
array which stores::array which stores
numbers and partitioned::numbers and partitioned
call the higher::call the higher
part the property::part the property
sort the lower::sort the lower
sort the higher::sort the higher
put all elements::put all elements
thing is sorted::thing is sorted
sorted the lower::sorted the lower
sorted the higher::sorted the higher
partition is done::partition is done
give an algorithm::give an algorithm
linear time procedure::linear time procedure
partitioning is done::partitioning is done
partitioning it takes::partitioning it takes
takes the parameters::takes the parameters
partition the sub::partition the sub
true which means::true which means
reach a location::reach a location
reach a locations::reach a locations
reached a location::reached a location
means just swap::means just swap
swap these contents::swap these contents
swapped these contents::swapped these contents
part and orange::part and orange
swap these things::swap these things
things i swapped::things i swapped
means our job::means our job
job is done::job is done
means they crossed::means they crossed
exit which means::exit which means
return the procedure::return the procedure
returning the value::returning the value
times the size::times the size
loop is done::loop is done
utmost n times::utmost n times
increment or decrement::increment or decrement
taking the pivot::taking the pivot
compare every element::compare every element
pivot and put::pivot and put
first few locations::first few locations
require more memory::require more memory
copy that array::copy that array
additional memory space::additional memory space
partitioning in in-place::partitioning in in-place
repeat until loop::repeat until loop
times this step::times this step
step is executed::step is executed
executed is order::executed is order
complete quick sort::complete quick sort
sort on lets::sort on lets
call for quick::call for quick
find the partition::find the partition
invoke the previous::invoke the previous
rearranges the part::rearranges the part
returns the demarcating::returns the demarcating
upper half separately::upper half separately
recursively invoke quick::recursively invoke quick
invoke quick sort::invoke quick sort
condition is met::condition is met
entire partition procedure::entire partition procedure
call quick sort::call quick sort
copy the array::copy the array
create more copies::create more copies
creating additional copies::creating additional copies
taking any additional::taking any additional
array what element::array what element
understand the quick::understand the quick
partitioned the array::partitioned the array
sort this left::sort this left
sort this right::sort this right
solve the left::solve the left
write a quick::write a quick
quick sort procedure::quick sort procedure
quick sort takes::quick sort takes
partition procedure takes::partition procedure takes
procedure takes order::procedure takes order
sort will depend::sort will depend
split is happening::split is happening
sort is taking::sort is taking
dividing the array::dividing the array
two equal halves::two equal halves
halves which means::halves which means
means that half::means that half
half the elements::half the elements
half elements ended::half elements ended
picked a pivot::picked a pivot
two equal parts::two equal parts
divide this array::divide this array
procedure took order::procedure took order
drawn am taking::drawn am taking
tree of mine::tree of mine
order n log::order n log
means i decreased::means i decreased
utmost m times::utmost m times
writing the recurrence::writing the recurrence
sort n elements::sort n elements
procedure was quick::procedure was quick
sort the left::sort the left
left part lets::left part lets
sort the right::sort the right
essentially become theta::essentially become theta
theta is bothering::theta is bothering
input is sorted::input is sorted
sorted already lets::sorted already lets
case would happen::case would happen
sorted in ascending::sorted in ascending
happen similar kind::happen similar kind
happened in insertion::happened in insertion
sort in insertion::sort in insertion
recall in insertion::recall in insertion
taking an element::taking an element
element and figuring::element and figuring
place to put::place to put
put that element::put that element
end to find::end to find
sorted in decreasing::sorted in decreasing
array was sorted::array was sorted
sorted in increasing::sorted in increasing
move back anymore::move back anymore
anymore every element::anymore every element
takes constant amount::takes constant amount
comparison with insertion::comparison with insertion
increasing or sorted::increasing or sorted
elements change out::elements change out
change out suppose::change out suppose
call this lucky::call this lucky
side one tenth::side one tenth
similarly the total::similarly the total
level will continue::level will continue
number is smaller::number is smaller
level is decreasing::level is decreasing
decrementing by half::decrementing by half
log n base::log n base
out the math::out the math
constant times log::constant times log
taking a total::taking a total
levels is log::levels is log
providing an upper::providing an upper
manner one tenth::manner one tenth
spectacular or special::spectacular or special
fraction of numbers::fraction of numbers
end up taking::end up taking
taking n squared::taking n squared
fraction one tenth::fraction one tenth
millionth the height::millionth the height
formal analysis starting::formal analysis starting
suppose we alternate::suppose we alternate
alternate the lucky::alternate the lucky
lucky and unlucky::lucky and unlucky
prove a log::prove a log
log n depth::log n depth
operations or comparisons::operations or comparisons
comparisons i managed::comparisons i managed
managed to split::managed to split
side and lets::side and lets
half and half::half and half
find a median::find a median
median element pick::median element pick
pick the median::pick the median
element ? sort::element ? sort
sort the numbers::sort the numbers
find the median::find the median
place so finding::place so finding
finding median element::finding median element
procedure for doing::procedure for doing
clear-some what close::clear-some what close
median by dividing::median by dividing
number of small::number of small
array then sorting::array then sorting
arrays of size::arrays of size
log n steps::log n steps
compute a median::compute a median
element in linear::element in linear
fairly an involved::fairly an involved
element and declare::element and declare
pick a specific::pick a specific
pick the last::pick the last
order or increasing::order or increasing
call a randomized::call a randomized
making some kind::making some kind
kind of random::kind of random
analyze the running::analyze the running
randomized quick sort::randomized quick sort
assume all elements::assume all elements
elements are distinct::elements are distinct
distinct we partition::distinct we partition
element a pivot::element a pivot
pick any element::pick any element
element at random::element at random
kind of splits::kind of splits
picked with equal::picked with equal
pick the tenth::pick the tenth
tenth smallest element::tenth smallest element
versus n-10 split::versus n-10 split
probability of picking::probability of picking
picking the tenth::picking the tenth
picked any element::picked any element
11th smallest element::11th smallest element
12th smallest element::12th smallest element
element the probability::element the probability
examples of randomization::examples of randomization
tool for designing::tool for designing
modify the partitioned::modify the partitioned
procedure and call::procedure and call
call it randomized::call it randomized
partition the array::partition the array
array between locations::array between locations
generates a random::generates a random
recall was taking::recall was taking
put my pivot::put my pivot
exchange the pivot::exchange the pivot
call my partition::call my partition
randomized partition procedure::randomized partition procedure
partition it calls::partition it calls
calls randomized partition::calls randomized partition
choice of pivot::choice of pivot
pivot is crucial::pivot is crucial
choose the pivot::choose the pivot
difference between random::difference between random
lets say increasing::lets say increasing
picking a random::picking a random
element to partition::element to partition
sequence as input::sequence as input
happen that today::happen that today
today you run::today you run
run the algorithm::run the algorithm
tomorrow you run::tomorrow you run
numbers are selected::numbers are selected
random numbers selected::random numbers selected
numbers selected decide::numbers selected decide
decide the pivot::decide the pivot
crucial in deciding::crucial in deciding
splitting the things::splitting the things
pivots were turning::pivots were turning
inputs ? sequence::inputs ? sequence
sequence of random::sequence of random
numbers is generated::numbers is generated
fix an input::fix an input
change the input::change the input
today and tomorrow::today and tomorrow
tomorrow and day::tomorrow and day
sorting that specific::sorting that specific
specific input sequence::specific input sequence
denote the expected::denote the expected
required by quick::required by quick
required to sort::required to sort
sort n numbers::sort n numbers
numbers will depend::numbers will depend
recall what quick::recall what quick
sort does quick::sort does quick
sort first partitions::sort first partitions
partition n numbers::partition n numbers
numbers no matter::numbers no matter
number is compared::number is compared
pivot are put::pivot are put
require n-1 comparisons::require n-1 comparisons
comparisons every number::comparisons every number
side and n-i::side and n-i
sort those n-i::sort those n-i
taking to quick::taking to quick
sort the n-i::sort the n-i
basically this sum::basically this sum
compute expectation expectations::compute expectation expectations
forgetting your expectations::forgetting your expectations
roll a dice::roll a dice
throw a dice::throw a dice
variable ? random::variable ? random
dice this random::dice this random
random variable lets::random variable lets
variable lets call::variable lets call
random variables takes::random variables takes
values each value::values each value
takes the probability::takes the probability
throwing this dice::throwing this dice
recording the outcome::recording the outcome
outcome keep doing::outcome keep doing
doing this forever::doing this forever
suppose you threw::suppose you threw
threw this dice::threw this dice
sufficiently many times::sufficiently many times
times your outcome::times your outcome
value one times::value one times
takes the random::takes the random
two so probability::two so probability
thinking of expectation::thinking of expectation
variable is taking::variable is taking
taking a set::taking a set
set of discrete::set of discrete
times the value::times the value
taking this value::taking this value
quantity also varies::quantity also varies
means every term::means every term
write this part::write this part
randomly chosen permutation::randomly chosen permutation
solved this recurrence::solved this recurrence
showed the solution::showed the solution
required by randomized::required by randomized
recurrence we solved::recurrence we solved
quick sort worst::quick sort worst
sort worst case::sort worst case
behavior is similar::behavior is similar
insert n elements::insert n elements
sequence is sorted::sequence is sorted
roughly the median::roughly the median
quick sort depends::quick sort depends
numbers were generated::numbers were generated
input the running::input the running
random numbers generated::random numbers generated
value it turns::value it turns
input was sorted::input was sorted
pick my pivot::pick my pivot
random number choice::random number choice
expectation will give::expectation will give
make any fix::make any fix
matter what input::matter what input
input the adversary::input the adversary
beat my algorithm::beat my algorithm
sequence no matter::sequence no matter
matter what sequence::matter what sequence
make an algorithm::make an algorithm
algorithm particular kind::algorithm particular kind
kind of input::kind of input
make it independent::make it independent
making a random::making a random
knew what kinds::knew what kinds
kinds of inputs::kinds of inputs
sense to design::sense to design
design the algorithm::design the algorithm
designing the algorithm::designing the algorithm
sequence or specific::sequence or specific
behavior is independent::behavior is independent
class for binary::class for binary
make this difference::make this difference
difference very clear::difference very clear
doing an average::doing an average
run it today::run it today
run it tomorrow::run it tomorrow
choices being made::choices being made
call an average::call an average
average case analysis::average case analysis
factorial different inputs::factorial different inputs
algorithm was taking::algorithm was taking
taking different times::taking different times
input was fixed::input was fixed
expected time analysis::expected time analysis
analysis for randomized::analysis for randomized
quick sort data::quick sort data
sort data structures::sort data structures
talk about avl::talk about avl
search tree data::search tree data
tree data structure::tree data structure
structure one problem::structure one problem
operations of insertion::operations of insertion
deletion and search::deletion and search
bad as order::bad as order
create a tree::create a tree
bad a height::bad a height
structure called avl::structure called avl
tree ? avl::tree ? avl
ignore the white::ignore the white
tree and inside::tree and inside
inside the nodes::inside the nodes
call the height::call the height
defined this term::defined this term
sub tree rooted::sub tree rooted
set of descendents::set of descendents
defined the height::defined the height
numbers are beginning::numbers are beginning
tree has height::tree has height
height the node::height the node
tree the binary::tree the binary
difference to talk::difference to talk
tree is missing::tree is missing
made this change::made this change
tree is absent::tree is absent
denote the height::denote the height
shift the definition::shift the definition
put some keys::put some keys
last node height::last node height
node height balanced::node height balanced
2nd node height::2nd node height
height balanced property::height balanced property
property is violated::property is violated
kind of trees::kind of trees
trees as avl::trees as avl
out how bad::out how bad
bad the height::bad the height
minutes the height::minutes the height
prove this claim::prove this claim
slightly different argument::slightly different argument
trees of height::trees of height
nodes i defined::nodes i defined
defined this quantity::defined this quantity
out the quantity::out the quantity
implies the proposition::implies the proposition
recall a binary::recall a binary
understand the quantity::understand the quantity
counting the minimum::counting the minimum
root node suppose::root node suppose
h-2 or h-1::h-2 or h-1
h-1 or h-2::h-1 or h-2
nodes a tree::nodes a tree
h-1 the smallest::h-1 the smallest
solving this recurrence::solving this recurrence
grows the number::grows the number
thing to solve::thing to solve
implies the entire::implies the entire
suppose i pick::suppose i pick
tree whose height::tree whose height
satisfy this relation::satisfy this relation
satisfy the relation::satisfy the relation
minimum possible number::minimum possible number
nodes any avl::nodes any avl
argued after taking::argued after taking
nodes its height::nodes its height
number of number::number of number
nodes the height::nodes the height
two times log::two times log
height only log::height only log
recurrences are solved::recurrences are solved
fairly crude analysis::fairly crude analysis
tree the bound::tree the bound
bound we obtained::bound we obtained
made a mistake::made a mistake
back this base::back this base
redefine the height::redefine the height
suppose the claim::suppose the claim
claim is true::claim is true
minute so recall::minute so recall
relation our induction::relation our induction
show this quantity::show this quantity
show is lager::show is lager
out the terms::out the terms
solve this quadratic::solve this quadratic
fibonacci number minus::fibonacci number minus
thing is base::thing is base
out i guess::out i guess
thing to pick::thing to pick
make a difference::make a difference
make that correction::make that correction
hypothesis is h-1::hypothesis is h-1
quadratic in equality::quadratic in equality
equality the value::equality the value
make that small::make that small
tree with smallest::tree with smallest
smallest possible number::smallest possible number
definition of log::definition of log
h-1 this implies::h-1 this implies
prove this kind::prove this kind
bound this equation::bound this equation
equation also works::equation also works
ways of solving::ways of solving
make a guess::make a guess
essentially you verify::essentially you verify
suppose the right::suppose the right
tree in detail::tree in detail
means whose level::means whose level
suppose this leaf::suppose this leaf
2k-1 this requires::2k-1 this requires
requires the proof::requires the proof
suppose the red::suppose the red
class for avl::class for avl
tree we work::tree we work
work with level::work with level
make a big::make a big
start with level::start with level
sub tree hanging::sub tree hanging
tree hanging out::tree hanging out
root at level::root at level
node at level::node at level
child has height::child has height
blue this means::blue this means
means this sub::means this sub
height this sub::height this sub
argument which means::argument which means
property of avl::property of avl
arbitrary binary tree::arbitrary binary tree
leaf at level::leaf at level
band whose width::band whose width
largest possible height::largest possible height
height the tree::height the tree
make another claim::make another claim
1st k-2 levels::1st k-2 levels
child the picture::child the picture
shown a node::shown a node
argument would apply::argument would apply
child so sub::child so sub
height balance property::height balance property
children at level::children at level
extends the dot::extends the dot
leaf is situated::leaf is situated
situated at level::situated at level
middle and provided::middle and provided
problem in height::problem in height
children which means::children which means
k-1 are full::k-1 are full
full it means::full it means
means the tree::means the tree
nodes this implies::nodes this implies
implies the number::implies the number
proved the sharper::proved the sharper
bound the point::bound the point
constant an exponential::constant an exponential
logarithmic height property::logarithmic height property
solving a recurrence::solving a recurrence
solving the recurrence::solving the recurrence
tree is concerned::tree is concerned
nodes of height::nodes of height
half the height::half the height
require a proof::require a proof
levels the avl::levels the avl
first half levels::first half levels
starts thinning out::starts thinning out
turn the tree::turn the tree
lot of nodes::lot of nodes
tree on levels::tree on levels
mind about avl::mind about avl
nice the height::nice the height
delete in log::delete in log
search is easy::search is easy
problem with search::problem with search
search tree forget::search tree forget
forget the height::forget the height
order h height::order h height
change the height::change the height
consequence the height::consequence the height
violated the first::violated the first
step of insertion::step of insertion
tree ? first::tree ? first
first you find::first you find
updating the heights::updating the heights
nodes you encountered::nodes you encountered
nodes whose heights::nodes whose heights
doing an insertion::doing an insertion
height change appears::height change appears
inserted and move::inserted and move
hit the root::hit the root
find the first::find the first
height imbalance property::height imbalance property
imbalance property suppose::imbalance property suppose
suppose that node::suppose that node
skip this part::skip this part
forget this empty::forget this empty
balance is satisfied::balance is satisfied
forget this type::forget this type
type of node::type of node
inserted a node::inserted a node
balance property violated::balance property violated
violated we call::violated we call
call this node::call this node
tree to make::tree to make
leave the tree::leave the tree
kind of rotation::kind of rotation
operation is done::operation is done
change the keys::change the keys
draw the picture::draw the picture
out what rotation::out what rotation
property is retained::property is retained
looked at avl::looked at avl
trees are defined::trees are defined
proved a bound::proved a bound
tree we spent::tree we spent
spent a lot::spent a lot
solve that recurrence::solve that recurrence
solving that recurrence::solving that recurrence
proved a similar::proved a similar
class data structures::class data structures
discussion on avl::discussion on avl
begin with insertion::begin with insertion
started this discussion::started this discussion
discussion on insertion::discussion on insertion
class also suppose::class also suppose
insert a key::insert a key
process of insertion::process of insertion
put the key::put the key
started the discussion::started the discussion
remain an avl::remain an avl
heights could change::heights could change
change ? recall::change ? recall
recall we defined::recall we defined
node whose subtree::node whose subtree
subtree has changed::subtree has changed
changed as result::changed as result
node its sub::node its sub
changed it remains::changed it remains
heights might change::heights might change
change and change::change and change
height might increase::height might increase
imbalance or unbalanced::imbalance or unbalanced
height balance problem::height balance problem
height problem means::height problem means
height imbalanced height::height imbalanced height
imbalanced height imbalance::imbalanced height imbalance
height imbalance means::height imbalance means
means one left::means one left
difference in heights::difference in heights
node v travel::node v travel
identify the node::identify the node
grandparent is unbalanced::grandparent is unbalanced
grandchild which grandchild::grandchild which grandchild
heights are changed::heights are changed
earlier the node::earlier the node
difference of height::difference of height
1.is the node::1.is the node
node has changed::node has changed
changed the height::changed the height
path would change::path would change
grandchild means child::grandchild means child
child so child::child so child
rebalance this tree::rebalance this tree
rebalance this sub::rebalance this sub
tree the sub::tree the sub
performing a rotation::performing a rotation
changed this sub::changed this sub
nodes but organized::nodes but organized
understand this process::understand this process
reorganizing a binary::reorganizing a binary
tree the picture::tree the picture
property of binary::property of binary
forget these links::forget these links
put the links::put the links
back what happened::back what happened
search tree property::search tree property
property still holds::property still holds
done some local::done some local
suppose the insertion::suppose the insertion
drawn the links::drawn the links
out these links::out these links
avoid the clutter::avoid the clutter
root the root::root the root
thing the height::thing the height
adding one node::adding one node
increase in height::increase in height
height of node::height of node
increased and height::increased and height
increased because height::increased because height
balanced after insertion::balanced after insertion
increase it remained::increase it remained
continue this argument::continue this argument
balanced the height::balanced the height
repeating the argument::repeating the argument
imbalanced because original::imbalanced because original
originally imbalanced height::originally imbalanced height
rotation and stuff::rotation and stuff
reduce its size::reduce its size
thing we argued::thing we argued
shown the links::shown the links
heights the height::heights the height
search tree properties::search tree properties
properties are maintained::properties are maintained
difference in height::difference in height
done a rotation::done a rotation
number of operations::number of operations
thing is happened::thing is happened
happened the original::happened the original
rotation the height::rotation the height
sub tree remains::sub tree remains
height before insertion::height before insertion
symmetric case completely::symmetric case completely
repeat the argument::repeat the argument
means the height::means the height
originally not balanced::originally not balanced
rotation we ended::rotation we ended
ended up making::ended up making
root the middle::root the middle
key we ended::key we ended
making the root::making the root
remains the right::remains the right
right of sub::right of sub
balanced ? height::balanced ? height
done the job::done the job
remain the right::remain the right
compute heights height::compute heights height
original sub tree::original sub tree
ended up doing::ended up doing
middle key ended::middle key ended
split the thing::split the thing
height imbalance happening::height imbalance happening
kind of split::kind of split
uniformly the heights::uniformly the heights
ways to rotate::ways to rotate
tree the single::tree the single
doing this thing::doing this thing
height balanced picture::height balanced picture
case after rotation::case after rotation
single and double::single and double
rotations are done::rotations are done
tree the difference::tree the difference
deleting a node::deleting a node
node i copied::node i copied
copied the content::copied the content
deleted the successor::deleted the successor
successor the actual::successor the actual
node i deleted::node i deleted
end up deleting::end up deleting
ended up deleting::ended up deleting
means this node::means this node
deleting a leaf::deleting a leaf
deleting the parent::deleting the parent
leaf which means::leaf which means
deleting the leaf::deleting the leaf
leaf and copying::leaf and copying
copying the content::copying the content
leaf or parent::leaf or parent
first unbalanced node::first unbalanced node
height could reduce::height could reduce
unbalanced node encountered::unbalanced node encountered
rotations to restore::rotations to restore
restore the height::restore the height
case of insertion::case of insertion
stop after doing::stop after doing
doing the rotation::doing the rotation
rotation in delete::rotation in delete
unbalanced and repeat::unbalanced and repeat
repeat the rotation::repeat the rotation
reach the root::reach the root
tree i found::tree i found
node i identified::node i identified
imbalance that happened::imbalance that happened
happened here earlier::happened here earlier
imbalance imbalance happen::imbalance imbalance happen
height the height::height the height
height of h-2::height of h-2
height of h-1::height of h-1
slides what kind::slides what kind
h-1 and h-1::h-1 and h-1
continue the argument::continue the argument
height has reduced::height has reduced
bigger thing height::bigger thing height
height of sub::height of sub
height and height::height and height
pick the root::pick the root
rotation of mine::rotation of mine
single rotation case::single rotation case
pick the left::pick the left
pick the right::pick the right
nodes and trees::nodes and trees
double rotation step::double rotation step
step so first::step so first
nodes ? height::nodes ? height
h-2 and height::h-2 and height
make that argument::make that argument
done single rotation::done single rotation
make this kind::make this kind
tree you understand::tree you understand
tree because height::tree because height
satisfied by checking::satisfied by checking
checking the parent::checking the parent
insertion we spent::insertion we spent
insert why log::insert why log
spent time proportional::spent time proportional
height we argued::height we argued
doing a rotation::doing a rotation
done the entire::done the entire
log n deletion::log n deletion
tree to find::tree to find
find the place::find the place
occurs the first::occurs the first
satisfy the height::satisfy the height
insertion basically requires::insertion basically requires
basically requires order::basically requires order
requires order log::requires order log
spend order log::spend order log
takes a log::takes a log
log n order::log n order
order time deletion::order time deletion
hand also requires::hand also requires
requires only order::requires only order
bit more work::bit more work
work the reason::work the reason
cases the node::cases the node
delete the successor::delete the successor
occurs having found::occurs having found
solve your problem::solve your problem
problem of height::problem of height
restore height balance::restore height balance
perform a rotation::perform a rotation
number of rotations::number of rotations
moving one level::moving one level
log n rotations::log n rotations
rotations only taking::rotations only taking
taking a constant::taking a constant
total time required::total time required
entire delete operation::entire delete operation
deletion in avl::deletion in avl
trees we argued::trees we argued
done in log::done in log
avl tree data::avl tree data
tree data structures::tree data structures
trees in today::trees in today
representing a dictionary::representing a dictionary
operation of insert::operation of insert
kind of performance::kind of performance
case in avl::case in avl
kind of search::kind of search
trees so recall::trees so recall
first point nodes::first point nodes
2-3-4 actually refers::2-3-4 actually refers
children and node::children and node
children such trees::children such trees
children but satisfy::children but satisfy
multi-way search trees::multi-way search trees
multi-way search tree::multi-way search tree
two which means::two which means
children any number::children any number
two each node::two each node
tree also stores::tree also stores
stores a collection::stores a collection
collection of items::collection of items
node was storing::node was storing
storing one key::storing one key
student entry number::student entry number
d-1 such pairs::d-1 such pairs
pairs or items::pairs or items
generalizing the binary::generalizing the binary
trees each node::trees each node
children each node::children each node
left or right::left or right
d-1 different keys::d-1 different keys
children that node::children that node
instance this node::instance this node
node the keys::node the keys
determine what set::determine what set
first sub tree::first sub tree
last sub tree::last sub tree
middle sub tree::middle sub tree
follow the first::follow the first
keys or items::keys or items
two consecutive keys::two consecutive keys
follow one child::follow one child
searching is similar::searching is similar
binary search procedure::binary search procedure
left most sub::left most sub
right most sub::right most sub
sequence of steps::sequence of steps
searching for lies::searching for lies
right most child::right most child
recall in order::recall in order
traversal says left::traversal says left
print the data::print the data
child then print::child then print
left so first::left so first
print this key::print this key
key which means::key which means
means i print::means i print
printed this key::printed this key
doing in order::doing in order
back and print::back and print
keys in sorted::keys in sorted
easy to prove::easy to prove
out this key::out this key
order of printing::order of printing
children so first::children so first
multi way search::multi way search
search tree multi::search tree multi
means every node::means every node
tree each node::tree each node
forget this square::forget this square
additional properties search::additional properties search
properties search tree::properties search tree
tree be maximum::tree be maximum
tree we argued::tree we argued
height is log2n::height is log2n
height is maximum::height is maximum
maximum the tree::maximum the tree
height is minimum::height is minimum
nodes are closer::nodes are closer
tree is log4n::tree is log4n
log4n so height::log4n so height
nodes always lies::nodes always lies
lies between log2n::lies between log2n
log2n and log4n::log2n and log4n
half of log2n::half of log2n
basically the height::basically the height
2-4 tree lies::2-4 tree lies
lies between half::lies between half
half of log::half of log
lets say suppose::lets say suppose
number of node::number of node
visiting order log::visiting order log
node you require::node you require
tree you required::tree you required
keys to determine::keys to determine
shown the node::shown the node
shown each node::shown each node
node having space::node having space
found that element::found that element
empty the right::empty the right
pointer we compared::pointer we compared
space no problem::space no problem
pointer which means::pointer which means
thing would happen::thing would happen
split the node::split the node
node which node::node which node
remove this node::remove this node
promoted one key::promoted one key
parent and inserted::parent and inserted
inserted that key::inserted that key
split this node::split this node
node two nodes::node two nodes
two nodes created::two nodes created
split the parent::split the parent
node and promote::node and promote
first two children::first two children
made the children::made the children
children the first::children the first
keys which means::keys which means
root the height::root the height
split that node::split that node
two lower keys::two lower keys
two higher keys::two higher keys
node the largest::node the largest
promoted up promoted::promoted up promoted
promoted up means::promoted up means
repeat the split::repeat the split
node so split::node so split
split might cascade::split might cascade
clear for search::clear for search
doing the split::doing the split
split a node::split a node
constant time independent::constant time independent
node split takes::node split takes
split takes constant::split takes constant
suppose i wanted::suppose i wanted
recall deletion require::recall deletion require
out the leaf::out the leaf
two child case::two child case
found the successor::found the successor
successor or predecessor::successor or predecessor
found the predecessor::found the predecessor
move the predecessor::move the predecessor
delete the predecessor::delete the predecessor
problem in deleting::problem in deleting
violating the property::violating the property
tree we require::tree we require
require each node::require each node
shown the process::shown the process
swap this two::swap this two
check this point::check this point
leaf node suppose::leaf node suppose
finding the predecessor::finding the predecessor
taking the right::taking the right
children are null::children are null
remove that leaf::remove that leaf
problem were arising::problem were arising
delete a key::delete a key
leaf becomes empty::leaf becomes empty
deleting a key::deleting a key
node becomes empty::node becomes empty
borrow a key::borrow a key
manner i reach::manner i reach
node not permitted::node not permitted
borrow from sibling::borrow from sibling
disaster because search::disaster because search
solve our problem::solve our problem
node which separates::node which separates
moving the key::moving the key
parent node corresponds::parent node corresponds
corresponds to deleting::corresponds to deleting
deleting the key::deleting the key
height can reduce::height can reduce
handled and insertion::handled and insertion
point is doing::point is doing
theta of log::theta of log
deletion was concerned::deletion was concerned
looked at running::looked at running
tree to search::tree to search
log n step::log n step
step each step::step each step
borrowing would correspond::borrowing would correspond
complicated data structure::complicated data structure
structure called red::structure called red
red black trees::red black trees
fast data structure::fast data structure
structure for implementing::structure for implementing
2-4 trees today::2-4 trees today
helpful in understanding::helpful in understanding
black trees functions::black trees functions
2-4 trees data::2-4 trees data
talking about red::talking about red
discussing about red::discussing about red
deletion in red::deletion in red
slightly more involved::slightly more involved
spending fair bit::spending fair bit
bit of class::bit of class
class on deletion::class on deletion
insertion in red::insertion in red
red black tree::red black tree
color them red::color them red
red and black::red and black
black tree subject::black tree subject
properties so first::properties so first
first the root::first the root
important a red::important a red
create the left::create the left
child by creating::child by creating
call an external::call an external
create an additional::create an additional
two external nodes::two external nodes
black we define::black we define
define the black::define the black
number of black::number of black
nodes we encounter::nodes we encounter
tree so lots::tree so lots
lots of definition::lots of definition
couple of examples::couple of examples
examples of red::examples of red
colored the nodes::colored the nodes
black and red::black and red
red the root::red the root
root is black::root is black
black or red::black or red
left right child::left right child
call external nodes::call external nodes
similarly the black::similarly the black
add this external::add this external
black children black::black children black
children black node::children black node
children or black::children or black
add the external::add the external
add an external::add an external
end of handing::end of handing
children but red::children but red
red right child::red right child
place the external::place the external
count the black::count the black
colored this red::colored this red
tree the black::tree the black
ancestors are black::ancestors are black
two black ancestors::two black ancestors
two black ancestor::two black ancestor
height of tree::height of tree
ensure ? first::ensure ? first
height or depth::height or depth
top so black::top so black
call the black::call the black
node and height::node and height
examples of trees::examples of trees
call a double::call a double
double red problem::double red problem
two reds occurring::two reds occurring
tree so black::tree so black
count its number::count its number
number of ancestor::number of ancestor
tree of black::tree of black
tree be small::tree be small
include your red::include your red
nodes and increase::nodes and increase
increase the number::increase the number
nodes the largest::nodes the largest
layers of black::layers of black
layer then red::layer then red
number of red::number of red
lies between log::lies between log
-1you can figure::-1you can figure
give you red::give you red
correspondence between red::correspondence between red
case the number::case the number
children and combine::children and combine
red children suppose::red children suppose
node so formed::node so formed
keys furthermore black::keys furthermore black
resulting 2-4 tree::resulting 2-4 tree
tree all leaves::tree all leaves
nodes i encounter::nodes i encounter
matter which leaf::matter which leaf
leaf i started::leaf i started
unique 2-4 node::unique 2-4 node
root i encounter::root i encounter
two red children::two red children
create a node::create a node
create another node::create another node
giving a proof::giving a proof
make a red::make a red
2-4 tree node::2-4 tree node
node so first::node so first
first i put::first i put
create one red::create one red
reds consecutively happening::reds consecutively happening
level the black::level the black
resulting red black::resulting red black
create a black::create a black
create some thing::create some thing
two consecutive reds::two consecutive reds
draw the external::draw the external
nodes and count::nodes and count
count their ancestors::count their ancestors
understand what red::understand what red
create a red::create a red
fact the operation::fact the operation
operation of insertion::operation of insertion
mimic those operations::mimic those operations
reasons for doing::reasons for doing
mimic the operation::mimic the operation
operation of deletion::operation of deletion
slightly more tricky::slightly more tricky
find it successor::find it successor
successor or predecessors::successor or predecessors
talking about successor::talking about successor
successor so successor::successor so successor
put an external::put an external
means the node::means the node
child we put::child we put
leaf or black::leaf or black
child which means::child which means
means right child::means right child
black then black::black then black
external node verses::external node verses
verses this external::verses this external
problem of black::problem of black
case the node::case the node
deleting or leaf::deleting or leaf
red double red::red double red
case to handle::case to handle
create a double::create a double
replace this entire::replace this entire
change the black::change the black
similarly this case::similarly this case
created a double::created a double
two cases corresponds::two cases corresponds
removing is part::removing is part
part of node::part of node
keys the key::keys the key
atleast two keys::atleast two keys
remove this key::remove this key
correspond to change::correspond to change
removing this reduces::removing this reduces
reduces the black::reduces the black
tree whose black::tree whose black
height is reduced::height is reduced
organize the tree::organize the tree
reorganizing this tree::reorganizing this tree
larger and larger::larger and larger
bunch of cases::bunch of cases
cases as procedure::cases as procedure
root has sub::root has sub
parent the parent::parent the parent
two different cases::two different cases
clarify this point::clarify this point
deleting this black::deleting this black
delete this entire::delete this entire
thing i replace::thing i replace
essentially this sub::essentially this sub
two external node::two external node
external node children::external node children
child is black::child is black
two children colored::two children colored
black so depending::black so depending
shown them black::shown them black
handle these cases::handle these cases
tree is hanging::tree is hanging
two case red::two case red
children and depending::children and depending
two more cases::two more cases
two is red::two is red
black which means::black which means
picture to show::picture to show
tree sub tree::tree sub tree
node is red::node is red
black red node::black red node
reorganize this tree::reorganize this tree
basically a rotation::basically a rotation
labeled these things::labeled these things
order will set::order will set
kind of reorganization::kind of reorganization
taking of avl::taking of avl
node was empty::node was empty
red which means::red which means
means the parent::means the parent
rotation ? student::rotation ? student
motivation is coming::motivation is coming
node which means::node which means
means its parent::means its parent
2-4 need tree::2-4 need tree
guy was red::guy was red
sibling my sibling::sibling my sibling
sibling can lend::sibling can lend
picture so lets::picture so lets
parent is red::parent is red
problem let check::problem let check
check the height::check the height
business so black::business so black
introduced double red::introduced double red
restored what case::restored what case
quickly now start::quickly now start
written so parent::written so parent
parent by parent::parent by parent
height is decreased::height is decreased
case the picture::case the picture
root black children::root black children
originally black height::originally black height
height of entire::height of entire
coloring will solve::coloring will solve
make this red::make this red
red and make::red and make
make this black::make this black
introduced the double::introduced the double
made this red::made this red
2-4 tree picture::2-4 tree picture
guy becomes empty::guy becomes empty
helps to clear::helps to clear
red next set::red next set
set of cases::set of cases
black so parent::black so parent
two assumption making::two assumption making
black this node::black this node
node has red::node has red
picture this height::picture this height
entire black height::entire black height
height that means::height that means
correct so first::correct so first
problem is concerned::problem is concerned
corresponds to parent::corresponds to parent
thing to decide::thing to decide
case we considered::case we considered
considered the case::considered the case
made the assumption::made the assumption
red that means::red that means
means this guy::means this guy
two sub tree::two sub tree
root are black::root are black
black height check::black height check
empty the parent::empty the parent
merge and merge::merge and merge
work with assumption::work with assumption
red child lets::red child lets
kind of combine::kind of combine
parents becomes empty::parents becomes empty
2-4 tree deletion::2-4 tree deletion
parent which means::parent which means
process the parent::process the parent
parent became empty::parent became empty
case you reduce::case you reduce
reduce the height::reduce the height
coloring a node::coloring a node
essentially one bit::essentially one bit
bit of information::bit of information
case the height::case the height
sub tree reduces::sub tree reduces
coloring the node::coloring the node
essentially one rotation::essentially one rotation
makes the process::makes the process
process really fast::process really fast
check this last::check this last
deletion next class::deletion next class
mind you don::mind you don
simpler to understand::simpler to understand
remember this process::remember this process
process data structures::process data structures
correspondence of red::correspondence of red
process in red::process in red
introduce the notion::introduce the notion
define the a-b::define the a-b
deletion in a-b::deletion in a-b
first the insertion::first the insertion
key already exist::key already exist
identify the place::identify the place
inserted we create::inserted we create
color this node::color this node
black tree differs::black tree differs
node is colored::node is colored
obeys certain properties::obeys certain properties
begin by coloring::begin by coloring
coloring this node::coloring this node
red colored node::red colored node
black colored node::black colored node
key and found::key and found
node i decided::node i decided
decided to put::decided to put
put my node::put my node
color it red::color it red
node is black::node is black
nodes that property::nodes that property
black tree continues::black tree continues
continues to hold::continues to hold
introduced a red::introduced a red
node the property::node the property
hold the problem::hold the problem
double red colored::double red colored
side is red::side is red
node with key::node with key
key k inside::key k inside
node i created::node i created
handle this problem::handle this problem
case of deletion::case of deletion
deletion the problem::deletion the problem
problem was arising::problem was arising
height was changing::height was changing
encountered a double::encountered a double
uniform the black::uniform the black
problem just concentrate::problem just concentrate
inserted is red::inserted is red
red this parent::red this parent
node was red::node was red
simple rotation note::simple rotation note
black height problem::black height problem
uniform only thing::uniform only thing
tree under node::tree under node
tree was red::tree was red
double red problems::double red problems
problem by inserting::problem by inserting
inserting that node::inserting that node
left side tree::left side tree
simple rotation takes::simple rotation takes
rotation takes care::rotation takes care
2-4 tree recall::2-4 tree recall
recolor the nodes::recolor the nodes
corresponds to split::corresponds to split
colored the node::colored the node
side that corresponds::side that corresponds
single black node::single black node
created a black::created a black
initial black height::initial black height
entire sub trees::entire sub trees
means the external::means the external
managed to move::managed to move
move the double::move the double
problem one level::problem one level
sub trees hanging::sub trees hanging
moves one level::moves one level
case the double::case the double
red problem moves::red problem moves
repeat this process::repeat this process
rotation take care::rotation take care
problem will move::problem will move
end up coloring::end up coloring
coloring the root::coloring the root
coloring it red::coloring it red
root is colored::root is colored
color it black::color it black
increase the black::increase the black
nodes should remain::nodes should remain
color the root::color the root
corresponds to moving::corresponds to moving
splitting the root::splitting the root
split the root::split the root
move the problem::move the problem
change the reds::change the reds
reds to black::reds to black
black and change::black and change
black to red::black to red
corresponds to recoloring::corresponds to recoloring
recoloring of nodes::recoloring of nodes
basically the node::basically the node
parent nodes sibling::parent nodes sibling
node whose color::node whose color
recoloring the moment::recoloring the moment
rotation the process::rotation the process
process very fast::process very fast
fast because recoloring::fast because recoloring
change those bits::change those bits
slightly more expensive::slightly more expensive
requires some pointer::requires some pointer
tree is faster::tree is faster
case of avl::case of avl
trees in avl::trees in avl
avl trees recall::avl trees recall
deletion is log::deletion is log
doing only log::doing only log
wanted to discuss::wanted to discuss
trees we looked::trees we looked
kind of operations::kind of operations
operations in log::operations in log
changing the tree::changing the tree
changed the tree::changed the tree
tree are insert::tree are insert
notion of a-b::notion of a-b
drawn an a-b::drawn an a-b
remember an a-b::remember an a-b
a-1 to b-1::a-1 to b-1
a-1 and b-1::a-1 and b-1
satisfy this property::satisfy this property
root the requirement::root the requirement
roughly the bounds::roughly the bounds
correct the statement::correct the statement
essentially a repetition::essentially a repetition
find a position::find a position
keeping in order::keeping in order
node gets split::node gets split
talking of a-b::talking of a-b
essentially 2-3 tree::essentially 2-3 tree
basically 2-3 tree::basically 2-3 tree
2-3 tree means::2-3 tree means
means each node::means each node
made with space::made with space
space then split::space then split
key is promoted::key is promoted
split can cascade::split can cascade
node and median::node and median
remove it shortly::remove it shortly
node had space::node had space
make it work::make it work
key gets promoted::key gets promoted
split and move::split and move
move the median::move the median
root this property::root this property
children so root::children so root
b-1keys this property::b-1keys this property
manner and inserted::manner and inserted
ended up splitting::ended up splitting
permit the root::permit the root
insist the root::insist the root
trees to a-b::trees to a-b
a-b tree node::a-b tree node
space for b-1keys::space for b-1keys
node is split::node is split
remaining are split::remaining are split
b-1is getting split::b-1is getting split
means one side::means one side
nodes are valid::nodes are valid
means that a-1this::means that a-1this
creating a node::creating a node
node with keys::node with keys
equal to a-1::equal to a-1
2-4tree the simple::2-4tree the simple
key left suppose::key left suppose
empty and node::empty and node
sibling the sibling::sibling the sibling
valid 2-3 tree::valid 2-3 tree
borrow one key::borrow one key
remember the reason::remember the reason
tree we merge::tree we merge
removed one key::removed one key
merged which means::merged which means
created one node::created one node
eventually the root::eventually the root
merge a node::merge a node
sibling which means::sibling which means
minimum number a-1::minimum number a-1
merging the node::merging the node
means the sibling::means the sibling
sibling has a-1keys::sibling has a-1keys
a-2keys after merging::a-2keys after merging
floor means rounded::floor means rounded
summary for insertion::summary for insertion
trees the height::trees the height
tree the reason::tree the reason
deletion was taking::deletion was taking
height was log::height was log
done some number::done some number
doing the operation::doing the operation
first we move::first we move
borrow the key::borrow the key
moved one level::moved one level
stop the entire::stop the entire
operation take order::operation take order
tree was concern::tree was concern
today was red::today was red
rotation to complete::rotation to complete
complete an insertion::complete an insertion
require one rotation::require one rotation
rotation some number::rotation some number
color many nodes::color many nodes
rotation is required::rotation is required
fast in practice::fast in practice
faster then avl::faster then avl
specially in searching::specially in searching
searching very large::searching very large
disk based data::disk based data
based data structures::based data structures
structures so today::structures so today
talking about disk::talking about disk
structures in last::structures in last
based data structure::based data structure
fact ab trees::fact ab trees
trees for specific::trees for specific
amount of data::amount of data
trees were limited::trees were limited
limited to main::limited to main
sense you build::sense you build
build a binary::build a binary
tree or build::tree or build
objects in memory::objects in memory
corresponds to pointer::corresponds to pointer
addresses or memory::addresses or memory
huge amount data::huge amount data
kind of transaction::kind of transaction
bank share markets::bank share markets
data get generate::data get generate
memory of computer::memory of computer
stored on disk::stored on disk
data or insert::data or insert
data or modify::data or modify
modify this data::modify this data
imagine the setting::imagine the setting
huge the data::huge the data
data should set::data should set
history of transaction::history of transaction
data to decide::data to decide
account so question::account so question
make a search::make a search
sense secondary storage::sense secondary storage
storage in avl::storage in avl
data is stored::data is stored
expect the entire::expect the entire
entire search tree::entire search tree
tree to fit::tree to fit
verses when thinks::verses when thinks
typically have bunch::typically have bunch
bunch of disk::bunch of disk
disk in stack::disk in stack
read write head::read write head
disk the disk::disk the disk
head can decide::head can decide
reading the data::reading the data
write head moving::write head moving
head moving determining::head moving determining
determining which track::determining which track
disk to rotate::disk to rotate
head is positioned::head is positioned
read in units::read in units
units in larger::units in larger
units you don::units you don
read one byte::read one byte
byte of data::byte of data
disk why don::disk why don
read whole lot::read whole lot
lot of bytes::lot of bytes
read or write::read or write
write in units::write in units
units called pages::units called pages
back and entire::back and entire
organize our search::organize our search
manner that first::manner that first
disk based algorithm::disk based algorithm
measured in terms::measured in terms
number of disk::number of disk
cpu is insignificant::cpu is insignificant
organize the data::organize the data
access the disk::access the disk
main memory algorithm::main memory algorithm
entire data sets::entire data sets
module when part::module when part
business is concern::business is concern
references to objects::references to objects
knew that correspondence::knew that correspondence
access that location::access that location
structure is sitting::structure is sitting
memory and part::memory and part
references is referring::references is referring
operation disk read::operation disk read
read to read::read to read
disk and disk::disk and disk
write to write::write to write
fetch that block::fetch that block
block of data::block of data
page of data::page of data
object so typical::object so typical
read this object::read this object
omit this step::omit this step
modify the object::modify the object
two operation today::two operation today
read and disk::read and disk
reading a block::reading a block
block from disk::block from disk
disk and writing::disk and writing
back to disk::back to disk
disk based access::disk based access
two level trees::two level trees
trees these leaves::trees these leaves
entire two levels::entire two levels
two levels structure::two levels structure
bytes of memory::bytes of memory
bytes of pointers::bytes of pointers
bytes per key::bytes per key
times a billion::times a billion
kind of space::kind of space
account has listed::account has listed
last three years::last three years
lets says stored::lets says stored
data was stored::data was stored
keys and pointers::keys and pointers
kind of structure::kind of structure
tree this structure::tree this structure
lies in suppose::lies in suppose
suppose it lies::suppose it lies
child node suppose::child node suppose
access this node::access this node
disk and bring::disk and bring
node from disk::node from disk
find your account::find your account
follow the account::follow the account
tree ? increase::tree ? increase
increase the value::increase the value
nodes and page::nodes and page
keys is taking::keys is taking
taking certain amount::taking certain amount
amount of space::amount of space
page ? page::page ? page
unit of transfer::unit of transfer
keys comma pointer::keys comma pointer
pointer per taking::pointer per taking
key comma pointer::key comma pointer
pair is taking::pair is taking
lets say methods::lets say methods
means leaf node::means leaf node
node other wise::node other wise
tree c sub::tree c sub
essentially same structure::essentially same structure
provided a lower::provided a lower
node has degree::node has degree
equals two times::equals two times
essentially special kind::essentially special kind
minus one keys::minus one keys
tree is meant::tree is meant
data structure meant::data structure meant
meant for secondary::meant for secondary
choose large value::choose large value
tree is smallest::tree is smallest
node can fit::node can fit
recursive search procedure::recursive search procedure
keys are arranging::keys are arranging
find a first::find a first
find a key::find a key
found a key::found a key
node i fetch::node i fetch
continue my search::continue my search
keys can sit::keys can sit
process of splitting::process of splitting
separately to understand::separately to understand
understand this code::understand this code
procedure for splitting::procedure for splitting
splitting a node::splitting a node
first you copy::first you copy
copy the children::copy the children
moved up copied::moved up copied
modified this node::modified this node
node we created::node we created
doing this disk::doing this disk
slides and understand::slides and understand
understand the code::understand the code
split the number::split the number
moves certain keys::moves certain keys
fairly small compared::fairly small compared
access so today::access so today
today one variant::today one variant
variant of binary::variant of binary
trees also works::trees also works
two four trees::two four trees
node getting split::node getting split
two parse operation::two parse operation
tree one possibility::tree one possibility
top you check::top you check
quota of keys::quota of keys
level we make::level we make
inserted the key::inserted the key
first root node::first root node
tree whatever key::tree whatever key
node is full::node is full
promoted here note::promoted here note
inserted an element::inserted an element
happen here anymore::happen here anymore
parent had room::parent had room
straight away split::straight away split
right away split::right away split
guy gets promoted::guy gets promoted
lets me accommodate::lets me accommodate
accommodate this addition::accommodate this addition
crossing ripple effect::crossing ripple effect
kind of access::kind of access
access every node::access every node
disk its parent::disk its parent
times the number::times the number
number of splits::number of splits
disadvantages of doing::disadvantages of doing
skip the code::skip the code
code i showed::code i showed
key is concern::key is concern
recall the earlier::recall the earlier
tree we deleted::tree we deleted
deleted the key::deleted the key
key that node::key that node
remove one key::remove one key
single pass delete::single pass delete
pass delete procedure::pass delete procedure
procedure which means::procedure which means
encounter a node::encounter a node
minimum of keys::minimum of keys
make a effort::make a effort
merge we bring::merge we bring
descending to lower::descending to lower
insertion we require::insertion we require
equals three means::equals three means
encounter this node::encounter this node
key the minimum::key the minimum
action to ensure::action to ensure
successful in borrowing::successful in borrowing
answering the question::answering the question
trees ? student::trees ? student
suppose i delete::suppose i delete
lot of works::lot of works
works in doing::works in doing
splitting the node::splitting the node
lots of pointer::lots of pointer
happening so insert::happening so insert
insert and deletes::insert and deletes
block of insert::block of insert
insert and block::insert and block
block of delete::block of delete
handle whole lots::handle whole lots
lots of delete::lots of delete
delete without significant::delete without significant
sequence of delete::sequence of delete
sequence of insert::sequence of insert
things alternating vary::things alternating vary
sibling or merging::sibling or merging
back my sibling::back my sibling
sibling one key::sibling one key
parent gets modified::parent gets modified
borrow or merge::borrow or merge
back three node::back three node
two pass operation::two pass operation
case of disk::case of disk
organize the things::organize the things
make one pass::make one pass
make a pass::make a pass
made a single::made a single
making first pass::making first pass
read in memory::read in memory
reduce the type::reduce the type
reduce the number::reduce the number
end this class::end this class
specifically for disk::specifically for disk
disk based accesses::disk based accesses
setting data structures::setting data structures
searching for patterns::searching for patterns
patterns so today::patterns so today
talking about pattern::talking about pattern
searching or pattern::searching or pattern
matching the setting::matching the setting
piece of text::piece of text
out all occurrences::out all occurrences
work most editors::work most editors
editors will provide::editors will provide
facility many things::facility many things
provide this kind::provide this kind
kind of facility::kind of facility
pattern so question::pattern so question
exact matching problem::exact matching problem
manner that means::manner that means
places it matches::places it matches
solve this problem::solve this problem
retrieval one big::retrieval one big
application is bio::application is bio
database with sequence::database with sequence
sequence of nucleotides::sequence of nucleotides
alphabet of size::alphabet of size
method of doing::method of doing
put the pattern::put the pattern
matching the pattern::matching the pattern
find the mismatch::find the mismatch
move the pattern::move the pattern
step was critical::step was critical
skipped this thing::skipped this thing
suppose i moved::suppose i moved
missed the occurrence::missed the occurrence
occurring at multiples::occurring at multiples
text so moving::text so moving
out the mismatch::out the mismatch
pattern how long::pattern how long
space we require::space we require
store the text::store the text
store the pattern::store the pattern
pattern we don::pattern we don
space we don::space we don
array to move::array to move
moving the pattern::moving the pattern
increment your index::increment your index
sequence of improvements::sequence of improvements
mismatch is detected::mismatch is detected
matched k-1 characters::matched k-1 characters
detected at position::detected at position
first two characters::first two characters
last two characters::last two characters
position in text::position in text
shift the pattern::shift the pattern
pointer in shifting::pointer in shifting
implement this idea::implement this idea
step the mismatch::step the mismatch
last three characters::last three characters
mismatch was happening::mismatch was happening
shift will depend::shift will depend
wanted to shift::wanted to shift
procedure very shortly::procedure very shortly
algorithm so key::algorithm so key
restart the computation::restart the computation
pattern some information::pattern some information
pattern to determine::pattern to determine
construct an array::construct an array
characters to shift::characters to shift
right in case::right in case
store this information::store this information
position that means::position that means
matched the prefix::matched the prefix
label these things::label these things
counting i-1 locations::counting i-1 locations
matches up completely::matches up completely
define so recall::define so recall
mismatch at position::mismatch at position
make the smallest::make the smallest
smallest possible shift::smallest possible shift
amount of shift::amount of shift
shift is smallest::shift is smallest
smallest or largest::smallest or largest
smallest and largest::smallest and largest
out any pattern::out any pattern
waste any comparisons::waste any comparisons
happened at position::happened at position
draw a picture::draw a picture
shifted the pattern::shifted the pattern
comparing the pattern::comparing the pattern
draw the shift::draw the shift
two ? useless::two ? useless
matching this shift::matching this shift
playing this game::playing this game
value to shift::value to shift
longest proper suffix::longest proper suffix
matches the prefix::matches the prefix
prefix is contiguous::prefix is contiguous
finding the longest::finding the longest
proper suffix proper::proper suffix proper
suffix proper suffix::suffix proper suffix
proper suffix means::proper suffix means
suffix means suffix::suffix means suffix
include the entire::include the entire
text like proper::text like proper
proper subset means::proper subset means
means strictly smaller::means strictly smaller
means that matches::means that matches
find out length::find out length
match the prefix::match the prefix
out the longest::out the longest
shift without missing::shift without missing
longest possible match::longest possible match
suffix which matches::suffix which matches
pattern has matched::pattern has matched
matched the first::matched the first
characters still continue::characters still continue
continue to match::continue to match
happening by shifting::happening by shifting
shifting the pattern::shifting the pattern
extent to shift::extent to shift
shift by huge::shift by huge
position which means::position which means
condition is true::condition is true
last six characters::last six characters
characters and first::characters and first
first six characters::first six characters
potential this guy::potential this guy
shifted pattern h11::shifted pattern h11
suffix of text::suffix of text
position of mismatch::position of mismatch
parts should match::parts should match
suppose the pattern::suppose the pattern
longest such matching::longest such matching
minimum shift occurs::minimum shift occurs
occurs or maximum::occurs or maximum
maximum shift occurs::maximum shift occurs
shift is happening::shift is happening
largest possible shift::largest possible shift
out any patterns::out any patterns
end up missing::end up missing
pattern by doing::pattern by doing
text the mismatch::text the mismatch
text and position::text and position
part is beta::part is beta
kmp algorithm missed::kmp algorithm missed
find the procedure::find the procedure
string of length::string of length
length alpha matches::length alpha matches
matches the suffix::matches the suffix
alpha and alpha::alpha and alpha
violates our definition::violates our definition
longer these matches::longer these matches
prefix yes agreed::prefix yes agreed
suffix or prefix::suffix or prefix
prefix which matches::prefix which matches
establishes the correctness::establishes the correctness
things would work::things would work
expand it out::expand it out
array h suppose::array h suppose
amount of effort::amount of effort
text the first::text the first
first mismatch occurs::first mismatch occurs
occurs at position::occurs at position
means till position::means till position
written in position::written in position
pattern will remain::pattern will remain
units the pattern::units the pattern
match the first::match the first
pattern the value::pattern the value
units i shift::units i shift
shift by additional::shift by additional
mismatch which means::mismatch which means
found the match::found the match
function is designed::function is designed
sound very good::sound very good
comparisons is huge::comparisons is huge
call this unsuccessful::call this unsuccessful
comparison ? comparisons::comparison ? comparisons
comparisons that result::comparisons that result
number of unsuccessful::number of unsuccessful
part of successful::part of successful
compare this part::compare this part
comparison is compared::comparison is compared
back track happening::back track happening
happening the number::happening the number
number of successful::number of successful
text the total::text the total
number of shifts::number of shifts
character is part::character is part
unsuccessful comparison results::unsuccessful comparison results
shift so total::shift so total
two successful comparisons::two successful comparisons
text so total::text so total
size the text::size the text
number of comparison::number of comparison
computing the array::computing the array
call that preprocessing::call that preprocessing
required to compute::required to compute
compute the array::compute the array
searching is order::searching is order
done in order::done in order
longest proper prefix::longest proper prefix
prefix or longest::prefix or longest
suffix whatever longest::suffix whatever longest
out the value::out the value
out the last::out the last
last three character::last three character
first three character::first three character
choose a value::choose a value
summation i square::summation i square
cube ; divide::cube ; divide
idea in fact::idea in fact
doing this computation::doing this computation
computation of array::computation of array
require the text::require the text
head and work::head and work
first five match::first five match
confusing my array::confusing my array
class so today::class so today
today we looked::today we looked
looked at pattern::looked at pattern
algorithm for doing::algorithm for doing
order m cube::order m cube
3rd has trees::3rd has trees
interested in matching::interested in matching
matching patterns finding::matching patterns finding
places certain pattern::places certain pattern
preprocessed the pattern::preprocessed the pattern
pattern we computed::pattern we computed
computed this failure::computed this failure
information to search::information to search
preprocessing the pattern::preprocessing the pattern
match the pattern::match the pattern
compute the failure::compute the failure
brute force method::brute force method
method of matching::method of matching
size of text::size of text
processing the pattern::processing the pattern
knuth-morris-pratt algorithm searches::knuth-morris-pratt algorithm searches
searches an arbitrary::searches an arbitrary
text which doesn::text which doesn
spend time proportional::spend time proportional
works of shakespeare::works of shakespeare
process the text::process the text
typically very small::typically very small
million characters large::million characters large
large you don::large you don
preprocess that text::preprocess that text
created some data::created some data
pattern all occurrences::pattern all occurrences
matter what pattern::matter what pattern
previous kmp algorithm::previous kmp algorithm
processed the pattern::processed the pattern
matter what text::matter what text
taking time proportional::taking time proportional
picture so trie::picture so trie
structure to maintain::structure to maintain
maintain a set::maintain a set
set of strings::set of strings
tree in fact::tree in fact
fact the number::fact the number
strings are lower::strings are lower
lower case characters::lower case characters
organized ? suppose::organized ? suppose
follow a path::follow a path
words here suppose::words here suppose
build this thing::build this thing
give you set::give you set
set of words::set of words
build this trie::build this trie
leaf node corresponds::leaf node corresponds
search for bed::search for bed
linked list ordered::linked list ordered
search ? suppose::search ? suppose
change the search::change the search
times the length::times the length
link list sitting::link list sitting
follow this pointer::follow this pointer
pointer and repeat::pointer and repeat
repeat these things::repeat these things
operation of find::operation of find
list of presentation::list of presentation
create that letter::create that letter
create new nodes::create new nodes
create one circular::create one circular
thing is bad::thing is bad
created ? total::created ? total
number of characters::number of characters
character the first::character the first
first word begins::first word begins
make a long::make a long
total not total::total not total
number of words::number of words
call that double::call that double
peace of text::peace of text
text and throw::text and throw
trie i make::trie i make
make a trie::make a trie
started off today::started off today
word matching find::word matching find
occurrence of word::occurrence of word
detect by doing::detect by doing
operations of matching::operations of matching
matching is done::matching is done
done by tracing::done by tracing
tracing the path::tracing the path
bunch of words::bunch of words
words i threw::words i threw
leaf i store::leaf i store
bid is occurring::bid is occurring
places perhaps starting::places perhaps starting
preprocessing the text::preprocessing the text
built this trie::built this trie
stored this information::stored this information
give you piece::give you piece
give you pattern::give you pattern
pattern and find::pattern and find
collection of words::collection of words
sequence of basis::sequence of basis
notion of words::notion of words
searching for words::searching for words
search for patterns::search for patterns
boundaries my pattern::boundaries my pattern
boundary and end::boundary and end
address the issue::address the issue
reduce the size::reduce the size
remove those nodes::remove those nodes
nodes by degree::nodes by degree
compress those nodes::compress those nodes
node this node::node this node
node in fact::node in fact
fact this node::fact this node
child and collapse::child and collapse
created a long::created a long
trie is smaller::trie is smaller
children every internal::children every internal
node clearly leaf::node clearly leaf
leaf nodes don::leaf nodes don
trie is order::trie is order
set of string::set of string
trie this doesn::trie this doesn
longer label inside::longer label inside
store that label::store that label
space to store::space to store
begins at position::begins at position
ends at position::ends at position
labels no matter::labels no matter
matter how long::matter how long
necessarily a suffix::necessarily a suffix
necessarily for instance::necessarily for instance
store these words::store these words
structure is number::structure is number
two times number::two times number
thing you understand::thing you understand
doing anything sophisticated::doing anything sophisticated
reach the middle::reach the middle
delete this guy::delete this guy
collapse the child::collapse the child
simple data structure::simple data structure
out the implementation::out the implementation
google you type::google you type
type a word::type a word
word that part::word that part
part which helps::part which helps
helps you retrieve::helps you retrieve
compressed trie typically::compressed trie typically
generic search engine::generic search engine
memory the list::memory the list
imagine the number::imagine the number
number of urls::number of urls
disk now suppose::disk now suppose
suppose you wrote::suppose you wrote
wrote ? computer::wrote ? computer
computer and music::computer and music
search for computer::search for computer
search for music::search for music
two occurrence lists::two occurrence lists
intersection so boolean::intersection so boolean
boolean queries corresponds::boolean queries corresponds
corresponds to set::corresponds to set
lots of techniques::lots of techniques
thing you eliminate::thing you eliminate
eliminate stop words::eliminate stop words
computer on internet::computer on internet
number so type::number so type
nslookup to find::nslookup to find
manner for instance::manner for instance
iit delhi address::iit delhi address
router when packet::router when packet
bunch of links::bunch of links
coming in links::coming in links
out so packets::out so packets
out which links::out which links
links to send::links to send
packet and find::packet and find
match your table::match your table
tables are organized::tables are organized
back to pattern::back to pattern
doing the job::doing the job
words or delimiter::words or delimiter
started and ended::started and ended
delimiter but suppose::delimiter but suppose
biological data base::biological data base
text and organize::text and organize
create a trie::create a trie
4th so put::4th so put
essentially a compressed::essentially a compressed
length of text::length of text
words order number::words order number
size d stores::size d stores
suppose i start::suppose i start
suffix whose prefix::suffix whose prefix
pattern that means::pattern that means
pattern which means::pattern which means
word will match::word will match
tree and identify::tree and identify
word ? minimized::word ? minimized
make the suffix::make the suffix
text i make::text i make
make a suffix::make a suffix
collapsed my nodes::collapsed my nodes
make this suffix::make this suffix
store by numbers::store by numbers
starts at position::starts at position
report all occurrences::report all occurrences
trie is contained::trie is contained
suppose my text::suppose my text
node you don::node you don
special about dollar::special about dollar
build a suffix::build a suffix
breaking this edge::breaking this edge
find the longest::find the longest
root whose label::root whose label
matches a prefix::matches a prefix
create an edge::create an edge
quickly one suffix::quickly one suffix
takes time order::takes time order
exploiting in pattern::exploiting in pattern
find all occurrences::find all occurrences
occurrences of pattern::occurrences of pattern
idea of algorithm::idea of algorithm
obtained as concatenation::obtained as concatenation
labels of edges::labels of edges
match the characters::match the characters
pattern is exhausted::pattern is exhausted
found a match::found a match
means that pattern::means that pattern
text in case::text in case
obtained by extending::obtained by extending
extending the path::extending the path
reach a leaf::reach a leaf
leaf each extension::leaf each extension
pattern each extension::pattern each extension
suffix this corresponds::suffix this corresponds
order n2 algorithm::order n2 algorithm
algorithm for constructing::algorithm for constructing
constructing the suffix::constructing the suffix
fairly complicated algorithm::fairly complicated algorithm
complexity of pattern::complexity of pattern
preprocessing which means::preprocessing which means
building the suffix::building the suffix
number of occurrences::number of occurrences
long but occurs::long but occurs
occurs one thousand::occurs one thousand
side the total::side the total
size of pattern::size of pattern
pattern to store::pattern to store
decide to preprocess::decide to preprocess
preprocess the text::preprocess the text
pattern data structures::pattern data structures
data compression today::data compression today
idea behind file::idea behind file
talking about huffman::talking about huffman
doing data compression::doing data compression
abracadabra ? translate::abracadabra ? translate
stored as bits::stored as bits
shell and type::shell and type
type < man::type < man
code which means::code which means
character is stored::character is stored
number of bits::number of bits
reduce the amount::reduce the amount
required to encode::required to encode
encode a piece::encode a piece
text but suppose::text but suppose
suppose i don::suppose i don
design a coding::design a coding
text using lesser::text using lesser
bits using lesser::bits using lesser
bits you understand::bits you understand
doing this kind::doing this kind
kind of compression::kind of compression
memory you require::memory you require
transmitting the file::transmitting the file
send less number::send less number
store less number::store less number
compress the information::compress the information
call variable-length coding::call variable-length coding
represent each character::represent each character
character which occur::character which occur
decide to encode::decide to encode
suppose my alphabets::suppose my alphabets
encoded were strings::encoded were strings
string and suppose::string and suppose
doing fixed length::doing fixed length
fixed length encoding::fixed length encoding
two possible values::two possible values
problem with variable::problem with variable
variable length decoding::variable length decoding
variable length encoding::variable length encoding
sequence of bits::sequence of bits
decode it uniquely::decode it uniquely
back to java::back to java
suppose for instance::suppose for instance
problem of ambiguity::problem of ambiguity
ambiguity while decoding::ambiguity while decoding
variable length codes::variable length codes
codes this problem::codes this problem
fixed length codes::fixed length codes
codes you understand::codes you understand
ambiguities in decoding::ambiguities in decoding
code by code::code by code
satisfy the prefix::satisfy the prefix
ambiguity in decoding::ambiguity in decoding
collection of code::collection of code
character the sequence::character the sequence
code so code::code so code
code which satisfies::code which satisfies
satisfies the prefix::satisfies the prefix
trie so recall::trie so recall
branching each node::branching each node
node the left::node the left
edge will label::edge will label
leaf each character::leaf each character
prefix of code::prefix of code
represent our codes::represent our codes
leaf to determine::leaf to determine
determine the code::determine the code
shown this picture::shown this picture
drawn this trie::drawn this trie
decoding ? suppose::decoding ? suppose
decode this text::decode this text
beginning you start::beginning you start
leaf you stop::leaf you stop
piece of encoded::piece of encoded
aim in doing::aim in doing
recall we wanted::recall we wanted
wanted to build::wanted to build
suppose this trie::suppose this trie
counting the number::counting the number
totally now suppose::totally now suppose
occur very infrequently::occur very infrequently
count the frequency::count the frequency
frequency of characters::frequency of characters
compute the trie::compute the trie
encode the character::encode the character
root is number::root is number
character has frequency::character has frequency
choose a tree::choose a tree
quantity is minimized::quantity is minimized
minimized our tree::minimized our tree
tree will determine::tree will determine
pick a tree::pick a tree
total external weighted::total external weighted
external weighted path::external weighted path
weighted path length::weighted path length
talking about external::talking about external
basically the number::basically the number
levels ? weighted::levels ? weighted
viewing each leaf::viewing each leaf
character the weights::character the weights
weighted are referring::weighted are referring
thing is weight::thing is weight
weight or frequency::weight or frequency
frequency this means::frequency this means
weights or frequencies::weights or frequencies
find the tree::find the tree
tree whose total::tree whose total
total weighted external::total weighted external
weighted external path::weighted external path
external path length::external path length
length is minimum::length is minimum
build a tree::build a tree
tree whose leaves::tree whose leaves
denote this minimum::denote this minimum
minimum weighted external::minimum weighted external
leaves with weights::leaves with weights
minimum total weighted::minimum total weighted
managed to translate::managed to translate
translate our question::translate our question
question of finding::question of finding
length in encoding::length in encoding
encoded message minimum::encoded message minimum
tree one thing::tree one thing
put red boxes::put red boxes
leaves i make::leaves i make
make another node::make another node
value of weight::value of weight
weight of sum::weight of sum
two will disappear::two will disappear
smallest and combine::smallest and combine
whichever you feel::whichever you feel
reducing a node::reducing a node
two nodes left::two nodes left
difference the length::difference the length
encoding was determined::encoding was determined
minimum for abracadabra::minimum for abracadabra
occurring five times::occurring five times
build another trie::build another trie
first i combined::first i combined
combined these two::combined these two
decide to combine::decide to combine
claiming is false::claiming is false
algorithm is computing::algorithm is computing
computing the tree::computing the tree
computing the minimum::computing the minimum
compute a tree::compute a tree
assume the claim::assume the claim
characters or leaves::characters or leaves
frequencies and combining::frequencies and combining
two characters frequencies::two characters frequencies
node of weight::node of weight
point the behavior::point the behavior
characters with frequencies::characters with frequencies
point the algorithm::point the algorithm
computed a tree::computed a tree
characters with total::characters with total
minimum the tree::minimum the tree
algorithm has weighted::algorithm has weighted
algorithm has computed::algorithm has computed
path length computed::path length computed
algorithm had computed::algorithm had computed
quantity that algorithm::quantity that algorithm
tree whose weighted::tree whose weighted
prove this fact::prove this fact
suppose this factor::suppose this factor
factor is true::factor is true
suppose had proved::suppose had proved
proved this factor::proved this factor
two lowest weights::two lowest weights
weights are siblings::weights are siblings
slightly more formal::slightly more formal
minimum are siblings::minimum are siblings
assumed this statement::assumed this statement
path length equal::path length equal
give this node::give this node
node weight equal::node weight equal
tree over leaves::tree over leaves
values or leaves::values or leaves
choice of weights::choice of weights
weights also suppose::weights also suppose
suppose the black::suppose the black
red weighted external::red weighted external
blue total external::blue total external
total external path::total external path
length is red::length is red
red external path::red external path
means blue weighted::means blue weighted
blue weighted external::blue weighted external
leaf is equal::leaf is equal
algorithm is completing::algorithm is completing
increased the black::increased the black
blue also differs::blue also differs
blue which violates::blue which violates
violates our optimal::violates our optimal
two lowest frequencies::two lowest frequencies
frequencies are siblings::frequencies are siblings
level number suppose::level number suppose
swap these two::swap these two
length becomes minimum::length becomes minimum
argument this leaf::argument this leaf
swap and reduce::swap and reduce
two smallest weights::two smallest weights
make them siblings::make them siblings
siblings and continue::siblings and continue
property being exploited::property being exploited
algorithm to compute::algorithm to compute
done priority queues::done priority queues
compute its running::compute its running
leaving the bit::leaving the bit
bit about computing::bit about computing
computing its running::computing its running
running time today::running time today
developed the notion::developed the notion
notion of paradigms::notion of paradigms
paradigms data structures::paradigms data structures
priority queues today::priority queues today
priority queue abstract::priority queue abstract
queue abstract data::queue abstract data
implement the priority::implement the priority
key thing today::key thing today
introduce the concept::introduce the concept
concept of binary::concept of binary
procedures for insertion::procedures for insertion
heap and procedure::heap and procedure
procedure called heapify::procedure called heapify
find to delete::find to delete
delete the minimum::delete the minimum
operations on heap::operations on heap
multi user computer::multi user computer
user computer system::user computer system
job is running::job is running
resumed one policy::resumed one policy
policy which minimizes::policy which minimizes
minimizes the average::minimizes the average
srpt the srpt::srpt the srpt
stands for shortest::stands for shortest
shortest remaining processing::shortest remaining processing
schedules the job::schedules the job
smallest remaining processing::smallest remaining processing
bunch of job::bunch of job
bunch and schedule::bunch and schedule
job and schedule::job and schedule
implement this kind::implement this kind
maintain the remaining::maintain the remaining
maintain that collection::maintain that collection
set of jobs::set of jobs
schedule the job::schedule the job
implement the srpt::implement the srpt
policies one data::policies one data
type to maintain::type to maintain
priority the priority::priority the priority
priority queue data::priority queue data
data type supports::data type supports
operations the first::operations the first
inserting the element::inserting the element
element the minimum::element the minimum
minimum operation returns::minimum operation returns
returns the element::returns the element
smallest priority priority::smallest priority priority
bit of misnomer::bit of misnomer
sense to remove::sense to remove
processing time remaining::processing time remaining
delete min operation::delete min operation
operation the delete::operation the delete
delete main operation::delete main operation
main operation returns::main operation returns
minimum and delete::minimum and delete
delete min differs::delete min differs
minimum only returns::minimum only returns
returns the minimum::returns the minimum
element it doesn::element it doesn
min also deletes::min also deletes
queue is supposed::queue is supposed
supposed to support::supposed to support
recall the priority::recall the priority
priority queue ranks::priority queue ranks
ranks its element::ranks its element
element by priority::element by priority
priority every element::priority every element
necessarily be unique::necessarily be unique
lets say denote::lets say denote
priorities these priorities::priorities these priorities
antisymmetric which means::antisymmetric which means
properties of total::properties of total
total order relation::total order relation
satisfies the total::satisfies the total
total order deletion::total order deletion
general and reusable::general and reusable
form of priority::form of priority
queue uses comparator::queue uses comparator
element has priority::element has priority
put any kind::put any kind
mechanism of comparing::mechanism of comparing
comparing the priorities::comparing the priorities
specifies the methods::specifies the methods
compare to priorities::compare to priorities
implementation of priority::implementation of priority
implementation to store::implementation to store
store any kind::store any kind
kind of object::kind of object
compare the priorities::compare the priorities
decide to put::decide to put
collection the comparator::collection the comparator
comparator abstract data::comparator abstract data
type would include::type would include
unsorted sequence recall::unsorted sequence recall
recall the items::recall the items
sequence or pairs::sequence or pairs
pairs of priority::pairs of priority
implement the insert::implement the insert
end this takes::end this takes
find a minimum::find a minimum
sequences for instance::sequences for instance
traverse the sequence::traverse the sequence
reach the element::reach the element
similarly for delete::similarly for delete
element so worst::element so worst
case time complexity::case time complexity
complexity of minimum::complexity of minimum
insertion takes constant::insertion takes constant
implement a priority::implement a priority
elements are sorted::elements are sorted
sorted with increasing::sorted with increasing
priority is straight::priority is straight
retrieve the minimum::retrieve the minimum
similarly to delete::similarly to delete
priority is sitting::priority is sitting
element with priority::element with priority
position and put::position and put
worst case insert::worst case insert
sequence priority queues::sequence priority queues
priority queues find::priority queues find
find many applications::find many applications
discreet event simulation::discreet event simulation
lets says dijkstra::lets says dijkstra
algorithm which require::algorithm which require
require the priority::require the priority
queue data structure::queue data structure
implement the algorithm::implement the algorithm
queue and unsorted::queue and unsorted
sequence and sorted::sequence and sorted
problems in case::problems in case
case of unsorted::case of unsorted
sequence the delete::sequence the delete
operation and minimum::operation and minimum
operations are constant::operations are constant
min and minimum::min and minimum
minimum very efficiently::minimum very efficiently
binary heap binary::binary heap binary
heap binary heap::heap binary heap
tree that stores::tree that stores
stores the priorities::stores the priorities
priority element pairs::priority element pairs
show the nodes::show the nodes
element is sitting::element is sitting
storing only priorities::storing only priorities
pairs now heap::pairs now heap
tree all levels::tree all levels
levels are full::levels are full
call left fill::call left fill
fill which means::fill which means
call a heap::call a heap
property the heap::property the heap
node its priority::node its priority
parent this picture::parent this picture
manner the priority::manner the priority
violates the heap::violates the heap
violate the heap::violate the heap
first four nodes::first four nodes
heap ? suppose::heap ? suppose
heap ? recall::heap ? recall
heap property suppose::heap property suppose
found the minimum::found the minimum
priority always sits::priority always sits
heap the top::heap the top
picture the element::picture the element
sitting in top::sitting in top
inside the heap::inside the heap
priority the heap::priority the heap
priority just recap::priority just recap
priority was sitting::priority was sitting
parent with smaller::parent with smaller
property this larger::property this larger
property the minimum::property the minimum
element to find::element to find
recall our discussion::recall our discussion
minus one nodes::minus one nodes
nodes with height::nodes with height
height h minus::height h minus
heap is larger::heap is larger
quantity this inequality::quantity this inequality
equals the floor::equals the floor
means that log::means that log
nearest integer hope::nearest integer hope
read h equals::read h equals
nodes just interchange::nodes just interchange
implement the heap::implement the heap
simpler to implement::simpler to implement
two and level::two and level
put these nodes::put these nodes
nodes of binary::nodes of binary
root node sitting::root node sitting
array my array::array my array
starting from location::starting from location
level would follow::level would follow
advantage of putting::advantage of putting
putting the nodes::putting the nodes
node at location::node at location
location five lets::location five lets
out the parent::out the parent
determine the parent::determine the parent
out this math::out this math
holding these priorities::holding these priorities
implicitly are maintaining::implicitly are maintaining
maintaining the tree::maintaining the tree
links the parent::links the parent
parent child relationships::parent child relationships
maintained the children::maintained the children
two just corresponds::two just corresponds
shift and multiplying::shift and multiplying
two and adding::two and adding
out the children::out the children
doing one left::doing one left
operation this makes::operation this makes
makes the operation::makes the operation
access the parent::access the parent
heap always sits::heap always sits
wanted to insert::wanted to insert
satisfy the structural::satisfy the structural
property of heap::property of heap
property this node::property this node
swap this thing::swap this thing
manner we swap::manner we swap
property is satisfied::property is satisfied
change the content::change the content
maintain the heap::maintain the heap
parent this violates::parent this violates
last now coming::last now coming
minimum priority element::minimum priority element
slightly different point::slightly different point
first we enlarge::first we enlarge
enlarge the heap::enlarge the heap
heap which means::heap which means
root to inserted::root to inserted
slight colored path::slight colored path
find the top::find the top
top most element::top most element
path with higher::path with higher
inserting is priority::inserting is priority
view of insertion::view of insertion
nodes whose contents::nodes whose contents
newly inserted node::newly inserted node
fact only changing::fact only changing
changing the contents::changing the contents
modifying this content::modifying this content
node is larger::node is larger
two pink color::two pink color
pink color nodes::pink color nodes
newly inserted element::newly inserted element
guy the priority::guy the priority
choice of path::choice of path
node with higher::node with higher
consequence of insertion::consequence of insertion
procedure the priority::procedure the priority
reduce the consequence::reduce the consequence
earlier its parent::earlier its parent
earlier the parent::earlier the parent
reducing then earlier::reducing then earlier
guy if earlier::guy if earlier
guy heap property::guy heap property
array so heapify::array so heapify
tree is rooted::tree is rooted
binary trees rooted::binary trees rooted
property now heapify::property now heapify
makes the binary::makes the binary
binary tree rooted::binary tree rooted
heap by suitable::heap by suitable
top has priority::top has priority
satisfy the heap::satisfy the heap
property each node::property each node
node has priority::node has priority
make this entire::make this entire
thing a heap::thing a heap
invoke the heapify::invoke the heapify
heapify procedure heap::heapify procedure heap
procedure heap property::procedure heap property
violated at node::violated at node
node with index::node with index
heap for heapify::heap for heapify
remember we require::remember we require
require that whichever::require that whichever
whichever node heapify::whichever node heapify
heapify is invoked::heapify is invoked
part for heapify::part for heapify
sub trees rooted::sub trees rooted
heapify works heapify::heapify works heapify
children and swap::children and swap
heap property heap::heap property heap
property heap property::property heap property
property is valid::property is valid
heap property valid::heap property valid
changed the content::changed the content
thing is heap::thing is heap
view of heapify::view of heapify
prove the correctness::prove the correctness
correctness of heapify::correctness of heapify
heapify very easily::heapify very easily
essentially is tracing::essentially is tracing
tracing a path::tracing a path
blue colored nodes::blue colored nodes
node whose context::node whose context
context we modified::context we modified
suppose i call::suppose i call
call it node::call it node
priority of node::priority of node
path have lower::path have lower
siblings ? sibling::siblings ? sibling
path have priorities::path have priorities
constructed our path::constructed our path
path this statement::path this statement
doing in heapify::doing in heapify
moving these elements::moving these elements
sequence of step::sequence of step
children have probability::children have probability
nodes have changed::nodes have changed
earlier a sibling::earlier a sibling
smaller priority node::smaller priority node
result of heapify::result of heapify
mechanism to rebuild::mechanism to rebuild
rebuild a heap::rebuild a heap
heap if due::heap if due
two sub trees::two sub trees
two child sub::two child sub
child sub trees::child sub trees
quick runtime analysis::quick runtime analysis
height order log::height order log
move the element::move the element
element might move::element might move
require time proportional::require time proportional
procedure we looked::procedure we looked
looked at today::looked at today
heapify at node::heapify at node
looked at node::looked at node
children and swapped::children and swapped
continued the process::continued the process
case the element::case the element
element might moved::element might moved
heap the height::heap the height
looked today insert::looked today insert
insert and heapify::insert and heapify
require only order::require only order
operation of minimum::operation of minimum
heap without removing::heap without removing
heap and return::heap and return
return the value::return the value
root minimum takes::root minimum takes
minimum takes constant::minimum takes constant
insertion takes order::insertion takes order
takes order log::takes order log
heapify also takes::heapify also takes
heapify to remove::heapify to remove
remove the minimum::remove the minimum
end to today::end to today
create a heap::create a heap
quickly in order::quickly in order
efficiently.thank you data::efficiently.thank you data
discussion of binary::discussion of binary
insertion and heapify::insertion and heapify
heap to recall::heap to recall
properties two critical::properties two critical
two critical properties::two critical properties
heap be similar::heap be similar
level of full::level of full
operations of deleting::operations of deleting
deleting the minimum::deleting the minimum
heap and building::heap and building
building a heap::building a heap
easy to build::easy to build
build a heap::build a heap
heap using repeated::heap using repeated
insertions but today::insertions but today
sort so recall::sort so recall
doing a delete::doing a delete
remove this element::remove this element
natural to promote::natural to promote
element to fill::element to fill
fill this empty::fill this empty
space would move::space would move
delete a minimum::delete a minimum
creates an empty::creates an empty
two children element::two children element
element and push::element and push
two and move::two and move
moves the empty::moves the empty
heap the elements::heap the elements
structurally this heap::structurally this heap
move this last::move this last
place and remove::place and remove
adjust the contents::adjust the contents
thing this sub::thing this sub
heap the heap::heap the heap
procedure for taking::procedure for taking
run a heapify::run a heapify
last class heapify::last class heapify
deleted the minimum::deleted the minimum
delete min procedure::delete min procedure
procedure to recap::procedure to recap
right most element::right most element
element and put::element and put
procedure fairly simple::procedure fairly simple
application of heapify::application of heapify
elements the last::elements the last
simple minded method::simple minded method
method of creating::method of creating
creating a heap::creating a heap
heap by repeated::heap by repeated
repeated insertion takes::repeated insertion takes
create the heap::create the heap
heaps using array::heaps using array
create the heaps::create the heaps
make a heap::make a heap
child and swap::child and swap
four sub trees::four sub trees
element and make::element and make
heapify the first::heapify the first
thing that heapify::thing that heapify
takes the smaller::takes the smaller
children and swaps::children and swaps
heap the smaller::heap the smaller
make the sub::make the sub
node a heap::node a heap
heap but note::heap but note
position to run::position to run
advantage of heapify::advantage of heapify
two and swap::two and swap
heapify so heapify::heapify so heapify
heapify would bubble::heapify would bubble
node the heapify::node the heapify
node just doesn::node just doesn
bubble the element::bubble the element
node to make::node to make
case and swap::case and swap
doing the heapify::doing the heapify
two children swapped::two children swapped
property is validated::property is validated
nodes and swap::nodes and swap
build heap procedure::build heap procedure
procedure the build::procedure the build
elements are laid::elements are laid
run the heapify::run the heapify
order of running::order of running
single for loop::single for loop
order but remember::order but remember
proceed to run::proceed to run
entire build heap::entire build heap
heapify sub routine::heapify sub routine
crucially which takes::crucially which takes
takes as parameter::takes as parameter
parameter the location::parameter the location
analyze the build::analyze the build
rooted at locations::rooted at locations
step and prove::step and prove
procedure a simple::procedure a simple
simple minded approach::simple minded approach
running time computation::running time computation
last class takes::last class takes
worst case order::worst case order
case order log::case order log
build heap takes::build heap takes
heap takes order::heap takes order
bound of order::bound of order
procedure on heaps::procedure on heaps
define the height::define the height
call the leaves::call the leaves
leaves at height::leaves at height
simply the analysis::simply the analysis
height one nodes::height one nodes
nodes is height::nodes is height
nodes at height::nodes at height
nodes you require::nodes you require
number of swaps::number of swaps
required by swaps::required by swaps
required by heapify::required by heapify
heapify in terms::heapify in terms
swap the location::swap the location
making n calls::making n calls
done on heaps::done on heaps
heaps of size::heaps of size
size of height::size of height
heaps of height::heaps of height
heapify is proportional::heapify is proportional
crude upper bound::crude upper bound
recall that summation::recall that summation
equal zero term::equal zero term
multiply both sides::multiply both sides
analysis to show::analysis to show
procedure went bottom::procedure went bottom
first created smaller::first created smaller
created smaller heaps::created smaller heaps
heapify procedure repeatedly::heapify procedure repeatedly
heap in linear::heap in linear
sort using heaps::sort using heaps
heaps so give::heaps so give
bunch of elements::bunch of elements
put those elements::put those elements
remove the smaller::remove the smaller
heap becomes empty::heap becomes empty
removing n elements::removing n elements
delete min steps::delete min steps
min steps requires::min steps requires
steps requires order::steps requires order
required is order::required is order
swap the elements::swap the elements
sorted sequence recall::sorted sequence recall
heaps are implemented::heaps are implemented
implemented using arrays::implemented using arrays
additional space starting::additional space starting
delete this element::delete this element
heap so recall::heap so recall
deleting the element::deleting the element
move this element::move this element
location to move::location to move
swap the element::swap the element
heap property validated::heap property validated
essentially the delete::essentially the delete
done a delete::done a delete
swapped this location::swapped this location
happen this location::happen this location
easily be reversed::easily be reversed
reversed in linear::reversed in linear
sequence in increasing::sequence in increasing
continue the procedure::continue the procedure
swap the last::swap the last
ensure the heap::ensure the heap
property by doing::property by doing
swaps so smaller::swaps so smaller
heap so heap::heap so heap
heap by taking::heap by taking
taking the smaller::taking the smaller
swapping heap property::swapping heap property
swap the heap::swap the heap
swapped this element::swapped this element
swapped the heap::swapped the heap
two children twenty::two children twenty
thirty one swap::thirty one swap
essentially means swap::essentially means swap
property by swapping::property by swapping
heap the smallest::heap the smallest
heap by doing::heap by doing
remove this minimum::remove this minimum
essentially that corresponds::essentially that corresponds
min which means::min which means
means i remove::means i remove
sequence in decreasing::sequence in decreasing
summarize the running::summarize the running
sort which takes::sort which takes
takes a total::takes a total
two step process::two step process
first we created::first we created
created a heap::created a heap
operation we spent::operation we spent
spent order log::spent order log
n-2 plus log::n-2 plus log
series is log::series is log
log n factorial::log n factorial
system is order::system is order
step is order::step is order
implies that heap::implies that heap
heap sort takes::heap sort takes
log n building::log n building
bottom up procedure::bottom up procedure
procedure for building::procedure for building
ways of building::ways of building
repeated insertion repeated::repeated insertion repeated
insertion repeated insertion::insertion repeated insertion
insertion we insert::insertion we insert
insert one element::insert one element
argued that takes::argued that takes
takes that kind::takes that kind
bottom up process::bottom up process
process of building::process of building
building the heap::building the heap
made the sub::made the sub
two a heap::two a heap
bottom up construction::bottom up construction
heap this takes::heap this takes
sorted is takes::sorted is takes
takes only order::takes only order
first we remove::first we remove
implementation this corresponds::implementation this corresponds
children are heaps::children are heaps
heapify and constant::heapify and constant
swap of moving::swap of moving
moving the last::moving the last
location so total::location so total
removing the minimum::removing the minimum
wanted to find::wanted to find
heap procedure today::heap procedure today
sort actually heapify::sort actually heapify
takes only log::takes only log
bubbling the element::bubbling the element
moving the element::moving the element
first we decide::first we decide
add an additional::add an additional
log n levels::log n levels
heap to implement::heap to implement
forget heap sort::forget heap sort
min and delete::min and delete
operations we started::operations we started
min is done::min is done
constant time insert::constant time insert
min also don::min also don
interested in implementing::interested in implementing
implementing a heap::implementing a heap
implementing a priority::implementing a priority
takes a lot::takes a lot
doing a lot::doing a lot
lot of find::lot of find
find min operations::find min operations
sequence so depending::sequence so depending
sequences and unsorted::sequences and unsorted
sequences and depending::sequences and depending
operation of occurring::operation of occurring
operation for building::operation for building
sorting in order::sorting in order
place sorting algorithm::place sorting algorithm
sorting ? today::sorting ? today
operation that computers::operation that computers
love to spend::love to spend
problem which requires::problem which requires
develop good algorithms::develop good algorithms
looked at heap::looked at heap
sort so today::sort so today
oftenly in databases::oftenly in databases
search becomes efficient::search becomes efficient
recall the search::recall the search
lot of settings::lot of settings
settings in computation::settings in computation
graphics where sorting::graphics where sorting
sorting is essential::sorting is essential
algorithms also give::algorithms also give
algorithm design techniques::algorithm design techniques
solving a problem::solving a problem
techniques that people::techniques that people
adopt to design::adopt to design
design an algorithm::design an algorithm
standard of techniques::standard of techniques
techniques in sorting::techniques in sorting
sorting it shows::sorting it shows
techniques so today::techniques so today
algorithm design technique::algorithm design technique
bound on sorting::bound on sorting
algorithm which requires::algorithm which requires
comparisons no sorting::comparisons no sorting
algorithm can sort::algorithm can sort
log n comparisons::log n comparisons
exist any sorting::exist any sorting
prove lower bounds::prove lower bounds
sorting is concerned::sorting is concerned
sort and selection::sort and selection
two sorting algorithm::two sorting algorithm
written quick sort::written quick sort
sort actually heap::sort actually heap
list is quick::list is quick
average case running::average case running
algorithm design paradigm::algorithm design paradigm
solve those sub::solve those sub
solve the problems::solve the problems
parts and solving::parts and solving
solving the problems::solving the problems
algorithm to solve::algorithm to solve
combine the result::combine the result
merge sort algorithm::merge sort algorithm
analyzing the algorithm::analyzing the algorithm
put in increasing::put in increasing
lets say lets::lets say lets
step the split::step the split
dividing the problem::dividing the problem
two sub problems::two sub problems
equal in size::equal in size
two equal sub::two equal sub
equal sub problems::equal sub problems
sub problems equal::sub problems equal
numbers of elements::numbers of elements
problems are equal::problems are equal
1contains the first::1contains the first
n floor elements::-NONE- floor elements
first n elements::first -NONE- elements
combine i wanted::combine i wanted
wanted a sorted::wanted a sorted
procedure called partition::procedure called partition
spend in division::spend in division
thing we partitioned::thing we partitioned
sort one part::sort one part
first sorted sequence::first sorted sequence
put the pivot::put the pivot
combining there taking::combining there taking
taking ? constant::taking ? constant
sort is deriving::sort is deriving
algorithm i give::algorithm i give
identify the part::identify the part
solving the conquer::solving the conquer
sort the first::sort the first
merger sort procedure::merger sort procedure
procedure called merge::procedure called merge
procedure the definition::procedure the definition
definition of merge::definition of merge
sequences one sequence::sequences one sequence
make one sorted::make one sorted
algorithm is doing::algorithm is doing
top most elements::top most elements
element the top::element the top
two and put::two and put
resulting sequence whichever::resulting sequence whichever
two the smallest::two the smallest
numbers i don::numbers i don
shown it lower::shown it lower
kind of doing::kind of doing
doing a recursive::doing a recursive
call of merge::call of merge
level of recursive::level of recursive
call so first::call so first
merge sort call::merge sort call
part now first::part now first
divisions and doing::divisions and doing
doing recursive calls::doing recursive calls
sort this part::sort this part
single element sequence::single element sequence
parent calling procedure::parent calling procedure
sorted first half::sorted first half
merge this sorted::merge this sorted
two sort sequences::two sort sequences
finished the merge::finished the merge
finished that merge::finished that merge
first we divide::first we divide
two but first::two but first
finished this merge::finished this merge
doing the merge::doing the merge
divide trivial merge::divide trivial merge
two sorted sequences::two sorted sequences
part this merge::part this merge
call has finished::call has finished
merge sort calls::merge sort calls
number of merge::number of merge
made ? order::made ? order
ways of thinking::ways of thinking
apply those formulas::apply those formulas
calls to merge::calls to merge
merge two sequences::merge two sequences
two sorted sequenences::two sorted sequenences
resulting sorted sequence::resulting sorted sequence
kind of removed::kind of removed
sequences and append::sequences and append
two sequences put::two sequences put
two smaller sequences::two smaller sequences
out the smaller::out the smaller
compared i found::compared i found
smaller i write::smaller i write
doing ? order::doing ? order
comparing two elements::comparing two elements
two front elements::two front elements
two and writing::two and writing
out one element::out one element
out n elements::out n elements
suppose one sequence::suppose one sequence
sequence of length::sequence of length
compare the worst::compare the worst
sequences of arbitrary::sequences of arbitrary
understood the merge::understood the merge
set we understood::set we understood
understood what merge::understood what merge
comparisons does merge::comparisons does merge
sequence we spit::sequence we spit
kind of created::kind of created
created a mirror::created a mirror
decided to merge::decided to merge
divisions of algorithmically::divisions of algorithmically
doing your recursive::doing your recursive
easy to compute::easy to compute
doing the merges::doing the merges
merges we spend::merges we spend
spend in doing::spend in doing
merge two units::merge two units
two units essentially::two units essentially
counting two length::counting two length
require two unit::require two unit
two such merges::two such merges
elements so total::elements so total
merges is taking::merges is taking
taking two units::taking two units
sequences of length::sequences of length
n such merges::-NONE- such merges
total time spent::total time spent
recursive of algorithms::recursive of algorithms
algorithms of procedure::algorithms of procedure
recursive in nature::recursive in nature
analyze their running::analyze their running
basically an equation::basically an equation
equation or inequality::equation or inequality
inequality that describes::inequality that describes
function in terms::function in terms
values at pervious::values at pervious
points at smaller::points at smaller
solve a problem::solve a problem
problem of size::problem of size
suppose i divide::suppose i divide
number of pieces::number of pieces
problem by sub::problem by sub
sub problem size::sub problem size
problem size factor::problem size factor
reduced the size::reduced the size
required to solve::required to solve
problems this part::problems this part
required that times::required that times
number of sub::number of sub
denote the recurrence::denote the recurrence
basically a trivial::basically a trivial
solve the trivial::solve the trivial
recurrence the initial::recurrence the initial
condition for instance::condition for instance
merge sort problem::merge sort problem
divided the problem::divided the problem
sort to merge::sort to merge
required to merge::required to merge
bunches of ways::bunches of ways
repeated substation method::repeated substation method
expand the recurrence::expand the recurrence
recurrence by substituting::recurrence by substituting
repeatedly and noticing::repeatedly and noticing
noticing any patters::noticing any patters
guess a solution::guess a solution
recurrence really satisfies::recurrence really satisfies
satisfies that guess::satisfies that guess
solving recurrence relations::solving recurrence relations
remember those formulas::remember those formulas
solve those recurrences::solve those recurrences
out a tree::out a tree
ease the analysis::ease the analysis
bit so recall::bit so recall
recall the recurrences::recall the recurrences
adopt repeated substitution::adopt repeated substitution
observe a pattern::observe a pattern
done this thing::done this thing
procedure everyone understands::procedure everyone understands
merge total number::merge total number
merge the number::merge the number
merge is theta::merge is theta
log n upper::log n upper
bounded and lower::bounded and lower
times now suppose::times now suppose
thinking this entire::thinking this entire
out a recursion::out a recursion
basically the num::basically the num
sum of numbers::sum of numbers
view this thing::view this thing
out this tree::out this tree
write the total::write the total
substation method substitute::substation method substitute
doing that observe::doing that observe
times you observe::times you observe
substitution and find::substitution and find
out a value::out a value
value the initial::value the initial
implementation of merge::implementation of merge
things are clear::things are clear
taking a comparator::taking a comparator
merge sorting integers::merge sorting integers
require the sort::require the sort
interface called sort::interface called sort
implementing a method::implementing a method
method called sort::method called sort
requires a sequence::requires a sequence
comparator why comparator::comparator why comparator
interested in sorting::interested in sorting
give you tow::give you tow
design a comparator::design a comparator
true or false::true or false
basically the merge::basically the merge
operation called insert::operation called insert
similarly we create::similarly we create
implemented your methods::implemented your methods
call sort sort::call sort sort
two sorted sequence::two sorted sequence
sequences are non-empty::sequences are non-empty
compare the first::compare the first
add the smaller::add the smaller
add the first::add the first
empty then depending::empty then depending
removing one element::removing one element
discussion on sorting::discussion on sorting
sorting we learnt::sorting we learnt
learnt what merge::learnt what merge
paradigm for sorting::paradigm for sorting
sorting is data::sorting is data
sort in place::sort in place
place sorting heap::place sorting heap
sorting heap sort::sorting heap sort
bubble sort bubble::bubble sort bubble
sort bubble sort::sort bubble sort
comparing the keys::comparing the keys
keys or people::keys or people
comparing two persons::comparing two persons
people but today::people but today
collection of keys::collection of keys
keys are represented::keys are represented
base m number::base m number
essentially in binary::essentially in binary
sorting is done::sorting is done
done by comparing::done by comparing
compare the bits::compare the bits
bit at position::bit at position
variants on radix::variants on radix
radix exchange sort::radix exchange sort
examine the bit::examine the bit
represented in binary::represented in binary
examine the bits::examine the bits
bits from left::bits from left
log n bits::log n bits
bits to represent::bits to represent
represent that largest::represent that largest
numbers in log::numbers in log
sort the array::sort the array
array with respect::array with respect
leftmost bit first::leftmost bit first
bit first suppose::bit first suppose
numbers are sitting::numbers are sitting
left most bit::left most bit
left most bits::left most bits
bit which means::bit which means
two different values::two different values
easy the zeros::easy the zeros
partition this array::partition this array
top sub array::top sub array
array and bottom::array and bottom
bottom sub array::bottom sub array
sort this top::sort this top
sort the top::sort the top
forget this bit::forget this bit
sorting these numbers::sorting these numbers
number or remove::number or remove
remove and subtract::remove and subtract
subtract some number::subtract some number
sorting the original::sorting the original
makes a difference::makes a difference
sort this bottom::sort this bottom
step is triviled::step is triviled
sub array ignoring::sub array ignoring
ignoring the leftmost::ignoring the leftmost
sort the bottom::sort the bottom
ignoring the left::ignoring the left
sort these n-bit::sort these n-bit
claim it takes::claim it takes
bits is log::bits is log
number the largest::number the largest
number of numbers::number of numbers
sir the number::sir the number
continue this discussion::continue this discussion
claim to sort::claim to sort
sort n b-bit::sort n b-bit
write a recurrence::write a recurrence
stretch and write::stretch and write
ignore the left::ignore the left
minus i numbers::minus i numbers
partition this numbers::partition this numbers
kind of recurrence::kind of recurrence
talked about solving::talked about solving
recurrences by guessing::recurrences by guessing
guessing a solution::guessing a solution
solution and substituting::solution and substituting
substituting that solution::substituting that solution
weather its true::weather its true
hand side equals::hand side equals
left hand side::left hand side
reference no harm::reference no harm
doing a randomized::doing a randomized
computing the expected::computing the expected
computing the average::computing the average
bit more cumbersome::bit more cumbersome
assume the maximum::assume the maximum
solve recurrence relations::solve recurrence relations
argument everyone understands::argument everyone understands
step we don::step we don
sorted this top::sorted this top
sorted this bottom::sorted this bottom
represent every number::represent every number
worry about negative::worry about negative
numbers and positive::numbers and positive
split the numbers::split the numbers
numbers into negatives::numbers into negatives
negatives and positives::negatives and positives
separately and put::separately and put
life more complicated::life more complicated
sort them separately::sort them separately
kind of partition::kind of partition
employed in quick::employed in quick
scan from top::scan from top
finding the first::finding the first
bit and swap::bit and swap
kind of technique::kind of technique
exchange these keys::exchange these keys
scan indices exchanged::scan indices exchanged
call it recursively::call it recursively
top to bottom::top to bottom
place we find::place we find
partitioning the numbers::partitioning the numbers
numbers whose value::numbers whose value
numbers with values::numbers with values
array i repeat::array i repeat
ignore the leftmost::ignore the leftmost
understand the algorithm::understand the algorithm
compared to quick::compared to quick
sort the sub::sort the sub
arrays so structure::arrays so structure
case of radix::case of radix
partitioning with respect::partitioning with respect
power b minus::power b minus
method of partitioning::method of partitioning
partitioning which makes::partitioning which makes
makes the difference::makes the difference
divide the array::divide the array
number is larger::number is larger
element the difference::element the difference
complexity for radix::complexity for radix
exchange we argued::exchange we argued
complexity is order::complexity is order
sort we argued::sort we argued
exchanging the elements::exchanging the elements
version of radix::version of radix
implementing radix sort::implementing radix sort
radix sort quick::radix sort quick
sort quick sort::sort quick sort
larger than log::larger than log
numbers of bits::numbers of bits
bits you require::bits you require
sorting is large::sorting is large
straight radix sort::straight radix sort
bits from right::bits from right
right to left::right to left
right most bit::right most bit
stable way sort::stable way sort
array in table::array in table
table way means::table way means
sort these numbers::sort these numbers
bit this corresponds::bit this corresponds
sorting them based::sorting them based
restrict your attention::restrict your attention
done some rearranging::done some rearranging
sorting with respect::sorting with respect
spending time proportional::spending time proportional
sorting their relative::sorting their relative
relative order remains::relative order remains
order remains unchanged::order remains unchanged
remains unchanged suppose::remains unchanged suppose
sorting this array::sorting this array
blue the first::blue the first
first was colored::first was colored
permitted to rearrange::permitted to rearrange
sort with respect::sort with respect
create this array::create this array
array post sorted::array post sorted
understands what table::understands what table
understand the correctness::understand the correctness
correct relative order::correct relative order
end that means::end that means
place they don::place they don
call this position::call this position
sorting this bunch::sorting this bunch
first the right::first the right
keys are put::keys are put
corrective relative order::corrective relative order
rearranged i don::rearranged i don
key would put::key would put
sort this key::sort this key
key and add::key and add
add sub sequent::add sub sequent
sub sequent steps::sub sequent steps
preserved the smaller::preserved the smaller
larger keys appearing::larger keys appearing
right now bigger::right now bigger
number is appearing::number is appearing
continue this relative::continue this relative
stable sorting ensures::stable sorting ensures
maintain the relative::maintain the relative
sort is stable::sort is stable
changed when bits::changed when bits
bits at position::bits at position
sacrosanct about binary::sacrosanct about binary
technique to decimal::technique to decimal
first i sort::first i sort
right most digit::right most digit
digit which means::digit which means
sorting is stable::sorting is stable
number of digits::number of digits
exchange radix sort::exchange radix sort
wanted to partition::wanted to partition
two way partition::two way partition
anymore for decimal::anymore for decimal
sorting the array::sorting the array
performed in order::performed in order
total time complexity::total time complexity
completely clear provided::completely clear provided
numbers are sorted::numbers are sorted
method of choice::method of choice
bucket sort algorithm::bucket sort algorithm
sort ? lots::sort ? lots
lots of buckets::lots of buckets
stable sorting algorithm::stable sorting algorithm
numbers with lots::numbers with lots
lots of duplicates::lots of duplicates
numbers are coming::numbers are coming
number and throw::number and throw
element of array::element of array
array is put::array is put
end is important::end is important
important to maintain::important to maintain
two and append::two and append
read the numbers::read the numbers
sorting you understand::sorting you understand
radix sort takes::radix sort takes
sort takes order::sort takes order
auxiliary data structures::auxiliary data structures
amount of additional::amount of additional
updates the input::updates the input
replaceelement and swap::replaceelement and swap
swaps two numbers::swaps two numbers
call the algorithm::call the algorithm
made to work::made to work
work in in-place::work in in-place
sort is heap::sort is heap
heap sort in-place::heap sort in-place
implement a heap::implement a heap
changing the elements::changing the elements
array merge sort::array merge sort
sort is merge::sort is merge
merge sort in-place::merge sort in-place
merge two list::merge two list
in-place quick sort::in-place quick sort
sort is in-place::sort is in-place
merge two lists::merge two lists
doing in merge::doing in merge
taking the first::taking the first
space would increase::space would increase
order one space::order one space
radix sort in-place::radix sort in-place
number of buckets::number of buckets
buckets is independent::buckets is independent
modify the scheme::modify the scheme
scheme to make::scheme to make
make it in-place::make it in-place
bucket just count::bucket just count
make radix sort::make radix sort
bound for comparison::bound for comparison
comparison base sorting::comparison base sorting
comparison based sorting::comparison based sorting
compare two numbers::compare two numbers
two numbers suppose::two numbers suppose
sort those elements::sort those elements
elements i give::elements i give
compare these objects::compare these objects
wanted to sort::wanted to sort
algorithm which takes::algorithm which takes
objects are sitting::objects are sitting
array the first::array the first
compare two elements::compare two elements
first it asks::first it asks
numbers to compare::numbers to compare
stop it doesn::stop it doesn
numbers this sequence::numbers this sequence
sequence of moves::sequence of moves
numbers we pick::numbers we pick
make certain comparison::make certain comparison
applies for randomization::applies for randomization
number in location::number in location
put a node::put a node
comparison it asked::comparison it asked
back and asked::back and asked
objects you don::objects you don
today i feel::today i feel
based on gpa::based on gpa
gpa then tomorrow::gpa then tomorrow
tomorrow i feel::tomorrow i feel
feel like relative::feel like relative
based on height::based on height
basically the length::basically the length
straight forward thing::straight forward thing
thing to understand::thing to understand
kinds of permutations::kinds of permutations
permutations every permutation::permutations every permutation
generate a permutation::generate a permutation
permutation should exist::permutation should exist
exist as leaves::exist as leaves
leaves that depends::leaves that depends
algorithm should end::algorithm should end
permutation and picked::permutation and picked
factorial so height::factorial so height
sir our order::sir our order
order to comparator::order to comparator
satisfy the symmetric::satisfy the symmetric
answer with respect::answer with respect
permutation all queries::permutation all queries
tree decision based::tree decision based
point the point::point the point
roughly n log::roughly n log
based sorting algorithm::based sorting algorithm
permitted to compare::permitted to compare
keys radix sort::keys radix sort
radix sort doesn::radix sort doesn
complexity n log::complexity n log
bits or digits::bits or digits
comparisons based sorting::comparisons based sorting
achieve that bound::achieve that bound
looked at bucket::looked at bucket
understood what stable::understood what stable
bound on comparison::bound on comparison
based sorting data::based sorting data
sorting data structures::sorting data structures
talking about graphs::talking about graphs
understanding the basic::understanding the basic
definition in terminologies::definition in terminologies
graph abstract data::graph abstract data
graph data type::graph data type
data type today::data type today
call the set::call the set
set of vertices::set of vertices
set of edges::set of edges
edges so set::edges so set
picture these red::picture these red
pair of vertices::pair of vertices
vertices an edge::vertices an edge
giving a pair::giving a pair
edge between vertices::edge between vertices
giving this drawing::giving this drawing
drawing or giving::drawing or giving
lots and lot::lots and lot
lot of applications::lot of applications
circuits as graphs::circuits as graphs
out the path::out the path
connecting to intersections::connecting to intersections
graph so transportation::graph so transportation
modeled as graphs::modeled as graphs
typically student day::typically student day
play cs201 programming::play cs201 programming
cs201 programming sleep::cs201 programming sleep
dream of cs201::dream of cs201
day before mine::day before mine
call directed graph::call directed graph
call such graphs::call such graphs
graphs directed graphs::graphs directed graphs
graphs whatever things::graphs whatever things
things i define::things i define
define will carry::define will carry
ordering is important::ordering is important
fairly simple lecture::fairly simple lecture
lots of terminologies::lots of terminologies
kinds of graphs::kinds of graphs
graphs a directed::graphs a directed
graph so graph::graph so graph
edges are adjacent::edges are adjacent
vertex the degree::vertex the degree
number of adjacent::number of adjacent
vertex is degree::vertex is degree
understands the degree::understands the degree
edge is incident::edge is incident
vertex is vertex::vertex is vertex
incident to vertices::incident to vertices
similarly this edge::similarly this edge
vertex so degree::vertex so degree
number of edges::number of edges
thing so question::thing so question
half a line::half a line
counting this edge::counting this edge
stones or pebbles::stones or pebbles
understand what degree::understand what degree
understand what adjacent::understand what adjacent
define the notion::define the notion
sequence of vertices::sequence of vertices
vertices are adjacent::vertices are adjacent
easy to construct::easy to construct
vertex is repeated::vertex is repeated
path a cycle::path a cycle
read the cycle::read the cycle
path because vertex::path because vertex
graph is connected::graph is connected
common mistake connected::common mistake connected
writing a minus::writing a minus
vertices are connected::vertices are connected
hand side suppose::hand side suppose
takes this edge::takes this edge
edge is running::edge is running
edge each edge::edge each edge
two end points::two end points
maximal connected graph::maximal connected graph
connected graph suppose::connected graph suppose
definition of connect::definition of connect
maximal connected sub::maximal connected sub
connected sub graph::connected sub graph
understood more carefully::understood more carefully
set while retaining::set while retaining
retaining the property::retaining the property
maximal with respect::maximal with respect
add more elements::add more elements
set and retain::set and retain
retain the property::retain the property
add more edges::add more edges
add more vertices::add more vertices
add this edge::add this edge
add this vertex::add this vertex
suppose i decided::suppose i decided
decided to add::decided to add
component as simple::component as simple
components more terminologies::components more terminologies
forest ? forest::forest ? forest
collection of trees::collection of trees
trees and animals::trees and animals
out the animals::out the animals
thinking of forest::thinking of forest
forest so forest::forest so forest
trees ? tree::trees ? tree
denote the number::denote the number
number of vertices::number of vertices
pairs of vertices::pairs of vertices
complete directed graph::complete directed graph
two times nc2::two times nc2
nc2 a directed::nc2 a directed
minimum elements connected::minimum elements connected
connected in graph::connected in graph
recall a tree::recall a tree
cycle so starting::cycle so starting
edges these vertices::edges these vertices
tree every vertex::tree every vertex
nodes we write::nodes we write
count the edges::count the edges
proof by induction::proof by induction
two so suppose::two so suppose
true so number::true so number
define a leaf::define a leaf
vertex of degree::vertex of degree
relating these vertices::relating these vertices
remove this edge::remove this edge
removing an edge::removing an edge
create a cycle::create a cycle
apply my induction::apply my induction
facts are critical::facts are critical
proof by contradiction::proof by contradiction
follow this argument::follow this argument
remove an edge::remove an edge
thing to remember::thing to remember
remove any edge::remove any edge
make the graph::make the graph
disconnected by doing::disconnected by doing
remove another edge::remove another edge
graph will remain::graph will remain
tree after removing::tree after removing
contradicting the earlier::contradicting the earlier
number of connected::number of connected
graph which means::graph which means
means the sub::means the sub
sub graph includes::sub graph includes
spanning tree suppose::spanning tree suppose
put the minimum::put the minimum
built a spanning::built a spanning
provide much fault::provide much fault
talk about bridges::talk about bridges
city in germany::city in germany
germany or austria::germany or austria
austria i don::austria i don
edges so question::edges so question
retrace the steps::retrace the steps
problem and euler::problem and euler
give a simple::give a simple
model this thing::model this thing
graph this island::graph this island
piece of land::piece of land
put two edges::put two edges
put one edge::put one edge
define a notion::define a notion
edges between pair::edges between pair
talked about pair::talked about pair
vertices the edges::vertices the edges
form a set::form a set
form a multi::form a multi
captures that problem::captures that problem
sets so eulerian::sets so eulerian
path that traverse::path that traverse
traverse every edge::traverse every edge
traverse each bridge::traverse each bridge
picture without lifting::picture without lifting
lifting your pencil::lifting your pencil
pencil or redrawing::pencil or redrawing
redrawing an edge::redrawing an edge
vertices of odd::vertices of odd
type the graph::type the graph
container of positions::container of positions
container like queues::container like queues
methods called size::methods called size
empty and elements::empty and elements
elements ; elements::elements ; elements
elements would return::elements would return
methods like swap::methods like swap
swap two positions::swap two positions
two positions replaceelement::two positions replaceelement
replaceelement those kind::replaceelement those kind
regular positional container::regular positional container
positional container swap::positional container swap
provide two positions::provide two positions
positions and swap::positions and swap
swap the contents::swap the contents
methods for positional::methods for positional
specific to graphs::specific to graphs
graphs so numvertices::graphs so numvertices
method which returns::method which returns
vertices numedges number::vertices numedges number
returns an iterator::returns an iterator
method next element::method next element
edges i call::edges i call
edge what order::edge what order
order this edge::order this edge
implemented the iterator::implemented the iterator
undirected edges incident::undirected edges incident
edges incident edges::edges incident edges
undirected graph incident::undirected graph incident
graph incident edges::graph incident edges
kinds of edges::kinds of edges
edges which start::edges which start
vertex which end::vertex which end
entering a vertexv::entering a vertexv
ending at vertex::ending at vertex
out incident edges::out incident edges
starting from vertex::starting from vertex
out of vertex::out of vertex
objects an edge::objects an edge
indegree so degree::indegree so degree
leaving the vertex::leaving the vertex
turns an iterator::turns an iterator
notion of inadjacent::notion of inadjacent
areadjacent whether vertices::areadjacent whether vertices
vertices two vertices::vertices two vertices
return a boolean::return a boolean
value ; endvertices::value ; endvertices
edge is starting::edge is starting
edge is ending::edge is ending
graphs some edges::graphs some edges
edges are directed::edges are directed
edges and roads::edges and roads
method which reverses::method which reverses
reverses the direction::reverses the direction
tonnes and tonnes::tonnes and tonnes
tonnes of update::tonnes of update
methods to create::methods to create
create the graph::create the graph
remove a vertex::remove a vertex
set the direction::set the direction
subset of method::subset of method
set of methods::set of methods
bunch of methods::bunch of methods
update and modify::update and modify
discussion on graphs::discussion on graphs
represent a graph::represent a graph
graph what kind::graph what kind
represent graphs data::represent graphs data
graphs data structures::graphs data structures
structures for graphs::structures for graphs
discussed various things::discussed various things
things about graphs::things about graphs
graphs various terms::graphs various terms
structures for representing::structures for representing
edge list data::edge list data
adjacency list data::adjacency list data
adjacency matrix data::adjacency matrix data
matrix data structure::matrix data structure
combined to give::combined to give
give better performances::give better performances
faster running times::faster running times
simplest data structure::simplest data structure
call an edge::call an edge
data structure suppose::data structure suppose
airports the blue::airports the blue
arcs are flight::arcs are flight
airport and suppose::airport and suppose
edges we call::edges we call
call each edge::call each edge
two such lists::two such lists
structure the edge::structure the edge
structure simply stores::structure simply stores
stores the vertices::stores the vertices
two unsorted sequences::two unsorted sequences
easy to implement::easy to implement
lists of vertices::lists of vertices
edges each edge::edges each edge
edge recall corresponds::edge recall corresponds
boston to jfk::boston to jfk
node has references::node has references
list data structures::list data structures
done very quickly::done very quickly
quickly for instance::quickly for instance
operation called opposite::operation called opposite
finding the adjacent::finding the adjacent
vertex i give::vertex i give
give you vertex::give you vertex
list of edges::list of edges
find out vertices::find out vertices
adjacent to dfw::adjacent to dfw
edge this edge::edge this edge
lax so lax::lax so lax
lax becomes adjacent::lax becomes adjacent
out the adjacent::out the adjacent
size for instance::size for instance
instance is constant::instance is constant
edges and vertices::edges and vertices
tool list isempty::tool list isempty
constant time number::constant time number
edges takes constant::edges takes constant
interesting thing suppose::interesting thing suppose
insert a vertex::insert a vertex
constant or order::constant or order
lists similarly insertedge::lists similarly insertedge
vertex this last::vertex this last
wanted to remove::wanted to remove
remove the edges::remove the edges
edges be referring::edges be referring
edges the list::edges the list
edges is order::edges is order
list to find::list to find
remove those edges::remove those edges
carefully and understand::carefully and understand
understand the times::understand the times
representing a graph::representing a graph
talking of today::talking of today
represent both directed::represent both directed
directed and undirected::directed and undirected
array of vertices::array of vertices
corresponds to vertex::corresponds to vertex
link list starting::link list starting
corresponded to location::corresponded to location
lists so adjacency::lists so adjacency
data structure require::data structure require
location the degree::location the degree
vertex the total::vertex the total
part is sum::part is sum
order of theta::order of theta
pros and cons::pros and cons
adjacency matrix implementation::adjacency matrix implementation
previous data structure::previous data structure
moving a vertex::moving a vertex
two vertices adjacent::two vertices adjacent
degree still degree::degree still degree
references of pointers::references of pointers
store more information::store more information
array typically indexed::array typically indexed
number your vertices::number your vertices
out adjacency list::out adjacency list
list of incoming::list of incoming
list of outgoing::list of outgoing
instance the operation::instance the operation
mechanism of storing::mechanism of storing
storing edge information::storing edge information
regard to vertices::regard to vertices
edges easily obtained::edges easily obtained
obtained what information::obtained what information
retrieve that information::retrieve that information
answer that question::answer that question
entire data structure::entire data structure
figure that out::figure that out
information very quickly::information very quickly
out the incident::out the incident
incident edges edges::incident edges edges
edges edges incident::edges edges incident
flight from dfw::flight from dfw
dfw to mia::dfw to mia
information it depends::information it depends
out adjacent vertices::out adjacent vertices
ways of organizing::ways of organizing
organizing a graph::organizing a graph
high level idea::high level idea
minimum of degree::minimum of degree
degree of worst::degree of worst
maximum but suppose::maximum but suppose
sense keep degree::sense keep degree
doing this operation::doing this operation
vertices third representation::vertices third representation
adjacency matrix representation::adjacency matrix representation
cross n matrix::cross n matrix
basically just binary::basically just binary
binary entries bits::binary entries bits
true that means::true that means
adding a vertex::adding a vertex
adjacency matrix structure::adjacency matrix structure
matrix structure augments::matrix structure augments
augments the edge::augments the edge
edge list structure::edge list structure
edge list recall::edge list recall
telling which row::telling which row
row they corresponds::row they corresponds
augmenting an array::augmenting an array
add new vertices::add new vertices
remove new vertices::remove new vertices
structure which implements::structure which implements
right data structure::right data structure
basically n square::basically n square
vertices to determine::vertices to determine
vertex to find::vertex to find
row or column::row or column
give you order::give you order
order n insertvertex::order n insertvertex
put down order::put down order
order n squared::order n squared
two dimensional array::two dimensional array
array and extend::array and extend
column you understand::column you understand
arrays are stored::arrays are stored
major or column::major or column
column major form::column major form
simple edge list::simple edge list
operations are critical::operations are critical
manner if space::manner if space
requires a lot::requires a lot
space it requires::space it requires
requires n squared::requires n squared
space the standard::space the standard
implement a graph::implement a graph
graph searching algorithms::graph searching algorithms
graph search algorithm::graph search algorithm
basically a mechanism::basically a mechanism
mechanism of visiting::mechanism of visiting
manner by systematic::manner by systematic
vertex a graph::vertex a graph
assuming adjacency list::assuming adjacency list
adjacency list algorithm::adjacency list algorithm
list algorithm implementation::list algorithm implementation
discussing graph searching::discussing graph searching
perform on graphs::perform on graphs
breadth first search::breadth first search
first search algorithm::first search algorithm
algorithm or bfs::algorithm or bfs
bfs for short::bfs for short
call a breadth::call a breadth
first search tree::first search tree
search on undirected::search on undirected
graph only today::graph only today
first search makes::first search makes
makes more sense::makes more sense
sense in undirected::sense in undirected
assigned a initial::assigned a initial
proceed in rounds::proceed in rounds
search the maze::search the maze
tide one end::tide one end
unroll the string::unroll the string
reach by unrolling::reach by unrolling
unrolling this string::unrolling this string
call the vertices::call the vertices
discussing the algorithm::discussing the algorithm
label will signify::label will signify
element the neighbours::element the neighbours
find its neighbours::find its neighbours
neighbours and put::neighbours and put
queue i color::queue i color
color it gray::color it gray
color of grey::color of grey
sense the grey::sense the grey
vertices are vertices::vertices are vertices
signifies that black::signifies that black
vertices and white::vertices and white
white means undiscovered::white means undiscovered
reached those vertices::reached those vertices
colored the vertex::colored the vertex
neighbors and put::neighbors and put
queue i assigned::queue i assigned
queue and color::queue and color
color them grey::color them grey
grey from white::grey from white
white i color::white i color
color gets colored::color gets colored
colored to black::colored to black
element gets inserted::element gets inserted
queue what label::queue what label
label of two::label of two
white and put::white and put
grey are sitting::grey are sitting
vertex is grey::vertex is grey
visited and removed::visited and removed
queue its black::queue its black
black everyone understands::black everyone understands
queue becomes empty::queue becomes empty
empty the procedure::empty the procedure
queue become empty::queue become empty
visiting the adjacent::visiting the adjacent
level one vertices::level one vertices
search as dividing::search as dividing
dividing your vertices::dividing your vertices
vertices or partitioning::vertices or partitioning
partitioning your set::partitioning your set
vertices into levels::vertices into levels
levels or sets::levels or sets
vertex at level::vertex at level
vertices at level::vertices at level
initially every vertex::initially every vertex
infinite which means::infinite which means
put any labels::put any labels
signifies the predecessor::signifies the predecessor
vertex the vertex::vertex the vertex
initializing all vertices::initializing all vertices
color the vertex::color the vertex
starting vertex grey::starting vertex grey
process this green::process this green
grey or black::grey or black
label we give::label we give
add the vertex::add the vertex
black to signify::black to signify
operations like breadth::operations like breadth
making the color::making the color
color ? color::color ? color
giving a color::giving a color
separate arrays indexed::separate arrays indexed
first search procedure::first search procedure
spending constant amount::spending constant amount
part ? constant::part ? constant
executed ? order::executed ? order
vertex v adjacent::vertex v adjacent
statements ? order::statements ? order
vertex and summed::vertex and summed
times the statement::times the statement
statement is executed::statement is executed
times is statement::times is statement
degree many times::degree many times
vertices so order::vertices so order
order m times::order m times
enqueue a vertex::enqueue a vertex
black you don::black you don
put a white::put a white
queue in fact::queue in fact
fact this statement::fact this statement
case the total::case the total
thing is order::thing is order
couple of properties::couple of properties
properties of bfs::properties of bfs
visited which means::visited which means
visit those vertices::visit those vertices
vertices the vertices::vertices the vertices
edge which gave::edge which gave
gave that vertex::gave that vertex
vertex its label::vertex its label
vpi every vertex::vpi every vertex
basically the set::basically the set
ignore the dotted::ignore the dotted
talking about note::talking about note
graph the predecessor::graph the predecessor
vertex was discovered::vertex was discovered
queue and looked::queue and looked
adjacent to vertices::adjacent to vertices
lines now form::lines now form
form a spanning::form a spanning
solid line entering::solid line entering
eventually i hit::eventually i hit
root basically starting::root basically starting
graph these solid::graph these solid
solid lines form::solid lines form
form a connected::form a connected
spanning tree recall::spanning tree recall
tree this spanning::tree this spanning
lines they form::lines they form
form the breadth::form the breadth
darkened the line::darkened the line
drawn the arrows::drawn the arrows
label this vertex::label this vertex
darkened these lines::darkened these lines
forms your spanning::forms your spanning
screen to show::screen to show
vertices in level::vertices in level
vertices of level::vertices of level
vertex in level::vertex in level
discovered this vertex::discovered this vertex
vertex and put::vertex and put
put it level::put it level
thing about structure::thing about structure
showing the tree::showing the tree
skip a level::skip a level
edge which skips::edge which skips
skips a level::skips a level
made a small::made a small
vertex was adjacent::vertex was adjacent
vertices were adjacent::vertices were adjacent
property of breadth::property of breadth
mind certain edges::mind certain edges
call them tree::call them tree
part of bfs::part of bfs
predecessor this vertex::predecessor this vertex
multiple edges leading::multiple edges leading
levels zeroth level::levels zeroth level
level this vertex::level this vertex
picked one arbitrarily::picked one arbitrarily
tree the bfs::tree the bfs
vertex why shortest::vertex why shortest
vertex of length::vertex of length
path of length::path of length
level which means::level which means
vertex is adjacent::vertex is adjacent
level number equal::level number equal
choosing the predecessor::choosing the predecessor
discussion on breadth::discussion on breadth
search for finding::search for finding
finding the connected::finding the connected
application of breadth::application of breadth
first search -connected::first search -connected
search -connected components::search -connected components
-connected components -bipartite::-connected components -bipartite
components -bipartite graphs::components -bipartite graphs
-bipartite graphs today::-bipartite graphs today
applications of breadth::applications of breadth
search to finding::search to finding
out the connected::out the connected
graph is bipartite::graph is bipartite
first search recall::first search recall
label these vertices::label these vertices
label every vertex::label every vertex
first connected component::first connected component
procedure which returns::procedure which returns
returns this labeling::returns this labeling
array called label::array called label
components that number::components that number
constant time determine::constant time determine
connected components question::connected components question
components your graph::components your graph
vertex are maintained::vertex are maintained
search the first::search the first
doing our breadth::doing our breadth
vertex and starting::vertex and starting
doing the breadth::doing the breadth
give each vertex::give each vertex
giving each vertex::giving each vertex
vertex a label::vertex a label
call this component::call this component
first search starting::first search starting
vertices and put::vertices and put
end up putting::end up putting
visiting these vertices::visiting these vertices
component number equal::component number equal
connected component number::connected component number
pick any vertex::pick any vertex
set then done::set then done
start a bfs::start a bfs
thought is required::thought is required
found the last::found the last
last root vertex::last root vertex
vertex and continue::vertex and continue
start a breadth::start a breadth
end up labeling::end up labeling
labeling certain vertices::labeling certain vertices
turning time equal::turning time equal
equal to order::equal to order
number is total::number is total
graph the graph::graph the graph
required for traversing::required for traversing
traversing this array::traversing this array
array to find::array to find
start our breadth::start our breadth
traverse this array::traverse this array
array ? order::array ? order
starting when searching::starting when searching
number of components::number of components
made one scan::made one scan
right time bound::right time bound
started breadth first::started breadth first
started my breadth::started my breadth
suppose i started::suppose i started
vertices these vertices::vertices these vertices
array and mark::array and mark
selecting the root::selecting the root
array and label::array and label
label that vertex::label that vertex
spending a constant::spending a constant
putting this vertex::putting this vertex
access this vertex::access this vertex
spend a constant::spend a constant
accessing this array::accessing this array
array and updating::array and updating
updating that information::updating that information
adjacency list representation::adjacency list representation
array and make::array and make
correspondence as numbers::correspondence as numbers
determine connected components::determine connected components
linear time algorithm::linear time algorithm
recall a graph::recall a graph
vertices and set::vertices and set
talking of undirected::talking of undirected
exist a partition::exist a partition
equals u union::equals u union
intersection w equals::intersection w equals
divide the set::divide the set
graph every edge::graph every edge
point that means::point that means
graphs actually model::graphs actually model
model a lot::model a lot
lot of things::lot of things
things one standard::things one standard
applicants to jobs::applicants to jobs
applicant is suitable::applicant is suitable
subset of jobs::subset of jobs
thing such graphs::thing such graphs
find a lot::find a lot
kinds of settings::kinds of settings
search will divide::search will divide
divide the graph::divide the graph
layers into levels::layers into levels
edges which jump::edges which jump
bipartite ? suppose::bipartite ? suppose
suppose these red::suppose these red
suppose all edges::suppose all edges
i.e no edge::i.e no edge
implies the graph::implies the graph
graph to simplify::graph to simplify
component is bipartite::component is bipartite
components is non-bipartite::components is non-bipartite
level the claim::level the claim
solved the problem::solved the problem
problem here suppose::problem here suppose
find an edge::find an edge
vertex you started::vertex you started
started this bfs::started this bfs
proof is correct::proof is correct
out another aspect::out another aspect
bipartite graphs suppose::bipartite graphs suppose
prove that fact::prove that fact
proved this fact::proved this fact
suppose the graph::suppose the graph
happen ? suppose::happen ? suppose
suppose this vertex::suppose this vertex
side ? suppose::side ? suppose
show the previous::show the previous
found an edge::found an edge
search to check::search to check
equivalent to checking::equivalent to checking
taking alternate levels::taking alternate levels
procedure to check::procedure to check
color we gave::color we gave
vertices were colored::vertices were colored
removed this vertex::removed this vertex
stop the procedure::stop the procedure
neighbor is white::neighbor is white
reboot the graph::reboot the graph
point is black::point is black
point being black::point being black
test for non::test for non
identify that edge::identify that edge
point i made::point i made
understand his question::understand his question
point ? depends::point ? depends
edge is grey::edge is grey
keeping level numbers::keeping level numbers
quantity is important::quantity is important
important that level::important that level
level number business::level number business
business is important::business is important
keeping the level::keeping the level
graph is non-bipartite::graph is non-bipartite
thing i wanted::thing i wanted
procedure is giving::procedure is giving
number of vertex::number of vertex
started a breadth::started a breadth
search from vertex::search from vertex
bunch of levels::bunch of levels
define what shortest::define what shortest
shortest path means::shortest path means
modify this definition::modify this definition
vertices the shortest::vertices the shortest
travel the minimum::travel the minimum
reflect the number::reflect the number
number of hops::number of hops
taking say suppose::taking say suppose
fast on link::fast on link
processed and forwarded::processed and forwarded
forwarded and stuff::forwarded and stuff
pick a path::pick a path
travels very quick::travels very quick
find the shortest::find the shortest
path the claim::path the claim
simple i start::simple i start
predecessor its predecessor::predecessor its predecessor
level you understand::level you understand
understand what predecessor::understand what predecessor
vertex which gave::vertex which gave
jump a level::jump a level
level which violates::level which violates
violates the fact::violates the fact
jumps a level::jumps a level
violates our breadth::violates our breadth
first search property::first search property
property that shows::property that shows
number would give::number would give
understood i give::understood i give
define the diameter::define the diameter
two vertices maximum::two vertices maximum
vertices maximum distance::vertices maximum distance
means ? distance::means ? distance
two vertices equals::two vertices equals
vertices equals length::vertices equals length
length of shortest::length of shortest
quantity to compute::quantity to compute
impossible to compute::impossible to compute
specifically defined maximum::specifically defined maximum
defined maximum distance::defined maximum distance
find the diameter::find the diameter
answer ? bfs::answer ? bfs
largest level number::largest level number
find the maximum::find the maximum
started my bfs::started my bfs
determining the diameter::determining the diameter
depth first search::depth first search
half the diameter::half the diameter
times the maximum::times the maximum
bfs you understand::bfs you understand
understand ? diameter::understand ? diameter
search you understand::search you understand
claim is diameter::claim is diameter
number and diameter::number and diameter
diameter is greater::diameter is greater
maximum level diameter::maximum level diameter
doing one bfs::doing one bfs
first search data::first search data
search data structures::search data structures
talking about depth::talking about depth
searching a graph::searching a graph
looked at breadth::looked at breadth
applications where depth::applications where depth
meaningful than breadth::meaningful than breadth
piece of cheese::piece of cheese
squares i put::squares i put
ends up doing::ends up doing
explore that path::explore that path
mouse has photogenic::mouse has photogenic
find its cheese::find its cheese
moved another step::moved another step
south and west::south and west
west and north::west and north
doubt about left::doubt about left
find the cheese::find the cheese
south and south::south and south
sides are blocked::sides are blocked
backtracks backtracks means::backtracks backtracks means
make any progress::make any progress
backtracks and backtrack::backtracks and backtrack
easy to find::easy to find
found the cheese::found the cheese
formalize this shortly::formalize this shortly
direction so direction::direction so direction
correspond to taking::correspond to taking
taking one edge::taking one edge
vertex and continuing::vertex and continuing
notion of goal::notion of goal
mechanism of exploring::mechanism of exploring
continuing our depth::continuing our depth
basically a method::basically a method
method of visiting::method of visiting
graph and show::graph and show
including some terminology::including some terminology
search is applicable::search is applicable
graphs so small::graphs so small
small simple graph::small simple graph
case of breadth::case of breadth
mouse we choose::mouse we choose
option going east::option going east
east then south::east then south
adjacency list implementation::adjacency list implementation
recall an adjacency::recall an adjacency
list of adjacent::list of adjacent
vertices the first::vertices the first
edge i considered::edge i considered
follow the procedure::follow the procedure
reach this vertex::reach this vertex
visited the vertices::visited the vertices
vertices i reach::vertices i reach
leave this vertex::leave this vertex
things are progressing::things are progressing
back ? backtrack::back ? backtrack
backtrack which means::backtrack which means
reach a vertex::reach a vertex
increment the counter::increment the counter
edge i decided::edge i decided
finished my visit::finished my visit
explored all options::explored all options
ready to backtrack::ready to backtrack
vertex i backtrack::vertex i backtrack
reached this vertex::reached this vertex
explored this possibility::explored this possibility
explored all possibilities::explored all possibilities
explored this edge::explored this edge
explore this edge::explore this edge
vertex each vertex::vertex each vertex
search any questions::search any questions
notion of black::notion of black
grey and white::grey and white
color a vertex::color a vertex
color it grey::color it grey
leave that node::leave that node
removed the node::removed the node
inserted the node::inserted the node
queue in breadth::queue in breadth
search i color::search i color
queue i put::queue i put
put its neighbors::put its neighbors
neighbors is white::neighbors is white
white i put::white i put
color that node::color that node
node is white::node is white
black or grey::black or grey
out the edges::out the edges
search with red::search with red
red i travel::red i travel
edges so number::edges so number
red edges equals::red edges equals
equals n minus::equals n minus
vertex these red::vertex these red
red edges form::red edges form
connected sub graphs::connected sub graphs
tree the red::tree the red
form a tree::form a tree
tree was defined::tree was defined
defined in terms::defined in terms
terms of predecessors::terms of predecessors
redraw this tree::redraw this tree
dfs tree edges::dfs tree edges
shown are meaningless::shown are meaningless
natural parent child::natural parent child
parent child relationship::parent child relationship
nodes the parent::nodes the parent
talk in terms::talk in terms
terms of parent::terms of parent
parent child siblings::parent child siblings
hanging the tree::hanging the tree
properties of depth::properties of depth
search these green::search these green
edges the green::edges the green
visited i don::visited i don
edge i backtrack::edge i backtrack
vertex already visited::vertex already visited
term back edge::term back edge
option i exhausted::option i exhausted
edges we don::edges we don
visited we don::visited we don
dotted red edge::dotted red edge
drawn a dotted::drawn a dotted
visited this vertex::visited this vertex
vertex was visited::vertex was visited
level in breadth::level in breadth
collection of levels::collection of levels
imp very important::imp very important
ancestors ? suppose::ancestors ? suppose
child of ancestor::child of ancestor
backtrack before backtracking::backtrack before backtracking
cover that vertex::cover that vertex
vertex that path::vertex that path
ready to define::ready to define
ancestor with respect::ancestor with respect
search with respect::search with respect
tree the notion::tree the notion
ancestor is coming::ancestor is coming
defined dfs tree::defined dfs tree
tree an edge::tree an edge
distinguish between tree::distinguish between tree
edges an ancestor::edges an ancestor
node an ancestor::node an ancestor
search basically means::search basically means
search you end::search you end
end up dividing::end up dividing
two classes tree::two classes tree
classes tree edges::classes tree edges
edge gets classified::edge gets classified
classifies every edge::classifies every edge
similar to breadth::similar to breadth
first search means::first search means
search means breadth::search means breadth
first search classifies::first search classifies
search in undirected::search in undirected
directed graphs things::directed graphs things
things will change::things will change
change a bit::change a bit
fairly complicated thing::fairly complicated thing
complicated thing stacks::complicated thing stacks
stacks or recursion::stacks or recursion
things we needed::things we needed
vertex is visited::vertex is visited
distinguish between grey::distinguish between grey
grey and black::grey and black
distinguish between white::distinguish between white
white and non-white::white and non-white
array called visited::array called visited
means not visited::means not visited
first search involve::first search involve
mark this vertex::mark this vertex
vertex as visited::vertex as visited
visited v equals::visited v equals
doffs dfs dfs::doffs dfs dfs
visited if visited::visited if visited
visited w equal::visited w equal
trivial to understand::trivial to understand
understand this part::understand this part
suited for depth::suited for depth
write three line::write three line
four line program::four line program
picture i started::picture i started
started a depth::started a depth
vertices were considered::vertices were considered
started my depth::started my depth
vertex since visited::vertex since visited
launched a depth::launched a depth
launched depth first::launched depth first
first search visits::first search visits
bunch of vertices::bunch of vertices
visited and marks::visited and marks
marks them visited::marks them visited
consequence this guy::consequence this guy
visit a bunch::visit a bunch
terminates ? dfs::terminates ? dfs
recursive call terminates::recursive call terminates
terminates we end::terminates we end
call to dfs::call to dfs
lot of recursive::lot of recursive
point it terminated::point it terminated
terminated we made::terminated we made
made a call::made a call
make a call::make a call
visited another bunch::visited another bunch
visited any vertex::visited any vertex
vertex whose visited::vertex whose visited
launch a dfs::launch a dfs
set to visited::set to visited
means the dfs::means the dfs
terminates the claim::terminates the claim
visited in dfs::visited in dfs
reachable from dfs::reachable from dfs
continued and visited::continued and visited
visited all vertices::visited all vertices
add my timestamps::add my timestamps
modify this procedure::modify this procedure
two other arrays::two other arrays
stamp and increment::stamp and increment
change the starting::change the starting
procedure to identify::procedure to identify
identify which edge::identify which edge
mark its edge::mark its edge
wanted this information::wanted this information
information every edge::information every edge
mark the tree::mark the tree
ready to launch::ready to launch
write that statement::write that statement
equivalent to identifying::equivalent to identifying
stop here today::stop here today
spend a couple::spend a couple
couple of classes::couple of classes
classes in applications::classes in applications
applications of depth::applications of depth
applications of dfs::applications of dfs
talking about applications::talking about applications
discussing the running::discussing the running
first search today::first search today
application of depth::application of depth
two edge connected::two edge connected
edge connected recall::edge connected recall
class we wrote::class we wrote
wrote a small::wrote a small
equals one lets::equals one lets
notion of children::notion of children
marks the node::marks the node
node as visited::node as visited
start the dfs::start the dfs
adjacent nodes provided::adjacent nodes provided
dfs v corresponds::dfs v corresponds
careful some careful::careful some careful
check the end::check the end
end is visited::end is visited
doing a total::doing a total
traverse this list::traverse this list
pointer which points::pointer which points
update the pointer::update the pointer
pointer to point::pointer to point
pointer becomes null::pointer becomes null
null or reference::null or reference
reference becomes null::reference becomes null
loop i advance::loop i advance
advance that reference::advance that reference
advance that pointer::advance that pointer
start a dfs::start a dfs
procedure the dfs::procedure the dfs
retrieve that pointer::retrieve that pointer
reached this pointer::reached this pointer
back from dfs::back from dfs
retrieving the fact::retrieving the fact
pointer was pointing::pointer was pointing
recursion the fact::recursion the fact
make a recursive::make a recursive
call i store::call i store
store the local::store the local
call this array::call this array
initially is pointing::initially is pointing
equal to null::equal to null
equals p dot::equals p dot
replace this line::replace this line
note that visited::note that visited
make this recursive::make this recursive
traversing this list::traversing this list
traversing the adjacency::traversing the adjacency
repeat any entry::repeat any entry
edge is visited::edge is visited
edge is looked::edge is looked
recursive call finishes::recursive call finishes
variable this local::variable this local
call was made::call was made
simulate the recursion::simulate the recursion
clear what variables::clear what variables
stack what information::stack what information
case of recursion::case of recursion
recursion two things::recursion two things
things are stored::things are stored
stored the parameters::stored the parameters
stack also stores::stack also stores
stores return address::stores return address
address and stuff::address and stuff
things you don::things you don
out the details::out the details
looked at dfs::looked at dfs
edges has tree::edges has tree
distinction between tree::distinction between tree
back edges suppose::back edges suppose
form a back::form a back
back edge suppose::back edge suppose
information i reached::information i reached
edge you reached::edge you reached
ancestor descendant relationship::ancestor descendant relationship
reach the descendant::reach the descendant
tree then first::tree then first
finished a descendant::finished a descendant
backtrack you finished::backtrack you finished
finished a node::finished a node
make the difference::make the difference
difference ? suppose::difference ? suppose
search to determine::search to determine
write down connected::write down connected
vertices and capital::vertices and capital
minus e means::minus e means
remove the edge::remove the edge
connected in words::connected in words
words a graph::words a graph
edge a graph::edge a graph
graph two edge::graph two edge
edge whose removal::edge whose removal
disconnects the graph::disconnects the graph
bridge this edge::bridge this edge
bridge this graph::bridge this graph
two edge connectivity::two edge connectivity
connected to begin::connected to begin
matter which link::matter which link
fails your network::fails your network
link can call::link can call
call the network::call the network
network to break::network to break
basically measuring liability::basically measuring liability
sir each vertex::sir each vertex
find a cycle::find a cycle
check this property::check this property
sir by bfs::sir by bfs
graph remains connected::graph remains connected
remove it check::remove it check
order m square::order m square
square by removing::square by removing
removing every edge::removing every edge
edge and checking::edge and checking
checking if resulting::checking if resulting
cycle two edge::cycle two edge
edge connected graph::edge connected graph
edge that means::edge that means
path of traversal::path of traversal
first search suppose::first search suppose
tree i obtain::tree i obtain
explored this entire::explored this entire
remove one edge::remove one edge
pieces by removing::pieces by removing
edge i create::edge i create
pieces are connected::pieces are connected
taking this green::taking this green
node i wanted::node i wanted
means every pair::means every pair
pair of node::pair of node
node is connected::node is connected
connected which means::connected which means
thing is connected::thing is connected
removed this red::removed this red
edge this red::edge this red
edge is present::edge is present
check everyone understands::check everyone understands
words when backtracking::words when backtracking
descendent so descendent::descendent so descendent
includes the node::includes the node
ancestor which means::ancestor which means
edge that node::edge that node
back edges starting::back edges starting
spending a lot::spending a lot
deepest back edge::deepest back edge
build this information::build this information
out the deepest::out the deepest
tree ? suppose::tree ? suppose
done this information::done this information
figured this information::figured this information
run the dfs::run the dfs
end up running::end up running
suppose i figured::suppose i figured
compute the deepest::compute the deepest
compute that compare::compute that compare
smallest possible arrival::smallest possible arrival
write our dfs::write our dfs
edge connectivity procedure::edge connectivity procedure
call the dfs::call the dfs
connectivity procedure eventually::connectivity procedure eventually
procedure eventually recall::procedure eventually recall
maintain my arrival::maintain my arrival
arrival counter suitably::arrival counter suitably
updating this variable::updating this variable
smaller than dbe::smaller than dbe
dbe equal minimum::dbe equal minimum
minimum of dbe::minimum of dbe
node is visited::node is visited
write that minimum::write that minimum
thing again minimum::thing again minimum
dbe equals minimum::dbe equals minimum
running a arrival::running a arrival
continue if dbe::continue if dbe
dbe equals arrival::dbe equals arrival
stop your procedure::stop your procedure
found a bridge::found a bridge
equal to greater::equal to greater
explain else part::explain else part
back edge starting::back edge starting
track of deepest::track of deepest
deepest by arrival::deepest by arrival
verses the arrival::verses the arrival
vertex with arrival::vertex with arrival
marked this edge::marked this edge
two minor things::two minor things
important your procedure::important your procedure
built on top::built on top
top of dfs::top of dfs
solved in liner::solved in liner
couple of minutes::couple of minutes
done a discrete::done a discrete
intersect now suppose::intersect now suppose
vertices i told::vertices i told
graph is complete::graph is complete
drew the initial::drew the initial
graph a planar::graph a planar
graph this problem::graph this problem
solved using depth::solved using depth
algorithm which runs::algorithm which runs
runs in linear::runs in linear
algorithm to check::algorithm to check
graph is planar::graph is planar
non planar graph::non planar graph
shown you learn::shown you learn
non planar graphs::non planar graphs
defined two edge::defined two edge
define two vertex::define two vertex
two vertex connectivity::two vertex connectivity
connectivity just replace::connectivity just replace
replace the edge::replace the edge
two vertex connected::two vertex connected
removing any vertex::removing any vertex
connected this corresponds::connected this corresponds
corresponds to computer::corresponds to computer
matter which computer::matter which computer
vertex connected graph::vertex connected graph
graph for instance::graph for instance
remove this vertex::remove this vertex
graph this graph::graph this graph
checked by depth::checked by depth
search in linear::search in linear
notion is cut::notion is cut
application that depth::application that depth
briefly two examples::briefly two examples
graph and checking::graph and checking
search in directed::search in directed
undirected graphs data::undirected graphs data
dfs in directed::dfs in directed
directed graphs today::directed graphs today
last two classes::last two classes
looked at depth::looked at depth
directed graphs differ::directed graphs differ
differ from depth::differ from depth
put this edge::put this edge
back here suppose::back here suppose
vertex the process::vertex the process
code for depth::code for depth
search would remain::search would remain
benefit so depth::benefit so depth
quote for depth::quote for depth
thing adjacent means::thing adjacent means
adjacent to vertex::adjacent to vertex
term out adjacent::term out adjacent
call this vertex::call this vertex
talk of adjacent::talk of adjacent
edge going out::edge going out
finished the procedure::finished the procedure
give the arrival::give the arrival
arrival and departure::arrival and departure
modify this graph::modify this graph
graph a bit::graph a bit
change the direction::change the direction
visit all vertices::visit all vertices
connected for instance::connected for instance
search you started::search you started
started the breadth::started the breadth
components similarly depth::components similarly depth
similarly depth first::similarly depth first
graph would visit::graph would visit
search would visit::search would visit
vertex this vertex::vertex this vertex
visited and started::visited and started
started out breadth::started out breadth
finish our depth::finish our depth
pick that vertex::pick that vertex
visited and continue::visited and continue
continue our depth::continue our depth
pick this vertex::pick this vertex
finish this depth::finish this depth
manner every vertex::manner every vertex
redraw the tree::redraw the tree
depth first breadth::depth first breadth
breadth and depth::breadth and depth
first search require::first search require
visit every vertex::visit every vertex
graph was connected::graph was connected
visited a bunch::visited a bunch
visited and start::visited and start
start a depth::start a depth
traverse the visited::traverse the visited
make one scan::make one scan
draw the back::draw the back
understand what kinds::understand what kinds
make them darker::make them darker
find in dash::find in dash
dash dash dotted::dash dash dotted
noise every day::noise every day
day you pen::day you pen
realizing its blue::realizing its blue
red light red::red light red
sir sketch pen::sir sketch pen
sketch pen sir::sketch pen sir
watching this program::watching this program
case of undirected::case of undirected
categories either tree::categories either tree
suppose this edge::suppose this edge
continuing to follow::continuing to follow
follow this path::follow this path
point is visited::point is visited
classify these edges::classify these edges
give them names::give them names
names our green::names our green
call that forward::call that forward
forward the brown::forward the brown
term backward edge::term backward edge
edge the red::edge the red
edges the brown::edges the brown
clear tree edge::clear tree edge
single ten vertex::single ten vertex
edge so cross::edge so cross
visiting the left::visiting the left
left the cross::left the cross
higher to lower::higher to lower
left this cross::left this cross
makes an edge::makes an edge
edge of forward::edge of forward
relate its arrival::relate its arrival
verses the departure::verses the departure
edge so arrival::edge so arrival
verses of arrival::verses of arrival
departure ? departure::departure ? departure
reached here arrival::reached here arrival
managed to create::managed to create
create a mess::create a mess
first i reach::first i reach
arrival and departures::arrival and departures
departures are arranged::departures are arranged
cross edge great::cross edge great
search the edges::search the edges
edges get classified::edges get classified
categories and based::categories and based
create the tree::create the tree
identify the parent::identify the parent
ancestors descendant relationships::ancestors descendant relationships
out these things::out these things
graph g check::graph g check
basically a path::basically a path
path which closes::path which closes
access the starting::access the starting
tree a tree::tree a tree
form a cycle::form a cycle
edge are connected::edge are connected
encounter a back::encounter a back
forms the cycle::forms the cycle
vertex i start::vertex i start
retrace my path::retrace my path
find a back::find a back
cycle the child::cycle the child
child is traversed::child is traversed
origin of cross::origin of cross
question so statement::question so statement
means no cycle::means no cycle
cycle no back::cycle no back
graph a cycle::graph a cycle
means a path::means a path
streets a cycle::streets a cycle
reach the starting::reach the starting
starting point great::starting point great
back edge means::back edge means
order the vertices::order the vertices
largest departure times::largest departure times
times are decreasing::times are decreasing
edge the edge::edge the edge
edge its tail::edge its tail
right a forward::right a forward
edge the departure::edge the departure
edge then departure::edge then departure
coming from right::coming from right
worrying about departure::worrying about departure
simple proof theorem::simple proof theorem
point you encounter::point you encounter
finish your depth::finish your depth
search without encountering::search without encountering
encountering a single::encountering a single
single back edge::single back edge
declare the graph::declare the graph
graph is acyclic::graph is acyclic
graph we started::graph we started
encounter any back::encounter any back
decreasing departure times::decreasing departure times
right this ordering::right this ordering
find a topological::find a topological
produce an ordering::produce an ordering
array i put::array i put
algorithm which performs::algorithm which performs
computed in order::computed in order
talking of directed::talking of directed
directed acyclic graph::directed acyclic graph
bit in circuits::bit in circuits
kind of graphs::kind of graphs
regular directed graph::regular directed graph
application of dfs::application of dfs
develop the terminology::develop the terminology
undirected graph connected::undirected graph connected
connected so connected::connected so connected
connected a directed::connected a directed
term ordered pair::term ordered pair
graph strongly connected::graph strongly connected
path still pardon::path still pardon
pairs and check::pairs and check
strongly connected component::strongly connected component
vertices any pair::vertices any pair
pair i choose::pair i choose
choose is connected::choose is connected
part of cycle::part of cycle
daily weakly connected::daily weakly connected
weakly connected graph::weakly connected graph
ignore the directions::ignore the directions
strongly connected graph::strongly connected graph
doing a dfs::doing a dfs
strongly connected means::strongly connected means
require something similar::require something similar
engineering iit delhi::engineering iit delhi
iit delhi lecture::iit delhi lecture
directed graphs recall::directed graphs recall
talk about strong::talk about strong
strong connectivity means::strong connectivity means
two vertices lets::two vertices lets
call the graph::call the graph
number of dfs::number of dfs
making n dfs::making n dfs
graph if dfs::graph if dfs
dfs v visits::dfs v visits
visits all vertices::visits all vertices
vertices in graph::vertices in graph
exists a path::exists a path
claim there exists::claim there exists
find a path::find a path
exist a path::exist a path
lower most vertex::lower most vertex
ending first starting::ending first starting
vertices are visited::vertices are visited
vertex gets visited::vertex gets visited
vertex which means::vertex which means
change the function::change the function
out adjacency edges::out adjacency edges
reverse the graph::reverse the graph
understands the procedure::understands the procedure
procedure is pick::procedure is pick
pick an arbitrary::pick an arbitrary
learn the properties::learn the properties
properties of dfs::properties of dfs
perfectly fine algorithm::perfectly fine algorithm
requires two dfs::requires two dfs
gammon of definitions::gammon of definitions
definitions and terminologies::definitions and terminologies
edges which form::edges which form
form the dfs::form the dfs
lets say backtracking::lets say backtracking
similar such thing::similar such thing
case of strong::case of strong
kind of edges::kind of edges
enter the sub::enter the sub
root for instance::root for instance
instance to vertex::instance to vertex
stop the process::stop the process
stop our dfs::stop our dfs
check this thing::check this thing
modification to make::modification to make
tree the check::tree the check
reach every vertex::reach every vertex
suppose this node::suppose this node
reach a node::reach a node
descendant this node::descendant this node
strictly smaller arrival::strictly smaller arrival
requirement to check::requirement to check
check this requirement::check this requirement
sub word sub::sub word sub
word sub tree::word sub tree
tree a bit::tree a bit
calling a sub::calling a sub
tree the generic::tree the generic
edge the arrival::edge the arrival
smallest such arrival::smallest such arrival
return the deepest::return the deepest
dfs would return::dfs would return
returns the smallest::returns the smallest
dfs v returns::dfs v returns
tree and edge::tree and edge
cross edge forward::cross edge forward
edge forward edge::edge forward edge
four arrival times::four arrival times
quantity the dfs::quantity the dfs
return this thing::return this thing
note that dfs::note that dfs
dfs from vertex::dfs from vertex
end up doing::end up doing
value of dfs::value of dfs
out the edge::out the edge
write the code::write the code
declare some variable::declare some variable
variable ? xyz::variable ? xyz
call it xyz::call it xyz
value of xyz::value of xyz
harm in setting::harm in setting
means out adjacent::means out adjacent
dfs i set::dfs i set
set the visited::set the visited
run this procedure::run this procedure
returns so xyz::returns so xyz
xyz equals minimum::xyz equals minimum
minimum of xyz::minimum of xyz
xyz equal min::xyz equal min
min of xyz::min of xyz
loop if xyz::loop if xyz
xyz equals arrival::xyz equals arrival
vertex this quantity::vertex this quantity
quantity will turn::quantity will turn
dfs are concerned::dfs are concerned
directed graphs checking::directed graphs checking
class any questions::class any questions
done for undirected::done for undirected
graph is vertex::graph is vertex
applications in detail::applications in detail
class what application::class what application
search ? finding::search ? finding
linear time procedures::linear time procedures
procedures data structures::procedures data structures
talking about minimum::talking about minimum
minimum spanning trees::minimum spanning trees
minimum spanning tree::minimum spanning tree
algorithms of minimum::algorithms of minimum
term is composed::term is composed
two things tree::two things tree
tree and panning::tree and panning
tree ? tree::tree ? tree
cycles connected sub::cycles connected sub
graph without cycles::graph without cycles
include all vertices::include all vertices
drew a graph::drew a graph
draw a spanning::draw a spanning
pick this edge::pick this edge
edges ? number::edges ? number
tree ? minimum::tree ? minimum
tree of minimum::tree of minimum
assume the lengths::assume the lengths
lengths are non-negative::lengths are non-negative
wires some options::wires some options
length function suppose::length function suppose
connect these cities::connect these cities
cities which means::cities which means
create a spanning::create a spanning
interested in spanning::interested in spanning
length of wire::length of wire
wire is spent::wire is spent
spent as small::spent as small
spanning tree equals::spanning tree equals
tree equals sum::tree equals sum
decide to pick::decide to pick
pick some edges::pick some edges
give this length::give this length
case of spanning::case of spanning
tree is trees::tree is trees
trees in graph::trees in graph
term free tree::term free tree
edges we included::edges we included
smallest possible tree::smallest possible tree
include this edge::include this edge
means it form::means it form
suppose the edges::suppose the edges
edge and drop::edge and drop
drop the edge::drop the edge
edge of length::edge of length
drop this edge::drop this edge
remain a tree::remain a tree
create alternate path::create alternate path
face of vertices::face of vertices
add an edge::add an edge
drop and edge::drop and edge
edge of longer::edge of longer
edge i added::edge i added
reduced the cost::reduced the cost
length or weight::length or weight
drop any edge::drop any edge
tree has length::tree has length
form the cycle::form the cycle
edges of length::edges of length
sense to drop::sense to drop
draw the tree::draw the tree
sense to include::sense to include
mst has length::mst has length
include an edge::include an edge
drop an edge::drop an edge
drop that edge::drop that edge
reduce the cost::reduce the cost
reduce it anymore::reduce it anymore
analyse this algorithm::analyse this algorithm
terms of running::terms of running
algorithm for computing::algorithm for computing
tree and algorithm::tree and algorithm
algorithm in minimum::algorithm in minimum
draw this graph::draw this graph
greedy to compute::greedy to compute
compute the minimum::compute the minimum
key thing make::key thing make
write without thinking::write without thinking
minimize the length::minimize the length
pick the edge::pick the edge
building the minimum::building the minimum
edge by edge::edge by edge
edge i included::edge i included
included the edge::included the edge
choice to make::choice to make
including an edge::including an edge
include that edge::include that edge
easy to write::easy to write
step is sort::step is sort
edges in increasing::edges in increasing
order of length::order of length
length of edge::length of edge
define some spanning::define some spanning
edges in type::edges in type
including a vertex::including a vertex
include the vertex::include the vertex
dictate the running::dictate the running
log m algorithm::log m algorithm
impure the tree::impure the tree
forms a cycle::forms a cycle
formalize this equation::formalize this equation
write your proofs::write your proofs
edges of kruskal::edges of kruskal
picked by kruskal::picked by kruskal
call those edges::call those edges
give those edges::give those edges
edge in kruskal::edge in kruskal
lengths are distinct::lengths are distinct
non distinct case::non distinct case
edges that kruskal::edges that kruskal
tree by optimum::tree by optimum
sets of edges::sets of edges
found from kruskal::found from kruskal
place they differ::place they differ
point of difference::point of difference
cycle ? add::cycle ? add
formed this cycle::formed this cycle
edges had length::edges had length
edge has length::edge has length
set is identical::set is identical
line of argument::line of argument
talking of case::talking of case
distinct from g1to::distinct from g1to
g1to gi minus::g1to gi minus
kruskal not pick::kruskal not pick
edges is identical::edges is identical
implies optimum tree::implies optimum tree
spanning tree unique::spanning tree unique
lengths are unique::lengths are unique
unique or distinct::unique or distinct
unique minimum spanning::unique minimum spanning
proved the correctness::proved the correctness
correctness of kruskal::correctness of kruskal
cycle in formed::cycle in formed
cycle is formed::cycle is formed
cycle be formed::cycle be formed
connected component connected::connected component connected
component connected component::component connected component
component or component::component or component
maintain the collection::maintain the collection
collection of components::collection of components
components so note::components so note
edges i pick::edges i pick
number of trees::number of trees
prove very easily::prove very easily
connected components reduces::connected components reduces
edge we include::edge we include
maintain the connected::maintain the connected
sets of vertices::sets of vertices
give these vertices::give these vertices
vertices the sets::vertices the sets
component they form::component they form
form a partition::form a partition
continue the discussion::continue the discussion
computing minimum spanning::computing minimum spanning
collection of connected::collection of connected
union fine data::union fine data
algorithm was considered::algorithm was considered
picked a set::picked a set
form a forest::form a forest
picked in krukal::picked in krukal
edge being added::edge being added
edge would form::edge would form
end points lie::end points lie
forest the tree::forest the tree
suffices to check::suffices to check
maintain our collection::maintain our collection
connected component reduces::connected component reduces
abstract this problem::abstract this problem
out and capture::out and capture
problem on maintaining::problem on maintaining
maintaining a collection::maintaining a collection
collection of disjoint::collection of disjoint
universe of elements::universe of elements
collection of disjoints::collection of disjoints
maintain a collection::maintain a collection
case of kruskal::case of kruskal
operation is union::operation is union
operation of union::operation of union
taking the union::taking the union
maintain this collection::maintain this collection
edge and determine::edge and determine
line same set::line same set
takes as parameters::takes as parameters
description of find::description of find
returning the sets::returning the sets
returns the set::returns the set
collection of sets::collection of sets
partition of universe::partition of universe
return that set::return that set
implement this operation::implement this operation
forming a cycle::forming a cycle
write down kruskal::write down kruskal
steps of kruskal::steps of kruskal
step ? sort::step ? sort
sort the edges::sort the edges
corresponds to edges::corresponds to edges
pick an edge::pick an edge
find u equals::find u equals
equal if find::equal if find
equal to find::equal to find
initialised to null::initialised to null
initialize this collection::initialize this collection
create this collection::create this collection
maintaining the collection::maintaining the collection
operation ? number::operation ? number
number of unions::number of unions
number of finds::number of finds
moment you form::moment you form
takes u times::takes u times
out a good::out a good
good data structure::good data structure
structure by good::structure by good
suggest a data::suggest a data
sets ? linked::sets ? linked
number of sets::number of sets
complete this first::complete this first
lists in constant::lists in constant
constant time union::constant time union
large as log::large as log
good at data::good at data
tree ? heap::tree ? heap
heaps ? order::heaps ? order
show this thing::show this thing
head the root::head the root
point is null::point is null
set whose root::set whose root
represent a set::represent a set
set is represented::set is represented
elect a leader::elect a leader
element a lies::element a lies
find b returns::find b returns
takes the root::takes the root
trees and links::trees and links
decide to make::decide to make
make b point::make b point
return a reference::return a reference
taking the roots::taking the roots
roots and merging::roots and merging
find d find::find d find
make d point::make d point
find a return::find a return
returns a pointer::returns a pointer
make c point::make c point
make e point::make e point
tracing the pointers::tracing the pointers
hits the roots::hits the roots
list of vertices::list of vertices
access the state::access the state
references of root::references of root
reference to point::reference to point
union takes order::union takes order
takes ? find::takes ? find
ways to reach::ways to reach
construct a sequence::construct a sequence
sequence of unions::sequence of unions
happen ? write::happen ? write
first to merge::first to merge
doing the union::doing the union
clever manner find::clever manner find
manner so recall::manner so recall
rule called union::rule called union
union by rank::union by rank
trees and suppose::trees and suppose
make the lighter::make the lighter
lighter tree point::lighter tree point
loss of generality::loss of generality
make this point::make this point
elements ; first::elements ; first
first you made::first you made
made this point::made this point
make this guy::make this guy
case how high::case how high
high the tree::high the tree
construct the worst::construct the worst
rule of union::rule of union
rank will lead::rank will lead
lead to trees::lead to trees
minimum a tree::minimum a tree
equal to log::equal to log
set any point::set any point
nodes without loss::nodes without loss
hypothesis is true::hypothesis is true
procedure that means::procedure that means
height of resulting::height of resulting
equal to max::equal to max
lesser or equal::lesser or equal
equal to number::equal to number
hypothesis this height::hypothesis this height
define the tree::define the tree
doing in induction::doing in induction
tree with larger::tree with larger
rank rank meaning::rank rank meaning
union by height::union by height
make the shallow::make the shallow
shallow tree point::shallow tree point
place a log::place a log
log in bound::log in bound
height h2 max::height h2 max
tree ? equals::tree ? equals
quantity is greater::quantity is greater
nodes is grater::nodes is grater
node the log::node the log
takes ? constant::takes ? constant
difficult to maintain::difficult to maintain
value is updated::value is updated
maintain the height::maintain the height
maintaining the number::maintaining the number
add this quantity::add this quantity
update this variable::update this variable
graph ? log::graph ? log
improving the union::improving the union
union find data::union find data
find data structure::find data structure
required for find::required for find
technique called path::technique called path
compression whose analysis::compression whose analysis
doing a find::doing a find
performance of future::performance of future
find this node::find this node
make this parent::make this parent
guys become closer::guys become closer
put a dot::put a dot
put a cross::put a cross
continue to hang::continue to hang
bringing the nodes::bringing the nodes
reducing the height::reducing the height
reduces the number::reduces the number
union procedure requires::union procedure requires
procedure requires height::procedure requires height
height the root::height the root
tree will point::tree will point
change this pointer::change this pointer
opting this procedure::opting this procedure
work with height::work with height
changing the height::changing the height
tree by doing::tree by doing
hard to recompute::hard to recompute
tree in constant::tree in constant
union by number::union by number
tree has lesser::tree has lesser
nodes the tree::nodes the tree
tree with lesser::tree with lesser
made to point::made to point
doing in path::doing in path
traverse this link::traverse this link
make future easier::make future easier
future finds easier::future finds easier
make another pass::make another pass
change the pointers::change the pointers
doing the find::doing the find
path to update::path to update
change the pointed::change the pointed
picture and decide::picture and decide
point in changing::point in changing
keeping the node::keeping the node
create the union::create the union
kind of cross::kind of cross
adjutancy list data::adjutancy list data
follow that reference::follow that reference
reference and find::reference and find
out which connected::out which connected
component that vertex::component that vertex
discuss another algorithm::discuss another algorithm
operations of union::operations of union
modifying the sets::modifying the sets
sets or modifying::sets or modifying
modifying the collection::modifying the collection
set it belongs::set it belongs
needed this data::needed this data
implement the kruskal::implement the kruskal
algorithm we looked::algorithm we looked
computing a minimum::computing a minimum
greedy algorithm today::greedy algorithm today
due to prim::due to prim
graph a spanning::graph a spanning
tree is defined::tree is defined
cut in graph::cut in graph
splitting would define::splitting would define
define a cut::define a cut
examples of cuts::examples of cuts
power n minus::power n minus
repeating each possibility::repeating each possibility
possibility is repeated::possibility is repeated
partition of vertex::partition of vertex
cut or edges::cut or edges
understand which edges::understand which edges
denote other point::denote other point
edge is length::edge is length
simplify my arguments::simplify my arguments
simplify my presentation::simplify my presentation
assume edge lengths::assume edge lengths
make a tree::make a tree
tree or part::tree or part
edges are part::edges are part
choose my edge::choose my edge
part of minimum::part of minimum
cut will belong::cut will belong
mst is short::mst is short
short for minimum::short for minimum
happen ? cycle::happen ? cycle
vertex any path::vertex any path
edges which means::edges which means
edges has length::edges has length
reduce the length::reduce the length
cycle got formed::cycle got formed
created the cycle::created the cycle
edge whose length::edge whose length
length is larger::length is larger
removing this edge::removing this edge
remain a spanning::remain a spanning
removing any thing::removing any thing
proving a structural::proving a structural
cut the minimum::cut the minimum
remove any thing::remove any thing
proving this statement::proving this statement
cycle has length::cycle has length
exploits this simple::exploits this simple
essentially is built::essentially is built
give every edge::give every edge
put down edge::put down edge
length of length1::length of length1
included everyone understands::included everyone understands
done the proof::done the proof
proved this claim::proved this claim
assumed edge lengths::assumed edge lengths
run the kruskal::run the kruskal
works very simple::works very simple
implement this algorithm::implement this algorithm
step ? add::step ? add
add a vertex::add a vertex
call this set::call this set
collection of vertices::collection of vertices
easily by keeping::easily by keeping
edges and find::edges and find
maintain a minimum::maintain a minimum
single this vertex::single this vertex
figure out minimum::figure out minimum
knowing the minimum::knowing the minimum
out the minimum::out the minimum
earlier the minimum::earlier the minimum
heap ? min::heap ? min
put some elements::put some elements
operation called delete::operation called delete
heap in constant::heap in constant
find min takes::find min takes
min takes constant::min takes constant
point of vertex::point of vertex
vertex the edges::vertex the edges
vertex to vertices::vertex to vertices
bad data structure::bad data structure
structure for searching::structure for searching
put some information::put some information
harm in deleting::harm in deleting
show this delete::show this delete
heap in log::heap in log
edges and noting::edges and noting
operation are required::operation are required
removed these edges::removed these edges
added each remove::added each remove
remove and add::remove and add
add takes log::add takes log
spending ? degree::spending ? degree
degree times log::degree times log
processes each vertex::processes each vertex
log m number::log m number
min ? number::min ? number
elements of initial::elements of initial
vertex to include::vertex to include
cut not visited::cut not visited
pick a vertex::pick a vertex
vertex root equals::vertex root equals
insert the edges::insert the edges
insert the edge::insert the edge
edge h dot::edge h dot
dot find min::dot find min
find min equals::find min equals
return in edge::return in edge
find the end::find the end
edge dot insert::edge dot insert
execute this loop::execute this loop
executed n minus::executed n minus
vertices or edges::vertices or edges
set s complement::set s complement
complement each vertex::complement each vertex
suppose these edge::suppose these edge
heap of vertices::heap of vertices
minimum edge incident::minimum edge incident
find the vertex::find the vertex
call this labels::call this labels
track of edges::track of edges
update or decrease::update or decrease
decrease the label::decrease the label
decrease priority decrease::decrease priority decrease
priority decrease priority::priority decrease priority
delete find min::delete find min
update its priority::update its priority
greater than length::greater than length
label w equals::label w equals
dot decease priority::dot decease priority
running time complexity::running time complexity
vertex and degree::vertex and degree
priority also takes::priority also takes
looked at prim::looked at prim
implementing it data::implementing it data
single source shortest::single source shortest
source shortest path::source shortest path
similar to prim::similar to prim
graph and today::graph and today
graph is directed::graph is directed
edges to positive::edges to positive
positive ? non::positive ? non
ton and tons::ton and tons
stands for termination::stands for termination
stand for destination::stand for destination
interested in taking::interested in taking
taking the shortest::taking the shortest
option fourth option::option fourth option
edge is directed::edge is directed
problem to compute::problem to compute
compute the length::compute the length
compute the shortest::compute the shortest
high time complexity::high time complexity
matter just list::matter just list
out your paths::out your paths
number of paths::number of paths
means exponentially varying::means exponentially varying
diamonds would count::diamonds would count
diamond i associate::diamond i associate
associate this vertex::associate this vertex
takes the top::takes the top
path that takes::path that takes
roughly how large::roughly how large
number of particles::number of particles
graph of size::graph of size
compute shortest path::compute shortest path
shortest path system::shortest path system
approach to compute::approach to compute
figure out shortest::figure out shortest
out shortest path::out shortest path
reached this point::reached this point
reach this destination::reach this destination
shortest heap improving::shortest heap improving
improving the path::improving the path
means this part::means this part
vertex any vertex::vertex any vertex
computed the shortest::computed the shortest
vertex the graph::vertex the graph
shortest path problem::shortest path problem
computing the shortest::computing the shortest
abbreviated as triple::abbreviated as triple
vertices and suppose::vertices and suppose
suppose these lengths::suppose these lengths
fact that shortest::fact that shortest
positive why negative::positive why negative
distance of vertex::distance of vertex
out the distance::out the distance
initially the directed::initially the directed
vertex have vertices::vertex have vertices
path have length::path have length
shortest path found::shortest path found
path found nay::path found nay
found nay point::found nay point
found with visited::found with visited
vertex then compare::vertex then compare
length already stored::length already stored
concretize this algorithm::concretize this algorithm
put down numbers::put down numbers
separate this out::separate this out
shown those edges::shown those edges
correct shortest path::correct shortest path
found another path::found another path
distance i call::distance i call
call them tentative::call them tentative
proceeds for instance::proceeds for instance
reduce this earlier::reduce this earlier
prove its correctness::prove its correctness
straight forward algorithm::straight forward algorithm
algorithm is first::algorithm is first
algorithm in grained::algorithm in grained
found the shortest::found the shortest
step of algorithm::step of algorithm
found the correct::found the correct
value of shortest::value of shortest
invariance the algorithm::invariance the algorithm
vertex i move::vertex i move
move that vertex::move that vertex
minimum is moved::minimum is moved
update these labels::update these labels
values of distance::values of distance
distance label recall::distance label recall
put every vertex::put every vertex
give every vertex::give every vertex
vertex distance labels::vertex distance labels
smallest distance labels::smallest distance labels
insert h dot::insert h dot
call it decrease::call it decrease
heap the minimum::heap the minimum
case of prim::case of prim
dot delete min::dot delete min
update its label::update its label
update the label::update the label
maintain this information::maintain this information
level everyone understands::level everyone understands
dot decrease priority::dot decrease priority
carefully this implementation::carefully this implementation
out the length::out the length
version of prim::version of prim
case of dijkstra::case of dijkstra
algorithm this label::algorithm this label
label v equals::label v equals
calling that label::calling that label
hazard a guess::hazard a guess
vertices are part::vertices are part
doing the correctness::doing the correctness
summation degree log::summation degree log
calling this loop::calling this loop
decrease priority operation::decrease priority operation
priority operation takes::priority operation takes
removing the vertex::removing the vertex
mistake i made::mistake i made
thing will coming::thing will coming
coming as min::coming as min
times this operation::times this operation
discussion on shortest::discussion on shortest
root data structures::root data structures
correctness of dijkstra::correctness of dijkstra
looked at dijkstra::looked at dijkstra
computing the single::computing the single
path the algorithm::path the algorithm
algorithm what remains::algorithm what remains
algorithm computing minimum::algorithm computing minimum
algorithm is correct::algorithm is correct
done in dijkstra::done in dijkstra
negative edge length::negative edge length
understand the semantics::understand the semantics
recall is infinite::recall is infinite
step only decreases::step only decreases
complement the vertices::complement the vertices
computed there actual::computed there actual
actual shortest path::actual shortest path
shortest path distances::shortest path distances
signifying the fact::signifying the fact
make this claim::make this claim
claim to argue::claim to argue
shortest path distance::shortest path distance
update the distances::update the distances
label were sitting::label were sitting
minimum that correspond::minimum that correspond
vertex in capital::vertex in capital
path including vertices::path including vertices
includes only vertices::includes only vertices
induction make sense::induction make sense
true the numbers::true the numbers
vertices do reflect::vertices do reflect
reflect this quantity::reflect this quantity
move one vertex::move one vertex
continue to reflect::continue to reflect
establish this claim::establish this claim
end up updating::end up updating
updating the distance::updating the distance
satisfies this thing::satisfies this thing
means the earlier::means the earlier
picture s complement::picture s complement
moment it hits::moment it hits
path has length::path has length
path what remains::path what remains
knew the shortest::knew the shortest
vertices of capital::vertices of capital
make this argument::make this argument
length of path::length of path
include w shortest::include w shortest
out the shortest::out the shortest
write that part::write that part
capital s complement::capital s complement
minus w capital::minus w capital
moved this thing::moved this thing
thing this path::thing this path
smallest possible path::smallest possible path
ignore this thing::ignore this thing
paths are captured::paths are captured
quantity only smaller::quantity only smaller
takes an edge::takes an edge
semantic in mind::semantic in mind
mind every thing::mind every thing
simple to follow::simple to follow
distance label reflect::distance label reflect
reflect this kind::reflect this kind
kind of length::kind of length
justified in moving::justified in moving
moving the smallest::moving the smallest
smallest label vertex::smallest label vertex
taking this vertex::taking this vertex
label and moving::label and moving
justified in doing::justified in doing
smallest d value::smallest d value
complement the claim::complement the claim
shorter path form::shorter path form
path will visit::path will visit
visit some vertices::visit some vertices
lot of crazy::lot of crazy
path whose length::path whose length
means the entire::means the entire
fact that edge::fact that edge
drawn has length::drawn has length
path we started::path we started
smaller than length::smaller than length
moving this vertex::moving this vertex
found the length::found the length
shortest path form::shortest path form
path would include::path would include
include some vertices::include some vertices
recap the argument::recap the argument
argument this clam::argument this clam
proving using induction::proving using induction
proving this induction::proving this induction
statement we required::statement we required
found a shortest::found a shortest
head and figure::head and figure
right induction statement::right induction statement
argue for vertex::argue for vertex
vertices s complement::vertices s complement
argue this statement::argue this statement
include these vertices::include these vertices
includes the vertex::includes the vertex
vertices basically sub::vertices basically sub
basically sub vertices::basically sub vertices
continue to remain::continue to remain
changed the distance::changed the distance
moved one vertex::moved one vertex
move this vertex::move this vertex
path which includes::path which includes
provided the path::provided the path
shortest path unqualified::shortest path unqualified
moment we move::moment we move
correct the base::correct the base
case is correct::case is correct
argues the correctness::argues the correctness
algorithm this algorithm::algorithm this algorithm
algorithm is due::algorithm is due
due to dijkstra::due to dijkstra
graph had edges::graph had edges
edges of negative::edges of negative
length in fact::length in fact
graph has edges::graph has edges
path some times::path some times
instance the shortest::instance the shortest
cycle for instance::cycle for instance
length of minus::length of minus
negative length make::negative length make
length make sense::length make sense
negative edge lengths::negative edge lengths
graph which represents::graph which represents
represents currency tradings::represents currency tradings
global currency trader::global currency trader
profit i incur::profit i incur
incur in doing::incur in doing
change your rupees::change your rupees
back into rupees::back into rupees
setting where negative::setting where negative
negative would make::negative would make
path in graph::path in graph
sufficiently a larger::sufficiently a larger
negative length brilliant::negative length brilliant
length brilliant idea::length brilliant idea
add a delta::add a delta
work ? number::work ? number
lot of edges::lot of edges
make this path::make this path
increase every edge::increase every edge
track of number::track of number
graph negative cycle::graph negative cycle
part of argument::part of argument
plenty of negative::plenty of negative
make your millions::make your millions
basically not discuss::basically not discuss
discuss it today::discuss it today
vertex has linked::vertex has linked
maintain a pointer::maintain a pointer
compute shortest paths::compute shortest paths
things that remain::things that remain
source shortest paths::source shortest paths
discussion on single::discussion on single
shortest path today::shortest path today
compute the path::compute the path
compute the distance::compute the distance
edges had non::edges had non
non negative lengths::non negative lengths
negative lengths today::negative lengths today
compute single source::compute single source
path when edges::path when edges
vertex is moving::vertex is moving
updation is happening::updation is happening
maintain with vertex::maintain with vertex
means the shortest::means the shortest
vertex we maintain::vertex we maintain
maintain predecessor information::maintain predecessor information
information to compute::information to compute
path ? suppose::path ? suppose
vertex which precedes::vertex which precedes
maintained this information::maintained this information
reach the source::reach the source
update the distance::update the distance
update the predecessor::update the predecessor
transfer a vertex::transfer a vertex
updating its information::updating its information
path you found::path you found
update the information::update the information
information and pred::information and pred
pieces of information::pieces of information
find the path::find the path
set the predecessor::set the predecessor
source to null::source to null
out the vertices::out the vertices
edges one suggestion::edges one suggestion
figure this out::figure this out
understand what edges::understand what edges
predecessor vertex information::predecessor vertex information
vertex information bur::vertex information bur
connecting the predecessor::connecting the predecessor
n-1 predecessor edges::n-1 predecessor edges
ignore or forget::ignore or forget
forget the directions::forget the directions
back the direction::back the direction
basically a sub::basically a sub
specific root vertex::specific root vertex
remember this step::remember this step
context of shortest::context of shortest
shortest path tree::shortest path tree
follow the unique::follow the unique
similarly the shortest::similarly the shortest
n-1 edges capture::n-1 edges capture
compute this tree::compute this tree
required by dijkstras::required by dijkstras
spent any additional::spent any additional
class if edges::class if edges
edges have negative::edges have negative
talking of single::talking of single
kind of negatives::kind of negatives
cycle because recall::cycle because recall
thing is meaningless::thing is meaningless
non simple path::non simple path
repeat any vertex::repeat any vertex
cycle has positive::cycle has positive
exists a shortest::exists a shortest
attention in finding::attention in finding
finding a simple::finding a simple
interested in finding::interested in finding
finding simple path::finding simple path
kind of algorithm::kind of algorithm
information this guys::information this guys
communicate this information::communicate this information
source has length::source has length
found a path::found a path
change its thing::change its thing
call one round::call one round
neighbors and sends::neighbors and sends
sends the information::sends the information
node also gathers::node also gathers
gathers the information::gathers the information
neighbors and updates::neighbors and updates
updates its value::updates its value
updated its value::updated its value
transfer then updation::transfer then updation
simultaneously a node::simultaneously a node
implement this thing::implement this thing
maintaining this distance::maintaining this distance
implement one round::implement one round
notion of actual::notion of actual
degree the total::degree the total
difference between length::difference between length
length and number::length and number
path using edges::path using edges
n-1 shortest path::n-1 shortest path
lengths were positive::lengths were positive
similarly shortest path::similarly shortest path
value which means::value which means
means the value::means the value
rounds this vertex::rounds this vertex
prove the claim::prove the claim
claim by induction::claim by induction
changing the value::changing the value
vertex whose value::vertex whose value
vertex you reach::vertex you reach
reach the vertex::reach the vertex
value for confusion::value for confusion
reduce the running::reduce the running
bit the worst::bit the worst
case will remain::case will remain
round this guy::round this guy
lesser this guy::lesser this guy
give a vertex::give a vertex
shortest path contradiction::shortest path contradiction
suppose this statement::suppose this statement
true till round::true till round
double induction kind::double induction kind
modified the code::modified the code
thing gets updated::thing gets updated
assume this vertex::assume this vertex
label in round::label in round
apply induction hypothesis::apply induction hypothesis
hypothesis which means::hypothesis which means
guys are worried::guys are worried
modify the thing::modify the thing
equal to min::equal to min
briefly is apsp::briefly is apsp
pair shortest path::pair shortest path
paths with positive::paths with positive
positive edges length::positive edges length
path when edge::path when edge
lengths are positive::lengths are positive
positive when edge::positive when edge
thing is negative::thing is negative
negative please remember::negative please remember
fact every thing::fact every thing
end today lecture::end today lecture
lecture on shortest::lecture on shortest
path in fact::path in fact
discuss data structures::discuss data structures
introduction to data::introduction to data
terminologies regarding data::terminologies regarding data
definitions an algorithm::definitions an algorithm
programming language data::programming language data
language data structure::language data structure
lot of data::lot of data
process develop data::process develop data
develop data structures::develop data structures
organizing the data::organizing the data
specification a sorted::specification a sorted
non decreasing sequence::non decreasing sequence
sequence of natural::sequence of natural
numbers of non-zero::numbers of non-zero
completely specified input::completely specified input
examples of input::examples of input
finite length forms::finite length forms
forms an instance::forms an instance
number of instances::number of instances
sequence of sorted::sequence of sorted
numbers as input::numbers as input
describing the actions::describing the actions
infinitely many input::infinitely many input
instances and algorithms::instances and algorithms
algorithms for solving::algorithms for solving
solving certain problem::solving certain problem
brings the notion::brings the notion
notion of good::notion of good
algorithm ? good::algorithm ? good
efficient ? efficient::efficient ? efficient
takes less memory::takes less memory
measures of efficiency::measures of efficiency
analyzing the running::analyzing the running
analyzing the space::analyzing the space
efficiency of algorithms::efficiency of algorithms
function of input::function of input
behavior of increase::behavior of increase
size of input::size of input
measure the running::measure the running
write a program::write a program
language you run::language you run
run the program::run the program
program with varying::program with varying
varying data sets::varying data sets
larger data sets::larger data sets
kinds of varying::kinds of varying
takes and clock::takes and clock
utility like system::utility like system
current time millis::current time millis
good your algorithms::good your algorithms
determine how good::determine how good
good your algorithm::good your algorithm
algorithm is implementing::algorithm is implementing
spend considerable amount::spend considerable amount
set of inputs::set of inputs
run your experiment::run your experiment
set of instances::set of instances
algorithm is taking::algorithm is taking
comparison platform means::comparison platform means
hardware and software::hardware and software
machines would make::machines would make
point would make::point would make
develop the general::develop the general
develop a high::develop a high
high level description::high level description
describing an algorithm::describing an algorithm
description to figure::description to figure
out the running::out the running
system a methodology::system a methodology
evaluate the efficiency::evaluate the efficiency
takes an array::takes an array
stores an integer::stores an integer
array algorithm array::array algorithm array
algorithm array max::algorithm array max
syntax is wrong::syntax is wrong
mixture of natural::mixture of natural
high-level programming concepts::high-level programming concepts
program is doing::program is doing
doing is clear::doing is clear
variable called current::variable called current
array current max::array current max
current maximum element::current maximum element
update the current::update the current
return current max::return current max
max if current::max if current
conveys the idea::conveys the idea
structured than usual::structured than usual
language how pseudo-code::language how pseudo-code
numeric and boolean::numeric and boolean
relationship in java::relationship in java
parameter it takes::parameter it takes
kinds of programming::kinds of programming
terminates and return::terminates and return
call a method::call a method
object used calls::object used calls
specifies the type::specifies the type
algorithms ? first::algorithms ? first
low level operation::low level operation
call or return::call or return
operations or logical::operations or logical
operation ? data::operation ? data
arithmetic an logical::arithmetic an logical
inspect the pseudo::inspect the pseudo
code and count::code and count
number of primitive::number of primitive
sorting the input::sorting the input
numbers and output::numbers and output
non decreasing order::non decreasing order
make an output::make an output
algorithm should sort::algorithm should sort
produce the sequence::produce the sequence
running time depends::running time depends
sorted these numbers::sorted these numbers
things the first::things the first
first sorting technique::first sorting technique
game of cards::game of cards
strategy you follow::strategy you follow
set of cards::set of cards
hand you start::hand you start
card and insert::card and insert
jack and queen::jack and queen
cards and inserted::cards and inserted
pseudo-code for insertion::pseudo-code for insertion
give an array::give an array
array of integers::array of integers
integers as input::integers as input
input and output::input and output
sorted the output::sorted the output
variables or indices::variables or indices
loop it starts::loop it starts
move it right::move it right
place i run::place i run
insert this loop::insert this loop
loop will continue::loop will continue
loop will terminate::loop will terminate
shifting the element::shifting the element
element one step::element one step
location becomes empty::location becomes empty
find the right::find the right
element and insert::element and insert
analyze this algorithm::analyze this algorithm
arrow please make::arrow please make
make a correction::make a correction
represent the amount::represent the amount
operations is executed::operations is executed
done n times::done n times
start by assigning::start by assigning
roughly n times::roughly n times
operation ? key::operation ? key
times just leave::times just leave
leave the comment::leave the comment
counts the number::counts the number
shift an element::shift an element
inserting the card::inserting the card
count that quantity::count that quantity
checking this condition::checking this condition
reach this condition::reach this condition
condition for times::condition for times
times the total::times the total
key this statement::key this statement
quantity which depends::quantity which depends
sorting the instance::sorting the instance
difference that makes::difference that makes
compare the element::compare the element
times n minus::times n minus
talk about asymptotic::talk about asymptotic
times some constant::times some constant
minus some constant::minus some constant
worst and average::worst and average
sorting n numbers::sorting n numbers
case is defined::case is defined
1size of size::1size of size
give the values::give the values
compute worst case::compute worst case
create a plot::create a plot
out the worst::out the worst
monotonically increasing plots::monotonically increasing plots
algorithm will increase::algorithm will increase
size becomes larger::size becomes larger
easiest to work::easiest to work
long your algorithm::long your algorithm
algorithms worst case::algorithms worst case
worst case occurs::worst case occurs
algorithm is close::algorithm is close
worst case average::worst case average
case average case::case average case
difficult to compute::difficult to compute
instance is drawn::instance is drawn
quantity to work::quantity to work
measure of interest::measure of interest
working with asymptotic::working with asymptotic
rid of superficial::rid of superficial
constant times squared::constant times squared
constant times ,because::constant times ,because
,because this constant::,because this constant
interested to distinguish::interested to distinguish
input size doubles::input size doubles
doubles the running::doubles the running
increases four fold::increases four fold
interested in capturing::interested in capturing
analysis clearly explains::analysis clearly explains
increases with increase::increases with increase
increase in input::increase in input
big-oh ? o-notation::big-oh ? o-notation
represents the input::represents the input
input size increases::input size increases
drawn two functions::drawn two functions
functions the function::functions the function
function in red::function in red
function the function::function the function
function in green::function in green
examples would clarify::examples would clarify
examples the function::examples the function
scale the scale::scale the scale
similarly on x-axis::similarly on x-axis
x-axis the red::x-axis the red
red colored line::red colored line
point of crossing::point of crossing
straight line displaced::straight line displaced
displaced by suitable::displaced by suitable
amount the green::amount the green
blue in color::blue in color
out a constant::out a constant
pick a larger::pick a larger
simple rule suppose::simple rule suppose
drop all constants::drop all constants
lower order terms::lower order terms
order terms forget::order terms forget
forget the constant::forget the constant
drop the constant::drop the constant
constant and lower::constant and lower
drop all lower::drop all lower
fastest growing term::fastest growing term
drop my constant::drop my constant
limit this quantity::limit this quantity
times this quantity::times this quantity
error the function::error the function
provide as strong::provide as strong
express the number::express the number
executed during run::executed during run
takes the number::takes the number
increase four fold::increase four fold
similarly our algorithm::similarly our algorithm
hierarchy of functions::hierarchy of functions
order of log::order of log
word of caution::word of caution
algorithm whose running::algorithm whose running
1,000,000 n algorithm::1,000,000 n algorithm
limit is achieved::limit is achieved
achieved very late::achieved very late
large for small::large for small
examples of asymptotic::examples of asymptotic
output an array::output an array
compute each element::compute each element
taking the value::taking the value
running the index::running the index
dividing the value::dividing the value
compute the running::compute the running
n-1 this entire::n-1 this entire
thing is done::thing is done
times the steps::times the steps
steps are executed::steps are executed
kind of repeating::kind of repeating
divide this sum::divide this sum
finish the iteration::finish the iteration
doing two primitive::doing two primitive
two primitive operations::two primitive operations
operations that makes::operations that makes
makes an order::makes an order
executed n times::executed n times
linear and quadratic::linear and quadratic
quadratic and logarithmic::quadratic and logarithmic
constant k algorithm::constant k algorithm
notation and big-theta::notation and big-theta
big-omega ? notation::big-omega ? notation
bound the function::bound the function
two more related::two more related
related asymptotic notations::related asymptotic notations
little-oh ? notation::little-oh ? notation
little-omega ? notation::little-omega ? notation
analogs of big-oh::analogs of big-oh
big-oh and big-omega::big-oh and big-omega
analogy of real::analogy of real
talk of equality::talk of equality
equal little-oh corresponds::equal little-oh corresponds
part the formal::part the formal
definition for little-oh::definition for little-oh
defines the difference::defines the difference
largest problem size::largest problem size
hour the largest::hour the largest
increases an hour::increases an hour
problem you solve::problem you solve
log n algorithm::log n algorithm
solve for problem::solve for problem
millions of years::millions of years
years to solve::years to solve
data structures::data structures
naveen garg::naveen garg
garg department::garg department
computer science::computer science
engineering indian::engineering indian
indian institute::indian institute
delhi lecture::delhi lecture
abstract data::abstract data
data types::data types
growable stacks::growable stacks
amortized analysis::amortized analysis
virtual machine::virtual machine
data type::data type
real numbers::real numbers
define data::define data
operation requires::operation requires
mathematics class::mathematics class
constructor operation::constructor operation
constructor method::constructor method
sophisticated data::sophisticated data
work access::work access
access functions::access functions
access elements::access elements
manipulation procedure::manipulation procedure
building blocks::building blocks
algorithmic procedure::algorithmic procedure
higher level::higher level
advanced data::advanced data
data structure::data structure
dynamic set::dynamic set
objects suppose::objects suppose
create data::create data
dynamic sets::dynamic sets
method insert::method insert
delete method::delete method
method removes::method removes
access methods::access methods
return value::return value
type boolean::type boolean
false axioms::false axioms
write axioms::write axioms
resulting set::resulting set
previous set::previous set
operation isin::operation isin
basic axioms::basic axioms
operations permitted::operations permitted
simple abstract::simple abstract
last-in-first-out principle::last-in-first-out principle
removed first::removed first
key methods::key methods
push method::push method
pop takes::pop takes
takes stack::takes stack
top element::top element
error stating::error stating
top operation::top operation
operation returns::operation returns
pop pop::pop pop
pop operation::pop operation
operation removes::operation removes
support methods::support methods
operations size::operations size
method size::method size
size tells::size tells
axiom governs::axiom governs
stack abstract::stack abstract
axioms axioms::axioms axioms
translate abstract::translate abstract
interface specification::interface specification
implementation meets::implementation meets
programming technique::programming technique
stack implementation::stack implementation
java java::java java
built-in stack::built-in stack
stack data::stack data
stack interface::stack interface
return type::return type
type object::type object
object object::object object
generic type::generic type
method isempty::method isempty
isempty returns::isempty returns
returns boolean::returns boolean
throws stackemptyexception::throws stackemptyexception
void means::void means
handle errors::handle errors
exceptional condition::exceptional condition
exceptional case::exceptional case
control moves::control moves
current method::current method
exception occurs::exception occurs
eat pizza::eat pizza
pizza method::pizza method
stomachache exception::stomachache exception
dotted code::dotted code
throw stomachacheexception::throw stomachacheexception
procedure public::procedure public
public void::public void
void eatpizza::void eatpizza
method eatpizza::method eatpizza
stimulate meeting::stimulate meeting
meeting procedure::meeting procedure
dotted point::dotted point
reach ta.eatpizza::reach ta.eatpizza
catch blocks::catch blocks
procedure call::procedure call
procedure stomachacheexception::procedure stomachacheexception
local variables::local variables
global variables::global variables
catch block::catch block
block start::block start
exception raised::exception raised
exception stomachacheexception::exception stomachacheexception
method raises::method raises
written inside::written inside
procedure simulate::procedure simulate
simulate meeting::simulate meeting
parent procedure::parent procedure
stomachacheexception throws::stomachacheexception throws
high level::high level
level procedure::level procedure
exception appearing::exception appearing
procedure stops::procedure stops
user system.out.println::user system.out.println
java class::java class
statement stomachacheexception::statement stomachacheexception
catch statement::catch statement
propagate upwards::propagate upwards
procedural hierarchy::procedural hierarchy
hierarchy stomachacheexception::hierarchy stomachacheexception
calling procedure::calling procedure
parameters written::parameters written
listening exceptions::listening exceptions
throws class::throws class
throws stomachacheexception::throws stomachacheexception
object stomachacheexception::object stomachacheexception
class public::class public
public class::public class
class stomachacheexception::class stomachacheexception
stomachacheexception extends::stomachacheexception extends
public stomachacheexception::public stomachacheexception
string err::string err
method takes::method takes
single parameter::single parameter
string super::string super
super means::super means
super class::super class
method calls::method calls
stomach ache::stomach ache
ache exception::ache exception
method throws::method throws
catch statements::catch statements
java book::java book
maximum size::maximum size
first element::first element
entire implementation::entire implementation
array stack::array stack
statement mentioned::statement mentioned
class arraystack::class arraystack
arraystack implements::arraystack implements
implements stack::implements stack
stack implement::stack implement
implement stack::implement stack
stack means::stack means
default capacity::default capacity
public arraystack::public arraystack
int cap::int cap
constructor methods::constructor methods
returns false::returns false
full exception::full exception
incremented location::incremented location
first increment::first increment
stack empty::stack empty
empty exception::empty exception
location elem::location elem
top location::top location
element pop::element pop
return elem::return elem
private member::private member
array implementation::array implementation
operations required::operations required
virtual dependent::virtual dependent
upper bound::upper bound
default value1024::default value1024
large size::large size
small stack::small stack
exception stack::exception stack
pop methods::pop methods
daily stock::daily stock
stock prices::stock prices
stock price::stock price
maximum number::maximum number
consecutive days::consecutive days
day price::day price
current day::current day
true done::true done
repeat-until loop::repeat-until loop
reached day::reached day
worst case::worst case
total number::total number
case question::case question
closest day::closest day
day preceding::day preceding
preceding day::preceding day
first price::first price
price greater::price greater
7th bar::7th bar
6th bar::6th bar
top value::top value
loop executes::loop executes
loop executed::loop executed
statements inside::statements inside
for-loop execute::for-loop execute
statements execute::statements execute
iteration put::iteration put
element stack::element stack
give maximum::give maximum
original stack::original stack
top counter::top counter
tight strategy::tight strategy
growth strategy::growth strategy
additive increment::additive increment
regular push::regular push
special push::special push
larger stack::larger stack
elements form::elements form
earlier stack::earlier stack
total cost::total cost
push operation::push operation
strategy behaves::strategy behaves
4th operation::4th operation
regular pushes::regular pushes
pound symbol::pound symbol
multiplication operator::multiplication operator
previous array::previous array
phases total::phases total
change slightly::change slightly
array size::array size
5th element::5th element
spent units::spent units
copy elements::copy elements
copying elements::copying elements
strategy data::strategy data
linked lists::linked lists
last lecture::last lecture
implement stacks::implement stacks
array today::array today
linked list::linked list
first part::first part
ended queues::ended queues
last-in first-out::last-in first-out
first-out principle::first-out principle
first-in-first-out principle::first-in-first-out principle
rear element::rear element
front end::front end
standard operations::standard operations
front element::front element
isempty size::isempty size
return false::return false
defined axioms::defined axioms
similar axioms::similar axioms
empty queue::empty queue
written front::written front
initially empty::initially empty
statement dequeue::statement dequeue
remaining queue::remaining queue
circular fashion::circular fashion
blue part::blue part
queue reach::queue reach
colored part::colored part
0th location::0th location
3rd element::3rd element
queue drift::queue drift
completely accurate::completely accurate
anymore elements::anymore elements
start inserting::start inserting
right side::right side
left side::left side
front refers::front refers
rear refers::rear refers
empty location::empty location
elements starting::elements starting
empty suppose::empty suppose
element close::element close
pseudo code::pseudo code
rear location::rear location
circular indices::circular indices
modn point::modn point
return r-f::return r-f
r-f tells::r-f tells
queue r-f::queue r-f
correct thing::correct thing
positive quantity::positive quantity
right number::right number
elements check::elements check
confused isempty::confused isempty
algorithm isempty::algorithm isempty
dequeue method::dequeue method
front index::front index
last class::last class
size increases::size increases
first node::first node
last node::last node
head node::head node
tail node::tail node
torcezo element::torcezo element
rome element::rome element
last place::last place
methods suppose::methods suppose
left head::left head
head part::head part
tail part::tail part
head point::head point
head element::head element
head easily::head easily
first diagram::first diagram
last element::last element
rear end::rear end
added element::added element
previous node::previous node
tail point::tail point
entire list::entire list
expensive operation::expensive operation
queue data::queue data
double-ended queue::double-ended queue
delete operations::delete operations
last operations::last operations
good idea::good idea
good solution::good solution
double-ended queues::double-ended queues
previous pointer::previous pointer
sentinel nodes::sentinel nodes
trailer nodes::trailer nodes
previous port::previous port
dummy nodes::dummy nodes
data inside::data inside
san francisco::san francisco
sentinel node::sentinel node
node point::node point
generic data::generic data
method top::method top
method push::method push
method pop::method pop
ended queue::ended queue
insert front::insert front
remove front::remove front
queue front::queue front
dequeue implementation::dequeue implementation
adapter pattern::adapter pattern
adapter patterns::adapter patterns
patterns implements::patterns implements
adapter classes::adapter classes
classes specialize::classes specialize
general classes::general classes
arbitrary objects::arbitrary objects
adapt arraystack::adapt arraystack
arraystack implementation::arraystack implementation
integer objects::integer objects
pointers head::pointers head
circular list::circular list
pointer point::pointer point
big pointer::big pointer
end make::end make
element rome::element rome
node make::node make
straight forward::straight forward
queue removing::queue removing
element corresponds::element corresponds
2nd node::2nd node
node copying::node copying
general sequences::general sequences
vector data::vector data
indicative methods::indicative methods
4th element::4th element
departmental rank::departmental rank
department rank::department rank
step right::step right
entire elements::entire elements
operations insert::operations insert
case spent::case spent
spent order::spent order
elements sitting::elements sitting
1st node::1st node
insert newyork::insert newyork
3rd diagram::3rd diagram
takes order::takes order
java code::java code
procedure nodeatrank::procedure nodeatrank
defining shortly::defining shortly
previous field::previous field
node dlnode::node dlnode
dlnode prev::dlnode prev
dlnode node::dlnode node
procedure dlnode::procedure dlnode
original list::original list
2nd diagram::2nd diagram
previous pointers::previous pointers
final node::final node
small improvement::small improvement
hundred elements::hundred elements
vector abstract::vector abstract
require order::require order
element correspond::element correspond
delete linked::delete linked
supporting node::supporting node
node based::node based
based operations::based operations
inserted node::inserted node
operations provided::operations provided
give access::give access
based operation::based operation
actual implementation::actual implementation
positions position::positions position
method element::method element
type position::type position
previous fields::previous fields
relative order::relative order
positions jus::positions jus
3rd node::3rd node
2nd position::2nd position
3rd position::3rd position
list abstract::list abstract
abstract datatype::abstract datatype
generic methods::generic methods
query method::query method
first position::first position
last position::last position
excessive methods::excessive methods
update methods::update methods
list data::list data
datatype implementation::datatype implementation
sequence abstract::sequence abstract
multiple inheritance::multiple inheritance
additional methods::additional methods
method atrank::method atrank
array refers::array refers
rank suppose::rank suppose
1st reference::1st reference
element stored::element stored
cross reference::cross reference
sequence suppose::sequence suppose
sequence operations::sequence operations
rank based::rank based
sequence data::sequence data
type data::type data
dictionary abstract::dictionary abstract
binary search::binary search
hash table::hash table
collision resolution::collision resolution
resolution techniques::resolution techniques
hashing techniques::hashing techniques
stores elements::stores elements
store bank::store bank
bank accounts::bank accounts
account number::account number
bank account::bank account
account numbers::account numbers
account stores::account stores
stores wealth::stores wealth
current balance::current balance
account holder::account holder
transactions done::transactions done
additional information::additional information
abstract model::abstract model
key-element pairs::key-element pairs
case suppose::case suppose
student records::student records
natural notion::natural notion
entry number::entry number
main operations::main operations
standard container::standard container
container methods::container methods
query methods::query methods
key find::key find
standard thing::standard thing
special element::special element
element nil::element nil
unsuccessful search::unsuccessful search
require comparison::require comparison
student record::student record
comparing keys::comparing keys
keys dictionary::keys dictionary
dictionary suppose::dictionary suppose
doing things::doing things
arbitrary manner::arbitrary manner
efficient today::efficient today
binary tree::binary tree
black trees::black trees
avl trees::avl trees
important data::important data
abstract class::abstract class
subsequent discussions::subsequent discussions
numbers lets::numbers lets
single number::single number
sitting index::sitting index
found number::found number
return nil::return nil
key idea::key idea
design technique::design technique
future classes::future classes
sorted order::sorted order
work suppose::work suppose
middle element::middle element
increasing order::increasing order
entire array::entire array
2nd part::2nd part
3rd part::3rd part
recursive procedure::recursive procedure
lower end::lower end
higher end::higher end
return mid::return mid
left part::left part
staring location::staring location
ending location::ending location
location mid-1::location mid-1
return binarysearch::return binarysearch
recursive call::recursive call
right part::right part
small pieces::small pieces
iterative procedure::iterative procedure
blue color::blue color
first step::first step
mid element::mid element
do-while loop::do-while loop
step range::step range
first comparison::first comparison
require comparisons::require comparisons
entire process::entire process
decreasing order::decreasing order
huge difference::huge difference
difference coming::difference coming
small pseudo::small pseudo
dictionary problem::dictionary problem
large phone::large phone
phone company::phone company
phone number::phone number
phone numbers::phone numbers
digit numbers::digit numbers
million phone::million phone
unordered sequence::unordered sequence
arbitrary order::arbitrary order
unordered list::unordered list
person decides::person decides
data record::data record
small modification::small modification
entire thing::entire thing
first location::first location
inserting takes::inserting takes
maintain log::maintain log
log files::log files
log file::log file
system administration::system administration
add data::add data
add insertions::add insertions
insertion takes::insertion takes
dictionary data::dictionary data
ordered sequence::ordered sequence
key searching::key searching
searching takes::searching takes
takes log::takes log
direct access::direct access
access mechanism::access mechanism
whichever element::whichever element
element insertion::element insertion
similarly deletion::similarly deletion
previous class::previous class
create space::create space
move order::move order
big-oh notation::big-oh notation
make sense::make sense
subsequent discussion::subsequent discussion
huge array::huge array
ankur phone::ankur phone
phone connection::phone connection
bad thing::bad thing
previous technique::previous technique
smaller array::smaller array
hypothetical setting::hypothetical setting
small number::small number
entry numbers::entry numbers
hash function::hash function
location number::location number
grade shape::grade shape
simple technique::simple technique
color thing::color thing
list starting::list starting
list suppose::list suppose
computing modulo::computing modulo
collision problem::collision problem
structure reduces::structure reduces
quick recap::quick recap
hash functions::hash functions
key modulo::key modulo
constant amount::constant amount
end suppose::end suppose
simple arithmetic::simple arithmetic
arithmetic operations::arithmetic operations
good choices::good choices
function lot::function lot
simple examples::simple examples
good hash::good hash
distributes things::distributes things
ideal hash::ideal hash
random location::random location
simple uniform::simple uniform
uniform hash::uniform hash
load factor::load factor
table divided::table divided
factor alpha::factor alpha
function takes::function takes
takes constant::takes constant
right linked::right linked
follow pointer::follow pointer
average size::average size
simple hash::simple hash
excepted number::excepted number
total search::total search
excepted search::excepted search
bad hash::bad hash
structure relies::structure relies
class designing::class designing
designing hash::designing hash
successful search::successful search
excepted length::excepted length
search excepted::search excepted
elements examined::elements examined
function computation::function computation
list divided::list divided
similar kind::similar kind
low order::low order
order term::order term
good choice::good choice
excepted sense::excepted sense
growable stack::growable stack
entire set::entire set
larger hash::larger hash
function keeping::function keeping
smaller table::smaller table
larger table::larger table
table slots::table slots
elements coming::elements coming
list length::list length
small hash::small hash
large hash::large hash
space today::space today
resolving collision::resolving collision
collision data::collision data
resolve collision::resolve collision
chaining today::chaining today
linear probing::linear probing
double hashing::double hashing
famous paradox::famous paradox
birthday paradox::birthday paradox
students sitting::students sitting
high probability::high probability
small probability::small probability
non-integer keys::non-integer keys
telephone numbers::telephone numbers
treat telephone::treat telephone
telephone number::telephone number
converting non-integers::converting non-integers
non-integers keys::non-integers keys
function value::function value
hash code::hash code
code map::code map
compression map::compression map
integer keys::integer keys
arbitrary range::arbitrary range
important requirement::important requirement
indexed location::indexed location
randomization happening::randomization happening
equal keys::equal keys
popular hash-code::popular hash-code
hash-code maps::hash-code maps
hash-code map::hash-code map
bit pattern::bit pattern
numeric type::numeric type
double real::double real
real number::real number
string suppose::string suppose
ascii code::ascii code
bad strategy::bad strategy
english dictionary::english dictionary
ascii values::ascii values
great strategy::great strategy
convert character::convert character
character strings::character strings
polynomial accumulation::polynomial accumulation
evaluated value::evaluated value
large range::large range
non-integer data::non-integer data
integer evaluate::integer evaluate
integer value::integer value
experimental stuff::experimental stuff
observed experimentally::observed experimentally
experimental study::experimental study
small range::small range
natural thing::natural thing
table suppose::table suppose
integer mod::integer mod
integer write::integer write
binary representation::binary representation
taking mod::taking mod
last bit::last bit
small set::small set
bits based::bits based
simple compression::simple compression
prime number::prime number
important thing::important thing
table close::table close
key mod::key mod
number things::number things
collisions happening::collisions happening
happening lot::happening lot
generic principles::generic principles
compression maps::compression maps
fractional part::fractional part
fractional number::fractional number
floor function::floor function
means round::means round
nearest integer::nearest integer
popular compression::popular compression
popular ways::popular ways
small fraction::small fraction
smaller fraction::smaller fraction
fraction part::fraction part
fibonacci hashing::fibonacci hashing
significant theory::significant theory
nice book::nice book
ronald knuth::ronald knuth
covers hash::covers hash
key multiply::key multiply
fixed numbers::fixed numbers
compute modulo::compute modulo
first technique::first technique
patterns happening::patterns happening
random number::random number
number generator::number generator
function random::function random
number generators::number generators
linear congruential::linear congruential
congruential generators::congruential generators
starting value::starting value
give random::give random
last value::last value
last random::last random
number generated::number generated
generate random::generate random
pseudo random::pseudo random
universal hashing::universal hashing
make life::make life
life difficult::life difficult
doing insertion::doing insertion
process starts::process starts
table implementation::table implementation
bad set::bad set
3rd year::3rd year
resolve collisions::resolve collisions
call chaining::call chaining
techniques today::techniques today
general class::general class
open addressing::open addressing
addressing differs::addressing differs
key fact::key fact
fact recall::fact recall
starting element::starting element
chaining technique::chaining technique
suitable manner::suitable manner
key sets::key sets
first probe::first probe
insertion depending::insertion depending
determining sequence::determining sequence
first place::first place
guiding principles::guiding principles
current location::current location
specific location::specific location
5th location::5th location
continuous locations::continuous locations
8th location::8th location
11th location::11th location
respective position::respective position
elements tend::elements tend
form clusters::form clusters
elements suppose::elements suppose
element present::element present
10th location::10th location
12th location::12th location
12th position::12th position
search terminates::search terminates
6th location::6th location
location suppose::location suppose
problem coming::problem coming
full location::full location
location empty::location empty
null location::null location
insert encounters::insert encounters
empty locations::empty locations
search degrades::search degrades
empty slots::empty slots
addressing techniques::addressing techniques
offset probe::offset probe
orange color::orange color
hashing works::hashing works
starting location::starting location
cycle back::cycle back
offset divides::offset divides
small fact::small fact
rough arguments::rough arguments
distributes keys::distributes keys
hashing recall::hashing recall
elements divided::elements divided
sit inside::sit inside
random element::random element
uniformly random::uniformly random
unsuccessful search.what::unsuccessful search.what
search stop::search stop
expected number::expected number
probes required::probes required
hit fraction::hit fraction
occupied location::occupied location
sense probes::sense probes
excepted numbers::excepted numbers
average number::average number
successful searches::successful searches
empty table::empty table
first elements::first elements
elements size::elements size
insert element::insert element
inserted elements::inserted elements
upper bounding::upper bounding
last number::last number
table empty::table empty
minus log::minus log
fraction empty::fraction empty
number smaller::number smaller
successful probes::successful probes
hashing linear::hashing linear
linear programming::linear programming
binary trees::binary trees
turn parent::turn parent
term grandparent::term grandparent
great grand::great grand
grand parent::grand parent
family tree::family tree
real trees::real trees
generic term::generic term
internal nodes::internal nodes
internal node::internal node
term depth::term depth
maximum level::maximum level
basic terminologies::basic terminologies
call electronics::call electronics
divisions rnd::divisions rnd
organizational structure::organizational structure
student guide::student guide
support code::support code
chapter grading::chapter grading
file system::file system
unix environment::unix environment
windows environment::windows environment
root directory::root directory
ordered tree::ordered tree
left child::left child
side suppose::side suppose
eldest child::eldest child
younger child::younger child
left node::left node
right node::right node
right child::right child
root node::root node
child node::child node
right nodes::right nodes
left nodes::left nodes
representing information::representing information
recursive form::recursive form
single node::single node
nodes marked::nodes marked
right subtree::right subtree
left subtree::left subtree
right subtrees::right subtrees
subtrees remember::subtrees remember
extreme left::extreme left
arithmetic expressions::arithmetic expressions
arithmetic expression::arithmetic expression
expression suppose::expression suppose
last line::last line
resulting value::resulting value
expression decision::expression decision
decision tree::decision tree
book star::book star
star bucks::star bucks
tree corresponds::tree corresponds
fast meal::fast meal
decision trees::decision trees
concrete stuff::concrete stuff
complete binary::complete binary
level number::level number
leaf nodes::leaf nodes
simple counting::simple counting
leafy kind::leafy kind
large complete::large complete
atmost nodes::atmost nodes
important fact::important fact
last level::last level
smallest height::smallest height
shortest height::shortest height
minimum height::minimum height
maximum height::maximum height
height atmost::height atmost
atmost n-1::atmost n-1
people make::people make
tree means::tree means
means height::means height
base case::base case
leaf base::leaf base
right hand::right hand
hand side::hand side
nodes suppose::nodes suppose
induction hypothesis::induction hypothesis
simple proof::simple proof
leafy tree::leafy tree
minimum number::minimum number
generic container::generic container
method elements::method elements
position based::position based
based container::based container
position data::position data
method positions::method positions
positions method::positions method
element method::element method
positions replaceelement::positions replaceelement
position isroot::position isroot
position correspond::position correspond
accessor method::accessor method
call root::call root
root hope::root hope
root means::root means
type casting::type casting
method parent::method parent
position returns::position returns
parent node::parent node
object type::object type
type sequence::type sequence
children position::children position
typically application::typically application
generic method::generic method
tree binary::tree binary
derived class::derived class
position give::position give
node structure::node structure
parent typically::parent typically
root method::root method
child method::child method
invoke element::invoke element
position interface::position interface
parent link::parent link
child member::child member
arbitrary trees::arbitrary trees
unbounded trees::unbounded trees
data members::data members
2nd level::2nd level
right sibling::right sibling
makes sense::makes sense
trees today::trees today
trees data::trees data
tree walks::tree walks
things today::things today
tree traversals::tree traversals
tree walk::tree walk
preorder walk::preorder walk
postorder walk::postorder walk
post order::post order
preorder tree::preorder tree
walks suppose::walks suppose
suppose recall::suppose recall
research paper::research paper
first section::first section
sub sections::sub sections
paper end::paper end
sub section::sub section
preorder traversal::preorder traversal
call preorder::call preorder
first visit::first visit
node corresponds::node corresponds
children nodes::children nodes
process repeat::process repeat
child nodes::child nodes
recursive traversal::recursive traversal
visit correspond::visit correspond
means visit::means visit
order traversal::order traversal
traversal recall::traversal recall
directory structure::directory structure
directory courses::directory courses
sub directories::sub directories
sub directory::sub directory
structure suppose::structure suppose
total space::total space
space occupied::space occupied
entire directory::entire directory
total spaces::total spaces
spaces required::spaces required
order corresponds::order corresponds
space required::space required
disk usage::disk usage
usage command::usage command
recursive manner::recursive manner
ordered trees::ordered trees
first child::first child
fourth child::fourth child
leftmost child::leftmost child
general trees::general trees
children node::children node
generic computation::generic computation
pre order::pre order
child note::child note
calling preorder::calling preorder
postorder traversal::postorder traversal
first thing::first thing
left sub::left sub
sub tree::sub tree
visit corresponds::visit corresponds
node visit::node visit
right sub::right sub
entire sub::entire sub
right answer::right answer
procedure works::procedure works
sub expression::sub expression
operator sitting::operator sitting
leaf corresponds::leaf corresponds
first evaluate::first evaluate
priority rules::priority rules
understood inorder::understood inorder
inorder traversal::inorder traversal
tree inorder::tree inorder
entire inorder::entire inorder
euler tour::euler tour
tour suppose::tour suppose
generic traversal::generic traversal
special case::special case
eulers tour::eulers tour
tour traversal::tour traversal
visited thrice::visited thrice
euler walk::euler walk
thing suppose::thing suppose
left bracket::left bracket
right bracket::right bracket
subtree corresponds::subtree corresponds
left brackets::left brackets
tree traversal::tree traversal
external node::external node
leaf node::leaf node
generic tree::generic tree
java details::java details
init result::init result
left unspecified::left unspecified
methods unspecified::methods unspecified
class anymore::class anymore
manner create::manner create
sub class::sub class
manner specializes::manner specializes
traversal procedure::traversal procedure
left result::left result
r.left result::r.left result
r.right result::r.right result
final value::final value
operator present::operator present
printexpression traversal::printexpression traversal
extending binarytree::extending binarytree
binarytree traversal::binarytree traversal
traversal method::traversal method
parenthesized form::parenthesized form
class binarytree::class binarytree
directories structure::directories structure
order suppose::order suppose
blue colored::blue colored
inorder traversals::inorder traversals
node tree::node tree
web today::web today
arbitrary sequences::arbitrary sequences
in order::in- order
tree suppose::tree suppose
first figure::first figure
recursively work::recursively work
sub trees::sub trees
traversal preorder::traversal preorder
unique tree::unique tree
order traversals::order traversals
child suppose::child suppose
full tree::full tree
indian tree::indian tree
single element::single element
program efficiently::program efficiently
huge number::huge number
power n-1::power n-1
absolute minimum::absolute minimum
finite number::finite number
close form::close form
form expression::form expression
stop today::stop today
traversing trees::traversing trees
traversals data::traversals data
ordered dictionaries::ordered dictionaries
search tree::search tree
simplest ways::simplest ways
ordered dictionary::ordered dictionary
dictionary functionality::dictionary functionality
functionality recall::functionality recall
recall dictionary::recall dictionary
key element::key element
element pairs::element pairs
minimum key::minimum key
maximum key::maximum key
total order::total order
ordering relation::ordering relation
function predecessor::function predecessor
dictionary keys::dictionary keys
total ordered::total ordered
successor function::successor function
trivial ways::trivial ways
list kind::list kind
order relation::order relation
smallest key::smallest key
key larger::key larger
largest key::largest key
efficient implementation::efficient implementation
ordered list::ordered list
minimum takes::minimum takes
pointer reference::pointer reference
end node::end node
predecessor takes::predecessor takes
correct position::correct position
insertion searching::insertion searching
takes lot::takes lot
array location::array location
order log::order log
searching recall::searching recall
recall insertion::recall insertion
search property::search property
children means::children means
talking out::talking out
property holds::property holds
key value::key value
property satisfied::property satisfied
property equals::property equals
search trees::search trees
implementation keys::implementation keys
keys stored::keys stored
graphic order::graphic order
alphabetic order::alphabetic order
complicates matters::complicates matters
assume keys::assume keys
entire discussion::entire discussion
duplicate key::duplicate key
duplicate keys::duplicate keys
implementing dictionary::implementing dictionary
property keys::property keys
right keys::right keys
search procedure::search procedure
equals nil::equals nil
empty tree::empty tree
recursively search::recursively search
iterative version::iterative version
recursive calls::recursive calls
current node::current node
dot left::dot left
minimum element::minimum element
wrong suppose::wrong suppose
smallest node::smallest node
leftmost leaf::leftmost leaf
node expect::node expect
expect left::expect left
last leaf::last leaf
last internal::last internal
left children::left children
sentence definition::sentence definition
procedural definition::procedural definition
entire code::entire code
successor element::successor element
successor means::successor means
key greater::key greater
key sub::key sub
hindi conversation::hindi conversation
fresh sheet::fresh sheet
successor lies::successor lies
entire tree::entire tree
null conversation::null conversation
minimum node::minimum node
non empty::non empty
right procedure::right procedure
procedure correct::procedure correct
largest node::largest node
hits null::hits null
means null::means null
successor code::successor code
order edge::order edge
insertion procedure::insertion procedure
compute predecessor::compute predecessor
similar idea::similar idea
interchange role::interchange role
alpha search::alpha search
assuming distinct::assuming distinct
distinct keys::distinct keys
fist search::fist search
search fails::search fails
null pointer::null pointer
null reference::null reference
descending order::descending order
small height::small height
height balanced::height balanced
balanced trees::balanced trees
balanced tree::balanced tree
full binary::full binary
tree provided::tree provided
random permutation::random permutation
ascending order::ascending order
bad tree::bad tree
good tree::good tree
huge height::huge height
tree height::tree height
height tree::height tree
bad order::bad order
insert elements::insert elements
random variable::random variable
variable means::variable means
minimum values::minimum values
expected value::expected value
random variables::random variables
modify child::modify child
essentially parent::essentially parent
parent pointer::parent pointer
pointer parent::pointer parent
case sequence::case sequence
deletion procedure::deletion procedure
random order::random order
deletion today::deletion today
computing successor::computing successor
computing predecessor::computing predecessor
tree today::tree today
easiest case::easiest case
case node::case node
part abd::part abd
child point::child point
3rd case::3rd case
largest element::largest element
delete operation::delete operation
deletion operation::deletion operation
2nd case::2nd case
successor predecessor::successor predecessor
tree case::tree case
pseudocode predecessor::pseudocode predecessor
right tree::right tree
in-order traversal::in-order traversal
5th node::5th node
left suppose::left suppose
root key::root key
right place::right place
out things::out things
print out::print out
good method::good method
tree base::tree base
base sorting::base sorting
sorting procedure::sorting procedure
in-order tree::in-order tree
tree work::tree work
atleast order::atleast order
todays class::todays class
bst sorting::bst sorting
final diagram::final diagram
sorted sequence::sorted sequence
bring backs::bring backs
element inserted::element inserted
variable recall::variable recall
variable takes::variable takes
permutation compute::permutation compute
3rd permutation::3rd permutation
huge quantity::huge quantity
tree obtained::tree obtained
expected height::expected height
induce permutations::induce permutations
simpler argument::simpler argument
permutations divided::permutations divided
average times::average times
previous setting::previous setting
setting recall::setting recall
average call::average call
small round::small round
coming inside::coming inside
first triangle::first triangle
darker triangle::darker triangle
original tree::original tree
unit extra::unit extra
permutations appears::permutations appears
inserting keys::inserting keys
appearing times::appearing times
insert keys::insert keys
first key::first key
permutations put::permutations put
recurrence relation::recurrence relation
previous points::previous points
fairly sophisticated::fairly sophisticated
previous values::previous values
sum equals::sum equals
previous expression::previous expression
simplify things::simplify things
sum inside::sum inside
harmonic series::harmonic series
draw line::draw line
harmonic sum::harmonic sum
integral part::integral part
sophisticated computation::sophisticated computation
height atleast::height atleast
atleast log::atleast log
height log::height log
average case::average case
interesting part::interesting part
constant times::constant times
class today::class today
discussed today::discussed today
quick sort::quick sort
sort today::sort today
sorting algorithm::sorting algorithm
insertion sort::insertion sort
case running::case running
sort algorithm::sort algorithm
quick algorithm::quick algorithm
small constants::small constants
additional memory::additional memory
place sorting::place sorting
good thing::good thing
large collection::large collection
algorithm falls::algorithm falls
conquer algorithms::conquer algorithms
smaller pieces::smaller pieces
divide step::divide step
lower part::lower part
higher part::higher part
combining part::combining part
conquer algorithm::conquer algorithm
pivot element::pivot element
lower half::lower half
larger part::larger part
larger array::larger array
sub array::sub array
stopped decrementing::stopped decrementing
sense culprits::sense culprits
orange part::orange part
means return::means return
left half::left half
right half::right half
procedure takes::procedure takes
taking order::taking order
done utmost::done utmost
memory space::memory space
loops put::loops put
statement executed::statement executed
student conversation::student conversation
complete quick::complete quick
initial call::initial call
previous procedure::previous procedure
initial part::initial part
demarcating lines::demarcating lines
larger half::larger half
upper half::upper half
half separately::half separately
true means::true means
loop forever::loop forever
loop stop::loop stop
break statement::break statement
entire partition::entire partition
partition procedure::partition procedure
additional copies::additional copies
space created::space created
single array::single array
sort procedure::sort procedure
sort takes::sort takes
elements end::elements end
equal halves::equal halves
median lets::median lets
elements ended::elements ended
equal parts::equal parts
written theta::written theta
inter change::inter change
elements equals::elements equals
part lets::part lets
basically theta::basically theta
half split::half split
skewed split::skewed split
n-1 elements::n-1 elements
upper part::upper part
smallest element::smallest element
thing happened::thing happened
back anymore::back anymore
elements change::elements change
change out::change out
out suppose::out suppose
first stage::first stage
tenth means::tenth means
largest number::largest number
largest guy::largest guy
base two::base two
times log::times log
strange manner::strange manner
constant fractions::constant fractions
argue log::argue log
constant fraction::constant fraction
formal analysis::formal analysis
analysis starting::analysis starting
unlucky cases::unlucky cases
unlucky case::unlucky case
lucky case::lucky case
partition half::partition half
median element::median element
element pick::element pick
odd number::odd number
small array::small array
small arrays::small arrays
involved procedure::involved procedure
specific element::specific element
square running::square running
randomized algorithm::randomized algorithm
random choices::random choices
randomized quick::randomized quick
equal probability::equal probability
11th smallest::11th smallest
designing algorithms::designing algorithms
partitioned procedure::partitioned procedure
randomized partition::randomized partition
last location::last location
calling partition::calling partition
random choice::random choice
good question::good question
specific input::specific input
interesting thing::interesting thing
randomly selected::randomly selected
random numbers::random numbers
numbers selected::numbers selected
selected decide::selected decide
algorithm today::algorithm today
input sequence::input sequence
comparisons required::comparisons required
first partitions::first partitions
partition process::partition process
partition depending::partition depending
element lets::element lets
n-i elements::n-i elements
quantity summed::quantity summed
compute expectation::compute expectation
expectation expectations::expectation expectations
unloaded dice::unloaded dice
variable lets::variable lets
lets call::lets call
value takes::value takes
average suppose::average suppose
probability means::probability means
value two::value two
discrete values::discrete values
value summed::value summed
probability times::probability times
quantity varies::quantity varies
chosen permutation::chosen permutation
sort worst::sort worst
crucial difference::crucial difference
doing today::doing today
done today::done today
sort depends::sort depends
value today::value today
value tomorrow::value tomorrow
numbers generated::numbers generated
fixed input::fixed input
pivot lets::pivot lets
input order::input order
number choice::number choice
make things::make things
fix element::fix element
specific kinds::specific kinds
specific amount::specific amount
specific algorithm::specific algorithm
input sequences::input sequences
vast difference::vast difference
case analysis::case analysis
average today::average today
times depending::times depending
end today::end today
sort data::sort data
tree data::tree data
avl tree::avl tree
white spots::white spots
tree rooted::tree rooted
previous classes::previous classes
singleton node::singleton node
level numbers::level numbers
50th node::50th node
children differ::children differ
node height::node height
balanced property::balanced property
smallest number::smallest number
large number::large number
node suppose::node suppose
height h-2::height h-2
smaller height::smaller height
smaller number::smaller number
recurrence relationship::recurrence relationship
solve today::solve today
base conditions::base conditions
tree grows::tree grows
simple thing::simple thing
taking algorithms::taking algorithms
crude analysis::crude analysis
sharper bound::sharper bound
tighter analysis::tighter analysis
strictly larger::strictly larger
quadratic equation::quadratic equation
golden ratio::golden ratio
fibonacci relation::fibonacci relation
fibonacci number::fibonacci number
number minus::number minus
worked out::worked out
wrong thing::wrong thing
small correction::small correction
right value::right value
leaves suppose::leaves suppose
root suppose::root suppose
red dot::red dot
level starting::level starting
big difference::big difference
tree hanging::tree hanging
hanging out::hanging out
level k-1::level k-1
larger height::larger height
largest value::largest value
largest height::largest height
simple argument::simple argument
closest leaf::closest leaf
arbitrary binary::arbitrary binary
shaded part::shaded part
height imbalance::height imbalance
height balance::height balance
balance property::balance property
tree extends::tree extends
means levels::means levels
shown earlier::shown earlier
thing nodes::thing nodes
older bound::older bound
exponential number::exponential number
logarithmic height::logarithmic height
height property::height property
sharpest bound::sharpest bound
changed things::changed things
atleast half::atleast half
first levels::first levels
thinning out::thinning out
full height::full height
first edge::first edge
levels means::levels means
structural fact::structural fact
logarithmic depth::logarithmic depth
times search::times search
tree forget::tree forget
wrong recall::wrong recall
parent pointers::parent pointers
height change::height change
change appears::change appears
imbalance property::imbalance property
property suppose::property suppose
empty node::empty node
tree originally::tree originally
property violated::property violated
grand child::grand child
rotation operation::rotation operation
bit mysterious::bit mysterious
class understand::class understand
ways solving::ways solving
structural property::structural property
similar bound::similar bound
class data::class data
place put::place put
large tree::large tree
insertion process::insertion process
change means::change means
balance problem::balance problem
height problem::height problem
problem means::problem means
height imbalanced::height imbalanced
imbalanced height::imbalanced height
imbalance means::imbalance means
essentially travel::essentially travel
nodes note::nodes note
grandchild means::grandchild means
means child::means child
process today::process today
term rotation::term rotation
picture shown::picture shown
huge tree::huge tree
null tree::null tree
rotation step::rotation step
links back::links back
tree property::tree property
local reorganization::local reorganization
insertion suppose::insertion suppose
relationships suppose::relationships suppose
insertion happened::insertion happened
increased height::increased height
height remains::height remains
increased implies::increased implies
implies height::implies height
original height::original height
argument roughly::argument roughly
originally imbalanced::originally imbalanced
final thing::final thing
big piece::big piece
tree properties::tree properties
imbalance happening::imbalance happening
single rotation::single rotation
constant number::constant number
tree remains::tree remains
symmetric case::symmetric case
case completely::case completely
height moved::height moved
middle key::middle key
previous rotation::previous rotation
step rotation::step rotation
double rotation::double rotation
switches loyalties::switches loyalties
compute heights::compute heights
heights height::heights height
original sub::original sub
final tree::final tree
key ended::key ended
thing uniformly::thing uniformly
heights reduced::heights reduced
rotate nodes::rotate nodes
balanced picture::balanced picture
double rotations::double rotations
actual node::actual node
successor node::successor node
unbalanced node::unbalanced node
node encountered::node encountered
perform rotations::perform rotations
ancestor nodes::ancestor nodes
valid question::valid question
imbalanced node::imbalanced node
imbalance imbalance::imbalance imbalance
imbalance happen::imbalance happen
guy decreased::guy decreased
wrong statement::wrong statement
bigger tree::bigger tree
bigger thing::bigger thing
thing height::thing height
previous case::previous case
asked earlier::asked earlier
rotation case::rotation case
insertion essentially::insertion essentially
ancestors ancestors::ancestors ancestors
spent log::spent log
imbalance occurs::imbalance occurs
requires order::requires order
spend order::spend order
swap contents::swap contents
rotations put::rotations put
entire delete::entire delete
performance guarantees::performance guarantees
first point::first point
point nodes::point nodes
search properties::search properties
multi-way search::multi-way search
student entry::student entry
key helps::key helps
search process::search process
keys sitting::keys sitting
node determine::node determine
first sub::first sub
last sub::last sub
middle sub::middle sub
consecutive keys::consecutive keys
consecutive pairs::consecutive pairs
tree searching::tree searching
last key::last key
middle child::middle child
valid node::valid node
tree multi::tree multi
important property::important property
square boxes::square boxes
numbering level::numbering level
additional properties::additional properties
properties search::properties search
log4n log4n::log4n log4n
tree lies::tree lies
key lets::key lets
order height::order height
visiting order::visiting order
branch out::branch out
right pointer::right pointer
empty space::empty space
link out::link out
place insertion::place insertion
nodes created::nodes created
sufficient space::sufficient space
made children::made children
smaller node::smaller node
key left::key left
split happening::split happening
tree increases::tree increases
lower keys::lower keys
higher keys::higher keys
split process::split process
node split::node split
split takes::split takes
recall deletion::recall deletion
deletion require::deletion require
child case::child case
problem note::problem note
point out::point out
simple case::simple case
means suppose::means suppose
sibling suppose::sibling suppose
small catch::small catch
adjacent sibling::adjacent sibling
merge node::merge node
cascading cascading::cascading cascading
child left::child left
sibling key::sibling key
conclude today::conclude today
discussion height::discussion height
operations borrowing::operations borrowing
complicated data::complicated data
fast data::fast data
implementing dictionaries::implementing dictionaries
red black::red black
trees functions::trees functions
involved process::involved process
spending fair::spending fair
fair bit::fair bit
handle insertion::handle insertion
black tree::black tree
tree subject::tree subject
red node::red node
black children::black children
additional left::additional left
external nodes::external nodes
non-external node::non-external node
original nodes::original nodes
black depth::black depth
black ancestor::black ancestor
black nodes::black nodes
key property::key property
black height::black height
nodes black::nodes black
black node::black node
red children::red children
left right::left right
children black::children black
first case::first case
children left::children left
black ancestors::black ancestors
key things::key things
red child::red child
red problem::red problem
term quiet::term quiet
reds occurring::reds occurring
red nodes::red nodes
alternate layers::alternate layers
red layer::red layer
black layer::black layer
total height::total height
figure out::figure out
turn thing::turn thing
first remember::first remember
compare key::compare key
children suppose::children suppose
unique node::unique node
combined structure::combined structure
critical property::critical property
tree node::tree node
double red::double red
first putting::first putting
black depths::black depths
consecutive reds::consecutive reds
major reasons::major reasons
tricky operation::tricky operation
predecessors suppose::predecessors suppose
red leaf::red leaf
black leaf::black leaf
remain consistence::remain consistence
node verses::node verses
entire structure::entire structure
red double::red double
easy case::easy case
tricky case::tricky case
cases corresponds::cases corresponds
simple operation::simple operation
black parent::black parent
single key::single key
door deleted::door deleted
cases happening::cases happening
black lets::black lets
node children::node children
blue triangle::blue triangle
children colored::children colored
case red::case red
scan structure::scan structure
starting picture::starting picture
tree organization::tree organization
tree sub::tree sub
black heights::black heights
black red::black red
symmetric thing::symmetric thing
height business::height business
black child::black child
root black::root black
resulting tree::resulting tree
case first::case first
tree picture::tree picture
node sitting::node sitting
clear things::clear things
assumption making::assumption making
entire black::entire black
valid thing::valid thing
takes care::takes care
last assumption::last assumption
height check::height check
case left::case left
started assumption::started assumption
child lets::child lets
tree deletion::tree deletion
thing happening::thing happening
process continued::process continued
deletion process::deletion process
last case::last case
tree reduces::tree reduces
fast procedure::fast procedure
height preserving::height preserving
last thing::last thing
understand conceptually::understand conceptually
process data::process data
extensive process::extensive process
a-b tree::a-b tree
tree differs::tree differs
coloring obeys::coloring obeys
node red::node red
red colored::red colored
colored node::colored node
black colored::black colored
tree continues::tree continues
problem remember::problem remember
left picture::left picture
previous picture::previous picture
simple rotation::simple rotation
rotation note::rotation note
red problems::red problems
right manner::right manner
side tree::side tree
rotation takes::rotation takes
tree recall::tree recall
single black::single black
side corresponds::side corresponds
initial black::initial black
trees hanging::trees hanging
rounded part::rounded part
problem moves::problem moves
remain uniform::remain uniform
nodes lets::nodes lets
parent nodes::parent nodes
process ends::process ends
tree rotation::tree rotation
trees recall::trees recall
faster process::faster process
minimum means::minimum means
a-b trees::a-b trees
generalized idea::generalized idea
children root::children root
discussion proceeds::discussion proceeds
small modifications::small modifications
insufficient space::insufficient space
median key::median key
lines disappear::lines disappear
middle path::middle path
adjacent node::adjacent node
upper node::upper node
space put::space put
space split::space split
remaining b-1keys::remaining b-1keys
valid nodes::valid nodes
a-1this quantity::a-1this quantity
deletion deletion::deletion deletion
28th node::28th node
number a-1::number a-1
floor means::floor means
symbol means::symbol means
integer round::integer round
quick summary::quick summary
taking log::taking log
key thing::key thing
large databases::large databases
disk based::disk based
based data::based data
specific value::specific value
large amount::large amount
main memory::main memory
references corresponds::references corresponds
pointer addresses::pointer addresses
memory addresses::memory addresses
huge amount::huge amount
amount data::amount data
transaction data::transaction data
bank share::bank share
share markets::share markets
million customers::million customers
suppose type::suppose type
sense secondary::sense secondary
secondary storage::secondary storage
entire search::entire search
disk verses::disk verses
big problem::big problem
disk access::disk access
read write::read write
write head::write head
disk rotates::disk rotates
starts reading::starts reading
significant fraction::significant fraction
head moving::head moving
moving determining::moving determining
seek latency::seek latency
rotation latency::rotation latency
right sector::right sector
entire sector::entire sector
typically read::typically read
larger units::larger units
computer system::computer system
kilo bytes::kilo bytes
page setting::page setting
entire page::entire page
search structure::search structure
based algorithm::based algorithm
memory algorithm::memory algorithm
entire data::entire data
data sets::data sets
data sit::data sit
data setting::data setting
pointer business::pointer business
concern pointer::concern pointer
memory location::memory location
operation disk::operation disk
disk read::disk read
disk write::disk write
key means::key means
first fetch::first fetch
typical pattern::typical pattern
operation today::operation today
writing block::writing block
thousand lets::thousand lets
based access::based access
level trees::level trees
levels structure::levels structure
data base::data base
bytes times::bytes times
giga bytes::giga bytes
mega bytes::mega bytes
account lets::account lets
actual data::actual data
top node::top node
key lies::key lies
account data::account data
page size::page size
pointer pair::pointer pair
means leaf::means leaf
lower bound::lower bound
special kind::special kind
structure meant::structure meant
internal memory::internal memory
large value::large value
entire node::entire node
remember things::remember things
recursive search::recursive search
first find::first find
splitting nodes::splitting nodes
split nodes::split nodes
describe operation::describe operation
catch today::catch today
disk operation::disk operation
input outputs::input outputs
parse operation::parse operation
full quota::full quota
recursively travel::recursively travel
lower level::lower level
first root::first root
step split::step split
lets show::lets show
place suppose::place suppose
full lets::full lets
addition key::addition key
crossing ripple::crossing ripple
ripple effect::ripple effect
splitting process::splitting process
single pass::single pass
potential disadvantages::potential disadvantages
doing deletion::doing deletion
earlier procedure::earlier procedure
successful merge::successful merge
cascading effect::cascading effect
pass delete::pass delete
delete procedure::delete procedure
tree make::tree make
keys suppose::keys suppose
lets skip::lets skip
situation happening::situation happening
bads key::bads key
spending lot::spending lot
node lots::node lots
pointer moments::pointer moments
things happening::things happening
delete happening::delete happening
significant trouble::significant trouble
large sequence::large sequence
long sequence::long sequence
things alternating::things alternating
sibling node::sibling node
right back::right back
pass operation::pass operation
first pass::first pass
blocks read::blocks read
small extension::small extension
based accesses::based accesses
setting data::setting data
case study::case study
pattern searching::pattern searching
pattern matching::pattern matching
english alphabet::english alphabet
things provide::things provide
exact matching::exact matching
matching problem::matching problem
approximate manner::approximate manner
means occurrences::means occurrences
text editing::text editing
information retrieval::information retrieval
big application::big application
bio informatics::bio informatics
large database::large database
protein sequence::protein sequence
naive method::naive method
mismatch right::mismatch right
fourth position::fourth position
space complexity::space complexity
additional space::additional space
index appropriately::index appropriately
huge document::huge document
solution today::solution today
complexity today::complexity today
pattern string::pattern string
position text::position text
exact procedure::exact procedure
complete match::complete match
split pattern::split pattern
mix pattern::mix pattern
disjoint occurrence::disjoint occurrence
knuth-morris-pratt algorithm::knuth-morris-pratt algorithm
famous algorithm::famous algorithm
mismatch occurs::mismatch occurs
information obtained::information obtained
shift forward::shift forward
location i-1::location i-1
part matches::part matches
shifted pattern::shifted pattern
part match::part match
pattern right::pattern right
right shift::right shift
largest smallest::largest smallest
pick suppose::pick suppose
mismatch happened::mismatch happened
key observation::key observation
useless shift::useless shift
reasonable value::reasonable value
longest proper::longest proper
proper suffix::proper suffix
contiguous parts::contiguous parts
suffix proper::suffix proper
suffix means::suffix means
means suffix::means suffix
entire text::entire text
proper subset::proper subset
subset means::subset means
strictly smaller::strictly smaller
out length::out length
longest suffix::longest suffix
suffix match::suffix match
longest match::longest match
additional congestion::additional congestion
1th character::1th character
mismatch happening::mismatch happening
tricky definition::tricky definition
smallest extent::smallest extent
mismatches happening::mismatches happening
right extent::right extent
make shift::make shift
7th position::7th position
matches happen::matches happen
guy matches::guy matches
pattern h11::pattern h11
right suppose::right suppose
11th position::11th position
matching part::matching part
minimum shift::minimum shift
shift occurs::shift occurs
maximum shift::maximum shift
minimum amount::minimum amount
longest prefix::longest prefix
shorter prefix::shorter prefix
argue correctness::argue correctness
beta suppose::beta suppose
kmp algorithm::kmp algorithm
algorithm missed::algorithm missed
happen suppose::happen suppose
missed occurrence::missed occurrence
guy mismatched::guy mismatched
alpha characters::alpha characters
length alpha::length alpha
alpha matches::alpha matches
definition alpha::definition alpha
longer prefix::longer prefix
longer suffix::longer suffix
correct value::correct value
character long::character long
input string::input string
first mismatch::first mismatch
remain matched::remain matched
position note::position note
shift function::shift function
potential match::potential match
comparisons put::comparisons put
unsuccessful comparisons::unsuccessful comparisons
unsuccessful comparison::unsuccessful comparison
text types::text types
successful comparisons::successful comparisons
red line::red line
successful comparison::successful comparison
back track::back track
track happening::track happening
comparison results::comparison results
compute array::compute array
proper prefix::proper prefix
potential value::potential value
subset proper::subset proper
proper suffixes::proper suffixes
entire string::entire string
candidate value::candidate value
square roughly::square roughly
taking computing::taking computing
previous value::previous value
nice idea::nice idea
right idea::right idea
text suppose::text suppose
pattern match::pattern match
pattern matches::pattern matches
match student::match student
simple algorithm::simple algorithm
modulo fact::modulo fact
plain version::plain version
space sufficient::space sufficient
last topic::last topic
suffix trees::suffix trees
matching patterns::matching patterns
patterns finding::patterns finding
pattern appears::pattern appears
failure function::failure function
pattern speeded::pattern speeded
brute force::brute force
force method::force method
algorithm searches::algorithm searches
arbitrary text::arbitrary text
good situation::good situation
large piece::large piece
small pattern::small pattern
collected works::collected works
million characters::million characters
characters large::characters large
previous kmp::previous kmp
lower case::lower case
case characters::case characters
ordered alphabetically::ordered alphabetically
first level::first level
first characters::first characters
first character::first character
word suppose::word suppose
sitting inside::sitting inside
array points::array points
waste space::waste space
list ordered::list ordered
alphabetical order::alphabetical order
first nodes::first nodes
link list::link list
list sitting::list sitting
word beginning::word beginning
alphabet size::alphabet size
smaller alphabet::smaller alphabet
larger alphabet::larger alphabet
insert bed::insert bed
square node::square node
circular node::circular node
longer change::longer change
case total::case total
space requirement::space requirement
first word::first word
word begins::word begins
long chain::long chain
total size::total size
word matching::word matching
matching find::matching find
first occurrence::first occurrence
instance appears::instance appears
distinct words::distinct words
sell stock::sell stock
buy stock::buy stock
bear occurs::bear occurs
bid bid::bid bid
initial text::initial text
gene database::gene database
separate notion::separate notion
special character::special character
defined boundaries::defined boundaries
trie first::trie first
standard trie::standard trie
resulting node::resulting node
single thing::single thing
compressed trie::compressed trie
node doesn::node doesn
single character::single character
simple suppose::simple suppose
nodes don::nodes don
problem completely::problem completely
longer label::longer label
label inside::label inside
store labels::store labels
6th word::6th word
sub string::sub string
contiguous part::contiguous part
nodes number::nodes number
times number::times number
deletion happen::deletion happen
compressed type::compressed type
parent edge::parent edge
subtle reason::subtle reason
start searching::start searching
done suppose::done suppose
multiple times::multiple times
simple data::simple data
implementation details::implementation details
things out::things out
web search::web search
web pages::web pages
search engine::search engine
trie typically::trie typically
google doesn::google doesn
generic search::generic search
occurrence list::occurrence list
urls pages::urls pages
occurrence lists::occurrence lists
boolean queries::boolean queries
queries corresponds::queries corresponds
set operation::set operation
stop words::stop words
internet routers::internet routers
32-bit number::32-bit number
type google.com::type google.com
iit delhi::iit delhi
delhi address::delhi address
routing done::routing done
address written::address written
links coming::links coming
routing tables::routing tables
pattern started::pattern started
biological data::biological data
suffix tree::suffix tree
starting position::starting position
words recall::words recall
words order::words order
order number::order number
order length::order length
typically small::typically small
doing suffixes::doing suffixes
compact representation::compact representation
storing labels::storing labels
big labels::big labels
end position::end position
single text::single text
edge labels::edge labels
mutual parts::mutual parts
common part::common part
original alphabet::original alphabet
longest path::longest path
label matches::label matches
edge running::edge running
order summation::order summation
path beginning::path beginning
complicated algorithm::complicated algorithm
total complexity::total complexity
means building::means building
completely essential::completely essential
thousand times::thousand times
entire sub-tree::entire sub-tree
last side::last side
pattern data::pattern data
data compression::data compression
compression today::compression today
file compression::file compression
doing data::doing data
unique shell::unique shell
man ascii::man ascii
bit code::bit code
fixed-length encoding::fixed-length encoding
fixed length::fixed length
idea today::idea today
bits required::bits required
fixed-length coding::fixed-length coding
characters occur::characters occur
coding screen::coding screen
lesser number::lesser number
lesser memory::lesser memory
variable-length coding::variable-length coding
longer sequences::longer sequences
characters java::characters java
java is1::java is1
length encoding::length encoding
choose1 bit::choose1 bit
represents java::represents java
single bit::single bit
variable length::variable length
length decoding::length decoding
retrieve java::retrieve java
java suppose::java suppose
length codes::length codes
prevent ambiguities::prevent ambiguities
encoding satisfies::encoding satisfies
prefix rule::prefix rule
encoding arising::encoding arising
codes satisfy::codes satisfy
code words::code words
code word::code word
left edge::left edge
right edge::right edge
ended midway::ended midway
character corresponds::character corresponds
first statement::first statement
encoded text::encoded text
code satisfies::code satisfies
long piece::long piece
total length::total length
encoding abracadabra::encoding abracadabra
character suppose::character suppose
tree number::tree number
total external::total external
external weighted::external weighted
weighted path::weighted path
path length::path length
external path::external path
minimum total::minimum total
total weighted::total weighted
minimum length::minimum length
encoded message::encoded message
message minimum::message minimum
red boxes::red boxes
smallest value::smallest value
option .we::option .we
nodes left::nodes left
only1 bit::only1 bit
right thing::right thing
final trie::final trie
previous code::previous code
algorithm compute::algorithm compute
characters suppose::characters suppose
smallest frequencies::smallest frequencies
characters frequencies::characters frequencies
algorithm behaves::algorithm behaves
minimum quantity::minimum quantity
tree computed::tree computed
length computed::length computed
optimum tree::optimum tree
fact suppose::fact suppose
lowest weights::lowest weights
weighted external::weighted external
remaining tree::remaining tree
node weight::node weight
minimum weighted::minimum weighted
green tree::green tree
blue total::blue total
previous algorithm::previous algorithm
bigger black::bigger black
bigger blue::bigger blue
optimal case::optimal case
statement true::statement true
lowest frequencies::lowest frequencies
lowest weight::lowest weight
number suppose::number suppose
higher weight::higher weight
smallest weight::smallest weight
smallest weights::smallest weights
problem reduces::problem reduces
done priority::done priority
priority queues::priority queues
paradigms data::paradigms data
queues today::queues today
priority queue::priority queue
queue abstract::queue abstract
thing today::thing today
binary heap::binary heap
subsequent classes::subsequent classes
multi user::multi user
user computer::user computer
multiple users::multiple users
submit jobs::submit jobs
job arrives::job arrives
average waiting::average waiting
srpt rule::srpt rule
remaining processing::remaining processing
processor schedules::processor schedules
smallest job::smallest job
job finishes::job finishes
smallest jobs::smallest jobs
running job::running job
unfinished job::unfinished job
completely finished::completely finished
srpt policies::srpt policies
type supports::type supports
first operation::first operation
minimum operation::minimum operation
smallest priority::smallest priority
priority priority::priority priority
largest priority::largest priority
made sense::made sense
minimum processing::minimum processing
delete min::delete min
min operation::min operation
delete main::delete main
main operation::main operation
minimum priority::minimum priority
min differs::min differs
basic operations::basic operations
container classes::container classes
queue ranks::queue ranks
totally ordered::totally ordered
order deletion::order deletion
reusable form::reusable form
comparator objects::comparator objects
comparator object::comparator object
comparator abstract::comparator abstract
include methods::include methods
unsorted sequence::unsorted sequence
sequence recall::sequence recall
insert last::insert last
insert operation::insert operation
end irrespective::end irrespective
increasing priorities::increasing priorities
straight sitting::straight sitting
case minimum::case minimum
insert lets::insert lets
right position::right position
case insert::case insert
order end::order end
sequence priority::sequence priority
queues find::queues find
discreet event::discreet event
event simulation::event simulation
building block::building block
priority element::priority element
structure properties::structure properties
node level::node level
nodes level::nodes level
last levels::last levels
left fill::left fill
heap property::heap property
case priority::case priority
lone child::lone child
left filled::left filled
larger priority::larger priority
smaller priority::smaller priority
root element::root element
inequality holds::inequality holds
integer hope::integer hope
equals log::equals log
node parent::node parent
node thirteen::node thirteen
tree links::tree links
parent child::parent child
child relationships::child relationships
implicitly maintained::implicitly maintained
left shift::left shift
equally simple::equally simple
increment operation::increment operation
heap suppose::heap suppose
lesser priority::lesser priority
higher priority::higher priority
lower priority::lower priority
move twelve::move twelve
inserted last::inserted last
slight colored::slight colored
colored path::colored path
inserted element::inserted element
priority lesser::priority lesser
highest element::highest element
move elements::move elements
first claim::first claim
pink color::pink color
color nodes::color nodes
heap properties::heap properties
guy heap::guy heap
trees rooted::trees rooted
suitable modification::suitable modification
heapify procedure::heapify procedure
procedure heap::procedure heap
heapify remember::heapify remember
whichever node::whichever node
node heapify::node heapify
crucial part::crucial part
heapify works::heapify works
works heapify::works heapify
correctly violated::correctly violated
property heap::property heap
property valid::property valid
colored nodes::colored nodes
path suppose::path suppose
net result::net result
heapify step::heapify step
priority node::priority node
heap heapify::heap heapify
node assuming::node assuming
child sub::child sub
larger heap::larger heap
quick runtime::quick runtime
runtime analysis::runtime analysis
height order::height order
node heap::node heap
element moved::element moved
invoking heapify::invoking heapify
eventually satisfied::eventually satisfied
looked today::looked today
today insert::today insert
root minimum::root minimum
binary heaps::binary heaps
class recall::class recall
critical properties::critical properties
repeated insertions::repeated insertions
build operation::build operation
heap sort::heap sort
children element::children element
empty slot::empty slot
taking care::taking care
class heapify::class heapify
min procedure::min procedure
simple minded::simple minded
minded method::minded method
repeated insertion::repeated insertion
heap bottom::heap bottom
arbitrary locations::arbitrary locations
implementing heaps::implementing heaps
individual leaves::individual leaves
heaps bottom::heaps bottom
smaller child::smaller child
run heapify::run heapify
heapify operation::heapify operation
doing heapify::doing heapify
larger heapify::larger heapify
children swapped::children swapped
heapify continues::heapify continues
build heap::build heap
heap procedure::heap procedure
right order::right order
running heapify::running heapify
necessarily required::necessarily required
entire build::entire build
heapify sub::heapify sub
sub routine::sub routine
prove correctness::prove correctness
induction claim::induction claim
induction statement::induction statement
induction step::induction step
minded approach::minded approach
class takes::class takes
case order::case order
heap takes::heap takes
swaps required::swaps required
times summation::times summation
crude upper::crude upper
equals half::equals half
completes analysis::completes analysis
smaller heaps::smaller heaps
larger heaps::larger heaps
procedure repeatedly::procedure repeatedly
smaller element::smaller element
min steps::min steps
steps requires::steps requires
place sort::place sort
space starting::space starting
initial array::initial array
order sitting::order sitting
property validated::property validated
heap furnace::heap furnace
swapping heap::swapping heap
children twenty::children twenty
means swap::means swap
heap anymore::heap anymore
remaining part::remaining part
element left::element left
running times::running times
heap operations::heap operations
step process::step process
heap reduces::heap reduces
kind log::kind log
insertion repeated::insertion repeated
takes total::takes total
leaf elements::leaf elements
two-step thing::two-step thing
root location::root location
root heapify::root heapify
recap today::recap today
element sitting::element sitting
directly access::directly access
procedure today::procedure today
crucial operations::crucial operations
additional node::additional node
insert procedure::insert procedure
forget heap::forget heap
typical operations::typical operations
find min::find min
insert takes::insert takes
min operations::min operations
insert operations::insert operations
ways heap::ways heap
sorted sequences::sorted sequences
unsorted sequences::unsorted sequences
sorting sorting::sorting sorting
computers love::computers love
sorting numbers::sorting numbers
requires attention::requires attention
requires consideration::requires consideration
good algorithms::good algorithms
sorting occur::sorting occur
data sorted::data sorted
efficient recall::efficient recall
computation geometry::computation geometry
computer graphics::computer graphics
sorting algorithms::sorting algorithms
algorithm design::algorithm design
design techniques::design techniques
people adopt::people adopt
requires comparisons::requires comparisons
lower bounds::lower bounds
selection sort::selection sort
design paradigm::design paradigm
sub problems::sub problems
conquer step::conquer step
smaller parts::smaller parts
original problem::original problem
combine step::combine step
sorting problem::sorting problem
merge sort::merge sort
division done::division done
equal sub::equal sub
floor elements::floor elements
arbitrary collection::arbitrary collection
merge step::merge step
swapping elements::swapping elements
division step::division step
conquer thing::conquer thing
merge sorted::merge sorted
upper index::upper index
mid point::mid point
conquer steps::conquer steps
array .sort::array .sort
merger sort::merger sort
part sorted::part sorted
merge proceed::merge proceed
merge algorithm::merge algorithm
resulting sequence::resulting sequence
sequence whichever::sequence whichever
continue building::continue building
element sequence::element sequence
sort call::sort call
first half::first half
doing divisions::doing divisions
parent calling::parent calling
sorted list::sorted list
blue oval::blue oval
sort sequences::sort sequences
trivial case::trivial case
trivial merge::trivial merge
merge sequence::merge sequence
sort calls::sort calls
blocks correspond::blocks correspond
sorted sequenences::sorted sequenences
sequences put::sequences put
smaller sequences::smaller sequences
things left::things left
front elements::front elements
sequences finishes::sequences finishes
copying requires::copying requires
create sequences::create sequences
arbitrary values::arbitrary values
understood merge::understood merge
merge set::merge set
mirror image::mirror image
split part::split part
units essentially::units essentially
merges require::merges require
length two::length two
basically sequences::basically sequences
search merges::search merges
recurrence relations::recurrence relations
pervious points::pervious points
smaller inputs::smaller inputs
conquer kind::conquer kind
part suppose::part suppose
original thing::original thing
sub problem::sub problem
problem size::problem size
size factor::size factor
general denote::general denote
trivial problem::trivial problem
initial condition::initial condition
sort problem::sort problem
solving recurrences::solving recurrences
repeated substation::repeated substation
substation method::substation method
substitution method::substitution method
solving recurrence::solving recurrence
master method::master method
fourth method::fourth method
recursion tree::recursion tree
repeated substitution::repeated substitution
substitution step::substitution step
pattern basically::pattern basically
simple recurrence::simple recurrence
upper bounded::upper bounded
num sum::num sum
numbers written::numbers written
method substitute::method substitute
expand substitute::expand substitute
sufficient number::sufficient number
java implementation::java implementation
sorting integers::sorting integers
sort object::sort object
method requires::method requires
tow objects::tow objects
essentially boolean::essentially boolean
sequence comparator::sequence comparator
class sequence::class sequence
call sort::call sort
sort sort::sort sort
doing removing::doing removing
conquer paradigm::conquer paradigm
sorting today::sorting today
bucket sort::bucket sort
sorting heap::sorting heap
bubble sort::bubble sort
radix sort::radix sort
actual structure::actual structure
people provided::people provided
comparator function::comparator function
sort people::sort people
number system::number system
sorting first::sorting first
base form::base form
radix sorting::radix sorting
comparing bits::comparing bits
comparing numbers::comparing numbers
alphanumeric strings::alphanumeric strings
binary numbers::binary numbers
radix exchange::radix exchange
exchange sort::exchange sort
numbers represented::numbers represented
binary first::binary first
fixed representation::fixed representation
leftmost bit::leftmost bit
bit first::bit first
first suppose::first suppose
first number::first number
top sub::top sub
bottom sub::bottom sub
bits number::bits number
original collection::original collection
combined step::combined step
array ignoring::array ignoring
n-bit numbers::n-bit numbers
bits log::bits log
b-bit numbers::b-bit numbers
verifying weather::verifying weather
side equals::side equals
left hand::left hand
quick sorting::quick sorting
bit numbers::bit numbers
distinct numbers::distinct numbers
solve recurrence::solve recurrence
negative numbers::negative numbers
positive numbers::positive numbers
first split::first split
wrote order::wrote order
partitioning algorithm::partitioning algorithm
scan indices::scan indices
indices exchanged::indices exchanged
step suppose::step suppose
first bit::first bit
significant bit::significant bit
algorithms partition::algorithms partition
recursively sort::recursively sort
sub arrays::sub arrays
fixed quantity::fixed quantity
bottom half::bottom half
array based::array based
scheme depending::scheme depending
implementing radix::implementing radix
sort quick::sort quick
huge numbers::huge numbers
rightmost bit::rightmost bit
numbers based::numbers based
magic happening::magic happening
table sort::table sort
order remains::order remains
remains unchanged::remains unchanged
unchanged suppose::unchanged suppose
colored blue::colored blue
array post::array post
post sorted::post sorted
stable sorting::stable sorting
table sorting::table sorting
smaller appears::smaller appears
leftmost position::leftmost position
sorting remember::sorting remember
corrective relative::corrective relative
latest step::latest step
change anymore::change anymore
smaller key::smaller key
larger key::larger key
add sub::add sub
sub sequent::sub sequent
sequent steps::sequent steps
larger keys::larger keys
keys appearing::keys appearing
bigger number::bigger number
sorting ensures::sorting ensures
subsequent steps::subsequent steps
right end::right end
left end::left end
decimal numbers::decimal numbers
man passes::man passes
stable manner::stable manner
exchange radix::exchange radix
partition anymore::partition anymore
binary form::binary form
bit suppose::bit suppose
sorting scheme::sorting scheme
numbers essentially::numbers essentially
works suppose::works suppose
fourth number::fourth number
list end::list end
maintain stability::maintain stability
first bucket::first bucket
straight radix::straight radix
in-place sorting::in-place sorting
auxiliary data::auxiliary data
operations replaceelement::operations replaceelement
sort in-place::sort in-place
array merge::array merge
in-place quick::in-place quick
comparison base::comparison base
comparison based::comparison based
numbers suppose::numbers suppose
comparison function::comparison function
comparison operation::comparison operation
algorithm works::algorithm works
comparative functions::comparative functions
anymore comparison::anymore comparison
path ends::path ends
finite criteria::finite criteria
deterministic algorithm::deterministic algorithm
argument applies::argument applies
compare lets::compare lets
complicated objects::complicated objects
factorial permutations::factorial permutations
factorial leaves::factorial leaves
forward thing::forward thing
transitive property::transitive property
tree decision::tree decision
decision based::decision based
factorial height::factorial height
farthest leaf::farthest leaf
furthest leaf::furthest leaf
sort doesn::sort doesn
comparisons based::comparisons based
based sorting::based sorting
sorting data::sorting data
graphs today::graphs today
start talking::start talking
basic definition::basic definition
graph abstract::graph abstract
graph data::graph data
type today::type today
red circles::red circles
blue lines::blue lines
term connect::term connect
unordered pair::unordered pair
pairs mentioned::pairs mentioned
model circuits::model circuits
model networks::model networks
transportation networks::transportation networks
communication networks::communication networks
typically student::typically student
student day::student day
play cs201::play cs201
cs201 programming::cs201 programming
programming sleep::programming sleep
cs201 cycles::cs201 cycles
directed graph::directed graph
graphs directed::graphs directed
directed graphs::directed graphs
undirected graphs::undirected graphs
ordered pair::ordered pair
first vertex::first vertex
simple lecture::simple lecture
undirected graph::undirected graph
adjacent vertices::adjacent vertices
equivalent ways::equivalent ways
vertices equals::vertices equals
consecutive vertices::consecutive vertices
construct examples::construct examples
paths suppose::paths suppose
simple path::simple path
last vertices::last vertices
graph connected::graph connected
common mistake::common mistake
mistake connected::mistake connected
wrong terminology::wrong terminology
sub graph::sub graph
resulting thing::resulting thing
end points::end points
connected component::connected component
connected graph::connected graph
graph suppose::graph suppose
connected components::connected components
connected sub::connected sub
carefully suppose::carefully suppose
original graph::original graph
connected anymore::connected anymore
connected componenent::connected componenent
complete graph::complete graph
n22 pairs::n22 pairs
times nc2::times nc2
chose two::chose two
minimum elements::minimum elements
elements connected::elements connected
degree two::degree two
repetition sir::repetition sir
edge coming::edge coming
true statement::true statement
edges equals::edges equals
leaf good::leaf good
path relating::path relating
text books::text books
contradiction suppose::contradiction suppose
lets remove::lets remove
graph disconnected::graph disconnected
earlier claim::earlier claim
question suppose::question suppose
simple exercise::simple exercise
spanning tree::spanning tree
graph includes::graph includes
fault tolerance::fault tolerance
bridges koenigsberg::bridges koenigsberg
pragal river::pragal river
nice thing::nice thing
river flowing::river flowing
black bar::black bar
starting point::starting point
koenigsberg problem::koenigsberg problem
euler proved::euler proved
edges don::edges don
multi set::multi set
multi graph::multi graph
eulerian tour::eulerian tour
starting vertex::starting vertex
euler theorem::euler theorem
fresh edge::fresh edge
odd degrees::odd degrees
uninteresting part::uninteresting part
regular methods::regular methods
positional container::positional container
regular positional::regular positional
container swap::container swap
swap method::swap method
returns number::returns number
vertices numedges::vertices numedges
numedges number::numedges number
edges vertices::edges vertices
method returns::method returns
edges directededges::edges directededges
directed edges::directed edges
enumerating edges::enumerating edges
iterator undirectededges::iterator undirectededges
undirected edges::undirected edges
edges incident::edges incident
incident edges::incident edges
graph incident::graph incident
edges entering::edges entering
out incident::out incident
end point::end point
outdegree indegree::outdegree indegree
edges coming::edges coming
vertex outdegree::vertex outdegree
edges leaving::edges leaving
method areadjacent::method areadjacent
boolean value::boolean value
directed edge::directed edge
mixed graphs::mixed graphs
mixed graph::mixed graph
problem setting::problem setting
traffic network::traffic network
undirected edge::undirected edge
update method::update method
change remove::change remove
set direction::set direction
method depending::method depending
represent graphs::represent graphs
graphs data::graphs data
representing graphs::representing graphs
edge list::edge list
adjacency list::adjacency list
adjacency matrix::adjacency matrix
matrix data::matrix data
simplest data::simplest data
blue vertices::blue vertices
red arcs::red arcs
flight numbers::flight numbers
edge recall::edge recall
recall corresponds::recall corresponds
airport boston::airport boston
references pointers::references pointers
instance suppose::instance suppose
vertex suppose::vertex suppose
vertex dfw::vertex dfw
edges suppose::edges suppose
out vertices::out vertices
container operations::container operations
tool list::tool list
list isempty::list isempty
empty replaceelement::empty replaceelement
edges takes::edges takes
method vertices::method vertices
unsorted lists::unsorted lists
similarly insertedge::similarly insertedge
remove vertex::remove vertex
last operation::last operation
location corresponds::location corresponds
location vertex::location vertex
vertexes adjacent::vertexes adjacent
vertices adjacent::vertices adjacent
keeping track::keeping track
structure require::structure require
matrix implementation::matrix implementation
previous data::previous data
order degree::order degree
storage location::storage location
typically number::typically number
out adjacency::out adjacency
incoming edges::incoming edges
outgoing edges::outgoing edges
storing edges::storing edges
storing edge::storing edge
edge information::edge information
storing information::storing information
starting airport::starting airport
information suppose::information suppose
flight number::flight number
ending airports::ending airports
double arrow::double arrow
doubly length::doubly length
arrow points::arrow points
edges edges::edges edges
out edges::out edges
out degree::out degree
out list::out list
out adjacent::out adjacent
level idea::level idea
common degree::common degree
degree information::degree information
matrix representation::matrix representation
simple representation::simple representation
binary entries::binary entries
entries bits::entries bits
round depending::round depending
false means::false means
simple implementation::simple implementation
vertex means::vertex means
matrix structure::matrix structure
structure augments::structure augments
list structure::list structure
list recall::list recall
edge augmenting::edge augmenting
static graphs::static graphs
right data::right data
frequent operation::frequent operation
adding vertices::adding vertices
times required::times required
dimensional array::dimensional array
two-dimensional arrays::two-dimensional arrays
dimensional arrays::dimensional arrays
major form::major form
easy task::easy task
simple edge::simple edge
squared space::squared space
standard implementation::standard implementation
graph searching::graph searching
searching algorithms::searching algorithms
graph search::graph search
search algorithm::search algorithm
systematic manner::systematic manner
organized manner::organized manner
assuming adjacency::assuming adjacency
list algorithm::list algorithm
algorithm implementation::algorithm implementation
discussing graph::discussing graph
common algorithm::common algorithm
typically perform::typically perform
first search::first search
discussing breadth::discussing breadth
today breadth::today breadth
search makes::search makes
initial distance::initial distance
first round::first round
unit find::unit find
simple graph::simple graph
minor question::minor question
grey vertices::grey vertices
grey signifies::grey signifies
white means::white means
means undiscovered::means undiscovered
first picture::first picture
vertex black::vertex black
color grey::color grey
grey color::grey color
colored grey::colored grey
colored black::colored black
first color::first color
queue color::queue color
right neighbours::right neighbours
white neighbour::white neighbour
white neighbours::white neighbours
labels signify::labels signify
shortest path::shortest path
manner shortly::manner shortly
maximum distance::maximum distance
predecessor vertex::predecessor vertex
vertex grey::vertex grey
suitable label::suitable label
dequeue operation::dequeue operation
separate arrays::separate arrays
arrays indexed::arrays indexed
spending constant::spending constant
degree times::degree times
executed degree::executed degree
executed order::executed order
white vertex::white vertex
bfs bfs::bfs bfs
source vertex::source vertex
bfs tree::bfs tree
vertices vpi::vertices vpi
dotted edges::dotted edges
dark edges::dark edges
solid edges::solid edges
shortest label::shortest label
predecessor information::predecessor information
solid lines::solid lines
edge entering::edge entering
solid line::solid line
line entering::line entering
lines form::lines form
previous examples::previous examples
largest level::largest level
number label::number label
tree edges::tree edges
adjacent levels::adjacent levels
small mistake::small mistake
previous level::previous level
wont count::wont count
multiple edges::multiple edges
edges leading::edges leading
levels zeroth::levels zeroth
zeroth level::zeroth level
vertex lets::vertex lets
label level::label level
predecessor edges::predecessor edges
-connected components::-connected components
-bipartite graphs::-bipartite graphs
applying breadth::applying breadth
apply breadth::apply breadth
search recall::search recall
components question::components question
counts vertexes::counts vertexes
standard things::standard things
starting doing::starting doing
distance label::distance label
component number::component number
search starting::search starting
easier set::easier set
small thought::small thought
last root::last root
root vertex::root vertex
total turning::total turning
total vertices::total vertices
entire graph::entire graph
breadth first::breadth first
array work::array work
list representation::list representation
vertices numbered::vertices numbered
vertices number::vertices number
direct correspondence::direct correspondence
bipartite graphs::bipartite graphs
bipartite graph::bipartite graph
equals null::equals null
standard setting::standard setting
graphs find::graphs find
settings question::settings question
lines levels::lines levels
arbitrary vertex::arbitrary vertex
jump levels::jump levels
brown edges::brown edges
red edges::red edges
graph bipartite::graph bipartite
level suppose::level suppose
componental graph::componental graph
simplify matters::simplify matters
alternate levels::alternate levels
edge exits::edge exits
graphs suppose::graphs suppose
odd cycle::odd cycle
general proof::general proof
taking alternate::taking alternate
non bipartiteness::non bipartiteness
valid point::valid point
simply level::simply level
keeping level::keeping level
number business::number business
number level::number level
continue clear::continue clear
formal statement::formal statement
path means::path means
computer network::computer network
information travels::information travels
predecessor means::predecessor means
recall predecessor::recall predecessor
vertex sitting::vertex sitting
simple application::simple application
vertices maximum::vertices maximum
vertices means::vertices means
equals length::equals length
hard quantity::hard quantity
defined maximum::defined maximum
right information::right information
disconnected graph::disconnected graph
diameter greater::diameter greater
level diameter::level diameter
search data::search data
depth first::depth first
photogenic memory::photogenic memory
direction south::direction south
backtracks backtracks::backtracks backtracks
option left::option left
find cheese::find cheese
call depth::call depth
graph sittings::graph sittings
start backtracking::start backtracking
options left::options left
small simple::small simple
list implementation::list implementation
label options::label options
incrementing unnecessarily::incrementing unnecessarily
edge left::edge left
white vertices::white vertices
initial color::initial color
node black::node black
first neighbor::first neighbor
forward tree::forward tree
unique edge::unique edge
vertices starting::vertices starting
start vertex::start vertex
edges form::edges form
sub graphs::sub graphs
dfs tree::dfs tree
actual notion::actual notion
rooted tree::rooted tree
graph right::graph right
natural parent::natural parent
child relationship::child relationship
child siblings::child siblings
green edges::green edges
back edges::back edges
front edges::front edges
back edge::back edge
front edge::front edge
red edge::red edge
level difference::level difference
important point::important point
backtrack means::backtrack means
defined dfs::defined dfs
tree edge::tree edge
red dotted::red dotted
graph depth::graph depth
classes tree::classes tree
dfs classifies::dfs classifies
search means::search means
means breadth::means breadth
search classifies::search classifies
graphs things::graphs things
implement depth::implement depth
complicated thing::complicated thing
thing stacks::thing stacks
search involve::search involve
doffs dfs::doffs dfs
dfs dfs::dfs dfs
visited dfs::visited dfs
sir predecessor::sir predecessor
predecessor sir::predecessor sir
magic right::magic right
line program::line program
minutes telling::minutes telling
search visits::search visits
call terminates::call terminates
dfs suppose::dfs suppose
process terminates::process terminates
juts visited::juts visited
arrays arrival::arrays arrival
previous thing::previous thing
reached vertex::reached vertex
left vertex::left vertex
start dfs::start dfs
guy doesn::guy doesn
launch dfs::launch dfs
dfs today::dfs today
search today::search today
edge connected::edge connected
connected recall::connected recall
small piece::small piece
code depth::code depth
dfs procedure::dfs procedure
adjacent nodes::adjacent nodes
careful analysis::careful analysis
assumed graph::assumed graph
computation finishes::computation finishes
local variable::local variable
longer list::longer list
pointer reached::pointer reached
dot data::dot data
dot node::dot node
braces ends::braces ends
global array::global array
finished dfs::finished dfs
doing dfs::doing dfs
recursive program::recursive program
call finishes::call finishes
implement dfs::implement dfs
current pointer::current pointer
stores return::stores return
return address::return address
sixth assignment::sixth assignment
departure times::departure times
questions suppose::questions suppose
edge suppose::edge suppose
ancestor descendant::ancestor descendant
descendant relationship::descendant relationship
picture essentially::picture essentially
tree path::tree path
ancestor dissonant::ancestor dissonant
reason agreed::reason agreed
means remove::means remove
removal disconnects::removal disconnects
bridge edge::bridge edge
edge connectivity::edge connectivity
link fails::link fails
remain connected::remain connected
disconnected components::disconnected components
measuring liability::measuring liability
edge sir::edge sir
fast pardon::fast pardon
graph remains::graph remains
edge remove::edge remove
resulting graph::resulting graph
last edge::last edge
cycle connected::cycle connected
search suppose::search suppose
backtracking means::backtracking means
back tacking::back tacking
blue tree::blue tree
remaining piece::remaining piece
blue edges::blue edges
green edge::green edge
proper descendent::proper descendent
descendent includes::descendent includes
proper ancestor::proper ancestor
means parent::means parent
permitted order::permitted order
edges starting::edges starting
information recursively::information recursively
doing recursively::doing recursively
running dfs::running dfs
minimum arrival::minimum arrival
smallest arrival::smallest arrival
lets give::lets give
connectivity procedure::connectivity procedure
dfs thing::dfs thing
procedure eventually::procedure eventually
eventually recall::eventually recall
arrival times::arrival times
arrival counter::arrival counter
counter suitably::counter suitably
arrival value::arrival value
dfs calls::dfs calls
equal minimum::equal minimum
dbe equals::dbe equals
equals minimum::equals minimum
equals arrival::equals arrival
write abort::write abort
end gracefully::end gracefully
edge starting::edge starting
arrival numbers::arrival numbers
arrival number::arrival number
minor things::minor things
total running::total running
sophisticated procedures::sophisticated procedures
graph problems::graph problems
complicated problem::complicated problem
planar graph::planar graph
discrete math::discrete math
compete graph::compete graph
initial thing::initial thing
sophisticated algorithm::sophisticated algorithm
non planar::non planar
non-planar graphs::non-planar graphs
planar graphs::planar graphs
vertex connectivity::vertex connectivity
vertex connected::vertex connected
computer failures::computer failures
link failures::link failures
computer breaks::computer breaks
cut vertex::cut vertex
graphs differ::graphs differ
interesting happening::interesting happening
adjacent means::adjacent means
thing adjacent::thing adjacent
vertex adjacent::vertex adjacent
departure numbers::departure numbers
visit start::visit start
first depth::first depth
out breadth::out breadth
similar thing::similar thing
search require::search require
discussing depth::discussing depth
clever manner::clever manner
visited array::visited array
colors wow::colors wow
deeper black::deeper black
easy bold::easy bold
dash dash::dash dash
dash dotted::dash dotted
pointed out::pointed out
pen moves::pen moves
blue edge::blue edge
sir sketch::sir sketch
sketch pen::sketch pen
pen sir::pen sir
nice picture::nice picture
forward edge::forward edge
brown edge::brown edge
term backward::term backward
backward edge::backward edge
cross edge::cross edge
clear tree::clear tree
single ten::single ten
ten vertex::ten vertex
cross edges::cross edges
draw picture::draw picture
actual thing::actual thing
tail first::tail first
verses departure::verses departure
verses arrival::verses arrival
depart form::depart form
arrive oops::arrive oops
edge great::edge great
ancestors descendant::ancestors descendant
descendant relationships::descendant relationships
starting node::starting node
remaining edges::remaining edges
cycle great::cycle great
back means::back means
cycle means::cycle means
point great::point great
edge means::edge means
order vertices::order vertices
largest departure::largest departure
largest side::largest side
higher departure::higher departure
edge remains::edge remains
proof theorem::proof theorem
single back::single back
acyclic graph::acyclic graph
lets order::lets order
decreasing departure::decreasing departure
topological sort::topological sort
linearly order::linearly order
vertices right::vertices right
maximum departure::maximum departure
total set::total set
assigning arrival::assigning arrival
directed acyclic::directed acyclic
graphs arise::graphs arise
combinational circuits::combinational circuits
graphs model::graphs model
longer application::longer application
connected means::connected means
strongly connected::strongly connected
term ordered::term ordered
pair pair::pair pair
sufficient right::sufficient right
weakly connected::weakly connected
right definition::right definition
natural question::natural question
dfs starting::dfs starting
argument clear::argument clear
dfs visit::dfs visit
borrow ideas::borrow ideas
engineering iit::engineering iit
graphs recall::graphs recall
strong connectivity::strong connectivity
connectivity means::connectivity means
vertices lets::vertices lets
first starting::first starting
path deepest::path deepest
reverse edges::reverse edges
fetch change::fetch change
function dfs::function dfs
adjacency edges::adjacency edges
inadjacency edges::inadjacency edges
academic exercise::academic exercise
undirected dfs::undirected dfs
lower arrival::lower arrival
big deal::big deal
smaller arrival::smaller arrival
easy requirement::easy requirement
modify dfs::modify dfs
sub word::sub word
word sub::word sub
generic definition::generic definition
modified dfs::modified dfs
dfs returns::dfs returns
edge forward::edge forward
thing note::thing note
neighboring vertices::neighboring vertices
initial value::initial value
started dfs::started dfs
xyz equals::xyz equals
equal min::equal min
min computation::min computation
small problem::small problem
additional variable::additional variable
graphs checking::graphs checking
switching topics::switching topics
similar procedures::similar procedures
shortest distance::shortest distance
procedures data::procedures data
minimum spanning::minimum spanning
spanning trees::spanning trees
things tree::things tree
cycles connected::cycles connected
spanning means::spanning means
minimum weight::minimum weight
term weight::term weight
terms length::terms length
length function::length function
non-negative reals::non-negative reals
function suppose::function suppose
kilo meters::kilo meters
tree equals::tree equals
equals sum::equals sum
free tree::free tree
alternate path::alternate path
longer length::longer length
tree length::tree length
longest edge::longest edge
cycle found::cycle found
longer cycle::longer cycle
arguments proving::arguments proving
longer edge::longer edge
doing procedure::doing procedure
simply algorithm::simply algorithm
graph out::graph out
minimum edge::minimum edge
greedy algorithm::greedy algorithm
greedy means::greedy means
greedy make::greedy make
thing make::thing make
smallest length::smallest length
smallest edge::smallest edge
include edge::include edge
obtained earlier::obtained earlier
sort edges::sort edges
type greater::type greater
visited means::visited means
including edges::including edges
included edges::included edges
edges means::edges means
step takes::step takes
minimum forms::minimum forms
edges picked::edges picked
algorithm picks::algorithm picks
edge lengths::edge lengths
non distinct::non distinct
distinct case::distinct case
set differ::set differ
opt tree::opt tree
cycle formed::cycle formed
quick repetition::quick repetition
set great::set great
implies optimum::implies optimum
sets differ::sets differ
algorithm finds::algorithm finds
tree unique::tree unique
mst unique::mst unique
unique minimum::unique minimum
component connected::component connected
components reduces::components reduces
vertices names::vertices names
vertices sets::vertices sets
first class::first class
computing minimum::computing minimum
complete algorithm::complete algorithm
current set::current set
revise part::revise part
points lie::points lie
algorithm proceeds::algorithm proceeds
component reduces::component reduces
disjoint sets::disjoint sets
elements correspond::elements correspond
initial vertices::initial vertices
completed description::completed description
find return::find return
elements lie::elements lie
accurate description::accurate description
unique set::unique set
operations exist::operations exist
edges sort::edges sort
equals find::equals find
singleton vertex::singleton vertex
union operation::union operation
find operation::find operation
good data::good data
good view::good view
order size::order size
order smaller::order smaller
smaller heap::smaller heap
union find::union find
data field::data field
reference field::reference field
guys point::guys point
pointer points::pointer points
tree right::tree right
parent point::parent point
vertex list::vertex list
node recall::node recall
array suppose::array suppose
node vertex::node vertex
union takes::union takes
root nodes::root nodes
long ways::long ways
manner find::manner find
linking elements::linking elements
link make::link make
lighter tree::lighter tree
tree point::tree point
lighter point::lighter point
guy point::guy point
induction good::induction good
equals max::equals max
value equals::value equals
quantity equals::quantity equals
larger number::larger number
rank rank::rank rank
rank meaning::rank meaning
shallow tree::shallow tree
make root::make root
alternative ways::alternative ways
holds true::holds true
cretin number::cretin number
height node::height node
reference update::reference update
order replay::order replay
minimum value::minimum value
things log::things log
theta log::theta log
find data::find data
find improves::find improves
path compression::path compression
future finds::future finds
drawing rest::drawing rest
nodes pointing::nodes pointing
union procedure::union procedure
procedure requires::procedure requires
requires height::requires height
future easier::future easier
directly point::directly point
root point::root point
root reference::root reference
standalone entity::standalone entity
adjutancy list::adjutancy list
vertex belongs::vertex belongs
algorithm kruskal::algorithm kruskal
first algorithm::first algorithm
discuss today::discuss today
vertex set::vertex set
break vertex::break vertex
first cut::first cut
cut recall::cut recall
necessarily distinct::necessarily distinct
assume edge::assume edge
cut belongs::cut belongs
edge length::edge length
mst mst::mst mst
edges added::edges added
smaller tree::smaller tree
mind game::mind game
algorithm exploits::algorithm exploits
simple fact::simple fact
algorithm work::algorithm work
first partition::first partition
root verses::root verses
proof effectively::proof effectively
assumed edge::assumed edge
remaining vertices::remaining vertices
complement side::complement side
adjacent edges::adjacent edges
edge incident::edge incident
find out::find out
complement insert::complement insert
min heap::min heap
remove element::remove element
min takes::min takes
bad data::bad data
information related::information related
add takes::add takes
write log::write log
small order::small order
find mine::find mine
initial vertex::initial vertex
initial heap::initial heap
vertex root::vertex root
root equals::root equals
dot insert::dot insert
dot empty::dot empty
dot find::dot find
min equals::min equals
edge dot::edge dot
loop clear::loop clear
delete log::delete log
minimum label::minimum label
update information::update information
decrease priority::decrease priority
priority decrease::priority decrease
delete find::delete find
label array::label array
dot decease::dot decease
decease priority::decease priority
spending degree::spending degree
single source::single source
source shortest::source shortest
length corresponds::length corresponds
fourth option::fourth option
simple problem::simple problem
simple matter::simple matter
ignore cycles::ignore cycles
large means::large means
exponentially varying::exponentially varying
count correctly::count correctly
top part::top part
bottom part::bottom part
paths roughly::paths roughly
path system::path system
arbitrary numbers::arbitrary numbers
clear demarcation::clear demarcation
part form::part form
shortest heap::shortest heap
heap improving::heap improving
intermediate vertices::intermediate vertices
blue path::blue path
green path::green path
path problem::path problem
adjacent vertex::adjacent vertex
non negative::non negative
denote distance::denote distance
similarly distance::similarly distance
correct distance::correct distance
actual distance::actual distance
directed length::directed length
path found::path found
found nay::found nay
nay point::nay point
vertex found::vertex found
visited vertex::visited vertex
theses vertices::theses vertices
specific vertex::specific vertex
correct shortest::correct shortest
additional argument::additional argument
upper bounds::upper bounds
tentative distances::tentative distances
tentative distance::tentative distance
infinite earlier::infinite earlier
forward algorithm::forward algorithm
set denote::set denote
actual values::actual values
numbers change::numbers change
right distance::right distance
distance labels::distance labels
lose heart::lose heart
initial values::initial values
label recall::label recall
vertex distance::vertex distance
equals infinite::equals infinite
smallest distance::smallest distance
algorithm yesterday::algorithm yesterday
mistake correct::mistake correct
dot delete::dot delete
minimum vertex::minimum vertex
complete clear::complete clear
shorter path::shorter path
dot decrease::dot decrease
heap priority::heap priority
square log::square log
summation degree::summation degree
degree log::degree log
priority operation::priority operation
operation takes::operation takes
operation corresponds::operation corresponds
computed length::computed length
root data::root data
case today::case today
negative edge::negative edge
first understand::first understand
numbers represent::numbers represent
actual shortest::actual shortest
path distances::path distances
minimum suppose::minimum suppose
path distance::path distance
operation shows::operation shows
things moves::things moves
initial composition::initial composition
shortest length::shortest length
path including::path including
including vertices::including vertices
last vertex::last vertex
induction make::induction make
vertices continue::vertices continue
vertex moves::vertex moves
out neighbors::out neighbors
earlier value::earlier value
complement minus::complement minus
path form::path form
includes vertices::includes vertices
include vertex::include vertex
path includes::path includes
covered case::covered case
blue line::blue line
path sits::path sits
longer path::longer path
smaller quantity::smaller quantity
smallest path::smallest path
label reflect::label reflect
smallest label::smallest label
label vertex::label vertex
claim true::claim true
crazy things::crazy things
reaches vertex::reaches vertex
entire path::entire path
path drawn::path drawn
right induction::right induction
path case::path case
sub vertices::sub vertices
statement continues::statement continues
path unqualified::path unqualified
basically length::basically length
negative length::negative length
length minus::length minus
negative cycle::negative cycle
length make::length make
negative lengths::negative lengths
represents currency::represents currency
currency tradings::currency tradings
global currency::global currency
currency trader::currency trader
edge reflects::edge reflects
indonesian path::indonesian path
positive cycle::positive cycle
shift increase::shift increase
brilliant idea::brilliant idea
length increases::length increases
length longer::length longer
safe side::safe side
argument break::argument break
negative edges::negative edges
thing breaks::thing breaks
thing remains::thing remains
shortest paths::shortest paths
path today::path today
lengths today::lengths today
vertex preceding::vertex preceding
maintain predecessor::maintain predecessor
finding find::finding find
null print::null print
vertex information::vertex information
information bur::information bur
predecessor edge::predecessor edge
edge connecting::edge connecting
n-1 predecessor::n-1 predecessor
previous vertex::previous vertex
specific root::specific root
path tree::path tree
unique path::unique path
edges capture::edges capture
dijkstras algorithm::dijkstras algorithm
permitting edges::permitting edges
non simple::non simple
straight line::straight line
positive length::positive length
finding simple::finding simple
gossiping kind::gossiping kind
person talks::person talks
earlier information::earlier information
original information::original information
guy talks::guy talks
first transfer::first transfer
round starts::round starts
thing simultaneously::thing simultaneously
actual transmitting::actual transmitting
edges length::edges length
property continues::property continues
hold true::hold true
correct length::correct length
things lesser::things lesser
path contradiction::path contradiction
round r-1::round r-1
double induction::double induction
induction kind::induction kind
updated simultaneously::updated simultaneously
apply induction::apply induction
valid doubt::valid doubt
pair shortest::pair shortest
algorithms scores::algorithms scores
bound nodes::bound nodes
positive edges::positive edges
factor log::factor log
today lecture::today lecture
discuss data::discuss data
simple definitions::simple definitions
computational procedure::computational procedure
programming language::programming language
language data::language data
process develop::process develop
develop data::develop data
algorithmic problem::algorithmic problem
non decreasing::non decreasing
decreasing sequence::decreasing sequence
natural numbers::natural numbers
finite length::finite length
output specification::output specification
non-decreasing sequence::non-decreasing sequence
length forms::length forms
non-decreasing numbers::non-decreasing numbers
input instance::input instance
input instances::input instances
good algorithm::good algorithm
efficient algorithm::efficient algorithm
input size::input size
small input::small input
program running::program running
varying data::varying data
larger data::larger data
varying composition::varying composition
program takes::program takes
system utility::system utility
huge overhead::huge overhead
considerable amount::considerable amount
limited set::limited set
comparison platform::comparison platform
platform means::platform means
software environment::software environment
software environments::software environments
first lecture::first lecture
general methodology::general methodology
level description::level description
earlier courses::earlier courses
algorithm doing::algorithm doing
algorithm takes::algorithm takes
maximum element::maximum element
array algorithm::array algorithm
algorithm array::algorithm array
array max::array max
natural language::natural language
high-level programming::high-level programming
programming concepts::programming concepts
if-then-else statement::if-then-else statement
current max::current max
remaining element::remaining element
current maximum::current maximum
current element::current element
loop terminates::loop terminates
usual prose::usual prose
standard numeric::standard numeric
boolean expressions::boolean expressions
assignment operator::assignment operator
equality operator::equality operator
equality relationship::equality relationship
declare methods::declare methods
takes algorithm::takes algorithm
programming construct::programming construct
index array::index array
procedure terminates::procedure terminates
value returned::value returned
function returns::function returns
object method::object method
object specifies::object specifies
analyze algorithms::analyze algorithms
primitive operations::primitive operations
primitive operation::primitive operation
low level::low level
level operation::level operation
data movement::data movement
control statement::control statement
subroutine call::subroutine call
logical operations::logical operations
e.g addition::e.g addition
non-decreasing order::non-decreasing order
output algorithm::output algorithm
first sorting::first sorting
sorting technique::sorting technique
playing game::playing game
empty hand::empty hand
first card::first card
original numbers::original numbers
key key::key key
decrease index::decrease index
value j-1::value j-1
step location::step location
left arrow::left arrow
entire program::entire program
small errors::small errors
comment statement::comment statement
problem problem::problem problem
asymptotic analysis::asymptotic analysis
constant minus::constant minus
infinite bars::infinite bars
inputs size::inputs size
increasing plots::increasing plots
input increases::input increases
algorithms worst::algorithms worst
case occurs::case occurs
case average::case average
harder quantity::harder quantity
superficial details::superficial details
times squared::times squared
times ,because::times ,because
quadratic behavior::quadratic behavior
size doubles::size doubles
algorithm increases::algorithm increases
crucial point::crucial point
non-negative functions::non-negative functions
non-decreasing functions::non-decreasing functions
exist constants::exist constants
non-linear function::non-linear function
exponential scale::exponential scale
scale increases::scale increases
colored line::colored line
dotted line::dotted line
line displaced::line displaced
suitable amount::suitable amount
green line::green line
simple rule::simple rule
rule suppose::rule suppose
lower order::lower order
order terms::order terms
terms forget::terms forget
complicated function::complicated function
growing term::growing term
common error::common error
strong amount::strong amount
subsequent slides::subsequent slides
linear running::linear running
small instances::small instances
numbers sitting::numbers sitting
executed times::executed times
dominant thing::dominant thing
step mentioned::step mentioned
last step::last step
repeating computations::repeating computations
single variable::single variable
compute element::compute element
asymptotic running::asymptotic running
linear algorithm::linear algorithm
big-omega notation::big-omega notation
big-theta notation::big-theta notation
related asymptotic::related asymptotic
asymptotic notations::asymptotic notations
non-tight analogs::non-tight analogs
equal little-oh::equal little-oh
little-oh corresponds::little-oh corresponds
little-omega corresponds::little-omega corresponds
formal definition::formal definition
largest problem::largest problem
differences happening::differences happening
huge increase::huge increase
large increase::large increase
data::data
structures::structures
algorithms::algorithms
naveen::naveen
garg::garg
department::department
computer::computer
science::science
engineering::engineering
indian::indian
institute::institute
technology::technology
delhi::delhi
lecture::lecture
stacks::stacks
talk::talk
abstract::abstract
types::types
interfaces::interfaces
exceptions::exceptions
implemented::implemented
java::java
application::application
analysis::analysis
series::series
growable::growable
bit::bit
amortized::amortized
virtual::virtual
machine::machine
type::type
basically::basically
specification::specification
instances::instances
set::set
axioms::axioms
define::define
semantics::semantics
operations::operations
integer::integer
real::real
numbers::numbers
understand::understand
notion::notion
addition::addition
add::add
integers::integers
mathematics::mathematics
similarly::similarly
defined::defined
interface::interface
signature::signature
operation::operation
parameters::parameters
requires::requires
results::results
case::case
sum::sum
variable::variable
answer::answer
class::class
clear::clear
talking::talking
essentially::essentially
kinds::kinds
constructor::constructor
method::method
create::create
instance::instance
sophisticated::sophisticated
lot::lot
work::work
access::access
functions::functions
elements::elements
manipulation::manipulation
procedure::procedure
manipulate::manipulate
modify::modify
identify::identify
requirements::requirements
building::building
blocks::blocks
algorithmic::algorithmic
language::language
higher::higher
level::level
abstraction::abstraction
terms::terms
adding::adding
queues::queues
advanced::advanced
encapsulate::encapsulate
structure::structure
organized::organized
separate::separate
issues::issues
correctness::correctness
efficiency::efficiency
start::start
giving::giving
simple::simple
dynamic::dynamic
collection::collection
objects::objects
suppose::suppose
means::means
remove::remove
object::object
call::call
changing::changing
sets::sets
methods::methods
insert::insert
element::element
two::two
result::result
includes::includes
delete::delete
removes::removes
updating::updating
creating::creating
constructing::constructing
isin::isin
telling::telling
return::return
value::value
boolean::boolean
true::true
false::false
behave::behave
write::write
form::form
empty::empty
matter::matter
resulting::resulting
previous::previous
provided::provided
basic::basic
nature::nature
functionality::functionality
algorithm::algorithm
talked::talked
code::code
implementing::implementing
interested::interested
permitted::permitted
govern::govern
familiar::familiar
queue::queue
doing::doing
stack::stack
last-in-first-out::last-in-first-out
principle::principle
inserted::inserted
last::last
removed::removed
first::first
inserting::inserting
pushing::pushing
removing::removing
popping::popping
kind::kind
toys::toys
trays::trays
mess::mess
put::put
tray::tray
top::top
pop::pop
supported::supported
four::four
key::key
push::push
adds::adds
inserts::inserts
takes::takes
parameter::parameter
flag::flag
error::error
stating::stating
returns::returns
differs::differs
make::make
sense::sense
support::support
size::size
tells::tells
isempty::isempty
hope::hope
understood::understood
axiom::axiom
governs::governs
behavior::behavior
back::back
complete::complete
translate::translate
constructs::constructs
declare::declare
done::done
part::part
implementation::implementation
right::right
names::names
fact::fact
provide::provide
classes::classes
people::people
implement::implement
completely::completely
ways::ways
program::program
written::written
meet::meet
meets::meets
coding::coding
helps::helps
programming::programming
technique::technique
built-in::built-in
generic::generic
derived::derived
throws::throws
stackemptyexception::stackemptyexception
signal::signal
void::void
executed::executed
modifies::modifies
considered::considered
exception::exception
mechanisms::mechanisms
handle::handle
errors::errors
reach::reach
exceptional::exceptional
condition::condition
execution::execution
throw::throw
term::term
thrown::thrown
flow::flow
control::control
moves::moves
current::current
point::point
idea::idea
occurs::occurs
delegate::delegate
responsibility::responsibility
handling::handling
eat::eat
pizza::pizza
stomachache::stomachache
dotted::dotted
problem::problem
stomachacheexception::stomachacheexception
public::public
eatpizza::eatpizza
inside::inside
stimulate::stimulate
meeting::meeting
ta.eatpizza::ta.eatpizza
exist::exist
bunches::bunches
statements::statements
interrupt::interrupt
catch::catch
modified::modified
depends::depends
returning::returning
local::local
variables::variables
global::global
if-loop::if-loop
modifications::modifications
carried::carried
block::block
enclose::enclose
open::open
bracket::bracket
include::include
calling::calling
close::close
raised::raised
skip::skip
statement::statement
raise::raise
execute::execute
raises::raises
caught::caught
necessarily::necessarily
system.out.exception::system.out.exception
happen::happen
simulate::simulate
parent::parent
catches::catches
high::high
finally::finally
stop::stop
appearing::appearing
console::console
manner::manner
propagated::propagated
stops::stops
shown::shown
user::user
system.out.println::system.out.println
print::print
initializing::initializing
ouch::ouch
making::making
assigned::assigned
created::created
enclosed::enclosed
propagate::propagate
upwards::upwards
procedural::procedural
hierarchy::hierarchy
reaches::reaches
brackets::brackets
signify::signify
signifies::signifies
invoking::invoking
listening::listening
catching::catching
mentioned::mentioned
turn::turn
exit::exit
wrote::wrote
extends::extends
string::string
err::err
single::single
super::super
chain::chain
calls::calls
stomach::stomach
ache::ache
extending::extending
run::run
book::book
details::details
array::array
maximum::maximum
location::location
index::index
move::move
listed::listed
out::out
entire::entire
arraystack::arraystack
implements::implements
default::default
capacity::capacity
final::final
constant::constant
changed::changed
hold::hold
initially::initially
int::int
cap::cap
number::number
started::started
equals::equals
full::full
increment::increment
incremented::incremented
give::give
check::check
save::save
elem::elem
decrement::decrement
earlier::earlier
null::null
dereference::dereference
to36::to36
t::t--
deference::deference
rid::rid
lie::lie
memory::memory
private::private
member::member
taking::taking
required::required
propositional::propositional
dependent::dependent
working::working
upper::upper
bound::bound
value1024::value1024
creation::creation
allocate::allocate
large::large
waste::waste
small::small
requirement::requirement
artifact::artifact
grow::grow
needed::needed
daily::daily
stock::stock
prices::prices
price::price
day::day
span::span
consecutive::consecutive
days::days
equal::equal
inclusive::inclusive
picture::picture
counting::counting
1,2,3,4::1,2,3,4
3,4,5,6::3,4,5,6
compute::compute
i-1::i-1
i-2::i-2
moment::moment
find::find
loop::loop
incrementing::incrementing
i-k::i-k
quantity::quantity
repeat-until::repeat-until
reached::reached
determined::determined
computing::computing
repeatedly::repeatedly
comparing::comparing
times::times
worst::worst
varying::varying
n-1::n-1
total::total
running::running
question::question
closest::closest
preceding::preceding
greater::greater
computed::computed
determine::determine
5-1::5-1
quantities::quantities
easily::easily
told::told
definition::definition
larger::larger
values::values
store::store
indices::indices
bottom::bottom
compare::compare
minus::minus
bar::bar
drawn::drawn
comparison::comparison
update::update
replacing::replacing
things::things
7th::7th
recall::recall
6th::6th
found::found
d.isempty::d.isempty
d.top::d.top
computation::computation
pushed::pushed
begin::begin
executes::executes
for-loop::for-loop
order::order
iteration::iteration
filled::filled
length::length
copy::copy
original::original
rename::rename
locations::locations
increase::increase
counter::counter
strategies::strategies
adopt::adopt
tight::tight
strategy::strategy
growth::growth
additive::additive
double::double
regular::regular
space::space
unit::unit
special::special
costs::costs
units::units
copied::copied
cost::cost
behaves::behaves
enlarge::enlarge
3rd::3rd
4th::4th
pushes::pushes
fill::fill
phase::phase
pound::pound
symbol::symbol
multiplication::multiplication
operator::operator
beginning::beginning
copying::copying
2ci::2ci
phases::phases
roughly::roughly
approximately::approximately
change::change
slightly::slightly
purposes::purposes
5th::5th
analyze::analyze
spent::spent
left::left
log::log
growing::growing
linked::linked
lists::lists
looked::looked
today::today
list::list
sequences::sequences
ended::ended
differ::differ
last-in::last-in
first-out::first-out
hand::hand
first-in-first-out::first-in-first-out
joins::joins
processed::processed
rear::rear
sitting::sitting
front::front
end::end
standard::standard
enqueue::enqueue
dequeue::dequeue
similar::similar
obtained::obtained
enqueued::enqueued
added::added
thing::thing
procedures::procedures
q,w::q,w
assume::assume
remaining::remaining
cases::cases
dequeued::dequeued
circular::circular
fashion::fashion
referring::referring
blue::blue
occupied::occupied
colored::colored
0th::0th
1st::1st
2nd::2nd
effect::effect
drift::drift
moved::moved
implies::implies
deleted::deleted
f-1::f-1
accurate::accurate
stage::stage
anymore::anymore
wrap::wrap
starting::starting
side::side
refers::refers
situation::situation
located::located
step::step
ambiguity::ambiguity
resolve::resolve
ensure::ensure
pseudo::pseudo
modn::modn
pseudo-code::pseudo-code
n-f::n-f
r-f::r-f
negative::negative
setting::setting
correct::correct
positive::positive
confused::confused
disadvantage::disadvantage
fixed::fixed
increases::increases
allotted::allotted
nodes::nodes
pointers::pointers
node::node
referred::referred
head::head
tail::tail
note::note
torcezo::torcezo
permit::permit
directly::directly
pointer::pointer
accessing::accessing
rome::rome
removal::removal
place::place
connect::connect
easy::easy
diagram::diagram
newly::newly
difficult::difficult
expensive::expensive
worth::worth
introduce::introduce
double-ended::double-ended
ends::ends
singly::singly
good::good
solution::solution
doubly::doubly
sentinel::sentinel
pointing::pointing
trailer::trailer
follow::follow
port::port
send::send
header::header
dummy::dummy
mark::mark
san::san
francisco::francisco
meant::meant
independent::independent
depended::depended
fairly::fairly
correspond::correspond
deleting::deleting
corresponds::corresponds
adapter::adapter
pattern::pattern
patterns::patterns
general::general
specialize::specialize
applications::applications
contents::contents
arbitrary::arbitrary
adapt::adapt
integerarraystack::integerarraystack
suitably::suitably
cast::cast
circularly::circularly
straight::straight
forward::forward
big::big
costly::costly
reference::reference
seattle::seattle
discusses::discusses
quickly::quickly
vectors::vectors
positions::positions
arrays::arrays
vector::vector
sequence::sequence
supports::supports
indicative::indicative
rank::rank
7,11,13,19::7,11,13,19
elematrank::elematrank
replace::replace
students::students
departmental::departmental
shift::shift
moving::moving
n-2::n-2
position::position
increased::increased
sores::sores
shifting::shifting
view::view
faster::faster
retrieve::retrieve
replaceatrank::replaceatrank
chart::chart
shows::shows
complexity::complexity
showing::showing
diagrams::diagrams
newyork::newyork
insertion::insertion
17th::17th
assuming::assuming
existence::existence
nodeatrank::nodeatrank
defining::defining
shortly::shortly
next.getprev::next.getprev
prev::prev
field::field
dlnode::dlnode
next.setprev::next.setprev
prev.setnext::prev.setnext
intimated::intimated
show::show
process::process
deletion::deletion
selected::selected
march::march
improvement::improvement
hundred::hundred
concerned::concerned
implementations::implementations
require::require
supporting::supporting
based::based
efficient::efficient
removeatnode::removeatnode
insertafternode::insertafternode
stuff::stuff
hide::hide
information::information
knowing::knowing
actual::actual
intuitively::intuitively
captures::captures
stored::stored
situated::situated
fields::fields
implementer::implementer
hides::hides
relative::relative
jus::jus
datatype::datatype
query::query
asks::asks
excessive::excessive
swapelements::swapelements
swaps::swaps
replaceelement::replaceelement
insertfirst::insertfirst
insertlast::insertlast
capture::capture
linear::linear
combines::combines
inherits::inherits
multiple::multiple
inheritance::inheritance
additional::additional
atrank::atrank
rankof::rankof
middle::middle
gave::gave
cross::cross
sit::sit
ranks::ranks
wanted::wanted
leave::leave
exercise::exercise
previously::previously
zap::zap
figure::figure
learnt::learnt
concretization::concretization
inheriting::inheriting
dictionaries::dictionaries
dictionary::dictionary
binary::binary
search::search
hashing::hashing
hash::hash
table::table
collision::collision
resolution::resolution
techniques::techniques
stores::stores
bank::bank
accounts::accounts
account::account
lots::lots
wealth::wealth
balance::balance
address::address
holder::holder
transactions::transactions
wishes::wishes
continued::continued
model::model
database::database
key-element::key-element
pairs::pairs
student::student
records::records
natural::natural
entry::entry
characters::characters
uniquely::uniquely
identifies::identifies
main::main
searching::searching
container::container
findelem::findelem
settings::settings
remember::remember
crucial::crucial
nil::nil
returned::returned
unsuccessful::unsuccessful
nill::nill
mind::mind
keys::keys
equality::equality
record::record
smaller::smaller
lectures::lectures
inefficient::inefficient
predecessor::predecessor
successor::successor
organize::organize
tree::tree
red::red
black::black
trees::trees
avl::avl
b-trees::b-trees
important::important
spending::spending
java.util.dictionary::java.util.dictionary
lays::lays
java.util.map::java.util.map
subsequent::subsequent
discussions::discussions
lets::lets
5,10,7::5,10,7
databases::databases
divide::divide
conquer::conquer
design::design
future::future
applied::applied
problems::problems
narrow::narrow
range::range
sorted::sorted
increasing::increasing
decreasing::decreasing
lies::lies
lye::lye
low::low
figured::figured
repeat::repeat
recursive::recursive
read::read
lower::lower
wrong::wrong
average::average
mid::mid
staring::staring
ending::ending
mid-1::mid-1
binarysearch::binarysearch
pieces::pieces
iterative::iterative
equivalent::equivalent
happening::happening
color::color
putting::putting
do-while::do-while
halved::halved
items::items
comparisons::comparisons
desire::desire
base::base
assumed::assumed
lucky::lucky
searched::searched
spend::spend
huge::huge
difference::difference
coming::coming
sorting::sorting
sort::sort
asked::asked
caller::caller
facility::facility
phone::phone
company::company
person::person
callers::callers
digit::digit
million::million
present::present
efficiently::efficiently
unordered::unordered
traverse::traverse
decides::decides
connection::connection
modification::modification
care::care
faliable::faliable
maintain::maintain
files::files
file::file
revert::revert
transaction::transaction
system::system
administration::administration
track::track
activities::activities
rarely::rarely
removals::removals
frequently::frequently
insertions::insertions
frequent::frequent
searches::searches
rare::rare
performed::performed
decide::decide
ordered::ordered
direct::direct
mechanism::mechanism
whichever::whichever
examples::examples
big-oh::big-oh
notation::notation
deletions::deletions
discussion::discussion
ankur::ankur
9635-8904::9635-8904
capability::capability
bad::bad
wasting::wasting
turning::turning
issue::issue
excepted::excepted
users::users
wasted::wasted
mapped::mapped
hypothetical::hypothetical
friends::friends
fancy::fancy
mod::mod
depending::depending
digits::digits
infact::infact
pick::pick
function::function
2004cs10110::2004cs10110
picks::picks
clash::clash
2004cs50310::2004cs50310
arise::arise
grade::grade
shape::shape
showed::showed
deal::deal
spot::spot
concept::concept
chaining::chaining
addressing::addressing
modulo::modulo
resolved::resolved
reduces::reduces
identity::identity
sits::sits
quick::quick
recap::recap
typically::typically
regarded::regarded
reason::reason
options::options
amount::amount
points::points
maintaining::maintaining
ordering::ordering
slot::slot
mapping::mapping
universe::universe
slots::slots
m-1::m-1
rest::rest
arithmetic::arithmetic
choice::choice
choices::choices
research::research
motivate::motivate
distribute::distribute
uniformly::uniformly
map::map
collisions::collisions
distributes::distributes
ideal::ideal
random::random
puts::puts
picked::picked
randomly::randomly
probability::probability
uniform::uniform
load::load
factor::factor
divided::divided
alpha::alpha
distributing::distributing
examined::examined
denote::denote
half::half
represents::represents
brings::brings
relies::relies
critically::critically
choose::choose
designing::designing
art::art
theorem::theorem
successful::successful
walking::walking
arguing::arguing
argued::argued
appended::appended
critical::critical
prove::prove
manners::manners
summing::summing
math::math
computations::computations
ignore::ignore
intuitive::intuitive
sizes::sizes
keeping::keeping
accommodate::accommodate
attach::attach
performance::performance
deteriorate::deteriorate
10,000::10,000
wastage::wastage
continue::continue
concepts::concepts
resolving::resolving
contd::contd
probing::probing
discussing::discussing
worse::worse
famous::famous
paradox::paradox
birthday::birthday
year::year
birthdays::birthdays
non-integer::non-integer
telephone::telephone
hyphen::hyphen
treat::treat
dropped::dropped
thought::thought
converting::converting
non-integers::non-integers
convert::convert
parts::parts
compression::compression
maps::maps
1stconvert::1stconvert
bring::bring
indexed::indexed
2004sa10110::2004sa10110
randomization::randomization
minimize::minimize
popular::popular
hash-code::hash-code
converts::converts
interpret::interpret
numeric::numeric
bits::bits
reinterpret::reinterpret
long::long
bytes::bytes
chunks::chunks
eventually::eventually
possibility::possibility
ascii::ascii
words::words
english::english
letters::letters
avoid::avoid
replaced::replaced
reasons::reasons
great::great
character::character
strings::strings
polynomial::polynomial
accumulation::accumulation
coefficients::coefficients
expression::expression
evaluate::evaluate
evaluated::evaluated
1stwe::1stwe
experimental::experimental
theory::theory
observed::observed
experimentally::experimentally
study::study
favour::favour
representation::representation
forgetting::forgetting
power::power
prime::prime
preferably::preferably
principles::principles
improve::improve
experiment::experiment
non-integral::non-integral
max::max
covert::covert
multiply::multiply
converted::converted
fractional::fractional
consequence::consequence
floor::floor
round::round
rounded::rounded
nearest::nearest
multiplied::multiplied
happened::happened
jugglery::jugglery
fraction::fraction
plotted::plotted
evidence::evidence
turns::turns
fibonacci::fibonacci
significant::significant
nice::nice
ronald::ronald
knuth::knuth
covers::covers
detail::detail
multiplying::multiplying
co-prime::co-prime
generator::generator
generators::generators
congruential::congruential
seed::seed
initial::initial
generated::generated
generate::generate
universal::universal
briefly::briefly
adversary::adversary
life::life
picking::picking
imply::imply
bunch::bunch
starts::starts
midway::midway
invoke::invoke
fall::fall
storing::storing
references::references
reside::reside
residing::residing
probe::probe
suitable::suitable
modifying::modifying
determining::determining
specifies::specifies
collections::collections
guiding::guiding
rap::rap
short::short
specific::specific
advantage::advantage
slower::slower
continuous::continuous
8th::8th
11th::11th
respective::respective
tend::tend
aggregate::aggregate
clusters::clusters
checked::checked
10th::10th
12th::12th
terminates::terminates
terminate::terminate
finds::finds
tombstone::tombstone
marker::marker
encounter::encounter
encounters::encounters
ignores::ignores
continues::continues
reclaim::reclaim
tombstones::tombstones
degrades::degrades
rehash::rehash
markers::markers
offset::offset
piece::piece
distance::distance
advance::advance
jumped::jumped
orange::orange
works::works
finding::finding
cycle::cycle
divides::divides
rough::rough
arguments::arguments
formally::formally
advantages::advantages
disadvantages::disadvantages
formed::formed
steps::steps
makes::makes
trouble::trouble
continuously::continuously
8-4::8-4
8-7::8-7
unoccupied::unoccupied
distributed::distributed
scheme::scheme
assumptions::assumptions
made::made
performs::performs
schemes::schemes
search.what::search.what
probes::probes
expected::expected
hit::hit
trails::trails
expectation::expectation
praising::praising
quarters::quarters
quarter::quarter
bounding::bounding
fractions::fractions
performances::performances
discussed::discussed
root::root
children::children
argument::argument
ancestor::ancestor
grandparent::grandparent
descendents::descendents
siblings::siblings
sibling::sibling
3three::3three
ancestors::ancestors
grand::grand
family::family
leaves::leaves
upside::upside
extremities::extremities
leaf::leaf
child::child
internal::internal
associate::associate
depth::depth
height::height
degree::degree
terminologies::terminologies
represent::represent
organization::organization
electronics::electronics
divisions::divisions
rnd::rnd
division::division
purchasing::purchasing
manufacturing::manufacturing
domestic::domestic
international::international
sub-division::sub-division
sales::sales
organizational::organizational
guide::guide
chapters::chapters
overview::overview
grading::grading
environment::environment
chapter::chapter
sections::sections
exams::exams
homework::homework
programs::programs
sub-sections::sub-sections
build::build
unix::unix
windows::windows
directory::directory
1stlevel::1stlevel
sub-directories::sub-directories
sub-directory::sub-directory
assignment::assignment
definitions::definitions
draw::draw
eldest::eldest
younger::younger
reflect::reflect
convey::convey
representing::representing
meaning::meaning
attached::attached
marked::marked
subtree::subtree
construct::construct
attaching::attaching
subtrees::subtrees
and::-NONE-
introduced::introduced
2ndlevel::2ndlevel
extreme::extreme
expressions::expressions
parenthezisation::parenthezisation
parenthesized::parenthesized
line::line
decision::decision
star::star
bucks::bucks
caf::caf
paragon::paragon
fast::fast
meal::meal
coffee::coffee
terminology::terminology
concrete::concrete
count::count
leaves-1::leaves-1
leafy::leafy
atmost::atmost
cut::cut
proof::proof
obtain::obtain
pruning::pruning
branches::branches
rewrite::rewrite
rearranged::rearranged
atleast::atleast
achieves::achieves
acquires::acquires
smallest::smallest
shortest::shortest
packing::packing
filling::filling
levels::levels
minimum::minimum
zigzag::zigzag
mistake::mistake
inequality::inequality
induction::induction
satisfied::satisfied
k-1::k-1
apply::apply
hypothesis::hypothesis
rearrange::rearrange
achieved::achieved
dry::dry
1leaf::1leaf
swapping::swapping
isroot::isroot
isinternal::isinternal
isexternal::isexternal
external::external
accessor::accessor
casting::casting
treated::treated
sub-class::sub-class
described::described
center::center
links::links
link::link
unbounded::unbounded
members::members
1of::1of
1stfield::1stfield
reversals::reversals
walks::walks
traversals::traversals
walk::walk
visiting::visiting
preorder::preorder
postorder::postorder
visit::visit
post::post
clarify::clarify
paper::paper
section::section
title::title
books::books
papers::papers
publication::publication
referenced::referenced
sub::sub
reading::reading
tables::tables
8,9,10,11,12,13::8,9,10,11,12,13
traversal::traversal
listing::listing
heading::heading
arbitrarily::arbitrarily
subsection::subsection
1.1.1::1.1.1
1.1.2::1.1.2
1.1.3::1.1.3
document::document
courses::courses
directories::directories
grades::grades
subdirectory::subdirectory
spaces::spaces
perform::perform
reverse::reverse
pervious::pervious
disk::disk
usage::usage
command::command
fourth::fourth
visited::visited
leftmost::leftmost
specializes::specializes
pre::pre
v.leftchild::v.leftchild
printing::printing
printed::printed
content::content
ready::ready
evaluating::evaluating
essence::essence
arrow::arrow
direction::direction
generating::generating
incorporate::incorporate
priority::priority
rules::rules
worried::worried
visits::visits
possibilities::possibilities
inorder::inorder
traversing::traversing
euler::euler
tour::tour
viewed::viewed
eulers::eulers
thrice::thrice
touching::touching
touch::touch
touched::touched
qualify::qualify
parenthesis::parenthesis
finish::finish
path::path
init::init
unspecified::unspecified
r.left::r.left
r.right::r.right
printexpression::printexpression
binarytree::binarytree
specializing::specializing
green::green
managed::managed
recursion::recursion
plug::plug
recursively::recursively
web::web
input::input
possibly::possibly
pre::pre-
in::in-
neatly::neatly
unique::unique
worked::worked
descendants::descendants
forms::forms
remains::remains
learn::learn
combinations::combinations
rise::rise
knowledge::knowledge
suffices::suffices
sufficient::sufficient
option::option
absolute::absolute
finite::finite
finitely::finitely
simplest::simplest
excepting::excepting
relation::relation
conversation::conversation
professor::professor
precedes::precedes
trivial::trivial
largest::largest
min::min
logarithmic::logarithmic
halves::halves
trivialities::trivialities
interesting::interesting
property::property
holds::holds
hindi::hindi
satisfy::satisfy
5,5,7,8::5,5,7,8
couple::couple
features::features
doesn::doesn
lexico::lexico
graphic::graphic
alphabetic::alphabetic
permitting::permitting
unnecessarily::unnecessarily
complicates::complicates
matters::matters
duplicate::duplicate
guy::guy
forget::forget
version::version
matching::matching
continuing::continuing
dot::dot
situations::situations
leafs::leafs
expect::expect
don::don
sentence::sentence
non-empty::non-empty
lying::lying
confusion::confusion
carefully::carefully
fresh::fresh
sheet::sheet
tempted::tempted
guys::guys
easiest::easiest
claim::claim
proceed::proceed
completing::completing
remote::remote
home::home
non::non
marching::marching
pair::pair
trailing::trailing
hits::hits
closer::closer
convince::convince
edge::edge
proportional::proportional
interchange::interchange
role::role
match::match
distinct::distinct
fist::fist
fails::fails
descending::descending
harm::harm
balanced::balanced
permutation::permutation
ascending::ascending
relevant::relevant
effort::effort
factorial::factorial
depend::depend
probabilities::probabilities
switch::switch
game::game
questions::questions
permute::permute
distinguish::distinguish
trickier::trickier
abd::abd
effectively::effectively
establishing::establishing
convinced::convinced
equally::equally
preventing::preventing
violated::violated
directed::directed
covered::covered
treesuccessor::treesuccessor
mistakes::mistakes
pseudocode::pseudocode
in-order::in-order
prints::prints
todays::todays
argue::argue
treeinsert::treeinsert
bst::bst
sums::sums
backs::backs
permutations::permutations
trials::trials
experiments::experiments
easier::easier
summarize::summarize
1to::1to
cleverly::cleverly
fix::fix
restrict::restrict
attention::attention
places::places
induce::induce
occur::occur
occurring::occurring
n-i::n-i
simpler::simpler
symmetric::symmetric
law::law
compared::compared
triangle::triangle
darker::darker
.then::.then
extra::extra
product::product
appears::appears
1through::1through
n-3::n-3
multiplies::multiplies
recurrence::recurrence
expressing::expressing
substitute::substitute
equation::equation
explained::explained
non-zero::non-zero
3-1::3-1
solve::solve
scaled::scaled
cancel::cancel
rearrangement::rearrangement
cancels::cancels
simplify::simplify
simplification::simplification
dense::dense
strictly::strictly
1.i::1.i
cancelled::cancelled
n-4::n-4
n-n::n-n
denominator::denominator
n-n-1::n-n-1
harmonic::harmonic
trick::trick
employ::employ
graph::graph
rectangle::rectangle
width::width
area::area
curve::curve
limits::limits
integral::integral
shallow::shallow
report::report
logn::logn
discuss::discuss
square::square
practice::practice
constants::constants
premium::premium
falls::falls
paradigm::paradigm
partition::partition
partitioned::partitioned
break::break
combining::combining
combine::combine
partitioning::partitioning
pivot::pivot
p-1::p-1
lop::lop
j-1::j-1
decrementing::decrementing
stopped::stopped
culprits::culprits
swap::swap
exchange::exchange
swapped::swapped
immediately::immediately
crossed::crossed
job::job
boundary::boundary
decremented::decremented
utmost::utmost
in-place::in-place
pursue::pursue
loops::loops
rearranges::rearranges
demarcating::demarcating
lines::lines
separately::separately
forever::forever
met::met
copies::copies
passing::passing
ignoring::ignoring
split::split
dividing::dividing
median::median
n::NNP
mine::mine
theta::theta
omega::omega
inter::inter
decrease::decrease
decreased::decreased
exact::exact
squared::squared
writing::writing
bothering::bothering
skewed::skewed
pictorially::pictorially
figuring::figuring
tenth::tenth
percent::percent
tenths::tenths
route::route
providing::providing
strange::strange
sacrosanct::sacrosanct
spectacular::spectacular
afford::afford
hundredth::hundredth
thousandth::thousandth
millionth::millionth
formal::formal
motivation::motivation
alternate::alternate
unlucky::unlucky
2n-1::2n-1
worry::worry
scenarios::scenarios
clear-some::clear-some
odd::odd
involved::involved
struck::struck
randomized::randomized
splits::splits
versus::versus
n-10::n-10
tool::tool
generates::generates
including::including
pivots::pivots
tomorrow::tomorrow
deciding::deciding
splitting::splitting
evenly::evenly
averaging::averaging
inputs::inputs
partitions::partitions
7-1::7-1
n-7::n-7
13-1::13-1
n-13::n-13
summed::summed
expectations::expectations
roll::roll
dice::dice
outcomes::outcomes
unloaded::unloaded
throwing::throwing
recording::recording
outcome::outcome
threw::threw
billion::billion
sufficiently::sufficiently
event::event
thinking::thinking
discrete::discrete
slides::slides
varies::varies
chosen::chosen
solved::solved
beat::beat
quit::quit
knew::knew
vast::vast
white::white
spots::spots
rooted::rooted
singleton::singleton
purpose::purpose
parents::parents
heights::heights
50th::50th
properties::properties
missing::missing
absent::absent
gained::gained
minutes::minutes
proposition::proposition
h-1::h-1
h-2::h-2
relationship::relationship
conditions::conditions
solving::solving
grows::grows
reduce::reduce
h-4::h-4
h-6::h-6
h-2i::h-2i
logarithms::logarithms
2log::2log
confuse::confuse
recurrences::recurrences
crude::crude
sharper::sharper
tighter::tighter
proving::proving
redefine::redefine
minute::minute
k-2::k-2
lager::lager
appropriately::appropriately
quadratic::quadratic
roots::roots
golden::golden
ratio::ratio
sides::sides
guess::guess
precisely::precisely
correction::correction
verify::verify
2k-1::2k-1
hanging::hanging
taller::taller
shaded::shaded
band::band
contradiction::contradiction
contradict::contradict
imbalance::imbalance
proved::proved
older::older
exponential::exponential
sharpest::sharpest
pretty::pretty
rewording::rewording
thinning::thinning
thins::thins
structural::structural
intuition::intuition
encountered::encountered
flavor::flavor
grandchild::grandchild
originally::originally
window::window
rotation::rotation
mysterious::mysterious
automated::automated
rotations::rotations
retained::retained
remain::remain
unbalanced::unbalanced
culprit::culprit
imbalanced::imbalanced
travel::travel
traversed::traversed
grandchildren::grandchildren
1.is::1.is
rebalance::rebalance
performing::performing
locally::locally
reorganizing::reorganizing
reorganization::reorganization
pictures::pictures
clutter::clutter
relationships::relationships
20-14::20-14
remained::remained
repeating::repeating
rotate::rotate
maintained::maintained
restored::restored
trust::trust
switches::switches
loyalties::loyalties
reduced::reduced
traveling::traveling
restore::restore
valid::valid
identified::identified
h-3::h-3
bigger::bigger
checking::checking
2-4::2-4
guarantees::guarantees
2-3-4::2-3-4
multi-way::multi-way
d-1::d-1
generalizing::generalizing
kd-1::kd-1
finishes::finishes
finished::finished
multi::multi
boxes::boxes
numbering::numbering
log4n::log4n
log2n::log2n
branch::branch
careful::careful
wondering::wondering
wait::wait
promote::promote
promoted::promoted
disappear::disappear
decided::decided
cascade::cascade
cascades::cascades
knock::knock
violating::violating
disappeared::disappeared
imagine::imagine
arising::arising
borrow::borrow
disaster::disaster
merge::merge
jumble::jumble
adjacent::adjacent
separates::separates
separating::separating
lead::lead
cascading::cascading
log4::log4
shrink::shrink
handled::handled
conclude::conclude
borrowing::borrowing
merging::merging
complicated::complicated
helpful::helpful
understanding::understanding
fair::fair
subject::subject
non-external::non-external
clearer::clearer
handing::handing
staff::staff
quiet::quiet
reds::reds
consecutively::consecutively
layers::layers
layer::layer
1and::1and
-1you::-1you
correspondence::correspondence
exceed::exceed
combination::combination
combined::combined
ensured::ensured
ensures::ensures
depths::depths
related::related
mimic::mimic
major::major
tricky::tricky
predecessors::predecessors
consistence::consistence
verses::verses
,this::,this
door::door
formulate::formulate
expand::expand
scan::scan
2.1.1::2.1.1
reorganize::reorganize
labeled::labeled
lend::lend
coloring::coloring
business::business
assumption::assumption
justified::justified
bother::bother
neighbor::neighbor
recolor::recolor
summary::summary
2.2.2::2.2.2
completed::completed
preserving::preserving
harder::harder
conceptually::conceptually
extensive::extensive
a-b::a-b
exists::exists
obeys::obeys
primarily::primarily
concentrate::concentrate
transformation::transformation
accommodated::accommodated
continuation::continuation
affect::affect
correspondingly::correspondingly
recoloring::recoloring
wise::wise
generalized::generalized
a-1::a-1
b-1::b-1
b-a::b-a
context::context
bounds::bounds
2-3::2-3
2-5::2-5
proceeds::proceeds
repetition::repetition
fit::fit
1key::1key
insufficient::insufficient
splitted::splitted
enter::enter
a-1keys::a-1keys
b-1keys::b-1keys
rephrase::rephrase
insist::insist
b-1is::b-1is
a-1this::a-1this
corrected::corrected
2-4tree::2-4tree
borrowed::borrowed
disappears::disappears
28th::28th
merged::merged
a-2::a-2
a-2keys::a-2keys
2a-1keys::2a-1keys
a-1has::a-1has
2a-1::2a-1
concern::concern
b-tree::b-tree
plays::plays
specially::specially
extension::extension
limited::limited
addresses::addresses
share::share
markets::markets
customers::customers
history::history
secondary::secondary
storage::storage
thinks::thinks
slow::slow
accessed::accessed
rotates::rotates
sectors::sectors
sector::sector
tag::tag
seek::seek
latency::latency
positioned::positioned
page::page
byte::byte
pages::pages
kilo::kilo
measured::measured
cpu::cpu
insignificant::insignificant
ported::ported
module::module
bind::bind
translated::translated
fetch::fetch
typical::typical
omit::omit
thousand::thousand
illustrate::illustrate
giga::giga
mega::mega
years::years
bringing::bringing
limiting::limiting
didn::didn
transfer::transfer
arranging::arranging
excess::excess
2t-1::2t-1
coping::coping
describe::describe
measuring::measuring
outputs::outputs
variant::variant
resulted::resulted
parse::parse
pass::pass
quota::quota
descend::descend
counted::counted
room::room
crossing::crossing
ripple::ripple
conversation-refer::conversation-refer
potential::potential
supposed::supposed
deletes::deletes
successfully::successfully
proceeding::proceeding
snaps::snaps
action::action
illustrates::illustrates
bads::bads
answering::answering
moments::moments
highly::highly
interspersed::interspersed
alternating::alternating
vary::vary
optimization::optimization
specifically::specifically
accesses::accesses
text::text
alphabets::alphabets
alphabet::alphabet
editor::editor
occurrences::occurrences
editors::editors
browser::browser
occurrence::occurrence
versions::versions
approximate::approximate
matches::matches
texts::texts
editing::editing
retrieval::retrieval
bio::bio
informatics::informatics
nucleotides::nucleotides
gene::gene
dna::dna
bases::bases
protein::protein
naive::naive
mismatch::mismatch
losing::losing
skipped::skipped
missed::missed
multiples::multiples
sized::sized
improvements::improvements
detected::detected
matched::matched
erase::erase
shifted::shifted
mismatching::mismatching
mix::mix
disjoint::disjoint
knuth-morris-pratt::knuth-morris-pratt
restart::restart
explain::explain
prefix::prefix
substring::substring
label::label
j-i::j-i
reprocess::reprocess
suffix::suffix
determines::determines
extent::extent
semantic::semantic
miss::miss
useless::useless
observation::observation
playing::playing
acceptable::acceptable
reasonable::reasonable
h11::h11
longest::longest
proper::proper
contiguous::contiguous
subset::subset
congestion::congestion
1th::1th
p12::p12
logic::logic
meaningless::meaningless
mismatches::mismatches
capturing::capturing
aligns::aligns
perfectly::perfectly
understands::understands
shorter::shorter
beta::beta
kmp::kmp
mismatched::mismatched
violates::violates
longer::longer
agreed::agreed
establishes::establishes
calculated::calculated
designed::designed
calculation::calculation
sound::sound
shifts::shifts
broke::broke
preprocessing::preprocessing
suffixes::suffixes
candidate::candidate
summation::summation
cube::cube
i-3::i-3
i-5::i-5
zeros::zeros
potentially::potentially
confusing::confusing
plain::plain
compressed::compressed
topic::topic
preprocessed::preprocessed
failure::failure
speeded::speeded
brute::brute
force::force
processing::processing
collected::collected
shakespeare::shakespeare
veronica::veronica
preprocess::preprocess
trie::trie
bear::bear
bell::bell
bid::bid
bull::bull
buy::buy
sell::sell
alphabetically::alphabetically
word::word
reflects::reflects
built::built
bed::bed
organizing::organizing
alphabetical::alphabetical
presentation::presentation
letter::letter
begins::begins
task::task
peace::peace
detect::detect
tracing::tracing
queries::queries
basis::basis
blank::blank
blanks::blanks
boundaries::boundaries
compress::compress
collapse::collapse
collapses::collapses
labels::labels
sub-string::sub-string
subtle::subtle
leaving::leaving
google::google
retrieves::retrieves
engine::engine
urls::urls
music::music
intersection::intersection
union::union
speed::speed
eliminate::eliminate
internet::internet
routers::routers
32-bit::32-bit
google.com::google.com
nslookup::nslookup
iit::iit
routing::routing
router::router
packet::packet
packets::packets
10.27.36::10.27.36
10.27.34::10.27.34
delimiter::delimiter
biological::biological
minimized::minimized
collapsed::collapsed
compact::compact
paths::paths
concatenation::concatenation
mutual::mutual
common::common
pointed::pointed
contained::contained
dollar::dollar
breaking::breaking
exploiting::exploiting
aim::aim
edges::edges
exhausted::exhausted
extensions::extensions
essential::essential
sub-tree::sub-tree
huffman::huffman
abracadabra::abracadabra
shell::shell
man::man
fixed-length::fixed-length
encoding::encoding
encode::encode
encoded::encoded
exploit::exploit
screen::screen
lesser::lesser
transmitting::transmitting
variable-length::variable-length
infrequently::infrequently
is1::is1
just1::just1
choose1::choose1
and11::and11
as110100::as110100
as11::as11
as10::as10
decoding::decoding
decode::decode
codes::codes
is00::is00
ambiguous::ambiguous
prevent::prevent
ambiguities::ambiguities
satisfies::satisfies
rule::rule
prefixes::prefixes
unambiguous::unambiguous
represented::represented
branching::branching
drew::drew
codeword::codeword
trace::trace
also1::also1
strike::strike
trie.so::trie.so
frequency::frequency
5,b::5,b
1,d::1,d
4,2::4,2
totally::totally
saving::saving
compensate::compensate
weighted::weighted
viewing::viewing
weight::weight
weights::weights
frequencies::frequencies
message::message
.we::.we
feel::feel
reducing::reducing
by2::by2
11.now::11.now
only1::only1
gap::gap
minimums::minimums
claiming::claiming
upto::upto
huffmen::huffmen
solutions::solutions
optimum::optimum
lowest::lowest
optimal::optimal
exploited::exploited
trap::trap
developed::developed
paradigms::paradigms
scheduling::scheduling
heap::heap
heapify::heapify
submit::submit
jobs::jobs
arrives::arrives
preempted::preempted
schedule::schedule
processors::processors
resumed::resumed
policy::policy
minimizes::minimizes
waiting::waiting
srpt::srpt
stands::stands
processor::processor
schedules::schedules
interruption::interruption
preemption::preemption
unfinished::unfinished
scheduled::scheduled
period::period
policies::policies
misnomer::misnomer
priorities::priorities
reflexive::reflexive
antisymmetric::antisymmetric
transitive::transitive
reusable::reusable
comparator::comparator
comparable::comparable
unsorted::unsorted
item::item
irrespective::irrespective
discreet::discreet
simulation::simulation
dijkstra::dijkstra
simply::simply
restate::restate
lone::lone
violate::violate
leads::leads
rounding::rounding
floors::floors
conversely::conversely
thirteen::thirteen
holding::holding
implicitly::implicitly
twelve::twelve
structurally::structurally
eleven::eleven
slight::slight
highest::highest
bubbled::bubbled
violation::violation
pink::pink
reaching::reaching
heaps::heaps
invoked::invoked
correctly::correctly
constructed::constructed
net::net
mention::mention
rebuild::rebuild
due::due
runtime::runtime
efficiently.thank::efficiently.thank
repeated::repeated
creates::creates
adjust::adjust
minded::minded
individual::individual
bubble::bubble
validated::validated
exchanged::exchanged
laid::laid
routine::routine
crucially::crucially
approach::approach
differentiate::differentiate
contribute::contribute
differential::differential
completes::completes
free::free
ten::ten
nineteen::nineteen
reversed::reversed
furnace::furnace
fades::fades
smart::smart
drop::drop
drops::drops
twenty::twenty
thirty::thirty
29comes::29comes
construction::construction
two-step::two-step
bubbling::bubbling
bubbles::bubbles
computers::computers
love::love
estimated::estimated
consideration::consideration
develop::develop
oftenly::oftenly
geometry::geometry
graphics::graphics
selection::selection
analyzing::analyzing
1contains::1contains
.but::.but
guarantee::guarantee
helping::helping
deriving::deriving
.sort::.sort
merger::merger
oval::oval
sixteen::sixteen
formulas::formulas
sequenences::sequenences
append::append
noise::noise
opinion::opinion
spit::spit
mirror::mirror
image::image
4merge::4merge
get1::get1
algorithmically::algorithmically
merges::merges
relations::relations
refreshed::refreshed
describes::describes
denotes::denotes
sub-problems::sub-problems
substation::substation
substituting::substituting
noticing::noticing
patters::patters
substitution::substitution
master::master
personally::personally
ease::ease
substituted::substituted
observe::observe
bounded::bounded
num::num
tow::tow
radix::radix
bucket::bucket
persons::persons
extended::extended
alphanumeric::alphanumeric
variants::variants
examine::examine
expressed::expressed
express::express
respect::respect
row::row
rows::rows
independently::independently
subtract::subtract
subtracting::subtracting
triviled::triviled
n-bit::n-bit
pardon::pardon
sir::sir
duplicates::duplicates
20,000::20,000
b-bit::b-bit
stretch::stretch
guessing::guessing
verifying::verifying
weather::weather
cumbersome::cumbersome
repetitions::repetitions
target::target
negatives::negatives
positives::positives
employed::employed
scanning::scanning
coordinate::coordinate
sixth::sixth
exchanging::exchanging
stable::stable
rightmost::rightmost
non-sorted::non-sorted
magic::magic
rearranging::rearranging
unchanged::unchanged
threes::threes
corrective::corrective
latest::latest
interchanged::interchanged
stability::stability
sequent::sequent
preserved::preserved
decimal::decimal
passes::passes
buckets::buckets
appending::appending
exam::exam
auxiliary::auxiliary
updates::updates
replaces::replaces
cover::cover
charge::charge
rupee::rupee
money::money
comparative::comparative
stream::stream
criteria::criteria
deterministic::deterministic
applies::applies
s13::s13
rate::rate
gpa::gpa
representable::representable
decisions::decisions
consistent::consistent
farthest::farthest
furthest::furthest
achieve::achieve
graphs::graphs
permits::permits
tuple::tuple
vertices::vertices
circles::circles
vertex::vertex
drawing::drawing
circuits::circuits
component::component
circuit::circuit
cs201::cs201
resistance::resistance
networks::networks
city::city
modeled::modeled
roads::roads
connecting::connecting
intersections::intersections
transportation::transportation
communication::communication
wake::wake
mediate::mediate
play::play
sleep::sleep
dream::dream
cycles::cycles
idealistic::idealistic
meditation::meditation
undirected::undirected
carry::carry
origin::origin
destination::destination
connected::connected
degrees::degrees
incident::incident
stones::stones
pebbles::pebbles
peppules::peppules
included::included
maximal::maximal
components::components
retaining::retaining
retain::retain
componenent::componenent
forest::forest
jungle::jungle
animals::animals
nc2::nc2
n22::n22
directions::directions
chose::chose
relating::relating
facts::facts
switched::switched
disconnected::disconnected
contradicting::contradicting
spanning::spanning
network::network
cities::cities
fault::fault
tolerance::tolerance
bridges::bridges
koenigsberg::koenigsberg
germany::germany
austria::austria
pragal::pragal
river::river
flowing::flowing
island::island
bridge::bridge
land::land
postmen::postmen
brides::brides
retrace::retrace
multi-graph::multi-graph
eulerian::eulerian
lifting::lifting
pencil::pencil
redrawing::redrawing
uninteresting::uninteresting
positional::positional
numvertices::numvertices
numedges::numedges
enumeration::enumeration
iterator::iterator
iterate::iterate
directededges::directededges
enumerated::enumerated
enumerator::enumerator
enumerating::enumerating
undirectededges::undirectededges
enumerate::enumerate
entering::entering
vertexv::vertexv
opposite::opposite
indegree::indegree
outdegree::outdegree
inadjacent::inadjacent
outadjacentvertices::outadjacentvertices
areadjacent::areadjacent
endvertices::endvertices
mixed::mixed
traffic::traffic
reverses::reverses
tonnes::tonnes
adjacency::adjacency
matrix::matrix
augmented::augmented
flights::flights
airports::airports
arcs::arcs
flight::flight
airport::airport
boston::boston
jfk::jfk
dfw::dfw
lax::lax
enumerates::enumerates
insertvertex::insertvertex
insertedge::insertedge
insertdirectededge::insertdirectededge
overlapped::overlapped
removevertex::removevertex
corresponded::corresponded
vertexes::vertexes
pros::pros
cons::cons
incoming::incoming
outgoing::outgoing
regard::regard
portion::portion
mia::mia
hard::hard
optimize::optimize
entries::entries
column::column
augments::augments
augmenting::augmenting
static::static
inincidentedges::inincidentedges
outincidentedges::outincidentedges
dimensional::dimensional
extend::extend
two-dimensional::two-dimensional
preferred::preferred
systematic::systematic
breadth::breadth
bfs::bfs
rounds::rounds
maze::maze
tide::tide
unroll::unroll
unrolling::unrolling
minor::minor
neighbours::neighbours
gray::gray
grey::grey
discovered::discovered
undiscovered::undiscovered
neighbors::neighbors
knocked::knocked
invariant::invariant
entered::entered
neighbour::neighbour
aspects::aspects
infinite::infinite
assign::assign
assigning::assigning
source::source
discover::discover
reachable::reachable
vpi::vpi
dark::dark
solid::solid
darkened::darkened
arrows::arrows
skips::skips
covering::covering
wont::wont
leading::leading
zeroth::zeroth
choosing::choosing
-connected::-connected
-bipartite::-bipartite
applying::applying
bipartite::bipartite
labeling::labeling
counts::counts
selecting::selecting
numbered::numbered
remind::remind
boys::boys
girls::girls
married::married
applicants::applicants
applicant::applicant
suggestion::suggestion
jump::jump
brown::brown
i.e::i.e
componental::componental
non-bipartite::non-bipartite
bipartition::bipartition
exits::exits
ultimately::ultimately
aspect::aspect
reboot::reboot
cluttered::cluttered
test::test
bipartiteness::bipartiteness
expanded::expanded
distances::distances
hops::hops
travels::travels
forwarded::forwarded
jumps::jumps
diameter::diameter
impossible::impossible
interrupting::interrupting
approximation::approximation
dfs::dfs
meaningful::meaningful
mouse::mouse
carrot::carrot
cat::cat
cheese::cheese
squares::squares
mice::mice
explore::explore
fully::fully
backtrack::backtrack
photogenic::photogenic
east::east
south::south
west::west
north::north
doubt::doubt
stuck::stuck
blocked::blocked
backtracks::backtracks
sees::sees
explored::explored
cell::cell
progress::progress
homerun::homerun
clap::clap
formalize::formalize
exploring::exploring
artificial::artificial
sittings::sittings
backtracking::backtracking
goal::goal
applicable::applicable
stamping::stamping
progressing::progressing
stamp::stamp
unvisited::unvisited
circumstances::circumstances
traveled::traveled
backtracked::backtracked
redraw::redraw
correspondences::correspondences
slash::slash
redrawn::redrawn
stick::stick
classified::classified
emanate::emanate
imp::imp
concluded::concluded
classifies::classifies
non-white::non-white
involve::involve
doffs::doffs
convenience::convenience
suited::suited
launched::launched
marks::marks
terminated::terminated
ensuring::ensuring
launch::launch
timestamps::timestamps
juts::juts
arrival::arrival
departure::departure
identifying::identifying
counters::counters
that1::that1
retrieving::retrieving
braces::braces
heavily::heavily
distinction::distinction
arrivals::arrivals
descendant::descendant
dissonant::dissonant
depart::depart
granted::granted
capital::capital
one-edge::one-edge
disconnects::disconnects
connectivity::connectivity
functioning::functioning
messages::messages
liability::liability
differently::differently
tracking::tracking
tacking::tacking
descendent::descendent
interest::interest
deepest::deepest
emanates::emanates
dbe::dbe
abort::abort
gracefully::gracefully
arr::arr
significance::significance
liner::liner
planar::planar
semester::semester
plane::plane
intersect::intersect
cleak::cleak
compete::compete
crosses::crosses
runs::runs
non-planar::non-planar
failures::failures
breaks::breaks
benefit::benefit
quote::quote
departed::departed
elaborate::elaborate
clever::clever
nt::nt
colors::colors
wow::wow
realize::realize
tragic::tragic
deeper::deeper
bold::bold
dash::dash
pen::pen
realizing::realizing
light::light
sketch::sketch
watching::watching
categories::categories
classify::classify
backward::backward
subjective::subjective
relate::relate
arrive::arrive
oops::oops
departures::departures
arranged::arranged
closes::closes
acyclic::acyclic
streets::streets
worrying::worrying
encountering::encountering
topological::topological
linearly::linearly
produce::produce
dag::dag
combinational::combinational
pulses::pulses
strongly::strongly
weakly::weakly
suggested::suggested
ideas::ideas
hint::hint
strong::strong
inadjacency::inadjacency
academic::academic
gammon::gammon
remarked::remarked
happy::happy
sufficiency::sufficiency
descendance::descendance
difficulty::difficulty
feature::feature
loosely::loosely
composed::composed
neighboring::neighboring
xyz::xyz
mins::mins
switching::switching
topics::topics
panning::panning
lengths::lengths
non-negative::non-negative
reals::reals
wire::wire
wires::wires
meters::meters
face::face
reduction::reduction
mst::mst
analyse::analyse
kruskal::kruskal
greedy::greedy
greed::greed
objective::objective
dfso::dfso
pfso::pfso
bsfo::bsfo
dictate::dictate
greedily::greedily
impure::impure
intrusion::intrusion
proofs::proofs
1,less::1,less
majors::majors
.because::.because
opt::opt
identical::identical
g1to::g1to
listen::listen
abc::abc
fgh::fgh
revise::revise
existing::existing
krukal::krukal
detecting::detecting
disjoints::disjoints
reflected::reflected
belong::belong
description::description
forming::forming
initialised::initialised
initialize::initialize
initialized::initialized
unions::unions
comfortable::comfortable
suggest::suggest
qutei::qutei
singletons::singletons
elect::elect
leader::leader
representations::representations
state::state
linking::linking
lighter::lighter
heavier::heavier
loss::loss
generality::generality
scenario::scenario
login::login
alternative::alternative
converse::converse
cretin::cretin
grater::grater
updated::updated
replay::replay
immaterial::immaterial
improving::improving
improves::improves
hang::hang
opting::opting
recompute::recompute
metric::metric
standalone::standalone
entity::entity
adjutancy::adjutancy
belongs::belongs
prim::prim
notions::notions
cuts::cuts
complement::complement
connects::connects
brought::brought
eye::eye
arriving::arriving
exploits::exploits
rapidly::rapidly
length1::length1
messy::messy
hndi::hndi
noting::noting
remembers::remembers
clean::clean
processes::processes
initialization::initialization
decease::decease
strikingly::strikingly
ton::ton
tons::tons
termination::termination
stand::stand
2,3::2,3
feasible::feasible
practical::practical
impractical::impractical
exponentially::exponentially
diamonds::diamonds
diamond::diamond
particles::particles
estimate::estimate
caliber::caliber
demarcation::demarcation
intermediate::intermediate
abbreviated::abbreviated
triple::triple
sssp::sssp
nay::nay
concretize::concretize
circle::circle
theses::theses
tentative::tentative
rush::rush
grained::grained
invariance::invariance
complements::complements
lose::lose
heart::heart
clue::clue
belonging::belonging
yesterday::yesterday
notes::notes
decreases::decreases
hazard::hazard
revising::revising
signifying::signifying
composition::composition
connotation::connotation
clime::clime
establish::establish
w,u1::w,u1
captured::captured
touches::touches
accounting::accounting
wrongly::wrongly
concentrating::concentrating
accounted::accounted
claming::claming
crazy::crazy
clam::clam
02-35::02-35
qualified::qualified
qualification::qualification
unqualified::unqualified
argues::argues
pronounced::pronounced
currency::currency
tradings::tradings
trader::trader
rupees::rupees
indonesian::indonesian
profit::profit
incur::incur
brilliant::brilliant
delta::delta
safe::safe
reconvert::reconvert
plenty::plenty
millions::millions
updation::updation
pred::pred
transferred::transferred
bur::bur
20-16::20-16
dijkstras::dijkstras
gossiping::gossiping
talks::talks
promptly::promptly
communicates::communicates
mates::mates
intern::intern
communicate::communicate
gossiped::gossiped
sends::sends
gathers::gathers
simultaneously::simultaneously
inmates::inmates
v-s::v-s
00-43::00-43
induct::induct
r-1::r-1
v,w::v,w
apparent::apparent
apsp::apsp
mlog::mlog
scores::scores
nlog::nlog
introduction::introduction
notations::notations
outline::outline
computational::computational
specifications::specifications
output::output
1,20,908,909,100000,1000000000::1,20,908,909,100000,1000000000
non-decreasing::non-decreasing
describing::describing
actions::actions
infinitely::infinitely
measures::measures
measure::measure
clock::clock
stopwatch::stopwatch
utility::utility
millis::millis
limitations::limitations
overhead::overhead
considerable::considerable
platforms::platforms
platform::platform
hardware::hardware
software::software
machines::machines
environments::environments
methodology::methodology
syntax::syntax
mixture::mixture
high-level::high-level
if-then-else::if-then-else
semicolon::semicolon
colon::colon
compiler::compiler
conveys::conveys
structured::structured
usual::usual
prose::prose
param::param
param2::param2
args::args
primitive::primitive
movement::movement
subroutine::subroutine
logical::logical
e.g::e.g
inspect::inspect
cards::cards
dealt::dealt
card::card
jack::jack
queen::queen
2-n::2-n
1_j-1::1_j-1
4,5,6,7::4,5,6,7
for3::for3
comment::comment
asymptotic::asymptotic
bars::bars
1size::1size
plot::plot
monotonically::monotonically
plots::plots
differences::differences
distribution::distribution
superficial::superficial
,because::,because
factors::factors
doubles::doubles
fold::fold
limit::limit
explains::explains
o-notation::o-notation
non-linear::non-linear
scale::scale
y-axis::y-axis
x-axis::x-axis
displaced::displaced
intercept::intercept
7n-3::7n-3
fastest::fastest
caution::caution
1,000,000::1,000,000
1,000,000n::1,000,000n
late::late
0-10::0-10
accumulator::accumulator
11,12,13,14::11,12,13,14
0,1,2,3::0,1,2,3
dominant::dominant
accumulating::accumulating
reuse::reuse
freely::freely
big-omega::big-omega
big-theta::big-theta
sandwiched::sandwiched
little-oh::little-oh
little-omega::little-omega
non-tight::non-tight
analogs::analogs
analogy::analogy
big::big-
defines::defines
400n::400n
20n::20n
hour::hour
3600seconds::3600seconds
