structures and algorithms
today some basic
terminology regarding data
definitions an algorithm
organize the data
structures an array
array or list
list for instance
lot more data
solve that problem
process develop data
develop data structures
organizing the data
problem okay whats
whats an algorithmic
problem an algorithmic
specification a sorted
sorted non decreasing
non decreasing sequence
sequence of natural
numbers of non
non zero finite
completely specified input
input which meet
meet the specification
sequence of sorted
non decreasing numbers
form a input
infinitely many input
describing the actions
infinitely many algorithms
algorithms for solving
notion of good
right so good
efficient is good
takes less memory
working with right
measures of efficiency
spending with running
analyzing this space
spend in worrying
efficiency of algorithms
function of input
input becomes ten
ten times larger
size of input
algorithm you implement
algorithm which means
means you write
write a program
language you run
run the program
program with varying
varying data sets
smaller some larger
larger data sets
kinds varying composition
right and clock
utility like system
current time millis
millis to clock
out how good
good your algorithms
call an experimental
limitations so put
implement the algorithm
mine how good
good your algorithm
set of inputs
number of instances
run your experimental
experimental small set
set of instances
algorithm is taking
right by platform
hardware and software
imagine different machines
machines would make
machines in fact
users were working
make a difference
develop the general
develop a high
high level description
describing an algorithm
description to det
out the running
system a methodology
evaluate the efficency
give a high
call a pseudo
doing this algorithm
takes an array
stores an integer
find the maximum
mixture of natural
high level programming
level programming construct
things are required
program is doing
doing is starting
starting its keeping
maximum variable maximum
variable called current
current maximum element
element the element
element under consideration
update current max
return current max
doing pseudo code
computer its pseudo
coveys the idea
idea it coveys
coveys the concepts
structured pseudo code
code most structured
structured than usual
standard numerical numeric
numerical numeric boolean
numeric boolean expression
quality operator quality
operator quality relationship
relationship in java
parameter it takes
kinds of programming
make a call
method the argument
low level operation
level operation examples
operation examples data
examples data movement
routine call return
operations or logical
call primitive operations
inspect the pseudo
pseudo code count
count the number
number of primitive
sequence of numbers
non decreasing order
input any set
set of numbers
make an output
right your algorithm
algorithm should sort
sort the numbers
produce the sequence
running time depend
sorted these numbers
algorithm using right
first sorting technique
game of cards
strategy you follow
picking up set
set of cards
start with empty
hand you pick
hand already lets
cards and inserted
code for insertion
understand i give
input an array
array of integers
input the output
input output specification
variables two indices
element i put
insert the key
loop its starts
value it starts
value j minus
found the right
find an element
loop will continue
key this loop
loop will terminate
reach i equals
case that means
moved every thing
insert the element
shifting the element
shifted to right
element once step
insert the right
place i shift
shift nine right
right one step
location becomes empty
put him key
find the right
element and insert
analyze this algorithm
algorithm okay put
arrow please make
make a correction
two primitive operation
reflect just represent
counting the number
number of times
operations is executed
executed is done
done n times
two then assign
roughly n times
minus one times
done n minus
times lets forget
sub j reflects
reflects the counts
counts the number
shift an element
shift two elements
counting that quantity
reach this part
checking this condition
condition so first
reach this condition
condition t subject
condition is sum
operation please correct
statement is part
loop is done
right t sub
quantity which depends
instances not problem
problem right difference
sorting the instance
instance is set
numbers the sequence
difference t sub
sub j makes
sorted t sub
compare the element
order the number
insert is smaller
element the fourth
case t sub
sub j equal
equal j note
kind n squared
case the running
times n minus
right the behavior
talking of asymptotic
case the total
times some constant
minus some constant
linear time algorithm
case would expect
right an average
worst and average
input i suppose
interest in sorting
sorting n numbers
worst case define
define the worst
case is defined
infinitely many bars
give as values
compute worst case
case best case
case average case
create a plot
case an average
topic monotonically increasing
monotonically increasing parts
size the input
increases the size
algorithm will increase
size become larger
easiest to work
work with worst
bound it tells
long your algorithm
case many algorithms
algorithms um occurs
algorithm is close
right in fact
squared and worst
quantity to compete
kind of average
instances are drawn
instance is drawn
quantity to work
measure of interest
kind of thing
analyze the running
read of superficial
constant n squared
times would depend
hardware the compiler
right and show
bother about distinguish
ahs the running
size its doubles
running time increases
increases fore fold
interested in capturing
increase with increase
instance in input
big oh notation
represent the input
non negative functions
size is increases
increases the value
non decreasing functions
drawn two functions
function is read
function this function
examples would clarify
non linear function
point of crossing
crossing what point
line any constant
displaces by suitable
out a constant
pick a larger
squared is big
out this things
simple rule suppose
function if fifty
fifty n log
drop all constants
constants an lower
lower order terms
terms so forget
forget the constant
drop the constant
constant an lower
minus three big
drop all lower
fastest growing term
squared n term
drop my constant
function is big
quantity this large
times n square
larger than sum
limit this quantity
times this quantity
quantity in fact
equal to fifty
provide as strong
statement is true
sub sequence slides
express the number
executed during run
algorithm which takes
operations is big
primitive operations big
input size grows
input size doubles
increase fore fold
similarly our algorithm
hierarchy this kind
square and algorithm
running time big
algorithm with running
word of caution
algorithm whose running
times n right
doing whole lot
create such algorithm
two n squared
achieved very late
large for small
two n square
array of numbers
numbers n numbers
output an array
compute each element
array a right
compute a ten
doing to compute
computing a ten
taking the value
running the index
ten this accumulator
dividing the value
accumulator with eleven
eleven twelve thirteen
twelve thirteen fourteen
right and lets
times this step
executed its executed
executed i times
minus one right
thing is done
roughly n square
executed n square
executed this step
executed n times
algorithm is big
repeating of computation
computation so hand
right the single
prefix the sum
compute ith element
finish ith run
run ith iteration
doing two steps
steps two primitive
two primitive operations
right that makes
order n times
loop is executed
linear and quadratic
log n polynomial
constant and algorithm
big omega notation
notation and big
big theta notation
notation the big
bound right function
two more related
related asymptotic notations
non tight logs
logs of big
non tight analogs
analogs of big
analogy the real
numbers when number
equal to theta
theta is equal
talk of equality
equality a functions
slides the formal
algorithms whose running
hundred n twenty
twenty n log
largest problems size
minute one hour
largest problem size
solve roughly twenty
lets say twenty
problem of size
solve the problem
thirty sixth hundred
algorithm still large
large in increase
solve for problem
millions of years
behavior that bothers
stop this lecture
notation and terminology
data structures
learn today
basic terminology
simple definitions
computational procedure
programming language
data structure
process develop
develop data
algorithmic problem
sorted non
non decreasing
decreasing sequence
natural numbers
finite length
output specification
decreasing numbers
input instance
input instances
good algorithm
efficient algorithm
efficient efficient
input sizes
small input
algorithm running
ten times
twenty times
hundred times
measure running
efficiency running
experimental study
varying data
data sets
larger data
kinds varying
varying composition
program takes
clock watch
system utility
huge overhead
considerable amount
limited set
small set
software environment
point make
first lecture
general methodology
first develop
high level
level description
algorithm describing
det figure
environment independent
first point
pseudo code
earlier courses
algorithm doing
algorithm takes
maximum element
natural language
level programming
programming construct
keeping track
variable maximum
current max
first element
remaining element
array compare
current maximum
current element
loop terminates
simple algorithm
doing pseudo
structured pseudo
formal programming
standard numerical
numerical numeric
numeric boolean
boolean expression
assignment operator
left arrow
quality operator
operator quality
quality relationship
single equivalent
declare methods
index array
procedure terminates
return value
value return
analyze algorithms
primitive operations
low level
level operation
operation examples
examples data
data movement
control statement
routine call
call return
arithmetic operations
logical operations
code count
decreasing order
increasing order
first sorting
sorting technique
playing game
sorted order
empty hand
first card
place suppose
right place
insertion sort
original numbers
input output
sorted sequence
key key
assured insert
first place
element shifted
empty location
lets start
small mistake
lets count
primitive operation
computer system
entire program
operation done
small errors
times lets
lets forget
comment statement
subject times
total number
assignment operation
procedure takes
constant work
right difference
subject depends
instance lets
last element
fourth element
constant times
asymptotic analysis
constant minus
worst case
average case
quantity summation
suppose interest
case define
size size
compute worst
case average
inputs size
increasing parts
input increases
input size
takes lesser
upper bound
difficult quantity
average right
harder quantity
symptotonic analysis
superficial details
quadratic behavior
increases fore
algorithm increases
crucial point
algorithm increase
negative functions
decreasing functions
exist constants
linear function
exponential scale
blue line
function red
previous line
line displaces
suitable amount
simple rule
rule suppose
lower order
order terms
constant fifty
function fifty
complicated function
log squared
growing term
squared log
square log
large sum
common error
fifty times
strong amount
sub sequence
sequence slides
function input
first algorithm
size grows
size doubles
fore fold
kind log
square running
squared right
small instances
million times
numbers sitting
value ten
eleven right
thirteen fourteen
lets compute
step executed
entire thing
total running
square times
dominant thing
simple problem
last step
single variable
makes order
free linear
asymptotic running
linear algorithm
quadratic logarithmic
big omega
omega notation
big theta
theta notation
lower bound
right function
picture illustrate
part tells
related asymptotic
asymptotic notations
non tight
tight logs
tight analogs
real numbers
number omega
omega corresponds
formal definition
largest problems
problems size
largest problem
problem size
roughly twenty
differences happening
problem nineteen
thirty sixth
sixth hundred
huge increase
large increase
logging algorithm
square algorithm
size hundred
solve means
lecture today
initial notation
data
structures
algorithms
learn
today
basic
terminology
notations
rest
begin
simple
definitions
algorithm
outline
steps
program
right
computational
procedure
hand
implementation
programming
language
structure
organize
effectively
familiar
array
list
instance
lot
problem
solve
process
develop
organizing
whats
algorithmic
essentially
specifications
input
output
specification
sorted
non
decreasing
sequence
natural
numbers
finite
length
comp
completely
two
examples
meet
instances
form
infinitely
describing
actions
decide
solving
slightly
bring
notion
good
efficient
small
running
takes
memory
measures
efficiency
working
spending
space
analyzing
spend
worrying
interested
function
sizes
imagine
noise
amount
ten
times
larger
grow
twenty
hundred
behavior
increase
size
interest
short
slides
measure
important
put
experimental
study
implement
means
write
run
varying
sets
smaller
kinds
composition
clock
sits
watch
system
utility
current
millis
figure
out
call
limitations
first
determine
mine
implemented
huge
overhead
considerable
spent
doing
experiments
done
limited
set
inputs
number
large
indicative
taking
considered
experiment
platforms
comparison
platform
hardware
software
environment
machines
make
fact
users
point
difference
messy
part
infact
lecture
general
methodology
analyze
high
level
description
det
account
evaluate
efficency
independent
give
pseudo
code
purpose
earlier
courses
stores
integer
find
maximum
element
written
syntax
wrong
mixture
construct
loop
meant
bother
semicolon
colon
things
required
compiler
understanding
clear
starting
keeping
track
variable
max
initialized
remaining
compare
consideration
update
terminates
return
understand
computer
coveys
idea
concepts
question
structured
usual
formal
standard
numerical
numeric
boolean
expression
assignment
operator
equal
java
left
arrow
quality
relationship
equals
single
equivalent
declare
methods
manner
parameter
statement
repeat
index
i.j
value
method
argument
object
type
identify
primitive
operations
low
operation
movement
control
branch
routine
arithmetic
logical
inspect
count
executed
sorting
permutation
order
hindi
requirements
nt
sort
produce
increasing
depend
elements
depends
long
technique
lets
playing
game
cards
strategy
follow
picking
dealt
start
empty
pick
card
inserted
place
suppose
jack
queen
inserting
insertion
picked
appropriately
integers
original
variables
indices
minus
location
insert
vary
key
decrease
starts
move
found
happening
continue
terminate
reach
case
moved
thing
assured
shifting
shifted
step
note
shift
eventually
mistake
correction
comparing
depending
four
reflect
represent
unit
care
counting
entire
assigning
assign
incremented
check
counted
errors
roughly
forget
comment
sub
reflects
counts
previous
quantity
checking
condition
iteration
subject
total
sum
last
exit
similarly
reason
correct
knew
constant
work
computed
makes
immediately
fourth
end
summation
kind
squared
constants
talking
asymptotic
analysis
behave
linear
average
expect
worst
half
points
minute
specific
define
defined
smallest
bars
values
compute
create
plot
topic
monotonically
parts
increases
happen
lesser
easiest
upper
bound
tells
occurs
fairly
close
bad
differences
difficult
compete
drawn
distribution
expected
typically
harder
symptotonic
goal
read
superficial
details
dependent
showed
factors
show
distinguish
ahs
square
quadratic
doubles
fore
fold
capturing
limit
crucial
brings
big
notation
functions
measuring
negative
exist
green
continues
clarify
wondering
scale
exponential
axis
blue
line
crossing
red
displaces
suitable
intercept
choose
violated
rule
fifty
log
drop
lower
terms
complicated
fastest
growing
term
common
error
provide
strong
true
express
grows
double
hierarchy
cube
word
caution
million
achieved
late
careful
sitting
basically
computing
summing
accumulator
dividing
eleven
twelve
thirteen
fourteen
initially
dominant
solution
accumulating
repeating
computation
prefix
prefixes
divide
finish
reuse
free
logarithmic
polynomial
introduce
omega
theta
picture
illustrate
lies
thinking
related
tight
logs
analogs
analogy
real
sense
definition
greater
talk
equality
corresponds
strictly
miss
great
largest
problems
hour
nineteen
thirty
sixth
logging
millions
years
bothers
questions
stop
looked
initial
