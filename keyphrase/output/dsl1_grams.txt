structures and algorithms
terminologies regarding data
definitions an algorithm
programming language data
language data structure
organize the data
lot of data
process develop data
develop data structures
organizing the data
problem an algorithmic
specification a sorted
non decreasing sequence
sequence of natural
numbers of non-zero
completely specified input
examples of input
meets the specification
instance a sorted
finite length forms
forms an instance
number of instances
sequence of sorted
numbers as input
input an algorithm
describing the actions
infinitely many input
instances and algorithms
algorithms for solving
solving certain problem
brings the notion
notion of good
good algorithm good
algorithm good algorithm
takes less memory
measures of efficiency
analyzing the running
analyzing the space
efficiency of algorithms
function of input
behavior of increase
size of input
measure the running
implement the algorithm
write a program
language you run
run the program
program with varying
varying data sets
larger data sets
kinds of varying
takes and clock
utility like system
current time millis
good your algorithms
determine how good
good your algorithm
algorithm is implementing
spend considerable amount
set of inputs
run your experiment
set of instances
algorithm is taking
comparison platform means
hardware and software
machines would make
make a difference
point would make
develop the general
develop a high
high level description
describing an algorithm
description to figure
out the running
system a methodology
evaluate the efficiency
doing this algorithm
takes an array
stores an integer
find the maximum
array algorithm array
algorithm array max
syntax is wrong
mixture of natural
high-level programming concepts
program is doing
doing is clear
variable called current
array current max
current maximum element
update the current
return current max
max if current
conveys the idea
concepts thus pseudo-code
structured than usual
language how pseudo-code
numeric and boolean
relationship in java
parameter it takes
kinds of programming
terminates and return
call a method
object used calls
specifies the type
low level operation
call or return
operations or logical
operation * data
arithmetic an logical
inspect the pseudo
code and count
count the number
number of primitive
sorting the input
sequence of numbers
numbers and output
non decreasing order
input any set
set of numbers
make an output
algorithm should sort
sort the numbers
produce the sequence
running time depends
number of elements
sorted these numbers
things the first
first sorting technique
game of cards
strategy you follow
set of cards
hand you start
card and insert
jack and queen
cards and inserted
pseudo-code for insertion
give an array
array of integers
integers as input
input and output
sorted the output
variables or indices
place to insert
loop it starts
move it right
place i run
find an element
insert this loop
loop will continue
loop will terminate
insert the element
shifting the element
element one step
step 9th location
location becomes empty
put the key
find the right
element and insert
analyze this algorithm
arrow please make
make a correction
,c2 ,c3 ,c4
,c3 ,c4 ,c5
,c4 ,c5 ,c6
,c6 just represent
represent the amount
counting the number
number of times
operations is executed
operation is done
done n times
times i start
start by assigning
roughly n times
times just leave
leave the comment
counts the number
shift an element
count that quantity
checking this condition
reach this condition
times the total
key this statement
quantity which depends
sorting the instance
compare the element
times n minus
talk about asymptotic
case the total
times some constant
minus some constant
linear time algorithm
worst and average
interested in sorting
sorting n numbers
case the worst
case is defined
1size of size
give the values
compute worst case
create a plot
out the worst
monotonically increasing plots
algorithm will increase
size becomes larger
easiest to work
work with worst
long your algorithm
algorithms worst case
worst case occurs
algorithm is close
worst case average
case average case
difficult to compute
instance is drawn
quantity to work
measure of interest
working with asymptotic
kind of thing
analyze the running
rid of superficial
,because this constant
interested to distinguish
input size doubles
doubles the running
increases four fold
interested in capturing
analysis clearly explains
increases with increase
increase in input
represents the input
input size increases
drawn two functions
functions the function
function in red
function the function
function in green
examples would clarify
examples the function
scale the scale
similarly on x-axis
x-axis the red
red colored line
point of crossing
straight line displaced
displaced by suitable
amount the green
blue in color
out a constant
pick a larger
out these things
simple rule suppose
drop all constants
lower order terms
order terms forget
forget the constant
drop the constant
constant and lower
drop all lower
fastest growing term
drop my constant
limit this quantity
times this quantity
error the function
provide as strong
statement is true
express the number
executed during run
algorithm which takes
takes the number
increase four fold
similarly our algorithm
hierarchy of functions
order of log
word of caution
algorithm whose running
1,000,000 n algorithm
limit is achieved
achieved very late
large for small
examples of asymptotic
output an array
compute each element
taking the value
running the index
dividing the value
compute the running
n-1 this entire
thing is done
times the steps
steps are executed
kind of repeating
divide this sum
doing two primitive
two primitive operations
operations that makes
makes an order
order n times
loop is executed
executed n times
linear and quadratic
quadratic and logarithmic
constant k algorithm
notation and big-theta
notation the big-omega
bound the function
two more related
related asymptotic notations
analogs of big-oh
big-oh and big-omega
analogy of real
talk of equality
equal little-oh corresponds
part the formal
definition for little-oh
defines the difference
largest problem size
hour the largest
increases an hour
problem you solve
log n algorithm
solve for problem
millions of years
years to solve
data structures
basic terminologies
simple definitions
computational procedure
programming language
language data
data structure
program hope
process develop
develop data
algorithmic problem
non decreasing
decreasing sequence
natural numbers
finite length
output specification
non-decreasing sequence
length forms
nondecreasing numbers
input instance
input instances
good algorithm
efficient algorithm
efficient efficient
input size
small input
program running
experimental study
varying data
data sets
larger data
varying composition
program takes
system utility
huge overhead
considerable amount
limited set
small set
comparison platform
platform means
software environment
software environments
first lecture
general methodology
high level
level description
pseudo code
earlier courses
algorithm doing
algorithm takes
maximum element
array algorithm
algorithm array
array max
natural language
high-level programming
programming concepts
if-then-else statement
current max
first element
remaining element
current maximum
current element
loop terminates
simple algorithm
usual prose
standard numeric
boolean expressions
assignment operator
equality operator
equality relationship
declare methods
takes algorithm
programming construct
index array
procedure terminates
return value
value returned
function returns
object method
object specifies
analyze algorithms
primitive operations
primitive operation
low level
level operation
data movement
control statement
subroutine call
arithmetic operations
logical operations
e.g addition
decreasing order
nondecreasing order
non-decreasing order
output algorithm
increasing order
sorted order
first sorting
sorting technique
playing game
empty hand
first card
place suppose
right place
insertion sort
original numbers
key key
sorted sequence
decrease index
value j-1
first place
8th location
empty location
small mistake
last line
left arrow
operation takes
computer system
,c2 ,c3
,c3 ,c4
,c4 ,c5
,c5 ,c6
entire program
small errors
operation key
comment statement
total number
problem problem
last element
3rd element
4th element
the1st element
constant times
asymptotic analysis
constant minus
worst case
average case
infinite bars
inputs size
increasing plots
input increases
upper bound
algorithms worst
case occurs
case average
harder quantity
superficial details
quadratic behavior
size doubles
algorithm increases
crucial point
big-oh o-notation
nonnegative functions
size increases
nondecreasing functions
exist constants
non-linear function
exponential scale
scale increases
red colored
colored line
blue line
dotted line
straight line
line displaced
suitable amount
green line
simple rule
rule suppose
lower order
order terms
terms forget
complicated function
growing term
common error
strong amount
subsequent slides
first algorithm
linear running
small instances
numbers sitting
entire thing
total running
dominant thing
step mentioned
simple problem
last step
repeating computations
single variable
asymptotic running
linear algorithm
big-oh notation
bigomega notation
big-theta notation
big-omega notation
lower bound
related asymptotic
asymptotic notations
little-oh notation
non-tight analogs
real numbers
equal little-oh
little-oh corresponds
littleomega corresponds
formal definition
running times
largest problem
problem size
differences happening
huge increase
large increase
data
structures
algorithms
learn
basic
terminologies
notations
rest
begin
simple
definitions
algorithm
outline
steps
program
computational
procedure
hand
implementation
programming
language
structure
organize
effectively
hope
familiar
array
list
lot
problem
solve
process
develop
organizing
algorithmic
essentially
specifications
input
output
specification
sorted
non
decreasing
sequence
natural
numbers
non-zero
finite
length
1,20,908,909,100000,1000000000
completely
two
examples
meets
instance
non-decreasing
forms
instances
number
nondecreasing
describing
actions
infinitely
solving
brings
notion
good
efficient
small
running
takes
memory
measures
efficiency
working
things
spending
analyzing
spend
space
interested
function
size
imagine
amount
times
larger
increase
behavior
interest
measure
experimental
study
implement
means
write
run
varying
sets
smaller
kinds
composition
clock
sit
stopwatch
system
utility
current
millis
figure
out
call
limitations
detail
first
determine
implementing
huge
overhead
considerable
experiments
done
limited
set
inputs
experiment
taking
considered
decide
platforms
comparison
platform
hardware
software
environment
machines
make
difference
fact
users
point
messy
environments
part
lecture
general
methodology
analyze
high
level
description
account
evaluate
independent
pseudo-code
purpose
pseudo
code
earlier
courses
doing
stores
integer
find
maximum
element
max
mentioned
syntax
wrong
mixture
high-level
concepts
loop
if-then-else
statement
bother
semicolon
colon
required
compiler
understanding
clear
beginning
track
variable
initialized
remaining
compare
update
terminates
return
understand
computer
conveys
idea
structured
usual
prose
formal
standard
numeric
boolean
expressions
assignment
operator
java
equality
relationship
declare
methods
parameter
param
param2
construct
repeat
index
value
returned
returns
method
argument
object
calls
args
specifies
type
identify
primitive
operations
operation
low
movement
control
branch
subroutine
arithmetic
logical
assign
e.g
addition
inspect
count
executed
sorting
permutation
order
requirements
sort
produce
increasing
depends
elements
long
depend
technique
playing
game
cards
strategy
follow
picking
dealt
start
empty
pick
card
insert
place
suppose
jack
queen
put
right
inserting
insertion
picked
inserted
give
integers
original
variables
indices
j-1
location
vary
2-n
key
i.e
1_j-1
decrease
starts
move
7th
greater
continue
terminate
reach
moved
shifting
step
note
shift
9th
8th
eventually
implemented
slightly
left
mistake
last
line
arrow
correction
comparing
depending
,c2
,c3
,c4
,c5
,c6
represent
units
counting
entire
assigning
4,5,6,7
increment
check
counted
errors
important
roughly
operation.how
n-1
for3
leave
comment
counts
previous
quantity
checking
condition
iteration
total
sum
exit
knew
constants
computed
makes
1st
2nd
3rd
4th
the1st
end
case
equal
summation
kind
constant
minus
talk
asymptotic
analysis
meant
linear
average
expect
worst
half
behaves
defined
smallest
infinite
bars
1size
values
compute
sizes
create
plot
monotonically
plots
increases
lesser
easiest
work
upper
bound
tells
occurs
fairly
close
bad
differences
difficult
drawn
distribution
expected
typically
harder
thing
goal
rid
superficial
details
squared
,because
dependent
factors
distinguish
quadratic
doubles
four
fold
capturing
limit
crucial
explains
big-oh
o-notation
functions
represents
nonnegative
exist
red
green
continues
clarify
wondering
non-linear
scale
exponential
y-axis
similarly
x-axis
colored
blue
dotted
crossing
straight
displaced
suitable
intercept
color
choose
violated
rule
log
drop
lower
terms
forget
7n-3
complicated
fastest
growing
term
happen
common
error
provide
strong
true
subsequent
slides
express
double
hierarchy
word
caution
1,000,000
1,000,000n
achieved
late
large
careful
sitting
basically
0-10
summing
accumulator
dividing
11,12,13,14
initially
0,1,2,3
dominant
solution
accumulating
i-1
computing
repeating
computations
single
prefixes
divide
finish
reuse
freely
logarithmic
polynomial
introduced
notation
bigomega
big-theta
big-omega
omega
picture
illustrates
sandwiched
lies
grows
thinking
related
little-oh
little-omega
non-tight
analogs
analogy
real
corresponds
strictly
littleomega
infact
definition
big
defines
400n
20n
listed
largest
minute
hour
happening
3600seconds
millions
years
it.this
