lecture we looked
looked at stacks
queues and linked
implement the queue
array to implement
implement our queue
array is fixed
queue you knew
maximum size queue
idea maximum size
size its increases
double the size
familiar with linked
essentially blinked list
tail of list
element some data
linked list implement
queue then question
front of queue
right the tail
remove this element
element the linked
element from linked
change this pointer
accessing it pointer
element no problem
remove the element
element the front
implement from methods
dequeue which means
increment just making
making the head
delete the head
delete this element
connected here make
make the head
node so inserting
inserting the head
kind of move
move the head
remove the front
add an element
enqueue an element
element recall enqueue
element this pointer
modified to pointer
pointer this element
element and tail
question we discuss
difficult to remove
remove an element
remove this node
node to remove
access the previous
kind of list
list to start
problem his question
problem in removing
removing this node
node the problem
make this point
throw the entire
node very expensive
tail which means
means the front
queue data type
type is concern
singly linked list
idea to implement
implement such double
double ended queue
doubly linked list
list to implement
implement double double
double double ended
double ended queues
queues so first
pointer one previous
two sentinel nodes
pointers one pointing
operations of double
queue in constant
delete this node
pointer to trail
follow the pointer
port and set
pointer to trailer
previous point trailer
node perhaps applied
header and trailer
linked list header
sentinel nodes dummy
nodes dummy nodes
nodes they don
dare to mark
mark the start
answering his question
delete san franchiso
makes this pointer
point to point
done in constant
operation in constant
front or delete
independent of number
number of elements
fairly generic data
generic data type
implement other data
implementation of double
make a stack
stack or make
make a queue
implementation to implement
implement a stack
instance the method
top would correspond
correspond to lets
make the top
correspond to return
last element double
element double ended
queue the method
correspond to inserting
method pop correspond
correspond to deleting
ended queue right
sacrificing about last
make this correspond
size just corresponds
queue is empty
empty double ended
circularly linked list
pointers first stack
first stack head
head and tail
structure to implement
implement both queues
queues and stack
front the queue
queue the rear
makes this front
queue this right
insert an element
guy and make
element your inserting
node and create
node and copy
copy this element
node right make
copying the reference
queue to remove
removing an element
corresponds to removing
removing the first
first one right
remove the first
copy the contents
remove the rome
rome i copy
seatle to rome
sequences so vectors
talk about vectors
talk about positions
talk about list
list and general
arrays and linked
implement this data
vector data type
data type vector
type vector data
type is sequence
elements its support
support these methods
notion of rank
rank every element
sequence of elements
element at rank
rank here corresponds
rank or integers
integers so first
element was element
suppose i asked
replaces the element
element e insert
rank r insert
insert the element
rank e rank
delete the element
methods yeah note
rank of student
two and departmental
suppose departmental rank
four does department
natural data type
data type structure
data structure implement
implement using arrays
lets see lets
implementation using arrays
element with rank
rank one element
rank two element
element as rank
rank zero rank
rank r whats
put an element
elements once step
first n minus
doing this first
two is moved
moved one step
element is pushed
thing is increased
right n suppose
stores the size
size of vector
elements one step
right all elements
two n minus
element at location
sitting at location
operations worst case
right this implementation
implementation is expensive
point of view
two operations insert
insert certain rank
remove certain rank
worst case order
operations are faster
array and retrive
retrive theelements sitting
sitting there replace
replace at rank
location and replace
replace with element
right chart shows
methods all elements
elements all methods
methods except inserted
inserted at rank
rank and remove
remove at rank
rank take constant
implementing this thing
right doubly linked
linked list vector
showing here operation
operation of inserting
insert at rank
node and put
understand the process
process of insertion
insertion right create
create this node
insert i make
makes a previous
previous pointer point
pointer would point
insert take order
list goes seventeen
insert this location
assuming the existence
node at rank
rank it tells
insert this node
rank two first
call this procedure
procedure with rank
node because earlier
node this node
previous to rank
set its previous
earlier at rank
rank two right
manner i create
check the previous
doing is assuming
process of deletion
out the node
node and update
manner get rid
code for doing
assuming the procedure
implement this procedure
array except march
list and find
incrementing my counter
reach that rank
two i start
list has hundred
element rank nineteen
point to start
start and staring
form the header
vector the vector
data type concerned
rank or insert
move the elements
insert to delete
supporting node based
node based operation
delete that node
node in constant
insert the node
node after constant
delete the insert
insert a node
constant time operations
provide we give
give it access
insert and delete
give you access
implemented my list
pointers and stuff
right without knowing
knowing the actual
thing was done
notion of positions
positions abstract data
abstract data type
intuitively the place
elements is stored
data structure captures
element is method
data type position
call this method
make much sense
node your familiar
familiar with pointers
pointer which tells
pointer is access
access the element
pointer to update
update or previous
fields you don
node is implemented
list we don
type which hides
method that element
notion of position
right the first
list second element
position is referring
node50.53 second node
similarly first position
post \ ition
define a list
list abstract datatype
meythods like size
havce query method
hacve a method
method whoich asks
asks is first
positionoif my list
dfirst will give
first position last
last would give
methods like swap
swaps the contents
positions it wswaps
replace the element
replace the elemtn
elemtn at position
uinsert the element
methods in constant
linked luist datastructure
abstract datatype implementation
double linked luist
linked luist methods
sequence abstract data
vector abstract data
element list data
list data type
combines the vector
vector and list
list abstract data
method that listed
listed for vector
vector list abstract
list abstract dat
abstract dat type
two additional methods
methods which kind
kind of suite
method at rank
correspond this rank
rank of method
identify what rank
method implement rank
position a position
suppose you gave
gave me rank
follow this reference
element certain rank
create new position
position the element
element would sit
move to right
change the ranks
ranks will change
change rank move
rank move step
case similarly deleting
deleting an element
wanted to delete
element that position
delete an element
comparison of sequence
implement a sequence
picture i shown
case of running
element ceratin rank
out the element
update the pointers
out the rank
rank any rank
rank based operation
find the rank
out the find
out the position
stop our class
today where queues
queues we learnt
learnt about double
ise linked list
type the list
essentially a concretization
linked list data
list data structure
looked at sequence
sequence data types
data types sequence
types sequence data
types basically inheriting
last lecture
data type
implement stacks
array today
linked list
fixed size
maximum size
size queue
idea maximum
last class
blinked list
nodes list
list implement
first element
queue removal
queue dequeue
front element
head point
element head
node connected
easy right
dequeue operation
manner remove
element recall
recall enqueue
rear queue
null right
previous node
removing removing
entire list
expensive operation
queue data
good idea
good solution
double double
double ended
ended queues
previous pointer
sentinel nodes
ended queue
previous port
previous point
point trailer
trailer nodes
list header
nodes dummy
dummy nodes
data inside
san franchiso
pointer point
operations understand
front insert
end delete
generic data
data types
method top
stack correspond
last element
method push
method pop
pop correspond
queue right
last year
empty corresponds
empty double
data structures
stack head
circular list
data structure
queue makes
rear right
element lets
straight forward
element removing
element corresponds
lets remove
general sequence
linked lists
vector data
type vector
fourth element
element rank
instance lets
departmental rank
suppose departmental
department change
department rank
natural data
type structure
structure implement
arrays lets
moving step
finally element
suppose stores
elements starting
operations worst
worst case
operations insert
rank remove
case order
rth location
retrive theelements
theelements sitting
right chart
chart shows
list vector
element insert
make point
node makes
rank seventeen
seventeen position
procedure node
rank rank
previous field
doing don
doing showing
original list
previous pointers
java code
rank tells
nodes sitting
small improvement
hundred elements
rank nineteen
staring form
type concerned
first case
element correspond
supporting node
node based
based operation
node delete
operations provide
delete right
things information
actual implementation
positions abstract
abstract data
structure captures
method element
type position
element sitting
previous fields
element element
first position
list abstract
abstract datatype
positions ruight
abtstract datatype
generic meythods
havce query
query method
first positionoif
last position
excessive methods
lsat position
update methods
swap elemts
elemtsn sitting
linked luist
luist datastructure
datatype implementation
asbstract datatype
luist methods
efficient implement
sequence abstract
vector abstract
element list
list data
multiple inheritance
vector list
abstract dat
dat type
additional methods
suite connect
rank return
position correspond
array refers
rank corresponds
method implement
implement rank
procedure position
element store
case newyork
cross reference
change rank
rank move
move step
sequence operations
implement sequence
array implementation
element ceratin
ceratin rank
rank figure
rank based
rank find
class today
learnt today
sequence data
types sequence
last
lecture
looked
stacks
data
type
implement
array
today
queues
linked
list
queue
right
noise
disadvantage
fixed
size
knew
maximum
idea
method
class
increases
allotted
double
implementation
assume
familiar
previous
essentially
blinked
nodes
pointers
basically
referring
referred
tail
node
element
question
front
first
remove
problem
removing
note
permit
directly
change
pointer
accessing
removal
done
sitting
call
lets
methods
suppose
dequeue
means
left
rear
head
point
removed
increment
making
manner
delete
easily
insert
create
connected
make
inserting
easy
operation
kind
move
step
add
enqueue
recall
modified
update
null
discuss
difficult
constant
access
start
beginning
throw
entire
expensive
worth
concern
singly
good
ended
repeatedly
solution
doubly
two
sentinel
minute
pointing
operations
trail
follow
port
set
trailer
applied
header
dummy
don
inside
dare
mark
end
answering
san
franchiso
out
makes
hindi
thing
shown
understand
questions
independent
number
elements
running
depend
fairly
generic
types
stack
instance
top
correspond
return
push
pop
deleting
sacrificing
year
case
corresponds
empty
structures
circularly
simple
points
circular
structure
guy
straight
forward
created
copy
copying
costly
reference
contents
rome
seatle
part
quickly
sequences
vectors
talk
positions
general
sequence
arrays
lists
vector
support
notion
rank
eleven
thirteen
nineteen
fourth
give
integers
asked
replaces
great
happen
student
departmental
four
department
natural
whats
put
shift
doing
loop
moving
minus
statement
moved
finally
pushed
increased
stores
similarly
shifting
starting
location
posi
worst
order
view
faster
rth
retrive
theelements
replace
chart
shows
complexity
inserted
implementing
showing
process
insertion
issues
find
seventeen
position
java
code
assuming
existence
procedure
finding
shortly
tells
earlier
field
place
check
intimated
original
slides
web
show
deletion
rid
write
march
incrementing
counter
reach
small
improvement
hundred
staring
form
concerned
usen
require
supporting
based
efficient
provide
mention
sense
telling
implemented
stuff
hide
things
information
knowing
actual
implementations
abstract
intuitively
stored
captures
object
situated
fields
implementer
hides
details
related
node50.53
refers
post
ition
define
datatype
ruight
abtstract
meythods
havce
query
hacve
whoich
asks
positionoif
excessive
dfirst
lsat
geive
postion
swap
elemts
key
swaps
elemtsn
wswaps
elemtn
uinsert
onya
luist
datastructure
caprture
yuou
asbstract
linear
talked
combines
inherits
interfaces
multiple
inheritance
listed
dat
additional
suite
connect
identify
determine
gave
store
newyork
cross
sit
ranks
wanted
leave
exercise
comparison
picture
previously
ceratin
zap
context
figure
stop
learnt
ise
concretization
inheriting
