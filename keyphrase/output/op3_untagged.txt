introduction what is an operating system the 1960 s definition of an operating system is the software that controls the hardware  however  today  due to microcode we need a better definition we see an operating system as the programs that make the hardware useable in brief  an operating system is the set of programs that controls a computer some examples of operating systems are unix  mach  ms-dos  ms-windows  windows/nt  chicago  os/2  macos  vms  mvs  and vm controlling the computer involves software at several levels we will differentiate kernel services  library services  and application-level services  all of which are part of the operating system processes run applications  which are linked together with libraries that perform standard services the kernel supports the processes by providing a path to the peripheral devices the kernel responds to service calls from the processes and interrupts from the devices the core of the operating system is the kernel  a control program that functions in privileged state  an execution context that allows all hardware instructions to be executed   reacting to interrupts from external devices and to service requests and traps from processes generally  the kernel is a permanent resident of the computer it creates and terminates processes and responds to their request for service operating systems are resource managers the main resource is computer hardware in the form of processors  storage  input/output devices  communication devices  and data some of the operating system functions are  implementing the user interface  sharing hardware among users  allowing users to share data among themselves  preventing users from interfering with one another  scheduling resources among users  facilitating input/output  recovering from errors  accounting for resource usage  facilitating parallel operations  organizing data for secure and rapid access  and handling network communications objectives of operating systems modern operating systems generally have following three major goals operating systems generally accomplish these goals by running processes in low privilege and providing service calls that invoke the operating system kernel in high-privilege state * to hide details of hardware by creating abstraction an abstraction is software that hides lower level details and provides a set of higher-level functions an operating system transforms the physical world of devices  instructions  memory  and time into virtual world that is the result of abstractions built by the operating system there are several reasons for abstraction first  the code needed to control peripheral devices is not standardized operating systems provide subroutines called device drivers that perform operations on behalf of programs for example  input/output operations second  the operating system introduces new functions as it abstracts the hardware for instance  operating system introduces the file abstraction so that programs do not have to deal with disks third  the operating system transforms the computer hardware into multiple virtual computers  each belonging to a different program each program that is running is called a process each process views the hardware through the lens of abstraction fourth  the operating system can enforce security through abstraction * to allocate resources to processes  manage resources  an operating system controls how processes  the active agents  may access resources  passive entities   * provide a pleasant and effective user interface the user interacts with the operating systems through the user interface and usually interested in the look and feel of the operating system the most important components of the user interface are the command interpreter  the file system  on-line help  and application integration the recent trend has been toward increasingly integrated graphical user interfaces that encompass the activities of multiple processes on networks of computers one can view operating systems from two points of views  resource manager and extended machines form resource manager point of view operating systems manage the different parts of the system efficiently and from extended machines point of view operating systems provide a virtual machine to users that is more convenient to use the structurally operating systems can be design as a monolithic system  a hierarchy of layers  a virtual machine system  an exokernel  or using the client-server model the basic concepts of operating systems are processes  memory management  i/o management  the file systems  and security history of operating systems historically operating systems have been tightly related to the computer architecture  it is good idea to study the history of operating systems from the architecture of the computers on which they run operating systems have evolved through a number of distinct phases or generations which corresponds roughly to the decades the 1940 's  first generations the earliest electronic digital computers had no operating systems machines of the time were so primitive that programs were often entered one bit at time on rows of mechanical switches  plug boards   programming languages were unknown  not even assembly languages   operating systems were unheard of  the 1950 's  second generation by the early 1950 's  the routine had improved somewhat with the introduction of punch cards the general motors research laboratories implemented the first operating systems in early 1950 's for their ibm 701 the system of the 50 's generally ran one job at a time these were called single-stream batch processing systems because programs and data were submitted in groups or batches the 1960 's  third generation the systems of the 1960 's were also batch processing systems  but they were able to take better advantage of the computer 's resources by running several jobs at once so operating systems designers developed the concept of multiprogramming in which several jobs are in main memory at once ; a processor is switched from job to job as needed to keep several jobs advancing while keeping the peripheral devices in use for example  on the system with no multiprogramming  when the current job paused to wait for other i/o operation to complete  the cpu simply sat idle until the i/o finished the solution for this problem that evolved was to partition memory into several pieces  with a different job in each partition while one job was waiting for i/o to complete  another job could be using the cpu another major feature in third-generation operating system was the technique called spooling  simultaneous peripheral operations on line   in spooling  a high-speed device like a disk interposed between a running program and a low-speed device involved with the program in input/output instead of writing directly to a printer  for example  outputs are written to the disk programs can run to completion faster  and other programs can be initiated sooner when the printer becomes available  the outputs may be printed note that spooling technique is much like thread being spun to a spool so that it may be later be unwound as needed another feature present in this generation was time-sharing technique  a variant of multiprogramming technique  in which each user has an on-line  i.e  directly connected  terminal because the user is present and interacting with the computer  the computer system must respond quickly to user requests  otherwise user productivity could suffer timesharing systems were developed to multiprogram large number of simultaneous interactive users fourth generation with the development of lsi  large scale integration  circuits  chips  operating system entered in the system entered in the personal computer and the workstation age microprocessor technology evolved to the point that it become possible to build desktop computers as powerful as the mainframes of the 1970s two operating systems have dominated the personal computer scene  ms-dos  written by microsoft  inc for the ibm pc and other machines using the intel 8088 cpu and its successors  and unix  which is dominant on the large personal computers using the motorola 6899 cpu family system components even though  not all systems have the same structure many modern operating systems share the same goal of supporting the following types of system components process management the operating system manages many kinds of activities ranging from user programs to system programs like printer spooler  name servers  file server etc each of these activities is encapsulated in a process a process includes the complete execution context  code  data  pc  registers  os resources in use etc   it is important to note that a process is not a program a process is only one instant of a program in execution there are many processes can be running the same program the five major activities of an operating system in regard to process management are * creation and deletion of user and system processes * suspension and resumption of processes * a mechanism for process synchronization * a mechanism for process communication * a mechanism for deadlock handling main-memory management primary-memory or main-memory is a large array of words or bytes each word or byte has its own address main-memory provides storage that can be access directly by the cpu that is to say for a program to be executed  it must in the main memory the major activities of an operating in regard to memory-management are  * keep track of which part of memory are currently being used and by whom * decide which process are loaded into memory when memory space becomes available * allocate and deallocate memory space as needed file management a file is a collected of related information defined by its creator computer can store files on the disk  secondary storage   which provide long term storage some examples of storage media are magnetic tape  magnetic disk and optical disk each of these media has its own properties like speed  capacity  data transfer rate and access methods a file systems normally organized into directories to ease their use these directories may contain files and other directions the five main major activities of an operating system in regard to file management are 1 the creation and deletion of files 2 the creation and deletion of directions 3 the support of primitives for manipulating files and directions 4 the mapping of files onto secondary storage 5 the back up of files on stable storage media i/o system management i/o subsystem hides the peculiarities of specific hardware devices from the user only the device driver knows the peculiarities of the specific device to whom it is assigned secondary-storage management generally speaking  systems have several levels of storage  including primary storage  secondary storage and cache storage instructions and data must be placed in primary storage or cache to be referenced by a running program because main memory is too small to accommodate all data and programs  and its data are lost when power is lost  the computer system must provide secondary storage to back up main memory secondary storage consists of tapes  disks  and other media designed to hold information that will eventually be accessed in primary storage  primary  secondary  cache  is ordinarily divided into bytes or words consisting of a fixed number of bytes each location in storage has an address ; the set of all addresses available to a program is called an address space the three major activities of an operating system in regard to secondary storage management are  1 managing the free space available on the secondary-storage device 2 allocation of storage space when new files have to be written 3 scheduling the requests for memory access networking a distributed systems is a collection of processors that do not share memory  peripheral devices  or a clock the processors communicate with one another through communication lines called network the communication-network design must consider routing and connection strategies  and the problems of contention and security protection system if a computer systems has multiple users and allows the concurrent execution of multiple processes  then the various processes must be protected from one another 's activities protection refers to mechanism for controlling the access of programs  processes  or users to the resources defined by a computer systems command interpreter system a command interpreter is an interface of the operating system with the user the user gives commands with are executed by operating system  usually by turning them into system calls   the main function of a command interpreter is to get and execute the next user specified command command-interpreter is usually not part of the kernel  since multiple command interpreters  shell  in unix terminology  may be support by an operating system  and they do not really need to run in kernel mode there are two main advantages to separating the command interpreter from the kernel 1 if we want to change the way the command interpreter looks  i.e  i want to change the interface of command interpreter  i am able to do that if the command interpreter is separate from the kernel i can not change the code of the kernel so i can not modify the interface 2 if the command interpreter is a part of the kernel it is possible for a malicious process to gain access to certain part of the kernel that it showed not have to avoid this ugly scenario it is advantageous to have the command interpreter separate from kernel operating systems services following are the five services provided by an operating systems to the convenience of the users program execution the purpose of a computer systems is to allow the user to execute programs so the operating systems provides an environment where the user can conveniently run programs the user does not have to worry about the memory allocation or multitasking or anything these things are taken care of by the operating systems running a program involves the allocating and deallocating memory  cpu scheduling in case of multiprocess these functions can not be given to the user-level programs so user-level programs can not help the user to run programs independently without the help from operating systems i/o operations each program requires an input and produces output this involves the use of i/o the operating systems hides the user the details of underlying hardware for the i/o all the user sees is that the i/o has been performed without any details so the operating systems by providing i/o makes it convenient for the users to run programs for efficiently and protection users can not control i/o so this service can not be provided by user-level programs file system manipulation the output of a program may need to be written into new files or input taken from some files the operating systems provides this service the user does not have to worry about secondary storage management user gives a command for reading or writing to a file and sees his her task accomplished thus operating systems makes it easier for user programs to accomplished their task this service involves secondary storage management the speed of i/o that depends on secondary storage management is critical to the speed of many programs and hence i think it is best relegated to the operating systems to manage it than giving individual users the control of it it is not difficult for the user-level programs to provide these services but for above mentioned reasons it is best if this service s left with operating system communications there are instances where processes need to communicate with each other to exchange information it may be between processes running on the same computer or running on the different computers by providing this service the operating system relieves the user of the worry of passing messages between processes in case where the messages need to be passed to processes on the other computers through a network it can be done by the user programs the user program may be customized to the specifics of the hardware through which the message transits and provides the service interface to the operating system error detection an error is one part of the system may cause malfunctioning of the complete system to avoid such a situation the operating system constantly monitors the system for detecting the errors this relieves the user of the worry of errors propagating to various part of the system and causing malfunctioning this service can not allowed to be handled by user programs because it involves monitoring and in cases altering area of memory or deallocation of memory for a faulty process or may be relinquishing the cpu of a process that goes into an infinite loop these tasks are too critical to be handed over to the user programs a user program if given these privileges can interfere with the correct  normal  operation of the operating systems system calls and system programs system calls provide an interface between the process an the operating system system calls allow user-level processes to request some services from the operating system which process itself is not allowed to do in handling the trap  the operating system will enter in the kernel mode  where it has access to privileged instructions  and can perform the desired service on the behalf of user-level process it is because of the critical nature of operations that the operating system itself does them every time they are needed for example  for i/o a process involves a system call telling the operating system to read or write particular area and this request is satisfied by the operating system system programs provide basic functioning to users so that they do not need to write their own environment for program development  editors  compilers  and program execution  shells   in some sense  they are bundles of useful system calls layered approach design in this case the system is easier to debug and modify  because changes affect only limited portions of the code  and programmer does not have to know the details of the other layers information is also kept only where it is needed and is accessible only in certain ways  so bugs affecting that data are limited to a specific module or layer mechanisms and policies the policies what is to be done while the mechanism specifies how it is to be done for instance  the timer construct for ensuring cpu protection is mechanism on the other hand  the decision of how long the timer is set for a particular user is a policy decision the separation of mechanism and policy is important to provide flexibility to a system if the interface between mechanism and policy is well defined  the change of policy may affect only a few parameters on the other hand  if interface between these two is vague or not well defined  it might involve much deeper change to the system once the policy has been decided it gives the programmer the choice of using his/her own implementation also  the underlying implementation may be changed for a more efficient one without much trouble if the mechanism and policy are well defined specifically  separating these two provides flexibility in a variety of ways first  the same mechanism can be used to implement a variety of policies  so changing the policy might not require the development of a new mechanism  but just a change in parameters for that mechanism  but just a change in parameters for that mechanism from a library of mechanisms second  the mechanism can be changed for example  to increase its efficiency or to move to a new platform  without changing the overall policy 