talking about ordered
binary search trees
implementing ordered dictionaries
key element pairs
insert an element
element to search
delete an element
minimum the element
minimum key element
element with maximum
notion of predecessor
talked about hashing
talked about dictionary
compare to keys
keys for equality
ordering relation keys
predecessor and successor
key so predecessor
key which precedes
keys in dictionaries
right so give
part of data
things are ordered
similarly successor function
two trivals doing
doing both cases
kind of data
taking only constant
out the entire
elements and deletion
deletion take order
search for element
successor of twelve
key following twelve
ordered relation assuming
smallest key fourteen
twenty two thirty
twelve from twelve
thing to find
smallest key larger
larger than twelve
successor and predecessor
predecessor and min
min and max
fairly inefficient implementation
implementation an ordered
ordered the thing
order of keys
takes only constant
constant time maximum
organize it takes
successor say predecessor
predecessor takes constant
asked for successor
throw this entire
list to reach
reach that node
node i gave
gave you lets
lets say reference
compute the successor
predecessor in constant
inserting also takes
takes n times
out the correction
position for insertion
insertion okay searching
takes n order
searching can improve
put the elements
search to find
out the element
logarithmic time log
right but binary
insertion and deletion
place to insert
similarly for deletion
recap what binary
remember binary search
search to search
search for twenty
middle element twenty
two is larger
larger the right
twenty five smaller
twenty two inch
inch away case
number of comparisons
process only logarithmic
make a comparison
making the search
trivial way trivial
adopt to implement
implement a ordered
ordered dictionary right
talk about trivialities
binary search binary
search binary search
binary search tree
property right recall
binary tree binary
tree binary tree
right a node
child two child
children no children
key and element
shown here written
binary search property
property the binary
left sub tree
tree all keys
right sub tree
node all keys
sub tree larger
property a binary
nodes have keys
keys which satisfies
properties is satisfied
clear so binary
tree plus search
search property equals
property equals binary
equals binary search
set of keys
kinds of trees
satisfy the search
keys stored left
stored left sub
couple of features
keys are unique
right an element
right can happen
happen right suppose
suppose your key
define total order
total order names
geographic order alphabetic
order alphabetic order
key is equal
right any problem
assume the keys
necessarily complicate matters
handle that suppose
root i compare
eleven is larger
search property keys
left so wee
tree we compare
done we found
find an element
right okay suppose
child id null
tree this guy
question no question
write the binary
search this search
search procedure binary
procedure binary search
simplest to understand
searching for key
nil which means
root empty tree
return the root
searching for searching
begin with refers
key is larger
larger than key
version the iterative
make recursive calls
search for procedure
right we start
right we started
continuing the search
dot left child
code just showed
right pseudo code
continue this search
children node child
node child nodes
started a level
level two level
executed the maximum
number of levels
procedure everyone understand
understand this simple
nodes whose height
height is order
kind of situations
large the search
order the height
number of nodes
finding the minimum
left most tree
left most leaf
left most node
node or left
leaf okay lets
tree so lets
ordered dictionaries
binary search
search trees
simplest ways
dictionary functionality
key element
element pairs
minimum key
predecessor successor
total order
ordering relation
relation keys
function predecessor
predecessor taking
dictionary right
precedes key
total ordered
similarly successor
successor function
trivals doing
list kind
data structure
unordered list
constant amount
worst case
entire list
entire elements
dictionary successor
ordered relation
relation assuming
smallest key
key fourteen
key larger
eighteen twenty
largest key
key twelve
entire thing
inefficient implementation
ordered list
hand lets
minimum takes
pointer reference
predecessor takes
takes constant
correction position
searching takes
array searching
right place
takes lot
remember binary
middle element
element twenty
right twenty
array location
point make
comparison size
search halves
order log
recall insertion
interesting right
search binary
search tree
binary tree
search property
tree binary
children means
leaf node
left sub
sub tree
right sub
property holds
root node
key value
tree larger
satisfies property
search properties
property equals
binary satisfy
unique right
unique key
order names
geographic order
alphabetic order
complicate matters
assume keys
entire discussion
duplicate key
duplicate keys
key setting
property keys
right keys
element key
compare key
wee compare
left child
search procedure
procedure binary
recursive procedure
iterative procedure
equals nil
root empty
empty tree
recursively search
pseudo code
good lets
iterative version
recursive calls
current node
dot left
node pointing
modified right
children node
node child
child nodes
right child
loop executed
maximum number
tree order
minimum element
tree left
leaf left
wrong suppose
today
class
talking
ordered
dictionaries
noise
binary
search
trees
simplest
ways
implementing
essentially
dictionary
functionality
right
recall
key
element
pairs
insert
delete
notion
minimum
maximum
predecessor
successor
means
kind
total
order
keys
talked
hashing
operation
compare
equality
two
decide
excepting
out
assume
ordering
relation
equal
larger
parameters
function
shown
taking
parameter
give
precedes
hindi
lies
elements
field
part
data
things
similarly
implement
trivals
doing
cases
list
structure
unordered
constant
amount
searching
worst
case
entire
found
deletion
first
suppose
twelve
twenty
fourteen
assuming
integers
smallest
eighteen
thirty
four
largest
run
thing
find
min
max
fairly
inefficient
implementation
hand
lets
takes
organize
pointer
reference
end
node
depends
asked
throw
reach
gave
compute
inserting
times
correction
position
insertion
array
improve
put
logarithmic
log
place
shift
lot
left
recap
remember
middle
smaller
manner
eventually
location
inch
number
comparisons
process
point
make
comparison
size
making
halves
halve
questions
trivial
adopt
talk
trivialities
interesting
tree
property
children
child
leaf
discussion
interested
written
nodes
sub
holds
root
basically
value
satisfies
properties
satisfied
clear
equals
set
kinds
satisfy
stored
couple
features
doesn
happen
settings
unique
setting
student
define
names
geographic
alphabetic
easily
problem
permitting
rest
necessarily
complicate
matters
duplicate
handle
show
eleven
wee
ten
done
null
guy
question
good
write
procedure
recursive
iterative
understand
nil
empty
forget
return
recursively
pseudo
code
don
begin
refers
referring
version
calls
matching
start
current
differently
started
continuing
dot
call
showed
continue
step
modified
pointing
loop
level
executed
levels
height
running
simple
large
situations
note
finding
wrong
thirteen
