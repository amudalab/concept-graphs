left sub tree::23.7744375108
binary search::21.0
right sub tree::20.6045125094
sub tree::19.0
binary search tree::15.8496250072
search property::8.0
left sub::7.0
root node::5.0
total order::5.0
left most leaf::4.75488750216
set of keys::4.75488750216
keys are unique::4.75488750216
right we start::4.75488750216
binary tree::4.0
left child::4.0
successor and predecessor::3.16992500144
successor of twelve::3.16992500144
right we started::3.16992500144
nil which means::3.16992500144
binary search property::3.16992500144
number of levels::3.16992500144
left most tree::3.16992500144
insertion and deletion::3.16992500144
insert an element::3.16992500144
out the element::3.16992500144
eleven is larger::3.16992500144
iterative version::3.0
ordered list::2.0
maximum number::2.0
entire list::2.0
entire thing::2.0
recursive procedure::2.0
unique right::2.0
duplicate key::2.0
minimum element::2.0
ordered dictionaries::2.0
array location::2.0
twenty two thirty::1.58496250072
code just showed::1.58496250072
gave you lets::1.58496250072
stored left sub::1.58496250072
delete an element::1.58496250072
question no question::1.58496250072
right okay suppose::1.58496250072
position for insertion::1.58496250072
node or left::1.58496250072
talk about trivialities::1.58496250072
put the elements::1.58496250072
assume the keys::1.58496250072
order of keys::1.58496250072
two is larger::1.58496250072
ordered the thing::1.58496250072
predecessor and successor::1.58496250072
make recursive calls::1.58496250072
clear so binary::1.58496250072
larger the right::1.58496250072
search binary search::1.58496250072
key which precedes::1.58496250072
key so predecessor::1.58496250072
tree we compare::1.58496250072
finding the minimum::1.58496250072
predecessor takes constant::1.58496250072
part of data::1.58496250072
satisfy the search::1.58496250072
takes n times::1.58496250072
organize it takes::1.58496250072
node child nodes::1.58496250072
kind of data::1.58496250072
compare to keys::1.58496250072
children node child::1.58496250072
searching for key::1.58496250072
handle that suppose::1.58496250072
smallest key larger::1.58496250072
adopt to implement::1.58496250072
twenty two inch::1.58496250072
child id null::1.58496250072
trivial way trivial::1.58496250072
search this search::1.58496250072
nodes have keys::1.58496250072
property equals binary::1.58496250072
out the entire::1.58496250072
keys for equality::1.58496250072
doing both cases::1.58496250072
key following twelve::1.58496250072
couple of features::1.58496250072
binary search trees::1.58496250072
takes only constant::1.58496250072
equals binary search::1.58496250072
search procedure binary::1.58496250072
list to reach::1.58496250072
write the binary::1.58496250072
constant time maximum::1.58496250072
node all keys::1.58496250072
middle element twenty::1.58496250072
necessarily complicate matters::1.58496250072
making the search::1.58496250072
child two child::1.58496250072
min and max::1.58496250072
larger than key::1.58496250072
continuing the search::1.58496250072
level two level::1.58496250072
root i compare::1.58496250072
things are ordered::1.58496250072
search to find::1.58496250072
two trivals doing::1.58496250072
property right recall::1.58496250072
deletion take order::1.58496250072
keys in dictionaries::1.58496250072
fairly inefficient implementation::1.58496250072
search to search::1.58496250072
search property keys::1.58496250072
started a level::1.58496250072
keys which satisfies::1.58496250072
process only logarithmic::1.58496250072
leaf okay lets::1.58496250072
search for procedure::1.58496250072
define total order::1.58496250072
right a node::1.58496250072
key and element::1.58496250072
kind of situations::1.58496250072
happen right suppose::1.58496250072
reach that node::1.58496250072
right but binary::1.58496250072
left most node::1.58496250072
shown here written::1.58496250072
talked about dictionary::1.58496250072
ordered dictionary right::1.58496250072
tree so lets::1.58496250072
twelve from twelve::1.58496250072
total order names::1.58496250072
talking about ordered::1.58496250072
predecessor and min::1.58496250072
simplest to understand::1.58496250072
node i gave::1.58496250072
inserting also takes::1.58496250072
insertion okay searching::1.58496250072
logarithmic time log::1.58496250072
key is equal::1.58496250072
thing to find::1.58496250072
takes n order::1.58496250072
elements and deletion::1.58496250072
element with maximum::1.58496250072
search property equals::1.58496250072
tree binary tree::1.58496250072
make a comparison::1.58496250072
right an element::1.58496250072
root empty tree::1.58496250072
procedure binary search::1.58496250072
order the height::1.58496250072
search for element::1.58496250072
successor say predecessor::1.58496250072
dot left child::1.58496250072
implementation an ordered::1.58496250072
large the search::1.58496250072
throw this entire::1.58496250072
tree plus search::1.58496250072
right pseudo code::1.58496250072
right can happen::1.58496250072
left so wee::1.58496250072
lets say reference::1.58496250072
executed the maximum::1.58496250072
recap what binary::1.58496250072
continue this search::1.58496250072
ordering relation keys::1.58496250072
key element pairs::1.58496250072
search for twenty::1.58496250072
implementing ordered dictionaries::1.58496250072
property a binary::1.58496250072
binary tree binary::1.58496250072
element to search::1.58496250072
tree this guy::1.58496250072
suppose your key::1.58496250072
children no children::1.58496250072
twenty five smaller::1.58496250072
begin with refers::1.58496250072
minimum the element::1.58496250072
place to insert::1.58496250072
asked for successor::1.58496250072
notion of predecessor::1.58496250072
smallest key fourteen::1.58496250072
understand this simple::1.58496250072
properties is satisfied::1.58496250072
minimum key element::1.58496250072
nodes whose height::1.58496250072
done we found::1.58496250072
tree all keys::1.58496250072
out the correction::1.58496250072
find an element::1.58496250072
procedure everyone understand::1.58496250072
similarly for deletion::1.58496250072
compute the successor::1.58496250072
kinds of trees::1.58496250072
larger than twelve::1.58496250072
geographic order alphabetic::1.58496250072
right so give::1.58496250072
property the binary::1.58496250072
remember binary search::1.58496250072
height is order::1.58496250072
right any problem::1.58496250072
number of comparisons::1.58496250072
ordered relation assuming::1.58496250072
talked about hashing::1.58496250072
order alphabetic order::1.58496250072
searching for searching::1.58496250072
binary search binary::1.58496250072
return the root::1.58496250072
searching can improve::1.58496250072
key is larger::1.58496250072
version the iterative::1.58496250072
number of nodes::1.58496250072
keys stored left::1.58496250072
implement a ordered::1.58496250072
similarly successor function::1.58496250072
predecessor in constant::1.58496250072
taking only constant::1.58496250072
sub tree larger::1.58496250072
inch away case::1.58496250072
assume keys::1.0
dictionary functionality::1.0
precedes key::1.0
interesting right::1.0
entire discussion::1.0
element key::1.0
property holds::1.0
binary satisfy::1.0
satisfies property::1.0
iterative procedure::1.0
search properties::1.0
constant amount::1.0
takes lot::1.0
unique key::1.0
key element::1.0
array searching::1.0
simplest ways::1.0
comparison size::1.0
ordered relation::1.0
good lets::1.0
recall insertion::1.0
predecessor taking::1.0
hand lets::1.0
empty tree::1.0
right child::1.0
wee compare::1.0
modified right::1.0
order log::1.0
key twelve::1.0
equals nil::1.0
worst case::1.0
duplicate keys::1.0
children means::1.0
searching takes::1.0
point make::1.0
tree left::1.0
function predecessor::1.0
leaf left::1.0
key setting::1.0
predecessor successor::1.0
dictionary right::1.0
loop executed::1.0
minimum takes::1.0
recursively search::1.0
leaf node::1.0
compare key::1.0
right twenty::1.0
list kind::1.0
key value::1.0
wrong suppose::1.0
current node::1.0
data structure::1.0
ordering relation::1.0
search halves::1.0
dictionary successor::1.0
node pointing::1.0
correction position::1.0
smallest key::1.0
pointer reference::1.0
entire elements::1.0
largest key::1.0
right keys::1.0
right place::1.0
unordered list::1.0
total ordered::1.0
pseudo code::1.0
key larger::1.0
takes constant::1.0
eighteen twenty::1.0
tree order::1.0
minimum key::1.0
halve::0.0
forget::0.0
pointing::0.0
maximum::0.0
four::0.0
code::0.0
number::0.0
referring::0.0
show::0.0
alphabetic::0.0
nodes::0.0
case::0.0
dot left::0.0
worst::0.0
decide::0.0
level::0.0
list::0.0
large::0.0
guy::0.0
talked::0.0
ten::0.0
modified::0.0
insertion::0.0
sub::0.0
trivial::0.0
duplicate::0.0
children::0.0
current::0.0
version::0.0
satisfy::0.0
alphabetic order::0.0
logarithmic::0.0
fourteen::0.0
search::0.0
thirty::0.0
shift::0.0
larger::0.0
amount::0.0
loop::0.0
implement::0.0
put::0.0
names::0.0
total::0.0
property equals::0.0
takes::0.0
child nodes::0.0
two::0.0
throw::0.0
process::0.0
call::0.0
today::0.0
started::0.0
basically::0.0
cases::0.0
search trees::0.0
search binary::0.0
recall::0.0
minimum::0.0
making::0.0
root::0.0
compare::0.0
search procedure::0.0
give::0.0
unordered::0.0
end::0.0
recursive::0.0
discussion::0.0
write::0.0
parameter::0.0
wrong::0.0
recursive calls::0.0
order names::0.0
remember::0.0
element::0.0
first::0.0
order::0.0
talk::0.0
holds::0.0
search tree::0.0
satisfied::0.0
satisfies::0.0
pointer::0.0
complicate::0.0
interesting::0.0
differently::0.0
eventually::0.0
return::0.0
entire::0.0
largest::0.0
thirteen::0.0
successor::0.0
easily::0.0
equality::0.0
found::0.0
doing::0.0
precedes::0.0
operation::0.0
out::0.0
shown::0.0
right sub::0.0
excepting::0.0
max::0.0
dictionary::0.0
necessarily::0.0
relation keys::0.0
pairs::0.0
trivals doing::0.0
iterative::0.0
times::0.0
thing::0.0
place::0.0
twenty::0.0
organize::0.0
features::0.0
smaller::0.0
done::0.0
array::0.0
size::0.0
properties::0.0
similarly::0.0
ordering::0.0
data::0.0
inefficient::0.0
recursively::0.0
complicate matters::0.0
kind::0.0
showed::0.0
tree::0.0
inefficient implementation::0.0
correction::0.0
talking::0.0
manner::0.0
root empty::0.0
null::0.0
min::0.0
note::0.0
finding::0.0
begin::0.0
reach::0.0
comparisons::0.0
comparison::0.0
class::0.0
geographic::0.0
don::0.0
ways::0.0
part::0.0
notion::0.0
dot::0.0
executed::0.0
relation::0.0
successor function::0.0
find::0.0
make::0.0
keys::0.0
parameters::0.0
implementation::0.0
situations::0.0
written::0.0
constant::0.0
predecessor::0.0
handle::0.0
means::0.0
trees::0.0
rest::0.0
settings::0.0
set::0.0
reference::0.0
depends::0.0
halves::0.0
smallest::0.0
simplest::0.0
tree larger::0.0
equals::0.0
implementing::0.0
key::0.0
problem::0.0
improve::0.0
essentially::0.0
taking::0.0
node child::0.0
equal::0.0
asked::0.0
point::0.0
simple::0.0
height::0.0
relation assuming::0.0
ordered::0.0
trivialities::0.0
hindi::0.0
empty::0.0
define::0.0
predecessor takes::0.0
understand::0.0
child::0.0
value::0.0
suppose::0.0
property::0.0
procedure::0.0
middle::0.0
eighteen::0.0
binary::0.0
geographic order::0.0
middle element::0.0
deletion::0.0
inch::0.0
children node::0.0
fairly::0.0
nil::0.0
hand::0.0
running::0.0
levels::0.0
student::0.0
similarly successor::0.0
element twenty::0.0
position::0.0
left::0.0
things::0.0
recap::0.0
stored::0.0
questions::0.0
wee::0.0
lets::0.0
setting::0.0
location::0.0
property keys::0.0
gave::0.0
couple::0.0
matters::0.0
unique::0.0
insert::0.0
dictionaries::0.0
continue::0.0
twelve::0.0
right::0.0
tree binary::0.0
searching::0.0
element pairs::0.0
permitting::0.0
matching::0.0
leaf::0.0
assuming::0.0
trivals::0.0
inserting::0.0
noise::0.0
run::0.0
continuing::0.0
step::0.0
procedure binary::0.0
refers::0.0
integers::0.0
good::0.0
lies::0.0
log::0.0
eleven::0.0
question::0.0
start::0.0
lot::0.0
remember binary::0.0
function::0.0
compute::0.0
clear::0.0
delete::0.0
adopt::0.0
doesn::0.0
happen::0.0
field::0.0
interested::0.0
functionality::0.0
node::0.0
elements::0.0
kinds::0.0
structure::0.0
hashing::0.0
calls::0.0
assume::0.0
pseudo::0.0
key fourteen::0.0
