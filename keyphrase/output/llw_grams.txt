list from wikipedia
encyclopedia this article
includes a list
list of references
sources remain unclear
insufficient inline citations
improve this article
article by introducing
introducing more precise
data structure consisting
group of nodes
represent a sequence
node is composed
composed of data
complex variants add
variants add additional
add additional links
links this structure
insertion or removal
removal of elements
sequence a linked
list whose nodes
node the last
node is linked
signify the end
list linked lists
common data structures
common abstract data
abstract data types
abstract data type
uncommon to implement
basis of implementation
implementation the principal
easily be inserted
inserted or removed
removed without reallocation
reallocation or reorganization
contiguously in memory
compiling and running
running the program
program linked lists
lists allow insertion
insertion and removal
removal of nodes
number of operations
link being added
added or removed
removed is maintained
maintained during list
simple linked lists
form of efficient
obtaining the last
maintained as separate
separate node reference
finding a node
locating the place
inserted may require
require sequential scanning
elements the advantages
advantages and disadvantages
concepts and nomenclature
singly linked list
doubly linked list
multiply linked list
circular linked list
lists vs dynamic
singly linked linear
linked linear lists
linked list operations
linearly linked lists
6.1.1 singly linked
singly linked lists
circularly linked list
lists using arrays
arrays of node
internal and external
speeding up search
random access lists
related data structures
external links advantages
dynamic data structure
allocating the needed
program is running
running * insertion
insertion and deletion
deletion node operations
list * linear
linear data structures
stacks and queues
expand in real
memory overhead disadvantages
due to pointers
pointers requiring extra
requiring extra storage
extra storage space
space * nodes
read in order
beginning as linked
inherently sequential access
access * nodes
nodes are stored
required to access
access individual elements
list * difficulties
arise in linked
traversing for instance
lists are cumbersome
cumbersome to navigate
doubly linked lists
easier to read
memory is wasted
wasted in allocating
back pointer history
lists were developed
shaw and herbert
herbert a simon
simon at rand
primary data structure
information processing language
processing language ipl
authors to develop
develop several early
early artificial intelligence
artificial intelligence programs
including the logic
logic theory machine
general problem solver
computer chess program
chess program reports
appeared in ire
transactions on information
western joint computer
joint computer conference
first unesco international
unesco international conference
conference on information
now-classic diagram consisting
consisting of blocks
blocks representing list
representing list nodes
nodes with arrows
pointing to successive
successive list nodes
list nodes appears
programming the logic
newell and shaw
shaw in proc
newell and simon
simon were recognized
acm turing award
made basic contributions
contributions to artificial
psychology of human
problem of machine
translation for natural
natural language processing
language processing led
processing led victor
led victor yngve
yngve at massachusetts
institute of technology
lists as data
comit programming language
language for computer
field of linguistics
linguistics a report
language for mechanical
translation " appeared
appeared in mechanical
standing for list
created by john
published its design
entitled " recursive
functions of symbolic
computation by machine
lisp s major
major data structures
lists and languages
primary data representation
established bert green
mit lincoln laboratory
lincoln laboratory published
published a review
review article entitled
entitled " computer
languages for symbol
transactions on human
factors in electronics
electronics in march
summarized the advantages
linked list approach
comparison of list-processing
list-processing computer languages
bobrow and raphael
appeared in communications
acm in april
operating systems developed
developed by technical
technical systems consultants
originally of west
west lafayette indiana
lists as file
structures a directory
directory entry pointed
file were located
located by traversing
traversing pointers systems
technique included flex
developed by tsc
marketed by smoke
smoke signal broadcasting
broadcasting in california
tss operating system
developed by ibm
double linked list
file system catalog
catalog the directory
structure was similar
similar to unix
directories and extend
depth basic concepts
node the field
pointer the remaining
payload  fields
fields the head
node the tail
list in lisp
car singly linked
lists contain nodes
next  field
node in line
line of nodes
linked lists include
lists include insertion
deletion and traversal
node doubly linked
doubly linked list
link field pointing
previous  node
node a technique
single link field
requires the ability
operations on addresses
languages multiply linked
multiply linked list
set of data
date of birth
leads to simpler
separate case circular
case circular linked
make it point
case the list
linear a circular
circular doubly linked
change that occurs
list is linked
list and vice
vice versa sentinel
versa sentinel nodes
dummy  node
first data record
simplifies and accelerates
accelerates some list-handling
last " node
node empty lists
nodes if sentinel
sentinel nodes hash
nodes hash linking
records are stored
array and referenced
data records list
records list handles
node gives access
algorithms that manipulate
manipulate linked lists
lists and return
return the handles
lists in fact
word " list
means " list
handle that consists
first and last
last nodes combining
nodes combining alternatives
lists without sentinels
circular singly linked
lists with sentinels
choices in computer
programming and design
circumstances a linked
linked list data
list data structure
structure might work
common tradeoffs involving
tradeoffs involving linked
involving linked list
linked list structures
list structures linked
structures linked lists
comparison of list
list data structures
data structures linked
structures linked list
linked list array
list array dynamic
array dynamic array
dynamic array balanced
array balanced tree
balanced tree random
tree random access
random access list
access list indexing
element is unknown
updating wasted space
structure that allocates
allocates all elements
number of elements
array is exceeded
expensive operation linked
operation linked lists
advantages over dynamic
dynamic arrays insertion
insertion or deletion
indexed a pointer
array at random
locations will require
require moving half
elements on average
array in constant
marking its slot
fragmentation that impedes
impedes the performance
performance of iteration
arbitrarily many elements
underlying array data
array data structure
reallocate an expensive
memory is fragmented
cost of reallocation
averaged over insertions
due to reallocation
helps with appending
array s end
positions still carries
carries prohibitive costs
prohibitive costs due
due to data
moving to maintain
contiguity an array
elements are removed
resized in order
order to avoid
fixed-size array data
array data structures
constant-time random access
access to elements
elements singly linked
direction this makes
makes linked lists
linked lists unsuitable
unsuitable for applications
heapsort sequential access
access on arrays
arrays and dynamic
locality of referenceand
referenceand thus make
caching another disadvantage
disadvantage of linked
extra storage needed
needed for references
makes them impractical
impractical for lists
lists of small
small data items
characters or boolean
links may exceed
data in contrast
dynamic array requires
amount of control
problem generally solved
solved using memory
pools some hybrid
combine the advantages
two representations unrolled
representations unrolled linked
unrolled linked lists
store several elements
increasing cache performance
performance while decreasing
decreasing memory overhead
overhead for references
references cdr coding
actual data referenced
record a good
highlights the pros
pros and cons
arrays vs linked
implementing a program
program that resolves
resolves the josephus
problem the josephus
method that works
group of people
circle n times
reach the nth
close the circle
circle then count
times and repeat
repeat the process
person is left
left that person
wins the election
election this shows
shows the strengths
strengths and weaknesses
view the people
people as connected
easily the linked
rearrange the links
poor at finding
person to remove
finds that person
person a dynamic
poor at deleting
remove one node
easy to find
find the nth
array the list
list ranking problem
ranking problem concerns
concerns the efficient
linked list representation
array although trivial
solving this problem
problem by aparallel
algorithm is complicated
research a balanced
tree has similar
similar memory access
memory access patterns
patterns and space
list while permitting
overhead of tree
manipulations to maintain
maintain balance schemes
balance schemes exist
exist for trees
trees or red-black
trees singly linked
doubly-linked and circular
lists have advantages
advantages over singly-linked
singly-linked linear lists
linear lists offer
offer some advantages
advantages that make
make them preferable
linked linear list
recursive data structure
merging two lists
enumerating the elements
elements in reverse
simple recursive algorithms
solution using iterative
circularly linked lists
generally need extra
complicated base cases
base cases linear
linear singly linked
common final portion
portion of sub-list
two different lists
node is added
persistent data structure
two different circular
singly linked non-circular
linked non-circular lists
proper list ends
denoted by nil
car and cdr
cdr links point
car or cdr
cdr of anylist
anylist the advantages
efficiency a circular
variables that point
cost doubly linked
double-linked lists require
require more space
space per node
easier to manipulate
fast and easy
easy sequential access
insert or delete
delete a node
node s address
node some algorithms
algorithms require access
persistent data structures
structures circularly linked
option to represent
e.g the corners
pool of buffers
released in fifo
set of processes
time-shared in round-robin
node gives easy
applications that require
handle the structure
two a circular
two circular lists
giving the addresses
piece the operation
consists in swapping
swapping the contents
two nodes applying
two distinct lists
distinct lists joins
property greatly simplifies
simplifies some algorithms
algorithms and data
quad-edge and face-edge
face-edge the simplest
empty circular list
thing makes sense
handle it separately
separately by contrast
null to denote
denote an empty
empty linear list
creates fewer special
fewer special cases
cases using sentinel
node may simplify
simplify certain list
previous nodes exist
eliminate some end-of-list
scanning the list
setting the sentinel
sentinel s data
makes it unnecessary
unnecessary to test
test for end-of-list
inside the loop
merging two sorted
two sorted lists
sentinels have data
data fields set
handling for empty
complicate other operations
simulate a linear
complexity by adding
adding a single
single sentinel node
first data nodes
empty list consists
link the list
last data node
list is empty
simplify the handling
doubly linked linear
manipulating linked lists
invalidated in previous
assignments this makes
algorithms for inserting
inserting or deleting
deleting linked list
linked list nodes
nodes somewhat subtle
subtle this section
section gives pseudocode
pseudocode for adding
adding or removing
linked lists in-place
marker or sentinel
number of ways
ways linearly linked
node data structure
empty list record
list record node
data being stored
null for last
node firstnode points
points to first
node of list
list ; null
null for empty
list is simple
list.firstnode while node
node not null
inserts a node
list the diagram
inserting a node
node and insert
insert a node
newnode after node
requires a separate
function this requires
requires updating firstnode
updating firstnode function
firstnode function insertbeginning
node before current
current first node
first node newnode.next
functions for removing
removing the node
removing a node
find and remove
previous element function
element function removeafter
remove node past
node.next.next destroy obsoletenode
destroy obsoletenode function
obsoletenode function removebeginning
remove first node
first node obsoletenode
list.firstnode.next point past
point past deleted
past deleted node
deleted node destroy
node destroy obsoletenode
destroy obsoletenode notice
notice that removebeginning
list.firstnode to null
null when removing
removing the last
nt iterate backwards
insertbefore or removebefore
appending one linked
traverse the entire
entire first list
list in order
order to find
find the tail
two linearly linked
appending has asymptotic
asymptotic time complexity
family of languages
appending is provided
cases of linked
eliminated by including
including a dummy
list this ensures
list and renders
renders both insertbeginning
first useful data
atlist.firstnode.next circularly linked
nodes are linked
null for lists
stores a reference
first node elements
list and removed
front in constant
linked both types
linked lists benefit
ability to traverse
traverse the full
full list beginning
avoid storing firstnode
firstnode and lastnode
variable which points
representation significantly simplifies
significantly simplifies adding
adding and removing
special case algorithms
assuming that somenode
starting with somenode
somenode null node
node.next while node
node somenode notice
test was moved
procedure would fail
node this function
node " newnode
node " node
empty function insertafter
node = null
newnode else newnode.next
append " newnode
newnode to insert
insert " newnode
newnode linked lists
support any type
type of reference
links by replacing
pointers with array
indices the approach
array of records
record has integer
integer fields indicating
indicating the index
linked list record
entry in array
array integer prev
prev ; previous
build by creating
creating an array
variable to store
store the index
first element integer
element integer listhead
integer listhead entry
listhead entry records
links between elements
elements are formed
formed by placing
placing the array
index next prev
prev name balance
notice that entry
list these cells
list by creating
creating a listfree
listfree integer variable
code would traverse
traverse the list
list and display
names and account
.balance print entry
.next when faced
list is relocatable
serialized for storage
storage on disk
disk or transfer
indexes can occupy
significantly less space
architectures * locality
locality of reference
improved by keeping
keeping the nodes
dynamic memory allocators
allocators can produce
produce an excessive
amount of overhead
overhead is incurred
incurred per node
approach * seizing
seizing an entry
array is faster
dynamic memory allocation
allocation typically requires
requires a search
free memory block
size this approach
creates and manages
manages a private
private memory space
nodes this leads
implementation * growing
growing a large
difficult or impossible
linked list node
general memory pool
easier * adding
unexpectedly take linear
memory pool leaves
leaves more memory
list is smaller
smaller than expected
nodes are freed
support dynamic memory
allocation these disadvantages
array is created
created language support
lisp and scheme
linked lists built
lists are constructed
constructed from nodes
consor cons cell
cell the cons
node although cons
build other data
purpose in languages
languages that support
support abstract data
types or templates
linked list adts
adts or templates
building linked lists
built using references
constructing a linked
store the data
store a reference
external storage internal
storage internal storage
advantage of making
data more efficient
requiring less storage
simplifying memory management
data is allocated
allocated and deallocated
structure and machine
list no matter
makes it easy
easy to place
data in multiple
multiple linked lists
lists by including
multiple next references
create separate routines
routines to add
add or delete
delete cells based
create additional linked
additional linked lists
lists of elements
lists store references
data in general
included in linked
generic linked list
linked list package
package using external
sets of data
single linked list
prev if double
location after defining
defining separate structures
type of data
amount of data
structures and contained
structures then generic
structure to perform
perform linked list
linked list type
list type operations
handle the specific
data this approach
message parsing routines
types of messages
messages are received
set of fields
including a field
field for message
type the generic
add new messages
queue in order
order to process
process the message
message the message
message type field
call the correct
routine to process
process the specific
type of message
suppose you wanted
wanted to create
create a linked
list of families
members using internal
firstname ; integer
lastname ; string
address ; member
member members head
head of list
list of members
print a complete
start at head
head of families
afamily null loop
loop through list
families print information
information about family
afamily.members get head
family s members
members while amember
amember null loop
members print information
information about member
afamily.next using external
generic link structure
link structure node
pointer data generic
data generic pointer
pointer for data
data at node
structure for family
family member string
member string firstname
family string lastname
address ; node
node members head
members using external
list while famnode
famnode null loop
famnode.data extract family
family from node
node print information
afamily.members get list
list of family
members while memnode
memnode null loop
memnode.data extract member
member from node
step is needed
needed to extract
extract the record
node and cast
proper data type
family are stored
two linked lists
number of families
member can belong
internal storage works
finding a specific
disadvantages of linked
structures in addition
two simple ways
ways to improve
heuristic for decreasing
decreasing average search
moves an element
found this scheme
handy for creating
creating simple caches
recently used items
quickest to find
efficient external data
external data structure
build a red-black
tree or hash
table whose elements
elements are references
list nodes multiple
multiple such indexes
list the disadvantage
list with support
support for fast
fast random access
access to read
read or modify
modify any element
skew binary random
binary random access
random access listusing
listusing the skew
skew binary number
binary number system
involves a list
list of trees
trees with special
logarithmic time random
element by index
implemented as persistent
viewed as immutable
immutable linked lists
head and tail
extension to random
operation that yields
yields the minimum
list in constant
implemented using linked
restrict the type
type of operations
supported the skip
linked list augmented
augmented with layers
layers of pointers
jumping over large
numbers of elements
layer this process
list a binary
type of linked
nature the result
node may include
include a reference
two other linked
form the subtrees
node an unrolled
unrolled linked list
array of data
values this leads
leads to improved
improved cache performance
elements are contiguous
contiguous in memory
reduced memory overhead
list a hash
lists to store
store the chains
chains of items
items that hash
table a heap
references from node
node to node
previous data indexes
indexes are calculated
data s index
index a self-organizing
self-organizing list rearranges
rearranges its nodes
heuristic which reduces
reduces search times
times for data
retrieval by keeping
keeping commonly accessed
commonly accessed nodes
control data required
number of dimensions
algorithm design manual
linear time searching
complexity trade-offs juniata
trade-offs juniata college
juniata college spring
style at goingnative
channel9.msdn.com from minute
andrej ; carlsson
svante ; sedgewick
robert ; munro
arrays in optimal
department of computer
university of waterloo
william ; topp
purely functional random-access
functional random-access lists
functional programming languages
languages and computer
ch20 data structures
structures ; id06
programming with java
book big java
vreda ; black
eds " linked
dictionary of algorithms
data structures national
structures national institute
institute of standards
standards and technology
2004-12-14 * antonakos
practical data structures
0-13-280843-9 * collins
java collections framework
framework new york
0-07-282379-8 * cormen
introduction to algorithms
algorithms mit press
0-262-03293-7 * cormen
0-262-03293-7 * green
0-201-89683-4 * newell
allen ; shaw
linked list basics
stanford university retrieved
2009-09-21 * sedgewick
0-201-31452-5 * shaffer
introduction to data
structures and algorithm
analysis new jersey
0-13-660911-2 * wilkes
simple list-processing language
review in automatic
90013-8 * wilkes
acm national conference
linux kernel linked
kernel linked list
linked list explained
retrieved 2009-09-21 external
2009-09-21 external links
commons has media
related to linked
lists * description
structures * introduction
introduction to linked
stanford university computer
university computer science
computer science library
library * linked
linked list problems
library * open
open data structures
lists * patent
patent was granted
data structures types
types * collection
collection * container
abstract * associative
array * double-ended
double-ended priority queue
queue * double-ended
queue * list
list * map
map * multimap
multimap * priority
queue * queue
queue * set
set * multiset
multiset * disjoint
sets * stack
arrays * bit
array * circular
buffer * dynamic
array * hash
table * hashed
hashed array tree
tree * sparse
sparse array linked
linked * association
list * linked
list * skip
list * unrolled
list * xor
xor linked list
linked list trees
trees * b-tree
b-tree * binary
binary search tree
avl * red-black
red-black * self-balancing
self-balancing * splay
splay * heap
heap * binary
binary * binomial
binomial * fibonacci
fibonacci * r-tree
hilbert * trie
trie * hash
hash tree graphs
graphs * binary
binary decision diagram
diagram * directed
directed acyclic graph
graph * directed
directed acyclic word
acyclic word graph
graph * list
list of data
data structures authority
structures authority control
control * gnd
lists * data
linked list
free encyclopedia
article includes
sources remain
remain unclear
insufficient inline
inline citations
precise citations
computer science
data structure
structure consisting
simplest form
complex variants
variants add
additional links
efficient insertion
integer value
last node
list linked
linked lists
common data
data structures
common abstract
abstract data
data types
including lists
data type
associative arrays
principal benefit
conventional array
list elements
entire structure
data items
source code
program linked
constant number
list traversal
random access
efficient indexing
basic operations
separate node
node reference
list structure
sequential scanning
basic concepts
sentinel nodes
empty lists
hash linking
list handles
combining alternatives
dynamic arrays
linear lists
list operations
language support
external storage
access lists
related data
external links
links advantages
dynamic data
needed memory
deletion node
node operations
linear data
reduce access
memory overhead
overhead disadvantages
pointers requiring
extra storage
storage space
sequential access
individual elements
reverse traversing
navigate backwards
allocating space
back pointer
pointer history
allen newell
cliff shaw
rand corporation
primary data
information processing
processing language
language ipl
early artificial
artificial intelligence
intelligence programs
logic theory
theory machine
general problem
problem solver
computer chess
chess program
program reports
work appeared
ire transactions
information theory
conference proceedings
including proceedings
western joint
joint computer
computer conference
first unesco
international conference
now-classic diagram
diagram consisting
blocks representing
representing list
list nodes
arrows pointing
successive list
nodes appears
proc wjcc
acm turing
turing award
basic contributions
human cognition
list processing
machine translation
natural language
language processing
processing led
led victor
victor yngve
massachusetts institute
comit programming
programming language
computer research
language entitled
mechanical translation
list processor
recursive functions
symbolic expressions
major data
data representation
established bert
mit lincoln
lincoln laboratory
laboratory published
review article
article entitled
computer languages
symbol manipulation
human factors
list approach
list-processing computer
operating systems
systems developed
technical systems
systems consultants
west lafayette
lafayette indiana
chapel hill
north carolina
file structures
directory entry
entry pointed
first sector
succeeding portions
traversing pointers
pointers systems
technique included
included flex
variant developed
smoke signal
signal broadcasting
operating system
file system
system catalog
directory structure
next link
next pointer
remaining fields
first node
derived languages
head node
data field
nodes operations
lists include
include insertion
main article
next-node link
link field
field pointing
link forward
link backward
previous node
single link
technique requires
bit operations
high-level languages
link fields
data records
special cases
efficient algorithms
separate case
case circular
circular linked
null reference
special value
common convention
vice versa
versa sentinel
sentinel node
extra sentinel
first data
data record
convention simplifies
list-handling algorithms
data elements
node empty
empty list
nodes hash
physically part
separate array
records list
list algorithms
input lists
resulting lists
list handle
last nodes
nodes combining
alternatives listed
computer programming
list data
common tradeoffs
tradeoffs involving
list structures
structures linked
list array
dynamic array
array balanced
balanced tree
tree random
access list
list indexing
last element
middle search
wasted space
current number
space reserved
expensive operation
operation linked
arrays insertion
specific point
insertion point
constant-time operation
random locations
moving half
worst case
total memory
underlying array
array data
appending elements
middle positions
prohibitive costs
data moving
maintain contiguity
avoid wasting
fixed-size array
constant-time random
optimal locality
data caching
storage needed
small data
boolean values
storage overhead
array requires
small amount
control data
allocate memory
memory pools
hybrid solutions
representations unrolled
list node
decreasing memory
references cdr
cdr coding
replacing references
actual data
data referenced
referencing record
josephus problem
election method
people stand
circle starting
predetermined person
nth person
members close
person wins
connected nodes
delete nodes
deleting nodes
list ranking
ranking problem
problem concerns
efficient conversion
list representation
conventional computer
aparallel algorithm
similar memory
memory access
access patterns
space overhead
deletion operations
expensive due
tree manipulations
maintain balance
balance schemes
schemes exist
balanced state
avl trees
red-black trees
circular lists
singly-linked linear
lists offer
linear list
recursive data
smaller object
reverse order
simple recursive
recursive algorithms
iterative commands
recursive solutions
extra arguments
complicated base
base cases
cases linear
common final
final portion
terminal portion
list remains
persistent data
end-sentinel nodes
non-circular lists
end-sentinel node
proper list
list ends
special node
cdr links
links point
lisp procedure
fancy variants
circular list
extra cost
double-linked lists
lists require
elementary operations
easy sequential
algorithms require
require access
natural option
represent arrays
round-robin order
node serves
easy access
circular structure
single pointer
operation consists
nodes applying
distinct lists
lists joins
simplest representation
empty circular
thing makes
makes sense
null pointer
special case
empty linear
fewer special
previous nodes
nodes exist
end-of-list tests
end-of-list inside
sorted lists
data fields
fields set
output node
special handling
extra space
short lists
single sentinel
data nodes
list consists
last data
data node
dummy node
previous assignments
makes algorithms
removing nodes
lists in-place
end-of-list marker
node data
variable firstnode
list record
record node
node node
record list
node firstnode
firstnode points
code inserts
existing node
diagram shows
works inserting
function insertafter
node newnode
insert newnode
node.next node.next
newnode inserting
list requires
separate function
updating firstnode
firstnode function
function insertbeginning
list list
insert node
current first
list.firstnode list.firstnode
diagram demonstrates
previous element
element function
function removeafter
remove node
node past
node.next.next destroy
destroy obsoletenode
obsoletenode function
function removebeginning
node obsoletenode
list.firstnode.next point
point past
past deleted
deleted node
node destroy
obsoletenode notice
iterate backwards
efficient insertbefore
removebefore operations
entire first
first list
list appending
lisp family
append procedure
dummy element
found atlist.firstnode.next
continuous circle
node elements
doubly linked
lists benefit
full list
list beginning
avoid storing
storing firstnode
special representation
non-empty list
case algorithms
non-empty circular
code iterates
list starting
function iterate
somenode null
null node
node.value node
node somenode
somenode notice
function inserts
empty function
newnode suppose
variable pointing
newnode linked
create links
replacing pointers
array indices
integer fields
fields indicating
supported,parallel arrays
record entry
array integer
integer prev
previous entry
real balance
first element
element integer
integer listhead
listhead entry
entry records
array index
prev field
first entry
list notice
listfree integer
free list
display names
account balance
list print
.balance print
print entry
approach include
small list
array indexes
full pointer
general store
dynamic memory
memory allocators
excessive amount
overhead storage
node allocated
allocation overhead
pre-allocated array
memory allocation
free memory
memory block
desired size
main disadvantage
private memory
memory space
increases complexity
large array
finding space
general memory
memory pool
adding elements
amortized constant
pool leaves
maximum size
created language
programming languages
lists built
functional languages
consor cons
cons cell
cons cells
primary purpose
support abstract
list adts
building linked
internal storage
making access
simplifying memory
memory management
machine code
multiple linked
multiple lists
including multiple
separate routines
delete cells
cells based
store references
list package
languages involves
initial fields
separate structures
generic structure
minimum amount
data shared
generic routines
minimal structure
list type
type operations
specific data
message parsing
parsing routines
message type
type field
correct routine
specific type
record member
family member
string firstname
integer age
record family
string lastname
string address
member members
members head
complete list
families start
families list
null loop
families print
print information
family amember
amember null
members print
member amember
amember.next afamily
generic link
link structure
structure node
pointer data
generic pointer
member string
family string
node members
famnode null
famnode.data extract
extract family
node print
family memnode
family members
memnode null
members amember
memnode.data extract
extract member
member memnode
memnode.next famnode
famnode.next notice
extra step
proper data
parametric types
storage works
member needed
arbitrary number
specific number
specific element
linear search
primary disadvantages
variants discussed
simple ways
improve search
unordered list
decreasing average
average search
move-to-front heuristic
creating simple
simple caches
common approach
efficient external
external data
red-black tree
nodes multiple
single list
fast random
skew binary
binary random
access listusing
binary number
number system
special properties
worst-case constant
worst-case logarithmic
likewise support
tail operations
simple extension
additional operation
minimum element
entire list
clarification needed
mutation complexities
skip list
list augmented
large numbers
process continues
bottom layer
actual list
binary tree
data values
improved cache
cache performance
reduced memory
hash table
heap shares
ordering properties
previous data
data indexes
current data
self-organizing list
list rearranges
nodes based
reduces search
search times
data retrieval
accessed nodes
list notes
data required
per-array constant
per-dimension constant
bytes footnotes
algorithm design
list predecessor
singly-linked list
gerald kruse
lecture notes
complexity trade-offs
trade-offs juniata
juniata college
college spring
bjarne stroustrup
number crunching
resizable arrays
technical report
functional random-access
random-access lists
functional programming
computer architecture
acm press
ch20 data
big java
cays horstmann
national institute
technology retrieved
practical data
java collections
collections framework
mcgraw hill
algorithms mit
mit press
fundamental algorithms
list basics
stanford university
university retrieved
addison wesley
practical introduction
algorithm analysis
prentice hall
maurice vincent
self-compiling compiler
simple list-processing
list-processing language
annual review
automatic programming
pergamon press
national conference
linux kernel
kernel linked
list explained
wikimedia commons
media related
university computer
science library
list problems
open data
structures types
container abstract
associative array
double-ended priority
priority queue
double-ended queue
disjoint sets
stack arrays
bit array
circular buffer
hashed array
array tree
sparse array
array linked
association list
list trees
binary search
search tree
tree graphs
binary decision
decision diagram
acyclic graph
acyclic word
word graph
structures authority
authority control
linked
list
wikipedia
free
encyclopedia
article
includes
references
sources
remain
unclear
insufficient
inline
citations
improve
introducing
precise
march
computer
science
data
structure
consisting
group
nodes
represent
sequence
simplest
form
node
composed
reference
words
link
complex
variants
add
additional
links
efficient
insertion
removal
elements
position
two
fields
integer
value
last
terminator
signify
end
lists
common
structures
implement
abstract
types
including
type
stacks
queues
associative
arrays
s-expressions
uncommon
directly
basis
implementation
principal
benefit
conventional
array
easily
inserted
removed
reallocation
reorganization
entire
items
stored
contiguously
memory
disk
declared
source
code
compiling
running
program
point
constant
number
operations
previous
added
maintained
traversal
hand
simple
random
access
indexing
basic
obtaining
assuming
separate
finding
datum
locating
place
require
sequential
scanning
advantages
disadvantages
contents
hide
history
concepts
nomenclature
singly
doubly
multiply
circular
sentinel
empty
hash
linking
handles
combining
alternatives
tradeoffs
dynamic
linear
circularly
linearly
6.1.1
6.2.1
algorithms
language
support
internal
external
storage
speeding
search
related
notes
footnotes
edit
allocating
needed
deletion
implemented
executed
reduce
expand
real
overhead
tendency
due
pointers
requiring
extra
space
read
order
beginning
inherently
incontiguously
greatly
increasing
required
individual
difficulties
arise
reverse
traversing
instance
cumbersome
navigate
backwards
easier
wasted
back
pointer
developed
allen
newell
cliff
shaw
herbert
simon
rand
corporation
primary
information
processing
ipl
authors
develop
early
artificial
intelligence
programs
logic
theory
machine
general
problem
solver
chess
reports
work
appeared
ire
transactions
conference
proceedings
western
joint
first
unesco
international
now-classic
diagram
blocks
representing
arrows
pointing
successive
appears
programming
proc
wjcc
february
recognized
acm
turing
award
made
contributions
psychology
human
cognition
translation
natural
led
victor
yngve
massachusetts
institute
technology
mit
comit
research
field
linguistics
report
entitled
mechanical
lisp
standing
processor
created
john
mccarthy
published
design
paper
communications
recursive
functions
symbolic
expressions
computation
part
major
1960s
utility
languages
representation
established
bert
green
lincoln
laboratory
review
symbol
manipulation
factors
electronics
summarized
approach
comparison
list-processing
bobrow
raphael
april
operating
systems
technical
consultants
originally
west
lafayette
indiana
chapel
hill
north
carolina
file
directory
entry
pointed
sector
succeeding
portions
located
technique
included
flex
motorola
cpu
mini-flex
flex9
variant
tsc
marketed
smoke
signal
broadcasting
california
manner
tss
system
ibm
machines
double
catalog
similar
unix
files
directories
extend
depth
record
element
node
address
next
pointer
remaining
data
information
value
cargo
payload
head
tail
rest
head
derived
cdr
pronounced
could-er
payload
car
points
line
performed
include
main
doubly
next-node
previous
forward
backwards
prev
forward
backward
xor-linking
single
requires
ability
bit
addresses
high-level
multiply
connect
set
records
e.g
department
date
birth
special
cases
fact
orders
opposite
leads
simpler
treated
case
null
lack
convention
make
circular
circularly
open
linear
change
occurs
tail
front
vice
versa
implementations
sentinel
dummy
simplifies
accelerates
list-handling
ensuring
safely
dereferenced
physically
referenced
indices
address
pointer
handle
manipulate
input
return
resulting
context
word
means
handle
situations
convenient
consists
listed
arbitrarily
combined
sentinels
choices
method
suited
circumstances
problems
involving
balanced
tree
log
element
unknown
n
amortized
updating
middle
average
allocates
count
current
reserved
exceeded
reallocated
possibly
copied
expensive
operation
specific
indexed
constant-time
locations
moving
half
worst
delete
marking
slot
vacant
fragmentation
impedes
performance
iteration
limited
total
eventually
fill
underlying
reallocate
fragmented
cost
averaged
insertions
helps
appending
inserting
removing
positions
carries
prohibitive
costs
maintain
contiguity
resized
avoid
wasting
fixed-size
traversed
direction
makes
unsuitable
applications
index
quickly
heapsort
faster
optimal
locality
referenceand
good
caching
disadvantage
impractical
small
characters
boolean
values
exceed
factor
size
contrast
amount
control
note
slow
allocator
wasteful
allocate
separately
generally
solved
pools
hybrid
solutions
combine
representations
unrolled
store
cache
decreasing
cdr
coding
replacing
actual
extends
referencing
highlights
pros
cons
implementing
resolves
josephus
election
works
people
stand
circle
starting
predetermined
person
times
reach
nth
out
members
close
repeat
process
left
wins
shows
strengths
weaknesses
view
connected
rearrange
poor
remove
finds
deleting
individually
shifting
exceptionally
easy
find
ranking
concerns
conversion
trivial
solving
aparallel
algorithm
complicated
subject
patterns
permitting
taking
manipulations
balance
schemes
exist
trees
automatically
state
avl
red-black
doubly-linked
singly-linked
offer
preferable
smaller
object
reason
merging
enumerating
solution
iterative
commands
adapted
procedures
arguments
base
tail-sharing
final
portion
sub-list
terminal
remains
persistent
true
belong
end-sentinel
shared
non-circular
proper
ends
denoted
nil
car
procedure
anylist
fancy
complexity
efficiency
emulated
variables
double-linked
elementary
fast
directions
insert
option
naturally
corners
polygon
pool
buffers
released
fifo
processes
time-shared
round-robin
serves
queue
split
giving
piece
swapping
applying
distinct
joins
property
quad-edge
face-edge
thing
sense
indicating
choice
test
denote
creates
fewer
simplify
eliminate
end-of-list
tests
setting
unnecessary
inside
loop
sorted
output
handling
short
complicate
creation
simulate
adding
trick
turning
dummy
manipulating
in-place
care
invalidated
assignments
subtle
section
pseudocode
nullto
marker
ways
variable
firstnode
list.firstnode
node.data
node.next
inserts
existing
done
track
function
insertafter
newnode
newnode.next
insertbeginning
similarly
demonstrates
removeafter
past
obsoletenode
node.next.next
destroy
removebeginning
list.firstnode.next
deleted
notice
sets
nt
iterate
insertbefore
removebefore
inefficient
traverse
append
length
asymptotic
family
provided
eliminated
ensures
renders
found
atlist.firstnode.next
continuous
stores
full
storing
lastnode
alastnode
significantly
non-empty
somenode
iterates
node.value
moved
fail
assumes
suppose
create
supported,parallel
prev
string
build
creating
listhead
formed
placing
cell
jones
smith
joseph
adams
adam
ignore
ignatius
anita
location
cells
additions
listfree
entries
increased
display
names
account
print
.name
.balance
.next
faced
relocatable
meaning
serialized
transfer
network
indexes
occupy
architectures
improved
keeping
periodically
rearranging
allocators
produce
excessive
allocated
allocation
incurred
seizing
pre-allocated
typically
block
desired
manages
private
issues
increases
growing
large
difficult
impossible
occasionally
unexpectedly
leaves
expected
freed
reasons
mitigated
maximum
scheme
built
functional
constructed
consor
purpose
templates
adts
building
constructing
advantage
making
simplifying
management
deallocated
generic
matter
multiple
routines
based
slightly
package
likewise
involves
initial
defining
defined
minimum
contained
top
minimal
perform
message
parsing
messages
received
start
call
correct
routine
wanted
families
member
firstname
age
lastname
complete
write
afamily
amember
afamily.members
amember.next
afamily.next
famnode
famnode.data
extract
memnode
memnode.data
memnode.next
famnode.next
step
cast
parametric
long
compile
arbitrary
run
addition
discussed
unordered
heuristic
move-to-front
simply
moves
handy
caches
recently
quickest
table
updated
modify
skew
binary
listusing
properties
worst-case
logarithmic
viewed
immutable
extension
min-list
yields
clarification
mutation
complexities
restrict
supported
skip
augmented
layers
jumping
numbers
descending
layer
continues
bottom
nature
result
subtrees
contiguous
reduced
metadata
chains
heap
shares
ordering
calculated
self-organizing
rearranges
reduces
retrieval
commonly
accessed
jump
per-array
per-dimension
dimensions
bytes
skiena
steven
manual
2nd
springer
isbn
predecessor
spend
searching
gerald
kruse
lecture
trade-offs
juniata
college
spring
day
keynote
bjarne
stroustrup
style
goingnative
channel9.msdn.com
minute
foil
crunching
linked-list
kjellkod.wordpress.com
brodnik
andrej
carlsson
svante
sedgewick
robert
munro
demaine
resizable
cs-99-09
pdf
university
waterloo
ford
william
topp
stl
prentice-hall
0-13-085850-1
okasaki
chris
purely
random-access
architecture
press
retrieved
7,2015
juan
angel
ch20
id06
java
book
big
cays
horstmann
black
paul
2004-08-16
pieterse
vreda
eds
dictionary
national
standards
2004-12-14
antonakos
james
mansfield
kenneth
practical
0-13-280843-9
collins
collections
framework
york
mcgraw
0-07-282379-8
cormen
thomas
leiserson
charles
rivest
ronald
stein
clifford
introduction
213,501
0-262-03293-7
209.isbn
doi
184.doi
knuth
donald
2.2.3-2.2.5
fundamental
3rd
addison-wesley
0-201-89683-4
parlante
nick
basics
stanford
2009-09-21
addison
wesley
0-201-31452-5
shaffer
analysis
jersey
prentice
hall
0-13-660911-2
wilkes
maurice
vincent
experiment
self-compiling
compiler
annual
automatic
pergamon
90013-8
proceeds
philadelphia
shanmugasundaram
kulesh
2005-04-04
linux
kernel
explained
wikimedia
commons
media
description
library
open
chapter
patent
idea
simultaneously
widely
decades
granted
collection
container
double-ended
priority
map
multimap
multiset
disjoint
stack
buffer
hashed
sparse
association
xor
b-tree
self-balancing
splay
binomial
fibonacci
r-tree
hilbert
trie
graphs
decision
directed
acyclic
graph
authority
gnd
4783888-7
categories
