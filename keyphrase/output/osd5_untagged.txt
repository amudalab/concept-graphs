an operating system  os  is an intermediary between users and computer hardware it provides users an environment in which a user can execute programs conveniently and efficiently in technical terms  it is a software which manages hardware an operating system controls the allocation of resources and services such as memory  processors  devices and information definition an operating system is a program that acts as an interface between the user and the computer hardware and controls the execution of all kinds of programs conceptual view of an operating system following are some of important functions of an operating system memory management processor management device management file management security control over system performance job accounting error detecting aids coordination between other software and users types of operating system operating systems are there from the very first computer generation operating systems keep evolving over the period of time following are few of the important types of operating system which are most commonly used batch operating system the users of batch operating system do not interact with the computer directly each user prepares his job on an off-line device like punch cards and submits it to the computer operator to speed up processing  jobs with similar needs are batched together and run as a group thus  the programmers left their programs with the operator the operator then sorts programs into batches with similar requirements the problems with batch systems are following lack of interaction between the user and job cpu is often idle  because the speeds of the mechanical i/o devices is slower than cpu difficult to provide the desired priority time-sharing operating systems time sharing is a technique which enables many people  located at various terminals  to use a particular computer system at the same time time-sharing or multitasking is a logical extension of multiprogramming processor 's time which is shared among multiple users simultaneously is termed as time-sharing the main difference between multiprogrammed batch systems and time-sharing systems is that in case of multiprogrammed batch systems  objective is to maximize processor use  whereas in time-sharing systems objective is to minimize response time multiple jobs are executed by the cpu by switching between them  but the switches occur so frequently thus  the user can receives an immediate response for example  in a transaction processing  processor execute each user program in a short burst or quantum of computation that is if n users are present  each user can get time quantum when the user submits the command  the response time is in few seconds at most distributed operating system distributed systems use multiple central processors to serve multiple real time application and multiple users data processing jobs are distributed among the processors accordingly to which one can perform each job most efficiently the processors communicate with one another through various communication lines  such as high-speed buses or telephone lines   these are referred as loosely coupled systems or distributed systems processors in a distributed system may vary in size and function these processors are referred as sites  nodes  computers and so on network operating system network operating system runs on a server and and provides server the capability to manage data  users  groups  security  applications  and other networking functions the primary purpose of the network operating system is to allow shared file and printer access among multiple computers in a network  typically a local area network  lan   a private network or to other networks examples of network operating systems are microsoft windows server 2003  microsoft windows server 2008  unix  linux  mac os x  novell netware  and bsd real time operating system real time system is defines as a data processing system in which the time interval required to process and respond to inputs is so small that it controls the environment real time processing is always on line whereas on line system need not be real time the time taken by the system to respond to an input and display of required updated information is termed as response time so in this method response time is very less as compared to the online processing real-time systems are used when there are rigid time requirements on the operation of a processor or the flow of data and real-time systems can be used as a control device in a dedicated application real-time operating system has well-defined  fixed time constraints otherwise system will fail.for example scientific experiments  medical imaging systems  industrial control systems  weapon systems  robots  and home-applicance controllers  air traffic control system etc operating system  services an operating system provides services to both the users and to the programs it provides programs  an environment to execute it provides users  services to execute the programs in a convenient manner following are few common services provided by operating systems program execution i/o operations file system manipulation communication error detection resource allocation protection operating system  properties following are few of very important tasks that operating system handles batch processing batch processing is a technique in which operating system collects one programs and data together in a batch before processing starts operating system does the following activities related to batch processing os defines a job which has predefined sequence of commands  programs and data as a single unit os keeps a number a jobs in memory and executes them without any manual information jobs are processed in the order of submission i.e first come first served fashion when job completes its execution  its memory is released and the output for the job gets copied into an output spool for later printing or processing batch processing multitasking multitasking refers to term where multiple jobs are executed by the cpu simultaneously by switching between them.switches occur so frequently that the users may interact with each program while it is running multitasking multiprogramming when two or more programs are residing in memory at the same time  then sharing the processor is referred to the multiprogramming multiprogramming assumes a single shared processor multiprogramming increases cpu utilization by organizing jobs so that the cpu always has one to execute following figure shows the memory layout for a multiprogramming system memory layout interactivity interactivity refers that a user is capable to interact with computer system operating system does the following activities related to interactivity os provides user an interface to interact with system os managers input devices to take inputs from the user for example  keyboard os manages output devices to show outputs to the user for example  monitor os response time needs to be short since the user submits and waits for the result real time system real time systems represents are usually dedicated  embedded systems operating system does the following activities related to real time system activity in such systems  operating systems typically read from and react to sensor data the operating system must guarantee response to events within fixed periods of time to ensure correct performance distributed environment distributed environment refers to multiple independent cpus or processors in a computer system operating system does the following activities related to distributed environment os distributes computation logics among several physical processors the processors do not share memory or a clock instead  each processor has its own local memory os manages the communications between the processors they communicate with each other through various communication lines spooling spooling is an acronym for simultaneous peripheral operations on line spooling refers to putting data of various i/o jobs in a buffer this buffer is a special area in memory or hard disk which is accessible to i/o devices operating system does the following activites related to distributed environment os handles i/o device data spooling as devices have different data access rates os maintains the spooling buffer which provides a waiting station where data can rest while the slower device catches up os maintains parallel computation because of spooling process as a computer can perform i/o in parallel fashin it becomes possible to have the computer read data from a tape  write data to disk and to write out to a tape printer while it is doing its computing task spooling operating system  processes process a process is a program in execution the execution of a process must progress in a sequential fashion definition of process is following a process is defined as an entity which represents the basic unit of work to be implemented in the system components of process are following s.n component & description 1 object program code to be executed 2 data data to be used for executing the program 3 resources while executing the program  it may require some resources 4 status verifies the status of the process execution.a process can run to completion only when all requested resources have been allocated to the process two or more processes could be executing the same program  each using their own data and resources program a program by itself is not a process it is a static entity made up of program statement while process is a dynamic entity program contains the instructions to be executed by processor a program takes a space at single place in main memory and continues to stay there a program does not perform any action by itself process states as a process executes  it changes state the state of a process is defined as the current activity of the process process can have one of the following five states at a time s.n state & description 1 new the process is being created 2 ready the process is waiting to be assigned to a processor ready processes are waiting to have the processor allocated to them by the operating system so that they can run 3 running process instructions are being executed  i.e the process that is currently being executed   4 waiting the process is waiting for some event to occur  such as the completion of an i/o operation   5 terminated the process has finished execution process states operating system  process scheduling definition the process scheduling is the activity of the process manager that handles the removal of the running process from the cpu and the selection of another process on the basis of a particular strategy process scheduling is an essential part of a multiprogramming operating system such operating systems allow more than one process to be loaded into the executable memory at a time and loaded process shares the cpu using time multiplexing scheduling queues scheduling queues refers to queues of processes or devices when the process enters into the system  then this process is put into a job queue this queue consists of all processes in the system the operating system also maintains other queues such as device queue device queue is a queue for which multiple processes are waiting for a particular i/o device each device has its own device queue this figure shows the queuing diagram of process scheduling queue is represented by rectangular box the circles represent the resources that serve the queues the arrows indicate the process flow in the system queuing diagram queues are of two types ready queue device queue a newly arrived process is put in the ready queue processes waits in ready queue for allocating the cpu once the cpu is assigned to a process  then that process will execute while executing the process  any one of the following events can occur the process could issue an i/o request and then it would be placed in an i/o queue the process could create new sub process and will wait for its termination the process could be removed forcibly from the cpu  as a result of interrupt and put back in the ready queue two state process model two state process model refers to running and non-running states which are described below s.n state & description 1 running when new process is created by operating system that process enters into the system as in the running state 2 not running processes that are not running are kept in queue  waiting for their turn to execute each entry in the queue is a pointer to a particular process queue is implemented by using linked list use of dispatcher is as follows when a process is interrupted  that process is transferred in the waiting queue if the process has completed or aborted  the process is discarded in either case  the dispatcher then selects a process from the queue to execute schedulers schedulers are special system softwares which handles process scheduling in various ways.their main task is to select the jobs to be submitted into the system and to decide which process to run schedulers are of three types long term scheduler short term scheduler medium term scheduler os  scheduling algorithms we 'll discuss four major scheduling algorithms here which are following first come first serve  fcfs  scheduling shortest-job-first  sjf  scheduling priority scheduling round robin  rr  scheduling multilevel queue scheduling operating system  multi-threading what is thread ? a thread is a flow of execution through the process code  with its own program counter  system registers and stack a thread is also called a light weight process threads provide a way to improve application performance through parallelism threads represent a software approach to improving performance of operating system by reducing the overhead thread is equivalent to a classical process each thread belongs to exactly one process and no thread can exist outside a process each thread represents a separate flow of control.threads have been successfully used in implementing network servers and web server they also provide a suitable foundation for parallel execution of applications on shared memory multiprocessors folowing figure shows the working of the single and multithreaded processes single vs multithreaded process difference between process and thread s.n process thread 1 process is heavy weight or resource intensive thread is light weight taking lesser resources than a process 1 process switching needs interaction with operating system thread switching does not need to interact with operating system 1 in multiple processing environments each process executes the same code but has its own memory and file resources all threads can share same set of open files  child processes 1 if one process is blocked then no other process can execute until the first process is unblocked while one thread is blocked and waiting  second thread in the same task can run 1 multiple processes without using threads use more resources multiple threaded processes use fewer resources 1 in multiple processes each process operates independently of the others one thread can read  write or change another thread 's data advantages of thread thread minimize context switching time use of threads provides concurrency within a process efficient communication economy it is more economical to create and context switch threads utilization of multiprocessor architectures to a greater scale and efficiency types of thread threads are implemented in following two ways user level threads  user managed threads kernel level threads  operating system managed threads acting on kernel  an operating system core os  memory management memory management is the functionality of an operating system which handles or manages primary memory memory management keeps track of each and every memory location either it is allocated to some process or it is free it checks how much memory is to be allocated to processes it decides which process will get memory at what time it tracks whenever some memory gets freed or unallocated and correspondingly it updates the status memory management provides protection by using two registers  a base register and a limit register the base register holds the smallest legal physical memory address and the limit register specifies the size of the range for example  if the base register holds 300000 and the limit register is 1209000  then the program can legally access all addresses from 300000 through 411999 memory management instructions and data to memory addresses can be done in following ways compile time  when it is known at compile time where the process will reside  compile time binding is used to generate the absolute code load time  when it is not known at compile time where the process will reside in memory  then the compiler generates re-locatable code execution time  if the process can be moved during its execution from one memory segment to another  then binding must be delayed to be done at run time dynamic loading in dynamic loading  a routine of a program is not loaded until it is called by the program all routines are kept on disk in a re-locatable load format the main program is loaded into memory and is executed other routines methods or modules are loaded on request dynamic loading makes better memory space utilization and unused routines are never loaded dynamic linking linking is the process of collecting and combining various modules of code and data into a executable file that can be loaded into memory and executed operating system can link system level libraries to a program when it combines the libraries at load time  the linking is called static linking and when this linking is done at the time of execution  it is called as dynamic linking in static linking  libraries linked at compile time  so program code size becomes bigger whereas in dynamic linking libraries linked at execution time so program code size remains smaller logical versus physical address space an address generated by the cpu is a logical address whereas address actually available on memory unit is a physical address logical address is also known a virtual address virtual and physical addresses are the same in compile-time and load-time address-binding schemes virtual and physical addresses differ in execution-time address-binding scheme the set of all logical addresses generated by a program is referred to as a logical address space the set of all physical addresses corresponding to these logical addresses is referred to as a physical address space the run-time mapping from virtual to physical address is done by the memory management unit  mmu  which is a hardware device mmu uses following mechanism to convert virtual address to physical address the value in the base register is added to every address generated by a user process which is treated as offset at the time it is sent to memory for example  if the base register value is 10000  then an attempt by the user to use address location 100 will be dynamically reallocated to location 10100 the user program deals with virtual addresses ; it never sees the real physical addresses swapping swapping is a mechanism in which a process can be swapped temporarily out of main memory to a backing store  and then brought back into memory for continued execution backing store is a usually a hard disk drive or any other secondary storage which fast in access and large enough to accommodate copies of all memory images for all users it must be capable of providing direct access to these memory images major time consuming part of swapping is transfer time total transfer time is directly proportional to the amount of memory swapped let us assume that the user process is of size 100kb and the backing store is a standard hard disk with transfer rate of 1 mb per second the actual transfer of the 100k process to or from memory will take 100kb / 1000kb per second = 1/10 second = 100 milliseconds process swapping memory allocation main memory usually has two partitions low memory  operating system resides in this memory high memory  user processes then held in high memory operating system uses the following memory allocation mechanism s.n memory allocation description 1 single-partition allocation in this type of allocation  relocation-register scheme is used to protect user processes from each other  and from changing operating-system code and data relocation register contains value of smallest physical address whereas limit register contains range of logical addresses each logical address must be less than the limit register 2 multiple-partition allocation in this type of allocation  main memory is divided into a number of fixed-sized partitions where each partition should contain only one process when a partition is free  a process is selected from the input queue and is loaded into the free partition when the process terminates  the partition becomes available for another process fragmentation as processes are loaded and removed from memory  the free memory space is broken into little pieces it happens after sometimes that processes can not be allocated to memory blocks considering their small size and memory blocks remains unused this problem is known as fragmentation fragmentation is of two types s.n fragmentation description 1 external fragmentation total memory space is enough to satisfy a request or to reside a process in it  but it is not contiguous so it can not be used 2 internal fragmentation memory block assigned to process is bigger some portion of memory is left unused as it can not be used by another process external fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block to make compaction feasible  relocation should be dynamic paging external fragmentation is avoided by using paging technique paging is a technique in which physical memory is broken into blocks of the same size called pages  size is power of 2  between 512 bytes and 8192 bytes   when a process is to be executed  it 's corresponding pages are loaded into any available memory frames logical address space of a process can be non-contiguous and a process is allocated physical memory whenever the free memory frame is available operating system keeps track of all free frames operating system needs n free frames to run a program of size n pages address generated by cpu is divided into page number  p   page number is used as an index into a page table which contains base address of each page in physical memory page offset  d   page offset is combined with base address to define the physical memory address paging following figure show the paging table architecture paging example segmentation segmentation is a technique to break memory into logical pieces where each piece represents a group of related information for example ,data segments or code segment for each process  data segment for operating system and so on segmentation can be implemented using or without using paging unlike paging  segment are having varying sizes and thus eliminates internal fragmentation external fragmentation still exists but to lesser extent logical address space address generated by cpu is divided into segment number  s   segment number is used as an index into a segment table which contains base address of each segment in physical memory and a limit of segment segment offset  o   segment offset is first checked against limit and then is combined with base address to define the physical memory address segmentation example operating system  virtual memory virtual memory is a technique that allows the execution of processes which are not completely available in memory the main visible advantage of this scheme is that programs can be larger than physical memory virtual memory is the separation of user logical memory from physical memory this separation allows an extremely large virtual memory to be provided for programmers when only a smaller physical memory is available following are the situations  when entire program is not required to be loaded fully in main memory user written error handling routines are used only when an error occured in the data or computation certain options and features of a program may be used rarely many tables are assigned a fixed amount of address space even though only a small amount of the table is actually used the ability to execute a program that is only partially in memory would counter many benefits less number of i/o would be needed to load or swap each user program into memory a program would no longer be constrained by the amount of physical memory that is available each user program could take less physical memory  more programs could be run the same time  with a corresponding increase in cpu utilization and throughput virtual memory virtual memory is commonly implemented by demand paging it can also be implemented in a segmentation system demand segmentation can also be used to provide virtual memory operating system  i/o hardware overview computers operate on many kinds of devices general types include storage devices  disks  tapes   transmission devices  network cards  modems   and human-interface devices  screen  keyboard  mouse   other devices are more specialized a device communicates with a computer system by sending signals over a cable or even through the air the device communicates with the machine via a connection point termed a port  for example  a serial port   if one or more devices use a common set of wires  the connection is called a bus.in other terms  a bus is a set of wires and a rigidly defined protocol that specifies a set of messages that can be sent on the wires daisy chain when device a has a cable that plugs into device b  and device b has a cable that plugs into device c  and device c plugs into a port on the computer  this arrangement is called a daisy chain it usually operates as a bus controller a controller is a collection of electronics that can operate a port  a bus  or a device a serial-port controller is an example of a simple device controller this is a single chip in the computer that controls the signals on the wires of a serial port the scsi bus controller is often implemented as a separate circuit board  a host adapter  that plugs into the computer it contains a processor  microcode  and some private memory to enable it to process the scsi protocol messages some devices have their own built-in controllers i/o port an i/o port typically consists of four registers  called the status  control  data-in  and data-out registers s.n register & description 1 status register the status register contains bits that can be read by the host these bits indicate states such as whether the current command has completed  whether a byte is available to be read from the data-in register  and whether there has been a device error 2 control register the control register can be written by the host to start a command or to change the mode of a device for instance  a certain bit in the control register of a serial port chooses between full-duplex and half-duplex communication  another enables parity checking  a third bit sets the word length to 7 or 8 bits  and other bits select one of the speeds supported by the serial port 3 data-in register the data-in register is read by the host to get input 4 data-out register the data out register is written by the host to send output polling polling is a process by which a host waits for controller response.it is a looping process  reading the status register over and over until the busy bit of status register becomes clear the controller uses/sets the busy bit when it is busy working on a command  and clears the busy bit when it is ready to accept the next command the host signals its wish via the command-ready bit in the command register the host sets the command-ready bit when a command is available for the controller to execute in the following example  the host writes output through a port  coordinating with the controller by handshaking the host repeatedly reads the busy bit until that bit becomes clear the host sets the write bit in the command register and writes a byte into the data-out register the host sets the command-ready bit when the controller notices that the command-ready bit is set  it sets the busy bit the controller reads the command register and sees the write command it reads the data-out register to get the byte  and does the i/o to the device the controller clears the command-ready bit  clears the error bit in the status register to indicate that the device i/o succeeded  and clears the busy bit to indicate that it is finished i/o devices i/o devices can be categorized into following category s.n category & description 1 human readable human readable devices are suitable for communicating with the computer user examples are printers  video display terminals  keyboard etc 2 machine readable machine readable devices are suitable for communicating with electronic equipment examples are disk and tape drives  sensors  controllers and actuators 2 communication communication devices are suitable for communicating with remote devices examples are digital line drivers and modems following are the differences between i/o devices s.n criteria & description 1 data rate there may be differences of several orders of magnitude between the data transfer rates 2 application different devices have different use in the system 3 complexity of control a disk is much more complex whereas printer requires simple control interface 4 unit of transfer data may be transferred as a stream of bytes or characters or in larger blocks 5 data representation different data encoding schemes are used for different devices 6 error conditions the nature of errors differs widely from one device to another direct memory access  dma  many computers avoid burdening the main cpu with programmed i/o by offloading some of this work to a special purpose processor this type of processor is called  a direct memory access  dma  controller a special control unit is used to transfer block of data directly between an external device and the main memory  without intervention by the processor this approach is called direct memory access  dma   dma can be used with either polling or interrupt software dma is particularly useful on devices like disks  where many bytes of information can be transferred in single i/o operations when used with an interrupt  the cpu is notified only after the entire block of data has been transferred for each byte or word transferred  it must provide the memory address and all the bus signals controlling the data transfer interaction with a device controller is managed through a device driver handshaking is a process between the dma controller and the device controller it is performed via wires using terms dma request and dma acknowledge dma step description 1 device driver is instructed to transfer disk data to a buffer address x 2 device driver then instruct disk controller to transfer data to buffer 3 disk controller starts dma transfer 4 disk controller sends each byte to dma controller 5 dma controller transfers bytes to buffer  increases the memory address  decreases the counter c until c becomes zero 6 when c becomes zero  dma interrupts cpu to signal transfer completion device controllers a computer system contains a many types of i/o devices and their respective controllers network card graphics adapter disk controller dvd-rom controller serial port usb sound card operating system  i/o softwares interrupts the cpu hardware uses an interrupt request line wire which helps cpu to sense after executing every instruction when the cpu checks that a controller has put a signal on the interrupt request line  the cpu saves a state  such as the current value of the instruction pointer  and jumps to the interrupt handler routine at a fixed address the interrupt handler part determines the cause of the interrupt  performs the necessary processing and executes a interrupt instruction to return the cpu to its execution state the basic mechanism of interrurpt enables the cpu to respond to an asynchronous event  such as when a device controller become ready for service most cpus have two interrupt request lines non-maskable interrupt  such kind of interrupts are reserved for events like unrecoverable memory errors maskable interrupt  such interrupts can be switched off by the cpu before the execution of critical instructions that must not be interrupted the interrupt mechanism accepts an address  a number that selects a specific interrupt handling routine/function from a small set.in most architectures  this address is an offset stored in a table called the interrupt vector table this vector contains the memory addresses of specialized interrupt handlers application i/o interface application i/o interface represents the structuring techniques and interfaces for the operating system to enable i/o devices to be treated in a standard  uniform way the actual differences lies kernel level modules called device drivers which are custom tailored to corresponding devices but show one of the standard interfaces to applications the purpose of the device-driver layer is to hide the differences among device controllers from the i/o subsystem of the kernel  such as the i/o system calls following are the characteristics of i/o interfaces with respected to devices character-stream / block  a character-stream device transfers bytes in one by one fashion  whereas a block device transfers a complete unit of bytes sequential / random-access  a sequential device transfers data in a fixed order determined by the device  random-access device can be instructed to seek position to any of the available data storage locations synchronous / asynchronous  a synchronous device performs data transfers with known response time where as an asynchronous device shows irregular or unpredictable response time sharable / dedicated  a sharable device can be used concurrently by several processes or threads but a dedicated device can not be used speed of operation  device speeds may range from a few bytes per second to a few gigabytes per second read-write  read only  or write only  some devices perform both input and output  but others support only one data direction that is read only clocks clocks are also called timers the clock software takes the form of a device driver though a clock is neither a blocking device nor a character based device the clock software is the clock driver the exact function of the clock driver may vary depending on operating system generally  the functions of the clock driver include the following s.n task description 1 maintaining the time of the day the clock driver implements the time of day or the real time clock function.it requires incrementing a counter at each clock tick 2 preventing processes from running too long as a process is started  the scheduler initializes the quantum counter in clock ticks for the process the clock driver decrements the quantum counter by 1  at every clock interrupt when the counter gets to zero  clock driver calls the scheduler to set up another process thus clock driver helps in preventing processes from running longer than time slice allowed 3 accounting for cpu usage another function performed by clock driver is doing cpu accounting cpu accounting implies telling how long the process has run 4 providing watchdog timers for parts of the system itself watchdog timers are the timers set by certain parts of the system for example  to use a floppy disk  the system must turn on the motor and then wait about 500msec for it to comes up to speed kernel i/o subsystem kernel i/o subsystem is responsible to provide many services related to i/o following are some of the services provided scheduling  kernel schedules a set of i/o requests to determine a good order in which to execute them when an application issues a blocking i/o system call  the request is placed on the queue for that device the kernel i/o scheduler rearranges the order of the queue to improve the overall system efficiency and the average response time experienced by the applications buffering  kernel i/o subsystem maintains a memory area known as buffer that stores data while they are transferred between two devices or between a device with an application operation buffering is done to cope with a speed mismatch between the producer and consumer of a data stream or to adapt between devices that have different data transfer sizes caching  kernel maintains cache memory which is region of fast memory that holds copies of data access to the cached copy is more efficient than access to the original spooling and device reservation a spool is a buffer that holds output for a device  such as a printer  that can not accept interleaved data streams the spooling system copies the queued spool files to the printer one at a time in some operating systems  spooling is managed by a system daemon process in other operating systems  it is handled by an in kernel thread error handling an operating system that uses protected memory can guard against many kinds of hardware and application errors device driver device driver is a program or routine developed for an i/o device a device driver implements i/o operations or behaviours on a specific class of devices for example a system supports one or a number of multiple brands of terminals  all slightly different terminals may have a single terminal driver in the layered structure of i/o system  device driver lies between interrupt handler and device independent i/o software the job of a device driver are following to accept request from the device independent software above it to see to it that the request is executed  