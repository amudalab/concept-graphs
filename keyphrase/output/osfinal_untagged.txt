operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/1 module 19  system administration in unix in the context of the os service provisioning  system administration plays a pivotal role this is particularly the case when a system is accessed by multiple users the primary task of a system administrator is to ensure that the following happens  a the top management is assured of efficiency in utilization of the system 's resources b the general user community gets the services which they are seeking in other words  system administrators ensure that there is very little to complain about the system 's performance or service availability in linux environment with single user pc usage  the user also doubles up as a system administrator much of what we discuss in unix context applies to linux as well in all unix flavours there is a notion of a superuser privilege most major administrative tasks require that the system administrator operates in the superuser mode with root privileges these tasks include starting up and shutting down a system  opening an account for a new user and giving him a proper working set-up administration tasks also involve installation of new software  distributing user disk space  taking regular back-ups  keeping system logs  ensuring secure operations and providing network services and web access we shall begin this module by enlisting the tasks in system administration and offering exposition on most of these tasks as the chapter develops 19.1 unix administration tasks most users are primarily interested in just running a set of basic applications for their professional needs often they can not afford to keep track of new software releases and patches that get announced also  rarely they can install these themselves in addition  these are non-trivial tasks and can only be done with superuser privileges users share resources like disk space  etc so there has to be some allocation policy of the disk space a system administrator needs to implement such a policy system administration also helps in setting up user 's working environments on the other hand  the management is usually keen to ensure that the resources are used properly and efficiently they seek to monitor the usage and keep an account of system usage in fact  the system usage pattern is often analysed to help determine the efficacy of operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/2 usage clearly  managements ' main concerns include performance and utilisation of resources to ensure that operations of the organisation do not suffer at this juncture it may be worth our while to list major tasks which are performed by system administrators we should note that most of the tasks require that the system administrator operates in superuser mode with root privileges 19.1.1 administration tasks list this is not an exhaustive list  yet it represents most of the tasks which system administrators perform  1 system startup and shutdown  in the section 19.2  we shall see the basic steps required to start and to stop operations in a unix operational environment 2 opening and closing user accounts  in unix an administrator is both a user and a super-user usually  an administrator has to switch to the super-user mode with root privileges to open or close user accounts in section 19.3  we shall discuss some of the nuances involved in this activity 3 helping users to set up their working environment  unix allows any user to customize his working environment this is usually achieved by using .rc files many users need help with an initial set-up of their .rc files later  a user may modify his .rc files to suit his requirements in section 19.4  we shall see most of the useful .rc files and the interpretations for various settings in these files 4 maintaining user services  users require services for printing  mail web access and chat we shall deal with mail and chat in section 19.4 where we discuss .rc files and with print services in section 19.5 where we discuss device management and services these services include spooling of print jobs  provisioning of print quota  etc 5 allocating disk space and re-allocating quotas when the needs grow  usually there would be a default allocation however  in some cases it may be imperative to enhance the allocation we shall deal with the device oriented services and management issues in section 19.5 6 installing and maintaining software  this may require installing software patches from time to time most oss are released with some bugs still present often with usage these bugs are identified and patches released also  one may have some software installed which satisfies a few of the specialized needs of the user operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/3 community as a convention this is installed in the directory /usr/local/bin the local is an indicator of the local  and therefore a non-standard  nature of software we shall not discuss the software installation as much of it is learned from experienced system administrators by assisting them in the task 7 installing new devices and upgrading the configuration  as a demand on a system grows  additional devices may need to be installed the system administrator will have to edit configuration files to identify these devices some related issues shall be covered in section 19.5 later in this chapter 8 provisioning the mail and internet services  users connected to any host shall seek mail and internet web access in addition  almost every machine shall be a resource within a local area network so for resource too the machine shall have an ip address in most cases it would be accessible from other machine as well we shall show the use .mailrc files in this context later in section 19.4 9 ensuring security of the system  the internet makes the task of system administration both interesting and challenging the administrators need to keep a check on spoofing and misuse we have discussed security in some detail in the module on os and security 10 maintaining system logs and profiling the users  a system administrator is required to often determine the usage of resources this is achieved by analysing system logs the system logs also help to profile the users in fact  user profiling helps in identifying security breaches as was explained in the module entitled os and security 11 system accounting  this is usually of interest to the management also  it helps system administrators to tune up an operating system to meet the user requirements this also involves maintaining and analysing logs of the system operation 12 reconfiguring the kernel whenever required  sometimes when new patches are installed or a new release of the os is received  then it is imperative to compile the kernel linux users often need to do this as new releases and extensions become available let us begin our discussions with the initiation of the operations and shutdown procedures operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/4 19.2 starting and shutting down first we shall examine what exactly happens when the system is powered on later  we shall examine the shutdown procedure for unix systems unix systems  on being powered on  usually require that a choice be made to operate either in single or in multiple-user mode most systems operate in multi-user mode however  system administrators use single-user mode when they have some serious reconfiguration or installation task to perform family of unix systems emanating from system v usually operate with a run level the single-user mode is identified with run level s  otherwise there are levels from 0 to 6 the run level 3 is the most common for multi-user mode of operation on being powered on  unix usually initiates the following sequence of tasks  1 the unix performs a sequence of self-tests to determine if there are any hardware problems 2 the unix kernel gets loaded from a root device 3 the kernel runs and initializes itself 4 the kernel starts the init process all subsequent processes are spawned from init process 5 the init checks out the file system using fsck 6 the init process executes a system boot script 7 the init process spawns a process to check all the terminals from which the system may be accessed this is done by checking the terminals defined under /etc/ttytab or a corresponding file for each terminal a getty process is launched this reconciles communication characteristics like baud rate and type for each terminal 8 the getty process initiates a login process to enable a prospective login from a terminal during the startup we notice that fsck checks out the integrity of the file system in case the fsck throws up messages of some problems  the system administrator has to work around to ensure that there is a working configuration made available to the users it will suffice here to mention that one may monitor disk usage and reconcile the disk integrity the starting up of systems is a routine activity the most important thing to note is that on booting  or following a startup  all the temporary files under tmp directory are cleaned operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/5 up also  zombies are cleaned up system administrators resort to booting when there are a number of zombies and often a considerable disk space is blocked in the tmp directory we next examine the shutdown most unix systems require invoking the shutdown utility the shutdown utility offers options to either halt immediately  or shutdown after a pre-assigned period usually system administrators choose to shutdown with a preassigned period such a shutdown results in sending a message to all the terminals that the system shall be going down after a certain interval of time  say 5 minutes this cautions all the users and gives them enough time to close their files and terminate their active processes yet another shutdown option is to reboot with obvious implications the most commonly used shutdown command is as follows  shutdown -h time  message  here the time is the period and message is optional  but often it is intended to advise users to take precautions to terminate their activity gracefully this mode also prepares to turn power off after a proper shutdown there are other options like k  r  n etc the readers are encouraged to find details about these in unix man pages for now  we shall move on to discuss the user accounts management and run command files 19.3 managing user accounts when a new person joins an organisation he is usually given an account by the system administrator this is the login account of the user now a days almost all unix systems support an admin tool which seeks the following information from the system administrator to open a new account  1 username  this serves as the login name for the user 2 password  usually a system administrator gives a simple password the users are advised to later select a password which they feel comfortable using user 's password appears in the shadow files in encrypted forms usually  the /etc/passwd file contains the information required by the login program to authenticate the login name and to initiate appropriate shell as shown in the description below  bhatt  x  1007  1   /export/home/bhatt  /usr/local/bin/bash damu  x  1001  10   /export/home/damu  /usr/local/bin/bash each line above contains information about one user the first field is the name of the user ; the next a dummy indicator of password  which is in another file  a shadow file password programs use a trap-door algorithm for encryption operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/6 3 home directory  every new user has a home directory defined for him this is the default login directory usually it is defined in the run command files 4 working set-up  the system administrators prepare .login and .profile files to help users to obtain an initial set-up for login the administrator may prepare .cshrc  .xinitrc .mailrc .ircrc files in section 19.4 we shall later see how these files may be helpful in customizing a user 's working environment a natural point of curiosity would be  what happens when users log out ? unix systems receive signals when users log out recall  in section 19.2 we mentioned that a user logs in under a login process initiated by getty process process getty identifies the terminal being used so when a user logs out  the getty process which was running to communicate with that terminal is first killed a new getty process is now launched to enable yet another prospective login from that terminal the working set-up is completely determined by the startup files these are basically .rc  run command  files these files help to customize the user 's working environment for instance  a user 's .cshrc file shall have a path variable which defines the access to various unix built-in shell commands  utilities  libraries etc in fact  many other shell environmental variables like home  shell  mail  tz  the time zone  are set up automatically in addition  the .rc files define the access to network services or some need-based access to certain licensed software or databases as well to that extent the .rc files help to customize the user 's working environment we shall discuss the role of run command files later in section 19.4 5 group-id  the user login name is the user-id under unix the access privileges are determined by the group a user belongs to so a user is assigned a group-id it is possible to obtain the id information by using an id command as shown below   bhatt @ iiitbsun os  $ id uid = 1007  bhatt  gid = 1  other   bhatt @ iiitbsun os  $ 6 disc quota  usually a certain amount of disk space is allocated by default in cases where the situation so warrants  a user may seek additional disk space a user may interrogate the disk space available at any time by using the df command its usage is shown below  operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/7 df  options   name   to know the free disk space where name refers to a mounted file system  local or remote we may specify directory if we need to know the information about that directory the following options may help with additional information  -l  for local file system -t  reports total no of allocated blocks and i-nodes on the device the unix command du reports the number of disk blocks occupied by a file its usage is shown below  du  options   name   where name is a directory or a file above name by default refers to the current directory the following options may help with additional information  -a  produce output line for each file -s  report only the total usage for each name that is a directory i.e not individual files -r  produce messages for files that can not be read or opened 7 network services  usually a user shall get a mail account we will discuss the role of .mailrc file in this context in section 19.4 the user gets an access to web services too 8 default terminal settings  usually vt100 is the default terminal setting one can attempt alternate terminal settings using tset  stty  tput  tabs with the control sequences defined in terminfo termcap with details recorded in /etc/ttytype or /etc/tty files and in shell variable term many of these details are discussed in section 19.5.1 which specifically deals with terminal settings the reader is encouraged to look up that section for details once an account has been opened the user may do the following  1 change the pass-word for access to one of his liking 2 customize many of the run command files to suit his needs closing a user account  here again the password file plays a role recall in section 19.1 we saw that /etc/password file has all the information about the users ' home directory  password  shell  user and group-id  etc when a user 's account is to be deleted  all of this information needs to be erased system administrators login as root and delete the user entry from the password file to delete the account operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/8 19.4 the .rc files usually system administration offers a set of start-up run command files to a new user these are files that appear as .rc files these may be .profile  .login  .cshrc  .bashrc .xinitrc  .mailrc .ircrc  etc the choice depends upon the nature of the login shell typical allocations may be as follows  0 bourne or korn shell  .profile 1 c-shell  .login  .cshrc 2 bash  .bashrci 3 tcsh  .tcshrc bash is referred as bourne-again shell tcsh is an advanced c-shell with many shortcuts like pressing a tab may complete a partial string to the extent it can be covered unambiguously for us it is important to understand what is it that these files facilitate role of .login and .profile files  the basic role of these files is to set up the environment for a user these may include the following set-ups ? set up the terminal characteristics  usually  the set up may include terminal type  and character settings for the prompt  erase  etc ? set up editors  it may set up a default editor or some specific editor like emacs ? set up protection mode  this file may set up umask  which stands for the user mask umask determines access right to files ? set up environment variables  this file may set up the path variable the path variable defines the sequence in which directories are searched for locating the commands and utilities of the operating system ? set up some customization variables  usually  these help to limit things like selecting icons for mail or core dump size up to a maximum value it may be used for setting up the limit on the scope of the command history  or some other preferences a typical .login file may have the following entries  # a typical .login file umask 022 setenv path /usr/ucb  /usr/bin  /usr/sbin  /usr/local/bin setenv printer labprinter operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/9 setenv editor vi biff y set prompt = 'hostname ' = > the meanings of the lines above should be obvious from the explanation we advanced earlier next we describe .cshrc files and the readers should note the commonalities between these definitions of initialisation files the .cshrc file  the c-shell makes a few features available over the bourne shell for instance  it is common to define aliases in .cshrc files for very frequently used commands like gh for ghostview and c for clear below we give some typical entries for .cshrc file in addition to the many we saw in the .login file in this section  if  ! $ ? term  setenv term unknown if  " term " = = " unknown " | | " $ term " = = " network "  then echo -n 'term ?  vt100   ' ; set ttype =  $ <  if  ttype = = " "  set ttype = " vt100 " if  ttype = = " pc "  then set ttype = " vt100 " endif setenv term $ ttype endif alias cl clear alias gh ghostview set history = 50 set nobeep note that the above  in the first few lines in the script  system identifies the nature of terminal and sets it to operate as vt100 it is highly recommended that the reader should examine and walk-through the initialization scripts which the system administration provides also  a customization of these files entails that as a user we must look up these files and modify them to suit our needs there are two more files of interest one corresponds to regulating the mail and the other which controls the screen display these are respectively initialized through .mailrc and .xinitrc we discussed the latter in the chapter on x windows we shall discuss the settings in .mailrc file in the context of the mail system operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/10 the mail system  .mailrc file  from the viewpoint of the user 's host machine  the mail program truly acts as the main anchor for our internet-based communication the unix sendmail program together with the uu class of programs form the very basis of the mail under unix essentially  the mail system has the following characteristics  1 the mail system is a store and forward system 2 mail is picked up from the mail server periodically the mail daemon  picks up the mail running as a background process 3 mail is sent by sendmail program under unix 4 the uu class of programs like uucp or unix-to-unix copy have provided the basis for developing the mail tools in fact  the file attachments facility is an example of it on a unix system it is possible to invoke the mail program from an auto-login or .cshrc program every unix user has a mailbox entry in the /usr/spool/mail directory each person 's mail box is named after his own username in table 19.1 we briefly review some very useful mail commands and the wild card used with these commands we next give some very useful commands which help users to manage their mails efficiently  table 19.1  various command options for mail d  r  delete all read messages d  usenet  delete all messages with usenet in body p  r  print all read messages p  bhatt  print all from user ` ` bhatt'' operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/11 during the time a user is composing a mail  the mail system tools usually offer facility to escape to a shell this can be very useful when large files need to be edited along side the mail being sent these use ~ commands with the interpretations shown below  ~ ! escape to shell  ~ d include dead.letter ~ h edit header field the mail system provides for command line interface to facilitate mail operations using some of the following commands for instance  every user has a default mail box called mbox if one wishes to give a different name to the mailbox  he may choose a new name for it other facilities allow a mail to be composed with  or without  a subject or to see the progress of the mail as it gets processed we show some of these options and their usage with mail command below mail -s greetings user @ machine.domain -s  option is used to send a mail with subject -v  option is for the verbose option  it shows mails ' progress -f mailbox  option allows user to name a new mail box mail -f newm  where newm may be the new mail box option which a user may opt for in place of mbox  default option   next we describe some of the options that often appear inside .mailrc user files generally  with these options we may have aliases  nick-names  in place of the full mail address one may also set or unset some flags as shown in the example below  unset askcc set verbose set append operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/12 table 19.2  various options for .mailrc file in table 19.2  we offer a brief explanation of the options which may be set initially in .mailrc files in addition  in using the mail system the following may be the additional facilities which could be utilized  1 to subscribe to listserv @ machine.domain  the body of the message should contain ? subscribe "  the group to subscribe to and the subscribers ' e-mail address as shown in the following example subscribe allmusic me @ mymachine.mydomain 2 to unsubscribe use logout allmusic in addition to the above there are vacation programs which send mails automatically when the receiver is on vacation mails may also be encrypted for instance  one may use a pretty good privacy  pgp  for encrypting mails facilitating chat with .ircrc file  system administrators may prepare terminals and offer inter relay chat or irc facility as well irc enables real-time conversation with one or more persons who may be scattered anywhere globally irc is a multi-user system to use irc 's  unix-based irc versions  one may have to set the terminal emulation to vt100 either from the keyboard or from an auto-login file such as .login in bin/sh or .cshrc in /bin/csh $ set term = vt100 $ stty erase " ^ h " operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/13 the most common way to use the irc system is to make a telnet call to the irc server there are many irc servers some servers require specification of a port number as in irc.ibmpcug.co.uk9999 when one first accesses the irc server  many channels are presented a channel may be taken as a discussion area and one may choose a channel for an online chat  like switch a channel on tv   ircs require setting up an .ircrc file below we give some sample entries for a .ircrc file the .ircrc files may also set internal variables /comment  /nick < nn > /join < ch > irc commands begin with a \ / " character in table 19.3  we give a few of the commands for irc with their interpretations table 19.3  various commands with interpretation ircs usually support a range of channels listed below are a few of the channel types  limbo or null public private secret moderated operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/14 limited topic limited invite only message disabled the above channel types are realized by using a mode command the modes are set or unset as follows the options have the interpretations shown in table 19.4 /mode sets  with +  and unsets  with   the mode of channel with the following options /mode < channel > + < channel options > < parameters > /mode < channel >  < channel options > < parameters > table 19.4  various options for channels 19.4.1 sourcing files as we have described above  the .rc files help to provide adequate support for a variety of services suppose we are logged to a system and seek a service that requires a change in one of the .rc files we may edit the corresponding file however  to affect the changed behavior we must source the file basically  we need to execute the source command with the file name as argument as shown below where we source the .cshrc file  source .cshrc 19.5 device management and services technically the system administrator is responsible for every device  for all of its usage and operation in particular  the administrator looks after its installation  upgrade  configuration  scheduling  and allocating quotas to service the user community we shall  however  restrict ourselves to the following three services  1 terminal-based services  discussed in section 19.5.1 2 printer services  discussed in section 19.5.2 3 disc space and file services  discussed in section 19.5.3 we shall begin with the terminal settings and related issues 19.5.1 the terminal settings operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/15 in the context of terminal settings the following three things are important  1 unix recognizes terminals as special files 2 terminals operate on serial lines unix has a way to deal with files that are essentially using serial communication lines 3 the terminals have a variety of settings available this is so even while the protocols of communication for all of them are similar from the point of terminal services provisioning and system configuration  system administration must bear the above three factors in mind unix maintains all terminal related information in tty files in /etc/dev directory these files are special files which adhere to the protocols of communication with serial lines this includes those terminals that use modems for communication some systems may have a special file for console like /etc/dev/console which can be monitored for messages as explained in the chapter on x-windows depending upon the terminal type a serial line control protocol is used which can interrogate or activate appropriate pins on the hardware interface plug the following brief session shows how a terminal may be identified on a host  login  bhatt password  last login  tue nov 5 00  25  21 from 203.197.175.174  bhatt @ iiitbsun bhatt  $ hostname iiitbsun  bhatt @ iiitbsun bhatt  $ tty /dev/pts/1  bhatt @ iiitbsun bhatt  $ termcap and terminfo files  the termcap and terminfo files in the directory /etc or in /usr/share/lib/terminfo provide the terminal database  information and programs for use in the unix environment the database includes programs that may have been compiled to elicit services from a specific terminal which may be installed the programs that control the usage of a specific terminal are identified in the environment variable term as shown in the example below   bhatt @ localhost dft02  $ echo $ term xterm  bhatt @ localhost dft02  $ operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/16 table 19.5  options under stty there are specific commands like tic  short for terminal information compilation also  there are programs that convert termcap to terminfo whenever required for detailed discussions on terminal characteristics and how to exploit various features the reader may refer to  2   we shall  however  elaborate on two specific commands here these are the tset and stty commands 1 tset command  the tset command is used to initialize a terminal usually  the command sets up initial settings for characters like erase  kill  etc below we show how under c-shell one may use the tset command  $ setenv term ` tset  q -m "  ? vt100 " sometimes one may prepare a temporary file and source it 2 stty command  we briefly encountered the stty command in section 19.2 here we shall elaborate on stty command in the context of options and the values which may be availed by using the stty command in table 19.5 we list a few of the options with their corresponding values there are many other options in table 19.5 we have a sample of those that are available try the command stty -a to see the options for your terminal below is shown the setting on my terminal   bhatt @ localhost dft02  $ stty -a speed 38400 baud ; rows 24 ; columns 80 ; line = 0 ; intr = ^ c ; quit = ^ \ ; erase = ^ ? ; kill = ^ u ; eof = ^ d ; eol = m ^ ? ; eol2 = m ^ ? ; start = ^ q ; stop = ^ s ; susp = ^ z ; rprnt = ^ r ; werase = ^ w ; lnext = ^ v ; flush = ^ o ; min = 1 ; time = 0 ; -parenb -parodd cs8 hupcl -cstopb cread -clocal -crtscts -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc ixany imaxbel operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/17 opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke  bhatt @ localhost dft02  $ lastly  we discuss how to attach a new terminal basically we need to connect a terminal and then we set-up the entries in termcap and/or in terminfo and configuration files sometimes one may have to look at the /etc/inittab or /etc/ttydefs as well it helps to reboot the system on some occasions to ensure proper initialization following a set-up attempt 19.5.2 printer services users obtain print services through a printer daemon the system arranges to offer print services by spooling print jobs in a spooling directory it also has a mechanism to service the print requests from the spooling directory in addition  system administrators need to be familiar with commands which help in monitoring the printer usage we shall begin with a description of the printcap file the printcap file  unix systems have their print services offered using a spooling system the spooling system recognizes print devices that are identified in /etc/printcap file the printcap file serves not only as a database  but also as a configuration file below we see the printcap file on my machine  # /etc/printcap # # do not edit ! manual changes will be lost ! # this file is autogenerated by printconf-backend during lpd init # # hand edited changes can be put in /etc/printcap.local  and will be included iiitb  \  sh  \  ml = 0  \  mx = 0  \  sd = /var/spool/lpd/iiitb  \  lp = | /usr/share/printconf/jetdirectprint  \  lpd_bounce = true  \ operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/18  if = /usr/share/ printconf/mf_wrap per  the printcap file is a read-only file except that it can be edited by superuser root the entries in printcap files can be explained using table 19.6 with the file description and the table we can see that the spooling directory for our printer  with printer name iiitb is at /var/spool also note we have no limit on file size which can be printed table 19.6  the printcap file  printer characteristics printer spooling directory  as we explained earlier  print requests get spooled first subsequently  the printer daemon lpd honours the print request to print to achieve this  one may employ a two layered design viewing it bottom up  at the bottom layer maintain a separate spooling directory for each of the printers so  when we attach a new printer  we must create a new spooling directory for it at the top level  we have a spooling process which receives each print request and finally spools it for printer  s   note that the owner of the spool process is a group daemon printer monitoring commands  the printer commands help to monitor both the health of the services as also the work in progress in table 19.7 we elaborate on the commands and their interpretations table 19.7  the printer commands to add a printer one may use a lpadmin tool some of the system administration practices are best learned by assisting experienced system administrators rarely can be taught through a textbook operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/19 19.5.3 disk space allocation and management in this section we shall discuss how does a system administrator manage the disk space we will also like the reader to refer to section 2.7.1 where we stated that at the time of formatting  partitions of the disk get defined the partitions may be physical or logical in case of a physical partition we have the file system resident within one disk drive in case of logical partition  the file system may extend over several drives in either of these cases the following issues are at stake  1 disk file system  in chapter 2 we indicated that system files are resident in the root file system similarly  the user information is maintained in home file system created by the administrator usually  a physical disk drive may have one or more file systems resident on it as an example  consider the mapping shown in figure 19.1 we notice that there are three physical drives with mapping or root and the names of file systems are shown in bold letters figure 19.1  mapping file systems on physical drives other file systems note that the disk drive with the root file system co-locates the var file system on the same drive also  the file system home extends over two drives this is possible by appropriate assignment of the disk partitions to various file systems of course  system programmers follow some method in both partitioning and allocating the partitions recall that each file system maintains some data about each of the files within it system administrators have to reallocate the file systems when new disks become available  or when some disk suffers damage to sectors or tracks which may no longer be available operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/20 2 mounting and unmounting  the file systems keep the files in a directory structure which is essentially a tree so a new file system can be created by specifying the point of mount in the directory tree a typical mount instruction has the following format mount a-block-special-file point-of-mount corresponding to a mount instruction  there is also an instruction to unmount in unix it is umount with the same format as mount in unix every time we have a new disk added  it is mounted at a suitable point of mount in the directory tree in that case the mount instruction is used exactly as explained of course  a disk is assumed to be formatted 3 disk quota  disk quota can be allocated by reconfiguring the file system usually located at /etc/fstab to extend the allocation quota in a file system we first have to modify the corresponding entry in the /etc/fstab file the system administration can set hard or soft limits of user quota if a hard limit has been set  then the user simply can not exceed the allocated space however  if a soft limit is set  then the user is cautioned when he approaches the soft limit usually  it is expected that the user will resort to purging files no longer in use else he may seek additional disk space some systems have quota set at the group level it may also be possible to set quota for individual users both these situations require executing an edit quota instruction with user name or group name as the argument the format of edquota instruction is shown below edquota user-name 4 integrity of file systems  due to the dynamics of temporary allocations and moving files around  the integrity of a file system may get compromised the following are some of the ways the integrity is lost  ? lost files this may happen because a user ahs opened the same file from multiple windows and edited them ? a block may be marked free but may be in use ? a block may be marked in use but may be free ? the link counts may not be correct ? the data in the file system table and actual files may be different operating systems/system administration in unix lecture notes pcp bhatt/iisc  bangalore m19/v1/june 04/21 the integrity of the file system is checked out by using a fsck instruction the argument to the command is the file system which we need to check as shown below fsck file-system-to-be-checked on rebooting the system these checks are mandatory and routinely performed consequently  the consistency of the file system is immediately restored on rebooting 5 access control  as explained earlier in this chapter  when an account is opened  a user is allocated a group the group determines the access it is also possible to offer an initial set-up that will allow access to special  licensed  software like matlab suite of software 6 periodic back-up  every good administrator follows a regular back-up procedure so that in case of a severe breakdown  at least a stable previous state can be achieved 19.6 after-word in this moduler we have listed many tasks which system administrators are required to perform however  as we remarked earlier  the best lessons in system administration are learned under the tutelage of a very experienced system administrator there is no substitute to the ? hands-on " learning operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/1 module 20  more on linux linux kernel architecture the big picture  it is a good idea to look at the linux kernel within the overall system ? s overall context applications and os services  these are the user application running on the linux system these applications are not fixed but typically include applications like email clients  text processors etc os services include utilities and services that are traditionally considered part of an os like the windowing system  shells  programming interface to the kernel  the libraries and compilers etc linux kernel  kernel abstracts the hardware to the upper layers the kernel presents the same view of the hardware even if the underlying hardware is ifferent it mediates and controls access to system resources hardware  this layer consists of the physical resources of the system that finally do the actual work this includes the cpu  the hard disk  the parallel port controllers  the system ram etc the linux kernel  after looking at the big picture we should zoom into the linux kernel to get a closer look purpose of the kernel  the linux kernel presents a virtual machine interface to user processes processes are written without needing any knowledge  most of the time  of the type of the physical hardware that constitutes the computer the linux kernel abstracts all hardware into a consistent interface operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/2 in addition  linux kernel supports multi-tasking in a manner that is transparent to user processes  each process can act as though it is the only process on the computer  with exclusive use of main memory and other hardware resources the kernel actually runs several processes concurrently  and mediates access to hardware resources so that each process has fair access while inter-process security is maintained the kernel code executes in privileged mode called kernel mode any code that does not need to run in privileged mode is put in the system library the interesting thing about linux kernel is that it has a modular architecture ? even with binary codes  linux kernel can load  and unload  modules dynamically  at run time  just as it can load or unload the system library modules here we shall explore the conceptual view of the kernel without really bothering about the implementation issues  which keep on constantly changing any way   kernel code provides for arbitrations and for protected access to hw resources kernel supports services for the applications through the system libraries system calls within applications  may be written in c  may also use system library for instance  the buffered file handling is operated and managed by linux kernel through system libraries programs like utilities that are needed to initialize the system and configure network devices are classed as user mode programs and do not run with kernel privileges  unlike in unix   programs like those that handle login requests are run as system utilities and also do not require kernel privileges  unlike in unix   the linux kernel structure overview  the ? loadable ? kernel modules execute in the privileged kernel mode ? and therefore have the capabilities to communicate with all of hw linux kernel source code is free people may develop their own kernel modules however  this requires recompiling  linking and loading such a code can be distributed under gpl more often the modality is  start with the standard minimal basic kernel module then enrich the environment by the addition of customized drivers this is the route presently most people in the embedded system area are adopting worldwide the commonly loaded linux system kernel can be thought of comprising of the following main components  operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/3 process management  user process as also the kernel processes seek the cpu and other services usually a fork system call results in creating a new process system call execve results in execution of a newly forked process processes  have an id  pid  and also have a user id  uid  like in unix linux additionally has a personality associated with a process personality of a process is used by emulation libraries to be able to cater to a range of implementations usually a forked process inherits parent ? s environment in linux two vectors define a process  these are argument vector and environment vector the environment vector essentially has a  name  value  value list wherein different environment variable values are specified the argument vector has the command line arguments used by the process usually the environment is inherited however  upon execution of execve the process body may be redefined with a new set of environment variables this helps in the customization of a process ? s operational environment usually a process also has some indication on its scheduling context typically a process context includes information on scheduling  accounting  file tables  capability on signal handling and virtual memory context in linux  internally  both processes and threads have the same kind of representation linux processes and threads are posix compliant and are supported by a threads library package which provides for two kinds of threads  user and kernel user-controlled scheduling can be used for user threads the kernel threads are scheduled by the kernel while in a single processor environment there can be only one kernel thread scheduled in a multiprocessor environment one can use the kernel supported library and clone system call to have multiple kernel threads created and scheduled scheduler  schedulers control the access to cpu by implementing some policy such that the cpu is shared in a way that is fair and also the system stability is maintained in linux scheduling is required for the user processes and the kernel tasks kernel tasks may be internal tasks on behalf of the drivers or initiated by user processes requiring specific os services examples are  a page fault  induced by a user process  or because some device driver raises an interrupt in linux  normally  the kernel mode of operation can not be pre-empted kernel code runs to completion  unless it results in a page fault  or an interrupt of some kind or kernel code it self calls the scheduler linux is a time sharing system so a timer interrupt happens and rescheduling may be initiated at that time linux operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/4 uses a credit based scheduling algorithm the process with the highest credits gets scheduled the credits are revised after every run if all run-able processes exhaust all the credits a priority based fresh credit allocation takes place the crediting system usually gives higher credits to interactive or io bound processes ? as these require immediate responses from a user linux also implements unix like nice process characterization the memory manager  memory manager manages the allocation and de-allocation of system memory amongst the processes that may be executing concurrently at any time on the system the memory manager ensures that these processes do not end up corrupting each other ? s memory area also  this module is responsible for implementing virtual memory and the paging mechanism within it the loadable kernel modules are managed in two stages  first the loader seeks memory allocation from the kernel next the kernel returns the address of the area for loading the new module ? the linking for symbols is handled by the compiler because whenever a new module is loaded recompilation is imperative the virtual file system  vfs   presents a consistent file system interface to the kernel this allows the kernel code to be independent of the various file systems that may be supported  details on virtual file system vfs follow under the files system   the network interface  provides kernel access to various network hardware and protocols operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/5 inter process communication  ipc   the ipc primitives for processes also reside on the same system with the explanation above we should think of the typical loadable kernel module in linux to have three main components  ? module management  ? driver registration and ? conflict resolution mechanism module management  for new modules this is done at two levels ? the management of kernel referenced symbols and the management of the code in kernel memory the linux kernel maintains a symbol table and symbols defined here can be exported  that is these definitions can be used elsewhere  explicitly the new module must seek these symbols in fact this is like having an external definition in c and then getting the definition at the kernel compile time the module management system also defines all the required communications interfaces for this newly inserted module with this done  processes can request the services  may be of a device driver  from this module driver registration  the kernel maintains a dynamic table which gets modified once a new module is added ? some times one may wish to delete also in writing these modules care is taken to ensure that initializations and cleaning up operations are defined for the driver a module may register one or more drivers of one or more types of drivers usually the registration of drivers is maintained in a registration table of the module the registration of drives entails the following  1 driver context identification  as a character or bulk device or a network driver 2 file system context  essentially the routines employed to store files in linux virtual file system or network file system like nfs 3 network protocols and packet filtering rules 4 file formats for executable and other files conflict resolution  the pc hardware configuration is supported by a large number of chip set configurations and with a large range of drivers for scsi devices  video display devices and adapters  network cards this results in the situation where we have operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/6 module device drivers which vary over a very wide range of capabilities and options this necessitates a conflict resolution mechanism to resolve accesses in a variety of conflicting concurrent accesses the conflict resolution mechanisms help in preventing modules from having an access conflict to the hw ? for example an access to a printer modules usually identify the hw resources it needs at the time of loading and the kernel makes these available by using a reservation table the kernel usually maintains information on the address to be used for accessing hw  be it dma channel or an interrupt line the drivers avail kernel services to access hw resources system calls  let us explore how system calls are handled a user space process enters the kernel from this point the mechanism is some what cpu architecture dependent most common examples of system calls are   open  close  read  write  exit  fork  exec  kill  socket calls etc the linux kernel 2.4 is non preemptable implying once a system call is executing it will run till it is finished or it relinquishes control of the cpu however  linux kernel 2.6 has been made partly preemptable this has improved the responsiveness considerably and the system behavior is less ? jerky ?  systems call interface in linux  system call is the interface with which a program in user space program accesses kernel functionality at a very high level it can be thought of as a user process calling a function in the linux kernel even though this would seem like a normal c function call  it is in fact handled differently the user process does not issue a system call directly  in stead  it is internally invoked by the c library linux has a fixed number of system calls that are reconciled at compile time a user process can access only these finite set of services via the system call interface each system call has a unique identifying number the exact mechanism of a system call implementation is platform dependent below we discuss how it is done in the x86 architecture to invoke a system call in x86 architecture  the following needs to be done first  a system call number is put into the eax hardware register arguments to the system call are put into other hardware registers then the int0x80 software interrupt is operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/7 issued which then invokes the kernel service adding one ? s own system call is a pretty straight forward  almost  in linux let us try to implement our own simple system call which we will call ? simple ? and whose source we will put in simple.c / * simple.c * / / * this code was never actually compiled and tested * / # include < linux/simple.h > asmlinkage int sys_simple  void   return 99 ;  as can be seen that this a very dumb system call that does nothing but return 99 but that is enough for our purpose of understanding the basics this file now has to be added to the linux source tree for compilation by executing  /usr/src/linux *  * /simple.c those who are not familiar with kernel programming might wonder what ? asmlinkage ? stands for in the system call ? c ? language does not allow access hardware directly so  some assembly code is required to access the eax register etc the asmlinkage macro does the dirty work fortunately the asmlinkage macro is defined in xxxx/linkage.h it initiates another macro_syscall in xxxxx/unistd.h the header file for a typical system call will contain the following operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/8 after defining the system call we need to assign a system call number this can be done by adding a line to the file unistd.h  unistd.h has a series of # defines of the form  # define _nr_sys_exit 1 now if the last system call number is 223 then we enter the following line at the bottom # define _nr_sys_simple 224 after assigning a number to the system call it is entered into system call table the system call number is the index into a table that contains a pointer to the actual routine this table is defined in the kernel file ? entry.s ? .we add the following line to the file  * this code was never actually compiled and tested * /.long sysmbol_name  sys_simple  finally  we need to modify the makefile so that our system call is added to the kernel when it is compiled if we look at the file /usr/src/linux *  * /kernel/makefile we get a line of the following format obj_y = sched.o + dn.o ? ? .etc we add  obj_y + = simple.o now we need to recompile the kernel note that there is no need to change the config file with the source code of the linux freely available  it is possible for users to make their own versions of the kernel a user can take the source code select only the parts of the kernel that are relevant to him and leave out the rest it is possible to get a working linux kernel in single 1.44 mb floppy disk a user can modify the source for the kernel so that operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/9 the kernel suits a targeted application better this is one of the reasons why linux is the successful  and preferred  platform for developing embedded systems in fact  linux has reopened the world of system programming the memory management issues the two major components in linux memory management are   the page management  the virtual memory management 1 the page management  pages are usually of a size which is a power of 2 given the main memory linux allocates a group of pages using a buddy system the allocation is the responsibility of a software called ? page allocator ?  page allocator software is responsible for both allocation  as well as  freeing the memory the basic memory allocator uses a buddy heap which allocates a contiguous area of size 2n > the required memory with minimum n obtained by successive generation of ? buddies ? of equal size we explain the buddy allocation using an example an example  suppose we need memory of size 1556 words starting with a memory size 16k we would proceed as follows  1 first create 2 buddies of size 8k from the given memory size ie 16k 2 from one of the 8k buddy create two buddies of size 4k each 3 from one of the 4k buddy create two buddies of size 2k each 4 use one of the most recently generated buddies to accommodate the 1556 size memory requirement note that for a requirement of 1556 words  memory chunk of size 2k words satisfies the property of being the smallest chunk larger than the required size possibly some more concepts on page replacement  page aging  page flushing and the changes done in linux 2.4 and 2.6 in these areas 2 virtual memory management  the basic idea of a virtual memory system is to expose address space to a process a process should have the entire address space exposed to it to make an allocation or deallocation linux makes a conscious effort to allocate logically  ? page aligned ? contiguous address space such page aligned logical spaces are called regions in the memory operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/10 linux organizes these regions to form a binary tree structure for fast access in addition to the above logical view the linux kernel maintains the physical view ie maps the hardware page table entries that determine the location of the logical page in the exact location on a disk the process address space may have private or shared pages changes made to a page require that locality is preserved for a process by maintaining a copy-on-write when the pages are private to the process where as these have to be visible when they are shared a process  when first created following a fork system call  finds its allocation with a new entry in the page table ? with inherited entries from the parent for any page which is shared amongst the processes  like parent and child   a reference count is maintained linux has a far more efficient page swapping algorithm than unix ? it uses a second chance algorithm dependent on the usage pattern the manner it manifests it self is that a page gets a few chances of survival before it is considered to be no longer useful frequently used pages get a higher age value and a reduction in usage brings the age closer to zero ? finally leading to its exit the kernel virtual memory  kernel also maintains for each process a certain amount of ? kernel virtual memory ? ? the page table entries for these are marked ? protected ?  the kernel virtual memory is split into two regions first there is a static region which has the core of the kernel and page table references for all the normally allocated pages that can not be modified the second region is dynamic  page table entries created here may point anywhere and can be modified loading  linking and execution  for a process the execution mode is entered following an exec system call this may result in completely rewriting the previous execution context ? this  however  requires that the calling process is entitled an access to the called code once the check is through the loading of the code is initiated older versions of linux used to load binary files in the a.out format the current version also loads binary files in elf format the elf format is flexible as it permits adding additional information for debugging etc a process can be executed when all the needed library routines have also been linked to form an executable module linux supports dynamic linking the dynamic linking is achieved in two stages  operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/11 1 first the linking process downloads a very small statically linked function ? whose task is to read the list of library functions which are to be dynamically linked 2 next the dynamic linking follows  resolving all symbolic references to get a loadable executable linux file systems introduction  linux retains most fundamentals of the unix file systems while most linux systems retain minix file systems as well  the more commonly used file systems are vfs and ext2fs which stand for virtual file system and extended file systems we shall also examine some details of proc file system and motivation for its presence in linux file systems as in other unixes in linux the files are mounted in one huge tree rooted at / the file may actually be on different drives on the same or on remotely networked machines unlike windows  and like unixes  linux does not have drive numbers like a  b  c  etc the mount operation  the unixes have a notion of mount operation the mount operation is used to attach a filesystem to an existing filesystem on a hard disk or any other block oriented device the idea is to attach the filesystem within the file hierarchy at a specified mount point the mount point is defined by the path name for an identified directory if that mount point has contents before the mount operation they are hidden till the file system is un-mounted the un-mount requires issuance of umount command linux supports multiple filesystems these include ext  ext2  xia  minix  umsdos  msdos  vfat  proc  smb  ncp  iso9660,sysv  hpfs  affs and ufs etc more file systems will be supported in future versions of linux all block capable devices like floppy drives  ide hard disks etc can run as a filesystem the ? look and feel ? of the files is the same regardless of the type of underlying block media the linux filesystems treat nearly all media as if they are linear collection of blocks it is the task of the device driver to translate the file system calls into appropriate cylinder head number etc if needed a single disk partition or the entire disk  if there are no partitions  can have only one filesystem that is  you can not have a half the file partition running ext2 and the operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/12 remaining half running fat32 the minimum granularity of a file system is a hard disk partition on the whole the ext2 filesystem is the most successful file system it is also now a part of the more popular linux distributions linux originally came with the minix filesystem which was quite primitive and 'academic ' in nature to improve the situation a new file system was designed for linux in 1992 called the exteneded file system or the ext file system mr remy card  r ? my card  laboratoire masi--institut blaise pascal  e-mail  card @ masi.ibp.fr  further improved the system to offer the extended file system -2 or the ext-2 file system this was an important addition to linux that was added along with the virtual file system which permitted linux to interoperate with different filesystems description  basic file systems concepts  every linux file system implements the basic set of concepts that have been a part of the unix filesystem along the lines described in ? the design of the unix ? book by maurice bach basically  these concepts are that every file is represented by an inode directories are nothing but special files with a list of entries i/o to devices can be handled by simply reading or writing into special files  example  to read data from the serial port we can do cat /dev/ttys0   superblock  super block contains the meta-data for the entire filesystem inodes  each file is associated with a structure called an inode inode stores the attributes of the file which include file type  owner time stamp  size pointers to data blocks etc whenever a file is accessed the kernel translates the offset into a block number and then uses the inode to figure out the actual address of the block this address is then used to read/write to the actual physical block on the disk the structure of an inode is as shown below in the figure operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/13 directories  directories are implemented as special files actually  a directory is nothing but a file containing a list of entries each entry contains a file name and a corresponding inode number whenever a path is resolved by the kernel it looks up these entries for the corresponding inode number if the inode number is found it is loaded in the memory and used for further file access links  unix operating systems implement the concept of links basically there are two types of links  hard links and soft links hard link is just another entry in directory structure pointing to the same inode number as the file name it is linked to the link count on the pointed inode is incremented if a hard link is deleted the link count is decremented if the name1 i1 name2 i2 name3 i3 name4 i4 name5 i5 directory inode table operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/14 link count becomes zero the inode is deallocated if the linkcount becoms zero it is impossible to have cross file systems hard links soft links are just files which contain the name of the file they are pointing to whenever the kernel encounters a soft link in a path it replaces the soft-link with it contents and restarts the path resolution with soft links it is possible to have cross file system links softlinks that are not linked to absolute paths can lead to havoc in some cases softlinks also degrade system performance device specific files  unix operating systems enable access to devices using special files these file do not take up any space but are actually used to connect the device to the correct device driver the device driver is located based on the major number associated with the device file the minor number is passed to the device driver as an argument linux kernel 2.4 introduced a new file system for accessing device files called as the device file system  look at the section on device drivers  the virtual file system  when the linux kernel has to access a filesystem it uses a filesystem type independent interface  which allows the system to carry out operations on a file system without knowing its construction or type since the kernel is independent of file system type or construction  it is flexible enough to accommodate future file systems as and when they become available virtual file system is an interface providing a clearly defined link between the operating system kernel and the different file systems operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/15 the vfs structure and file management in vfs  for management of files  vfs employs an underlying definition for three kinds of objects  1 inode object 2 file object 3 file system object associated with each type of object is a function table which contains the operations that can be performed the function table basically maintains the addresses of the operational routines the file objects and inode objects maintain all the access mechanism for each file ? s access to access an inode object the process must obtain a pointer to it from the corresponding file object the file object maintains from where a certain file is currently being read or written to ensure sequential io file objects usually belong to a single user process system call interface vfs f a t m i n i x f s e x t 2 buffer cache device driver disk controller linux kernel hardware operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/16 process the inode object maintains such information as the owner  time of file creation and modification the vfs knows about file-system types supported in the kernel it uses a table defined during the kernel configuration each entry in this table describes filesystem type  it contains the name of the filesystem type and a pointer to a function called during the mount operation when a file-system is to be mounted  the appropriate mount function is called this function is responsible for reading the super-block from the disk  initializing its internal variables  and returning a mounted file-system descriptor to the vfs the vfs functions can use this descriptor to access the physical file-system routines subsequently a mounted file-system descriptor contains several kinds of data  information that is common to every file-system type  pointers to functions provided by the physical file-system kernel code  and private data maintained by the physical filesystem code the function pointers contained in the file-system descriptors allow the vfs to access the file-system internal routines two other types of descriptors are used by the vfs  an inode descriptor and an open file descriptor each descriptor contains information related to files in use and a set of operations provided by the physical filesystem code while the inode descriptor contains pointers to functions that can be used to act on any file  e.g create  unlink   the file descriptors contains pointer to functions which can only act on open files  e.g read  write   the second extended file system  ext2fs  standard ext2fs features  this is the most commonly used file system in linux in fact  it extends the original minix fs which had several restrictions ? such as file name length being limited to 14 characters and the file system size limited to 64 k etc the ext2fs permits three levels of indirections to store really large files  as in bsd fast file system   small files and fragments are stored in 1kb  kilo bytes  blocks it is possible to support 2kb or 4kb blocks sizes 1kb is the default size the ext2fs supports standard * nix file types  regular files  directories  device special files and symbolic links ext2fs is able to manage file systems created on really big partitions while the original kernel code restricted the maximal file-system size to 2 gb  recent work in the vfs layer have raised this limit to 4 tb thus  it is now possible to use big disks without the need of creating many partitions operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/17 not only does ext2fs provide long file names it also uses variable length directory entries the maximal file name size is 255 characters this limit could be extended to 1012  if needed ext2fs reserves some blocks for the super user  root   normally  5 % of the blocks are reserved this allows the administrator to recover easily from situations where user processes fill up file systems as we had earlier mentioned physical block allocation policy attempts to place logically related blocks physically close so that io is expedited this is achieved by having two forms of groups  1 block group 2 cylinder group usually the file allocation is attempted with the block group with the inode of the file in the same block group also within a block group physical proximity is attempted as for the cylinder group  the distribution depends on the way head movement can be optimized advanced ext2fs features in addition to the standard features of the * nix file systems ext2fs supports several advanced features file attributes allow the users to modify the kernel behavior when acting on a set of files one can set attributes on a file or on a directory in the later case  new files created in the directory inherit these attributes  examples  compression immutability etc  bsd or system v release 4 semantics can be selected at mount time a mount option allows the administrator to choose the file creation semantics on a file-system mounted with bsd semantics  files are created with the same group id as their parent directory system v semantics are a bit more complex  if a directory has the setgid bit set  new files inherit the group id of the directory and subdirectories inherit the group id and the setgid bit ; in the other case  files and subdirectories are created with the primary group id of the calling process bsd-like synchronous updates can be used in ext2fs a mount option allows the administrator to request that metadata  inodes  bitmap blocks  indirect blocks and directory blocks  be written synchronously on the disk when they are modified this can be useful to maintain a strict metadata consistency but this leads to poor performances operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/18 ext2fs allows the administrator to choose the logical block size when creating the filesystem block sizes can typically be 1024  2048 and 4096 bytes ext2fs implements fast symbolic links a fast symbolic link does not use any data block on the file-system the target name is not stored in a data block but in the inode itself ext2fs keeps track of the file-system state a special field in the superblock is used by the kernel code to indicate the status of the file system when a file-system is mounted in read or write mode  its state is set to ` ` not clean'' whenever filesystem is unmounted  or re-mounted in read-only mode  its state is reset to  ` ` clean'' at boot time  the file-system checker uses this information to decide if a file-system must be checked the kernel code also records errors in this field when an inconsistency is detected by the kernel code  the file-system is marked as ` ` erroneous'' the file-system checker tests this to force the check of the file-system regardless of its apparently clean state always skipping filesystem checks may sometimes be dangerous  so ext2fs provides two ways to force checks at regular intervals a mount counter is maintained in the superblock each time the filesystem is mounted in read/write mode  this counter is incremented when it reaches a maximal value  also recorded in the superblock   the filesystem checker forces the check even if the filesystem is ` ` clean'' a last check time and a maximal check interval are also maintained in the superblock these two fields allow the administrator to request periodical checks when the maximal check interval has been reached  the checker ignores the filesystem state and forces a filesystem check ext2fs offers tools to tune the filesystem behavior like tune2fs physical structure  the physical structure of ext2 filesystems has been strongly influenced by the layout of the bsd filesystem .a filesystem is made up of block groups the physical structure of a filesystem is represented in this table  boot sector block grp 1 block grp2 ? ?  block grp n each block group contains a redundant copy of crucial filesystem control informations  superblock and the filesystem descriptors  and also contains a part of the filesystem  a block bitmap  an inode bitmap  a piece of the inode table  and data blocks   the structure of a block group is represented in this table  super block fs descriptors block bitmap inode bitmap inode table data blocks operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/19 using block groups is a big factor contributing to the reliability of the file system  since the control structures are replicated in each block group  it is easy to recover from a filesystem where the superblock has been corrupted this structure also helps to get good performances  by reducing the distance between the inode table and the data blocks  it is possible to reduce the disk head seeks during i/o on files in ext2fs  directories are managed as linked lists of variable length entries each entry contains the inode number  the entry length  the file name and its length by using variable length entries  it is possible to implement long file names without wasting disk space in directories as an example  the next table represents the structure of a directory containing three files  file  very_long_name  and f2 the first entry in the table is inode number ; the second entry is the entire entry length  the third field indicates the length of the file name and the last entry is the name of the file itself i1 15 05 file i2 40 30 very_very_very_long_file_name i3 12 03 i1 15 5 file i2 40 30 very_very_very_long_file_name inode table 0 15 40 operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/20 the ext3 file system  the ext2 file system is in fact a robust and well tested system even so some problem areas have been identified with ext2fs these are mostly with the shutdown fsck  for filesystem health check at the time of shutdown   it takes unduly long to set it right using e2fsck  the solution was to add journaling to the filesystem one more line about journaling another issue with the ext2 file system is its poor capability to scale to very large drives and files the ext3 file system which is in some sense an extension of the ext2 filesystem will try to address these shortcomings and also offer many other enhancements the proc file system  proc file system shows the power of the linux virtual file system the proc file system is a special file system which actually displays the present state of the system in fact we can call it a ? pretend ? file system if one explores the /proc directory one notices that all the files have zero bytes as the file size many commands like ps actually parse the /proc files to generate their output interestingly enough linux does not have any system call to get process information it can only be accessed by reading the proc file system the proc file system has a wealth of information for example the file /proc/cpuinfo gives a lot of things about the host processor a sample output could be as shown below  processor  0 vendor_id  authenticamd cpu family  5 model  9 model name  amd-k6  tm  3d + processor stepping  1 cpu mhz  400.919 cache size  256 kb fdiv_bug  no hlt_bug  no f00f_bug  no coma_bug  no fpu  yes fpu_exception  yes operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/21 cpuid level  1 wp  yes flags  fpu vme de pse tsc msr mce cx8 pge mmx syscall 3dnow k6_mtrr bogomips  799.53 /proc also contains  apart from other things  properties of all the processes running on the system at that moment each property is grouped together into a directory with a name equal to the pid of the process some of the information that can be obtained is shown as follows /proc/pid/cmdline command line arguments /proc/pid/cpu current and last cpu in which it was executed /proc/pid/cwd link to the current working directory /proc/pid/environ values of environment variables /proc/pid/exe link to the executable of this process /proc/pid/fd directory  which contains all file descriptors /proc/pid/maps memory maps to executables and library files /proc/pid/mem memory held by this process /proc/pid/root link to the root directory of this process /proc/pid/stat process status /proc/pid/statm process memory status information /proc/pid/status operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/22 process status in human readable form device drivers on linux introduction  most of the linux code is independent of the hardware it runs on applications are often agnostic to the internals of a hardware device they interact with they interact with the devices as a black box using operating system defined interfaces as far as applications are concerned  inside the black box sits a program that exercises a protocol to interact with the device completely this program interacts with the device at a very low level and abstracts away all the oddities and peculiarities of the underlying hardware to the invoking application obviously every device has a different device driver the demand for device drivers is increasing as more and more devices are being introduced and the old ones become obsolete in the context of linux as an open source os  device drivers are in great demand there are two principal drivers behind this firstly  many hardware manufacturers do not ship a linux driver so it is left for someone from the open source community to implement a driver second reason is the large proliferation of linux in the embedded system market some believe that linux today is number one choice for embedded system development work embedded devices have special devices attached to them that require specialized drivers an example could be a microwave oven running linux and having a special device driver to control its turntable motor in linux the device driver can be linked into the kernel at compile time this implies that the driver is now a part of the kernel and it is always loaded the device driver can also be linked into the kernel dynamically at runtime as a pluggable module operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/23 almost every system call eventually maps to a physical device with the exception of the processor  memory and a few other entities  all device control operations are performed by code that is specific to the device this code as we know is called the device driver kernel must have device drivers for all the peripherals that are present in the system right from the keyboard to the hard disk etc device classes  char devices  these devices have a stream oriented nature where data is accessed as a stream of bytes example serial ports the drivers that are written for these devices are usually called ? char device drivers ?  these devices are accessed using the normal file system usually they are mounted in the /dev directory if ls ? al command is typed on the command prompt in the /dev directory these devices appear with a ? c ? in the first column example  crw-rw-rw 1 root tty 2  176 apr 11 2002 ptya0 crw-rw-rw 1 root tty 2  177 apr 11 2002 ptya1 crw-rw-rw 1 root tty 2  178 apr 11 2002 ptya2 crw-rw-rw 1 root tty 2  179 apr 11 2002 ptya3 block devices  applicati on code kernel subsystems  examples  i/o controllers  file systems etc device drivers  examples  keyboard driver  scsi driver etc physical device  example  keyboard  hard disk etc system call interface hardware interface operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/24 these devices have a ? block ? oriented nature where data is provided by the devices in blocks the drivers that are written for these devices are usually called as block device drivers classic example of a block device is the hard disk these devices are accessed using the normal file system usually they are mounted in the /dev directory if a ls ? al command is typed on the command prompt in the /dev directory these devices appear with a ? b ? in the first column example  brw-rw 1 root disk 29  0 apr 11 2002 aztcd brw-rw 1 root disk 41  0 apr 11 2002 bpcd brw-rw 1 root floppy 2  0 apr 11 2002 fd0 network devices  these devices handle the network interface to the system these devices are not accessed via the file system usually the kernel handles these devices by providing special names to the network interfaces e.g eth0 etc note that linux permits a lot of experimentation with regards to checking out new device drivers one need to learn to load  unload and recompile to check out the efficacy of any newly introduced device driver the cycle of testing is beyond the scope of discussion here major/minor numbers  most devices are accessed through nodes in the file system these nodes are called special files or device files or simply nodes of the file system tree these names are usually mounted in the /dev/ directory if a ls ? al command is issued in this directory we can see two comma separated numbers that appear where usually the file size is mentioned the first number  from left side  is called the device major number and the second number is called the device minor number example  crw-rw-rw 1 root tty 2  176 apr 11 2002 ptya0 here the major number is 2 and the minor number is 176 the major number is used by the kernel to locate the device driver for that device it is an index into a static array of the device driver entry points  function pointers   the minor number is passed to the driver as an argument and the kernel does not bother about it the minor number may be used by the device driver to distinguish between the different types operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/25 of devices of the same type it supports it is left to the device driver  what it does with the minor numbers for the linux kernel 2.4 the major and minor numbers are eight bit quantities so at a given time you can have utmost 256 drivers of a particular type and 256 different types of devices loaded in a system this value is likely to increase in future releases of the kernel kernel 2.4 has introduced a new  optional  file system to handle device this file system is called the device file system  in this file system the management of devices is much more simplified although it has lot of user visible incompatibilities with the previous file system  at present device file system is not a standard part of most linux distributions in future  things might change in favour of the device file system here it must be mentioned that the following discussion is far from complete there is no substitute for looking at the actual source code the following section will mainly help the reader to know what to grep for in the source code we will now discuss each of the device class drivers that is block  character and network drivers in more detail character drivers  driver registeration/uregisteration  we register a device driver with the linux kernel by invoking a routine  < linux/fs.h >  int register_chrdev  unsigned int major  const char * name  struct file_operations * fops  ; here the major argument is the major number associated with the device name signifies the device driver as it will appear in the /proc/devices once it is successfully registered the fops is a pointer to the structure containing function pointers to the devices ? functionalities we will discuss fops in detail later now the question arises  how do we assign a major number to our driver  assigning major numbers  some numbers are permanently allocated to some common devices the reader may like to explore  /documentation/devices.txt in the source tree so if we are writing device drivers for these devices we simply use these major numbers if that is not the case then we can use major numbers that are allocated for experimental usage major numbers in the range 60-63  120-127  240-254 are for experimental usage operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/26 but how do we know that a major number is not already used especially when we are shipping a driver to some other computer by far the best approach is to dynamically assign the major number the idea is to get a free major number by looking at the present state of the system and then assigning it to our driver if the register_chrdev function is invoked with a zero in the major number field  the function  if it registers the driver successfully  returns the major number allocated to it what it does is that it searches the system for an unused major number  assigns it to the driver and then returns it the story does not end here to access our device we need to add our device to the file system tree that is  we need to do mknod for the device into the tree for that we need to know the major number for the driver for a statically assigned major number that is not a problem just use that major number you assigned to the device but for a dynamically assigned number how do we get the major number ? the answer is  parse the /proc/devices file and find out the major number assigned to our device a script can also be written to do the job removing a driver from the system is easy we invoke the unregister_chrdev  unsigned int major  const char * name  ; important data structure  the file structure < linux/fs.h >  every linux open file has a corresponding file structure associated with it whenever a method of the device driver is invoked the kernel will pass the associated file structure to the method the method can then use the contents of this structure to do its job we list down some important fields of this structure mode_t f_mode ; this field indicates the mode of the file i.e for read write or both etc loff_t f_pos ; the current offset in the file unsigned int f_flags ; this fields contains the flags for driver access for example synchronous access  blocking  or asynchronus  non blocking  access etc struct file_operations * fops ; this structure contains the entry points for the methods that device driver supports this is an important structure we will look at it in more detail in the later sections operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/27 void * private_data ; this pointer can be allocated memory by the device driver for its own personal use like for maintaining states of the driver across different function calls sruct dentry * f_dentry ; the directory entry associated with the file etc the file operations structure  fops   < linux/fs.h > this is the most important structure as far as device driver writer are concerned it contains pointers to the driver functions the file structure discussed in the previous section contains a pointer to the fops structure the file  device  is the object and fops contains the methods that act on this object we can see here object oriented approach in the linux kernel before we look at the members of the fops structure it will be useful if we look at taggd structure initialization  tagged structure initializations  the fops structure has been expanding with every kernel release this can lead to compatibility problems of the driver across different kernel versions this problem is solved by using tagged structure initialization tagged structure initialization is an extension of ansi c by gnu it allows initialization of structure by name tags rather than positional initialization as in standard c example  struct fops myfops =  ? ? ? ? ? ? ? ?  ? ? ? ? ? ? ?  open  myopen ; close  myclose  ? ? ? ?  ? ? ? ?  the intilization can now be oblivious of the change in the structure  provided obviously that the fields have not been removed   operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/28 pointers to functions that are implemented by the driver are stored in the fops structure methods that are not implemented are made null now we look at some of the members of the fops structure  loff_t  * llseek   struct file * ,loff_t  ; / * this method can be used to change the present offset in a file * / ssize_t  * read   struct file * ,char * ,size_t,loff_t *  ; / * read data from a device * / ssize_t  * write   struct file * ,const char * ,size_t,loff_t *  ; / * write data to the device * / int  * readdir   struct file * ,void * ,fill_dir_t  ; / * reading directories useful for file systems * / unsigned int  * poll   struct file * ,struct poll_table_struct *  ; / * used to check the state of the device * / int  * ioctl   struct inode * ,struct file * ,unsigned int,unsigned long  ; / * the ioctl is used to issue device specific calls  example setting the baud rate of the serial port   * / int  * mmap   struct file * ,struct vm_area_struct *  ; / * map to primary memory * / int  * open   struct inode * ,struct file *  ; / * open device * / int  * flush   struct file *  ; / * flush the device * / int  * release   struct inode * ,struct file *  ; / * release the file structure * / int  * fsync   struct inode * ,struct dentry *  ; / * flush any pending data to the device * / etc advance char driver operations  although most of the following discussion is valid to character as well as network and block drivers  the actual implementation of these features is explained with respect to char drivers operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/29 blocking and non-blocking operations  device drivers usually interact with hardware devices that are several orders of time slower than the processor typically if a modern pc processor takes a second to process a byte of data from a keyboard  the keyboard takes several thousand years to produce a single byte of data it will be very foolish to keep the processor waiting for data to arrive from a hardware device it could have severe impact on the overall system performance and throughput another cause that can lead to delays in accessing devices  which has nothing to do with the device characteristics  is the policy in accessing the device there might be cases where device may be blocked by other drivers  for a device driver writer it is of paramount importance that the processor is freed to perform other tasks when the device is not ready we can achieve this by the following ways one way is blocking or the synchronous driver access in this way of access we cause the invoking process to sleep till the data arrives the cpu is then available for other processes in the system the process is then awakened when the device is ready another method is in which the driver returns immediately whether the device is ready or not allowing the application to poll the device also the driver can be provided asynchronous methods for indicating to the application when the data is available let us briefly look at the linux kernel 2.4 mechanisms to achieve this there is a flag called o_nonblock flag in filp > f_flags  < linux/fcntl.h >   if this flag is set it implies that the driver is being used with non-blocking access this flag is cleared by default this flag is examined by the driver to implement the correct semantics blocking io  there are several ways to cause a process to sleep in linux 2.4 all of them will use the same basic data structure  the wait queue  wait_queue_head_t   this queue maintains a linked list of processes that are waiting for an event a wait queue is declared and initialized as follows  wait_queue_head_t my_queue ; / * declaration * / init_waitqueue_head  &my_queue  / * initialization * / operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/30 / * 2.4 kernel requires you to intialize the wait queue  although some earlier versions of the kernel did not * / the process can be made to sleep by calling any of the following  sleep_on  wait_queue_head_t * queue  ; / * puts the process to sleep on this queue * / / * this routine puts the process into non-interruptible sleep * / / * this a dangerous sleep since the process may end up sleeping forever * / interruptible_sleep_on  wait_queue_head_t * queue  / * same as sleep_on with the exception that the process can be awoken by a signal * / sleep_on_timeout  wait_queue_head_t * queue,long timeout  / * same as sleep_on except that the process will be awakened when a timeout happens the timeout parameter is measured in jiffies * / interruptible_sleep_on_timeout  wait_queue_head_t * queue,long timeout  / * same as interruptible_sleep_on except that the process will be awakened when a timeout happens the timeout parameter is measured in jiffies * / void wait_event  wait_queue_head_t * queue,int condition  int wait_event_interruptible  wait_queue_head_t * queue  int condition  / * sleep until the condition evaluates to true that is non-zero value * / / * preferred way to sleep * / if a driver puts a process to sleep there is usually some other part of the driver that awakens it  typically it is the interrupt service routine one more important point is that if a process is in interruptible sleep it might wake up even on a signal even if the event it was waiting on  has not occurred the driver must in this case put a process in sleep in a loop checking for the event as a condition in the loop the kernel routines that are available to wake up a process are as follows  wake_up  wait_queue_head_t * queue  / * wake proccess in the queue * / wake_up_interruptible  wait_queue_head_t * queue  / * wake process in the queue that are sleeping on interruptible sleep in the queue rest of the procccess are left undisturbed * / wake_up_sync  wait_queue_head_t_ * queue  wake_up_interruptible_sync  wait_queue_head_t_ * queue  operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/31 / * the normal wake up calls can cause an immediate reschedule of the processor * / / * these calls will only cause the process to go into runnable state without rescheduling the cpu * / non blocking io  if o_nonblock flag is set then driver does not block even if data is not available for the call to complete the normal semantics for a non-blocking io is to return -eagain which really tells the invoking application to try again usually devices that are using non-blocking access to devices will use the poll system call to find out if the device is ready with the data this is also very useful for an application that is accessing multiple devices without blocking polling methods  linux provides the applications 'poll ' and 'select ' system calls to check if the device is ready without blocking  there are two system calls offering the same functionality for historical reasons these calls were implemented in unix at nearly same time by two different distributions  bsd unix  select  system 5  poll   both the calls have the following prototype  unsigned int  * poll   struct file * ,poll_table *  ; the poll method returns a bit mask describing what operations can be performed on the device without blocking asynchronous notification  linux provides a mechanism by which a drive can asynchronously notify the application if data arrives basically a driver can signal a process when the data arrives user processes have to execute two steps to enable asynchronous notification from a device 1 the process invokes the f_setown command using the fcntl system call  the process id of the process is saved in filp > f_owner this is the step needed basically for the kernel to route the signal to the correct process 2 the asynchronous notification is then enabled by setting the fasync flag in the device by means of f_setfel fcntl command after these two steps have been successfully executed the user process can request the delivery of a sigio signal whenever data arrives interrupt handling in linux 2.4 the linux kernel has a single entry point for all the interrupts the number of interrupt lines is platform dependent the earlier x86 processors had just 16 interrupt lines but operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/32 now this is no longer true the current processors have much more than that moreover new hardware comes with programmable interrupt controllers that can be programmed among other things to distribute interrupts in an intelligent and a programmable way to different processors for a multi-processors system fortunately the device driver writer does not have to bother too much about the underlying hardware  since the linux kernel nicely abstracts it for the intel x86 architecture the linux kernel still uses only 16 lines the linux kernel handles all the interrupts in the same manner on the receipt of an interrupt the kernel first acknowledges the interrupt then it looks for registered handlers for that interrupt if a handler is registered  it is invoked the device driver has to register a handler for the interrupts caused by the device the following api is used to register an interrupt handler < linux/sched.h > int request_irq  unsigned int irq  void  * interrupthandler   int  void * ,struct pt_regs *   unisgned long flags  const char * dev_name  void * dev_id  ; / * irq  > the interrupt number being requested * / / * interrupthandler  > function pointer to the interrupt handler * / / * flags  > bitwise orable flags one of sa_interrupt implies 'fast handler ' which basically means that the interrupt handler finishes its job quickly and can be run in the interrupt context with interrupts disabled sa_shirq implies that the interrupt is shared sa_sample_random implies that the interrupt can be used to increase the entropy of the system * / / * dev_name  > a pointer to a string which will appear in /proc/interrupts to signify the owner of the interrupt * / / * dev_id > a unique identifier signifying which device is interrupting is mostly used when the interrupt line is shared otherwise kept null * / / * the interrupt can be freeed implying that the handler associated with it can be removed * /void free_irq  unsigned int irq,void * dev_id  ; / * by calling the following function here the meaning of the parameters is the same as in request_irq * /now the question that arises  how do we know which interrupt line our device is going to use some device use predefined fixed interrupt lines so they can be used some operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/33 devices have jumper settings on them that let you decide which interrupt line the device will use there are devices  like device complying to the pci standard  that can on request tell which interrupt line they are going to use but there are devices for which we can not tell before hand which interrupt number they are going to use for such device we need the driver to probe the irq number basically what is done is the device is asked to interrupt and then we look at all the free interrupt lines to figure out which line got interrupted this is not a clean method and ideally a device should itself announce which interrupt it wants to use  like pci   the kernel provides helper functions for probing of interrupts  < linux/interrupt.h > probe_irq_on  probe_irq_off  or the drive can do manual probing for interrupts top half and bottom half processing  one problem with interrupt processing is that some interrupt service routines are rather long and take a long time to process these can then cause interrupts to be disabled for a long time degrading system responsiveness and performance the method used in linux  and in many other systems  to solve this problem is to split up the interrupt handler into two parts  the ? top half ? and the ? bottom half ?  the top half is what is actually invoked at the interrupt context it will just do the minimum required processing and then wake up the bottom half the top half is kept very short and fast the bottom half then does the time consuming processing at a safer time earlier linux had a predefined fixed number of bottom halves  32 of them  for use by the driver but now the  kernel 2.3 and later  the kernel uses ? tasklets ? to do the bottom half processing tasklet is a special function that may be scheduled to run in interrupt context  at a system determined safe time a tasklet may be scheduled to run multiple times  but it only runs once an interesting consequence of this is that a top half may be executed several times before a bottom half gets a chance to execute now since only a single tasklet will be run  the tasklet should be able to handle such a situation the top half should keep a count of the number of interrupts that have happened the tasklet can use this count to figure out what to do / * takelets are declared using the following macro * / declare_tasklet  taskletname,function,data  ; / * taskletname  > name of the tasklet * / / * the function to be run as a tasklet the function has the following prototype * / operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/34 / * void function  usigned long  * / / * data is the argument to be passed to the function * / / * the tasklet can be scheduled using this function * / tasklet_schedule  &takletname  interprocess communication in linux  again there is considerable similarity with unix for example  in linux  signals may be utilized for communication between parent and child processes processes may synchronize using wait instruction processes may communicate using pipe mechanism processes may use shared memory mechanism for communication probably need some more points on this topic on ipc and the different mechanisms available i found a good url ? http  //cne.gmu.edu/modules/ipc/map.html ?   show these using animation  let us examine how the communication is done in the networked environment the networking features in linux are implemented in three layers  1 socket interface 2 protocol drivers 3 network drivers typically a user applications ? first i/f is the socket the socket definition is similar to bsd 4.3 unix which provides a general purpose interconnection framework the protocol layer supports what is often referred to as protocol stack the data may come from either an application or from a network driver the protocol layer manages routing  error reporting  reliable retransmission of data for networking the most important support is the ip suite which guides in routing of packets between hosts on top of the routing are built higher layers like udp or tcp the routing is actually done by ip driver the ip driver also helps in disassembly / assembly of the packets the routing gets done in two ways  1 by using recent cached routing decisions 2 by using a table which acts as a persistent forwarding base generally the packets are stored in a buffer and have a tag to identify the protocol that need to be used after the selection of the appropriate protocol the ip driver then hands it over to the network device driver to manage the packet movement operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/35 as for security  the firewall management maintains several chains ? with each chain having its own set of rules of filtering the packets real time linux  large number of projects both open source and commercial have been dedicated to get real time functionality from the linux kernel some of the projects are listed below commercial distributions  fsmlabs  rtlinuxpro lineo solutions  ulinux lynuxworks  bluecat rt montavista software  real-time solutions for linux concurrent  redhawk redsonic  redice-linux open source distributions  adeos ? art linux kurt  the ku real-time linux linux/rk qlinuxrealtimelinux.org red-linux rtai rtlinux linux installation amongst various flavors of unix  linux is currently the most popular os linux is also part of the gnu movement which believes in free software distribution a large community of programmers subscribe to it linux came about mainly through the efforts of linus torvalds from finland who wanted a unix environment on his pc while he was a university student he drew inspiration from prof andrew tanenbaum of university of amsterdam  who had earlier designed a small os called minix minix was primarily used as a teaching tool with its code made widely available and distributed minix code could be modified and its capability extended linus torvalds not only designed a pc-based unix for his personal use  but also freely distributed it presently  operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/36 there is a very large linux community worldwide every major university  or urban centre  has a linux group linux found ready acceptance and the spirit of free distribution has attracted many willing voluntary contributors now a days linux community regulates itself by having all contributions evaluated to ensure quality and to take care of compatibility this helps in ensuring a certain level of acceptance if you do a google search you will get a lot of information on linux our immediate concerns here are to help you have your own linux installation so that you can practice with many of the tools available under the broad category of unix-based oss 20.1 the installation linux can be installed on a wide range of machines the range may span from one 's own pda to a set of machines which cooperate like google 's 4000 node linux cluster for now we shall assume that we wish to install it on a pc most pcs have a bootable cd player and bios this means in most cases we can use the cd boot and install procedure older pc 's did not have these features in that case one was required to use a set of floppies the first part of this basic guide is about getting the installation program up and running  using either a cd or a set of floppies 20.2 the installation program in this section we describe the linux installation the main point in the installation is to select the correct configuration typically red hat linux is installed by booting to the install directory from a cd-rom the other options may include the following * booting to install using a floppy disk * using a hard drive partition to hold the installation software * booting from a dos command line * booting to an install and installing software using ftp or http protocols * booting to an install and installing software from an nfs-mounted hard drive installing from cd-rom  most pcs support booting directly from a cd-rom drive set your pc 's bios  if required   now insert the cd-rom and reboot to the pc to install red hat linux you should see a boot screen that offers a variety of options for booting .the options typically would be as follows  * < enter >  start the installation using a graphical interface * text  start the install using a text interface operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/37 * nofb  start the install using a video frame buffer * expert * linux rescue * linux dd at this stage if you press key f2 then it provides a help screen for the text-based installation type the word text at the boot prompt and press enter to continue you shall be asked to select a language so select a language of your choice highlight ok button and press enter you will then be asked to select a keyboard for install so highlight ok button and press enter after selecting a keyboard you shall be next asked to select a pointing device  select a suitable mouse and press ok next you will be asked  select the type of installation from ? * workstation * server * laptop * custom * upgrade an existing system select the suitable option  for example  select server install and press enter next you will choose a partitioning scheme the choices include the following  * auto partition * disk druid * fdisk the auto partition will the format hard drive according to the type of selected installation it will automatically configure the partitions for use with linux the disk druid will launch a graphical editor listing the free spaces available the fdisk option offers an ability to create nearly 60 different types of partitions on clicking disk druid  you will get an option of creating new partitions if you are using a new hard drive if you are using an old hard disk the partitions are recognized create the appropriate partitions or use existing ones as the case may be finally  press ok to continue red hat linux requires a minimum of two partitions one is a swap partition and the other a root  /  partition the swap partition should be more than twice as large as the operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/38 installed amount of memory other partitions may be /remote and /home these can be created after the installation as well you will now be as asked to select a boot-loader for booting linux the choice of not using a boot-loader is also available the options available are grub and lilo select the appropriate boot loader and press ok grub and lilo are typically installed in the mbr of the first ide hard drive in the pc you will now be asked for to choose kernel parameters for booting linux enter the arguments in the dialog box or use the ok button to continue if for some reason we can not arrive at dual booting automatically  then add this code at the end of the file /etc/boot/grud/grub.conf file title windows rootnoverify  hd0,0  chainloader + 1 makeactive you can now configure a dual boot system  if required by configuring the boot-loader when finished click ok and you will be asked to select a firewall configuration use a security level from * high * medium * none after this you will have to set the incoming service requests followed by a time-zone selection dialog box select the appropriate settings and press ok to continue you will now be prompted to enter a user-id and password the password will not be echoed onto the screen now is the time to create user accounts each has home directory home usually under /home/usr directory next you have to select packages you want to install use the spacebar to select the various groups of software packages the size of the installed software will dynamically reflect the choices use the select individual package item to choose the individual software packages the installer will now start installing the packages selected from the cd-rom drive onto the new linux partitions at the end of the installation you will get an option of creating a boot-disk for later use you can create the boot disk later using the mkbootdisk command operating systems/more on linux lecture notes pcp bhatt/iisc  bangalore m20/v1/june 04/39 after this  your installation is done press ok and red hat linux will eject the cd rom and reboot after rebooting you will be able to log onto a linux session to shutdown your computer use the shutdown -h now command usually most distributions allow you to test the set-up it helps to see if it works the auto detection  like in red hat  takes care of most of the cards and monitor types 20.2.1 finishing the installation with the above steps  we should have installed a good working linux machine the install program will usually prompt to take out all boot-disks  etc and the machine will be rebooted  sometimes you may have to reboot   you will see the linux loader coming up it is also known as lilo newer versions or distributions like mandrake come up with their own lilo 's redhat 7.x comes with a graphical screen and menu for startup anyway  one may see options like linux and/or dos or windows  normally we fill in these names during the installations another popular boot-loader called grub has become the default for redhat 