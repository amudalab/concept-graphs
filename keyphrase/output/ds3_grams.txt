lecture we looked
looked at stacks
queues and linked
part the class
queues linked list
list and double
double ended queues
recall the stack
follow the last
last in first
first out principle
removed first right
first right queue
first in first
principle whoever joins
joins the queue
queue early earlier
familiar with queues
queue for instance
instance here notion
element is removed
queue the element
remove the element
element from queue
insert an element
remove an element
abstract data type
create a queue
queue the method
method to add
add an element
queue and dequeue
queue the front
differ from dequeue
dequeue it doesn
remove the front
method to implement
implement the queue
queue and empty
queue is empty
return the true
empty and false
case of stacks
define similar axioms
element or enqueue
enqueue an element
suppose i create
dequeue an element
queue um queue
enqueued a element
means i added
added a element
two the queue
elements of first
elements of queue
front of queue
queue if queue
notion of front
front of enqueue
removed an element
queue was empty
queue i removed
right lets check
out lets assume
assume that queue
first i added
empty i added
left an empty
left be left
element the original
original queue queue
started with queue
queue i added
dequeued which means
means i remove
element of queue
implement a queue
array to implement
right um suppose
suppose someone tells
allocate an array
array of size
location this blue
reached this place
right the first
element i insert
element i inserted
deleting an elements
deleting an element
effect the elements
elements the queue
kind of drift
kind of deleted
deleted f minus
minus one element
lets say queue
right not accurate
accurate completely accurate
accurate the statement
inserting an elements
elements this queue
queue i insert
insert another element
inserted another element
insert anymore elements
doing ill rap
start and setting
setting the elements
right of rear
location the first
initially a queue
front was referring
minus one right
right because rear
point i reaches
reaches at equation
empty or full
full or empty
removing the elements
elements i didn
deleted i removed
element i removed
removed this removed
remove this right
suppose i incremented
move one step
move another step
add a element
manner f equals
code for enqueue
number of elements
queue is full
full we written
written the queue
queue full exception
case then add
add the rear
rear location put
put the element
circular so rap
rap around right
two it returns
returns this value
setting r minus
minus f tells
queue n minus
elements right check
confused is empty
empty f equals
element with queue
means the queue
full f equals
equals r return
empty will return
method for front
empty then raise
raise an exception
return an front
removing the front
front element done
increment the front
index and remove
element by setting
implement our queue
queue the disadvantage
array is fixed
queue you knew
maximum size queue
idea maximum size
size its increases
double the size
linked list assume
familiar with linked
essentially blinked list
tail of list
element some data
linked list implement
queue then question
right the tail
remove this element
element the linked
element from linked
change this pointer
accessing it pointer
element no problem
element the front
implement from methods
dequeue which means
increment just making
making the head
delete the head
delete this element
connected here make
make the head
node so inserting
inserting the head
kind of move
move the head
element recall enqueue
element this pointer
modified to pointer
pointer this element
element and tail
question we discuss
difficult to remove
remove this node
node to remove
access the previous
kind of list
list to start
problem his question
problem in removing
removing this node
node the problem
make this point
throw the entire
node very expensive
tail which means
means the front
queue data type
type is concern
introduce another data
double ended queue
queue right whats
whats the double
insert and delete
operations both ends
insert first insert
first insert last
insert last remove
remove first remove
first remove last
remove last insert
queue and insert
first and last
queue both ends
singly linked list
idea to implement
implement such double
doubly linked list
list to implement
implement double double
double double ended
queues so first
pointer one previous
two sentinel nodes
pointers one pointing
operations of double
queue in constant
delete this node
pointer to trail
follow the pointer
port and set
pointer to trailer
previous point trailer
node perhaps applied
header and trailer
linked list header
sentinel nodes dummy
nodes dummy nodes
nodes they don
dare to mark
mark the start
answering his question
delete san franchiso
makes this pointer
point to point
done in constant
operation in constant
front or delete
independent of number
right your running
fairly generic data
generic data type
implement other data
implementation of double
make a stack
stack or make
make a queue
implementation to implement
implement a stack
instance the method
top would correspond
correspond to lets
stack we make
make the top
correspond to return
last element double
element double ended
correspond to inserting
method pop correspond
correspond to deleting
ended queue right
sacrificing about last
make this correspond
size just corresponds
empty double ended
queue to implement
front would correspond
front first element
ended queue enqueue
corresponds to last
remove the first
element of double
methods two implement
stack or queue
pattern so adaptor
adaptor patterns implement
implement a class
class using methods
general adaptor classes
adaptor classes good
classes good specialized
good specialized general
specialized general classes
implement by changing
changing some methods
implement for stack
stack double ended
ended queue implement
changing sum methods
queue another application
stack we define
define an interface
interface called stack
array right lets
lets that implementation
contents of array
adapt this implementation
implementation called integer
integer array stack
cast the type
stack or removing
circularly linked list
element is pointing
pointers first stack
first stack head
head and tail
structure to implement
implement both queues
queues and stack
front the queue
queue the rear
makes this front
queue this right
guy and make
element your inserting
node and create
node and copy
copy this element
node right make
copying the reference
queue to remove
removing an element
corresponds to removing
removing the first
first one right
copy the contents
remove the rome
rome i copy
seatle to rome
copy here means
means just changing
changing this reference
discuss about queues
queues and double
sequences so vectors
talk about vectors
talk about positions
talk about list
list and general
arrays and linked
implement this data
vector data type
data type vector
type vector data
type is sequence
elements its support
support these methods
notion of rank
rank every element
sequence of elements
methods like give
element at rank
rank here corresponds
rank or integers
integers so first
element was element
suppose i asked
replaces the element
element e insert
rank r insert
insert the element
rank e rank
delete the element
methods yeah note
rank of student
two and departmental
suppose departmental rank
four does department
natural data type
data type structure
data structure implement
implement using arrays
lets see lets
implementation using arrays
element with rank
rank one element
rank two element
element as rank
rank zero rank
rank r whats
put an element
elements once step
first n minus
doing this first
two is moved
moved one step
element is pushed
thing is increased
right n suppose
stores the size
size of vector
elements one step
right all elements
two n minus
element at location
sitting at location
operations worst case
right this implementation
implementation is expensive
point of view
two operations insert
insert certain rank
remove certain rank
worst case order
operations are faster
array and retrive
retrive theelements sitting
sitting there replace
replace at rank
location and replace
replace with element
right chart shows
methods all elements
elements all methods
methods except inserted
inserted at rank
rank and remove
remove at rank
rank take constant
implementing this thing
right doubly linked
linked list vector
showing here operation
operation of inserting
insert at rank
node and put
understand the process
process of insertion
insertion right create
create this node
insert i make
makes a previous
previous pointer point
pointer would point
insert take order
list goes seventeen
insert this location
code for inserting
assuming the existence
node at rank
rank it tells
insert this node
rank two first
call this procedure
procedure with rank
node because earlier
node this node
previous to rank
set its previous
earlier at rank
rank two right
manner i create
check the previous
doing is assuming
process of deletion
out the node
node and update
manner get rid
code for doing
assuming the procedure
implement this procedure
array except march
list and find
incrementing my counter
reach that rank
two i start
list has hundred
element rank nineteen
point to start
start and staring
form the header
vector the vector
data type concerned
rank or insert
move the elements
insert to delete
right so linked
supporting node based
node based operation
delete that node
node in constant
insert the node
node after constant
delete the insert
insert a node
constant time operations
provide we give
give it access
give you access
implemented my list
pointers and stuff
right without knowing
knowing the actual
thing was done
notion of positions
positions abstract data
intuitively the place
elements is stored
data structure captures
element is method
data type position
call this method
make much sense
node your familiar
familiar with pointers
pointer which tells
pointer is access
access the element
pointer to update
update or previous
fields you don
node is implemented
list we don
type which hides
method that element
notion of position
list second element
position is referring
node50.53 second node
similarly first position
post \ ition
define a list
list abstract datatype
meythods like size
havce query method
hacve a method
method whoich asks
asks is first
positionoif my list
dfirst will give
first position last
last would give
methods like swap
swaps the contents
positions it wswaps
replace the element
replace the elemtn
elemtn at position
first ‘ position
uinsert the element
methods in constant
linked luist datastructure
abstract datatype implementation
double linked luist
linked luist methods
sequence abstract data
vector abstract data
element list data
list data type
combines the vector
vector and list
list abstract data
method that listed
listed for vector
vector list abstract
list abstract dat
abstract dat type
two additional methods
methods which kind
kind of suite
method at rank
correspond this rank
rank of method
identify what rank
method implement rank
position a position
suppose you gave
gave me rank
follow this reference
element certain rank
create new position
position the element
element would sit
move to right
change the ranks
ranks will change
change rank move
rank move step
case similarly deleting
wanted to delete
element that position
delete an element
comparison of sequence
implement a sequence
array the picture
picture i shown
case of running
element ceratin rank
out the element
update the pointers
out the rank
rank any rank
rank based operation
find the rank
out the find
out the position
stop our class
today where queues
queues we learnt
learnt about double
ise linked list
type the list
essentially a concretization
linked list data
list data structure
looked at sequence
sequence data types
data types sequence
types sequence data
types basically inheriting
last lecture
data type
implement stacks
array today
linked list
class today
first part
queues linked
ended queues
stack follow
out principle
first right
right queue
first element
rear element
element inserted
front rear
abstract data
standard operations
queue enqueue
front element
front end
support method
empty size
define axioms
similar axioms
true suppose
extra queue
empty queue
queue whichever
written front
written queue
queue queue
right lets
lets check
out lets
lets assume
remaining queue
cases queue
pros doubt
original queue
lets thing
elements queues
circular fashion
blue part
part occupied
queue kind
element lets
queue begin
anymore elements
started front
begin front
rear refers
empty location
point starting
empty right
adding elements
nth element
full exception
rear location
location put
modern require
sized bracket
method size
correct thing
negative right
worst minus
positive quantity
right number
ambiguity recall
return empty
queue empty
element done
front index
fixed size
maximum size
size queue
idea maximum
last class
list assume
blinked list
nodes list
list implement
element remove
removing note
queue removal
queue dequeue
head point
element head
node connected
easy right
dequeue operation
manner remove
element enqueue
element recall
recall enqueue
rear queue
null right
previous node
removing removing
entire list
expensive operation
queue data
ended queue
support insert
delete operations
first insert
last remove
last insert
queue remove
queue ofcourse
element operations
good idea
good solution
double double
double ended
previous pointer
sentinel nodes
previous port
previous point
point trailer
trailer nodes
list header
nodes dummy
dummy nodes
data inside
san franchiso
pointer point
operations understand
front insert
end delete
generic data
data types
method top
stack correspond
last element
method push
method pop
pop correspond
queue right
last year
empty corresponds
empty double
enqueue insert
rear corresponds
dequeue implementation
adaptor pattern
adaptor patterns
patterns implement
general adaptor
adaptor classes
general classes
queue implement
changing sum
sum methods
implement stack
array stack
stack implemented
arbitrary objects
integer array
integer objects
data structures
stack head
circular list
data structure
queue makes
rear right
straight forward
node make
node copying
element removing
element corresponds
lets remove
node copy
general sequence
linked lists
vector data
type vector
fourth element
element rank
instance lets
departmental rank
suppose departmental
department change
department rank
natural data
type structure
structure implement
arrays lets
moving step
finally element
suppose stores
elements starting
operations worst
worst case
operations insert
rank remove
case order
rth location
retrive theelements
theelements sitting
right chart
chart shows
list vector
element insert
make point
node makes
rank seventeen
seventeen position
procedure node
rank rank
previous field
doing don
doing showing
original list
previous pointers
java code
rank tells
nodes sitting
small improvement
hundred elements
rank nineteen
staring form
type concerned
require order
first case
element correspond
supporting node
node based
based operation
node delete
operations provide
delete right
things information
actual implementation
positions abstract
structure captures
method element
type position
element sitting
previous fields
element element
first position
list abstract
abstract datatype
positions ruight
abtstract datatype
generic meythods
havce query
query method
first positionoif
last position
excessive methods
lsat position
update methods
swap elemts
elemtsn sitting
linked luist
luist datastructure
datatype implementation
asbstract datatype
luist methods
efficient implement
sequence abstract
vector abstract
element list
list data
multiple inheritance
vector list
abstract dat
dat type
additional methods
suite connect
rank return
position correspond
array refers
rank corresponds
method implement
implement rank
procedure position
element store
case newyork
cross reference
change rank
rank move
move step
sequence operations
implement sequence
array implementation
element ceratin
ceratin rank
rank figure
rank based
rank find
learnt today
sequence data
types sequence
last
lecture
looked
stacks
data
type
implement
array
today
queues
linked
list
part
class
sequences
first
double
ended
queue
differ
stack
recall
follow
out
principle
element
inserted
removed
right
hand
joins
early
earlier
processed
familiar
elements
instance
notion
rear
remove
sitting
front
guilty
insert
end
abstract
define
methods
standard
operations
create
method
enqueue
add
dequeue
doesn
tells
support
size
empty
return
true
false
axioms
case
similar
understand
suppose
extra
obtained
call
similarly
enqueued
means
added
two
coming
whichever
written
defined
thing
operation
result
procedure
lets
check
assume
initially
remaining
left
cases
pros
doubt
dequeued
original
started
circular
fashion
larger
allocate
moving
variables
index
referring
position
refers
location
blue
occupied
reached
place
deleting
effect
kind
drift
stage
implies
essentially
deleted
minus
begin
accurate
completely
statement
inserting
anymore
space
start
doing
rap
setting
happen
point
previous
starting
reaches
equation
equals
full
removing
didn
increment
incremented
adding
move
step
pointing
nth
ambiguity
resolve
manner
problem
don
ensure
declare
code
pseudo
number
stop
exception
put
modern
require
indices
wanted
mod
sized
bracket
returns
value
negative
correct
things
quantity
positive
worst
confused
raise
done
null
clear
questions
disadvantage
fixed
knew
maximum
idea
increases
allotted
implementation
blinked
nodes
pointers
basically
referred
tail
node
question
note
permit
directly
change
pointer
accessing
removal
head
making
delete
easily
connected
make
easy
modified
update
discuss
difficult
constant
access
beginning
throw
entire
expensive
worth
concern
introduce
whats
ends
ofcourse
singly
good
repeatedly
solution
doubly
sentinel
minute
trail
port
set
trailer
applied
header
dummy
inside
dare
mark
answering
san
franchiso
makes
shown
independent
running
depend
fairly
generic
types
top
correspond
push
pop
sacrificing
year
corresponds
give
adaptor
pattern
patterns
general
classes
specialized
applications
application
changing
sum
interface
implemented
contents
arbitrary
objects
adapt
integer
suitably
cast
pushing
structures
circularly
simple
points
structure
guy
straight
forward
created
copy
copying
costly
reference
rome
seatle
quickly
vectors
talk
positions
sequence
arrays
lists
vector
rank
eleven
thirteen
nineteen
fourth
integers
asked
replaces
great
student
departmental
four
department
natural
shift
loop
moved
finally
pushed
increased
stores
shifting
posi
order
view
faster
rth
retrive
theelements
replace
chart
shows
complexity
implementing
showing
process
insertion
issues
find
seventeen
java
assuming
existence
finding
shortly
field
intimated
slides
web
show
deletion
rid
write
march
incrementing
counter
reach
small
improvement
hundred
staring
form
concerned
usen
supporting
based
efficient
provide
mention
sense
telling
stuff
hide
information
knowing
actual
implementations
intuitively
stored
captures
object
situated
fields
implementer
hides
details
related
node50.53
post
ition
datatype
ruight
abtstract
meythods
havce
query
hacve
whoich
asks
positionoif
excessive
dfirst
lsat
geive
postion
swap
elemts
key
swaps
elemtsn
wswaps
elemtn
uinsert
onya
luist
datastructure
caprture
yuou
asbstract
linear
talked
combines
inherits
interfaces
multiple
inheritance
listed
dat
additional
suite
connect
identify
determine
gave
store
newyork
cross
sit
ranks
leave
exercise
comparison
picture
previously
ceratin
zap
context
figure
learnt
ise
concretization
inheriting
