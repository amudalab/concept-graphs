nicolette avi silberschatz
maddie peter baer
peter baer galvin
tom and jay
jay greg gagne
greg gagne abraham
gagne abraham silberschatz
sidney j weinberg
professor & chair
chair of computer
science at yale
prior to joining
information sciences research
sciences research center
center at bell
held a chaired
department of computer
university of texas
texas at austin
austin professor silberschatz
fellow he received
taylor l booth
booth education award
karlstrom outstanding educator
outstanding educator award
acm sigmod contribution
sigmod contribution award
award in recognition
level of innovation
innovation and technical
awarded the bell
bell laboratories president
president s award
projects-the qtm project
silberschatz  writings
writings have appeared
appeared in numerous
acm and ieee
conferences and journals
textbook database system
database system concepts
written op-ed articles
technologist for corporate
computer facility reseller
reseller and integrator
manager for brown
university s computer
computer science department
magazine mr galvin
galvin has written
articles for byte
columns for sun
world and sysadmin
consultant and trainer
talks and taught
tutorials on security
security and system
system administration worldwide
administration worldwide greg
worldwide greg gagne
gagne is chair
department at westminster
college in salt
salt lake city
addition to teaching
teaching operating systems
teaches computer networks
workshops to computer
computer science educators
educators and industry
industry professionals operating
professionals operating systems
education this field
field is undergoing
undergoing rapid change
virtually every application
games for children
sophisticated planning tools
tools for governments
governments and multinational
fundamental concepts remain
remain fairly clear
base this book
book we wrote
wrote this book
junior or senior
senior undergraduate level
first-year graduate level
level we hope
hope that practitioners
concepts that underlie
underlie operating systems
systems as prerequisites
reader is familiar
familiar with basic
basic data struchues
java the hardware
hardware topics required
understanding of operating
systems are included
included in chapter
understand the algorithms
concepts are presented
presented using intuitive
intuitive descriptions important
descriptions important theoretical
important theoretical results
results are covered
proofs are omitted
omitted the bibliographical
chapter contain pointers
pointers to research
presented and proved
references to material
reading in place
place of proofs
figures and examples
expect the result
result in question
true the fundamental
concepts and algorithms
existing conunercial operating
conunercial operating systems
systems our aim
present these concepts
system we present
present a large
number of examples
examples that pertain
im1.ovative operating systems
including sun microsystems
microsystems  solaris
solaris ; linux
linux ; microsoft
microsoft windows vista
implying windows vista
state this explicitly
explicitly vii viii
viii the organization
years of teaching
courses on operating
operating systems consideration
submitted by readers
readers of earlier
editions in addition
suggestions from computing
joint task force
ieee computing society
association for computing
supporting web site
provide several sample
syllabi that suggest
suggest various approaches
introductory and advanced
readers to progress
study of operating
reader can select
ordering of chapters
subsections of chapters
text is provided
provided by wileyplus
students can find
find sample exercises
exercises and programming
instructors can assign
assign and grade
problems in addition
students can access
access new operating-system
work through exercises
exercises and hands-on
hands-on lab activities
lab activities references
text the text
text is organized
explain what operating
designed and constructed
constructed these chapters
operator the presentation
presentation is motivational
motivational and explanatory
explanatory in nature
avoided a discussion
things are done
suitable for individual
students in lower-level
internal algorithms process
algorithms process management
management and process
process coordination chapters
describe the process
concept and concurrency
heart of modern
modern operating systems
systems a process
unit of work
concurrently executing processes
execute system code
execute user code
chapters cover n1.ethods
n1.ethods for process
handling also included
discussion of threads
examination of issues
related to multicore
multicore systems memory
systems memory management
memory management chapters
management of main
process to improve
processes in memory
situation storage management
storage management chapters
i are handled
modern computer system
system the file
mechanism for on-line
data and programs
programs we describe
describe the classic
classic internal algorithms
algorithms and structures
structures of storage
management and provide
provide a firm
firm practical understanding
algorithms used -their
disadvantages our discussion
discussion of storage
storage also includes
includes matters related
related to secondary
secondary and tertiary
provide a wide
range of functionality
functionality to applications
control all aspects
devices we discuss
i in depth
including i system
internal system structures
structures and functions
slowest major components
represent a performance
examine performance issues
i devices protection
protection and security
discuss the mechanisms
security of computer
systems the processes
provide such protection
gained proper authorization
system can operate
mechanism for controlling
controlling the access
access of programs
system this mechanism
mechanism must provide
provide a means
means of enforcement
enforcement security protects
protects the integrity
data and code
destruction or alteration
introduction of inconsistency
inconsistency distributed systems
distributed systems chapters
collection of processors
clock-a distributed system
system by providing
providing the user
user with access
system can improve
improve computation speed
speed and data
availability and reliability
distributed file system
system whose users
devices are dispersed
system a distributed
system must provide
provide various mechanisms
mechanisms for process
synchronization and communication
dealing with deadlock
variety of failures
centralized system special-purpose
system special-purpose systems
special-purpose systems chapters
deal with systems
including real-time systems
systems and multimedia
systems these systems
systems have specific
requirements that differ
text real-time systems
systems may require
results be correct
results be produced
deadline period multimedia
period multimedia systems
multimedia systems require
systems require quality-of-service
require quality-of-service guarantees
quality-of-service guarantees ensuring
data are delivered
delivered to clients
specific time frame
frame x case
case studies chapters
integrate the concepts
chapters by describing
describing real operating
real operating systems
systems include linux
linux and freebsd
freebsd because unix-at
unix-at one time-was
time-was almost small
toy operating system
algorithms were selected
selected for simplicity
speed or sophistication
sophistication both linux
students have access
systems we chose
provide an opporhmity
study a modern
modern operating system
design and implementation
influential operating systems
systems this book
book uses examples
real-world operating systems
systems to illustrate
illustrate fundamental operating-system
fundamental operating-system concepts
attention is paid
family of operating
including windows vista
versions of unix
provide a significant
amount of coverage
linux operating system
operating system reflecting
book was written
written the text
java these programs
programs are intended
intended to run
systems the primary
primary programming environment
environment for windows
application programming interface
set of functions
functions for managing
devices we provide
api example programs
programs were tested
tested on systems
systems rum1.ing windows
rum1.ing windows vista
windows xp posix
stands for portable
portable operating system
operating system inte1jace
represents a set
set of standards
primarily for unix-based
unix-based operating systems
systems although windows
run certain posix
primarily on unix
unix and linux
linux systems posix-compliant
systems posix-compliant systems
systems must implement
implement the posix
posix core standard
examples of posix-compliant
posix also defines
defines several extensions
including real-time extensions
provide several programn1.ing
programn1.ing examples written
written inc illustrating
illustrating the posix
posix base api
extensions for real-time
tested on debian
compilers java java
widely used programming
api and built-in
built-in language support
support for thread
creation and management
java xi programs
operating system supporting
supporting a java
java virtual machine
illustrate various operating
system and networking
java programs tested
two most popular
models of operating
widely used java
environment most programming
examples are written
language ; readers
understand most programs
instances-such as thread
thread creation-we illustrate
illustrate a specific
allowing the reader
reader to contrast
apis to demonstrate
demonstrate a concept
illustrate shared memory
api ; socket
programming in tcp
wrote the eighth
edition of operating
operating system concepts
comments and suggestions
suggestions we received
received from readers
rapidly changing fields
fields of operating
systems and networking
chapters by bringing
bringing older material
date and removing
longer of interest
interest or relevance
made substantive revisions
revisions and organizational
coverage of open-source
open-source operating systems
systems in chapter
added more practice
exercises for students
students and included
solutions in wileyplus
includes new simulators
simulators to provide
demonstrations of operating-system
expanded to include
include multicore cpus
operating systems chapter
significantly updated coverage
coverage of virtual
grub boot loader
operating-system debugging chapter
coverage of pipes
form of interprocess
interprocess communication chapter
adds new coverage
coverage of programming
programming for multicore
multicore systems chapter
virtual machine scheduling
scheduling and multithreaded
multicore architectures chapter
adds a discussion
discussion of mutual
mutual exclusion locks
transactional memory chapter
discussion of numa
numa xii chapter
updates the solaris
memory managernent chapter
updated with current
technologies and capacities
implementing file systems
includes a full
description of sun
sun s zfs
zfs file system
system and expands
expands the coverage
coverage of volumes
volumes and directories
coverage of iscsi
zfs pools chapter
coverage of pcix
pcix pci express
distributed operating systems
wireless networks chapter
updated to cover
cover the latest
limix kernel chapter
emphasize the concepts
added several programming
problems and projects
posix and win32
networking in addition
added or modified
modified several programming
involved than standard
standard programming exercises
exercises these projects
projects include adding
adding a system
unix and windows
unix message queues
creating multithreaded applications
solving the producer-consumer
problem using shared
memory the eighth
edition also incorporates
incorporates a set
set of operating-system
operating-system simulators designed
texas at san
antonio the simulators
simulators are intended
intended to model
model the behavior
performs various tasks
cpu and disk-head
creation and interprocess
translation these simulators
simulators are written
written in java
systern with java
students can download
download the simulators
simulators from wileyplus
wileyplus and observe
observe the behavior
scenarios in addition
includes several exercises
students to set
set certain parameters
explain this behavior
behavior these exercises
assigned through wileyplus
wileyplus the wileyplus
includes algorithmic problems
problems and tutorials
developed by scott
scott m pike
pike of texas
texas a&m university
a&m university xiii
set of slides
slides to accompany
accompany the book
model course syllabi
java source code
case study appendices
distributed communication appendix
appendix the wileyplus
additional practice exercises
testbank of additional
additional problems students
students are encouraged
encouraged to solve
solve the practice
solutions to check
answers to obtain
obtain restricted supplements
contact your local
local j orne
wiley & sons
sons sales representative
sales representative note
system for communication
users of operating
url and follow
follow the instructions
mailmanllistinfo i os-book
os-book the mailman
mailman mailing-list system
archive of postings
digest and web
forward the message
list the list
list is moderated
receive no inappropriate
inappropriate mail students
text for class
attempted to clean
systems-a few obscure
bugs may remain
errors or omissions
glad to hear
correspondence to os-book-authors
os-book-authors @ cs.yale.edu
cs.yale.edu this book
book is derived
coauthored by james
previous editions include
editions include hamid
include hamid arabnia
xiv joseph boykin
ajoy kum.ar datta
sudarshan k dhall
ahmed kamet marty
kamet marty kewstet
marty kewstet richard
kewstet richard kieburtz
marty k westet
westet thomas leblanc
thomas p skimcer
jesse st laurent
larry l wear
james m westall
yang xiang parts
parts of chapter
paper by hillyer
hillyer and silberschatz
paper by levy
levy and silberschatz
manuscript by stephen
stephen tweedie chapter
manuscript by dave
avi silberschatz appendix
manuscript by cliff
cliff martin cliff
martin cliff martin
martin also helped
helped with updating
updating the unix
appendix to cover
exercises and accompanying
solutions were supplied
supplied by arvind
arvind krishnamurthy mike
krishnamurthy mike shapiro
jim mauro answered
answered several solarisrelated
solarisrelated questions bryan
questions bryan cantrill
cantrill from sun
sun microsystems helped
zfs coverage steve
coverage steve robbins
san antonio designed
designed the set
set of simulators
incorporate in wileyplus
wileyplus reece newman
newman of westminster
college initially explored
explored this set
text josh dees
dees and rob
rob reynolds contributed
reynolds contributed coverage
coverage of microsoft
microsoft s .net
.net the project
posix message queues
queues was contributed
contributed by john
trona of saint
michael s college
college in colchester
vermont marilyn turnamian
marilyn turnamian helped
turnamian helped generate
helped generate figures
figures and presentation
presentation slides mark
slides mark wogahn
wogahn has made
software to produce
produce the book
properly our associate
provided expert guidance
prepared this edition
assisted by carolyn
managed many details
smoothly the senior
senior production editor
production editor ken
editor ken santor
instrumental in handling
production details lauren
details lauren sapira
sapira and cindy
wileyplus beverly peavler
beverly peavler copy-edited
copy-edited the manuscript
manuscript the freelance
proofreader was katrina
indexer was word
part one overview
operating-system sh ucture
user operating-system interface
types of system
part two process
two process management
process management chapter
operations on processes
examples of ipc
communication in clientserver
operating system examples
part three process
process coordination chapter
peterson s solution
problems of synchronization
methods for handling
recovery from deadlock
part four memory
four memory management
memory management chapter
contiguous memory allocation
allocation of frames
allocating kernel memory
part five storage
storage management chapter
directory and disk
efficiency and performance
wafl file system
overview of mass-storage
application i interface
kernel i subsystem
transforming i requests
requests to hardware
part six protection
goals of protection
principles of protection
domain of protection
implementation of access
system and network
implementing security defenses
firewalling to protect
systems and networks
revocation of access
part seven distributed
distributed systems chapter
types of networkbased
networkbased operating systems
distributed file systems
naming and transparency
remote file access
stateful versus stateless
versus stateless service
part eight special
special purpose systems
purpose systems chapter
features of real-time
implementing real-time operating
real-time operating systems
real-time cpu scheduling
requirements of multimedia
part nine case
case studies chapter
input and output
macintosh operating system
system and windows
xix xx chapter
chapter a bsd
unix a1 unix
a.4 user interface
mach system b.l
system b.l history
b.2 design principles
b.3 system components
b.4 process management
b.s interprocess conununication
b.6 memory management
appendix c windows
c.2 design principles
c.3 system components
c.4 enviromnental subsystems
c.s file system
b.7 programmer interface
c.7 programmer interface
operating system acts
hardware the purpose
provide an environment
user can execute
convenient and efficient
manner an operating
system is software
software that manages
manages the computer
hardware the hardware
hardware must provide
provide appropriate mechanisms
mechanisms to ensure
ensure the correct
prevent user programs
programs from interfering
operating systems vary
lines the design
begins these goals
form the basis
basis for choices
algorithms and strategies
system is large
large and complex
piece by piece
carefully defined inputs
program that manages
basis for application
programs and acts
hardware an amazing
aspect of operating
accomplishing these tasks
tasks mainframe operating
mainframe operating systems
systems are designed
primarily to optimize
utilization of hardware
hardware personal computer
operating systems support
systems support complex
support complex games
systems for handheld
computers are designed
designed to provide
computer to execute
explore the details
details of computer
computer system operation
structure we begin
begin by discussing
discussing the basic
functions of system
describe the basic
basic computer architecture
architecture that makes
write a functional
functional operating system
provide a general
system to provide
provide a grand
components of operating
systems to describe
organization of computer
systems we begin
begin our discussion
system s role
system a computer
compiler assembler text
assembler text editor
text editor operating
editor operating system
operating system database
system database system
database system figure
system four components
ievices-provides the basic
basic computing resources
browsers-define the ways
users  computing
problems the operating
operating system controls
controls the hardware
hardware and coordinates
view a computer
system as consisting
data the operating
means for proper
system an operating
system is similar
work to understand
fully the operating
operating systemfs role
explore operating systems
system 1.1.1 user
1.1.1 user view
view the user
user s view
computer users sit
sit in front
system is designed
user to monopolize
monopolize its resources
resources the goal
maximize the work
user is performing
paid to performance
hardware and software
resources are shared
requirements of multiple
users are accessing
accessing the sance
terminals these users
users share resources
information the operating
cases is designed
designed to maximize
resource utilizationto assure
efficiently and tbat
tbat no individual
individual user takes
sit at connected
connected to networks
users have dedicated
networking and servers-file
designed to compromise
compromise between individual
usability and resource
varieties of handheld
devices are standalone
units for individual
directly by wire
modems and networking
operations their operating
performance per unit
unit of battery
life is important
computers in home
devices and automobiles
turn indicator lights
primarily to run
run without user
intervention 1.1.2 system
1.1.2 system view
computer s point
point of view
view an operating
required to solve
solve a problem
resources facing numerous
possibly conflicting requests
requests for resources
system must decide
programs and users
operate the computer
efficiently and fairly
mainframe or minicomputer
slightly different view
operating system emphasizes
devices and user
programs an operating
program a manages
manages the execution
execution of user
programs to prevent
errors and improper
operation and control
devices 1.1.3 defining
1.1.3 defining operating
defining operating systems
completely adequate definition
operating system operating
system operating systems
operating systems exist
offer a reasonable
solve the problem
problem of creating
creating a usable
usable computing system
system the fundamental
goal of computer
execute user programs
make solving user
definitions and notation
unit of computer
computer is based
based on collections
collections of bits
things a computer
computer can represent
smallest convenient chunk
chunk of storage
instruction to move
move a bit
move a byte
architecture s native
native storage unit
unit a word
instructions to move
words a kilobyte
1,0243 bytes computer
bytes computer manufacturers
manufacturers often round
billion bytes problems
bytes problems easier
hardware is constructed
constructed since bare
programs are developed
developed these programs
require certain common
devices the common
functions of controlling
controlling and allocating
piece of software
system in addition
universally accepted definition
system a simple
order the operating
system the features
greatly across systems
systems some systems
megabyte of space
space and lack
gigabytes of space
based on graphical
graphical windowing systems
two other types
types of programs
include all programs
constitutes an operating
united states deparhnent
deparhnent of justice
justice filed suit
suit against microsoft
claiming that microsoft
prevented application vendors
vendors from competing
microsoft was found
monopoly to limit
computer systems operate
structure the section
study ofoperating systems
neverbeenarnore interestirighnwtostud yoperating
interestirighnwtostud yoperating systems
neverb.een.e ~ sier.theopen-sourc
movernent has overtaken
overtaken .operating systems
caj.tsing marly ofthenctobemadeavailable
source and binary
fonnat .this iistindud
availa ~ ilityqf
.gsy tems frorrt
1sly could onlyb
onlyb ~ answerecl
rating system c.annow
c.annow be answered
answered by examining
examining the code
rise of virtualization
hundreds.of free .virtualappliilnces
.virtualappliilnces  cann.m.using
cann.m.using this method,students
method,students call tryolit
call tryolit hundreds
tryolit hundreds ofoperatingsystems.withintheir
hundreds ofoperatingsystems.withintheir existing
ofoperatingsystems.withintheir existing operatingsystems
operatingsystems .atno cost
enablirtg .usto study
study how system
system ~ pperated
exten ~ iye.b
.it not complete
9pen-sourct operafirtg system
.to.runon.na ~ ve.hardware
tipj-iter and moderj1
opf ~ ystem
decsystemc20 simulator running
running on mac
modify alld comp
rnel art interested
art interested stltdent
theint ~ rnet
rnet to find
find the origillal
cribe the operating
the.origipa ~ manuals
easy t .make
.make the move
fromstu ~ enttooper
lting ~ systemdeveloper.with
systemdeveloper.with some knov.rledge
som ~ effo1t
a11d an internet
internet connection,a student
operating-systemdistribution ! justa
justa fev.r years
_llt or if1lpossible
access is lijnited
lijnited only bylt
wmuchtimeand disk space
space a student
skim or skip
understand the concepts
concepts 1.2.1 computer-system
1.2.1 computer-system operation
operation a modern
modern general-purpose computer
general-purpose computer system
computer system consists
number of device
device controllers connected
access to shared
type of device
controllers can execute
competing for memory
cycles to ensure
ensure orderly access
controller is provided
provided whose function
computer to start
start rum ing-for
rum ing-for instance
program to run
run this initial
mouse keyboard printer
keyboard printer monitor
i-nneh b figure
computer system program
stored in read-only
electrically erasable programmable
erasable programmable read-only
programmable read-only memory
hardware it initializes
initializes all aspects
registers to device
controllers to memory
contents the bootstrap
load the operating
system to accomplish
accomplish this goal
program must locate
locate and load
load into memory
memory the operatingsystem
kernel the operating
system then starts
executing the first
event to occur
occur the occurrence
hardware may trigger
trigger an interrupt
sending a signal
system bus software
software may trigger
executing a special
cpu is interrupted
immediately transfers execution
location the fixed
interrupt is located
located the interrupt
interrupt service routine
service routine executes
resumes the interrupted
operation is shown
shown in figure
architecture each computer
functions are common
common the interrupt
interrupt must transfer
routine the straightforward
method for handling
handling this transfer
invoke a generic
routine to examine
examine the interrupt
call the interrupt-specific
number of interrupts
table of pointers
pointers to interrupt
speed the interrupt
intermediate routine needed
pointers is stored
stored in low
hold the addresses
interrupt service routines
devices this array
unique device number
provide the address
routine for cpu
device process executing
interrupt processing idle
transfer request done
request done figure
interrupt time line
single process doing
process doing output
interrupting device operating
device operating systems
unix dispatch interrupts
manner the interrupt
save the address
designs simply stored
stored the interrupt
number more recent
recent architectures store
store the return
modify the processor
processor state-for instance
modifying register values-it
save the current
restore that state
state before returning
interrupt is serviced
saved return address
address is loaded
interrupted computation resumes
occurred 1.2.2 storage
1.2.2 storage structure
structure the cpu
cpu can load
programs to run
stored there general-purpose
general-purpose computers run
programs from rewriteable
commonly is implemented
technology called computers
forms of memory
camwt be changed
programs are stored
immutability of rom
cartridges eeprom camwt
eeprom to store
store their factory-il
factory-il stalled programs
programs all forms
provide an array
array of words
words each word
interaction is achieved
sequence of load
load or store
instructions to specific
specific memory addresses
addresses the load
load instruction moves
moves a word
word from main
store instruction moves
moves the content
register to main
loads and stores
cpu automatically loads
automatically loads instructions
instructions from main
memory for execution
execution a typical
typical instruction-execution cycle
fetches an il1struction
il1struction from memory
memory and stores
stores that instruction
fetched from memory
memory and stored
back in memory
memory unit sees
stream of memory
instructions or data
address is generated
sequence of memory
memory addresses generated
programs and data
data to reside
reside in main
main ncemory permanently
permanently this arrangement
small to store
store all needed
data permanently main
permanently main memory
volatile storage device
device that loses
loses its contents
contents when power
power is turned
computer systems provide
extension of main
memory the main
requirement for secondary
hold large quantities
quantities of data
common secondary-storage device
data most programs
system and application
loaded into memory
memory many programs
management of disk
discuss in chapter
describedconsisting of registers
systems others include
include cache memory
functions of storing
storing a datum
datum and holding
holding that datum
storage systems lie
lie in speed
volatility the wide
variety of storage
speed and cost
cost the higher
levels are expensive
cost per bit
bit generally decreases
increases this trade-off
trade-off is reasonable
expensive than another-other
memory in fact
early storage devices
including paper tape
tape and core
relegated to museums
faster and cheaper
cheaper the top
top four levels
levels of memory
memory in figure
constructed using semiconductor
memory in addition
addition to differing
differing in speed
volatile or nonvolatile
nonvolatile as mentioned
device is removed
absence of expensive
battery and generator
generator backup systems
disk are volatile
symmetric multiprocessing architecture
multiprocessing architecture solaris
solaris the benefit
processes can run
simultaneously -n processes
causing a significant
deterioration of performance
i to ensure
cpus are separate
resulting in inefficiencies
inefficiencies these inefficiencies
share certain data
structures a multiprocessor
processes and resources-such
resources-such as memory-to
memory-to be shared
lower the variance
virtually all modern
modern operating systems-including
operating systems-including windows
linux -now provide
-now provide support
support for smp
smp the difference
difference between symmetric
symmetric and asymmetric
multiprocessing may result
hardware or software
software special hardware
hardware can differentiate
differentiate the multiple
master and multiple
slaves for instance
sun s operating
operating system sunos
system sunos version
provided asymmetric multiprocessing
hardware multiprocessing adds
multiprocessing adds cpus
cpus to increase
increase computing power
integrated memory controller
increase the amount
amount of memory
system to change
change its memory
memory access model
model from uniform
uniform memory access
access to non-uniform
non-uniform memory access
memory access uma
uma is defined
parts of memory
longer to access
creating a performance
performance penalty operating
penalty operating systems
systems can minimize
minimize the numa
penalty through resource
discussed in section
9.5.4 a recent
trend in cpu
in.clude multiple computing
chip in essence
efficient than multiple
chips with single
cores because on-chip
communication is faster
faster than between-chip
communication in addition
chip with multiple
significantly less power
power than multiple
multiple single-core chips
database and web
chip in figure
show a dual-core
combination of local
local and shared
processors this tendency
tendency puts pressure
pressure on operating
operating system designers-and
system designers-and application
application programmers-to make
multiple processor boards
chassis the difference
traditional multiprocessor systems
blade-processor board boots
independently and runs
system some blade-server
boards are n1.ultiprocessor
blurs the lines
lines between types
types of computers
computers in essence
consist of multiple
multiple independent multiprocessor
independent multiprocessor systems
systems 1.3.3 clustered
1.3.3 clustered systems
systems another type
type of multiple-cpu
gather together multiple
cpus to accomplish
accomplish computational work
computational work clustered
work clustered systems
clustered systems differ
differ from multiprocessor
individual systems-or nodes-joined
commercial packages wrestle
generally accepted definition
clustered computers share
computers share storage
described in section
service will continue
cluster fail high
fail high availability
obtained by adding
adding a level
level of redundancy
system a layer
layer of cluster
cluster software runs
nodes each node
node can monitor
monitored machine fails
storage and restart
restart the applications
machine the users
users and clients
interruption of service
beowulf clusters beowulf
clusters beowulf clusters
clusters are designed
designed for solving
solving high-performance computing
high-performance computing tasks
tasks these clusters
clusters are built
built using comm.odi
ware-such as personal
computers-that are connected
simple local area
local area network
specific software package
set of open-source
open-source software libraries
cluster to communicate
variety of approaches
approaches for constructing
constructing a beowulf
beowulf computing nodes
nodes typically run
run the linux
system since beowulf
beowulf clusters require
require no special
hardware and operate
operate using open
open ~ source
offer a low-cost
strategy for building
building a high
high ~ performance
performance computing cluster
cluster in fact
beowulf clusters built
built from collections
collections of discarded
discarded personal computers
ht.mdreds of cornputing
nodes to solve
solve computationally expensive
computationally expensive problems
problems in scientific
scientific computing clusterin.g
structured or symmetrically
rmming the applications
applications the hot-standby
hot-standby host machine
monitor the active
hosts are rmming
environments such systems
supply significantly greater
significantly greater computational
greater computational power
power than single-processor
capable of running
running an application
consists of dividing
dividing a program
program into separate
components that run
run in parallel
parallel on individual
applications are designed
cluster has solved
solved its portion
nodes are combined
solution other forms
forms of clusters
clusters include parallel
include parallel clusters
clusters and clustering
clusters allow multiple
hosts to access
operating systems lack
systems lack support
support for simultaneous
simultaneous data access
access by multiple
versions of software
software and special
releases of applications
oracle real application
real application cluster
version of oracle
oracle s database
designed to run
cluster each machine
machine runs oracle
layer of software
software tracks access
disk each machine
machine has full
database to provide
provide this shared
access to data
supply access control
control and locking
locking to ensure
conflicting operations occur
occur this function
interconnect interconnect computer
interconnect computer computer
computer computer computer
computer computer figure
clustered system cluster
system cluster technology
technology is changing
rapidly some cluster
cluster products support
products support dozens
dozens of systems
separated by miles
improvements are made
systems to attach
pool of storage
data are stored
software can assign
assign the application
application to run
dozens of hosts
hosts can share
greatly increasing performance
performance and reliability
depicts the general
discussed basic information
information about computer-system
organization and architecture
ready to talk
talk about operating
systems an operating
programs are executed
aspects of operating
ability to multiprogram
multiprogram a single
ith_er thg cpu
thg cpu ortbt
1jusy_c1t all times
frequently have multiple
multiple programs running
programs running il.ul
running il.ul increases
il.ul increases cpu
increases cpu utilization
cpu utilization byorganizing
utilization byorganizing jobs
jobs in memory
generat main memory
small to accommodate
accommodate all jobs
residing on disk
disk awaiting allocation
allocation of main
setofjobs inmemg_ry_canbe asubt
jpoo1 the operating
operating system picks
picks and begins
begins to execute
cpu would sit
system simply switches
cpu is switched
eventually the first
first job finishes
job finishes waiting
idle this idea
idea is common
situations a lawyer
case is waiting
lawyer can work
idle for lack
lack of work
idle lawyers tend
value in keeping
keeping lawyers busy
multiprogrammed systems provide
provide for user
computer system is_
alex_tension of multiprogramming
time-s ! caring
syste ~ s,the
execu ~ eslnl1ltiplejobs
eslnl1ltiplejobs by switcll.ing
canh ~ teract
teract with eachprograffi
ere l.t1sil.mning. -ti1ne
l.t1sil.mning. -ti1ne shar
system the user
user gives instructions
time-shared operating system
users to share
share the computer
action or command
entire computer system
system is dedicated
users a time-shared
operating system 11ses
system 11ses cpu
11ses cpu scheduling
scheduling and multiprogramming
multiprogramming to provide
provide each user
time-shared computer eachuserhas
computer eachuserhas atleast
t_e s parateprogra111inmemory
parateprogra111inmemory a program
memory and executing
device since interactive
i typically runs
runs at people
user s typing
fast for people
slow for computers
cpu sit idle
interactive input takes
input takes place
switch the cpu
user time sharing
sharing and multiprogramming
simultaneously in memory
brought into memory
system must choose
making this decision
discussed in chapter
operating system selects
selects a job
loads that job
job into memory
programs in memory
requires some form
form of memory
covered in chapters
f_s ~ verajjq
running multiple jobscoi
jobscoi ~ cl.lrl
ability to affect
including process scheduling
management these considerations
considerations are discussed
system must ensure
ensure reasonable response
processes are swapped
out of main
method for achieving
achieving this goal
hdiql1 ~ _fuc
cillqws._ the execution
isnot completely inl1le1yl_cld
users to run
larger than actual
abstracts main memory
array of storage
logical as viewed
user from physical
memory this arrangement
arrangement frees programmers
programmers from concern
concern over memory-storage
memory-storage limitations time-sharing
limitations time-sharing systems
provide a file
file system resides
collection of disks
time-sharing systems provide
provide a mechanism
mechanism for protecting
resources from inappropriate
ensure orderly execution
mechanisms for job
ensure that jobs
e11tio11ecl ~ arlier
processes to execute
devices to service
system will sit
sit quietly waiting
is_ a software
software ~ generated
interruptca ~ seci
ler byan error
byzero or invalid
invalid memory acc
acc ~ ss_
performed the interrupt-driven
operating system defines
defines that system
system s general
type of interrupt
segments of code
operating system determine
determine what action
routine is provided
responsible for dealing
share the hardware
running with sharing
process gets stuck
loop could prev.ent
prev.ent the correct
processes more subtle
errors can occur
program might modify
modify another program
sorts of errors
computer must execute
properly designed operating
designed operating system
x.t ; cute
1.5.1 dual-mode operation
operation in order
order to ensure
ensure the proper
execution of operating-system
code and userdefined
code the approach
provide hardware support
modes of execution
jle to distinguishbetween
distinguishbetween a task
operating system aicd
executeci on behalfofthejjser
computer systel.n1s executing
executing on behalf
user application requests
requests a service
transition from user
user to kernel
mode to fulfill
fulfill the request
aspects of system
execute system call
system call figure
kernel mode user
mode user mode
starts in kernel
mode the operating
loaded and starts
starts user applications
applications in user
trap or interrupt
switches from user
mode to kernel
operating system gains
system gains control
mode the system
system always switches
switches to user
setting the mode
program the dual
mode of operation
means for protecting
protecting the operating
system from errant
errant users-and errant
users-and errant users
protection by designating
designating some ofthe
machineine ; tructions
l11 ins trucrci
ctionsto be o11ly
inkern ~ ll11qq_
attempt is made
made to execute
execute a privileged
instruction in user
execute the instruction
illegal and traps
system the instruction
instruction to switch
switch to kernel
include i controt
i controt timer
controt timer management
management and interrupt
additional privileged instructions
cycle of instruction
computer system initial
system initial control
initial control resides
instructions are executed
executed in kernel
mode when control
mode is set
set to user
control is switched
system call _5ysiemcalls
call _5ysiemcalls proyide
proyide the means
means for auser
tasks re_ erved
erved forjhe operating
forjhe operating syst
gr1 the 1.lser
qgra1llsbeha,lf a system
call is invoked
variety of ways
process to request
system a system
call usually takes
takes the form
vector this trap
generic trap instruction
mips r2000 family
specific syscall instruction
instruction when asystep1
bit is set
set to kernel
mode the systemcaflserv1ce
operating system the-kernel
system the-kernel examines
examines the interrupting
instruction to determine
determine what system
call has occurred
type of service
service the user
program is requesting
requesting additional information
additional information needed
quest_may be passed
passed in registers
memory locations passed
parameters are correct
correct and legat
legat executes ti1erequest
call we describe
describe system calls
fully in section
hardware-supported dual mode
system for instance
ms-dos was written
mode a user
user program rum1ing
program rum1ing awry
awry can wipe
out the operating
system by writing
potentially disastrous results
disastrous results recent
results recent versions
cpu do provide
provide dual-mode operation
contemporary operating systemssuch
systemssuch as microsoft
vista and windows
feature and provide
provide greater protection
system once hardware
errors that violate
modes these errors
user program fails
making an attempt
execute an illegal
user s address
space-then the hardware
system the trap
trap transfers control
program error occurs
system must terminate
terminate the program
abnormally this situation
situation is handled
user-requested abnormal termination
dumped the memory
user or programmer
programmer can examine
restart the program
program 1.5.2 timer
1.5.2 timer wer
userp ~ ogram
to_ get stuc
kin e1ninfinite loop
fail to call
call syste1n seryices
we_can usea _a_tirn
_a_tirn ~ r_can
beset to interrupt
af_t ~ ril
counter the operating
operating system sets
sets the counter
counter is decremented
occurs for instance
clock allows interrupts
interrupts at intervals
millisecond before turning
turning over control
operating system ensures
timer is set
set to interrupt
transfers automatically totll.e
epl,_ \ thicfl__
1ytreat the interrupt
clearly,il ~ structions
structions that modify
modify the content
timer are privileged
timer to prevent
prevent a user
program from running
running too long
long a simple
il1.itialize a counter
program is allowed
allowed to run
run a program
7-minute time limit
counter is positive
control is returned
counter becomes negative
operating system terminates
terminates the program
program for exceeding
exceeding the assigned
assigned time limit
limit a program
cpu a program
program in execution
process a time-shared
time-shared user program
process a word-processing
program being run
process a system
provide system calls
processes to create
subprocesses to execute
created or allocated
running in addition
physical and logical
process whose function
display the status
terminal the process
instructions and system
calls to obtain
obtain and display
terminal the desired
system will reclaim
reclaim any reusable
program by itselfis
itselfis nota process
i1terltsof a fil
iskl ~ a.thereasc
a.thereasc \ _pr
entity a si-dgl
eecifying the nexf1il
_ex ~ cljte
threads are covered
covered in chapter
sequential the cpu
executes one instruction
executed on behalf
considered two separate
two separate execution
separate execution sequences
sequences a multithreaded
process has multiple
multiple program counters
instruction to execute
thread a process
collection of processes
ltially execute concurrently
execute concurrently _lly.ij
system is responsible
activities in connection
connection with process
processes and threads
creating and deleting
deleting both user
user and system
system processes suspending
suspending and resuming
resuming processes providing
processes providing mechanisms
process synchronization providing
synchronization providing mechanisms
communication we discuss
discuss process-management techniques
techniques in chapters
memory is central
computer system main
system main memory
words or bytes
ranging in size
size from hundreds
hundreds of thousands
thousands to billions
billions each word
word or byte
address main memory
quickly accessible data
accessible data shared
devices the central
central processor reads
processor reads instructions
reads and writes
data from main
von neumann architecture
generallythe only large
large storage device
address and access
cpu to process
data from disk
data mu.st first
first be transferred
transferred to main
main n lemory
lemory by cpu-generated
cpu-generated i calls
cpu to execute
mapped to absolute
addresses and loaded
accesses program instructions
instructions and data
data from memory
memory by generating
generating these absolute
space is declared
loaded and executed
executed to improve
computer s response
reflect various approaches
situation in selecting
selecting a memory-management
factors-especially the hardware
system each algorithm
support the operating
connection with memory
deciding which processes
data to move
out of memory
allocating and deallocating
deallocating memory space
space as needed
needed memory-management techniques
techniques are discussed
discussed il1 chapters
make the computer
computer system convenient
convenient for users
view of information
storage the operating
operating system abstracts
devices to define
define a logical
logical storage unit
file the operating
operating system maps
system maps files
files onto physical
media and accesses
accesses these files
devices 1.8.1 file-system
1.8.1 file-system management
file-system management pile
management pile management
operating system computers
computers can store
types of physical
physical media magnetic
media magnetic disk
characteristics and physical
organization each medium
medium is controlled
drive or tape
characteristics these properties
properties include access
include access speed
sequential or randmn
collection of related
related information defined
files represent programs
source and object
data data files
operating system implements
implements the abstract
file by managing
managing mass-storage media
tapes and disks
devices that control
organized into directories
directories to make
make them easier
users have access
access to files
desirable to control
accessed the operating
connection with file
deleting files creating
directories to organize
organize files supporting
files supporting primitives
primitives for manipulating
files and directories
directories mapping files
files onto secondary
secondary storage backing
backing up files
files on stable
storage media file-management
media file-management teclmiques
teclmiques are discussed
discussed in chapters
1.8.2 mass-storage management
accommodate all data
holds are lost
lost when power
power is lost
provide secondary storage
storage to back
back up main
memory most modern
modern computer systems
systems use disks
principal on-line storage
on-line storage medium
data most programs-including
disk until loaded
source and destination
system the operating
connection with disk
free-space management storage
management storage allocation
storage allocation disk
allocation disk scheduling
scheduling because secondary
efficiently the entire
speed of operation
computer may hinge
algorithms that manipulate
slower and lower
lower in cost
secondary storage backups
backups of disk
long-term archival storage
examples magnetic drives
drives and platters
platters are typical
devices the media
tapes and optical
crucial to systern
managed some operating
leave tertiary-storage management
management to application
functions that operating
systerns can provide
provide include mounting
mounting and unmounting
rnedia in devices
allocating and freeing
freeing the devices
devices for exclusive
data from secondary
secondary to tertiary
tertiary storage techniques
techniques for secondary
tertiary storage management
management are discussed
principle of computer
computer systems information
faster storage system-the
storage system-the cache-on
cache-on a temporary
piece of information
putting a copy
internal programmable registers
provide a high-speed
cache for main
memory the programmer
implements the register-allocation
register-allocation and register-replacement
algorithms to decide
decide which information
totally in hardware
hardware for instance
cache to hold
hold the instructions
wait several cycles
instruction was fetched
fetched from main
memory for similar
high-speed data caches
system because caches
caches have limited
important design problem
design problem careful
problem careful selection
policy can result
greatly increased performance
increased performance figure
compares storage performance
performance in large
workstations and small
servers various replacement
algorithms for software-controlled
caches are discussed
64gb 100gb implementation
100gb implementation custom
implementation custom memory
memory with on-chip
on-chip or off-chip
off-chip cmos dram
cmos dram magnetic
dram magnetic disk
magnetic disk technology
disk technology multiple
technology multiple ports
cmos cmossram access
80-250 5,000.000 bandwidth
1000-5000 20-150 managed
managed by compiler
compiler hardware operating
hardware operating system
system operating system
operating system backed
backed by cache
cache main memory
main memory disk
levels of storage
cache for secondary
data in secondary
copied into main
moved to secondary
storage for safekeeping
safekeeping the file-system
permanently on secondary
system may maintain
maintain a cache
cache of file-system
data in main
electronic ram disks
interface the bulk
bulk of secondary
disks the magneticdisk
tapes or removable
disks to protect
protect against data
loss in case
failure some systems
systems autoinatically archive
archive old file
storage to tertiary
lower the storage
movement of information
information between levels
explicit or implicit
controlling operating-system software
operating-system software f_o
11 ~ cl_
1suall y ahardvvare
ii.g = sy-s
sy-s tern intervention
intervention in contrast
transfer of data-from
aisk to memory
the-op ~ ra-t
11ier2rrchical storage structure
located in file
file b resides
resides on magnetic
disk the increment
increment operation proceeds
proceeds by first
operation to copy
copy the disk
resides to main
memory this operation
increment takes place
systems the value
poses no difficulties
access to integer
back and -forth-among
-forth-among var1ous processes
processes ~ extreme
processes will obtain
recently updated ___
addition to maintaining
maintaining internal registers
exist simultaneouslyinseyeral caches
migration of integer
disk to register
purposes of a11
a11 operating system
hide the peculiarities
peculiarities ofspecific hardware
devices are hidden
i subsystem consists
component that includes
spooling a general
general device-driver interface
device-driver interface drivers
drivers for specific
specific hardware devices
assigned we discussed
1.2.3 how interrupt
handlers and device
construction of efficient
efficient i subsystems
subsystems in chapter
i subsystem interfaces
detects i completion
system has multiple
execution of multiple
ensure that files
memory-addressing hardware ensures
process can execute
space the timer
process can gain
eventually relinquishing control
relinquishing control device-control
control device-control registers
accessible to users
devices is protected
access of processes
processes or users-to
users-to the resourcesdefined
mechanism rni1st provide
rni1st provide means
imposed and means
means to enforce
enforce the controls
protection can improve
reliability by detecting
detecting latent errors
interfaces between component
subsystems early detection
detection of interface
unauthorized or incompetent
user a protection-oriented
means to distinguish
distinguish between authorized
authorized and unauthorized
terl _ca1lhave adequateprotection
prone to failure
failure and ado_w
priat ~ acs
user whose authentication
means of identifying
stolen her data
copied or deleted
file and memory
protection are working
defend a system
system from external
external and internal
attacks such attacks
range and include
viruses and worms
system s resources
theft of service
attacks is considered
considered an operatingsystem
leave the prevention
prevention to policy
policy or additional
additional software due
rise in security
operating-system security features
security features represent
represent a fast-growing
area of research
research and implementation
security is discussed
require the system
users most maintain
maintain a list
list of user
windows vista parlance
ids are unique
logs in system
authentication stage determines
user that user
user s processes
user name list
distinguish among sets
sets of users
allowed to issue
issue all operations
set of users
allowed to read
read the file
file to accomplish
define a group
group group functionality
list of group
names and ic1entifiers
ic1entifiers a user
depending on operating-system
operating-system design decisions
decisions the user
user s group
process and thread
hov \ tever
gain extra permissions
activity the user
resh ; icted,for
icted,for examp1e.operatmg systems
examp1e.operatmg systems provide
provide various methods
escalation on unix
privileges or terminates
terminates a distributed
networked to provide
provide the users
users with access
system maintains access
increases computation speed
reliability some operating
operating systems generalize
systems generalize network
generalize network access
form of file
details of networking
interface s device
driver others make
users specifically invoke
specifically invoke network
invoke network functions
modes-for example ftp
ftp and nfs
nfs the protocols
protocols that create
create a distributed
affect that system
system s utility
utility and popularity
systems distributed systems
distributed systems depend
depend on networking
functionality networks vary
distances between nodes
transport media tcp
common network protocol
widespread use likewise
support of protocols
varies most operating
systems support tcp
including the windows
unix operating systems
systems support proprietary
support proprietary protocols
protocols to suit
interface device-a network
device-a network adapter
examplewith a device
driver to manage
software to handle
data these concepts
concepts are discussed
networks are characterized
nodes a computers
countries a global
wan to com1ect
com1ect its offices
worldwide these networks
networks may run
run one protocol
protocols the continuing
forms of networks
devices use wireless
technology to commt.micate
home the media
media to carry
varied they include
include copper wires
transmissions between satellites
radios when computing
devices are connected
connected to cellular
create a network
short-range infrared communication
network these networks
networks also vary
concept of networks
networks and distributed
notion of providing
providing network connectivity
includes a communication
computers to exchange
messages a computer
rmming a network
network operating system
computers a distributed
distributed operating system
operating systems comm
systems comm lmicate
provide the illusion
single operating system
controls the network
cover computer networks
systems in chapters
general-purpose computer systems
classes of computer
systems whose functions
deal with limited
limited computation domains
domains 1.11.1 real-time
1.11.1 real-time embedded
real-time embedded systems
embedded systems embedded
systems embedded computers
form of computers
computers in existence
existence these devices
devices are found
engines and manufacturing
robots to dvds
dvds and microwave
ovens they tend
tasks the systencs
systencs they run
operating systems provide
systems provide limited
provide limited features
preferring to spend
monitoring and managing
managing hardware devices
engines and robotic
arms these embedded
embedded systems vary
systems vary considerably
running standard operating
standard operating systems-such
systems-such as unix-with
unix-with special-purpose applications
applications to implement
implement the functionality
special-purpose embedded operating
embedded operating system
operating system providing
devices with application-specific
application-specific integrated circuits
circuits that perform
perform their tasks
embedded systems continues
continues to expand
expand the power
elements of networks
computer-either a general-purpose
embedded system-can control
system-can control heating
heating and lighting
coffee makers web
makers web access
access can enable
enable a home
house to heat
arrives home someday
refrigerator may call
call the grocery
notices the milk
run a real-time
rigid time requirements
flow of data
dedicated application sensors
application sensors bring
sensors bring data
computer the computer
computer must analyze
analyze the data
possibly adjust controls
controls to modify
modify the sensor
sensor inputs systems
systems that control
control scientific experiments
medical imaging systems
industrial control systems
systems some automobile-engine
automobile-engine fuel-injection systems
systems a real-time
system has well-defined
fixed time constraints
system will fail
fail for instance
instructed to halt
building a real-time
real-time system functions
returns the correct
contrast this system
cover real-time embedded
systems in great
detail in chapter
scheduling facility needed
needed to implement
implement real-time functionality
system in chapter
describe the design
management for real-time
describe the real-time
windows xp operating
system 1.11.2 multimedia
1.11.2 multimedia systems
systems most operating
designed to handle
handle conventional data
trend in technology
incorporation of multimedia
data into computer
computer systems multimedia
systems multimedia data
multimedia data consist
consist of audio
audio and video
files these data
differ from conventional
data-such as frames
frames of video-must
video-must be delivered
describes a wide
range of applications
applications in popular
popular use today
today these include
include audio files
short video clips
clips of movie
previews or news
news stories downloaded
internet multimedia applications
include live webcasts
world wide web
speeches or sporting
viewer in manhattan
manhattan to observe
cafe in paris
paris multimedia applications
audio or video
application often includes
includes a combination
movie may consist
consist of separate
applications be delivered
desktop personal computers
directed toward smaller
pdas and cellular
stock quotes delivered
pda in chapter
explore the demands
demands of multimedia
describe how multimedia
multimedia data differ
affects the design
design of operating
systems that support
support the requirements
systems 1.11.3 handheld
1.11.3 handheld systems
handheld systems include
systems include personal
include personal digital
personal digital assistants
palm and pocket-pes
embedded operating systems
operating systems developers
developers of handheld
systems and applications
face many challenges
inches in height
inches in width
devices have small
amounts of memory
small display screens
limitations the amount
amount of physical
gigabytes of memory
system and applications
applications must manage
manage memory efficiently
efficiently this includes
returning all allocated
explore virtual memory
developers to write
programs that behave
devices use virtual
virtual memory techniques
developers must work
confines of limited
limited physical memory
issue of concern
concern to developers
handheld devices run
faster processors require
require more power
power to include
include a faster
device would require
require a larger
frequently most handheld
devices use smaller
processors that consume
consume less power
tax the processor
processor the last
last issue confronting
issue confronting program
confronting program designers
designers for handheld
l a lack
lack of physical
physical space limits
space limits input
limits input methods
methods to small
small screen-based keyboards
keyboards the small
display screens limit
screens limit output
limit output options
computer may measure
inches square familiar
square familiar tasks
e-mail and browsing
browsing web pages
condensed into smaller
displays one approach
approach for displaying
displaying the content
content in web
page is delivered
delivered and displayed
device some handheld
allowing remote access
access to e-mail
e-mail and web
web browsing cellular
browsing cellular telephones
telephones with connectivity
provide wireless access
data typically requires
requires the user
first to download
download the data
pda some pdas
pdas allow data
functionality of pdas
pdas are balanced
convenience and portability
expand as network
cameras and mp3
expand their utility
provided an overview
overview of computer-system
organization and major
major operating-system components
components we conclude
variety of computing
environments 1.12.1 traditional
1.12.1 traditional computing
computing as computing
traditional computing environments
environments are blurring
typical office environment
consisted of pcs
servers providing file
file and print
print services remote
services remote access
access was awkward
portability was achieved
laptop computers terminals
computers terminals attached
attached to mainframes
mainframes were prevalent
fewer remote access
access and portability
options the current
providing more ways
ways to access
access these computing
computing environments web
environments web technologies
technologies are stretching
stretching the boundaries
boundaries of traditional
traditional computing companies
computing companies establish
establish which provide
provide web accessibility
internal servers ccxepu1as
terminals that understand
understand web-based computing
web-based computing handheld
computing handheld computers
computers can synchronize
con1pany information handheld
information handheld pdas
company s web
myriad other web
slow modem connection
giving home users
users more access
data these fast
fast data connections
connections are allowing
allowing home computers
computers to serve
serve up web
networks that include
servers some homes
protect their networks
networks from security
breaches those firewalls
firewalls cost thousands
thousands of dollars
exist a decade
resources were scarce
batch or interactive
interactive batch systems
batch systems processed
systems processed jobs
jobs in bulk
sources of data
interactive systems waited
waited for input
input from users
users to optimize
multiple users shared
systems time-sharing systems
timer and scheduling
rapidly cycle processes
giving each user
user a share
traditional time-sharing systems
systems are uncommon
workstations and servers
frequently the processes
processes that provide
slice of computer
user is working
performing different tasks
1.12.2 client-server computing
computing as pcs
designers have shifted
centralized system architecture
system architecture terminals
architecture terminals connected
connected to centralized
supplanted by pcs
functionality once handled
directly by centralized
increasingly being handled
handled by pcs
satisfy requests generated
form of specialized
specialized distributed system
general structure depicted
depicted in figure
categorized as compute
servers and file
client can send
send a request
request to perform
perform an action
executes the action
action and sends
sends back results
client a server
running a database
database that responds
responds to client
requests for data
interface where clients
clients can create
server that delivers
files to clients
clients running web
running web browsers
browsers 1.12.3 peer-to-peer
1.12.3 peer-to-peer computing
computing another structure
clients and servers
system are considered
requesting or providing
providing a service
service peer-to-peer systems
peer-to-peer systems offer
offer an advantage
advantage over traditional
traditional client-server systems
network to participate
join the network
network of peers
node has joined
joined the network
begin providing services
services to-and requesting
to-and requesting services
services from -other
determining what services
two general ways
joins a network
registers its service
centralized lookup service
network any node
desiring a specific
service first contacts
contacts this centralized
service to determine
determine which node
service the remainder
communication takes place
provider a peer
discover what node
service by broadcasting
broadcasting a request
network the node
providing that service
making the request
request to support
support this approach
peers to discover
discover services provided
network peer-to-peer networks
peer-to-peer networks gained
networks gained widespread
gained widespread popularity
napster and gnutella
peers to exchange
first type described
centralized server maintains
maintains an index
stored on peer
exchanging of files
files takes place
nodes the gnutella
client broadcasts file
broadcasts file requests
service the request
client the future
future of exchanging
exchanging files remains
files remains uncertain
files are copyrighted
governing the distribution
distribution of copyrighted
peerto peer technology
undoubtedly will play
play a role
1.12.4 web-based computing
computing the web
variety of devices
years ago pcs
phones also providing
providing access web
access web computing
computing has increased
increased the emphasis
emphasis on networking
networked now include
wired or wireless
wireless access devices
network connectivity provided
improved networking technology
networking technology optimized
technology optimized network
optimized network implementation
implementation of web-based
distribute network connections
network connections an1.ong
an1.ong a pool
pool of similar
similar servers operating
servers operating systems
systems like windows
acted as web
evolved into linux
linux and windows
act as web
generally the web
web has increased
increased the complexity
complexity of devices
web-enabled the study
number of open-source
compiled binary code
binary code linux
famous open source
open source operating
source operating system
opposite dosedapproach starting
programmer to produce
produce binary code
doing the oppositethe
oppositethe source code
lot of work1
recovered learning operating
learning operating systems
systems by examining
examining the actual
actual source code1
hand a student
student can modify
modify the operating
out those changes1
excellent learning tool
tool this text
text indudes projects
projects that involve
involve modifying operating
modifying operating system
operating system source
important operating system
operating system topics
topics are covered
text1 we provide
pointers to examples
examples of open-source
code for deeper
benefits to open-source
operating systems including
including a commtmity
commtmity of interested
programmers who contribute
code by helping
helping to debug
debug it analyze
analyze it provide
arguably open-source code
secure than closed-source
eyes are viewing
viewing the code
code certainly open-source
open-source advocates argue
argue that bugs
found and fixed
fixed faster owing
number of people
companies that earn
revenue from selling
selling their programs
hesitant to open-source
red hat suse1
companies are doing
showing that commercial
open-source their code
generated through support
sale of hardware
days of modern
deal of software
format the original
mit s tech
tech model railroad
model railroad club
railroad club left
left their programs
programs in drawers
work on homebrew
homebrew user groups
user groups exchanged
groups exchanged code
company-specific user groups
digital equipment corporation
corporation s dec
contributions of source-code
distributed the tapes
tapes to interested
interested ncembers computer
computer and software
companies eventually sought
sought to limit
software to authorized
computers and paying
paying customers releasing
binary files compiled
achieve this goal
protecting their code
competitors another issue
issue involved copyrighted
involved copyrighted material
copyrighted material operating
material operating systems
programs can limit
limit the ability
ability to play
play back movies
movies and music
music or display
display electronic books
books to authorized
code that implemented
implemented these limits
limits were published
including the u.s
u.s digital millennium
digital millennium copyright
millennium copyright act
make it illegal
illegal to reverse-engineer
reverse-engineer drm code
circumvent copy protection
protection to counter
counter the move
move to limit
started the gnu
project to create
create a free
open-source unixcompatible operating
unixcompatible operating system
published the gnu
free and open-sourced
goal of encouraging
encouraging the free
exchange of software
software source code
copyright its software
copylefts the software
software to encourage
sharing and improvement
improvement the gercera
software is released
code be distributed
code be released
license 1.13.2 linux
open-source operating system
gnu project produced
produced many unix-compatible
released a kernel
student in finland
released a rudimentary
rudimentary unix-like kernel
compilers and tools
tools and invited
invited contributions worldwide
worldwide the advent
interested could download
download the source
torvalds releasing updates
allowed this so-called
so-called linux operating
system to grow
programmers the gnu
system has spawned
hundreds of unique
unique or custom
system major distributions
major distributions include
ubuntu distributions vary
vary in function
redhat enterprise lim1x
lim1x is geared
geared to large
commercial use pclinuxos
cd-an operating system
booted and run
system s hard
disk one variant
variant of pclinuxos
pclinuxos supergamer dvd
includes graphics drivers
drivers and games
games a gamer
gamer can run
simply by booting
gamer is finished
installed operating system
operating system access
linux source code
source code varies
varies by release
ubuntu linux ubuntu
popular linux distribution
variety of types
including those tuned
tuned for desktops
students its founder
printing and mailing
mailing of dvds
binary and source
helps to make
make it popular
explore the ubuntu
ubuntu kernel source
kernel source code
code on systems
support the free
free vmware player
vmware player tool
download the player
player from uncompress
uncompress and untar
untar the downloaded
file via tar
linux 2.6.18.1.tar.bz2 explore
explore the source
1.13.3 bsd unix
history than linux
linux it started
derivative of at&t
at&t s unix
university of california
california at berkeley
license from at&t
at&t was required
required bsd unix
unix s development
development was slowed
lawsuit by at&t
distributions of bsd
dragonflybsd to explore
code of freebsd
download the virtual
virtual machine image
version of interest
interest and boot
linux the source
src the kernel
examine the virtual-memory
virtual-memory implementation code
core kernel component
component of mac
based on bsd
darwinsource every mac
open-source components posted
kernel is xnu
xnu the source
code for mac
mac kernel revision
code to mac
found at www.opensource.apple.coml
darwinsource i tar
balls i apsll
apsll xnu-1228 tar.gz
xnu-1228 tar.gz appl
commercial unix-based operating
unix-based operating system
system of sun
system was based
bsd unix sun
unix sun moved
moved to at&t
at&t s system
system v unix
company has added
open-source code base
solaris is open-sourced
owned by at&t
source and linked
linked with binaries
tested the source
projects open-source projects
open-source projects enable
projects enable students
programs and test
find and fix
full-featured operating systems
programs the availability
availability of source
code for historic
students to understand
understand those projects
projects gnu ilinux
purpose sometimes licenses
exclusive and cross-pollination
allowing rapid improvements
improvements in operating-system
components of solaris
ported to bsd
unix the advantages
advantages of free
software and open
increase the number
number and quality
quality of open-source
number of individuals
individuals and companies
projects an operating
manages the cornputer
providing an environment
environment for application
job of executing
main memory main
memory main memory
large storage area
processor can access
size from millions
millions to billions
word in memory
address the main
lost most computer
systems provide secondary
main memory secondary
memory secondary storage
form of nonvolatile
capable of holding
holding large quantities
data the wide
strategies for designing
designing a computer
computer system uniprocessor
system uniprocessor systems
processors that share
share physical memory
memory and peripheral
common multiprocessor design
design is symmetric
processors are considered
peers and run
form of multiprocessor
systems and consist
multiple computer systems
computer systems connected
utilize the cpu
operating systems employ
systems employ multiprogramming
job to execute
execute time-sharing systems
extension of multiprogramming
multiprogramming wherein cpu
cpu scheduling algorithms
algorithms rapidly switch
switch between jobs
providing the illusion
job is nmning
concurrently the operating
ensure correct operation
system to prevent
mode and kernel
mode various instructions
instructions and halt
mode the memory
operating system resides
protected from modification
user a tin1.er
tin1.er prevents infinite
prevents infinite loops
loops these facilities
basic building blocks
systems to achieve
achieve correct operation
operation a process
operating system process
system process management
process management includes
management includes creating
processes and providing
mechanisms for processes
processes to communicate
communicate and synchronize
operating system manages
system manages memory
memory by keeping
freeing memory space
memory space storage
space storage space
includes providing file
providing file systems
systems for representing
directories and managing
space on mass-storage
mass-storage devices operating
devices operating systems
concerned with protecting
protecting and securing
securing the operating
system and users
users protection measures
measures are mechanisms
mechanisms that control
control the access
processes or users
computer system security
system security measures
measures are responsible
responsible for defending
defending a computer
external or internal
internal attacks distributed
attacks distributed systems
systems allow users
geographically dispersed hosts
dispersed hosts connected
computer network services
machines can perform
computations on data
residing on shared
computing can continue
subset of cluster
cluster members fails
members fails lans
lans and wans
two basic types
types of networks
networks lans enable
lans enable processors
enable processors distributed
small geographical area
area to communicate
wans allow processors
typically are faster
faster than wans
systems that serve
serve specific purposes
purposes these include
include real-time operating
operating systems designed
designed for embedded
robotics real-time operating
systems have well-defined
fixed-time constraints processing
fail multimedia systems
multimedia systems involve
involve the delivery
delivery of multimedia
requirements of displaying
displaying or playing
web has encouraged
encouraged the development
development of operating
systems that include
include web browsers
browsers and networking
networking and communication
software as integral
features the free
free software movement
movement has created
thousands of open-source
including operating systems
systems the advantages
traditional personal computers
personal computers describe
describe some usage
give two reasons
reasons why caches
solve vvbat problems
made as large
cache as large
large and eliminate
eliminate the device
dedicated machine-a computer
distinction between kernel
mode and user
user mode function
form of protection
multiprogramming and time-sharing
share the system
simultaneously this situation
situation can result
two such problems
degree of security
dedicated machine explain
explain your answer
describe a mechanism
mechanism for enforcing
enforcing memory protection
protection in order
order to prevent
prevent a program
program from modifying
modifying the memory
inherent in handheld
client-server and peer-to-peer
models of distributed
provide a privileged
operation in hardware
construct a secure
secure operating system
computer systems give
systems give arguments
differences between operating
systems for mainframe
computers and personal
privileged a set
value of timer
timer b read
read the clock
memory d issue
issue a trap
instruction e turn
turn off interrupts
interrupts f modify
entries in device-status
table g switch
switch from user
mode h access
access i device
problem of maintaining
coherence of cached
cached data manifests
systems b multiprocessor
systems c distributed
identify several advantages
disadvantages of open-source
operating systems include
include the types
types of people
find each aspect
two machines belonging
cluster to cooperate
cooperate to provide
highly available service
programmer must overcome
overcome in writing
writing an operating
direct memory access
high-speed i devices
devices in order
order to avoid
increasing the cpu
cpu s execution
device to coordinate
coordinate the transfer
operations are complete
cpu is allowed
allowed to execute
execute other programs
controller is transferring
describe what forms
forms of interference
interference are caused
systems a batch
programming b virtual
modes of operation
define the essential
types of operating
batch b interactive
sharing d real
network f parallel
parallel a distributed
describe the differences
differences between symmetric
disadvantage of multiprocessor
issue of resource
resource utilization shows
operating systems list
list what resources
systems b workstations
connected to servers
servers c handheld
purpose of interrupts
traps be generated
smp system sincilar
residing in memory
two different values
computing cluster consisting
two nodes running
describe two ways
software can manage
discuss the benefits
benefits and disadvantages
overview of computer
science in general
general an overview
system is presented
presented in bovet
bovet and cesati
solomon and russinovich
give an overview
overview of microsoft
windows and considerable
considerable technical detail
technical detail abmrt
abmrt the systern
internals and components
russinovich and solomon
update this information
information to windows
windows xp mcdougall
mcdougall and mauro
cover the internals
solaris operating system
operating system mac
presented at http
apple com mac
internals are discussed
discussed in singh
coverage of peer-to-peer
peer-to-peer systems includes
systems includes parameswaran
discussion of peer-to-peer
peer-to-peer file-sharing systems
found in lee
coverage of cluster
computing is provided
provided by buyya
advances in cluster
computing are described
described by ahmed
survey of issues
relating to operating-system
support for distributed
found in tanenbaum
tanenbaum and van
textbooks cover operating
cover operating systems
describe cmnputer organization
mcdougall and laudon
discuss multicore processors
multicore processors hennessy
hennessy and patterson
systems and buses
architecture in general
blaauw and brooks
introduction to microprocessors
microprocessors and computer
computer architecture cache
architecture cache memories
including associative memory
described and analyzed
analyzed by smith
paper also includes
includes an extensive
discussions concerning magnetic-disk
technology are presented
presented by freedman
disks are covered
covered by kenville
oleary and kitts
olsen and kenley
discussions of floppy
disks are offered
offered by pechura
pechura and schoeffler
discussions concerning mass-storage
technology are offered
offered by chi
kurose and ross
provide general overviews
overviews of computer
computer networks fortier
presents a detailed
discussion of networking
tcp in detail
overview of distributed
discusses recent developments
developments in developing
developing embedded systems
embedded systems issues
systems issues related
related to handheld
found in myers
myers and beigl
dipietro and mancini
history of open
benefits and challenges
challenges is found
found in raymond
history of hacking
hacking is discussed
discussed in levy
free software foundation
foundation has published
published its philosophy
build the ubuntu
ubuntu linux kernel
com the open-source
components of mac
points one view
users and programmers
showin.g the viewpoints
viewpoints of users
services an operating
designing such systems
describe how operating
systems are created
starts its operating
system to describe
describe the services
systems to discuss
ways of structuring
structuring an operating
system to explain
explain how operating
systems are installed
installed and customized
boot an operating
execution of programs
services to programs
programs the specific
specific services provided
identify common classes
classes these operating-system
services are provided
n1.ake the programming
system programs hardware
programs hardware figure
view of operating
operating system services
system services task
services task easier
task easier figure
shows one view
interrelate one set
services provides functions
method for entering
entering and editing
editing of commands
commands and directives
directives to control
control those commands
commands are entered
entered into files
files are executed
device to direct
choose from menus
keyboard to enter
text some systems
variations program execution
execution the system
load a program
program into memory
run that program
program the program
end its execution
operations a running
program may require
involve a file
device for specific
drive or blanking
blanking a display
efficiency and protection
control i devices
i devices directly
i file-system manipulation
manipulation the file
read and write
create and delete
list file information
programs include permissions
include permissions management
files or directories
based on file
ownership many operating
provide a variety
variety of file
provide specific features
features or performance
process such communication
communication ncay occur
occur between processes
computer systems tied
computer network communications
implemented via shared
packets of information
information are moved
moved between processes
operating system error
system error detection
detection the operating
errors may occur
cpu and memory
error on tape
lack of paper
attempt to access
access an illegal
illegal memory location
type of error
action to ensure
correct and consistent
operating systems react
correct errors debugging
errors debugging facilities
enhance the user
programmer s abilities
efficiently another set
operating-system functions exists
helping the user
ensuring the efficient
system itself systems
systems with multiple
users can gain
efficiency by sharing
sharing the computer
users resource allocation
lultiple usersormultiple jobs
usersormultiple jobs rmuung
-types of resources
resources are managed
special allocation code
request and release
code for instance
systems have cpu-scheduling
account the speed
number of registers
routines to allocate
usb storage drives
peripheral devices accounting
to_keeptrack of whichusers
hand what kindsofcomputer
resources this record
simply for accumulating
accumulating usage statistics
usage statistics usage
statistics usage statistics
tool for researchers
reconfigure the system
system to improve
improve computing services
computing services protection
security the owners
owners of information
multiuser or networked
networked computer system
separate processes execute
process to interfere
system itself protection
protection iiwolves ensuring
access to systerr1
resources 1s -controlled
system from outsiders
important such security
starts with requiring
requiring each user
user to authenticate
access to system
resources it extends
extends to defending
external i devices
modems and network
invalid access attempts
connections for detection
detection of break-ins
protected and secure
link we mentioned
ways for users
users to interface
discuss two fundamental
two fundamental approaches
directly enter commands
graphical user interface
gui 2.2.1 command
2.2.1 command interpreter
interpreter some operating
include the command
treat the command
job is initiated
user first logs
multiple command interpreters
interpreters to choose
user may choose
including the bourne
shells and free
free user-written shells
shells provide similar
provide similar functionality
user s choice
based on personal
personal preference figure
shows the bourne
bourne shell command
shell command interpreter
level manipulate files
unix shells operate
code to execute
execute the command
command to delete
delete a file
interpreter to jump
code that sets
parameters and makes
number of comnlands
determines the size
code an alternative
alternative approach -used
-used by unix
operating systems -implements
-implements most commands
commands through system
understand the cmnmand
command to identify
identify a file
memory and executed
file rm file.txt
file.txt would search
load the file
file into memory
parameter file txt
txt the function
programmers can add
add new commands
easily by creating
creating new files
extended device statistics
ogi nell idle
idle 1sj un0718days
1sj un0718days wai
wai t actv
interpreter in solaris
names the command-interpreter
added 2.2.2 graphical
2.2.2 graphical user
graphical user interfaces
strategy for interfacing
userfriendly graphical user
employ a mouse-based
windowand nl.enu system
nl.enu system characterized
metaphor the user
moves the mouse
mouse to position
position its pointer
pointer on images
system functions depending
pointer s location
clicking a button
mouse can invoke
invoke a program
select a file
file or directory-known
commands graphical user
interfaces first appeared
first appeared due
due in part
part to research
research taking place
1970s at xerox
xerox parc research
parc research facility
facility the first
first cui appeared
xerox alto computer
advent of apple
apple macintosh computers
1980s the user
interface that appeared
appeared with mac
microsoft s first
version of windows-version
windows-version 1.0-was based
ms-dos operating system
system later versions
versions of windows
windows have made
including windows explorer
dominated by command-line
interfaces various gul
including the common
common desktop environment
common on commercial
solaris and ibm
ibm s aix
development in gui
kde and gnome
gnome desktops run
run on linux
means their source
modification under specific
specific license terms
terms the choice
command-line or gui
unix users prefer
users prefer command-line
prefer command-line interfaces
provide powerful shell
powerful shell interfaces
interfaces in contrast
users are pleased
windows gui environment
ms-dos shell interface
macintosh operating systems
provide a nice
study in contrast
provided a command-line
requiring its users
release of mac
command-line interface figure
gui the user
interface can vary
vary from system
system to system
user to user
actual system structure
structure the design
friendly user interface
problems of providing
providing adequate service
service to user
distinguish between user
programs and systern
systern programs system
programs system calls
system calls provide
provide an interface
system these calls
tasks where hardware
written using assembly-language
operating system makes
system makes system
makes system calls
illustrate how system
writing a simple
program to read
file and copy
file the first
file these names
design one approach
approach will require
require a sequence
sequence of system
first to write
write a prompting
keyboard the characters
characters that define
files on mouse-based
mouse-based and icon-based
menu of file
window the user
mouse to select
select the source
i system calls
two file names
names are obtained
program must open
open the input
file and create
create the output
requires another system
file is protected
protected against access
program should print
print a message
input file exists
program to abort
delete the existing
calls to output
output the prompting
read the response
replace the existing
abort the program
files are set
enter a loop
loop that reads
write must return
return status information
conditions on input
program may find
operation may encounter
encounter various errors
out of paper
file is copied
program may close
close both files
write a message
console or window
final system call
see1 even simple
programs may make
system frequently systems
frequently systems execute
systems execute thousands
thousands of system
sequence is shown
level of detail
typically applicatiol1 developers
applicatiol1 developers design
developers design program.s
design program.s accordir1g
ajispecifies a set
application programmer including
including the parameters
values the programmer
programmer can expect
api for windows
api for posix-based
virtually all versions
linux and mac
api for designing
programs that run
virtual machine note
machine note that-unless
that-unless specified -the
-the system-call names
text are generic
examples each operating
scenes the functions
functions that make
api typically invoke
invoke the actual
actual system calls
calls on behalf
win32 function createprocess
calls the ntcreateprocess
application programnl.er prefer
programnl.er prefer programming
invoking actual system
reasons for doing
benefit of programming
api concerns program
concerns program portability
application programmer designing
designing a program
api can expect
expect her program
program to compile
compile and run
system that supports
differences often make
detailed and difficult
difficult to work
exists a strong
kernel example system
system call sequence
call sequence acquire
sequence acquire input
acquire input file
file name write
prompt to screen
screen accept input
accept input acquire
input acquire output
acquire output file
accept input open
file if file
abort create output
create output file
abort loop read
read from input
input file write
write to output
file until read
read fails close
fails close output
close output file
output file write
file write completion
write completion message
message to screen
terminate normally figure
win32 api-a function
function for reading
rom a file
file the api
appears in figure
value ~ bool
handle lpvoid dword
lpvoid dword lpdword
dword lpdword lpoverlapped
lpdword lpoverlapped file
bytes to read
parameters bytes read
function a description
passed to readfile
handle file-the file
read lpvoid buffer-a
lpvoid buffer-a buffer
written from dword
dword bytestoread-the number
number of bytes
buffer lpdword bytesread
lpdword bytesread -the
bytesread -the number
last read lpoverlapped
read lpoverlapped ovl-indicates
ovl-indicates if overlapped
apis are similar
native system calls
system calls provided
windows operating systems
systems the run-time
run-time support system
built into libraries
interface that serves
link to system
system calls made
system the system-call
system-call interface intercepts
interface intercepts function
intercepts function calls
api and invokes
system-call interface maintains
maintains a table
nunlbers the system
system call interface
interface then invokes
invokes the intended
intended system call
kernel and returns
returns the status
values the caller
call is implemented
obey the api
api and understand
interface are hidden
run-time support library
library the relationship
user mode kernel
mode kernel mode
mode user application
user application opeo
implementation of open
system call return
call return figure
user application invoking
invoking the open
system call system
system is shown
operating system handles
handles a user
call system calls
system calls occur
depending onthe coj
information is required
simply the identity
desired system call
call the exact
type and ammmt
ammmt of information
system and call
file or device
address and length
device or file
file and length
call three general
system the simplest
pass the param.eters
param.eters in registers
parameters than registers
block is passed
linux and solaris
program and popped
operating syste1ns prefer
prefer the block
block or stack
limit the number
number or length
length of parameters
parameters being passed
passed system calls
coinmuiii ~ a1ioii
2.4.l ~ hi.i
briefly the types
system calls support
concepts and functions
parameters for call
call load address
address x system
register operating system
operating system figure
passing of parameters
summarizes the types
calls normally provided
system 2.4.1 process
2.4.1 process control
control a running
halt its execution
call is made
made to terminate
dump of memory
error message generated
generated the dump
dump is written
written to disk
system program designed
designed to aid
aid the programmer
programmer in finding
finding and correcting
correcting bugs-to determine
normal or abnormal
system must transfer
invoking command mterpreter
mterpreter the command
interpreter then reads
interpreter simply continues
user will issue
command to respond
wmdow might alert
alert the user
interpreter usually terminates
terminates the entire
job and continues
job some systems
systems allow control
special recovery actions
actions in case
case an error
command to manage
manage the execution
discovers an error
define an error
level more severe
higher-level error parameter
normal and abnormal
termination by defining
defining a normal
error at level
level to determine
automatically a process
process or jobexecuting
ll1tto joad andexecut
andexecut ~ anoteer
i11terpreter to execute
execute a program
program as directed
command an interesting
loaded program terminates
terminates this question
question is related
control o end
abort o load
execute o create
set process attributes
attributes o wait
event o allocate
allocate and free
free memory file
memory file management
management o create
file o open
close o read
set file attributes
management o request
device o read
set device attributes
detach devices information
devices information maintenance
set system data
attributes o set
device attributes communications
communications o create
delete communication connection
connection o send
messages o transfer
transfer status information
information o attach
attach or detach
detach remote devices
remote devices figure
program is lost
allowed to continue
program if control
save the memory
created a mechanism
program to call
call another program
job or process
examples of windows
unix system calls
system calls windows
calls windows unix
windows unix process
unix process createprocesso
process createprocesso fork
control exi tprocess
maintenance settimero alarm
mmapo protection setfilesecurity
process or submit
set of jobs
jobs or processes
control its execution
execution this control
requires the ability
ability to determine
determine and reset
reset the attributes
including the job
job s priority
maximum allowable execution
attributes and set
terminate a job
needed having created
created new jobs
finish their execution
event has occurred
processes may share
data to ensure
ensure the integrity
data being shared
systems often provide
system calls allowing
allowing a process
process to lock
lock shared data
preventing another process
process from accessing
accessing the data
typically such system
system calls include
calls include acquire
include acquire lock
lock and release
release lock system
lock system calls
standard c library
library the standard
invokes the printf
intercepts this call
call and invokes
system-in this instance
takes the value
returned by write
include stdio.h int
stdio.h int main
handling of write
coordination of concurrent
discussed in great
variations in process
process and job
two examples-one involving
involving a single-tasking
system -to clarify
clarify these concepts
concepts the ms-dos
computer is started
ms-dos is single-tasking
method to run
process it loads
loads the program
give the program
sets the instruction
program then runs
executes a system
call to terminate
code is saved
overwritten resumes execution
execution its first
reload the rest
rest free memory
free memory command
memory command interpreter
free memory process
memory process command
process command interpreter
running a program
interpreter from disk
command interpreter makes
makes the previous
previous error code
shell otthe user
otthe user s-choiceis
user s-choiceis run
run this shell
shell is similar
commands and executes
interpreter may continue
program is executed
program is loaded
command was issued
process to finish
finish or runs
runs the process
shell immediately requests
requests another command
process is rmming
input directly fron1
fron1 the keyboard
process d free
process c interpreter
freebsd running multiple
running multiple programs
done through files
user is free
shell to run
run other programs
monitor the progress
change that program
program s priority
process is done
executes an exit
process a status
nonzero error code
code this status
status or error
processes are discussed
systemcalls 2.4.2 file
2.4.2 file management
management the file
system is discussed
detail in chapters
identify several common
common system calls
system calls dealing
dealing with files
files either system
system call requires
file s attributes
file is created
rewinding or skipping
close the file
sets of operations
operations for directories
structure for organizing
determine the values
file attributes include
include the file
two system calls
attribute and set
set file attribute
function some operating
calls for file
move and copy
provide an api
api that performs
performs those operations
operations using code
provide system programs
programs to perform
perform those tasks
programs are callable
considered an api
programs 2.4.3 device
2.4.3 device management
management a process
resources to execute-main
wait until sufficient
devices are physical
abstract or virtual
system with multiple
users may require
request the device
functions are similar
open and close
close system calls
calls for files
files other operating
systems allow llnmanaged
access to devices
devices the hazard
potential for device
described in chapter
reposition the device
files in fact
devices and files
combined file-device structure
set of system
files and devices
devices are identified
identified by special
special file names
attributes the user
underlying system calls
calls are dissimilar
building an operating
system and user
interface 2.4.4 information
2.4.4 information maintenance
maintenance many system
system calls exist
purpose of transferring
call to return
return the current
date other system
calls may return
number of current
amount of free
memory or disk
calls is helpful
helpful in debugging
debugging a program
program many systems
systems provide system
calls to dump
memory this provision
program trace lists
lists each system
executed even microprocessors
provide a cpu
trap is executed
instruction the trap
debugger many operating
location or set
set of locations
tii ! _ee
te1 -ls recorded
sufficiently frequent timer
frequent timer interrupts
obtained in addition
system keeps information
access this information
reset the process
discuss what information
ji1_ _m od_e_l
model ! nth
pa,s ~ ij1gl
rrtll12injfa_fii ~ gpr
lailg ~ ill-es
mailbox before communication
network each computer
hostidand get processid
processid system calls
translation the identifiers
close calls provided
specific open connection
connection and close
close connection system
connection system calls
system s model
model of communication
communication the recipient
permission for comnmnication
accept connection call
call most processes
connections are special-purpose
systems programs provided
purpose they execute
execute a wait
wait for connection
connection is rna
message and write
write message system
message system calls
calls the close
close connection call
connection call terminates
terminates the communication
shared-me_1llorytllodel,proc ~ sses
memorycreate and shared
shared memory attach
memory attach system
attach system calls
calls to create
create 2rt1d gain
2rt1d gain access
gain access toi
access toi egions
egions ot n1emory
prevei1foiie process-from accessing
accessing another process
process s memory
memory shared memory
shared memory requires
agree to remove
remove this restriction
information by reading
reading and writing
areas the form
data is determined
system s control
control the processes
responsible for ensuring
sirnultaneously such mechanisms
mechanisms are discussed
scheme-threads-in which memory
memory is shared
shared by default
models just discussed
discussed are common
common in operating
implement both message
exchanging smaller amounts
amounts of data
easier to implement
memory for intercomputer
intercomputer communication shared
communication shared memory
memory allows maximum
speed and convenience
convenience of communication
done at memory
memory transfer speeds
computer problems exist
areas of protection
protection and synchronization
processes sharing memory
memory 2.4.6 protection
2.4.6 protection protection
multiprogrammed computer systems
advent of networking
servers to pdas
concerned with protection
system calls providing
calls providing protection
providing protection include
protection include set
include set permission
manipulate the permission
settings of resources
files and disks
user and deny
deny user system
user system calls
can-or can not-be
not-be allowed access
protection in chapter
issue of security
security in chapter
collection of system
system programs recall
programs recall figure
depicted the logical
logical computer hierarchy
level is hardware
finally the application
application programs system
programs system programs
provide a convenient
simply user interfaces
interfaces to system
considerably more complex
management these programs
generally ncanipulate files
directories status information
information some programs
number of users
similar status information
providing detailed performance
format and print
print the output
devices or files
files or display
gui some systems
systems also support
store and retrieve
retrieve configuration information
configuration information file
information file modification
modification several text
create and modify
content of files
stored on disk
commands to search
contents of files
files or perform
text programming-language support
programming-language support compilers
interpreters for common
common programming languages
operating system program
system program loading
loading and execution
program is assembled
assembled or compiled
executed the system
system may provide
provide absolute loaders
overlay loaders debugging
loaders debugging systems
languages or machine
language are needed
communications these programs
provide the mechanism
mechanism for creating
creating virtual comcections
comcections among processes
users to send
browse web pages
send electronic-mail messages
addition to systems
systems are supplied
supplied with programs
solving common problems
problems or performing
performing common operations
operations such application
ogr ! lj1ls
plott1i1g ana s-tafistica
___ tne viewoclne
tne viewoclne opei
opei ; ating-sysrerri-seen
users is defined
application and system
actual systern calls
user s computer
computer is rumcing
rumcing the mac
featuring a mouse-and-windows
command-line unix shell
ways further confusing
confusing the user
dual-booting from mac
sets of applications
exposed to multiple
multiple user interfaces
sequentially or concurrently
problems we face
face in designing
designing and implementing
implementing an operating
successful 2.6.1 design
2.6.1 design goals
goals the first
problem in designing
designing a system
goals and specifications
choice of hardware
type of system
highest design level
two basic groups
goals and system
system goals users
goals users desire
desire certain obvious
system the system
easy to learn
set of requirements
operate the system
easy to design
requirements are vague
problem of defining
defining the requirements
system the wide
range of systems
systems in existence
requirements can result
variety of solutions
requirements for vxworks
realtime operating system
system for embedded
multiaccess operating system
system for ibm
designing an operating
highly creative task
field of software
mechanisms and policies
separation of policy
policy from mechanisiil
mechanisiil ~ echa
hcnu ! q_c
-sonl ~ tl-til1g
zul1dt wilcbe done
-forensill1ng cpu protection
deciding how long
long the timer
122l ! cl_tig
fp.qli_cy_an_ci ~ t1_echanism
t1_echanism is imp
rtant for flexibility
change across places
over time rri
rri tlle worst
tlle worst case
change in policy
policy would require
require a change
mechanism a general
general mechanism insensitive
desirable a change
mechanism for giving
separated from policy
support a policy
priority over cpu-intensive
support the opposite
opposite policy microkernel
microkernel = based
based operati1lg sy_sh
separation of mechai
1sinai ~ cfp
hcyto one extreme
byimplementing a basicset
bfocks these blocks
allowing more advanced
-1necharnsms and policies
added via user-created
user-created kernel modules
history of unix
unix at first
version of solaris
scheduling is controlled
controlled by loadable
loadable tables depending
table currently loaded
making the scheduling
scheduling mechanism general
mechanism general purpose
purpose allows vast
single load-new-table command
command at th_
ti_ ! l_t
fe_el all applications
applications have similar
kernel and system
libraries the mac
system has similar
similar functionality policy
functionality policy decisions
decisions are important
allocate a resource
determined 2.6.3 implementation
written in higher-level
master control program
burroughs computers mcp
mcp was written
variant of algol
developed at mit
pl the linux
systems are written
code for device
saving and restoring
restoring the state
state of registers
registers the advantages
implementing operating systems
easier to understand
understand and debug
debug in addition
improvements in compiler
technology will improve
improve the generated
entire operating system
system by simple
easier to port-to
written in intel
intel x86 family
family of cpus
x86 instruction set
system to run
use-on other cpus
cpus are programs
programs that duplicate
duplicate the functionality
including intel x86
disadvantages of implementing
language are reduced
speed and increased
increased storage requirements
longer a major
issue in today
today s systems
expert assembly-language programmer
programmer can produce
produce efficient small
efficient small routines
programs a modern
compiler can perform
perform complex analysis
apply sophisticated optimizations
optimizations that produce
produce excellent code
excellent code modern
code modern processors
processors have deep
pipelining and n1.ultiple
n1.ultiple functional units
handle the details
details of complex
major performance improvements
improvements in operating
structures and algorithms
excellent assembly-language code
code in addition
systems are large
code is critical
critical to high
system is written
replaced with assembly-language
equivalents a system
system as large
easily a common
partition the task
task into small
briefly in chapter
components are interconnected
interconnected and melded
kernel 2.7.1 simple
2.7.1 simple structure
structure many commercial
commercial operating systen1.s
started as small
original scope ms-dos
designed and implemented
written to provide
divided into modules
modules carefully figure
shows its structure
structure in ms-dos
interfaces and levels
levels of functionality
wellseparated for rnstai1.ce
appii.cat1on programs aie
access the basic
outiri.es to write
display and disk
drives such freedom
freedom leaves ms-dos
leaves ms-dos vulnerable
vulnerable to errant
causing entire system
entire system crashes
crashes when user
user programs fail
designers of ms-dos
leave the base
base hardware accessible
original unix operating
unix operating systein
initially was limited
limited by hard
hard ware ft1il.cfionali.ty
ai1d the system
rom bios device
bios device drivers
device drivers figure
ms-dos layer structure
series of interfaces
interfaces and device
added and expanded
years as unix
unix has evolved
view the traditional
traditional unix operating
unix operating system
_fil ~ syste
fm1ctions through system
thatl.sai1 enormous an1ol.lnt
an1ol.lnt of functionality
level this monolithic
structure was difficult
difficult to implement
implement and maintain
maintain 2.7.2 layered
2.7.2 layered approach
layered approach withproper
shells and commands
compilers and interpreters
interpreters system libraries
system libraries signals
libraries signals terminal
signals terminal handling
terminal handling character
system terminal drivers
drivers file system
file system swapping
system swapping block
disk and tape
tape drivers cpu
drivers cpu scheduling
cpu scheduling page
scheduling page replacement
page replacement demand
replacement demand paging
demand paging virtual
paging virtual memory
virtual memory figure
traditional unix system
unix system structure
layered operating system
retain much greater
applications that make
freedom in changing
creating modular operating
modular operating systems
functionality and features
features are determined
separated into components
components information hiding
leaves programmers free
free to implement
implement the low-level
routine stays unchanged
routine itself performs
performs the advertised
task a system
ways qne method
system is broken
1sfhe user interface
interface this layering
structure is depicted
abstract object made
manipulate those data
data a typical
typical operating-system layer-say
layer m -consists
-consists of data
set of routines
invoked by higher-level
higher-level layers layer
operations on lower-level
layers the main
approach is simplicity
simplicity of construction
construction and debugging
debugging the layers
layers are selected
layers this approach
approach simplifies debugging
debugging and .system
verification the first
implement its functions
layer is debugged
error is found
system are simplified
layer is implemented
provided by lowerlevel
layers a layer
operations are implemented
hides the existence
hardware from higher-level
layers the major
layered approach involves
involves appropriately defining
memory management requires
store other requirements
obvious the backing-store
cpu scheduler m.ay
fit in memory
requiring the backu1.g-store
backu1.g-store driver routine
scheduler a final
problem with layered
types for instance
user program executes
calls the memory-management
calls the cpu-scheduling
layer adds overhead
call that takes
system these limitations
limitations have caused
caused a small
backlash against layering
layering in recent
recent years fewer
years fewer layers
functionality are beu1.g
advantages of modularized
code while avoidu1.g
avoidu1.g the difficult
problems of layer
definition and interaction
interaction 2.7.3 microkernels
kernel became large
large and difficult
difficult to manage
researchers at carnegie
carnegie mellon university
mellon university developed
developed an operatu1.g
system called mach
mach that modularized
modularized the kernel
i.b ~ ._gl
operatingsystem by removing
removing all nonessential
nonessential cornponentsfrom thekemel
1mp ~ e_l
the.reslin is-a smarrei
services should remain
implemented in user
microkernels provide minimal
provide minimal process
process and memory
facility the main
provide a communication
rum1.ing in user
user space communication
communication is provided
provided by message
client program wishes
wishes to access
access a file
server the client
program and service
service never interact
interact directly rathel
indirectly by exchanging
approach is ease
ease of extending
extending the operating
services are added
added to user
kernel the resulting
resulting operating system
system is easier
easier to port
security and reliability
services are running
running as user-rather
user-rather than kernel-processes
operating system remains
system remains untouched
untouched several contemporary
contemporary operating systems
microkernel approach tru64
approach tru64 unix
kernel the mach
mach kernel maps
kernel maps unix
maps unix system
calls into messages
services the mac
mach micro kernel
real-time operating system
system the qnx
nl.icrokernel provides services
services for message
passing and process
handles low-level network
low-level network communication
communication and hardware
services in qnx
qnx are provided
provided by standard
processes that run
kernel in user
microkernels can suffer
suffer from performance
performance decreases due
due to increased
increased system function
system function overhead
history of windows
layered microkernel organization
version delivered low
delivered low performance
low performance compared
redressed the performance
problem by moving
layers from user
space to kernel
space and integrating
monolithic than microkernel
microkernel 2.7.4 modules
methodology for operating-system
operating-system design involves
involves using object-oriented
object-oriented programming techniques
techniques to create
create a modular
set of core
components and links
links in additional
dynamically loadable modules
common in modern
implementations of unix
operating system structure
armmd a core
types of loadable
loadable kernel modules
classes file systems
file systems loadable
systems loadable system
loadable system calls
system calls executable
calls executable formats
executable formats streams
formats streams modules
streams modules miscellaneous
modules miscellaneous device
device and bus
kernel to provide
provide core services
file systems figure
solaris loadable modules
loadable modules loadable
modules loadable system
added as loadable
resembles a layered
section has defined
module can call
functions and knowledge
load and communicate
invoke message passing
passing in order
order to communicate
communicate the apple
microkernel the structure
structure of mac
top layers include
layers include application
include application environments
set of services
providing a graphical
interface to applications
bsd kernel mach
mach provides memory
management ; support
support for remote
remote procedure calls
including message passing
scheduling the bsd
bsd command line
command line interface
support for networking
networking and file
including pthreads kernel
pthreads kernel environment
kernel environment application
environment application environments
environments and common
common services figure
addition to mach
mach and bsd
kit for development
development of device
applications and comn
services can make
mach or bsd
bsd facilities directly
directly the layered
layered approach described
abstract the hardware
network interface cards
creating the illusion
separate execution environment
environment is run.ning
system can create
create the illusion
memory the virtual
underlying bare hardware
hardware each process
process is provided
fact an operating
single physical machine
machine can run
run multiple operating
multiple operating systems
machine 2.8.1 history
2.8.1 history virtual
history virtual machines
machines first appeared
commercially on ibm
processes processes processes
processes processes kernel
processes kernel kernel
kernel kernel kernel
kernel kernel vm1
kernel vm1 vm2
vm1 vm2 vm3
vm2 vm3 virtual-machine
vm3 virtual-machine implementation
concepts are found
making this facility
facility worth exploring
worth exploring ibm
exploring ibm vm370
ibm vm370 divided
divided a mainframe
mainframe into nmltiple
nmltiple virtual machines
system a ncajor
virtualmachine approach involved
approach involved disk
involved disk systems
disk systems suppose
drives but wanted
wanted to support
support seven virtual
allocate a disk
software itself needed
needed substantial disk
substantial disk space
space to provide
provide virtual memory
memory and spooling
spooling the solution
provide virtual disks-termed
virtual disks-termed minidislcs
minidislcs in ibm
-that are identical
respects except size
size the system
implemented each minidisk
minidisk by allocating
machines were created
users could run
systems or software
ibm vm system
user normally ran
ran cms-a single-user
cms-a single-user interactive
single-user interactive operating
interactive operating system
system 2.8.2 benefits
reasons for creating
creating a virtual
hardware yet run
concurrently one important
system is protected
machines are protected
inside a guest
guest operating system
system might damage
damage that operating
affect the host
sharing of resources
resources two approaches
approaches to provide
share a file-system
define a network
network of virtual
virtual communications network
network the network
network is modeled
modeled after physical
physical communication networks
implemented in software
software a virtual-machine
vehicle for operating-systems
research and development
changing an operating
difficult task operating
task operating systems
part the power
system makes changing
operating system executes
executes in kernel
destroy the entire
entire file system
operating system carefully
carefully the operating
controls the entire
tlle current system
made and tested
tested this period
comnconly called systemdevelopment
makes the system
unavailable to users
late at night
load is low
system can eliminate
problem system programmers
development is done
physical machine normal
machine normal system
normal system operation
system operation seldom
disrupted for system
development another advantage
advantage of virtual
machines for developers
developer s workstation
concurrently this virtualized
porting and testing
testing of programs
programs in varying
varying enviromnents sinlilarly
engineers can test
test their applications
applications in multiple
environments without buying
maintaining a computer
environment a major
machines in production
system which involves
systems and running
system such physical-to-virtual
physical-to-virtual conversions result
result in resource
lightly used systems
combined to create
heavily used system
virtual machines continues
continues to spread
deployment will evolve
move a virtual
developers would pre-install
pre-install the application
tuned and customized
customized operating system
machine that virtual
application this method
improvement for application
developers ; application
tuning would required
straightforward system administrators
administrators would find
find the environment
easier to manage
redeploying the application
steps of uninstalling
uninstalling and reinstalling
reinstalling for widespread
methodology to occur
format of virtual
machine will run
platform the open
open virtual machine
virtual machine format
succeed in unifying
unifying virtual-machine formats
formats 2.8.3 simulation
2.8.3 simulation system
simulation system virtualization
virtualization as discussed
system-emulation methodologies virtualization
makes guest operating
guest operating systems
running on native
speed another methodology
system was compiled
suppose a company
company has replaced
replaced its outdated
outdated computer system
continue to run
run certain important
system the programs
e1nulator that translates
system s instructions
native instruction set
emulation can increase
increase the life
life of programs
explore old architectures
actual old machine
challenge is performance
performance instruction-set emulation
emulation can run
run an order
order of magnitude
slower than native
machine is ten
ten times faster
hardware another challenge
difficult to create
create a correct
writing an entire
cpu in software
software 2.8.4 para-virtualization
trick a guest
system into believing
presents the guest
guest s preferred
system the guest
modified to run
hardware the gain
smaller virtualization layer
virtualization layer solaris
create a virtual
kernel is installed
devices are virtualized
address and ports
systemwide processes figure
shows a solaris
standard global user
global user space
user space user
space user programs
user programs system
system programs cpu
programs cpu resources
cpu resources memory
resources memory resources
memory resources global
resources global zone
global zone user
zone user programs
system programs network
programs network addresses
network addresses device
addresses device access
device access cpu
access cpu resources
cpu resources user
resources user programs
memory resources memory
memory resources zone
virtual platform device
platform device management
device management figure
concept is usefut
implement much work
work is required
required to provide
provide an exact
underlying machine remember
mode the virtual-machine
software can run
run in kernel
system the virtual
virtual user mode
virtual kernel mode
physical user mode
mode those actions
transfer from user
attempt to execute
transfer from virtual
mode to virtual
machine in virtual
virtual-machine monitor gains
monitor gains controt
change the register
contents and program
machine to simulate
simulate the effect
restart the virtual
mode the major
machines in unpredictable
simulate all instructions
instructions to provide
provide a true
true virtual machine
works for ibm
machines because normal
machines can execute
execute more slowly
level of hardware
performing the virtual
major generalpurpose cpus
generalpurpose cpus provide
provide some amount
amount of hardware
support for virtualization
amd virtualization technology
technology is found
processors it defines
two new modes
modes of operation-host
operation-host and guest
guest virtual machine
virtual machine software
software can enable
enable host mode
define the characteristics
switch the system
system to guest
machine in guest
virtualized operating system
operating system thinks
rum1.ing on native
hardware and sees
sees certain devices
host s definition
access a virtualized
control is passed
host to manage
manage that interaction
interaction 2.8.6 examples
advantages of virtual
received little attention
number of years
first developed today
machines are coming
coming into fashion
means of solving
solving system compatibility
system compatibility problems
explore two popular
two popular contemporary
popular contemporary virtual
contemporary virtual machines
run on top
top of operating
design types discussed
types discussed earlier
operating system design
system design methods-simple
design methods-simple layers
exclusive 2.8.6.1 vmware
virtualization techniques discussed
section require virtualization
kernel another method
method involves writing
writing the virtualization
tool to run
run in user
application on top
operating system virtual
system virtual machines
virtual machines running
ing on bare
fact are running
inside a user-level
popular commercial application
application that abstracts
abstracts intel x86
x86 and compatible
hardware into isolated
isolated virtual machines
virtual machines vmware
machines vmware workstation
vmware workstation runs
host operating system
windows or linux
systems as independent
independent virtual machines
machines the architecture
linux is running
ing as guest
systems the virtualization
heart of vmware
abstracts the physical
running as guest
systems each virtual
disk the guest
owns and manages
system to create
create an identical
identical guest instance
copy the file
copying the file
protects the guest
original site moving
moving the file
application application application
application application guest
application guest operating
guest operating guest
operating guest operating
operating system system
system system system
virtual cpu virtual
cpu virtual cpu
cpu virtual memory
virtual memory virtual
memory virtual memory
memory virtual devices
virtual devices virtual
devices virtual devices
virtual devices virtualization
devices virtualization layer
virtualization layer hardware
hardware i qpu
moves the guest
system these scenarios
show how virtualization
virtualization can improve
improve the efficiency
efficiency of system
2.8.6.2 the java
virtual machine java
popular object-oriented programming
object-oriented programming language
programming language introduced
introduced by sun
large api library
java virtual machine-or
virtual machine-or jvm
machine-or jvm java
jvm java objects
java program consists
produces an architecture-neutral
architecture-neutral bytecode output
jvm the jvm
computer it consists
interpreter that executes
executes the architecture-neutral
diagrammed in figure
class loader loads
loads the compiled
api for execution
class is loaded
file is valid
valid java bytecode
overflow or underflow
underflow the stack
perform pointer arithmetic
provide illegal memory
illegal memory access
class passes verification
interpreter the jvm
automatically manages memory
memory by performing
performing garbage collection
garbage collection -the
collection -the practice
practice of reclaiming
memory from objects
objects no longer
system much research
focuses on garbage
garbage collection algorithms
algorithms for increasing
increasing the performance
performance of java
machine the jvm
software on top
implemented in hardware
chip specifically designed
jvm is implemented
java interpreter interprets
interprets the bytecode
faster software technique
method is invoked
method are turned
turned into native
native machine language
system these operations
method are performed
native machine instructions
potentially even faster
jvm in hardware
java program .class
program .class files
java i interpreter
interpreter t host
framework the .net
collection of technologies
including a set
set of class
provide a platform
platform for developing
software this platform
platform allows programs
written to target
target the .net
architecture a program
worry aboutthe specifics
architecture implementing .net
execute the program
execution environment abstracts
abstracts these details
common language runtime
.net virtual machine
virtual machine itprovides
itprovides an environment
environment for execution
.net framework programs
framework programs written
written in languages
vb.net are compiled
language called microsoft
microsoft intermediate language
include ms-il instructions
instructions and metadata
.exe or .dll
.dll upon execution
clr loads assemblies
domain as instructions
instructions are requested
converts the ms-il
ms-il instructions inside
inside the assemblies
assemblies into native
architecture using just-in-time
compilation once instructions
converted to native
run as native
cpu the architecture
framework is shown
ms-il assembly vb.net
assembly vb.net source
vb.net source ms-il
source ms-il assembly
ms-il assembly host
assembly host system
host system figure
special java chip
chip that executes
executes the java
java bytecode operations
operations as native
activity of finding
finding and fixing
system debugging seeks
seeks to find
software performance problems
problems are considered
include which seeks
seeks to improve
performance by removing
processing taking place
system a discussion
discussion of hardware
explore debugging kernel
kernel and process
errors and performance
problems 2.9.1 failure
2.9.1 failure analysis
operating systems write
write the error
alert system operators
operators or users
occurred the operating
days of computing
process this core
image is stored
analysis running programs
programs and core
programmer to explore
explore the code
code and memory
memory a process
process debugging user-level
debugging user-level process
user-level process code
challenge operating system
operating system kernel
system kernel debugging
size and complexity
lack of user-level
user-level debugging tools
tools a kernel
information is saved
state is saved
operating system debugging
tools and techniques
techniques than process
process debugging due
code would make
make it risky
save its state
system before rebooting
rebooting a common
save the kernel
kernel s memory
section of disk
detects an unrecoverable
writes the entire
contents of memory
gather the data
area and write
crash dump file
system for analysis
analysis 2.9.2 performance
2.9.2 performance tuning
tuning to identify
monitor system performance
system performance code
added to compute
compute and display
measures of system
number of systems
task by producing
producing trace listings
listings of system
behavior all interesting
events are logged
program can process
process the log
file to determine
determine system performance
bottlenecks and inefficiencies
run as input
suggested improved system
improved system traces
people to find
errors in operating-system
kernighan s law
hard as writing
writing the code
write the code
approach to performance
include interactive tools
users and administrators
administrators to question
question the state
bottlenecks the unix
unix command top
command top displays
top displays resources
top resource-using processes
processes other tools
display the state
state of disk
traffic the authors
analyzing a system
provide that information
information making running
making running operating
running operating systems
operating systems easier
area of operating
operating system research
implementation the cycle
cycle of enabling
tracing as system
system problems occur
occur and analyzing
analyzing the traces
generation of kernel-enabled
kernel-enabled performance analysis
performance analysis tools
sections of code
written to emit
emit debugging data
data the solaris
dtrace dynamic tracing
dynamic tracing facility
tool 2.9.3 dtrace
dynamically adds probes
i11 user processes
kernel these probes
language to determine
determine an astonishing
shows the functional
execute to perform
perform the system
system call lines
call lines ending
executed in user
kernel mode debugging
debugging the interactions
interactions between user-level
user-level and kernel
toolset that understands
understands both sets
sets of code
instrument the interactions
debug any area
written with debugging
debugging in mind
affecting system reliability
reliability this tool
dtrace tool meets
meets these requirements
low-impact debugging environncent
framework and tools
shrouded in mystery
mystery and accomplished
accomplished via happenstance
happenstance and archaic
code and tools
debugger to examine
examine the state
system then execution
execution can continue
breakpoint or termination
termination this method
multiuser operating-system kernel
samples the instruction
pointer to determine
determine which code
show statistical trends
individual activities code
kernel to emit
emit specific data
data under specific
xclock  xeventsqueued
probes cpu function
releasef ioctl ioctl
ioctl ioctl xeventsqueued
ioctl xeventsqueued xeventsqueued
problem being debugged
debugged is occurring
occurring in contrast
runs on production
important or critical
system it slows
activities while enabled
execution it resets
resets the system
broad and deep
debug everything happening
user and kernel
deeply into code
showing individual cpu
individual cpu instructions
instructions or kernel
kernel subroutine activities
activities is composed
probes dtrace providers
dtrace providers create
providers create probes
create probes kernel
probes kernel structures
kernel structures exist
providers have created
created the probes
probes are stored
hash table data
table data structure
unique probe identifiers
probe is enabled
bit of code
probed is rewritten
rewritten to call
code s original
operation different providers
create different kinds
kinds of probes
kernel system-call probe
system-call probe works
probe dtrace features
features a compiler
compiler that generates
generates a byte
kernel this code
code is assured
loops are allowed
specific kernel state
kernel state modifications
modifications are allowed
requested only users
retrieve private kernel
private kernel data
data if requested
generated code runs
kernel and enables
consumers in user
mode and enables
consumer is code
results a consumer
performed when probes
fire one probe
ecbs to execute
consumer is interested
probe each ecb
out that ecb
list of actions
ecb is executed
capture some bit
bit of data
variable s value
execution by gathering
gathering such data
user or kernel
kernel can show
user-level action caused
action caused kernel-level
caused kernel-level reactions
reactions such data
data are invaluable
invaluable for performance
monitoril1.g and code
probe consumer tennil1.ates
ecbs are removed
consuming a probe
probe is removed
removed that involves
rewriting the code
code to remove
remove the dtrace_probe
call and put
back the original
probe is created
probing occurred dtrace
occurred dtrace takes
dtrace takes care
care to assure
assure that probes
memory or cpu
harm the running
system the buffers
hold the probe
results are monitored
monitored for exceeding
default and maximum
maximum limits cpu
execution is monitored
limits are exceeded
consumer is terminated
offending probes buffers
buffers are allocated
allocated per cpu
cpu to avoid
contention and data
shows the dtrace
code to enable
enable scheduler probes
probes and record
record the amount
amount of cpu
running with user
probes are enabled
self ts timestamp
showing the processes
dtrace -s sched.d
sched.d  matched
probes ac grwme-settings-d
grwme-settings-d gnome-vfs-daemon dsdm
gnome-vfs-daemon dsdm wnck-applet
dsdm wnck-applet gnome-panel
wnck-applet gnome-panel clock-applet
gnome-panel clock-applet mapping-daemon
clock-applet mapping-daemon xscreensaver
mapping-daemon xscreensaver meta
xscreensaver meta city
meta city xorg
city xorg gnome-terminal
xorg gnome-terminal mixer
gnome-terminal mixer applet2
mixer applet2 java
code because dtrace
dtrace is part
conflicting license agreements
added to mac
spread further due
capabilities other operating
adding kernel-tracing functionality
systems are beginning
beginning to include
performance and tracing
tracing tools fostered
fostered by research
including the paradyn
implement an operating
class of machines
variety of sites
variety of peripheral
configurations the system
configured or generated
specific computer site
distributed on disk
cd-rom or dvd-rom
dvd-rom to generate
generate a system
program this sysgen
sysgen program reads
asks the operator
system for information
probes the hardware
directly to determine
determine what components
kinds of information
extended instruction sets
installed for multiple
multiple cpu systems
disk be formatted
systems will determine
determine this value
referencing memory location
location after memory
illegal address fault
fault is generated
generated this procedure
defines the final
final legal address
memory what devices
address each device
device interrupt number
device s type
type and model
special device characteristics
options are desired
options or values
values might include
type of cpu-scheduling
algorithm is desired
number of processes
information is determined
modify a copy
completely compiled data
compiled data declarations
produce an output-object
slightly less tailored
description can lead
creation of tables
selection of modules
library these modules
modules are linked
form the generated
generated operating system
operating system selection
supported i devices
needed are linked
generation is faster
construct a system
completely table driven
occurs at execution
compile or lil1.k
lil1.k time system
system generation involves
involves simply creating
tables to describe
describe the system
system the major
size and generality
ease of modifying
cost of modifying
modifying the system
system to support
newly acquired graphics
acquired graphics termil1.al
disk drive balanced
system is generated
load that kernel
kernel the procedure
procedure of starting
starting a computer
computer by loading
loading the kernel
booting the system
piece of code
program or bootstrap
bootstrap loader locates
locates the kernel
starts its execution
execution some computer
simple bootstrap loader
bootstrap loader fetches
complex boot program
program from disk
loads the kernel
receives a reset
reset event-for instance
rebooted -the instruction
-the instruction register
register is loaded
predefined memory location
initial bootstrap program
program this program
form of read-only
state at system
rom is convenient
easily be infected
virus the bootstrap
program can perform
perform a variety
variety of tasks
diagnostics to determine
determine the state
program can continue
initialize all aspects
contents of main
main memory sooner
starts the operating
system some systems-such
systems-such as cellular
consoles-store the entire
system in rom
storing the operating
rom is suitable
suitable for small
small operating systems
simple supporting hardware
operation a problem
changing the bootstrap
bootstrap code requires
code requires changing
changing the rom
rom hardware chips
chips some systems
resolve this problem
writable all forms
forms of rom
software a problem
problem with firmware
firmware in general
slower thart executing
thart executing code
code in ram
ram some systems
store the operating
system in firmware
firmware and copy
ram for fast
execution a final
issue with firmware
large operating systems
including most general-purpose
general-purpose operating systems
systems that change
loader is stored
stored in firmware
bootstrap nms diagnostics
read a single
disk into memory
memory and execute
execute the code
ock the program
load the entire
system into memory
memory and begin
begin its execution
single disk block
address on disk
disk and length
open-source bootstrap program
program for linux
changed by writing
writing new versions
versions to disk
disk a disk
disk or system
bootsh ap program
traverse the file
system to find
find the operating
start its execution
provide a number
number of services
program to make
operating system directly
interpreter or shell
user to issue
issue a request
request without writing
writing a program
files during batch-mode
interactive or time-shared
time-shared mode system
mode system programs
programs are provided
provided to satisfy
satisfy many common
common u.ser requests
requests the types
types of requests
requests vary accord
ilcg to level
level the system-call
level must provide
provide the basic
control and file
file and device
device manipulation higher-level
manipulation higher-level requests
interpreter or system
system calls system
calls system services
program controt status
controt status requests
i requests program
requests program errors
considered implicit requests
requests for service
services are defined
developed various tables
tables are needed
needed to record
record the information
information that defines
defines the state
system s jobs
jobs the design
begins the type
foundation for choices
iilce an operating
modularity is important
sequence of layers
microkernel is considered
considered a good
technique the virtual-machine
virtual-machine concept takes
takes the layered
approach and treats
loaded on top
entire operating-system design
operating-system design cycle
careful to separate
separate policy decisions
decisions from implementation
separation allows maximum
flexibility if policy
changed later operating
language this feature
improves their implementation
portability to create
create an operating
perform system generation
system generation debugging
generation debugging process
process and kernel
tools that analyze
analyze core dumps
core dumps tools
dtrace analyze production
analyze production systems
systems to fucd
bottlenecks and understand
understand other system
system to begin
cpu must initialize
initialize and start
executing the bootstrap
program in firmware
firmware the bootstrap
bootstrap can execute
execute the operating
complete a sequence
loads progressively smarter
progressively smarter programs
programs from firmware
firmware and disk
system with regard
regard to file
regard to memory
executing java programs
services and functions
two main categories
categories briefly describe
categories and discuss
separation of mechanism
mechanism and policy
user to develop
system-call interface provided
difficult to achieve
achieve a layered
system are dependent
identify a scenario
layer two system
two system components
components that require
require tight coupling
approach to system
system like vmware
vmware what factors
considered in choosing
choosing the host
describe three general
methods for passing
programs and system
system services interact
disadvantages of usil1.g
usil1.g the microkernel
shell in order
order to start
models of interprocess
strengths and weaknesses
experimental synthesis operating
synthesis operating system
kernel to optimize
optimize system-call performance
kernel assembles routines
routines within kernel
space to minimize
minimize the path
kernel this approach
kernel is extended
extended to make
buildu1.g the operating
operating system easier
system easier discuss
discuss the pros
pros and cons
approach to kernel
design and system-performance
modular kernel approach
kernel approach similar
system be designed
choice of operating
advantages and disadvantages
interface for manipulating
manipulating both files
obtain a statistical
executing different sections
discuss the importance
importance of obtaining
described a program
program that copies
copies the contents
file this program
prompting the user
source and destilcation
destilcation files write
write this program
source file exists
designed and tested
tested the program
run the program
utility that traces
traces system calls
system calls linux
calls linux systems
linux systems provide
provide the ptrace
truss or dtrace
command on mac
facility provides similar
functionality as windows
provide such features
study the system-call
system and learn
learn how user
user programs communicate
interface your task
kernet thereby expanding
expanding the functionality
operating system part
started a user-mode
user-mode procedure call
call is performed
performed by passing
saving the current
procedure the process
calls to user
programs but result
i11 a change
change in execution
context and privileges
privileges in linux
call is accomplished
accomplished by storing
storing the system-call
executing a trap
ox80 assembly instruction
table of code
pointers to obtain
obtain the starting
handler code implementing
implementing the system
call the process
process then juxnps
process are switched
switched from user
execute kernel code
include privileged instructions
mode the kernel
out the requested
perform process management
performed in user
system call numbers
numbers for recent
kernel are listed
listed in lusr
system call close
invoked for closin.g
closin.g a file
defined as value
list of pointers
pointers to system-call
notice that sys_close
sys_close is stored
stored at entry
system-call number defined
unistd h file
keyword .long denotes
entry will occupy
value of type
kernel before adding
task of building
building the binary
code and booting
booting the machine
newly built kernel
kernel this activity
obtain the kernel
source code package
lusr i srcllinux
kernel version number
install the kernel
commands for building
building the kernel
entering the directory
code is stored
xconfig o make
dep o make
make bzimage add
set of boatable
boatable kernels supported
system the linux
typically uses utilities
lilo and grub
grub to maintain
list ofbootable kernels
user can choose
choose during machine
system supports lilo
add an entry
entry to lilo
label = mykernel
read-only where lbootlbzimage
lbootlbzimage my kernel
kernel this step
kernel or booting
booting the unmodified
ftmction properly part
extending the kernel
experiment with adding
set of source
compiling the kernel
lusr i srcllinux-2
srcllinux-2 xlkernel directory
location may differ
options for adding
adding the system
call the first
add the system
existing source file
directory and modify
srcllinux-2 xlkernelimakef ile
ile to include
newly created file
process the advantage
modify an existing
building and booting
booting linux kernels
begin the process
process of adding
back to user
helloworld system call
illustrates the system-call
mechanism and sheds
interaction between user
file called helloworld
define your system
system call include
include the header
header files linuxllinkage
linuxlkernel h add
linuxllinkage.h # include
include linuxlkernel.h asmlinkage
linuxlkernel.h asmlinkage int
asmlinkage int sysjhelloworld
kern_emerg hello world
creates a system
choose to add
add this system
add the sys_hellowor
file you choose
days when linux
code is written
kernel log file
kernel the kernel
parameter to printk
call is defined
system call number
number to identify
newly added system
added system call
increment the value
file this constant
tracks the number
number of system
calls currently defuced
entry .long sys_helloworld
sys_calltable definedinthe file
file as discussed
table to find
find the position
invoked system call
system call add
add your file
save a copy
kernel binary image
newly created kernel
kernet and add
loader configuration files
completing these steps
system call part
newly defined system
defined system call
invoke this system
supports an interface
interface for system
system calls defined
invoking your system
call will require
require manual intervention
intervention as noted
invoked by storing
register and performing
performing a trap
require assembly instructions
linux provides macros
macros for instantiating
instantiating wrapper functions
instructions for instance
macro to invoke
include linux _syscallo
_syscallo macro takes
takes two arguments
arguments the first
specifies the type
identify the systemcall
instruction is executed
call requires arguments
number of arguments
instantiate the assembly
assembly code required
required for performing
performing the system
system call compile
compile and execute
message hello world
call has executed
pass an integer
illto the kernel
implications of passing
pointers to data
program s address
space as opposed
passing an integer
kernel using hardware
hardware registers dijkstra
advocated the layered
approach to operating-system
proponent of constructing
constructing an operating
built system instrumentation
instrumentation and dynamic
tracing are described
described in tamches
tamches and miller
dtrace is discussed
discussed in cantrill
dtrace source code
described in microsoft
described by solomon
windows xp internals
internals are described
described in russinovich
covers windows system
system $ programming
programming in detail
detail bsd unix
unix is described
described in mckusick
discuss the linux
unix systems-including mach-are
systems-including mach-are treated
treated in detail
detail in vahalia
lwww apple comlmacosx
described in mcdougall
first operating system
provide a virtual
commercially available ibm
ibm vmi370 operating
vmi370 operating system
system was derived
details regarding mach
microkernel-based operating system
found in young
details regarding exokernel
exokernel operating systems
architecture separates management
separates management issues
issues from protection
giving untrusted software
software the ability
ability to exercise
control over hardware
resources the specifications
machine are presented
presented by gosling
lindholm and yellin
described by ven11ers
cover several issues
design of java
java operating systems
systems more information
information on java
web at part
two a process
execution a process
resources-such as cpu
devices -to accomplish
accomplish its task
task these resources
resources are allocated
executing a process
systems systems consist
operating-system processes execute
processes execute system
user processes execute
processes execute user
processes may execute
traditionally a process
thread of control
modem operating systems
systems now support
threads the operating
creation and deletion
scheduling of processes
provision of mechanisms
mechanisms for synchronization
handling for processes
chapter early computer
early computer systems
computer systems allowed
program had complete
resources in contrast
current-day computer systems
systems allow multiple
concurrently this evolution
evolution required firmer
required firmer control
modern time-sharing system
complex the operating
system therefore consists
operatingsystem processes executing
processes executing system
executing system code
code and user
user processes executing
processes executing user
executing user code
processes can execute
switching the cpu
cpu between processes
system can make
computer more productive
work to introduce
introduce the notion
process a program
forms the basis
computation to describe
features of processes
creation and termination
communication to describe
communication in client-server
systems a question
question that arises
arises in discussing
discussing operating systems
operating systems involves
activities,_f \ _qcij
hj3ystem ~ xeq_l_
xeq_l_ ~ _lqq.s_
_2l_ ! _i_
run several programs
internal programmed activities
activities are similar
processes _the ten
prefer the term
theory and terminology
terminology was developed
activity of operating
systems was job
misleading to avoid
commonly accepted terms
terms that include
include the word
simply because process
process has superseded
3.1.1 the process
includes the current
processor s registers
registers a process
generally also includes
includes the process
variables a process
include a heap
thatis dynamically allocated
allocated during process
process in memory
memory is shown
list of instructions
resources a program
file is loaded
memory two common
two common techniques
techniques for loading
loading executable files
files are double-clicking
double-clicking an icon
representing the executable
file and entering
event completion figure
diagram of process
sequences for instance
running different copies
user may invoke
invoke many copies
web browser program
sections are equivalent
stack sections vary
process that spawns
spawns many processes
runs we discuss
discuss such matters
matters in section
3.1.2 process state
state the state
process is defil1.ed
defil1.ed in part
process each process
created running instructions
waiting the process
process is waiting
completion or reception
ready the process
terminated the process
process has finished
execution these names
names are arbitrary
vary across operating
systems the states
represent are found
finely delineate process
delineate process states
important to realize
instant many processes
ready and waiting
states is presented
presented in figure
3.1.3 process control
process control block
pjnthe operatir1,g system
process_ coptrol blo_ck
-alsocalled a taskcontrozbloclc
taskcontrozbloclc a pcb
pcb is shown
pieces of iil.format1o11assodated
counter the counter
process cpu registers
registers the registers
vary in number
number and type
architecture they mclude
information this information
includes a process
pointers to scheduling
describes process scheduling
information may include
include such information
base and limit
information this mformation
includes the amount
cpu and real
i status information
includes the list
i devices allocated
list of open
briet the pcb
pcb simply serves
vary from process
process to process
process 3.1.4 threads
threads the process
process model discussed
program that performs
performs a single
thread of execution
process is running
running a word-processor
thread of instructions
executed this single
process to perform
process p0 idle
operating system interrupt
interrupt or system
system call process
process p1 executing
executing idle figure
diagram showing cpu
showing cpu switch
switch from process
type in characters
characters and run
run the spell
modern operatin.g systems
systems have extended
extended the process
threads of execution
pcb is expanded
needed to support
support threads chapter
explores multithreaded processes
processes in detail
detail the objective
objective of multiprogramming
maximize cpu utilization
utilization the objective
cpu among processes
frequently that users
users can interact
run.ning to meet
meet these objectives
process scheduler selects
cpu is free
rescheduled 3.2.1 scheduling
3.2.1 scheduling queues
queues as processes
enter the system
system the processes
residing in main
waiting to execute
representation in linux
linux the process
system is represented
task_struct this structure
information for representing
representing a process
including the state
scheduling and memory-management
process s parent
process that created
process i unsigned
unsigned int time_slice
time_slice i scheduling
information i struct
struct task_struct parent
parent i struct
struct list__head children
process s children
children i struct
struct files_struct files
files i struct
field long state
processes are represented
doubly linked list
list of task_struct
maintains a pointer
-to the process
process currently executing
struct task_struct process
task_struct process information
process information struct
information struct task_struct
information t current
processes in linux
linux struct task_struct
kernel might manipulate
assume the system
change the state
process currently running
new_state if currentis
currentis a pointer
state is changed
state = new_state
list a ready-queue
header contains pointers
first and final
list each pcb
includes a pointer
field that points
queue header mag
header mag tape
queues the system
system also includes
includes other queues
process is allocated
allocated the cpu
suppose the process
process the process
disk the list
list of processes
queue each device
representation of process
rectangular box represents
represents a queue
queue two types
types of queues
queues are present
set of device
queues the circles
represent the resources
resources that serve
serve the queues
flow of processes
queue it waits
selected for execution
events could occur
process could issue
queue the process
process could create
subprocess and wait
subprocess s termination
termination the process
first two cases
process eventually switches
queue a process
continues this cycle
pcb and resources
deallocated 3.2.2 schedulers
schedulers a process
lifetime the operating
system must select
fashion the selection
process is carried
processes are submitted
immediately these processes
processes are spooled
typically a disk
execution the long-term
pool and loads
execution the short-term
ready to execute
execute and allocates
allocates the cpu
two schedulers lies
lies in frequency
frequency of execution
scheduler must select
frequently a process
process may execute
milliseconds before waiting
short-term scheduler executes
milliseconds to decide
decide to execute
execute a process
simply for scheduling
scheduling the work
work the long-term
long-term scheduler executes
freqvently ; minutes
minutes may separate
separate the creation
long-term scheduler controls
controls the degree
degree of multiprogramming
multiprogramming is stable
rate of process
average departure rate
rate of processes
leaving the system
leaves the system
interval between executions
scheduler can afford
decide which process
long-term scheduler make
make a careful
selection in general
bound or cpu
spends doing computations
computations a cpu-bound
generates i requests
long-term scheduler select
select a good
good process mix
i waiting queue
unbalanced the system
combination of cpu-bound
absent or minimal
unix and microsoft
microsoft windows systems
scheduler the stability
nature of human
users if performance
quit some operating
introduce an additional
level of scheduling
scheduling this medium-term
scheduler is diagrammed
advantageous to remove
processes from memory
reduce the degree
degree of multiprogramrning
reintroduced into memory
swapping the process
process is swapped
medium-term scheduler swapping
improve the process
change in memory
requirements has overcommitted
overcommitted available memory
freed up swapping
swapping is discussed
swap out figure
addition of medium-term
3.2.3 context switch
switch as mentioned
mentioned in section
change a cpu
run a kernel
routine such operations
frequently on general-purpose
restore that context
processing is done
suspending the process
context is represented
includes the value
kernel or user
resu.me operations switching
process requires performing
performing a state
process this task
context switch occurs
saves the context
pcb and loads
loads the saved
scheduled to run
work while switching
switching its speed
varies from machine
machine to machine
existence of special
instruction to load
store all registers
milliseconds context-switch times
dependent on hardware
support for instance
provide multiple sets
sets of registers
registers a context
simply requires changing
changing the pointer
current register set
resorts to copying
copying register data
advanced memory-management techniques
techniques may require
require extra data
context for instance
task is prepared
space is preserved
amount of work
work is needed
needed to preserve
systems can execute
created and deleted
systems must provide
mechanism for process
explore the n1.echanisms
involved in creating
processes and illustrate
illustrate process creation
creation on unix
systems 3.3.1 process
3.3.1 process creation
creation a process
process may create
create-process system call
execution the creating
create other processes
forming a tree
tree of processes
processes most operating
unique process identifier
typically an integer
integer number figure
illustrates a typical
typical process tree
pid in solaris
sched process creates
creates several children
pageout and fsflush
fsflush these processes
processes are responsible
responsible for managing
memory and file
systems the sched
process also creates
creates the ini
ini t process
root parent process
processes in figure
children of ini
t-inetd and dtlogin
inetd is responsible
responsible for networking
telnet and ftp
ftp ; dtlogin
representing a user
user login screen
creates an x-windows
creates the sdt_shel
process below sdlshel
user s command-line
command-line shell-the c-shell
c-shell or csh-is
invoke various child
process with pid
system using telnet
telnet this user
user has started
started the netscape
obtain a listing
listing of processes
command ps -el
-el will list
list complete information
processes currently active
easy to construct
construct a process
process tree similar
recursively tracing parent
tracing parent processes
process in general
creates a subprocess
typical solaris system
obtain its resources
process the parent
partition its resources
share some resources
ncemory or files
restricting a child
parent s resources
prevents any process
process from overloading
overloading the system
system by creating
subprocesses in addition
display the contents
img.jpg-on the screen
open the file
write the contents
device some operating
operating systems pass
systems pass resources
resources to child
two open files
transfer the datum
two possibilities exist
exist in terms
terms of execution
continues to execute
children the parent
children have terminated
possibilities in terms
program and data
illustrate these differences
system in unix
process is identified
process is created
process this mechanism
process to communicate
process both processes
child is returned
processes to replace
replace the process
program the exec
system call loads
loads a binary
destroying the memory
ways the parent
create more children
call to move
illustrates the unix
calls previously described
two different processes
processes running copies
value of pid
sysltypes.h # include
stdio.h # include
include unistd.h int
unistd.h int main
fork a child
process i pid
pid = fork
occurred i fprintf
process i execlp
parent will wait
child to complete
complete i wait
creating a separate
integer value greater
child process inherits
process inherits privileges
privileges and scheduling
files the child
process then overlays
overlays its address
process to complete
child process completes
explicitly invoking exit
parent process resumes
call to wait
,where it completes
illustrated in figure
parent wait resumes
wait resumes child
creation using fork
include windows.h int
windows.h int main
allocate memory zeromemory
create child process
command line null
nt inherit process
inherit process handle
nt inherit thread
inherit thread handle
thread handle false
disable handle inheritance
creation flags null
parent s environment
environment block null
parent s existing
create process failed
close handles closehandle
creation in windows
processes are created
similar to fork
child process howeverf
howeverf whereas fork
child process inheriting
inheriting the address
process at process
process creation furthermoref
furthermoref whereas fork
passed no parametersf
expects no fewer
illustrates the createprocess
functionf which creates
creates a child
process that loads
loads the application
ten parameters passed
passed to createprocess
interested in pursuing
pursuing the details
details of process
api are encouraged
encouraged to consult
consult the bibliographical
chapter two parameters
two parameters passed
startupinfo and process_information
process_information structures startupinfo
structures startupinfo specifies
specifies many properties
size and appearance
appearance and handles
handles to standard
files the process_information
newly created process
thread we invoke
invoke the zeromemory
function to allocate
structures before proceeding
proceeding with createprocess
first two parameters
command-line parameter specifies
specifies the application
application to load
loading the microsoft
microsoft windows mspaint.exe
windows mspaint.exe application
two initial parameters
parameters for inheriting
existing environment block
block and starting
starting directory last
provide two pointers
startupinfo and process.lnformation
process.lnformation structures created
program in figure
parent process waits
complete by invoking
invoking the wait
call the equivalent
win32 is wai
wai tforsingleobj ect
passed a handle
child process-pi hprocess-and
process-pi hprocess-and waits
child process exits
process 3.3.2 process
3.3.2 process termination
termination a process
executing its final
statement and asks
asks the operating
system to delete
process may return
return a status
physical and virtual
i buffers-are deallocated
operating system termination
termination can occur
process is passed
parent a parent
parent may terminate
terminate the execution
variety of reasons
child has exceeded
exceeded its usage
mechanism to inspect
inspect the state
required the parent
parent is exiting
child to continue
child to exist
parent has terminated
terminated this phenomenon
system to illustrate
illustrate process execution
execution and termination
terminate a process
process may wait
call the wait
system call returns
returns the process
children has terminated
children have assigned
parent the ini
parent to collect
collect their status
status and execution
execution statistics processes
statistics processes executing
processes or cooperating
processes a process
process is independent
system any process
independent a process
process is cooperating
process that shares
reasons for providing
information computation speedup
task to run
executing in parallel
multiple processing elements
construct the system
dividing the system
functions into separate
processes or threads
user may work
compiling in parallel
parallel cooperating processes
cooperating processes require
require an interprocess
data and information
two fundamental models
region of memory
shared by cooperating
processes is established
place by means
means of messages
process a process
two communications models
models are conh
asted in figure
exchanging smaller ammmts
ammmts of data
avoided message passing
memory is faster
faster than message
implemented using system
task of kernel
irttervention in contrast
calls are required
establish shared-memory regions
regions once shared
memory is established
accesses are treated
treated as routine
routine memory accesses
kernel is required
detail 3.4.1 shared-memory
3.4.1 shared-memory systems
shared-memory systems interprocess
systems interprocess communication
communication using shared
memory requires communicating
requires communicating processes
processes to establish
establish a region
region of shared
shared-memory region resides
creating the sharedmemory
segment other processes
segment must attach
address space recall
prevent one process
location are determined
illustrate the concept
concept of cooperating
paradigm for cooperating
processes a producer
producer process produces
process produces information
compiler may produce
produce assembly code
assembler the assembler
ncay produce object
produce object modules
loader the producer-consumer
web server produces
files and images
client web browser
web browser requesting
requesting the resource
resource one solution
problem uses shared
producer and consumer
processes to run
buffer of items
producer and emptied
consumer this buffer
buffer will reside
producer can produce
produce one item
consumer is consuming
consuming another item
item the producer
consume an item
produced two types
types of buffers
places no practical
buffer the consumer
produce new items
items the assumes
assumes a fixed
fixed buffer size
consumer must wait
buffer is empty
producer must wait
buffer is full
processes to share
item ; item
buffer is implemented
two logical pointers
out the variable
variable in points
first full position
buffer the buffer
out the code
processes is shown
shown in figures
local variable nextproduced
produced is stored
stored the consumer
variable next consumed
consumed is stored
stored this scheme
provide a solution
solution where buffer_size
illustrate the posix
api for shared
produce an item
item in nextproduced
buffer_size ; figure
3.14 the producer
issue this illustration
concerns the situation
consumer process attempt
access the shared
shared buffer concurrently
concurrently in chapter
discuss how synchronization
synchronization among cooperating
environment 3.4.2 message-passing
3.4.2 message-passing systems
message-passing systems lrt
systems lrt section
showed how cooperating
processes can communicate
environment the scheme
share a region
code for accessing
accessing and manipulating
manipulating the shared
memory be written
provide the means
means for cooperating
processes to comm
message-passing facility message
facility message passing
synchronize their actions
actions without sharing
processes may reside
chat participants communicate
messages a message-passing
fixed or variable
implementation is straightforward
straightforward this restriction
makes the task
task item nextconsumed
nextconsumed = buffer
consume the item
item in nextconsumed
nextconsumed i figure
programming more difficult
variable-sized messages require
require a 1nore
1nore complex system-level
complex system-level implementation
task becomes simpler
kind of tradeoff
design if processes
link must exist
link s physical
implementing a link
direct or indirect
indirect communication synchronous
synchronous or asynchronous
asynchronous communication automatic
automatic or explicit
3.4.2.1 naming processes
communication under direct
recipient or sender
primitives are defined
-send a message
message to process
process p receive
-receive a message
message from process
link is established
pair of processes
communicate the processes
identity to communicate
communicate a link
link this scheme
scheme exhibits symmetry
symmetry in addressing
communicate a variant
scheme employs asymmetry
asymmetry in addressing
names the recipient
place the disadvantage
resulting process definitions
process definitions changing
changing the identifier
process may necessitate
definitions all references
identifier in general
desirable than techniques
techniques involving indirection
received from mailboxes
ports a mailbox
removed each mailbox
value to identify
identify a mailbox
process can communicate
mailboxes two processes
message to mailbox
mailbox a receive
message from mailbox
mailbox a link
pair of communicating
mailbox now suppose
suppose that processes
mailbox a process
process p1 sends
sends a message
execute a receive
process will receive
receive the message
methods we choose
system to select
arbitrarily which process
define an algorithm
algorithm for selecting
selecting which process
processes take turns
turns receiving messages
system may identify
identify the receiver
sender a mailbox
mailbox is owned
mailbox is part
process should receive
receive a message
process that owns
owns a mailbox
disappears any process
mailbox no longer
exists in contrast
process the operating
send and receive
delete a mailbox
mailbox the process
process that creates
mailbox s owner
owner by default
ownership and receiving
provision could result
result in multiple
mailbox 3.4.2.2 synchronization
3.4.2.2 synchronization communication
communication between processes
processes takes place
place through calls
calls to send
options for implementing
implementing each primitive
primitive message passing
synchronous and asynchronous
asynchronous blocking send
send the sending
process is blocked
message is received
mailbox nonblocking send
sending process sends
sends the message
message and resumes
resumes operation blocking
operation blocking receive
receive the receiver
null different combinations
combinations of send
receiver the solution
problem becomes trivial
statements the producer
producer merely invokes
invokes the blocking
call and waits
message is delivered
consumer invokes receive
concepts of synchronous
frequently in operating-system
operating-system i algorithms
text 3.4.2.3 buffering
buffering whether communication
communication is direct
exchanged by communicating
communicating processes reside
capacity the queue
sender must block
receives the message
message bounded capacity
messages can reside
message is copied
sender can continue
waiting the link
link s capacity
capacity is finite
link is full
block until space
quelie unbounded capacity
queue s length
number of messages
messages can wait
sender never blocks
blocks the zero-capacity
cases are referred
systems with automatic
cover the posix
discuss message passing
mach operating system
system we conclude
conclude with windows
interestingly uses shared
mechanism for providing
providing certain types
types of message
posix shared memory
memory several ipc
including shared memory
memory and message
explore the posix
create a shared
shared memory segment
derived from shared
segment_id = shmget
s_lrusr i s_lwusr
first parameter specifies
specifies the key
set to ipcprivate
segment is created
specifies the size
identifies the mode
mode to s_lrusr
owner may read
read or write
segment a successful
call to shmget
returns an integer
access a shared-memory
call the call
call to shmat
expects three parameters
segment being attached
location in memory
pass a value
value of null
selects the location
user s behalf
identifies a flag
attached in read-only
read-only or read-write
passing a parameter
region we attach
attach a region
memory using shmat
returns a pointer
ncemory is attached
process s address
process can access
routine memory access
returned from shmat
writing to shared
sharing this segment
existing shared-memory segment
segment first attaches
attaches the shared-memory
process no longer
longer requires access
segment it detaches
detaches the segment
space to detach
detach a region
process can pass
pass the pointer
passed the identifier
ipcrmid the program
illustrates the posix
posix shared-memory api
api just discussed
discussed this program
creates a 4,096-byte
4,096-byte shared-memory segment
memory is attached
writes the message
memory after outputting
outputting the contents
detaches and removes
removes the shared-memory
region we provide
provide further exercises
message-based operating system
developed at carnegie
university we introduced
mach in chapter
system the mach
mach kernel supports
supports the creation
creation and destruction
destruction of multiple
similar to processes
threads of control
control most communication
communication in mach-including
intertask informationis carried
out by messages
ports in mach
mach even system
calls are made
made by messages
task is created
tailboxes-the kernel mailbox
mailbox-are also created
created the kernel
kernel to communicate
task the kernel
kernel sends notification
notification of event
calls are needed
needed for message
transfer the msg_send
mailbox a message
received via msg_recei
executed via msg_rpc
message and waits
models a typical
typical subroutine procedure
subroutine procedure call
work between systems-hence
systems-hence the term
remote the porlallocate
system call creates
mailbox and allocates
queue of messages
messages the maximum
queue # include
syslshm.h # include
include syslstat.h int
syslstat.h int main
segment i int
segment i char
segment i canst
canst int size
allocate a shared
s_irusr i s_iwusr
attach the shared
segment i shared_memory
segment i sprint
out the string
string from shared
memory i printf
detach the shared
segment i shmdt
remove the shared
segment i shmctl
illustrating posix shared-memory
shared-memory api defaults
messages the task
task that creates
creates the mailbox
owner the owner
allowed to receive
tasks if desired
desired the mailbox
mailbox s message
empty as messages
messages are copied
mailbox all messages
priority mach guarantees
guarantees that multiple
sender are queued
queued in first-in
guarantee an absolute
ordering for instance
order the messages
messages themselves consist
variable-length data portion
portion the header
indudes two mailbox
two mailbox names
names one mailbox
sending thread expects
expects a reply
sender is passed
address the variable
list of typed
typed data items
items each entry
value the type
message is important
system-such as ownership
ownership or receive
receive access rights
messages the send
flexible for instance
sending thread continues
mailbox is full
cache a message
message one message
thread the final
option is meant
meant for server
driver after finishing
finishing a request
send a one-time
client is full
full the receive
mailbox or mailbox
received a mailbox
collection of mailboxes
task can receive
task has receive
access a porlstatus
returns the number
mailbox the receive
receive operation attempts
attempts to receive
message is waiting
designed for distributed
discuss in chapters
suitable for singleprocessor
problem with message
generally been poor
poor performance caused
caused by double
copying of messages
receiver the mach
mach message system
message system attempts
attempts to avoid
avoid double-copy operations
maps the address
sender s message
receiver s address
space the message
copied this message-management
large performance boost
boost but works
messages the mach
extra chapter posted
design that employs
modularity to increase
functionality and decrease
implement new features
support for multiple
application programs communicate
mechanism the application
windows xp subsystem
server the message-passing
facility in windows
facility the lpc
lpc in windows
windows xp communicates
standard rpc mechanism
specific to windows
object to establish
establish and maintain
maintain a connection
processes every client
client that calls
calls a subsystem
types of ports
ports and communication
ports are named
set up communication
opens a handle
connection port object
object the client
sends a cmmection
request the server
creates two private
two private conimunication
private conimunication ports
ports and returns
returns the handle
client the client
client and server
handle to send
messages or callbacks
listen for replies
types of rnessage-passing
establishes the channel
port s message
queue as intermediate
storage and copies
copies the message
send a larger
passes the message
memory the client
send a large
decides that replies
creates a section
pointer and size
object this method
avoids data copying
request the callback
perform asynchronous message
asynchronous message handling
handling the structure
structure of local
local procedure calls
calls in windows
important to note
win32 api invoke
api invoke standard
invoke standard remote
standard remote procedure
client server connection
server connection request
request j connection
connection i handle
handle i port
port i handle
handle i client
server i handle
handle communication port
port i shared
shared section object
local procedure call
procedure call lpcs
api in section
described how processes
communicate using shared
passing these techniques
strategies for communication
communication ir1 client-server
ir1 client-server systems
pipes 3.6.1 sockets
endpoint for communication
communication a pair
employ a pair
pair of sockets-one
process a socket
socket is identified
number in general
architecture the server
waits for incoming
incoming client requests
requests by listening
request is received
accepts a cmmection
socket to complete
complete the com1ection
com1ection servers implementing
servers implementing specific
implementing specific services
listen to well-known
telnet server listens
listens to port
ftp server listens
implement standard services
client process initiates
initiates a request
assigned a port
computer this port
arbitrary number greater
client on host
address 146.86.5.20 wishes
wishes to establish
establish a connection
listening on port
connection will consist
pair of sockets
server this situation
situation is illustrated
hosts are delivered
destination port number
communication using sockets
sockets all com1.ections
host x wished
wished to establish
establish another connection
port number greater
sockets using java
interface to sockets
library for networking
utilities those interested
interested in socket
types of sockets
sockets are implemented
mul ticastsocket class
class a multicast
socket allows data
describes a date
connection-oriented tcp sockets
sockets the operation
operation allows clients
clients to request
request the current
server the server
cmmection is received
returns the date
client the date
server is shown
creates a serversocket
serversocket that specifies
listen to port
server then begins
method the server
client to request
request a com1.ection
returns a socket
client the details
server first establishes
establishes a printwri
printwri ter objectthatitwill
client a printwri
printwri ter object
server to write
methods for output
output the server
server process sends
sends the date
calling the method
written the date
closes the socket
client and resumes
requests a client
server by creating
creating a socket
socket and connecting
server is listening
listening we implement
java.net ; import
java.io ; public
public class dateserver
public static void
static void main
listen for connections
client = sock.accept
write the date
close the socket
socket and resume
resume ii listening
listening for connections
connections client close
date server java
server java program
java program shown
creates a socket
socket and requests
requests a connection
127.0.0.1 on port
connection is madef
madef the client
client can read
socket using normal
stream i statements
received the date
serverf the client
socket and exits
special ip address
host to communicate
running the date
server in addition
addressf an actual
actual host namef
communication using sockets-although
common and efficient-is
considered a low-level
form of communication
communication between distributed
processes one reason
stream of bytes
application to impose
impose a structure
two higher-level methods
methods of communication
public class dateclient
connection to server
server socket socket
socket socket sock
read the date
socket string line
line = bin.readline
socket connection sock
connection sock close
client 3.6.2 remote
3.6.2 remote procedure
forms of remote
briefly in section
3.5.2 the rpc
rpc was designed
abstract the procedure-call
systems with network
ipc mechanism described
built on top
processes are executing
executing on separate
message-based communication scheme
scheme to provide
provide remote service
service in contrast
exchanged in rpc
longer just packets
packets of data
data each message
message is addressed
rpc daemon listening
ftmction to execute
parameters to pass
function the function
executed as requested
message a port
simply a number
address to differentiate
services it supports
addresses a message
port for instance
list its current
system could obtain
obtain the needed
list of current
sending an rpc
message to port
oil the server
message the semantics
semantics of rpcs
client to invoke
invoke a procedure
locally the rpc
rpc system hides
hides the details
place by providing
separate stub exists
separate remote procedure
invokes a remote
rpc system calls
procedure this stub
locates the port
server and marshals
marshals the parameters
parameters parameter marshalling
parameter marshalling involves
marshalling involves packaging
packaging the parameters
network the stub
stub then transmits
transmits a message
server using message
passing a similar
server side receives
receives this message
message and invokes
invokes the procedure
values are passed
teclu1.ique one issue
dealt with concerns
differences in data
integers some systems
significant byte first
first neither order
choice is arbitrary
architecture to resolve
rpc systems define
define a machine-independent
representation of data
marshalling involves converting
converting the machine-dependent
data into xdr
data are m1.marshalled
m1.marshalled and converted
server another important
important issue involves
involves the semantics
call whereas local
procedure calls fail
rpcs can fait
duplicated and executed
result of common
common network errors
address this problem
system to ensure
ensure that messages
messages are acted
implemented by attaching
attaching a timestamp
message the server
timestamps of messages
ensure that repeated
messages are detected
detected incoming messages
send a message
timestamps is discussed
remove the risk
receive the reqliest
reqliest to accomplish
server must implement
call was received
received and executed
executed these ack
messages are common
common throughout networking
networking the client
client must resend
resend each rpc
receives the ack
call another important
important issue concerns
concerns the communication
client with standard
standard procedure calls
form of binding
binding takes place
call the rpc
rpc scheme requires
requires a similar
server neither system
system has full
memory two approaches
approaches are common
form of fixed
fixed port addresses
addresses at compile
fixed port number
program is compiled
change the port
mechanism an operating
fixed rpc port
port a client
client then sends
rendezvous daemon requesting
requesting the port
execute the port
number is returned
requires the extra
first approach figure
shows a sample
sample interaction client
interaction client kejyt
sends rness tqe
f \ port
address for rpc
remote procedure call
implementing a distriblited
distriblited file system
set of rpc
daemons and clients
clients the messages
messages are addressed
file system port
place the message
performed the disk
usual file-related system
file-related system calls
calls the return
daemon on behalf
client for instance
request to transfer
simple block request
transferred 3.6.3 pipes
pipes a acts
allowin.g two processes
first ipc mechanisms
mechanisms in early
early unix systems
ways for processes
limitations in implementing
implementing a pipe
pipe allow unidirectional
communication or bidirectional
communication if two-way
communication is allowed
data can travel
explore two common
two common types
types of pipes
systems 3.6.3.1 ordinary
3.6.3.1 ordinary pipes
ordinary pipes ordinary
pipes ordinary pipes
communicate in standard
standard producerconsumer fashion
pipes are unidirectional
allowing only one-way
communication is required
pipe sending data
illustrate constructing ordinary
constructing ordinary pipes
reads this message
front the pipe
pipe on unix
pipes are constructed
creates a pipe
-pip-e -ou figure
ordinary pipe unix
pipe unix treats
treats a pipe
type of file
accessed using ordinary
calls an ordinary
typically a parent
parent process creates
process it creates
creates via fork
recall from section
process inherits open
inherits open files
inherits the pipe
parent process figure
illustrates the relationship
parent and child
unix progranc shown
sends a fork
creating the child
process what occurs
important to notice
process initially close
close their unused
require this action
step to ensure
pipe can detect
writer has closed
closed its end
pipe # include
string.h # include
unistd.h # define
continues in figure
pipes in unix
create the pipe
close the unused
pipe i close
pipe i write
close the write
pipe i read
continuation of figure
program ordinary pipes
pipes on windows
systems are termed
unidirectional and employ
employ parent-child relationships
processes in addition
functions the win32
api for creating
passed four parameters
stdlib.h # include
windows.h # define
writehandle ; startupinfo
written ; program
windows anonymous pipes
anonymous pipes parent
pipes parent process
inherit the handles
illustrates a parent
parent process creating
creating an anonymous
pipe for communicating
child unlike unix
unlike unix systems
process automatically inherits
inherits a pipe
requires the programmer
attributes the child
process will inherit
accomplished by first
initializing the security--attributes
redirecting the child
process s handles
handles for standard
input or standard
parent must redirect
redirect the child
child s standard
prohibit the child
child from inheriting
inheriting the write
process is similar
parameter is set
set to true
inherit designated handles
parent before writing
parent first closes
closes its unused
unused read end
pipe the child
process that reads
pipe is shown
obtains the read
pipe by invoking
note that ordinary
ordinary pipes require
require a parent-child
systems this means
machine 3.6.3.2 named
3.6.3.2 named pipes
named pipes ordinary
ordinary pipes provide
provide a simple
simple communication mechanism
ordinary pipes exist
processes are communicating
processes have finished
communicating and terminated
ordinary pipe ceases
ceases to exist
set up security
security attributes allowing
attributes allowing pipes
inherited i securi1yattributes
memory i zeromemory
create pipe failed
establish the startjnfo
process i getstartupinfo
si.hstdoutput = getstdhandle
redirect standard input
pipe i si.hstdinput
si.hstdinput = readhandle
dwflags = startf
child to inherit
inherit the write
end of pipe
pipe i sethandleinformation
create the child
process i createprocess
pipe i closehandle
writing to pipe
child to exit
exit i wai
program named pipes
named pipes provide
powerful communication tool
tool ; communication
relationship is required
pipe is established
readhandle ; char
pipe i readhandle
reading from pipe
anonymous pipes -child
pipes -child process
-child process communication
communication in fact
named pipes continue
continue to exist
exist after communicating
finished both unix
windows systems support
systems support named
support named pipes
details of implementation
implementation vary greatly
explore named pipes
systems named pipes
pipes are referred
fifos in unix
systems once created
system a fifo
fifo is created
call and manipulated
contirme to exist
system although fifos
fifos allow bidirectional
transmission is permitted
permitted if data
data must travel
processes must reside
machine ; sockets
required named pipes
windows systems provide
provide a richer
richer communication mechanism
unix counterparts full-duplex
counterparts full-duplex communication
byte or message-oriented
message-oriented data named
data named pipes
pipes are created
client can connect
pipe using connectnamedpipe
pipes in practice
unix command-line environment
environment for situations
serves as input
unix ls command
produces a directory
long directory listings
output may scroll
screens the command
command more manages
output by displaying
screen of output
user must press
press the space
bar to move
running as individual
input to moref
enabling the user
user to display
display a large
large directory listing
listing a screen
character the complete
output is consumed
command windows systems
shell with functionality
cmmterpart the dos
character for establishing
establishing a pipe
command in dos
process is defined
process s current
activity each process
terminated each process
process is represented
two major classes
classes of queues
i request queuecc
queue the ready
cpu each process
form a ready
ready queue long-term
selection of processes
allowed to contend
influenced by resourceallocation
memory management short-term
ready queue operating
queue operating systems
mechanism for parent
create new child
processes the parent
parent may wait
children to terminate
terminate before proceeding
parent and children
children may execute
reasons for allowing
allowing concurrent execution
cooperating processes cooperating
processes cooperating processes
interprocess communication mechanisnc
mechanisnc to commlmicate
communication is achieved
mernory and message
passing the shared-memory
shared-memory method requires
method requires communicating
share some variables
variables the processes
processes are expected
expected to exchange
responsibility for providing
providing communication rests
memory the message-passing
processes to exchange
messages the responsibility
communication may rest
operating system communication
pipes a socket
socket is defined
communication a connection
pair of applications
communication chamcel rpcs
form of distributed
commlmication an rpc
calls a procedure
remote application ordinary
application ordinary pipes
pipes allow communication
communication between parent
named pipes permit
pipes permit unrelated
permit unrelated processes
level a synchronous
commmucation b automatic
automatic and explicit
buffering c send
send by copy
copy and send
send by reference
reference d fixed-sized
fixed-sized and variable-sized
rpc mechanism describe
describe the undesirable
algorithm for implementing
implementing this semantic
client is lost
network problem describe
describe the sequence
sequence of messages
messages and discuss
means of concurrent
concurrent processing discuss
discuss three major
complications that concurrent
concurrent processing adds
describe the actions
kernel to context-switch
context-switch between processes
sun ultrasparc processor
processor has multiple
multiple register sets
register sets describe
similar to figure
obtain process information
unix or linux
command ps -ael
command on windows
suitable than named
suitable than ordinary
differences among short-term
including the initial
initial parent process
identify the values
values of pid
pid at lines
process i fork
fork another child
created # include
pid  pid1
process i pid1
pid1 = getpid
series of numbers
jibn = jibn-l
call that generates
generates the fibonacci
process the number
first five numbers
unistd.h int value
process i value
process i wait
line a process
child to output
output the sequence
invoke the wait
complete before exiting
exiting the program
perform necessary error
checking to ensure
number is passed
repeat the preceding
invoked from createprocess
child process outputting
outputting the fibonacci
fibonacci sequence perform
modify the date
date server shown
delivers random jokes
lines the date
date client shown
read the multi-line
multi-line jokes returned
echo server echoes
client for examplef
sends the server
server the string
server will respond
data it received
write an echo
java networking api
networking api described
3.6.1 this server
server will wait
connection is received
server will loop
client the server
server will break
client has closed
closed the connection
connection the server
java io bufferedreader
bufferedreader class bufferedreader
class bufferedreader extends
extends the java
java io reader
reading character streams
characters from clients
receive binary data
java io input
input stream deals
deals with data
object that extends
java io inputstrearn
inputstrearn the read
inputstrearn class returns
process must output
output the fibonacci
data another approach
approach to designing
designing this program
establish a shared-memory
processes this technique
child to write
memory as described
3.5.1 the program
program first requires
first requires creating
creating the data
struct this data
array of size
hold the fibonacci
sequence the child
malsequence these items
process will progress
accept the parameter
line and perform
perform error checking
max_sequence b create
create a shared-memory
segment of size
shared_data c attach
attach the shared-memory
set the value
value of sequence_size
line e fork
fork the child
process and invoke
child to finish
finish f output
output the value
segment g detach
detach and remove
remove the shared-memory
child s address
write the fibonacci
sequence to shared
finally will detach
detach the segment
segment one issue
concern with cooperating
cooperating processes involves
processes involves synchronization
involves synchronization issues
child finishes generating
generating the sequence
process will invoke
design a program
program using ordinary
sends a string
reverses the case
message and sends
first process sends
process will return
sending the original
sending the modified
unix or windows
design a file-copying
file-copying program named
program named filecopy
filecopy using ordinary
pipes this program
passed two parameters
file the program
create an ordinary
pipe and write
process will read
read this file
invoke the program
filecopy input.txt copy.txt
copy.txt the file
file input txt
read the contents
file and write
destination file copy
file copy txt
provide the ipcs
command this command
lists the status
posix interprocess communication
interprocess communication mechanisms
including shared-memory segments
data structure struct
structure struct shmid_ds
shared-memory segment short
segment short shm__nattch-number
shm__nattch-number of attaches
shared-memory segment struct
segment struct ipc_perm
struct ipc_perm shm_perm-permission
ipc_perm shm_perm-permission structure
segment the struct
struct ipc_perm data
ipc_perm data structure
unsigned short uid
short uid -identifier
shared -memory segment
-memory segment unsigned
segment unsigned short
unsigned short mode-permission
short mode-permission modes
mode-permission modes key_t
modes key_t key
-user-specified key identifier
identifier the permission
modes are set
segment is established
system call permissions
permissions are identified
permission of owner
permission of group
permission of world
write permissionof world
permissionof world permissions
bitwise and operator
evaluates to true
mode gives read
segment a shared-memory
integer value returned
represents the integer
shared-memory segment created
created the shm_ds
integer segment identifier
segment_id ; shm_ds
shmbuffer ; shmctl
indicating an error
global variable errno
accessed to determine
determine the error
passed an identifier
segment this program
program will invoke
invoke the shmctl
function to obtain
obtain its shm_ds
segmentid key mode
key mode owner
owner did size
number of attaches
posix message passing
passing this project
queues for communicating
four external processes
process the project
completed on systems
support posix message
overview four external
processes will communicate
system has stabilized
stabilized each process
receive its initial
temperature upon creation
four temps received
received from external
process will send
send its temperature
process will notify
notify each external
process will output
output the final
final stabilized temperature
processes and await
await their replies
replies the processes
processes will continue
temperature has stabilized
message passing system
passing system processes
processes can exchange
four system calls
converts a mailbox
externally known message
internal identifier returned
returned by msgget
subsequent system calls
queue to facilitate
facilitate interprocess communication
communication a typical
invocation of msgget
msqid = msgget
instructs the operating
create the message
queue already exists
returns the msqid
mailbox to avoid
existing message queue
attempt to attach
mailbox by omitting
checking the return
value from msgget
error has occurred
globally accessible variable
accessible variable errno
consulted to determine
assigned unique ranges
ranges of mailbox
process can begin
messages and msgrcv
messages the messages
received are similar
similar in format
include a fixed-length
senders and receivers
receivers must agree
messages being exchanged
operating system specifies
specifies one field
logical to create
create a data
type of message
struct the first
make the first
processes three additional
fields are recommended
external process sending
sending the message
process will set
stability a recommended
recommended struct appears
priority ; int
temp ; int
pid ; int
msgp ; assuming
assuming the msqid
examples of msgsnd
msqid ; stat
stat = msgsnd
value is returned
return the number
received upon successful
find or store
store the message
number of information
received the final
sender will block
queue is full
operations were desired
desired each individual
individual message queue
queue can hold
hold a maximum
number of messages-or
reason a sender
sender may block
block when attempting
attempting to transmit
transmit a message
parameter in msgrcv
minimum priority level
messages the process
wishes to receive
receiver will wait
process is finished
queue-and any messages
kernel to remove
remove the message
delete any unread
struct msgid_ds dummyparam
dummyparam ; status
status = msgctl
wishes to collect
collect some statistics
accomplished by substituting
parameter all programs
programs should include
possibly confusing artifact
message queue implementation
queue implementation bears
mailbox is removed
removed via msgctl
,any subsequent attempts
attempts to create
create another mailbox
creating the processes
processes each external
process would receive
send its replies
replies to mailboxes
mailboxes 71-74 outer
71-74 outer process
receive in mailbox
send to mailbox
process will attach
process specifies ipc_creat
ipc_creat when invoking
process that invokes
mailbox ; subsequent
calls to msgget
mailbox the protocol
protocol for removal
process is listening
removes -via msgctl
parameter the first
passed one parameter-its
parameter-its initial temperature
initial temperature assuming
assuming the executable
process is external
server is central
start by sending
sending one message
single outer process
code to solve
solve this problem
wise to check
four message queue
message queue system
queue system calls
output a message
completes the message
created by outer
received by central
process from external
removed or commented
problem is solved
passed the correct
number of command-line
parameter in main
extraneous messages residing
collection of cooperating
processes that function
wise to remove
remove all mailboxes
project to ensure
ensure that mailboxes
mailboxes are empty
begin the easiest
command to list
list all message
command to remove
remove existing message
existing message queues
queues the ipcs
ipcs command lists
lists the msqid
system use ipcrm
ipcrm to remove
remove message queues
output of ipcs
discussed by brinchhansen
schlichting and schneider
discuss asynchronous message-passing
asynchronous message-passing prirnitives
prirnitives the ipc
ipc facility implemented
level is described
described by bershad
details of interprocess
communication in unix
systems are presented
presented by gray
describe interprocess communication
mach system russinovich
outline interprocess communication
communication in windows
unix respectively hart
covers windows systems
windows systems programming
detail the implementation
implementation of rpcs
rpcs is discussed
discussed by birrell
birrell and nelson
shrivastava and panzieri
describes the design
reliable rpc mechanism
tay and ananda
presents a survey
survey of rpcs
discuss procedure calls
calls versus message-passing
versus message-passing communication
message-passing communication harold
coverage of socket
programming in java
robbins and robbins
pipes in windows
chapter the process
process model introduced
introduced in chapter
control most modern
systems now provide
provide features enabling
enabling a process
control this chapter
introduces many concepts
multithreaded computer systems
including a discussion
java thread libraries
related to multithreaded
linux operating systems
systems support threads
level to introduce
thread a fundamental
unit of cpu
utilization that forms
basis of multithreaded
discuss the apis
libraries to examine
examine issues related
programming a thread
comprises a thread
stack it shares
process its code
files and signals
signals a traditional
illustrates the difference
process 4.1.1 motivation
motivation many software
packages that run
run on modern
modern desktop pcs
pcs are multithreaded
multithreaded an application
typically is implemented
control a web
thread display images
thread + single-threaded
single-threaded process multithreaded
process multithreaded process
multithreaded process figure
single-threaded and multithreaded
multithreaded processes text
thread retrieves data
thread for displaying
thread for responding
responding to keystrokes
thread for performing
spelling and grammar
required to perform
perform several similar
web server accepts
server accepts client
accepts client requests
requests for web
busy web server
clients concurrently accessing
web server ran
traditional single-tlu eaded
single-tlu eaded process
artd a client
serviced one solution
process that accepts
receives a request
creates a separate
process to service
service that request
request in fact
threads became popular
popular process creation
consuming and resource
process will perform
generally more efficient
process is multithreaded
server will create
create a separate
thread that listens
listens for client
request is made
creating another process
thread to service
request and resume
listening for additional
threads also play
play a vital
role in remote
recall from chapter
rpcs allow interprocess
communication by providing
providing a communication
communication mechanism similar
similar to ordinary
function or procedure
servers are multithreaded
receives a message
services the message
server to service
service several concurrent
operating system kernels
performs a specific
create new thread
additional client requests
client requests figure
multithreaded server architecture
devices or interrupt
handling for examplef
examplef solaris creates
creates a set
set of threads
specifically for interrupt
handling ; linux
thread for managing
managing the amount
system 4.1.2 benefits
benefits the benefits
benefits of multithreaded
four major categories
multithreading an interactive
program to continue
performing a lengthy
user for instancef
instancef a multithreaded
multithreaded web browser
thread resource sharing
resource sharing processes
resources through techniques
memory or message
passing such techniques
share the memory
belong by default
default the benefit
benefit of sharing
code and data
threads of activity
economy allocating memory
memory and resources
resources for process
creation is costly
costly because threads
share the resources
economical to create
create and context-switch
threads empirically gauging
gauging the difference
difference in overhead
consuming to create
create and manage
processes than threads
threads in solarisf
creating a process
thirty times slower
creating a thread
times slower scalability
scalability the benefits
benefits of multithreading
running in parallel
processors a single-threaded
multicpu machine increases
machine increases parallelism
parallelism we explore
explore this issue
system 4.1.3 multicore
4.1.3 multicore programming
programming a recent
trend in system
place multiple computing
multiple computing cores
cores and improved
single computing core
concurrency merely means
core is capable
capable of executing
threads can run
system can assign
assign a separate
trend towards multicore
pressure on system
programmers to make
computing cores designers
designers of operating
systems must write
write scheduling algorithms
multiple processing cores
parallel execution shown
modify existing programs
design new programs
advantage of multicore
systems in general
areas present challenges
challenges in programming
activities this involves
involves examining applications
applications to find
divided into separate
individual cores balance
balance while identifying
tasks perform equal
perform equal work
work of equal
separate execution core
core to run
run that task
worth the cost
cost data splitting
applications are divided
accessed and manipulated
divided to run
run on separate
separate cores core
dependency the data
examined for dependencies
tasks in instances
depends on data
programmers must ensure
tasks is synchronized
synchronized to accommodate
accommodate the data
dependency we examine
examine such strategies
strategies in chapter
testing and debugging
program is running
parallel on multiple
execution paths testing
debugging such concurrent
inherently more difficult
difficult than testing
debugging single-threaded applications
software developers argue
advent of multicore
systems will require
designing software systems
future our discussion
support for threads
threads user threads
threads are supported
managed without kernel
supported and managed
virtually all contemporary
contemporary operating systems-including
operating systems-including wiridows
-support kernel threads
relationship must exist
exist between user
threads and kernel
ways of establishing
relationship 4.2.1 many-to-one
4.2.1 many-to-one model
model the many-to-one
maps many user-level
kernel thread thread
thread thread management
management is done
library in user
user thread figure
one-to-one model space
process will block
makes a blocking
blocking system call
thread can access
access the kernel
threads are unable
parallel on multiprocessors
multiprocessors -a thread
solaris-uses this modet
gnu 4.2.2 one-to-one
4.2.2 one-to-one model
model the one-to-one
maps each user
model by allowing
allowing another thread
thread to run
threads to run
creating a user
user thread requires
thread requires creating
overhead of creating
creating kernel threads
threads can burden
burden the performance
restrict the number
number of threads
family of windows
implement the one-to-one
model 4.2.3 many-to-many
4.2.3 many-to-many model
model the many-to-many
multiplexes many user-level
smaller or equal
number of kernel
threads the number
allocated more kernel
developer to user
kernel thread figure
......._ user thread
-kernel thread figure
two-level model create
kernel can schedule
many-to-many model suffers
developers can create
performs a blocking
schedule another thread
thread for execution
execution one popular
model still multiplexes
thread this variation
supported by operating
unix the solaris
operating system supported
supported the two-level
model in versions
older than solaris
beginning with solaris
creating and managing
two primary ways
ways of implementii
library the first
provide a library
support all code
exist ii user
space this means
means that invoking
invoking a function
local function call
call in user
implement a kernel-level
kernel-level library supported
exist in kernel
kernel space invoking
library typically results
kernel three main
main thread libraries
user or kernel-level
library the win32
win32 thread library
systems the java
java thread api
api allows threads
created and managed
directly in java
instances the jvm
jvm is running
running on top
system this means
api ; unix
describe basic thread
basic thread creation
design a multithreaded
performs the summation
well-known summation function
function would represent
represent the summation
summation of integers
output 4.3.1 pthreads
4.3.1 pthreads refers
defining an api
api for thread
creation and synchronization
specification for thread
implementation operating system
operating system designers
designers may implement
implement the specification
numerous systems implement
implement the pthreads
tru64 unix shareware
unix shareware implementations
demonstrates the basic
basic pthreads api
api for constructing
constructing a multithreaded
program that calculates
calculates the summation
separate threads begin
threads begin execution
function in figure
begins in main
thread that begins
function both threads
share the global
global data sum
program all pthreads
programs must include
include the pthread
pthread h header
file the statement
statement pthread_t tid
pthread_t tid declares
declares the identifier
create each thread
set of attributes
including stack size
size and scheduling
information the pthread_attr_t
pthread_attr_t attr declaration
attr declaration represents
represents the attributes
thread we set
set the attributes
function call pthread_attr
call pthread_attr ini
set any attributes
default attributes provided
scheduling attributes provided
thread is created
call in addition
addition to passirtg
passirtg the thread
thread will begin
execution-in this case
pass the integer
thread in main
performing the summation
pthread.h # include
stdio.h int sum
data is shared
thread i int
identifier i pthread_attr_t
set of thread
a.out integer value
attributes i pthread_attr_init
create the thread
thread i pthread_create
thread to exit
exit i pthread_join
function i void
upper = atoi
multithreaded c program
function after creating
creating the summation
threadf the parent
thread will wait
complete by calling
calling the pthread_j
function the summation
thread will complete
calls the function
thread has returnedf
returnedf the parent
thread will output
shared data sum
4.3.2 win32 threads
threads the technique
technique for creating
library is similar
ways we illustrate
illustrate the win32
win32 thread api
include the windows
pthreads version shown
threads-in this case
dword data type
unsigned 32-bit integer
define the summation
thread this function
function is passed
passed a pointer
defines as lpvoid
lpvoid the thread
performing this function
sets the global
passed to summation
threads are created
thread is passed
function these attributes
attributes il1.clude security
il1.clude security information
set the thread
make it eligible
parent must wait
complete before outputting
outputting the value
value of sum
value is set
summation thread recall
parent thread wait
statement we perform
perform the equivalent
creatil1.gthread to block
thread has exited
cover synchronization objects
4.3.3 java threads
java threads tlu
threads tlu eads
model of program
provide a rich
set of features
management of threads
threads all java
java programs comprise
thread of control-even
control-even a simple
simple java program
java program consisting
teclmiques for creating
program one approach
override its run
method an alternative-and
define a class
class that implements
implements the runnable
interface the runnable
interface is defined
public interface runnable
public abstract void
abstract void run
class implements runnable
define a run
method the code
implementing the run
separate thread figure
shows the java
program that determines
determines the summation
integer the summation
summation class implements
runnable interface thread
interface thread creation
creation is performed
performed by creating
windows.h # include
include stdio.h dword
stdio.h dword sum
function i dword
dword winapi sumrnation
threadid ; handle
threadhandle ; int
perform some basic
basic error checking
parameter is required
param = atoi
threadhandle = createthread
default security attributes
default stack size
stack size summation
thread function &param
parameter to thread
default creation flags
creation flags &threadid
returns the thread
thread to finish
close the thread
thread handle closehandle
private int sum
sum ; public
public int getsum
public void setsum
class summation implements
summation implements runnable
private int upper
upper ; private
private sum sumvalue
sumvalue ; public
this.upper = upper
upper ; this.sumvalue
this.sumvalue = sumvalue
public void run
public class driver
create the object
shared sum sumobject
upper = integer.parseint
summation integer value
class and passing
passing the constructor
constructor a runnable
runnable object creating
method that creates
calling the start
memory and initializes
jvm it calls
calls the run
making the thread
call the run
method directly rathel
call the start
summation program runs
jvm the first
object is invoked
invoked this child
child thread begins
thread begins execution
class after outputting
sharing of data
data between threads
easily in win32
win32 and pthreads
simply declared globally
pure object-oriented language
notion of global
occurs by passing
summation thread share
share the object
class this shared
object is referenced
class the reason
class is immutable-that
pthreads and win32
libraries use pthread_j
wai tforsingledbj ect
threads to finish
finish before proceeding
proceeding the join
method in java
java provides similar
notice that join
throw an interruptedexception
choose to ignore
4.4.1 the fork
calls in chapter
process the semantics
system calls change
program calls fork
duplicate all threads
single-threaded some unix
systems have chosen
versions of fork
duplicates all threads
thread that invoked
invoked the fork
call the exec
call typically works
invokes the exec
system the jvm
implemented on top
jvm to hide
hide the implementation
underlying operating system
provide a consistent
programs to operate
platform that supports
supports a jvm
jvm the specification
leaving that decision
thread is mapped
solaris initially implemented
implemented the jvm
jvm using themany
themany ~ to-one
jvm were implementedusing
implementedusing the many-to
inany model beginning
threads were mapped
model in addition
java thread library
system for .example
api when creating
creating java threads
threads ; linux
parameter to exec
replace the entire
process-including all threads
application if exec
immediately after forking
duplicating all threads
threads is unnecessary
parameters to exec
process should duplicate
threads 4.4.2 cancellation
4.4.2 cancellation -c
task of terminating
terminating a thread
returns the result
canceled another situation
situation might occur
presses a button
browser that stops
stops a web
page from loading
page is loaded
image is loaded
presses the stop
loading the page
page are canceled
canceled a thread
thread may occur
two different scenarios
cancellation one thread
thread immediately terminates
terminates the target
cancellation the target
thread periodically checks
opportunity to terminate
fashion the difficulty
difficulty with cancellation
occurs in situations
situations where resources
thread is canceled
midst of updating
troublesome with asynchronous
reclaim system resources
reclaim all resources
canceling a thread
resource with deferred
thread has checked
checked a flag
flag to determine
canceled the thread
thread can perform
perform this check
canceled safely pthreads
safely pthreads refers
4.4.3 signal handling
systems to notify
notify a process
occurred a signal
event being signaled
signaled all signals
signal is generated
event a generated
signal is delivered
process once delivered
examples of synchronous
synchronous signals include
signals include illegal
include illegal memory
access and division
running program performs
generated synchronous signals
signals are delivered
process that performed
performed the operation
operation that caused
caused the signal
receives the signal
signal asynchronously examples
signals include terminating
terminating a process
process with specific
process a signal
two possible handlers
default signal handler
handler a user-defilced
user-defilced signal handler
handler every signal
kernel when handling
signal this default
handle the signal
signals are handled
ways some signals
changing the size
handled by terminating
terminating the program
signals in single-threaded
programs is straightforward
complicated in multithreaded
signal be delivered
delivered in generat
deliver the signal
signal applies deliver
assign a specific
thread to receive
receive all signals
process the method
method for delivering
delivering a signal
type of signal
causing the signal
situation with asynchronous
clear some asynchronous
signal that terminates
terminates a process
threads most multithreaded
first thread found
standard unix function
function for delivering
specifies the process
delivered posix pthreads
support for signals
user thread receives
thread receives notification
signal in unix
unix must contend
deal with signals
apc is delivered
process 4.4.4 thread
4.4.4 thread pools
pools in section
request whereas creating
superior to creating
multithreaded server nonetheless
nonetheless has potential
problems the first
first issue concerns
concerns the amount
required to create
prior to servicing
servicing the request
completed its work
threads concurrently active
system unlimited threads
threads could exhaust
exhaust system resources
tince or memory
memory one solution
general idea beh_ind
beh_ind a thread
create a number
threads at process
startup and place
sit and wait
wait for work
awakens a thread
request for service
completes its service
pool and awaits
awaits more work
free thread pools
thread pools offer
offer these benefits
servicing a request
faster than waiting
waiting to create
create a thread
thread a thread
thread pool limits
limits the number
threads that exist
important on systems
support a large
number of concurrent
set heuristically based
based on factors
number of cpus
concurrent client requests
requests more sophisticated
sophisticated thread-pool architectures
adjust the number
patterns such architectures
smaller pool-thereby consuming
consuming less memory-when
memory-when the load
system is low
low the win32
related to thread
thread pool api
api is similar
similar to creating
thread is defin_ed
dword winapi poolfunction
pointer to poolfunction
executes this function
passed three paranceters
lpthread_starlroutine function-a pointer
separate thread pvoid
thread pvoid param-the
pvoid param-the parameter
param-the parameter passed
passed to function
function ulong flags-flags
ulong flags-flags indicating
pool to invoke
pass no parameters
provide the thread
instructions for thread
creation other members
win32 thread pool
pool api include
api include utilities
utilities that invoke
functions at periodic
asynchronous i request
completes the java
java util concurrent
util concurrent package
package in java
thread pool utility
4.4.5 thread-specific data
thread-specific data threads
data threads belonging
share the data
call such data
service each transaction
assigned a unique
identifier to associate
associate each thread
data most thread
thread libraries-including win32
win32 and pthreads-provide
pthreads-provide some form
form of support
support for thread-specific
thread-specific data java
java provides support
4.4.6 scheduler activations
activations a final
considered with multithreaded
multithreaded programs concerns
programs concerns communication
many-to-many and two-level
two-level models discussed
4.2.3 such coordination
performance many systems
two-level model place
place an intermediate
intermediate data structure
threads this data
application can schedule
schedule a user
run each lwp
lwp is attached
operating system schedules
schedules to run
run on physical
kernel thread blocks
operation to complete
user-level thread attached
lwp also blocks
blocks an application
application may require
require any number
number of lwps
lwps to run
cpu-bound application running
thread can run
lwp is sufficient
sufficient an application
require multiple lwps
lwps to execute
lwp is required
concurrent blocking system
system call suppose
file-read requests occur
requests occur simultaneously
simultaneously five lwps
lwps are needed
request must wait
lwps to return
kernel one scheme
scheme for communication
set of virtual
schedule user threads
kernel must inform
inform an application
events this procedure
upcalls are handled
handlers must run
processor one event
event that triggers
triggers an upcall
makes an upcall
block and identifying
identifying the specific
thread the kernel
kernel then allocates
application the application
runs an upcall
saves the state
thread and relinquishes
relinquishes the virtual
thread is running
running the upcall
handler then schedules
schedules another thread
eligible to run
thread was waiting
waiting for occurs
makes another upcall
thread library informilcg
previously blocked thread
event also requires
requires a virtual
kernel may allocate
processor or preempt
threads and run
run the upcall
processor after marking
marking the 1-mblocked
thread as eligible
schedules an eligible
explore how threads
threads are implemented
implemented in windows
systems 4.5.1 windows
windows xp threads
windows xp implements
implements the win32
family of microsoft
microsoft operating systems
systems a windows
windows xp application
threads the win32
threads is covered
covered in section
section 4.3.2 windows
one-to-one mapping described
user-level thread maps
access the address
identifying the thread
thread a register
register set representing
representing the status
processor a user
running in user
running in kernel
mode a private
private storage area
libraries and dynamic
dynamic link libraries
thread the primary
primary data structures
ethread-executive thread block
thread block kthread-kernel
block kthread-kernel thread
kthread-kernel thread block
thread block tee-thread
block tee-thread environment
tee-thread environment block
block the key
include a pointer
thread starts control
control the ethread
kthread ethread kernel
ethread kernel space
kernel space user
space user space
user space figure
windows xp thread
kthread includes scheduling
scheduling and synchronization
thread in addition
includes the kernel
teb the ethread
kernel can access
thern the teb
user-space data structure
array for threadspecific
windows xp terms
terms the structure
thread is illustrated
4.5.2 linux threads
linux threads linux
functionality of duplicating
duplicating a process
ability to create
distinguish between processes
threads in fact
task-rather than process
process or thread-when
flow of control
program when clone
passed a set
set of flags
flags are listed
flag meaning clone
information is shared
space is shared
sighand signal handlers
handlers are shared
shared clone files
files the set
set of open
files is shared
passed the flags
tasks will share
current working directory
files using clone
fashion is equivalent
equivalent to creating
thread as described
parent task shares
flags is set
set when clone
sharing takes place
resulting in functionality
call the varying
level of sharing
task is represented
kernel a unique
unique kernel data
kernel data structure
system this data
structures that represent
represent the list
memory when fork
copying all data
passed to clone
kernel now include
include the nptl
nptl thread library
thread library nptl
stands for native
native posix thread
posix thread library
posix-compliant thread model
model for linux
advantage of numa
support in addition
cost for creating
thread is lower
lower with nptl
traditional linux threads
potential to support
thousands of threads
threads such support
growth of multicore
systems a thread
process a multithreaded
flows of control
space the benefits
multithreading include increased
include increased responsiveness
use1 ~ resource
multiple cores user-level
cores user-level threads
threads are threads
kernel the operating-system
operating-system kernel supports
supports and manages
manages kernel-level threads
threads in general
threads are faster
faster to create
types of models
models relate user
many-to-one model maps
maps many user
single kernel thread
thread the one-to-one
one-to-one model maps
thread the many-to-many
many-to-many model multiplexes
multiplexes many user
threads most modern
systems provide kernel
provide kernel support
solaris and linux
linux thread libraries
thread libraries provide
provide the application
threads three primary
primary thread libraries
threads for windows
java threads multithreaded
threads multithreaded programs
multithreaded programs introduce
introduce many challenges
including the semantics
calls other issues
issues include thread
include thread cancellation
provide two programming
two programming examples
provide better performance
write a ncultithreaded
program that outputs
outputs prime numbers
numbers this program
program should work
user will run
enter a number
thread that outputs
components of program
state are shared
shared across threads
process a register
values b heap
memory c global
variables d stack
program at line
stdio.h int value
pid ; pthread_t
tid ; pthread_attr
pthread_attr t attr
process i pthread_attr_init
program for exercise
multithreaded program written
many-to-many threading rnodel
number of user-level
number of processors
discuss the performance
kernel threads allocated
program is equal
program is greater
number of userlevel
differences between user-level
threads and kernel-level
designing an echo
java threading api
server is single-threaded
respond to concurrent
concurrent echo clients
current client exits
client exits modify
modify the solution
solution to exercise
echo server services
services each client
modify the socket-based
socket-based date server
solution using multiple
multiple user-level threads
user-level threads achieve
achieve better performance
singleprocessor system explain
multiple kernel threads
kernel threads provide
write a multithreaded
program that generates
library this program
user will enter
line the number
number of fibonacci
generate the program
generate the fibonacci
placing the sequence
sequence in data
convenient data structure
thread finishes execution
child thread finishes
performs the smmnation
function was provided
provided in section
section 4.3.1 rewrite
rewrite this program
program in java
allowing a task
systems-such as windows
process contains pointers
separate threads belonging
approaches for modeling
library to context-switch
context-switch between user-level
threads the set
set of projects
projects below deal
two distinct topics-naming
distinct topics-naming service
matrix muliplication project
naming service project
project a naming
domain name system
resolve ip names
accesses the host
host www westminstercollege
consists of writing
writing a multithreaded
service in java
java using sockets
java net api
mechanism for resolving
resolving ip names
hostaddress = inetaddress.getbyname
ipaddress = hostaddress.gethostaddress
throws an unknownhostexception
unable to resolve
resolve the host
server will listen
waiting for client
connection is made
server will service
service the connection
additional client connections
makes a connection
client will write
wishes the server
server to resolve-such
resolve-such as www
www westminstercollege eduto
eduto the socket
socket the server
thread will read
locate the host
catch an unknownhostexception
unknownhostexception the server
server will write
write the message
resolve host host
server has written
close its socket
connection the client
application and connect
assuming the server
server is running
localhost a telnet
connected to localhost
localhost escape character
146.86.1.17 connection closed
closed by foreign
initially having telnet
debug any problems
convinced your server
server is working
write a client
application the client
parameter the client
client will open
open a socket
client is named
address or unknown
unknown host message
client has output
socket connection project
matrix multiplication project
coh.11m1s the entry
entry in matrix
elements for row
calculate each element
separate worker thread
threads the main-or
parent-thread will initialize
initialize the matrices
allocate sufficient memory
memory for matrix
hold the product
product of matrices
declared as global
thread has access
populated by reading
reading in values
file passing parameters
thread the parent
thread will create
passing each worker
worker the values
values of row
calculating the matrix
product this requires
passing two parameters
thread the easiest
approach with pthreads
struct the members
structure for passing
data to threads
threads i struct
row i int
programs will create
create the worker
struct v data
passing it data
public class workerthread
class workerthread implements
workerthread implements runnable
private int row
row ; private
private int col
col ; private
this.row = row
row ; this.col
this.col = col
col ; this.a
calculate the matrix
thread in java
java the data
turn will pass
separate thread sharing
data between java
sharing between threads
threads in pthreads
pthreads or win32
win32 one approach
thread to create
create and initialize
matrices-along with row
jto the constructor
worker thread appears
waiting for threads
threads to complete
threads have completed
output the product
contained in matrix
requires the main
thread to wait
enable a thread
thread to complete
thread libraries win32
pthreads and java
java use pthread_j
parent thread waits
single child thread
finish ; completing
completing this exercise
exercise will require
waiting for multiple
threads in section
describe the wai
wai tformultipledbj ects
waitformultipleobjectso is passed
array of threads
code for joining
joining ten threads
threads the num.ber
num.ber of objects
objects to wait
array of objects
objects a flag
signaled a timeout
array of thread
thread handle objects
objects of size
thread can wait
strategy for waiting
java s join
enclose the join
simple for loop
join on ten
pthread code depicted
code using java
threads is shown
final static int
static int num_threads
ten threads threads
starting as cheap
concurrency in programming
languages and moving
moving to lightweight
examples that included
included the thotll
described moving threads
unix kernel mach
major operating systems
operating systems implemented
thread performance issues
issues were discussed
discussed by anderson
continued their work
work in anderson
evaluating the performance
performance of user-level
threads with kernel
kernel support bershad
describe combining threads
threads with rpc
discusses a technique
technique for supporting
supporting user-level threads
threads an analysis
optimal thread-pool size
found in ling
presented in anderson
discusses scheduler activations
system_ other mechanisms
user-level thread library
discussed in marsh
govindan and anderson
zabatta and young
symmetric multiprocessor pinilla
pinilla and gill
compare java thread
java thread performance
performance on lim1x
describe recent developments
developments in threading
threading the solaris
solaris kernel russinovich
windows operating system
operating system family
system family bovet
explain how linux
linux handles threading
threading and singh
threads in mac
information on pthreads
lewis and berg
oaks and wong
multithreading in java
present a detailed
discussion of concurrent
beveridge and wiener
cohen and woodring
multithreading using win32
basis of multiprogrammed
multiprogrammed operating systems
systems by switching
introduce basic cpu-scheduling
basic cpu-scheduling concepts
concepts and present
present several cpu-scheduling
problem of selecting
selecting an algorithm
model on operating
kernel-level threads-not processes-that
fact being scheduled
terms process scheduling
scheduling and thread
scheduling when discussing
discussing general scheduling
general scheduling concepts
concepts and thread
ideas to introduce
introduce cpu scheduling
basis for multiprogrammed
describe various cpu-scheduling
algorithms to discuss
discuss evaluation criteria
criteria for selecting
selecting a cpu-scheduling
process can run
rescheduled the objective
utilization the idea
simple a process
process is executed
simple computer system
work is accomplished
accomplished with multiprogramming
productively several processes
operating system takes
takes the cpu
load store add
store add store
add store read
read from file
store increment index
increment index write
write to file
l cpu burst
burst cpu burst
figure 5.i alternating
5.i alternating sequence
sequence of cpu
process this pattern
fundamental operating-system function
resources are scheduled
primary computer resources
scheduling is central
central to operating-system
5.1.1 cpu-i burst
cpu-i burst cycle
cycle the success
success of cpu
cpu scheduling depends
property of processes
process execution consists
cycle of cpu
i wait processes
wait processes alternate
two states process
states process execution
process execution begins
final cpu burst
cpu burst ends
request to terminate
durations of cpu
greatly from process
computer to compute1
frequency curve similar
characterized as exponential
exponential or hyperexponential
number of short
short cpu bursts
number of long
long cpu bursts
bursts a cpu-bound
histogram of cpu-burst
cpu-burst durations program
bursts this distribution
algorithm 5.1.2 cpu
5.1.2 cpu scheduler
cpu becomes idle
executed the selection
selects a process
necessarily a first-in
sirnply an unordered
unordered linked list
queue are lined
lined up waiting
chance to run
cpu the records
generally process control
process control blocks
processes 5.1.3 preemptive
5.1.3 preemptive scheduling
preemptive scheduling cpu-scheduling
scheduling cpu-scheduling decisions
invocation of wait
terminates for situations
choice in terms
terms of scheduling
scheduling takes place
scheme is nonpreemptive
nonpreemptive or cooperative
preemptive under nonpreemptive
releases the cpu
state this scheduling
3.x ; windows
introduced preemptive scheduling
scheduling the mac
scheduling ; previous
operating system relied
relied on cooperative
cooperative scheduling cooperative
scheduling cooperative scheduling
require the special
needed for preemptive
preemptive scheduling incurs
incurs a cost
processes that share
updating the data
read the data
mechanisms to coordinate
discuss this topic
topic in chapter
preemption also affects
activity on behalf
process such activities
activities may involve
involve changing important
changing important kernel
important kernel data
process is preempted
read or modify
structure chaos ensues
ensues certain operating
including most versions
problem by waiting
call to com.plete
place before doing
doing a context
switch this scheme
structure is simple
preempt a process
kernel data structures
supportil1g real-time computing
computing and multiprocessing
multiprocessing these problems
described i.j.1 sections
affected by interrupts
guarded from simultaneous
lost or output
interrupts at entry
entry and reenable
interrupts at exit
note that sections
code that disable
dispatcher another component
dispatcher the dispatcher
scheduler this function
switching context switching
switching to user
user mode jumping
program to restart
restart that program
program the dispatcher
dispatcher to stop
stop one process
process and start
start another running
latency different cpu-scheduling
algorithm may favor
favor one class
class of processes
choosing which algorithm
algorithms many criteria
suggested for comparing
comparing cpu-scheduling algorithms
algorithms which characteristics
comparison can make
make a substantial
algorithm is judged
cpu as busy
utilization can range
lightly loaded system
cpu is busy
busy executing processes
done one measure
measure of work
long it takes
takes to execute
execute that process
process the interval
turnaround time turnaround
periods spent waiting
doing i waiting
affect the amount
process spends waiting
ready queue waiting
ready queue response
process can produce
produce some output
output fairly early
computing new results
results while previous
response is produced
produced this measure
tince it takes
takes to start
takes to output
output the response
response the turnaround
desirable to maximize
utilization and throughput
optimize the average
desirable to optimize
optimize the minimum
minimum or maximum
users get good
minirnize the maximum
response time investigators
investigators have suggested
important to minimize
minimize the variance
minimize the average
system with reasonable
reasonable and predictable
considered more desirable
highly variable howeve1
done on cpu-scheduling
algorithms that minimize
discuss various cpu-scheduling
illustrate their operation
operation an accurate
illustration should involve
involve many processes
hundred cpu bursts
bursts for simplicity
examples our measure
measure of comparison
elaborate evaluation mechanisms
cpu scheduling deals
problem of deciding
simplest cpu-scheduling algorithm
process that requests
requests the cpu
first is allocated
first the implementation
enters the ready
pcb is linked
queue the running
queue the code
code for fcfs
scheduling is simple
simple to write
write and understand
set of processes
processes that arrive
served in fcfs
chart that illustrates
including the start
start and finish
milliseconds for process
milliseconds this reduction
reduction is substantial
generally not minimal
processes cpu burst
cpu burst times
burst times vary
times vary greatly
greatly in addition
performance of fcfs
dynamic situation assume
processes flow armmd
armmd the system
scenario may result
result the cpu-bound
hold the cpu
processes will finish
devices are idle
cpu-bound process finishes
finishes its cpu
burst and moves
quickly and move
cpu sits idle
idle the cpu-bound
i processes end
end up waiting
cpu this effect
results in lower
cpu and device
processes were allowed
fcfs scheduling algorithm
algorithm is nonpreemptive
i the fcfs
troublesome for time-sharing
cpu at regular
period 5.3.2 shortest-job-first
5.3.2 shortest-job-first scheduling
approach to cpu
algorithm this algorithm
process the length
smallest next cpu
break the tie
sjf because m.ost
people and textbooks
type of scheduling
schedule these processes
milliseconds by comparison
fcfs scheduling scheme
milliseconds the sjf
sjf scheduling algorithm
minimum average waiting
moving a short
long one decreases
decreases the waiting
increases the waiting
waiting time decreases
decreases the real
algorithm is knowing
knowing the length
request for long-term
length the process
process time limit
submits the job
users are motivated
motivated to estimate
estimate the process
low a value
error and require
frequently in long-term
algorithm is optimal
level of short-term
short-term cpu scheduling
scheduling with short-term
burst one approach
approximate sjf scheduling
predict its value
value we expect
similar in length
computing an approximation
pick the process
shortest predicted cpu
predicted cpu burst
lengths of previous
previous cpu bursts
define the exponential
formula let t11
nth cpu burst
define the value
information ; t11
stores the past
history the parameter
parameter a controls
controls the relative
weight of recent
recent and past
conditions are assumed
recent cpu burst
cpu burst matters
history is assumed
history and past
weighted the initial
system average figure
shows an exponential
lmderstand the behavior
expand the formula
predecessor the sjf
preemptive or nonpreemptive
nonpreemptive the choice
newly arrived process
time + cpu
process a preemptive
preemptive sjf algorithm
algorithm will preempt
nonpreemptive sjf algorithm
finish its cpu
cpu burst preemptive
burst preemptive sjf
preemptive sjf scheduling
arrival time burst
resulting preemptive sjf
preemptive sjf schedule
process p2 arrives
required by process
scheduled the average
milliseconds nonpreemptive sjf
nonpreemptive sjf scheduling
scheduling would result
milliseconds 5.3.3 priority
5.3.3 priority scheduling
scheduling the sjf
general priority scheduling
priority scheduling algorithm
algorithm a priority
cpu is allocated
highest priority equal-priority
priority equal-priority processes
processes are scheduled
scheduled in fcfs
order an sjf
simply a priority
burst the larger
larger the cpu
lower the priority
vice versa note
scheduling in terms
terms of high
priority and low
low priority priorities
range of numbers
highest or lowest
priority some systems
systems use low
numbers to represent
represent low priority
numbers for high
priority this difference
difference can lead
lead to confusion
assume that low
low numbers represent
numbers represent high
represent high priority
internally or externally
externally internally defined
internally defined priorities
quantity or quantities
quantities to compute
compute the priority
number of open
ratio of average
average i burst
burst to average
average cpu burst
computing priorities external
priorities external priorities
priorities are set
set by criteria
type and amount
amount of funds
funds being paid
paid for computer
sponsoring the work
politicat factors priority
factors priority scheduling
priority is compared
preemptive priority scheduling
preempt the cpu
process is higher
process a nonpreemptive
nonpreemptive priority scheduling
queue a rnajor
problem with priority
priority scheduling algorithms
algorithms is indefinite
starvation a process
ready to run
run but waiting
blocked a priority
algorithm can leave
leave some lowpriority
lowpriority processes waiting
processes waiting indefinitely
heavily loaded computer
loaded computer system
stream of higher-priority
processes can prevent
prevent a low-priority
things will happen
eventually be run
finally lightly loaded
crash and lose
lose all unfinished
unfinished low-priority processes
found a low-priority
problem of indefinite
blockage of low-priority
processes is aging
increasing the priority
priority of processes
processes that wait
increase the priority
executed in fact
process to age
5.3.4 round-robin scheduling
scheduling the round-robin
algorithm is designed
similar to fcfs
preemption is added
added to enable
enable the system
system to switch
switch between processes
processes a small
milliseconds in length
length the ready
queue is treated
queue the cpu
allocating the cpu
quantum to implement
implement rr scheduling
queue o processes
processes new processes
processes are added
cpu scheduler picks
picks the first
sets a timer
timer to interrupt
dispatches the process
happen the process
release the cpu
voluntarily the scheduler
process is longer
system a context
queue the average
first time quantum
expires the cpu
process has received
cpu is returned
returned to process
additional time quantum
quantum the resulting
resulting rr schedule
calculate the average
schedule p1 waits
process s cpu
cpu burst exceeds
units each process
process must wait
wait no longer
milliseconds the performance
policy in contrast
creates the appearance
processor this approach
control data corporation
hardware to implement
implement ten peripheral
ten peripheral processors
set of hardware
registers the hardware
set of registers
resulting in ten
ten slow processors
faster than memory
instruction referenced memory
ten real processors
effect of context
switches will occur
slowing the execution
large with respect
spent in context
switching in practice
quantum context switches
smaller time quantum
increases context switches
turnaround time varies
time-quantum size increases
increases in general
single time quantum
turnaround time drops
turnaround time increases
switches are required
policy a rule
rule of thumb
quantum 5.3.5 multilevel
5.3.5 multilevel queue
multilevel queue scheduling
scheduling another class
class of scheduling
created for situations
division is made
made between foreground
processes and background
types of processes
processes a multilevel
queue scheduling algorithm
scheduling algorithm partitions
partitions the ready
-------i--n_te_r ~ ac_t_iv_e_e
.d_it ~ in_g--p
in_g--p ~ r-.o-c_
e---ss ~ e-s
-------s_tu_d_e_n_t_p_ro_c_e_s_s_es_ _____ _jl
lowest priority figure
queue scheduling size
type each queue
foreground and background
processes the foreground
queue is scheduled
algorithm in addition
implemented as fixed-priority
fixed-priority preemptive scheduling
order of priority
system processes interactive
processes interactive processes
interactive processes interactive
processes interactive editing
interactive editing processes
editing processes batch
processes batch processes
batch processes student
processes student processes
processes each queue
queue has absolute
priority over lower-priority
queues no process
queues for system
interactive editing process
editing process entered
entered the ready
process was running
preempted another possibility
processes for instance
background queue receives
cpu to give
5.3.6 multilevel feedback
multilevel feedback queue
feedback queue scheduling
queues for foreground
change their foreground
foreground or background
nature this setup
advantage of low
low scheduling overhead
inflexible the multilevel
process to move
move between queues
queues the idea
queue this scheme
queues in addition
process that waits
queue this form
form of aging
aging prevents starvation
feedback queue scheduler
scheduler first executes
executes all processes
processes in queue
executed if queues
empty a process
process that arrives
arrives for queue
process in queue
turn be preempted
arriving for queue
entering the ready
queue is put
put in queue
tail of queue
head of queue
put into queue
empty this scheduling
algorithm gives highest
priority than shorter
processes long processes
processes automatically sink
sink to queue
cpu cycles left
multilevel feedback queues
scheduler is defined
number of queues
queues the scheduling
queue the method
upgrade a process
demote a process
determine which queue
process will enter
process needs service
service the definition
queue scheduler makes
general cpu-scheduling algorithm
configured to match
match a specific
system under design
requires some means
parameters in chapter
distinguishing between user-level
user-level and kernel-level
threads on operating
operating system user-level
system user-level threads
threads are managed
kernel is unaware
ultimately be mapped
explore scheduling issues
scheduling issues involving
issues involving user-level
threads and offer
offer specific examples
examples of scheduling
scheduling for pthreads
pthreads 5.4.1 contention
5.4.1 contention scope
scope one distinction
distinction between user-level
kernel-level threads lies
scheduled on systems
implementing the many-to-one
thread library schedules
library schedules user-level
schedules user-level threads
cpu takes place
place among threads
library schedules user
schedules user threads
require the operating
system to schedule
schedule the kernel
cpu to decide
decide which kernel
thread to schedule
kernel uses system-contention
cpu with scs
scs scheduling takes
system systems usilcg
usilcg the one-to-one
pcs is done
priority-the scheduler selects
selects the runnable
priority to run
run user-level thread
user-level thread priorities
programmer to change
change the priority
note that pcs
preempt the thread
thread currently running
running in favor
threads of equal
priority 5.4.2 pthread
5.4.2 pthread scheduling
scheduling we provided
provided a sample
sample postx pthread
postx pthread program
program in section
introduction to thread
creation with pthreads
highlight the posix
posix pthread api
pcs or scs
scs during thread
thread creation pthreads
creation pthreads identifies
contention scope values
pthread_scope_process schedules threads
threads using pcs
pcs scheduling pthread_scope_system
scheduling pthread_scope_system schedules
pthread_scope_system schedules threads
threads using scs
scheduling on systems
implementing the many-to-many
pthread_scope_process policy schedules
policy schedules user-level
lwps the number
lwps is maintained
pthread_scope_system scheduling policy
policy will create
create and bind
bind an lwp
thread on many-to-many
effectively mapping threads
policy the pthread
functions for getting-and
getting-and setting-the contention
setting-the contention scope
contention scope policy
case of pthread_attr_getscope
contaiils a pointer
returns a non-zero
value in figure
illustrate a pthread
pthread scheduling api
api the program
program first determines
determines the existing
existing contention scope
scope and sets
creates five separate
scs scheduling policy
scheduling policy note
values are allowed
pthread_scope_system our discussion
problems of scheduling
scheduling the cpu
processor if multiple
pthreadoh # include
stdiooh # define
scope ; pthread_t
illegal scope valueo
set the scheduling
algorithm to pcs
scs i pthread_attr_setscope
create the threads
complex many possibilities
singleprocessor cpu scheduling
discuss several concerns
concerns in multiprocessor
scheduling we concentrate
concentrate on systems
processors are identical-homogeneous-in
processor to run
run any process
limitations on scheduling
approaches to multiple-processor
scheduling one approach
system activities handled
single processor-the master
processor-the master server
execute only user
code this asymmetric
multiprocessing is simple
accesses the system
system data structures
approach uses symmetric
processor is self-scheduling
self-scheduling all processes
common ready queue
queue of ready
examine the ready
queue and select
select a process
process to execute
access and update
update a common
common data structure
systems support smp
issues concerning smp
systems 5.5.2 processor
5.5.2 processor affinity
processor the data
populate the cache
successive memory accesses
satisfied in cache
processor the contents
contents of cache
cost of invalidating
invalidating and repopulating
migration of processes
rumting processor affinity
processor affinity takes
takes several forms
policy of attempting
processor-but not guaranteeing
process to migrate
migrate between processors
processors some systems
-such as lim.ix
lim.ix -also provide
-also provide system
calls that support
support hard affinity
solaris allows processes
assigned to limiting
limiting which processes
implements soft affinity
affinity the main-memory
system can affect
affect processor affinity
processor affinity issues
affinity issues figure
illustrates an architecture
architecture featuring non-uniform
featuring non-uniform memory
cpu has faster
parts of main
occurs in systems
systems containing combined
numa and cpu
scheduling and memory
boards the cpus
board can access
access the memory
system s cpu
scheduler and memory-placement
memory-placement algorithms work
shows that operating
defined and implemented
implemented as described
described in operating-system
lines between sections
frequently only dotted
algorithms creating connections
connections in ways
aimed at optimizing
reliability 5.5.3 load
5.5.3 load balancing
balancing on smp
utilize the benefits
processors may sit
processors have high
lists of processes
awaiting the cpu
cpu load balancing
load balancing attempts
workload evenly distributed
note that load
queue of eligible
execute on systems
common run queue
processor becomes idle
extracts a rmmable
operating systems supporting
systems supporting smp
two general approaches
approaches to load
migration and pull
migration with push
task periodically checks
checks the load
processor and -if
-if it finds
finds an imbalance-evenly
distributes the load
load by moving
processes from overloaded
overloaded to idle
idle or less-busy
less-busy processors pull
processors pull migration
pull migration occurs
idle processor pulls
pulls a waiting
busy processor push
push and pull
fact often implemented
implemented in parallel
parallel on load-balancing
freebsd systems implement
implement both techniql1es
techniql1es linux runs
runs its loadbalancing
processor is empty
balancing often counteracts
counteracts the benefits
benefits of processor
benefit of keeping
keeping a process
processor s cache
memory either pulling
pulling or pushing
pushing a process
invalidates this benefit
case in systems
processor always pulls
pulls a process
processes are moved
threshold 5.5.4 multicore
5.5.4 multicore processors
systems have allowed
allowed several threads
concurrently by providing
providing multiple physical
multiple physical processors
trend in computer
place multiple processor
multiple processor cores
set to maintain
maintain its architectural
state and appears
separate physical processor
physical processor smp
processor smp systems
processors are faster
faster and consume
power than systems
physical chip multicore
chip multicore processors
processors may complicate
complicate scheduling issues
researchers have discovered
processor accesses memory
spends a significant
illustrates a memory
processor can spend
waiting for data
memory to remedy
remedy this situation
recent hardware designs
designs have implemented
implemented multithreaded processor
multithreaded processor cores
threads are assigned
stalls while waiting
waiting for memory
core can switch
illustrates a dual-threaded
dual-threaded processor core
execution of thread
hardware thread appears
run a software
four logical processors
processors are presented
system the ultrasparc
ultrasparc tl cpu
cores per chip
cycle ~ memory
memory stall cycle
stall cycle thread
multithreaded multicore system
multicore system hardware
system hardware threads
threads per core
processors in general
ways to multithread
multithread a processor
multithreading with coarse-grained
memory stall occurs
processor must switch
thread to begin
cost of switching
switching between threads
threads is high
thread can begin
filling the pipeline
switches between threads
level of granularity-typically
design of fine-grained
fine-grained systems includes
systems includes logic
logic for thread
threads is small
multithreaded multicore processor
processor actually requires
two different levels
levels of scheduling
chooses which software
system may choose
choose any scheduling
decides which hardware
strategies to adopt
situation the ultrasparc
simple roundrobin algorithm
algorithm to schedule
four hardware threads
processor with hvo
hvo hardwaremanaged threads
dynamic urgency value
urgency value ranging
representing the lowest
highest the itanium
trigger a thread
thread-switching logic compares
compares the urgency
threads and selects
selects the thread
highest urgency value
value to execute
core 5.5.5 virtualization
virtualization and scheduling
scheduling a system
system with virtualization
system the virtualization
virtualization software presents
virtual machines rum1.ing
machines the significant
variations between virtualization
virtualization technologies make
make it difficult
difficult to summarize
summarize the effect
effect of virtualization
virtualization on scheduling
systems the host
operating system creates
creates and manages
manages the virtual
virtual n achine
operating system installed
installed and applications
guest eacb guest
eacb guest operating
fine-tuned for specific
specific use cases
including time sharing
operation any guest
guest operating-system scheduling
operating-system scheduling algorithm
algorithm that assumes
amount of progress
impacted by virtualization
time-sharing operating system
slice to give
users a reasonable
100-millisecond time slice
milliseconds of virtual
cpu time depending
busy the system
poor response times
times for users
machine the effect
catastrophic the net
individual virtualized operating
virtualized operating systems
operating systems receive
clocks in virtual
machines are incorrect
incorrect because timers
timers take longer
longer to trigger
dedicated cpus virtualization
lmdo the good
good scheduling-algorithm efforts
systems within virtual
machines we turn
important to remember
describing the scheduling
scheduling of kernel
tlueads with solaris
solaris and windows
windows xp recall
recall that linux
task when discussing
discussing the linux
solaris scheduling solaris
solaris uses priority-based
priority-based thread scheduling
algorithms the default
default scheduling class
sharing the scheduling
class dynamically alters
dynamically alters priorities
priorities and assigns
solaris dispatch table
table for time-sharing
time-sharing and interactive
interactive threads slices
queue by default
relationship between priorities
slices the higher
higher the priority
slice interactive processes
priority ; cpu-bound
priority this scheduling
policy gives good
processes and good
throughput for cpu-bound
processes the interactive
kde or gnome
window managers-a higher
managers-a higher priority
shows the dispatch
table for scheduling
two scheduling classes
scheduling classes include
handful the dispatch
dispatch table shown
priority the class-dependent
classes a higher
priority time quantum
priority this illustrates
illustrates the inverse
highest tince quantum
lowest time quantum
entire time quantum
quantum without blocking
blocking such threads
threads are considered
cpu-intensive as shown
priorities lowered return
return from sleep
sleep the priority
returning from sleeping
priority is boosted
supporting the scheduling
policy of providing
providing good response
interactive processes threads
priority this assignment
process will run
class in general
real-time class solaris
class to run
run kernel threads
scheduler and paging
daemon once established
change the system
class is reserved
reserved for kernel
user processes rum1ing
rum1ing in kernel
fixed-priority and fair-share
classes were introduced
introduced with solaris
adjusted the fair-share
fair-share scheduling class
class uses cpu
priorities to make
make scheduling decisions
scheduling decisions cpu
decisions cpu shares
shares indicate entitlement
scheduling class includes
includes a set
set of priorities
converts the class-specific
priorities into global
priorities and selects
highest global priority
priority to n.m
n.m the selected
selected thread n.ms
round-robin queue figure
scheduling classes relate
map to global
global priorities notice
threads for servicing
interrupts these threads
class and execute
windows xp scheduling
windows xp schedules
preemptive scheduling algorithm
algorithm the windows
windows xp scheduler
run the portion
windows xp kernel
kernel that handles
dispatcher a thread
selected to run
dispatcher will run
calls a blocking
higher-priority real-time thread
thread becomes ready
preempted this preemption
real-time thread preferential
thread preferential access
access the dispatcher
32-level priority scheme
scheme to determine
determine the order
order of thread
thread execution priorities
priorities are divided
classes the global
global priority highest
priority highest lowest
solaris scheduling scheduling
scheduling scheduling order
order first last
threads having priorities
threads with priorities
running at priority
priority and traverses
traverses the set
set of queues
queues from highest
highest to lowest
finds a thread
thread is found
dispatcher will execute
execute a special
api the win32
win32 api identifies
identifies several priority
process can belong
belong these include
realtime_priority _class higf-lpriority
_class higf-lpriority _class
higf-lpriority _class abovknormalpriority
_class abovknormalpriority class
abovknormalpriority class normalpriority
class normalpriority class
windows xp priorities
priorities below normal...priority
normal...priority _class idle...priority
_class idle...priority _class
_class are variable
classes can change
change a thread
priority the values
values for relative
relative priorities include
time_critical highest above_normal
highest above_normal normal
normal below normal
normal lowest idle
idle the priority
thread is based
class it belongs
class this relationship
relationship is shown
row the left
above_normal...priority_class is normal
base priority representing
representing a value
class the thread
normal relative priority
class the base
_class-8 below _normalpriority
_normalpriority _class-6 idle_priority
normalpriority_class a process
process was created
created the initial
typically the base
process the thread
thread is interrupted
priority is lowered
lowered the priority
lowering the priority
limit the cpu
consumption of compute-bound
thread is released
boosts the priority
priority the amount
waiting for keyboard
give good response
good response times
times to interactive
mouse and windows
enables i threads
i devices busy
busy while permitting
permitting compute-bound threads
spare cpu cycles
background this strategy
time-sharing operating systems
unix in addition
receives a priority
boost to enhance
enhance its response
user is running
running an interactive
provide especially good
special scheduling rule
rule for processes
windows xp distinguishes
windows xp increases
increases the scheduling
process three times
longer to run
time-sharing preemption occurs
prior to version
linux kernel ran
ran a variation
traditional unix scheduling
unix scheduling algorithm
algorithm two problems
traditional unix scheduler
provide adequate support
number of tasks
grows with version
scheduler was overhauled
algorithm that runs
runs in constant
including processor affinity
affinity and load
fairness and support
support for interactive
tasks the linux
two separate priority
separate priority ranges
nice value ranging
two ranges map
global priority scheme
numerically lower values
values indicate higher
relative priority highest
priorities and time-slice
length unlike schedulers
lim1x assigns higher-priority
assigns higher-priority tasks
higher-priority tasks longer
longer time quanta
quanta and lower-priority
shorter time quanta
quanta the relationship
priorities and tim.e-slice
length is shown
task is considered
eligible for execution
task has exhausted
quanta the kernel
maintains a list
nmqueue and schedules
schedules itself independently
independently each runqueue
two priority arrays
list of tasks
chooses the task
array for execution
cpu on multiprocessor
processor is scheduling
scheduling the highest-priority
tasks have exhausted
array is empty
arrays are exchanged
vice versa linux
versa linux implements
linux implements real-time
implements real-time scheduling
scheduling as defined
defined by posix.1b
section 5.4.2 real-time
5.4.2 real-time tasks
tasks are assigned
assigned static priorities
priorities all active
active array priority
expired array priority
tasks have dynamic
minus the value
value a task
task s interactivity
interactivity is deterncined
sleeping while waiting
typically have longer
longer sleep times
scheduler favors interactive
favors interactive tasks
tasks the result
tasks with shorter
shorter sleep times
lowered a task
task s dynamic
priority is recalculated
assigned new priorities
select a cpu-scheduling
difficult the first
problem is defining
defining the criteria
defined in terms
terms of cpu
thxoughput to select
select an algorithm
define the relative
elements our criteria
criteria may include
include several measures
maximizing cpu utilization
proportional to total
evaluate the algorithms
algorithms under consideration
5.7.1 deterministic modeling
modeling one major
class of evaluation
methods is analytic
analytic evaluation analytic
evaluation analytic evaluation
workload to produce
produce a formula
formula or number
number that evaluates
evaluates the performance
workload deterministic modeling
type of analytic
evaluation this method
workload and defines
defines the performance
processes which algorithm
algorithm would give
give the minimum
execute the processes
milliseconds with nonpreemptive
waiting time obtained
half that obtained
obtained with fcfs
intermediate value deterministic
value deterministic modeling
modeling is simple
simple and fast
compare the algorithms
requires exact numbers
numbers for input
cases the main
describing scheduling algorithms
algorithms and providing
measure the program
program s processing
modeling to select
select a scheduling
set of examples
analyzed and proved
5.7.2 queueing models
vary from day
day to day
distribution of cpu
bursts these distributions
estimated the result
mathematical formula describing
describing the probability
distribution is exponential
describe the distribution
distribution of times
times when processes
compute the average
algorithms the computer
system is described
network of servers
servers each server
queue of waiting
processes the cpu
device queues knowing
queues knowing arrival
knowing arrival rates
rates and service
average queue length
area of study
excluding the process
process being serviced
average arrival rate
processes will arrive
leaving the queue
algorithm and arrival
formula to compute
seconds queueing analysis
comparing scheduling algorithms
classes of algorithms
algorithms and distributions
limited the mathematics
mathematics of complicated
arrival and service
mathematically tractable -but
tractable -but unrealistic-ways
make a number
number of independent
approximations of real
statistics for fcfs
fcfs performance statistics
statistics for sjf
sjf performance statistics
evaluation of cpu
schedulers by simulation
simulation 5.7.3 simulations
evaluation of scheduling
simulations rumung simulations
rumung simulations involves
simulations involves programming
programming a model
computer system software
system software data
software data structures
data structures represent
represent the major
system the simulator
representing a clock
value is increased
modifies the system
state to reflect
reflect the activities
performance are gathered
gathered and printed
printed the data
data to drive
drive the simulation
programmed to generate
distributions the distributions
system under study
define the distribution
distribution of events
simulation a distribution-driven
relationships between successive
system the frequency
occurrence to correct
correct this problem
tapes we create
create a trace
tape by monitoring
monitoring the real
system and recording
recording the sequence
sequence of actual
sequence to drive
simulation trace tapes
trace tapes provide
provide an excellent
compare two algorithms
set of real
inputs this method
method can produce
produce accurate results
hours of computer
takes more computer
tapes can require
require large amounts
amounts of storage
task 5.7.4 implementation
evaluate a scheduling
works this approach
puts the actual
system for evaluation
evaluation under real
real operating conditions
conditions the major
cost the expense
expense is incurred
coding the algorithm
algorithm and modifying
modifying the operating
required data structures
constantly changing operating
changing operating system
system most users
interested in building
done another difficulty
change the environment
environment will change
programs are written
types of problems
scheduler if short
users may break
break larger processes
processes into sets
sets of smaller
processes if interactive
priority over noninteractive
users may switch
switch to interactive
designed one system
system that classified
interactive and noninteractive
amount of terminal
input or output
process was classified
classified as noninteractive
queue in response
modified his programs
programs to write
write an arbitrary
terminal at regular
gave his programs
programs a high
flexible scheduling algorithms
application or set
set of applications
applications a workstation
workstation that performs
performs high-end graphical
high-end graphical applications
server or file
server some operating
systemsparticularly several versions
versions of unix-allow
unix-allow the system
manager to fine-tune
fine-tune the scheduling
administrator to modify
modify the parameters
scheduling classes described
5.6.1 another approach
apis that modify
modify the priority
process or thread
thread the java
provide such functions
functions the downfall
performance-tuning a system
system or application
result in improved
general situations cpu
situations cpu scheduling
task of selecting
selecting a waiting
queue and allocating
simplest scheduling algorithm
processes to wait
long processes shortestjob
providing the shortest
shortest average waiting
waiting time implementing
implementing sjf scheduling
scheduling is difficult
predicting the length
burst is difficult
difficult the sjf
process both priority
priority and sjf
scheduling may suffer
suffer from starvation
technique to prevent
prevent starvation round-robin
system rr scheduling
relinquished the cpu
process is put
queue the major
degenerates to fcfs
form of context-switch
excessive the fcfs
algorithm is preemptive
preemptive the sjf
sjf and priority
nonpreemptive multilevel queue
multilevel queue algorithms
classes of processes
common model includes
includes a foreground
foreground interactive queue
background batch queue
fcfs scheduling multilevel
scheduling multilevel feedback
queues allow processes
processes to move
contemporary computer systems
computer systems support
systems support multiple
support multiple processors
processor to schedule
schedule itself independently
queue of processes
run additional issues
additional issues related
related to multiprocessor
multiprocessor scheduling include
scheduling include processor
include processor affinity
scheduling on virtualization
virtualization systems operating
systems operating systems
systems supporting threads
level must schedule
schedule threads-not processes-for
threads-not processes-for execution
case with solaris
systems schedule threads
threads using preemptive
priority-based scheduling algorithms
support for real-time
threads the linux
linux process scheduler
algorithm with real-time
systems typically favor
typically favor interactive
interactive over batch
batch and cpu-bound
processes the wide
variety of scheduling
scheduling algorithms demands
methods to select
select among algorithms
algorithms analytic methods
methods use mathematical
analysis to determine
determine the performance
algorithm simulation methods
simulation methods determine
methods determine performance
performance by imitating
imitating the scheduling
sample of processes
processes and computing
computing the resulting
provide an approximation
approximation of actual
actual system performance
technique for evaluating
evaluating a scheduling
implencent the algorithm
system and monitor
monitor its performance
scheduler to distinguish
programs from cpu-bound
cpu-scheduling algorithm determines
determines an order
give a formula
formula in tentls
systenc running ten
ten i tasks
cpu-bound task assume
millisecond of cpu
i operation takes
milliseconds to complete
complete also assume
processes are long-running
long-running tasks describe
describe the cpu
multilevel queueing system
system implementing multilevel
implementing multilevel queue
scheduling what strategy
computer user employ
employ to maximize
maximize the amount
cpu time allocated
user s process
system for time-sharing
thread with priority
assign this thread
thread c assume
quantum has expired
explain the differences
scheduling algorithms discriminate
discriminate in favor
favor of short
exponential average formula
predict the length
implications of assigning
algorithms could result
result in starvation
starvation a first-come
first-served b shortest
first c round
robin d priority
favors those processes
favor i programs
permanently starve cpu-bound
starve cpu-bound programs
determine the numeric
priority of highest
priority of normal
priority of above..normal
queue are pointers
effect of putting
putting two pointers
two major advantages
modify the basic
basic rr algorithm
algorithm to achieve
burst time priority
processes are assumed
draw four gantt
four gantt charts
charts that illustrate
illustrate the execution
smaller priority number
priority number implies
implies a higher
algorithms in part
unix scheduler enforces
enforces an inverse
relationship between priority
numbers and priorities
higher the numbe1
priority the scheduler
scheduler recalculates process
recalculates process priorities
recent cpu usage
base where base
cpu usage refers
cpu since priorities
priorities were last
last recalculated assume
assume that recent
usage for process
processes when priorities
priorities are recalculated
unix scheduler raise
raise or lower
lower the relative
pairs of scheduling
scheduling criteria conflict
settings a cpu
utilization and response
i device utilization
utilization and cpu
scheduling algorithm based
dynamically changing priorities
changing priorities larger
priorities larger priority
larger priority numbers
numbers imply higher
imply higher priority
enter the ready
queue the parameters
set to give
algorithm that results
arrive for execution
listed in answering
answering the questions
made process arrival
algorithm is supposed
supposed to improve
chose to run
two shorter processes
processes would arrive
arrive soon compute
cpu is left
remember that processes
durirtg this idle
increase this algorithm
future-knowledge scheduling feedback
scheduling feedback queues
ctss system described
described in corbato
queue scheduling system
system was analyzed
analyzed by schrage
algorithm of exercise
suggested by kleinrock
discuss thread scheduling
scheduling multicore scheduling
scheduling is examined
examined in mcnairy
mcnairy and bhatia
information regarding process
process execution times
times from previous
runs are described
described in fisher
schedulers are covered
covered by henry
unix v operating
system are described
described by bach
presented by mckusick
mckusick and neville-neil
system are discussed
discussed by black
scheduling in lim.ix
found in roberson
scheduling is described
described by mauro
mauro and mcdougall
scheduling in windows
scheduling in pthreads
pthreads systems siddha
discuss scheduling challenges
challenges on multicore
multicore systems part
system cooperating processes
share a logical
logical address space
allowed to share
files or messages
case is achieved
data may result
result in data
discuss various mechanisms
ensure the orderly
execution of cooperating
consistency is maintained
maintained to introduce
introduce the critical-section
ensure the consistency
consistency of shared
data to present
present both software
software and hardware
problem to introduce
introduce the concept
transaction and describe
atomicity in chapter
developed a model
consisting of cooperating
cooperating sequential processes
possibly sharing data
data we illustrated
illustrated this model
representative of operating
original solution allowed
modify the algorithm
algorithm to remedy
remedy this deficiency
deficiency one possibility
add an integer
integer variable counter
counter is incremented
remove one item
buffer the code
buffer_size ; counter
correctly when executed
consumer processes execute
execute the statements
consumer execute separately
value of counter
implemented in machine
register1 = counter
register1 = register1
counter = register1
register1 where register1
local cpu registers
statement register2 counter
counter is implemented
register2 = counter
register2 = register2
counter = register2
register1 and register2
saved and restored
execution of counter
counter is equivalent
lower-level statements presented
previously are interleaved
statement is preserved
producer execute register1
consumer execute register2
producer execute counter
consumer execute counter
incorrect state counter
buffers are full
reversed the order
allowed both processes
processes to manipulate
manipulate the variable
variable counter concurrently
concurrently a situation
access and manipulate
access takes place
manipulating the variable
counter to make
processes be synchronized
frequently in operating
system manipulate resources
emphasis on developing
developing multithreaded applications
possibly sharing data-are
sharing data-are rmming
rmming in parallel
chapter is concerned
segment of code
changing common variables
updating a table
writing a file
process is executing
design a protocol
cooperate each process
process must request
permission to enter
enter its critical
section the section
section of code
implementing this request
exit the remaining
section i critical
section i exit
section i remainder
process a figure
section and exit
section are enclosed
enclosed in boxes
boxes to highlight
highlight these important
code a solution
problem must satisfy
exclusion if process
enter their critical
sections can participate
participate in deciding
carmot be postponed
postponed indefinitely bounded
indefinitely bounded waiting
waiting there exists
exists a bound
number of times
processes are allowed
allowed to enter
process has made
made a request
request to enter
request is granted
granted we assume
make no assumption
structure that maintains
system this list
file is opened
opened or closed
adding the file
list or removing
list could result
condition other kernel
race conditions include
conditions include structures
structures for maintaining
maintaining memory allocation
maintaining process lists
developers to ensure
system is free
conditions two general
handle critical sections
sections in operating
kernels a preemptive
mode a nonpreemptive
exits kernel mode
voluntarily yields control
free from race
conditions on kernel
process is active
designed to ensure
ensure that shared
shared kernel data
data are free
race conditions preemptive
conditions preemptive kernels
difficult to design
design for smp
two kernel-mode processes
favor a preemptive
suitable for real-time
process to preempt
arbitrarily long period
period before relinquishing
relinquishing the processor
processor to waiting
minimized by designing
designing kernel code
operating systems manage
systems manage preemption
illustrate a classic
classic software-based solution
modern computer architectures
computer architectures perform
architectures perform basic
perform basic machine-language
basic machine-language instructions
load and store
guarantees that peterson
solution will work
present the solution
good algorithmic description
description of solving
solving the critical-section
problem and illustrates
involved in designing
software that addresses
addresses the requirements
requirements of mutual
bomcded waiting peterson
solution is restricted
processes that alternate
sections and remainder
sections the processes
processes are numbered
share two data
two data items
turn ; boolean
section the flag
process is ready
ready to enter
data structures complete
ready to describe
describe the algorithm
enter the critical
first sets flag
wishes to enter
roughly the sance
assignments will last
true ; turn
section i flag
structure of process
solution the eventual
value of turn
processes is allowed
critical section first
solution is correct
exclusion is preserved
preserved the progress
requirement is satisfied
satisfied the bounded-waiting
requirement is met
met to prove
enters its critical
false or turn
true and turn
condition will persist
preserved to prove
prevented from entering
entering the critical
section if turn
exits its critical
change the value
turn while executing
acquire lock critical
lock critical section
section i release
lock i remainder
problem using locks
described one software-based
guaranteed to work
work on modern
critical-section problem requires
requires a simple
simple tool-a lock
tool-a lock race
lock race conditions
conditions are prevented
prevented by requiring
requiring that critical
regions be protected
protected by locks
process must acquire
acquire a lock
lock before entering
entering a critical
releases the lock
exits the critical
problem using techniques
ranging from hardware
hardware to softwarebased
solutions are based
premise of locking
sophisticated we start
start by presenting
presenting some simple
simple hardware instructions
systems and showing
effectively in solving
critical-section problem hardware
problem hardware features
features can make
make any programming
programming task easier
easier and improve
improve system efficiency
efficiency the critical-section
interrupts from occurring
sequence of instructions
execute in order
order without preemption
multiprocessor environment disabling
environment disabling interrupts
target ; target
target = true
true ; return
critical section lock
lock = false
implementation with testandset
message is passed
processors this message
message passing delays
passing delays entry
system efficiency decreases
system s clock
updated by interrupts
interrupts many modern
systems therefore provide
provide special hardware
special hardware instructions
test and modify
swap the contents
instructions to solve
solve the critical-section
discussing one specific
abstract the main
types of instructions
instructions by describing
describing the testandset
instructions the testandset
defined as shown
supports the testandset
implement mutual exclusion
exclusion by declaring
declaring a boolean
boolean variable lock
initialized to false
false the structure
supports the swap
global boolean variable
lock is declared
false in addition
local boolean variable
boolean variable key
key the structure
satisfy the mutual-exclusion
satisfy the bounded-waiting
requirement in figure
present another algorithm
instruction that satisfies
requirements the common
common data structures
structures are void
key = true
instruction boolean waiting
structures are initialized
false to prove
note that process
false or key
false the value
value of key
executed the first
execute the testandset
wait the variable
leaves its critical
set to false
maintaining the mutual-exclusion
true ; key
key = testandset
bounded-waiting mutual exclusion
exclusion with testandset
presented for mutual
exiting the critical
section either sets
lock to false
false or sets
waiting to enter
section to proceed
proceed to prove
scans the array
designates the first
section any process
implementing atomic testandset
instructions on multiprocessors
task such implementations
implementations are discussed
discussed in books
books on computer
architecture the hardware-based
critical-section problem presented
presented in section
complicated for application
overcmrte this difficulty
two standard atomic
standard atomic operations
definition of wait
definition of signal
modifies the semaphore
value in addition
case of wait
executed without interruption
implemented in section
6.5.2 ; first
6.5.1 usage operating
usage operating systems
systems often distinguish
distinguish between counting
counting and binary
semaphores the value
semaphore can range
domain the value
semaphores are lmown
lmown as mutex
locks that provide
provide mutual exclusion
semaphores to deal
problem or mljltiple
processes then processes
share a semaphore
organized as shown
number o instances
instances the semaphore
semaphore is initialized
number of resources
process that wishes
performs a wait
decrementing the count
releases a resource
performs a signal
incrementing the count
resource will block
count becomes greater
semaphores to solve
solve various synchronization
two concurrently numing
concurrently numing processes
suppose we require
implement this scheme
readily by letting
share a common
common semaphore synch
inserting the statements
synch is initialized
executed 6.5.2 implementation
implementation the main
section must loop
code this continual
real multiprogramming system
critical section signal
implementation with semaphores
cpu is shared
shared among ncany
ncany processes busy
processes busy waiting
busy waiting wastes
waiting wastes cpu
wastes cpu cycles
productively this type
type of semaphore
spins while waiting
switch is required
locks are expected
held for short
employed on multiprocessor
thread can spin
performs its critical
modify the definition
executes the wait
operation and finds
engaging in busy
process can block
block operation places
places a process
process is switched
state then control
control is transferred
selects another process
executes a signal
operation the process
process is restarted
state the process
newly ready process
define a semaphore
value ; struct
struct process list
processes a signal
removes one process
list of waiting
processes and awakens
process the wait
defined as wait
add this process
list ; block
defined as signal
remove a process
process p fron
fron s list
list ; wakeup
suspends the process
resumes the execution
operations are provided
system as basic
basic system calls
system calls note
definition of semaphores
semaphores with busy
value is negative
semaphore this fact
results from switching
switching the order
operation the list
list of pcbs
add and rernove
ensure bounded waiting
head and tail
queue in general
queueing strategy correct
strategy correct usage
usage of semaphores
critical that semaphores
semaphores be executed
simply inhibiting interrupts
operations are executing
executing this scheme
interrupts are inhibited
running process executes
executes until interrupts
interrupts are reenabled
scheduler can regain
arbitrary way disabling
provide alternative locking
alternative locking techniques-such
techniques-such as spinlocks-to
ensure that wait
important to admit
completely eliminated busy
eliminated busy waiting
moved busy waiting
sections of application
limited busy waiting
sections are short
busy waiting occurs
exists with application
programs whose critical
casesf busy waiting
inefficient 6.5.3 deadlocks
deadlocks and starvation
starvation the implementation
queue may result
processes are waiting
processes the event
event in question
state is reached
accessing two semaphores
cam1ot be executed
set is waiting
set the events
acquisition and release
types of events
events may result
result in deadlocks
show in chapter
describe various mechanisms
mechanisms for dealing
problem another problem
related to deadlocks
semaphore indefinite blocking
blocking may occur
semaphore in lifo
order 6.5.4 priority
6.5.4 priority inversion
inversion a scheduling
scheduling challenge arises
modify kernel data
process-or a chain
chain of lower-priority
processes since kernel
resource the situation
preempted in favor
follow the order
assume that process
process h requires
accessed by process
finish using resource
suppose that process
mars pathfinder priority
pathfinder priority inversion
inconvenience on systems
systems with tight
tight time constraints
real-time systems-see chapter
accomplish a task
failures can cascade
resulting in system
nasa space probe
probe that landed
landed a robot
sojourner began operating
started to experience
experience frequent computer
frequent computer resets
resets each reset
reinitialized all hardware
mission the problem
problem was caused
longer than expected
expected to complete
complete its work
work this task
forced to wait
lower-priority asi task
turn was preempted
preempted by multiple
multiple medium-priority tasks
tasks the bcdist
task would stall
ultimately the bc_sched
task would discover
discover the problem
problem and perform
perform the reset
reset the sojourner
sojourner was suffering
case of priority
inversion the operating
sojourner was vxworks
variable to enable
enable priority inheritance
semaphores after testing
variable was set
problem was solved
solved a full
solution was written
software team lead
lower priority-process m-has
priority-process m-has affected
affected how long
typically these systems
problem by implementing
implementing a 2tic
accessing resources needed
higher-priority process inherit
inherit the higher
resources in question
inherit the priority
priority of process
preempting its execution
execution when process
finished using resource
relinquish its inherited
priority from hand
assume its original
priority because resource
h-not m-would run
present a number
number of synchronization
problems as examples
class of concurrency-control
problems these problems
item in nextp
nextp to buffer
producer process testing
newly proposed synchronization
proposed synchronization scheme
semaphores for synchronization
6.6.1 the bounded-buffer
problem the bounded-buffer
problem was introduced
introduced in section
illustrate the power
power of synchronization
present a general
scheme without committing
provide a related
related programming project
chapter we assume
holding one item
item the mutex
semaphore provides mutual
exclusion for accesses
empty and full
full semaphores comct
comct the number
number of empty
buffers the semaphore
empty is initialized
full is initialized
process is shown
note the symmetry
interpret this code
producer producing full
producing full buffers
consumer producing empty
producing empty buffers
remove an item
item from buffer
buffer to nextc
item in nextc
6.6.2 the readers-writers
readers-writers problem suppose
read the database
database we distinguish
processes by referring
two readers access
effects will result
access the database
chaos may ensue
ensue to ensure
writers have exclusive
database while writing
database this synchronization
problem is referred
primitive the readers-writers
priorities the simplest
first readers-writers problem
reader should wait
readers to finish
writer is waiting
readerswriters problem requires
writer is ready
performs its write
waiting to access
access the object
readers may start
reading a solution
problem may result
writers may starve
readers may starve
present a solution
chapter for references
references describing starvation-free
describing starvation-free solutions
reader processes share
wrt ; int
mutex and wrt
wrt are initialized
readcount is initialized
wrt is common
reader and writer
processes the mutex
ensure mutual exclusion
readcount is updated
updated the readcount
variable keeps track
reading the object
object the semaphore
semaphore wrt functions
first or last
reader that enters
enters or exits
readers who enter
enter or exit
sections the code
readers are waiting
reader is queued
queued on wrt
readers are queued
queued on mutex
mutex also observe
writer executes signal
resume the execution
single waiting writer
writer the selection
selection is made
scheduler the readers-writers
generalized to provide
acquiring a reader-writer
writing is performed
writer process requires
lock either read
read shared data
requests the reader-writer
lock in read
wishing to modify
modify the shared
data must request
request the lock
lock in write
write mode multiple
mode multiple processes
processes are permitted
acquire a reader-writer
process may acquire
acquire the lock
lock for writing
access is required
required for writers
writers reader-writer locks
easy to identify
identify which processes
processes only read
processes only write
write shared data
data in applications
readers than writers
locks generally require
require more overhead
overhead to establish
establish than semaphores
semaphores or mutual-exclusion
locks the increased
concurrency of allowing
allowing multiple readers
multiple readers compensates
involved in setting
6.6.3 the dining-philosophers
philosophers who spend
spend their lives
thinking and eating
eating the philosophers
share a circular
circular table surrounded
reading is performed
bowl of rice
table is laid
philosopher gets hungry
philosopher may pick
eats without releasing
releasing her chopsticks
chopsticks and starts
problem is considered
considered a classic
classic synchronization problem
computer scientists dislike
scientists dislike philosophers
allocate several resources
deadlock-free and starvation-free
mam1er one simple
represent each chopstick
semaphore a philosopher
grab a chopstick
chopstick by executing
releases her chopsticks
chopsticks by executing
executing the signal
elements of chopstick
chopstick are initialized
structure of philosopher
neighbors are eating
create a deadlock
philosophers become hungry
grabs her left
grab her right
problem are listed
philosopher to pick
odd philosopher picks
picks up first
first her left
chopstick in section
problem that ensures
freedom from deadlocks
problem must guard
philosophers will starve
starve to death
death a deadlock-free
eliminate the possibility
possibility of starvation
starvation although semaphores
convenient and effective
incorrectly can result
result in timing
difficult to detect
sequences take place
timing problem happened
counter value appeared
reason that semaphores
semaphores were introduced
occur when semaphores
review the semaphore
problem all processes
semaphore variable mutex
process must execute
section and signal
critical sections simultaneously
difficulties will arise
behaved this situation
honest programming error
interchanges the order
mutex are executed
critical section wait
violating the mutual-exclusion
requirement this error
critical sections note
process replaces signal
deadlock will occur
omits the wait
exclusion is violated
occur these examples
types of errors
easily when programmers
programmers use sencaphores
incorrectly to solve
critical-section problem similar
problem similar problems
problems may arise
synchronization models discussed
researchers have developed
developed high-level language
high-level language constructs
describe one fundamental
fundamental high-level synchronization
high-level synchronization construct-the
synchronization construct-the monitor
construct-the monitor type
type 6.7.1 usage
usage a abstract
abstract data type
type or adt
adt encapsulates private
encapsulates private data
data with public
methods to operate
data a monitor
adt which presents
presents a set
set of programmer-defined
provided mutual exclusion
monitor the monitor
declaration of variables
variables whose values
define the state
bodies of procedures
procedures or functions
functions that operate
variables the syntax
type is shown
monitor can access
shared variable declarations
variable declarations procedure
monitor construct ensures
code this synchronization
defined so fa1
powerful for modeling
modeling some synchronization
define additional synchronization
additional synchronization mechanisms
mechanisms these mechanisms
mechanisms are provided
construct a programmer
write a tailor-made
tailor-made synchronization scheme
scheme can define
variables of type
variable are wait
operation x wait
invoking this operation
operation is suspended
invokes x signal
process is suspended
figure shared data
shared data operations
data operations initialization
operations initialization code
contrast this operation
affects the state
semaphore now suppose
operation is invoked
exists a suspended
allowed to resume
resume its execution
execution two possibilities
signal and wait
leaves the monitor
monitor or waits
signal and continue
arguments in favor
favor of adopting
adopting either option
hold a compromise
choices was adopted
language concurrent pascal
pascal when thread
thread p executes
executes the signal
resumed many programming
languages have incorporated
incorporated the idea
monitor as described
including concurrent pascal
java other languages-such
languages-such as erlang-provide
erlang-provide some type
type of concurrency
initialization code figure
monitor with condition
variables 6.7.2 dining-philosophers
6.7.2 dining-philosophers solution
solution using monitors
illustrate monitor concepts
concepts by presenting
presenting a deadlock-free
problem this solution
imposes the restriction
code this solution
find a philosopher
set the variable
declare condition sel
unable to obtain
obtain the chopsticks
position to describe
describe our solution
problem the distribution
chopsticks is controlled
definition is shown
starting to eat
invoke the operation
act nlay result
philosopher may eat
hungry ; test
thinking ; test
thinking ; figure
invoke the operations
easy to show
deadlocks will occur
occur we note
philosopher to starve
implementing a monitor
monitor using semaphores
mechanism using semaphores
provided a process
entering the n1onitor
leaving the monitor
process either leaves
leaves or waits
integer variable next_count
provided to count
count the number
replaced by wait
monitor is ensured
describe how condition
variables are implemented
introduce a semaphore
integer variable x_count
implemented as x_count
operation x signal
implementation is applicable
definitions of monitors
hoare and brinch-hansen
implementation is unnecessary
improvement in efficiency
leave this problem
6.7.4 resuming processes
monitor we turn
subject of process-resumption
processes are suspended
suspended on condition
operation monitor resourceallocator
busy ; condition
busy = true
busy = false
monitor to allocate
allocate a single
waiting the longest
longest is resumed
simple scheduling scheme
operation is executed
executed the value
smallest priority number
number is resumed
resourceallocator monitor shown
controls the allocation
resource among competing
processes each process
requesting an allocation
specifies the maximum
resource the monitor
allocates the resource
shortest time-allocation request
request a process
access the resource
resource in question
question must observe
instance of type
preceding access sequence
problems can occur
process might access
access a resource
resource without first
first gaining access
gaining access permission
resource a process
ntight never release
release a resource
process might attempt
attempt to release
requested a process
process might request
releasing the resource
difficulties are encountered
difficulties are similar
similar in nature
develop the monitor
higher-level programmer-defined operations
include the resourceaccess
scheduling is done
built-in monitor-scheduling algorithm
coded to ensure
programs that make
check two conditions
conditions to establish
establish the correctness
make their calls
ignore the mutual-exclusion
mutual-exclusion gateway provided
errors will occur
system this access-control
describe the synchronization
synchronization mechanisms provided
provide good examples
approaches for synchronizing
synchronizing the kernel
java monitors java
monitor-like concurrency mechanisn1
mechanisn1 for thread
synchronization every object
object in java
method is declared
method requires owning
owning the lock
object we declare
declare a synchronized
method by placing
placing the synchronized
defines the safemethod
public class simpleclass
public synchronized void
synchronized void safemethod
implementation of safemethod
assume we create
create an object
instance of simpleclass
calling the synchronized
synchronized method blocks
object s lock
lock the entry
entry set represents
represents the set
enter the method
method the lock
lock is released
exits the method
similar in function
language provides api
support for semaphores
concurrent package pthreads
package pthreads api
synchronization by developers
developers on unix
differing systems vary
vary in subtle
subtle and significant
ways 6.8.1 synchronization
synchronization in solaris
solaris to control
access to critical
solaris provides adaptive
turnstiles solaris implements
solaris implements semaphores
semaphores and condition
presented in sections
describe adaptive mlltexes
critical data item
adaptive mutex starts
standard semaphore implemented
data are locked
lock is held
holding the lock
put to sleep
spin while waiting
threads always sleep
encounter a lock
method to protect
protect only data
accessed by short
short code segments
longer code segments
variables and semaphores
issues a wait
wait and sleeps
frees the lock
issues a signal
queue the extra
cost of putting
putting a thread
thread to sleep
sleep and waking
cost of wasting
hundred instructions waiting
spinlock reader-writer locks
efficient than semaphores
threads can read
semaphores always serialize
data reader-writer locks
expensive to implement
solaris uses turnstiles
turnstiles to order
order the list
list of threads
waiting to acquire
structure containing threads
thread currently owns
owns the lock
lock will block
block and enter
enter the turnstile
selects a thread
lock each synchronized
requires a separate
associating a turnstile
object the turnstile
thread to block
object itself threads
threads subsequently blocking
thread ultimately releases
list of free
free turnstiles maintained
kernel to prevent
prevent a priority
turnstiles are organized
protocol this means
thread currently holds
holds a lock
thread is blocked
thread upon releasing
releasing the lock
thread will revert
kernel are implemented
implemented for user-level
types of locks
kernel a crucial
crucial implementation difference
priorityinheritance protocol kernel-locking
protocol kernel-locking routines
kernel priorityinheritance methods
user-level thread-locking mechanisms
provide this functionality
functionality to optimize
optimize solaris performance
developers have refined
refined and fine-tuned
fine-tuned the locking
methods because locks
crucial kernel functions
tuning their implem.entation
produce great performance
great performance gains
gains 6.8.2 synchronization
synchronization in windows
applications and multiple
accesses a global
temporarily masks interrupts
access the global
windows xp protects
access to global
resources using spinlocks
kernel uses spinlocks
protect short code
reasons of efficiency
preempted while holding
holding a spinlock
spinlock for thread
timers the system
system protects shared
protects shared data
data by requiring
requiring a tluead
tluead to gain
mutex to access
access the data
finished semaphores behave
behave as described
similar to condition
notify a waiting
desired condition occurs
expired dispatcher objects
block when acquiring
acquiring the object
thread will block
attempting to acquire
acquire the object
object we illustrate
illustrate the state
mutex lock dispatcher
lock dispatcher object
object in figure
nonsignaled dispatcher object
state changes frmn
ready to waiting
dispatcher object moves
moves to signaled
threads are waiting
owner thread releases
thread releases mutex
releases mutex lock
mutex lock thread
lock thread acquires
thread acquires mutex
acquires mutex lock
mutex lock figure
mutex dispatcher object
moves one thread
-or possibly nlore
possibly nlore threads-from
threads-from the waiting
executing the number
threads the kernel
waiting queue depends
type of dispatcher
waiting the kernel
kernel will select
select all threads
illustration of dispatcher
objects and thread
acquire a mutex
thread has released
released the lock
acquire the mutex
lock we provide
provide a programming
locks and semaphores
api 6.8.3 synchronization
synchronization in linux
kernel the linux
kernel provides spinlocks
spinlocks and semaphores
kernel on smp
fundamental locking mechanism
kernel is designed
spinlock is held
durations on single-processor
spinlocks are inappropriate
replaced by enabling
enabling and disabling
disabling kernel preemption
kernel disables kernel
disables kernel preemption
releasing the spinlock
enables kernel preemption
disable kernel preemption
acquirespin lock enable
lock enable kernel
enable kernel preemption
kernel preemption release
preemption release spin
release spin lock
spin lock linux
approach to disable
disable and enable
two simple system
simple system calls-preempldisable
disabling and enabling
enabling kernel preemption
preemption in addition
task is holding
holding a lock
lock to enforce
enforce this rule
irl the system
number of locks
locks being held
lock is acquired
preemplcount is incremented
value of preempt_count
task currently running
running is greater
safe to preempt
preempt the kernel
task currently holds
safely be interrupted
calls to preempldisable
spinlocks-along with enabling
disabling kernel preemption-are
synchronization in pthreads
pthreads the pthreads
api provides mutex
locks for thread
synchronization this api
kernel mutex locks
mutex locks represent
represent the fundamental
fundamental synchronization technique
pthreads a mutex
protect critical sections
sections of code-that
acquires the lock
section and releases
critical section condition
section condition variables
variables in pthreads
read-write locks behave
locking mechanism described
6.6.2 many systems
systems that implement
pthreads also provide
posix sem extension
extension other extensions
pthreads api include
api include spinlocks
extensions are considered
pthreads mutex locks
semaphores the mutual
exclusion of critical
critical sections ensures
sections are executed
executed atomically -that
two critical sections
result is equivalent
critical section forms
forms a single
single logical unit
account is debited
essential for data
credit and debit
consistency of data
storage and retrieval
retrieval of data
upsurge of interest
techniques in operating
operating systems operating
viewed as manipulators
manipulators of data
techniques and models
research for instance
systems to manage
flexible and powerful
formal database methods
place in sections
techniques and explain
issue of transaction
techniques are meant
meant to address
address 6.9.1 system
6.9.1 system model
model a collection
collection of instructions
single logical function
issue in processing
preservation of atomicity
possibility of failures
unit that accesses
updates various data
simply a sequence
sequence of read
write operations terminated
operation a commit
commit operation signifies
transaction has terminated
terminated its execution
abort operation signifies
transaction has transactional
emergence of multicore
pressure to develop
develop multithreaded applications
advantage of multiple
multithreaded applications present
present an increased
risk of race
conditions and deadlocks
address these issues
alternative strategy fordeveloping
strategy fordeveloping thread-safe
fordeveloping thread-safe concurrent
thread-safe concurrent applications
memory read-write operations
transaction are completed
transaction is committed
aborted and rolled
back the benefits
benefits of transactional
obtained through features
modifies shared data
written using locks
modify shared data
data i release
involves many potential
alternative to traditional
advantage of transactional
suppose we add
add the construct
rewrite the update
memoi y system
developer-isrespon.sible for guaranteeing
system can identify
identify which statements
statements in atomic
concurrent read access
programmer to identify
identify these situations
ofthreads within anapplicationgrows
anapplicationgrows transactional memory
software or hardware
hardware software transactional
software transactional memory
nam ~ suggests
imp lee ments
lee ments transactional
ments transactional memory
transactional memory exclusivelyin
memory exclusivelyin software
software ~ nospecial
hardware is needed
needed stm works
works by inserting
inserting instrumentation code
instrumentation code inside
code inside transaction
inside transaction blocks
blocks the code
code is inserted
compiler and manages
manages each transaction
transaction by examining
examining where statements
statements may run
specific lowlevellockingis required
lowlevellockingis required hardware
required hardware transactional
hardware transactional memory
hardware cache hierarchies
cache coherency protocols
protocols to manage
manage and resolve
resolve conflicts involving
conflicts involving shared
involving shared data
shared data residing
residing in separate
separate processors caches
processors caches htm
caches htm requires
requires no special
special code instmmentation
overhead than stm
htm does require
require that existing
existing cache hierarchies
hierarchies and cachecoherencyprotocolsbe
modified to support
support transactional memory
transactional memory transactional
memory transactional memory
memory has existed
years without widespread
growth of multi
multi core systems
emphasis on concurrent
programming have prompted
prompted a significant
significant amolmt ofresearch
academics and hard
hard ware vendors
intel and sun
sun microsystems ended
ended its normal
normal execution due
transaction has completed
completed its execution
modified the data
transaction had executed
atomicity is ensured
transaction started executing
ensure this property
property to determ.ine
system should ensure
first to identify
identify the properties
properties of devices
transactions various types
types of storage
media are distinguished
resilience to failure
failure volatile storage
volatile storage information
storage information residing
residing in volatile
survive system crashes
system crashes examples
storage are main
main and cache
cache merrwry access
access to volatile
directly any data
item in volatile
nonvolatile storage information
residing in nonvolatile
storage usually survives
survives system crashes
examples of m.edia
storage are disks
disks and magnetic
magnetic tapes disks
reliable than main
reliable than magnetic
tapes both disks
disks and tapes
subject to failure
result in loss
loss of inform.ation
storage is slower
slower than volatile
orders of magnitude
devices are electromechanical
electromechanical and require
require physical motion
motion to access
access data stable
data stable storage
stable storage information
residing in stable
grain of salt
theoretically such absolutes
implement an approximation
nonvolatile storage caches
independent failure modes
update the inform.ation
ensuring transaction atomicity
environment where failures
inform.ation on volatile
storage 6.9.2 log-based
6.9.2 log-based recovery
data it accesses
widely used method
achieving this form
form of recording
log record describes
describes a single
transaction that performed
performed the write
write operation data
operation data item
data item written
written old value
value the value
operation new value
write other special
special log records
log records exist
exist to record
record significant events
events during transaction
commit or abort
starts is written
commits is written
reconstructing the state
data items accessed
record is written
out to stable
prior to execution
written onto stable
stable storage note
note the performance
performance penalty inherent
system two physical
two physical writes
writes are required
logical write requested
storage is needed
fast failure recovery
functionality is worth
worth tl1e price
system can handle
handle any failure
loss of information
information on nonvolatile
storage the recovery
restores the value
updated by transaction
sets the value
values the set
set of data
undo and redo
guarantee correct behavior
restore the state
simply executing undo
system failure occurs
data by consulting
consulting the log
log to determine
determine which transactions
lmdone this classification
classification of transactions
transactions is accomplished
corrnni ts record
corrnni ts records
records 6.9.3 checkpoints
consult the log
undone in principle
search the entire
log to make
make these determinations
two major drawbacks
updated the data
modify although redoing
redoing the data
due to idempotency
longer to reduce
reduce these types
types of overhead
maintains the write-ahead
log in addition
system periodically performs
periodically performs checkpoints
checkpoints that require
sequence of actions
output all log
records currently residing
stable storage output
output all modified
modified data residing
output a log
log record checkpoint
checkpoint onto stable
systenl to streamline
streamline its recovery
commits record appears
record any modifications
written to stable
storage either prior
perform a redo
refine our previous
previous recovery algorithm
failure has occurred
recovery routine examines
examines the log
checkpoint took place
place it finds
transaction by searching
searching the log
backward to find
find the first
first checkpoint record
finding the subsequent
record once transaction
redo and undo
executing after transaction
call these transactions
record tic commits
tic commits appears
tic commits record
6.9.4 concurrent atomic
concurrent atomic transactions
case where multiple
transactions are active
transaction is atomic
execution of transactions
transactions are executed
arbih ary order
order this property
executing each transaction
common semaphore mutex
transaction starts executing
transaction either commits
commits or aborts
ensures the atomicity
concurrently executing transactions
transactions to overlap
overlap their execution
execution while maintaining
serializability a number
describe these algorithms
read and written
represented in figure
sequence of instruction
order from top
top to bottom
column and instructions
transaction is executed
serial schedule consists
valid serial schedules
schedules each serial
schedule is correct
imply an incorrect
define the notion
notion of nflic
nflic ; cing
two consecutive operations
operation to illustrate
concept of conflicting
two operations access
access different data
concurrent serializable schedule
swap the order
illustrate the swapping
swap these operations
operations to generate
generate an equivalent
initial system state
final system state
system state continuing
procedure of swapping
swapping nonconflicting operations
swap the read
swap the write
swap the wri
swaps is schedule
shown that schedule
schedule this result
swaps of nonconflicting
6.9.4.2 locking protocol
associate a lock
governs how locks
locks are acquired
acquired and released
restrict our attention
obtained a shared-mode
read this item
write q exclusive
obtained an exclusive-mode
request a lock
m.ode on data
type of operations
access data item
lock is granted
requests an exclusive
requests a shared
locked in exclusive
obtain the lock
lock and access
access q notice
readers-writers algorithm discussed
6.6.2 a transaction
transaction may unlock
unlock a data
hold a lock
accesses that item
transaction to unlock
ensured one protocol
protocol that ensures
transaction issue lock
lock and unlock
phase a transaction
transaction may obtain
release any locks
locks shrinking phase
transaction may release
initially a transaction
phase the transaction
transaction acquires locks
locks as needed
releases a lock
enters the shrinking
issued the two-phase
two-phase locking protocol
locking protocol ensures
protocol ensures conflict
ensures conflict serializability
freedom from deadlock
deadlock in addition
set of transactions
protocol to improve
performance over two-phase
impose some structure
structure or ordering
data 6.9.4.3 timestamp-based
6.9.4.3 timestamp-based protocols
locking protocols described
pairs of conflicting
transactions is determined
determined at execution
method for determining
determining the serializability
select an order
order in advance
method for doing
associate a unique
unique fixed timestamp
timestamp is assigned
transaction ti enters
enters the system
two simple methods
methods for implementing
implementing this scheme
transaction s timestamp
timestamp is equal
system this method
work for transactions
transactions that occur
occur on separate
share a clock
system the counter
assigned the timestamps
determine the serializability
produced is equivalent
transaction ~ appears
appears before transaction
two timestamp values
denotes the largest
successfully executed wri
successfully executed read
timestamps are updated
executed the timestamp
timestamp ordering protocol
ordering protocol ensures
operations are executed
executed in timestamp
order this protocol
suppose that transaction
read a value
operation is rejected
maximum of r-timestamp
producing was needed
attempting to write
write an obsolete
executed a transaction
operation is assigned
restarted to illustrate
illustrate this protocol
transaction is assigned
assigned a timestamp
protocol this execution
locking protocol howeve1
timestamp protocol ensures
serializability this capability
fact that conflicting
operations are processed
processed in timestamp
order the protocol
protocol also ensures
ensures freedom fron1
freedom fron1 deadlocl
transaction ever waits
provided to ensure
operations that ensure
overcome this obstacle
support for atomic
scheme the operating
means to guard
guard against timing
errors several language
proposed to deal
problems monitors provide
provide the synchronization
mechanism for sharing
sharing abstract data
abstract data types
types a condition
procedure can block
block its execution
signaled to continue
continue operating systems
systems also provide
support for synchronization
linux provide mechanisms
variables to control
data the pthreads
api provides support
support for mutexes
mutexes and condition
variables a transaction
executed to completion
performed to ensure
atomicity despite system
log all updates
updates are recorded
system crash occurs
updated data items
operations to reduce
reduce the overhead
overhead in searching
scheme to ensure
scheme various concurrency-control
concurrency-control schemes ensure
schemes ensure serializability
serializability by delaying
delaying an operation
operation or aborting
aborting the transaction
transaction that issued
issued the operation
protocols and timestamp
timestamp ordering schemes
first known correct
correct software sohjtion
processes was developed
developed by dekker
false i int
critical section turn
dekker s algorithm
algorithm the structure
explain why interrupts
implementing synchronization primitives
primitives in multiprocessor
correct software solution
bound on waiting
turns was presented
presented by eisenberg
eisenberg and mcguire
mcguire the processes
elements of flag
turn is immaterial
write a monitor
monitor that implements
implements an alarm
clock that enables
enables a calling
program to delay
number of tirne
assume the existence
real hardware clock
clock that invokes
invokes a procedure
monitor at regular
number the file
mcguire s algorithm
processes currently accessing
accessing the file
monitor to coordinate
exercise currently returns
leads to awkward
wishes to obtain
obtain a number
rewrite the resource-manager
resource-manager code segment
monitor and condition
process until sufficient
process to invoke
simply calling decrease_count
requires the parent
finish its execution
execution before printing
out the computed
parent thread access
access the fibonacci
thread to terminate
implement your modified
mentioned that disabling
frequently can affect
affect the system
designed to limit
connections are made
accept another incoming
connection is released
explain how semaphores
server to limit
implement the wait
operations in multiprocessor
instruction the solution
solution should exhibit
exhibit minimal busy
minimal busy waiting
suppose we replace
replace the wait
operations of monitors
single construct await
general boolean expression
true a write
scheme to implement
implement the readerswriters
problem b explain
restrict the generality
defined for semaphores
describe how volatile
stable storage differ
differ in cost
explain why implementing
primitives by disabling
consisting of processes
unique priority number
priority number write
monitor that allocates
allocates three identical
identical line printers
numbers for deciding
deciding the order
order of allocation
describe two kernel
two kernel data
include a description
condition can occur
single resource type
resources and -once
-once finished-will return
commercial software packages
software packages provide
number of licenses
indicating the number
number of applications
application is started
count is decremented
application is terminated
count is incremented
requests to start
start the application
application are denied
denied such requests
existing license holder
license holder terminates
terminates the application
license is returned
manage a finite
number of instances
resource the maximum
resources are declared
available_resources = max_resources
invokes the decrease_count
available_resources by count
count ; return
return a number
number of resourcesf
resourcesf it calls
calls the increase_count
count i int
preceding program segment
program segment produces
produces a race
identify the data
condition b identify
identify the location
race condition occurs
fix the race
modify the decrease_count
blocked until sufficient
explain why spinlocks
process each smoker
smoker continuously rolls
rolls a cigarette
roll and smoke
smoke a cigarettef
cigarettef the smoker
paperf and matches
processes has paperf
matches the agent
materials the agent
table the smoker
ij.l.gredient then makes
makes and smokes
smokes a cigarette
signaling the agent
agent on completion
completion the agent
agent then puts
cycle repeats write
write a program
program to synchronize
synchronize the agent
smokers using java
exclusion that satisfies
satisfies the bounded-waiting
lightweight synchronization tool
tool called locks
implementations of readerwriter
readerwriter locks favor
favor either readers
readers or writers
order waiting threads
slim reader-writer locks
reader-writer locks favor
favor neither readers
readers nor writers
waiting threads ordered
fifo queue explain
explain the benefits
benefits of providing
system process transactions
rolled -back transaction
-back transaction b-ut
discuss the tradeoff
tradeoff between fairness
fairness and throughput
throughput of operations
readers-writers problem propose
propose a method
method for solving
solving the readers-writers
problem without causing
signal is performed
inside a monitor
continue its execution
execution or transfer
preceding exercise differ
two different ways
term busy waiting
kinds of waiting
system can busy
waiting be avoided
avoided altogether explain
demonstrate that monitors
monitors and semaphores
semaphores are equivalent
types of synchronization
systems that provide
support for transactions
updates to data
entries are logged
explain the purpose
checkpoints be performed
frequency of checkpoints
takes to recover
write a bounded-buffer
strict mutual exclusion
makes the bounded-buffer
monitor of exercise
portions a explain
true b design
suitable for larger
functions are passed
passed the amount
deposited or withdrawn
bank account assume
assume a shared
shared bank account
bank account exists
husband and wife
concurrently the husband
calls the withdraw
wife calls deposit
done to prevent
prevent the race
condition from occurring
suppose the signal
monitor procedure suggest
problem a barbershop
enters the barbershop
chairs are occupied
leaves the shop
barber is busy
busy but chairs
barber is asleep
program to coordinate
coordinate the barber
problem in section
presented a semaphore-based
design a programming
semaphore that protects
protects the actual
insertion or removal
removal of items
standard counting semaphores
mutex the producer
producer and consumer-running
consumer-running as separate
separate threads-will move
threads-will move items
api the buffer
buffer will consist
array of type
type buffer_i tern
array of buffer_i
buffer_i tern objects
queue the definition
definition of buffer
buffer _i tern
buffer.h i typedef
typedef int buffer_item
outlining these functions
buffer i buffer_item
item into buffer
remove an object
object from buffer
condition i figure
functions will synchronize
synchronize the producer
outlined in figures
require an initialization
function that initializes
initializes the mutual-exclusion
mutual-exclusion object mutex
semaphores the main
f-lmction will initialize
initialize the buffer
buffer and create
create the separate
created the producer
function will sleep
terminate the application
application the main
passed three parameters
long to sleep
sleep before terminating
number of producer
nuncber of consumer
threads a skeleton
include buffer.h int
buffer.h int main
command line arguments
line arguments argv
create producer thread
create consumer thread
exit i figure
threads the producer
thread will alternate
alternate between sleeping
inserting a random
buffer random numbers
produces random integers
rand..max the consumer
attempt to remove
buffer an outline
consumer threads appears
first cover details
cover details specific
specific to pthreads
win32 api pthreads
api pthreads thread
pthreads thread creation
thread creation creating
creation creating threads
api is discussed
chapter for specific
instructions regarding creation
consumer using pthreads
pthreads # include
stdlib.h i required
required for rand
include buffer.h void
buffer.h void producer
generate a random
number i item
item = rand
report error condition
threads # include
include pthread.h pthread_mutex_t
pthread.h pthread_mutex_t mutex
create the mutex
lock i pthread_mutex_init
lock i pthread_mutex_lock
release the mutex
lock i pthread_mutex_unlock
code sample pthreads
sample pthreads mutex
code sample depicted
illustrates how mutex
protect a critical
critical section pthreads
pthread_mutex_t data type
type for mutex
locks a mutex
mutex is created
mutex by passing
initialize the mutex
attributes the mutex
mutex is acquired
lock is unavailable
unavailable when pthread_mutex_lock
owner invokes pthread_mutex_unlock
mutex ftmctions return
return a value
return a nonzero
error code pthreads
code pthreads semaphores
pthreads semaphores pthreads
types of semaphores-named
semaphores-named and unnamed
semaphores the code
code below illush
semaphore is created
include semaphore.h sem_t
semaphore.h sem_t sem
create the semaphore
semaphore and initialize
creates and initializes
initializes a semaphore
semaphore this function
indicating the level
semaphore s initial
semaphore.h sem_t mutex
semaphore i sem_init
acquire the semaphore
semaphore i sem_wait
release the semaphore
semaphore i sem_post
passing the flag
shared by threads
created the semaphore
semaphore a nonzero
processes to access
access the semaphore
initialize the semaphore
described the classical
semaphore operations pthreads
operations pthreads names
names the wait
,respectively the code
code example shown
creates a binary
binary semaphore mutex
protecting a critical
critical section win32
section win32 details
details concerning thread
specific instructions win32
instructions win32 mutex
win32 mutex locks
mutex locks mutex
locks mutex locks
create a mutex
include windows.h handle
windows.h handle mutex
mutex ; mutex
mutex = createmutex
first parameter refers
lock by setting
setting this attribute
attribute to null
disallowing any children
creating this mutex
lock to inherit
inherit the handle
mutex lock passing
passing a value
value off alse
creating the mutex
parameter allows naming
provide a value
mutex if successful
returns a handle
null in section
identified dispatcher objects
signaled or nonsignaled
nonsignaled a signaled
object is released
returns to signaled
signaled mutex locks
acquired by invoking
invoking the wai
passing the function
function the handle
indicating how long
long to wait
mutex lock created
parameter value infinite
wait an infinite
lock becomes nonsignaled
nonsignaled a lock
invoking re leas
win32 semaphores semaphores
mechanism as mutex
mutex locks semaphores
semaphores are created
windows.h handle sem
sem ; sem
sem = createsemaphore
first and last
last parameters identify
identify a security
described for mutex
value and maximum
returns null semaphores
semaphores are acquired
function as mutex
locks we acquire
semaphore sem created
calling thread blocks
infinite-until the semaphore
semaphore becomes signaled
operation on win32
function this function
increase the value
nonzero if successful
problem was first
paper by dijkstra
-the first correct
first correct software
mutual-exclusion problem-was developed
mathematician t dekker
dekker this algorithm
discussed by dijkstra
two-process mutual-exclusion problem
presented by peterson
presented the first
processes this solution
critical section knuth
turns a refinement
refinement of knuth
knuth s algorithm
algorithm by debruijn
reduced the waiting
succeeded in reducing
turns another algorithm
requires n-1 turns
easier to program
developed by lamport
developed the hardware-solution
algorithm that satisfies
bounded-waiting requirement general
requirement general discussions
problem were offered
offered by lamport
collection of algorithms
algorithms for mutual
concept was suggested
suggested by dijkstra
examined the question
semaphores can solve
synchronization problems parnas
flaws in patil
patil s arguments
patil s work
work to produce
produce a problem
solved by wait
discussed the limitations
primitives the classic
classic process-coordination problems
described are paradigms
problems the boundedbuffer
developed by patil
problem was suggested
suggested by courtois
issue of concurrent
writing was discussed
discussed by lamport
problem of synchronization
synchronization of independent
processes was discussed
suggested by hoare
concept was developed
developed by brinch-hansen
proposed an extension
automatic signalil1.g experience
signalil1.g experience obtained
monitors in concurrent
programs was discussed
discussed by lampson
lampson and redell
examined the priority
priority inversion problem
inversion problem general
problem general discussions
discussions concerning concurrent
programming were offered
offered by ben-ari
optimizing the performance
performance of lockil1.g
mellor-crummey and scott
sections was discussed
discussed in herlihy
kopetz and reisinger
utility in implementing
described in works
herlihy and moss
solaris were presented
presented in mauro
details of windows
found in solomon
package the write-ahead
write-ahead log scheme
scheme was first
mtroduced in system
concept of serializability
serializability was formulated
formulated by eswaran
work on concurrency
control for system
protocol was introduced
introduced by eswaran
timestampbased concurrency-control scheme
scheme was provided
provided by reed
timestamp-based concurrency-control algorithms
algorithms were explail1.ed
explail1.ed by bernstem
bernstem and goodman
discusses transactional memory
processes may compete
resources a process
process requests resources
enters a waiting
requested are held
processes this situation
deadlock we discussed
discussed this issue
cmmection with semaphores
kansas legislature early
two trains approach
prevent or deal
deal with deadlocks
applications can identify
provide deadlock-prevention facilities
remains the responsibility
responsibility of programmers
programmers to ensure
design deadlock-free programs
deadlock-free programs deadlock
programs deadlock problems
including larger numbers
numbers of processes
withirt a system
emphasis on long-lived
file and database
systems to develop
develop a description
description of deadlocks
sets of concurrent
processes from completing
completing their tasks
tasks to present
methods for preventing
preventing or avoiding
number of competing
processes the resources
resources are partitioned
number of identical
identical instances memory
instances memory space
printers and dvd
examples of resource
resource type cpu
resource type printer
requests an instance
type will satisfy
satisfy the request
resource type classes
cares which printer
prints which output
printers as equivalent
separate resource classes
printer a process
request a resource
release the resource
process may request
requires to carry
out its designated
exceed the total
request three printers
process may utilize
utilize a resource
request the process
requests the resource
acquire the resource
process can operate
process can print
release the process
releases the resource
resource the request
release of resources
resources are system
explained in chapter
memory system calls
system calls request
operations on semaphores
operating system checks
checks to make
process has requested
allocated the resource
resource a system
system table records
resource is free
free or allocated
table also records
records the process
requests a resource
resource a set
release the resources
ipc facilities discussed
illustrate a deadlocked
requests another drive
illustrates a deadlock
resource type deadlocks
involve different resource
dvd drive suppose
holding the dvd
dvd and process
holding the printer
requests the printer
requests the dvd
occurs a programmer
applications must pay
pay particular attention
problem multithreaded programs
programs are good
candidates for deadlock
deadlock because multiple
threads can compete
compete for shared
processes never finish
resources are tied
preventing other jobs
jobs from starting
methods for dealing
closely at features
features that characterize
7.2.1 necessary conditions
conditions a deadlock
situation can arise
four conditions hold
deadlock with mutex
deadlock can occur
multithreaded pthread program
program using mutex
locks the pthread....mutex_ini
initializes an unlocked
unlocked mutex mutex
mutex mutex locks
released using pthread....mutex_lock
attempts to acquire
acquire a locked
call to pthread....mutex_lock
blocks the thread
mutex lock invokes
lock invokes pthread....mutex_unlock
two mutex locks
locks are created
locks i pthread....mutex_t
first....mutex ; pthread....mutex_t
second_nmtex ; pthread....mutex_ini
threads-thread_one and thread_two--are
threads have access
mutex locks thread_one
thread_one and thread_
thread_ two run
work i pthread_mutex
work i pthread_mutex_unlock
acquires first __mutex
__mutex while thread_
thread_ two aacquites
two aacquites second__mutex
aacquites second__mutex note
occur if thread_one
acquire and release
locks for first_mutex
first_mutex and second_
thread_two attemptsto acquire
acquire the locks
illustrates a problem
problem with handling
difficult to identify
identify and test
test for deadlocks
circumstances process requests
requests that resource
hold and wait
wait a process
resource and waiting
acquire additional resources
cmrently being held
process has completed
completed its task
task circular wait
wait a set
processes must exist
pn-1 is waiting
held by p,v
p,v and p11
p11 is waiting
conditions must hold
deadlock to occur
occur the circular-wait
circular-wait condition implies
implies the hold-and-wait
separately 7.2.2 resource-allocation
7.2.2 resource-allocation graph
resource-allocation graph deadlocks
precisely in terms
graph this graph
set of vertices
set of edges
vertices vis partitioned
two different types
types of nodes
rml the set
system a directed
edge from process
signifies that process
requested an instance
instance of resource
resource a directed
edge from resource
allocated to process
pictorially we represent
represent each process
rectangle since resource
request edge points
rectangle when process
edge is inserted
longer needs access
edge is deleted
deleted the resource-allocation
resource-allocation graph shown
situation the sets
pl + rlf
p2 + r3f
rl + p2f
r2 + p2f
instances of resource
type ~ process
holding an instance
system is deadlocked
deadlock may exist
deadlock has occurred
set of resource
occurred each process
cycle is deadlocked
existence of deadlock
deadlock to illustrate
illustrate this concept
resource-allocation graph depicted
process p3 requests
two minimal cycles
minimal cycles exist
held by process
process p3 process
waiting for process
graph in figure
observe that process
release its instance
breaking the cycle
cycle in summary
state this observation
observation is important
deadlock problem figure
protocol to prevent
prevent or avoid
enter a deadlocked
system to enter
ignore the problem
altogether and pretend
pretend that deadlocks
deadlocks never occur
developer to write
programs that handle
present detailed algorithms
algorithms before proceeding
researchers have argued
spectrum of resource-allocation
problems in operating
systems the basic
select an optimal
class of resources
ensure that deadlocks
set of methods
methods for ensuring
hold these methods
methods prevent deadlocks
deadlocks by constraining
constraining how requests
made we discuss
discuss these methods
methods in section
advance additional information
process will request
process should wait
wait to decide
resources currently allocated
requests and releases
process we discuss
discuss these schemes
schemes in section
situation may arise
system can provide
provide an algorithm
algorithm that examines
examines the state
system to determine
algorithm to recover
discuss these issues
issues in section
absence of algorithms
algorithms to detect
detect and recover
recover from deadlocks
deadlock will result
result in deterioration
system s performance
held by processes
system will stop
method is cheaper
detection and recovery
real-time process running
manual recovery methods
techniques for deadlock
noted in section
four necessary conditions
hold by ensuring
prevent the occurrence
deadlock we elaborate
approach by examining
separately 7.4.1 mutual
7.4.1 mutual exclusion
exclusion the mutual-exclusion
condition must hold
hold for nonsharable
processes sharable resources
require mutually exclusive
mutually exclusive access
deadlock read-only files
attempt to open
open a read-only
granted simultaneous access
file a process
resource in general
deadlocks by denying
denying the mutual-exclusion
nonsharable 7.4.2 hold
wait to ensure
condition never occurs
resources one protocol
requires each process
implement this provision
provision by requiring
requiring that system
system calls requesting
calls requesting resources
calls an alternative
request some resources
request any additional
allocated to illustrate
illustrate the difference
process that copies
file on disk
sorts the file
prints the results
request the dvd
hold the printer
drive and disk
file it copies
file the process
request the disk
printer after copying
copying the disk
resources and terminates
two main disadvantages
allocated but unused
release the dvd
file and printe1
data will remain
request all resources
7.4.3 no preemption
condition for deadlocks
preemption of resources
allocated to ensure
process is holding
holding some resources
resources and requests
requests another resource
resources the process
holding are preempted
released the preempted
resources are added
list of resources
requests some resources
waiting for additional
preempt the desired
process and allocate
requesting and recovers
recovers any resources
waiting this protocol
applied to resources
resources whose state
registers and memory
generally be applied
resources as printers
printers and tape
.4.4 circular wait
wait the fourth
fourth and final
condition never holds
impose a total
order of enumeration
enumeration to illustrate
types we assign
type a unique
unique integer number
compare two resources
define a one-to-one
set of natural
types r includes
includes tape drives
process can request
request any number
resource type -say
drive and printer
request the tape
request the printer
requesting an instance
released any resources
type are needed
demonstrate this fact
fact by assuming
circular wait exists
proof by contradiction
resource r11 held
accomplish this scheme
program by developing
developing an ordering
system all requests
requests for synchronization
made in increasing
pthread program shown
request the locks
out of order
mind that developing
programs that follow
follow the ordering
ordering also note
order of usage
reasonable to define
ensuring that resources
resources are acquired
responsibility of application
verify that locks
give appropriate warnings
warnings when locks
order and deadlock
works on bsd
witness uses mutual-exclusion
locks to protect
maintaining the relationship
relationship of lock
assume that thread_one
first to acquire
second_mutex wih1ess records
records the relationship
relationship that first_mutex
acquired before second_mutex
second_mutex if thread_two
acquires the locks
generates a warning
note that imposing
imposing a lock
guarantee deadlock prevention
prevention if locks
function that transfers
accounts to prevent
prevent a race
lock2 ; lock1
lock2 = getlock
threads simultaneously invoke
invoke the trans
transposing different accounts
thread might invoke
exercise for students
students to fix
fix this situation
situation deadlock-prevention algorithms
deadlocks by restraining
restraining how requests
made the restraints
conditions for deadlock
hold possible side
effects of preventing
low device utilization
utilization and reduced
reduced system throughput
throughput an alternative
method for avoiding
require additional information
first the tape
printer before releasing
releasing both resources
first the printer
sequence of requests
system can decide
wait in order
deadlock each request
decision the system
amount and type
type of information
required the simplest
declare the maximum
construct an algorithm
algorithm that ensures
defines the deadlock-avoidance
approach a deadlock-avoidance
algorithm dynamically examines
examines the resource-allocation
state to ensure
exist the resource-allocation
state is defined
explore two deadlock-avoidance
two deadlock-avoidance algorithms
algorithms 7.5.1 safe
7.5.1 safe state
state a state
state is safe
system can allocate
avoid a deadlock
exists a safe
sequence a sequence
sequence of processes
current allocation state
complete its designated
return its allocated
obtain its needed
unsafe a safe
states are deadlocks
state may lead
system can avoid
processes from requesting
occurs the behavior
processes controls unsafe
controls unsafe states
unsafe states figure
deadlocked state spaces
deadlocks to illustrate
system with twelve
twelve magnetic tape
magnetic tape drives
process po requires
requires ten tape
ten tape drives
four tape drives
tape drives suppose
holding five tape
holding two tape
two tape drives
free tape drives
maximum needs current
state the sequence
satisfies the safety
safety condition process
immediately be allocated
drives and return
ten available tape
twelve tape drives
unsafe state suppose
process p2 requests
drive the system
four available tape
drives since process
allocated five tape
maximum of ten
request six additional
additional tape drives
deadlock our mistake
granting the request
request from process
made p2 wait
processes had finished
finished and released
released its resources
avoided the deadlock
define avoidance algorithms
algorithms that ensure
deadlock the idea
simply to ensure
wait the request
7.5.2 resource-allocation-graph algorithm
resource-allocation graph defined
defined in section
7.2.2 for deadlock
avoidance in addition
request and assignment
edges already described
type of edge
edge a claim
future this edge
resembles a request
edge in direction
line when process
process pi requests
graph for deadlock
claimed a priori
relax this condition
condition by allowing
allowing a claim
edges now suppose
converting the request
graph we check
check for safety
algorithm an algorithm
algorithm for detecting
detecting a cycle
requires an order
resource will leave
leave the system
cycle is found
allocation will put
put the system
satisfied to illustrate
illustrate this algorithm
graph of figure
action will create
create a cycle
banker s algorithm
algorithm the resource-allocation-graph
type the deadlockavoidance
resource-allocation graph scheme
scheme this algorithm
bank never allocated
requests a set
set of resources
system must determine
resources will leave
releases enough resources
resources several data
maintained to implement
implement the banker
algorithm these data
data structures encode
encode the state
number of resource
vector of length
defines the maximum
process if max
type ri allocation
defines the number
type currently allocated
process if allocation
allocated lc instances
complete its task
data structures vary
size and value
value to simplify
simplify the presentation
establish some notation
andy be vectors
vectors of length
treat each row
allocation ; specifies
specifies the resources
specifies the additional
resources that process
request to complete
task 7.5.3.1 safety
7.5.3.1 safety algorithm
present the algorithm
algorithm for finding
state this algorithm
work and finish
finish be vectors
find an index
work = work
work + allocation
allocation ; finish
algorithm may require
require an order
operations to determine
safe 7.5.3.2 resource-request
7.5.3.2 resource-request algorithm
algorithm for determining
determining whether requests
granted let request
vector for process
request for resources
resources is made
made by process
raise an error
process has exceeded
exceeded its maximum
claim if request
allocated the requested
resources to process
modifyil1.g the state
resulting resource-allocation state
transaction is completed
allocated its resources
state is unsafe
wait for request
state is restored
7.5.3.3 an illustrative
max available abc
abc abc abc
safety criteria suppose
process p1 requests
requests one additional
check that request1
execute our safety
algorithm and find
grant the request
request of process
unsafe we leave
students to implement
situation may occur
occurred an algorithm
pertain to systems
detection-and-recovery scheme requires
scheme requires overhead
overhead that includes
costs of maintaining
information and executing
executing the detection
potential losses inherent
inherent in recovering
deadlock 7.6.1 single
7.6.1 single instance
define a deadlockdetection
graph we obtain
obtain this graph
graph by removing
removing the resource
nodes and collapsing
wait-for graph implies
implies that process
iil a wait-for
present a resource-allocation
cycle to detect
maintain the wait-for
invoke an algorithm
algorithm that searches
graph an algorithm
algorithm to detect
detect a cycle
number of vertices
7.6.2 several instances
type the wait-for
wait-for graph scheme
type we turn
system the algorithm
employs several time-varying
time-varying data structures
type allocation ann
wait-for graph request
process if request
vectors is defined
7.5.3 to simplify
treat the rows
allocation and request
request as vectors
detection algorithm described
processes that remain
compare this algorithm
algorithm of section
7.5.3 let work
false b request
deadlocked this algorithm
operations to detect
reclaim the resources
resources of process
determine that request
attitude and assume
resources to complete
assumption is incorrect
deadlock may occur
tince the deadlock-detection
algorithm is invoked
invoked to illustrate
request available abc
execute our algorithm
plt p4 results
results in finish
process p2 makes
makes one additional
matrix is modified
sufficient to fulfill
fulfill the requests
7.6.3 detection-algorithm usage
invoke the detection
algorithm the answer
affected by deadlock
invoked frequently resources
frequently resources allocated
allocated to deadlocked
broken in addition
cycle may grow
grow deadlocks occur
makes a request
immediately this request
request that completes
completes a chain
chain of waiting
invoke the deadlockdetection
request for allocation
process that caused
caused the deadlock
request may create
create many cycles
request and caused
invoking the deadlock-detection
request will incur
incur considerable overhead
overhead in computation
simply to invoke
invoke the algorithm
algorithm at defined
cpu utilization drops
deadlock eventually cripples
eventually cripples system
cripples system throughput
utilization to drop
invoked at arbitrary
deadlocked processes caused
detection algorithm determines
inform the operator
manually another possibility
options for breaking
breaking a deadlock
simply to abort
processes to break
break the circular
preempt some resources
processes 7.7.1 process
7.7.1 process termination
termination to eliminate
deadlocks by aborting
aborting a process
reclaims all resources
terminated processes abort
abort all deadlocked
processes this method
break the deadlock
recomputed later abort
abort one process
cycle is eliminated
eliminated this method
method incurs considerable
incurs considerable overhead
process is aborted
deadlock-detection algorithnc rnust
rnust be invoked
invoked to determine
updating a file
leave that file
midst of printing
system must reset
reset the printer
state before printing
partial termination method
determine which deadlocked
terminated this determination
similar to cpu-scheduling
decisions the question
basically an economic
abort those processes
processes whose termination
termination will incur
incur the minimum
term minimum cost
factors may affect
affect which process
process is chosen
long the process
process has computed
longer the process
process will compute
compute before completing
completing its designated
types of resources
resources are simple
simple to preempt
order to complete
process is interactive
interactive or batch
batch 7.7.2 resource
7.7.2 resource preemption
preemption to eliminate
deadlocks using resource
resources from processes
processes and give
give these resources
processes 1-m til
til the deadlock
cycle is broken
broken if preemption
preemption is required
required to deal
selecting a victim
victim which resources
process termil ation
order of preemption
preemption to minimize
minimize cost cost
cost cost factors
factors may include
include such parameters
resources a deadlocked
preempt a resource
missing some needed
back the process
state and restart
difficult to determine
abort the process
effective to roll
requires the system
running processes starvation
ensure that starvation
guarantee that resources
system where victim
selection is based
primarily on cost
process never completes
completes its designated
include the number
number of rollbacks
factor a deadlocked
deadlocked state occurs
dealing with deadlocks
windows a deadlock
wait to prevent
conditions never holds
holds a method
process will utilize
utilize system resources
resources the banker
requires a priori
define a deadlockavoidance
employ a protocol
protocol to ensure
employed a deadlockdetection
invoked to detennine
deadlock is detected
system must recover
processes where preemption
system that selects
victims for rollback
basis of cost
starvation may occur
designated task researchers
single-lane bridge connects
two vermont villages
villages of north
tunbridge and south
south tunbridge farmers
bridge to deliver
deliver their produce
town the bridge
farmers are stubborn
unable to back
design an algorithm
algorithm that prevents
concerned about starvation
northbound farmers prevent
farmers prevent southbound
prevent southbound farmers
modify your solution
two resources show
system is deadlock
traffic deadlock depicted
state a simple
rule for avoiding
real computer system
demands of processes
processes for resources
resources are consistent
resources are bought
bought and added
system if deadlock
deadlock is controlled
deadlock for exercise
introducing the possibility
possibility of deadlock
circumstances a increase
resource permanently removed
removed from system
resources than allowed
processes f decrease
decrease the number
obtain the banker
simply by reducing
reducing the dimensionality
implement the multiple-resource-type
banker s scheme
scheme by applying
applying the sil1.gle-resource-type
resource type individually
resource-allocation policy requests
releases of resources
resources are allowed
check any processes
waiting for resources
process the vector
vector of resources
waiting is increased
increased to include
include the resources
vector available initialized
process po asks
indefinite blocking occur
blocking occur explain
method for preventing
multiple threads attempt
access the synchronization
objects may include
prevent the deadlock
deadlock by adding
adding a sixth
acquire the synchronization
lock for object
locks for objects
object f compare
compare this scheme
scheme of section
compare the circular-wait
banker s algorithnc
overheads b system
abcd abcd abcd
process p1 arrives
request be granted
type being shared
request or release
two conditions hold
system that runs
runs 5,000 jobs
jobs per month
deadlock-prevention or deadlock-avoidance
deadlock-avoidance scheme deadlocks
scheme deadlocks occur
operator must terminate
terminate and rerun
jobs per deadlock
deadlock each job
job is worth
jobs terminated tend
aborted a systems
programmer has estimated
percent on average
arguments for installing
installing the deadlock-avoidance
arguments against installing
discuss how deadlocks
avoided by eliminating
optimistic assumption made
assumption be violated
assume that requests
requests for chopsticks
chopsticks are made
describe a simple
rule for determining
satisfied without causing
allocation of chopsticks
chopsticks to philosophers
single process explain
preceding question assume
requires three chopsticks
chopsticks to eat
eat resource requests
describe some simple
rules for determining
describe a situation
deadlock by ensuring
out that deadlock
invoke the transaction
fix the transaction
function to prevent
program that implements
implements the banker
section 7.5.3 create
create n threads
threads that request
bank the banker
banker will grant
important that shared
data be safe
safe from concurrent
access to ensure
ensure safe access
libraries is described
project entitled producer-consumer
entitled producer-consumer problem
end of chapter
deadlock area holt
person to formalize
formalize the notion
notion of deadlocks
deadlocks in terms
allocation-graph model similar
covered by holt
provided the deadlock
legislature a recent
study of deadlock
handling is provided
provided in levine
algorithms were suggested
suggested by havender
devised the resource-ordering
ibm os systenl
systenl the banker
algorithm for avoiding
deadlocks was developed
type by dijkstra
extended to multiple
multiple resource types
types by habermaml
algorithm for multiple
presented by coffman
traditional unix kernel
unix kernel handle
kernel handle deadlock
handle deadlock solutions
solutions to deadlock
problems in networks
networks are discussed
discussed in works
rodeheffer and schroeder
witness lock-order verifier
verifier is presented
presented in baldwin
four the main
programs these programs
data they access
partially in main
memory during execution
execution to improve
response to users
memory many memory-management
memory-management schemes exist
reflecting various approaches
system most algorithms
algorithms require hardware
require hardware support
result of cpu
users to realize
realize this increase
increase in performance
discuss various ways
ways to manage
memory the memorymanagement
memorymanagement algorithms vary
primitive bare-machine approach
approach to paging
paging and segmentation
strategies each approach
specific system depends
integrated the hardware
hardware and operating
provide a detailed
ways of organizing
organizing memory hardware
hardware to discuss
discuss various memory-management
segmentation to provide
supports both pure
segmentation and segmentation
segmentation with paging
computer system memory
system memory consists
address the cpu
cpu fetches instructions
instructions from memory
counter these instructions
storing to specific
addresses a typical
fetches an instruction
instruction from memory
memory the instruction
memory the mernory
mernory unit sees
hozu a program
generates a memory
program we begin
discussion by covering
covering several issues
techniques for managing
memory this coverage
includes an overview
overview of basic
basic hardware issues
binding of symbolic
symbolic memory addresses
addresses to actual
actual physical addresses
distinction between logical
logical and physical
addresses we conclude
conclude the section
loading and linking
code and shared
libraries 8.1.1 basic
8.1.1 basic hardware
basic hardware main
hardware main memory
cpu can access
addresses as arguments
instructions in execution
direct-access storage devices
cpu can operate
clock most cpus
cpus can decode
instructions and perform
perform simple operations
operations on register
operations per clock
memory bus completing
completing a memory
required to complete
complete the instruction
executing this situation
situation is intolerable
frequency of memory
accesses the remedy
add fast memory
lj.o i process
limit register define
memory a memory
accommodate a speed
speed of accessing
accessing physical memory
operation to protect
protect the operating
system from access
access by user
protect user processes
separate memory space
determine the range
range of legal
process may access
provide this protection
holds the smallest
smallest legal physical
legal physical memory
physical memory address
base register holds
access all addresses
protection of memory
space is accomplished
cpu hardware compare
compare every address
generated in user
registers any attempt
executing in user
mode to access
access operating-system memory
users  memory
treats the attempt
prevents a user
modifying the code
code or data
users the base
special privileged instruction
instruction since privileged
system can load
load the base
registers this scheme
registers but prevents
prevents user programs
programs from changing
changing the registers
registers  contents
contents the operating
executing in kernel
operating system memory
memory and users
system to load
users  programs
programs into users
trap to operating
operating system monitor-addressing
system monitor-addressing error
monitor-addressing error memory
error memory figure
hardware address protection
protection with base
out those programs
programs in case
case of errors
access and modify
parameters of system
8.1.2 address binding
binary executable file
moved between disk
disk and memory
execution the processes
load that process
process into memory
process to reside
affects the addresses
optional-before bein.g executed
bind these symbolic
addresses to relocatable
editor or loader
bind the relocatable
addresses to absolute
binding of instructions
data to memory
process will reside
reside in memory
starting at location
generated compiler code
code will start
location and extend
recompile this code
code the ms-dos
ms-dos .com-format programs
programs are bound
bound at compile
compile time load
compiler must generate
binding is delayed
delayed until load
reload the user
code to incorporate
incorporate this changed
changed value execution
delayed until run
run time special
scheme to work
8.1.3 most general-purpose
11se this method
method a major
chapter is devoted
devoted to showing
discussing appropriate hardware
program 8.1.3 logical
8.1.3 logical versus
logical versus physical
versus physical address
physical address space
space an address
memory-is commonly referred
compile-time and load-time
load-time address-binding methods
address-binding methods generate
methods generate identical
generate identical logical
execution-time addressbinding scheme
addressbinding scheme results
results in differing
logical and addresses
address and virtual
text the set
logical addresses generated
logical the set
in_ the execution-time
execution-time address-binding scheme
physical address spaces
address spaces differ
differ the run-time
mapping from virtual
virtual to physical
addresses is done
methods to accomplish
accomplish such mapping
relocation register sections
illustrate this mapping
simple mmu scheme
base-register scheme described
8.1.1 the base
register is added
user to address
relocated to location
access to location
mapped to location
operating system running
intel 80x86 family
family of processors
four relocation registers
registers when loading
loading and running
processes the user
program never sees
sees the real
real physical addresses
addresses the program
program can create
create a pointer
pointer to location
register the user
user program deals
deals with logical
addresses the memory-mapping
memory-mapping hardware converts
hardware converts logical
converts logical addresses
addresses into physical
addresses this form
form of execution-time
binding was discussed
8.1.2 the final
referenced memory address
reference is made
types of addresses
tor + max
generates only logical
addresses and thinks
runs in locations
max the user
user program generates
mapped to physical
separate physical address
space is central
central to proper
proper memory management
management 8.1.4 dynamic
8.1.4 dynamic loading
execute the size
size of physical
memory to obtain
obtain better memory-space
dynamic with dynancic
relocatable load format
format the main
call another routine
routine first checks
relocatable linking loader
load the desired
routine into menwry
update the program
tables to reflect
reflect this change
change then control
newly loaded routine
routine the advantage
advantage of dynamic
loaded this method
amounts of code
code are needed
needed to handle
handle infrequently occurring
infrequently occurring cases
total program size
smaller dynamic loading
require special support
users to design
design their programs
method operating systems
providing library routines
routines to implement
implement dynamic loading
loading 8.1.5 dynamic
8.1.5 dynamic linking
linking and shared
shared libraries figure
shows some operating
support only linking
system language libraries
libraries are treated
binary program image
program image dynamic
image dynamic linking
similar to dynamic
postponed until execution
language subroutine libraries
system must include
include a copy
image this requirement
wastes both disk
space and main
memory with dynamic
stub is included
reference the stub
memory-resident library routine
load the library
stub is executed
loads the routine
routine into memory
routine and executes
executes the routine
segment is reached
routine is executed
incurring no cost
cost for dynamic
language library execute
code this feature
extended to library
programs that reference
reference the library
version without dynamic
relinked to gain
versions of libraries
information is included
information to decide
decide which copy
versions with minor
minor changes retain
versions with major
major changes increment
increment the number
version are affected
incompatible changes incorporated
library was installed
installed will continue
library this system
unlike dynamic loading
linking generally requires
memory are protected
addresses we elaborate
paging in section
8.4.4 a process
executed a process
memory for continued
assume a multiprogramming
round-robin cpu-scheduling algorithm
manager will start
start to swap
out the process
swap another process
scheduler will allocate
finishes its quantum
manager can swap
reschedule the cpu
cpu in addition
amounts of computing
done between swaps
swaps a variant
higher-priority process arrives
out the lower-priority
load and execute
execute the higher-priority
higher-priority process finishes
out @ swap
swap in backing
backing store main
store main memory
main memory figure
continued this variant
variant of swapping
space it occupied
previously this restriction
restriction is dictated
method of address
binding if binding
binding is done
assembly or load
location if execution-time
addresses are computed
computed during execution
execution time swapping
requires a backing
store the backing
commonly a fast
provide direct access
images the system
maintains a consisting
processes whose memory
cpu scheduler decides
decides to execute
calls the dispatcher
free memory region
out a process
memory and swaps
registers and transfers
process the context-switch
standard hard disk
main memory takes
assuming an average
out and swap
resident operating system
operating system taking
smaller than this-say
required for swapping
memory a user
process with dynamic
dynamic memory requirements
issue system calls
memory and release
inform the operating
memory needs swapping
swapping is constrained
swap a process
i a process
swap that process
process to free
free up memory
accessing the user
operation is queued
device is busy
swap out process
swap in process
belongs to process
two main solutions
process with pending
execute i operations
operating-system buffers transfers
transfers between operating-system
buffers and process
memory then occur
explanation we postpone
discussing this issue
issue until chapter
structure is covered
space is allocated
chunk of disk
systems it requires
reasonable memory-management solution
memory-management solution modified
solution modified versions
versions of swapping
systems a modification
modification of swapping
processes are running
system is reduced
reduced memory management
management in unix
fully in sections
a.6 early pcs-which
early pcs-which lacked
lacked the sophistication
sophistication to implement
implement more advanced
advanced memory-management methods-ran
memory-management methods-ran multiple
methods-ran multiple large
multiple large processes
version of swapping
swapping a prime
supports concurrent execution
execution of processes
process is loaded
insufficient main memory
swapped to disk
disk this operating
provide full swapping
preempt one process
swapped-out process remains
process remains swapped
selects that process
process to run
run subsequent versions
versions of microsoft
systems take advantage
advanced mmu features
features now found
found in pcs
pcs we explore
explore such features
features in section
cover virtual memory
memory must accommodate
allocate main menlory
explains one common
allocation the memory
place the operating
memory or high
memory the major
major factor affecting
affecting this decision
programmers usually place
system in low
resides in low
memory the development
situation is similar
processes to reside
allocate available memory
input queue waiting
process is contained
single contiguous section
section of memory
memory 8.3.1 memory
8.3.1 memory mapping
mapping and protection
protection before discussing
discussing memory allocation
discuss the issue
issue of memory
provide these features
8.1.1 the relocation
relocation register contaitls
contaitls the value
smallest physical address
range of logical
relocation and limit
maps the logical
dynamically by adding
adding the value
register this mapped
cpu scheduler selects
process for execution
loads the relocation
values as part
cpu is checked
process the relocation-register
system s size
size to change
dynamically this flexibility
flexibility is desirable
system contains code
code and buffer
space for device
data in memory
purposes such code
transient operating-system code
system during program
execution 8.3.2 memory
8.3.2 memory allocation
ready to turn
turn to memory
methods for allocating
fixed-sized each partition
degree no trap
addressing error figure
hardware supportfor relocation
multiprogramming is bound
number of partitions
partition is free
process is selected
process this method
ibm os operating
os operating system
primarily in batch
indicating which parts
considered one large
set of holes
sizes as processes
queue the operating
takes into account
account the memory
space in determining
determining which processes
processes are allocated
compete for cpu
releases its memory
system can order
order the input
scheduling algorithm memory
memory is allocated
allocated to processes
block of memory
hold that process
large enough block
smaller memory requirements
met in generat
generat as mentioned
blocks available comprise
comprise a set
scattered throughout memory
searches the set
parts one part
part is allocated
releases its block
hole is adjacent
holes are merged
merged to form
form one larger
freed and recombined
memory could satisfy
satisfy the demands
processes this procedure
general which concerns
satisfy a request
request of size
select a free
holes first fit
first fit allocate
allocate the first
big enough searching
searching can start
previous first-fit search
first-fit search ended
find a free
allocate the smallest
list is ordered
ordered by size
size this strategy
produces the smallest
smallest leftover hole
leftover hole worst
hole worst fit
worst fit allocate
allocate the largest
sorted by size
produces the largest
largest leftover hole
smaller leftover hole
best-fit approach simulations
simulations have shown
fit in terms
terms of decreasing
utilization neither first
terms of storage
faster 8.3.3 fragmentation
first-fit and best-fit
strategies for memory
memory allocation suffer
suffer from external
external as processes
processes are loaded
loaded and removed
removed from memory
free memory space
space is broken
pieces external fragmentation
external fragmentation exists
total memory space
space to satisfy
contiguous ; storage
storage is fragmented
number of small
holes this fragmentation
block of free
pieces of memory
big free block
first-fit or best-fit
strategy can affect
amount of fragmentation
block is allocated
matter which algorithm
average process size
major problem statistical
problem statistical analysis
analysis of first
lost to fragmentation
one-third of memory
multiple-partition allocation scheme
18,464 bytes suppose
requests 18,462 bytes
bytes the overhead
approach to avoiding
avoiding this problem
break the physical
memory into fixed-sized
blocks and allocate
memory in units
based on block
memory the difference
numbers is internal
partition one solution
problem of external
shuffle the memory
place all free
large block compaction
relocation is static
done ; compaction
relocation is dynamic
done at execution
addresses are relocated
requires only moving
moving the program
changing the base
register to reflect
address when compaction
determine its cost
cost the simplest
simplest compaction algorithm
move all processes
end of memory
producing one large
memory this scheme
permit the logical
allocated physical memory
two complementary techniques
complementary techniques achieve
achieve this solution
scheme that permits
permits the physical
space a process
noncontiguous paging avoids
paging avoids external
avoids external fragmentation
solves the considerable
problem of fitting
fitting memory chunks
chunks of varying
introduction of paging
problem the problem
fragments or data
fragmentation problems discussed
discussed in connection
connection with main
compaction is impossible
advantages over earlier
operating systems physical
systems physical address
physical address foooo
page table figure
hardware 1---------1 physical
1---------1 physical memory
support for paging
handled by hardware
integrating the hardware
microprocessors 8.4.1 basic
8.4.1 basic method
method the basic
method for implementing
implementing paging involves
paging involves breaking
involves breaking physical
breaking physical memory
blocks called harnes
harnes and breaking
breaking logical memory
memory into blocks
pages are loaded
store is divided
divided into fixed-sized
frames the hardware
paging is illustrated
generated the cpu
cpu is divided
page in physical
memory this base
address is combined
offset to define
define the physical
unit the paging
model of memory
hardware the size
typically a power
architecture the selection
page size makes
makes the translation
number and page
offset particularly easy
bytes or wordst
logical address designate
designate the page
low-order bits designate
page table frame
table frame number
frame number physical
number physical memory
physical memory figure
model of logical
page number page
number page offset
view of memory
mapped into physical
physical memory logical
memory logical address
find that page
maps to physical
mapped to frame
noticed that paging
form of dynamic
relocation every logical
address is bound
address using paging
paging is similar
table of base
frame of memory
page table logical
table logical memory
logical memory physical
memory physical memory
memory with 4-byte
internal fragmentation notice
notice that frames
frames are allocated
allocated as units
happen to coincide
coincide with page
last frame allocated
resulting in internal
frame if process
size is independent
independent of page
expect internal fragmentation
fragmentation to average
average one-half page
page per process
process this consideration
suggests that small
small page sizes
sizes are desirable
overhead is involved
overhead is reduced
data being transferred
transferred is larger
sizes have grown
support even larger
larger page sizes
sizes some cpus
cpus and kernels
kernels even support
support multiple page
multiple page sizes
sizes for instance
solaris uses page
support for variable
variable on-the-fly page
on-the-fly page size
size can vary
entry can point
physical page frames
frames if frame
system with 4-byte
entries can address
expressed in pages
examined each page
process the first
number is put
aspect of paging
actual physical memory
memory the user
user program views
program views memory
program in fact
program is scattered
scattered throughout physical
holds other programs
programs the difference
memory is reconciled
hardware the logical
addresses are translated
translated into physical
addresses this mapping
mapping is hidden
operating system notice
process by definition
definition is unable
unable to access
system is managing
managing physical memory
details of physical
physical memory-which frames
frame the frame
physical page frame
process or processes
free-frame list free-frame
list free-frame list
new-process page table
allocation in addition
aware that user
user processes operate
operate in user
mapped to produce
produce physical addresses
makes a system
produce the correct
correct physical address
address the operating
operating system maintains
maintains a copy
counter and register
contents this copy
translate logical addresses
addresses to physical
system must map
map a logical
physical address manually
dispatcher to define
define the hardware
hardware page table
paging therefore increases
increases the context-switch
8.4.2 hardware support
support each operating
methods for storing
storing page tables
tables most allocate
allocate a page
process a pointer
table is stored
dispatcher is told
told to start
start a process
registers and define
define the correct
correct hardware page-table
hardware page-table values
stored user page
user page table
table the hardware
table is implemented
set of dedicated
dedicated these registers
logic to make
make the paging-address
paging-address translation efficient
efficient every access
access to memory
consideration the cpu
cpu dispatcher reloads
reloads these registers
instructions to load
load or modify
modify the page-table
system can change
change the memory
map the dec
architecture the address
table thus consists
table is satisfactory
registers to implement
implement the page
page table changing
table changing page
changing page tables
page tables requires
tables requires changing
substantially reducing context-switch
required to access
access a user
user memory location
page number fori
fori this task
requires a memory
offset to produce
produce the actual
access the desired
place in memory
two memory accesses
accesses are needed
needed to access
access a byte
access is slowed
resort to swapping
fastlookup hardware cache
bc.1her the tlb
tlb is associative
memory each entry
memory is presented
item is compared
item is found
field is returned
returned the search
search is fast
number of entries
tlb is small
1,024 the tlb
number is presented
number is found
unmapped memory reference
number is obtained
add the page
number and frame
full of entries
replacement replacement policies
replacement policies range
entries for kernel
code are wired
entry an asid
asid uniquely identifies
identifies each process
provide address-space protection
attempts to resolve
resolve virtual page
virtual page numbers
running process matches
matches the asid
attempt is treated
miss in addition
addition to providing
providing address-space protection
support separate asids
table is selected
wrong translation information
tlb could include
include old entries
tlb hit tlb
tlb p tlb
tlb miss page
miss page table
hardware with tlb
tlb physical memory
memory contain valid
valid virtual addresses
incorrect or invalid
invalid physical addresses
physical addresses left
process the percentage
percentage of times
80-percent hit ratio
find the desired
desired page number
nanoseconds to search
search the tlb
nanoseconds to access
mapped-memory access takes
fail to find
find the page
first access memory
table and frame
byte in memory
nanoseconds to find
find the effective
weight the case
suffer a 40-percent
slowdown in memory-access
98-percent hit ratio
nanoseconds this increased
increased hit rate
hit rate produces
slowdown in access
explore the impact
tlb in chapter
8.4.3 protection memory
protection memory protection
environment is accomplished
accomplished by protection
table one bit
bit can define
define a page
read-write or read-only
read-only every reference
reference to memory
find the correct
correct frame nuncber
checked to verify
page an attempt
attempt to write
expand this approach
approach to provide
provide a finer
level of protection
hardware to provide
providing separate protection
separate protection bits
kind of access
accesses illegal attempts
system one additional
set to valid
process s logical
set to invalid
address space illegal
space illegal addresses
addresses are trapped
valid -invalid bit
bit the operating
sets this bit
14-bit address space
number j valid-invalid
---------  page
page n figure
table any attempt
attempt to generate
generate an address
address in pages
computer will trap
trap to flee
flee operating system
invalid page reference
scheme has created
created a problem
address is illegal
howeve1 ~ references
references to page
classified as valid
accesses to addresses
invalid this problem
2-kb page size
size and reflects
reflects the internal
fragmentation of paging
range in fact
fact many processes
cases to create
create a page
table with entries
valuable memory space
space some systems
systems provide hardware
page table value
value is checked
address to verify
system 8.4.4 shared
8.4.4 shared pages
pages an advantage
advantage of paging
possibility of sharing
sharing common code
code this consideration
executes a text
text editor consists
three-page editor-each page
large page size
simplify the figure
data page reentrant
page reentrant code
code is non-self-modifying
copy of registers
registers and data
storage to hold
hold the data
process s execution
execution the data
memory each user
user s page
page table maps
pages are mapped
space per user
user the total
total space required
8,000 kb-a significant
kb-a significant savings
heavily used programs
reentrant the read-only
nature of shared
system should enforce
enforce this property
property the sharing
sharing of memory
memory among processes
task by threads
described shared memory
process p1 process
process p3 page
sharing of code
corrununication some operating
operating systems implement
systems implement shared
implement shared memory
memory using shared
shared pages organizing
pages organizing memory
pages provides numerous
benefits in addition
addition to allowing
allowing several processes
benefits in chapter
techniques for structuring
structuring the page
table 8.5.1 hierarchical
8.5.1 hierarchical paging
paging most modern
large logical address
32-bit logical address
table may consist
4mb of physical
allocate the page
contiguously in main
memory one simple
divide the page
table into smaller
accomplish this division
two-level paging algorithm
page table memory
table memory figure
two-level page-table scheme
scheme a 32-bit
address is divided
page number consisting
page offset consisting
page the page
10-bit page number
10-bit page offset
outer page table
table the address-translation
architecture is shown
address translation works
vax architecture supports
supports a variation
variation of two-level
paging the vax
bytes the logical
process is divided
four equal sections
bytes each section
represent the logical
logical page number
represent an offset
page by partitioning
partitioning the page
page outer page
two-level 32-bit paging
32-bit paging architecture
system can leave
leave partitions unused
section page offset
designates the section
one-level page table
bytes per entry
pages the user-process
user-process page tables
64-bit logical address
two-level paging scheme
illustrate this point
page table consists
iml.er page tables
entries the addresses
page inner page
bytes the obvious
divide the outer
processors for added
flexibility and efficiency
page the outer
three-level paging scheme
paging scheme suppose
table is made
64-bit address space
2nd outer page
outer page outer
table is sti11234
bytes in size
four-level paging scheme
second-level outer page
ultrasparc would require
require seven levels
levels of paging-a
paging-a prohibitive number
number of memory
memory accessesto translate
translate each logical
hierarchical page tables
generally considered inappropriate
inappropriate 8.5.2 hashed
8.5.2 hashed page
hashed page tables
tables a common
approach for handling
handling address spaces
address spaces larger
virtual page number
number each entry
list of elements
elements that hash
mapped page frame
list the algorithm
address is hashed
table the virtual
number is compared
compared with field
form the desired
desired physical address
list are searched
matching virtual page
number this scheme
scheme is shown
favorable for 64-bit
64-bit address spaces
proposed this variation
similar to hashed
hash table refers
single page-table entry
entry can store
store the mappings
mappings for multiple
multiple physical-page frames
physical-page frames clustered
frames clustered page
clustered page tables
references are noncontiguous
noncontiguous and scattered
space 8.5.3 inverted
8.5.3 inverted page
inverted page tables
table the page
virtual hash table
hash table figure
hashed page table
page table physical
table physical address
physical address physical
address physical memory
processes reference pages
pages  virtual
addresses the operating
translate this reference
table is sorted
sorted by virtual
physical address entry
entry is located
consist of millions
millions of entries
entries these tables
tables may consume
consume large amounts
amounts of physical
page an inverted
inverted page table
real memory location
owns the page
page of physical
shows the operation
page table compare
depicts a standard
standard page table
table in operation
operation inverted page
tables often require
address spaces mapping
spaces mapping physical
mapping physical memory
physical memory storing
storing the address-space
address-space identifier ensures
process is mapped
page frame examples
examples of systems
systems using inverted
page tables include
include the 64-bit
ultrasparc and powerpc
powerpc to illustrate
illustrate this method
describe a simplified
i11verted page table
inverted page-table entry
assumes the role
memory page table
physical address figure
table physical memory
consisting of process-id
subsystem the inverted
match is found-say
i-then the physical
offset is generated
match is found
illegal address access
decreases the amount
needed to store
store each page
increases the amount
needed to search
search the table
page reference occurs
sorted by physical
occur on virtual
match this search
long to alleviate
alleviate this problem
limit the search
search to one-or
hash table adds
adds a memory
virtual memory reference
memory reference requires
two real memory
real memory reads-one
tlb is searched
table is consulted
offering some performance
tables have difficulty
difficulty implementing shared
implementing shared memory
shared memory shared
implemented as multiple
multiple virtual addresses
sharing the memory
address this standard
virtual page entry
shared virtual addresses
addresses a simple
technique for addressing
addressing this issue
shared physical address
address this means
means that references
references to virtual
result in page
faults an important
aspect of memory
unavoidable with paging
view is mapped
mapped onto physical
memory this mapping
mapping allows differentiation
differentiation between logical
memory and physical
memory 8.6.1 basic
8.6.1 basic method
method do users
array of bytes
data most people
prefer to view
collection of variable-sized
ordering among segments
include various data
modules or data
elements is referred
caring what addresses
addresses in memory
memory these elements
stack is stored
defined by subroutine
subroutine symbol table
main program logical
program logical address
segment are identified
seventh stack frame
stack frame entry
scheme that supports
supports this user
memory a logical
collection of segments
segments each segment
length the addresses
segment the user
user therefore specifies
specifies each address
contrast this scheme
simplicity of implementation
segments are numbered
segn lent number
logical address consists
compiler automatically constructs
automatically constructs segments
constructs segments reflecting
reflecting the input
compiler might create
create separate segments
code global variables
variables the heap
allocated the stacks
thread the standard
table yes trap
error + figure
segmentation hardware physical
hardware physical memory
physical memory libraries
assign.ed separate segments
segments the loader
segments and assign
assign them segment
numbers 8.6.2 hardware
sequence of bytes
define an implementation
implementation to map
map twodimensional user-defined
twodimensional user-defined addresses
addresses into one-dimensional
one-dimensional physical addresses
mapping is effected
limit the segment
startilcg physical address
resides in memory
segment limit specifies
specifies the length
table is illustrated
table the offset
logical addressing attempt
attempt beyond end
end of segment
offset is legal
base to produce
produce the address
address in physical
byte the segment
essentially an array
array of base-limit
base-limit register pairs
segments are stored
stored in physical
memory as shown
shown the segment
giving the beginning
segment in physical
long and begins
begins at location
reference to byte
segment o segment1
segment1 symbol table
main program segment
segment table figure
segmentation 14001---1 segment
reference to segment
base of segment
tooo bytes long
long both paging
segmentation have advantages
disadvantages in fact
fact some architectures
discuss the intel
intel pentium architecture
give a complete
present the major
based we conclude
conclude our discussion
overview of linux
linux address translation
translation on pentium
systems in pentium
cpu generates logical
generates logical addresses
unit the segmentation
segmentation unit produces
produces a linear
address the linear
generates the physical
address in main
segmentation and paging
paging units form
form the equivalent
8.7.1 pentium segmentation
segmentation the pentium
number of segments
segments per process
cpu i figure
logical to physical
physical address translation
partitions the first
first partition consists
ldt and gdt
8-byte segment descriptor
descriptor with detailed
including the base
location and limit
segment the logical
designates the segment
gdt or ldt
deals with protection
protection the offset
segment in question
question the machine
allowing six segments
8-byte microprogram registers
registers to hold
ldt or gdt
gdt this cache
lets the pentium
read the descriptor
descriptor from memory
reference the linear
segment register points
gdt the base
generate a first
check for address
offset is added
32-bit linear address
paging unit turns
turns this linear
address 8.7.2 pentium
8.7.2 pentium paging
paging the pentium
two-level paging schence
architecture is similar
intel pentium address
pentium address translation
translation is shown
logical address offset
linear address figure
intel pentium segmentation
pentium segmentation detail
detail in figure
high-order bits reference
reference an entry
outernlost page table
terms the page
cr3 register points
page directory entry
directory entry points
4-kb page pointed
table one entry
page size flag
flag is set
page directory points
4-mb page frame
registe r page
page directory page
directory page directory
page 4-mb page
4-mb page figure
efficiency of physical
intel pentium page
pentium page tables
entry is pointing
memory on demand
demand 8.7.3 linux
linux on pentium
architecture because linux
linux is designed
variety of processors
provide only limited
support for segmentationlinux
rely on segmentation
segment for kernel
code a segment
data a segment
segment for user
data a task-state
default ldt segment
segment the segments
segments for user
data are shared
descriptors are stored
global descriptor table
segment is stored
gdt the tss
store the hardware
process during context
switches the default
ldt as noted
segment selector includes
includes a 2-bit
field for protection
levels of protection
limlx only recognizes
two-level paging model
variety of hardware
platforms where two-level
linux has adopted
adopted a threelevel
threelevel paging strategy
strategy that works
32-bit and 64-bit
architectures the linear
address in linux
linux is broken
global directory middle
directory middle directory
middle directory page
directory page table
highlights the three-level
three-level paging model
model in linux
linux the number
number of bits
linear address varies
lglobal directory global
directory global directory
global directory cr3
directory cr3 __,.c__
cr3 __,.c__ ___
__,.c__ ___ __l
___ __l register
middle directory figure
paging in linux
linux offset page
offset page frame
bypassing the middle
directory each task
task in linux
set of page
tables and -just
-the cr3 register
task currently executing
register is saved
context switch memory-management
switch memory-management algorithms
algorithms for multiprogrammed
operating systems range
simple single-user system
single-user system approach
approach to paged
provided every memory
memory address generated
checked for legality
address the checking
combinations of paging
aspects in comparing
comparing different memory-management
support a simple
simple base register
base-limit register pair
pair is sufficient
single and multiple-partition
segmentation need mapping
tables to define
define the address
address map performance
required to map
physical address increases
compare or add
implemented in fast
user memory accesses
substantially a tlb
tlb can reduce
reduce the performance
acceptable level fragmentation
fragmentation a multiprogrammed
level of multiprogramming
increase the multiprogramming
packing more processes
processes into memory
memory to accomplish
accomplish this task
reduce memory waste
systems with fixed-sized
fixed-sized allocation units
scheme and paging
suffer from internal
internal fragmentation systems
systems with variable-sized
variable-sized allocation units
scheme and segmentation
external fragmentation relocation
relocation one solution
problem is compaction
compaction compaction involves
compaction involves shifting
shifting a program
program in memory
notice the change
change this consideration
requires that logical
addresses be relocated
compact storage swapping
storage swapping swapping
algorithm at intervals
dictated by cpu-scheduling
processes are copied
copied from main
back to main
fit into memory
sharing another means
means of increasing
increasing the multiprogramming
sharing generally requires
paging or segmentation
provide small packets
pages or segments
means of running
running many processes
designed carefully protection
protection if paging
segmentation is provided
read-write this restriction
case to provide
provide simple run-time
simple run-time checks
checks for common
common programming errors
explain the difference
difference between internal
internal and external
compare the memory
memory organization schemes
schemes of contiguous
paging with respect
fragmentation b internal
fragmentation c ability
ability to share
code across processes
paging sometimes combined
program to allocate
allocate more memory
space during execution
allocation of data
segments of programs
required to support
support dynamic memory
dynamic memory allocation
schemes a contiguous
allocation b pure
segmentation c pure
intel address-translation scheme
address-translation scheme shown
pentium in translatil
system of hardware
complicated memory translation
purpose of paging
paging the page
explain why sharil
module is easier
easier when segmentation
system with paging
system allow access
compare the segmented
pagil g scheme
page table scheme
scheme for handling
handling large address
large address spaces
page table stored
stored in memory
memory reference takes
paged memory reference
references are found
effective memory reference
assume that finding
finding a page-table
paging with segmentation
segmentation with respect
address translation structures
structures in order
order to convert
convert virtual addresses
data the cpu
fetch or store
two baselimit register
baselimit register pairs
pairs are provided
data the instruction
instruction base-limit register
discuss the advantages
process for generating
binaries a compiler
generate the object
code for individual
combine multiple object
multiple object modules
single program bilcary
linkage editor change
change the bindmg
bindmg of instructions
addresses what information
editor to facilitate
facilitate the memory-binding
hierarchical paging scheme
operations are performed
executes a memory-load
worst-fit algorithms place
algorithms place processes
segment could belong
4-kb page size
512mb of physical
conventional single-level page
single-level page table
1-kb page size
numbers and offsets
provided as decimal
fixed virtual address
storing the program
program starts executing
stack is allocated
virtual address space
allowed to grow
grow toward lower
lower virtual addresses
segment base length
words per page
bits are required
segments among processes
processes without requiring
dynamically linked segmentation
linked segmentation system
system a define
define a system
linking and sharing
sharing of segments
segments without requiring
describe a paging
shared without requiring
32-bit virtual address
page size write
passed a virtual
output the page
number and offset
program would run
program would output
writing this program
program will require
type to store
bits we encourage
unsigned data types
dynamic storage allocation
allocation was discussed
discussed by knuth
found through simulation
results that first
discussed the 50-percent
rule the concept
concept of paging
described by kilburn
concept of segmentation
segmentation was first
discussed by dennis
daley and dennis
tables are discussed
ibm rt storage
manager by chang
chang and mergen
translation in software
software is covered
covered in jacob
jacob and mudge
explains the hardware
aspects of tlbs
discusses page tables
tables for 64-bit
address spaces alternative
spaces alternative approaches
approaches to enforcing
protection are proposed
proposed and studied
studied in wahbe
tedmiques for managing
managing the tlb
support for large
large pages tanenbaum
discusses intel80386 paging
intel80386 paging memory
paging memory management
described by jacob
segmentation on lim1x
systems is presented
discussed various memory-management
tend to require
execute virtual memory
completely in memory
memory one major
larger than physical
virtual memory abstracts
memory abstracts main
separating logical memory
memory as viewed
memory this technique
technique frees programmers
concerns of memory-storage
memory-storage limitations virtual
limitations virtual memory
process creation virtual
creation virtual memory
easy to implement
substantially decrease performance
discuss virtual memory
form of demand
paging and examine
examine its complexity
complexity and cost
cost to describe
describe the benefits
virtual memory system
explain the concepts
concepts of demand
allocation of page
frames to discuss
discuss the principles
model the memory-management
memory-management algorithms outlined
outlined in chapter
instructions being executed
memory the first
approach to meeting
meeting this requirement
place the entire
entire logical address
space in physical
physical memory dynamic
memory dynamic loading
ease this restriction
generally requires special
requires special precautions
precautions and extra
requirement that instructions
limits the size
examination of real
real programs shows
needed for instance
code to handle
handle unusual error
unusual error conditions
occur in practice
allocated more memory
elements an assembler
assembler symbol table
symbols certain options
options and features
rarely for instance
routines on u.s
u.s government computers
computers that balance
balance the budget
program is needed
ability to execute
partially in memory
memory would confer
confer many benefits
longer be constrained
extremely large virtual
large virtual address
simplifying the programming
programming task page
page v virtual
virtual memory memory
memory memory map
memory map physical
map physical memory
diagram showing virtual
showing virtual memory
increase in cpu
increase in response
needed to load
load or swap
swap user programs
programs into memory
memory would benefit
involves the separation
separation of logical
memory as perceived
perceived by users
users from physical
memory this separation
large virtual memory
provided for programmers
smaller physical memory
virtual memory makes
task of programming
programming much easier
programmer no longer
programmed the address
process is stored
address 0-and exists
exists in contiguous
fact physical memory
organized in page
page frames assigned
map logical pages
pages to physical
frames in memory
note in figure
heap to grow
upward in memory
stack to grow
downward in memory
memory through successive
successive function calls
calls the large
large blank space
stack is part
virtual address figure
require actual physical
actual physical pages
heap or stack
stack grows virtual
grows virtual address
virtual address spaces
spaces that include
sparse address spaces
sparse address space
space is beneficial
stack or heap
heap segments grow
dynam.ically link libraries
possibly other shared
execution in addition
addition to separating
memory from physical
memory allows files
files and memory
processes through page
processes through mapping
considers the shared
reside in physical
memory are shared
library is mapped
virtual memory enables
memory enables processes
share memory recall
shared memory virtual
process to create
create a region
process processes sharing
sharing this region
pages of memory
shared during process
calt thus speeding
speeding up process
explore these-and other-benefits
other-benefits of virtual
discuss implementing virtual
implementing virtual memory
memory through demand
demand paging shared
paging shared library
shared library shared
library shared pages
shared pages shared
pages shared library
shared library figure
library using virtual
loaded from disk
disk into nlemory
nlemory one option
program in physical
memory at program
suppose a program
loading the entire
results in loading
loading the executable
needed this technique
virtual memory systems
systems with demand-paged
demand-paged virtual memory
demanded during program
execution ; pages
loaded into physical
memory a demand-paging
system with swapping
reside in secondary
swapping the entire
swapper never swaps
swaps a page
page into memory
viewing a process
sequence of pages
large contiguous address
contiguous address space
incorrect a swapper
swapper manipulates entire
manipulates entire processes
connection with demand
demand paging program
program a program
program b main
main memory swap
memory to contiguous
contiguous disk space
9.2.1 basic concepts
guesses which pages
pages into memory
reading into memory
decreasing the swap
physical memory needed
form of hardware
support to distinguish
disk the valid
-invalid bit scheme
bit scheme described
disk the page-table
memory is set
set as usuat
simply marked invalid
page on disk
disk this situation
situation is depicted
notice that marking
marking a page
process never attempts
attempts to access
access that page
right and page
executes and accesses
valid-invalid frame bit
physical memory dod
main memory operating
memory operating system
operating system reference
backing store trap
store trap restart
trap restart instruction
restart instruction page
instruction page table
page table reset
table reset page
reset page table
bring in missing
missing page figure
steps in handling
handling a page
access a page
page marked invalid
translating the address
causing a trap
system this trap
system s failure
failure to bring
bring the desired
memory the procedure
procedure for handling
handling this page
fault is straightforward
check an internal
process to determine
invalid memory access
reference was invalid
terminate the process
schedule a disk
operation to read
read the desired
newly allocated frame
read is complete
modify the internal
memory we restart
restart the instruction
trap the process
access the page
pages in memory
process immediately faults
page is brought
faults this scheme
bring a page
programs could access
possibly causing multiple
causing multiple page
multiple page faults
faults per instruction
instruction this situation
situation would result
result in unacceptable
unacceptable system performance
analysis of running
running processes shows
exceedingly unlikely programs
results in reasonable
performance from demand
paging the hardware
hardware to support
support demand paging
hardware for paging
paging and swapping
table this table
ability to mark
mark an entry
value of protection
protection bits secondary
bits secondary memory
memory this memory
holds those pages
present in main
memory the secondary
allocation is discussed
requirement for demand
ability to restart
restart any instruction
save the state
page fault occurs
restart the process
place and state
requirement is easy
easy to meet
meet a page
fault may occur
restart by fetching
fetching the instruction
fetching an operand
fetch and decode
decode the instruction
fetch the operand
add the content
placing the result
steps to execute
execute this instruction
fetch a fetch
fetch b add
store the sum
correct the page
instruction the restart
restart will require
occurs the major
major difficulty arises
instruction may modify
source or destination
straddles a page
fault might occur
done in addition
destination blocks overlap
instruction this problem
computes and attempts
access both ends
modified the move
fault can occur
solution uses temporary
hold the values
values of overwritten
values are written
back into memory
occurs this action
action restores memory
instruction was started
architectural problem resulting
resulting from adding
difficulties involved paging
paging is added
people often assume
assume that paging
assumption is true
page fault represents
represents a fatal
page fault means
restarted 9.2.2 performance
performance of demand
demand paging demand
paging demand paging
affect the performance
compute the effective
read the relevant
page from disk
close to zero-that
faults the ttp
needed to service
service a page
fault a page
sequence to occur
operating system save
save the user
registers and process
page fault check
reference was legal
legal and determine
determine the location
issue a read
request is serviced
serviced b wait
begin the transfer
frame while waiting
allocate the cpu
receive an interrupt
disk i subsystem
save the registers
tables to show
process again restore
restore the user
resume the interrupted
occurs this arrangement
arrangement allows multiprogramming
multiprogramming to maintain
maintain cpu utilization
utilization but requires
resume the page-fault
page-fault service routine
transfer is complete
faced with tlu
tlu ee major
service the page-fault
page-fault interrupt read
instructions these tasks
typical hard disk
processes is waiting
free to service
service our request
average page-fault service
microseconds the computer
due to paging
399,990 to page-fault
page-fault in sum
page-fault rate low
access time increases
slowing process execution
process execution dramatically
dramatically an additional
aspect of demand
swap space disk
i to swap
faster because swap
lookups and indirect
indirect allocation methods
gain better paging
throughput by copying
copying an entire
entire file image
space at process
performing demand paging
space another option
write the pages
pages to swap
replaced this approach
approach will ensure
pages are read
paging is done
done from swap
attempt to limit
limit the amount
amount of swap
paging of binary
binary files demand
files demand pages
files are brought
simply be overwritten
system itself serves
backing store howeve1
howeve1 ~ swap
include the stack
stack and heap
solaris and bsd
unix in section
process can start
similar to page
rapid process creation
creation and minimizes
minimizes the number
process i modifies
page c recall
recall thatthe fork
worked by creating
creating a copy
parent s address
duplicating the pages
child processes invoke
invoke the exec
immediately after creation
works by allowing
allowing the parent
initially to share
pages these shared
pages are marked
marked as copy-on-write
page is created
copy-on-write is illustrated
illustrated in figures
show the contents
child process attempts
attempts to modify
modify a page
page containing portions
copy-on-write the operating
system will create
create a copy
process the child
modify its copied
process are copied
child processes note
process1 physical memory
page c process2
arked as copy-on-write
pages containing executable
duplicated using copyon
note the location
allocated many operating
requests these free
process must expand
managed operating systems
systems typically allocate
allocate these pages
1and zero-fill-on-demand pages
erasing the previous
contents several versions
provide a variation
variation ofthe fork
differently from fork
copy-on-write with vfork
parent because vfork
caution to ensure
modify the address
child process calls
process calls exec
copying of pages
pages takes place
extremely efficient method
method of process
implement unix command-line
unix command-line shell
command-line shell interfaces
referenced this representation
process of ten
demand paging saves
increase our degree
multiprogramming by running
run eight processes
required ten frames
run six processes
pages in size
higher cpu utilization
frames to spare
holding program pages
program pages buffers
consume a considerable
increase the strain
strain on memory-placement
memory-placement algorithms deciding
memory to allocate
challenge some systems
allocate a fixed
percentage of memory
subsystem to compete
memory for user
table for user
page replacement over-allocation
over-allocation of memory
occurs the operating
operating system determines
page is residing
terminate the user
system s attempt
attempt to improve
improve the computer
system s utilization
choice the operating
frames and reducing
reducing the level
multiprogramming this option
9.4.1 basic page
basic page replacement
page replacement page
replacement page replacement
page replacement takes
frame is free
free a frame
frame by writing
writing its contents
contents to swap
space and changing
changing the page
longer in memory
frame to hold
hold the page
faulted we modify
modify the page-fault
routine to include
include page replacement
find the location
algorithnc to select
write the victim
disk ; change
change the page
page and frame
tables accordingly read
newly freed frame
frame ; change
frame tables restart
restart the user
user process notice
frames are free
two page transfers
required this situation
situation effectively doubles
doubles the page-fault
increases the effective
reduce this overhead
page or frame
hardware the modify
page is set
page is written
select a page
page for replacement
examine its modify
write the page
read into memory
write the memory
technique also applies
pages of binary
discarded when desired
desired this scheme
required to service
modified frame valid-invalid
frame valid-invalid bit
replacement is basic
basic to demand
paging it completes
completes the separation
separation between logical
enormous virtual memory
provided for programnlers
addresses are mapped
sets of addresses
constrained by physical
process of twenty
algorithm to find
contents are copied
solve two major
two major problems
problems to implement
implement demand develop
develop a algorithm
frames to allocate
replacement is required
select the frames
designing appropriate algorithms
algorithms to solve
solve these problems
expensive even slight
improvements in demand-paging
demand-paging methods yield
methods yield large
yield large gains
gains in system
algorithms every operating
algorithm in general
lowest page-fault rate
rate we evaluate
evaluate an algorithm
algorithm by running
string of memory
references and computing
computing the number
number of page
faults the string
generate reference strings
system and record
record the address
produces a large
number of data
reduce the number
two facts first
hardware or system
page fault page
immediately following references
bytes per page
sequence is reduced
number of frames
graph of page
faults versus number
frames to determine
determine the number
string and page-replacement
frames available increases
page faults decreases
reference strillg considered
page in contrast
resulting in eleven
faults in general
expect a curve
page faults drops
adding physical memory
physical memory increases
increases the number
illustrate several page-replacement
algorithms in doing
frames 9.4.2 fifo
9.4.2 fifo page
fifo page replacement
replacement the simplest
simplest page-replacement algorithm
algorithm a fifo
fifo replacement algorithm
replacement algorithm associates
page was brought
page is chosen
create a fifo
queue to hold
hold all pages
memory we replace
replace the page
empty the first
first three references
brought in first
reference the first
results in replacement
replacement of page
page frames figure
fifo page-replacement algorithm
first in line
replaced by page
continues as shown
show which pages
fifteen faults altogether
altogether the fifo
algorithm is easy
easy to lmderstand
lmderstand and program
heavily used variable
constant use notice
select for replacement
replacement a page
replace an active
immediately to retrieve
retrieve the active
replaced to bring
bring the active
bad replacement choice
replacement choice increases
increases the page-fault
rate and slows
slows process execution
execution to illustrate
illustrate the problems
shows the curve
curve of page
reference string versus
versus the number
number of faults
rate may increase
number of allocated
allocated frames increases
expect that giving
giving more memory
process would improve
improve its performance
anomaly was discovered
result 9.4.3 optimal
9.4.3 optimal page
optimal page replacement
replacement of belady
suffer from belady
belady s anomaly
algorithm does exist
opt or min
curve for fifo
page-replacement algorithm guarantees
guarantees the lowest
lowest possible pagefault
sample reference string
optimal page-replacement algorithm
algorithm would yield
yield nine page
references cause faults
faults that fill
frames the reference
reference to page
ignore the first
algorithms must suffer
good as fifo
algorithm can process
process this reference
frames with fewer
algorithm is difficult
requires future knowledge
encountered a similar
sjf cpu-schedulin.g algorithm
algorithm in section
studies for instance
algorithm reference string
percent of optimal
optimal at worst
average 9.4.4 lru
9.4.4 lru page
lru page replacement
fifo and opt
backward versus forward
lru replacement associates
page s last
chooses the page
algorithm looking backward
algorithm on sis
result of applying
applying lru replacement
string is shown
lru algorithm produces
algorithm produces twelve
produces twelve faults
twelve faults notice
first five faults
lru replacement sees
lru algorithm replaces
algorithm replaces page
knowing that page
faults for page
replacement with twelve
replacement with fifteen
fifteen the lru
good the major
implement lru replacement
replacement an lru
lru page-replacement algorithm
require substantial hardware
substantial hardware assistance
assistance the problem
determine an order
implementations are feasible
entry a time-of-use
field and add
cpu a logical
clock or counter
counter the clock
clock is reference
page is made
register are copied
page we replace
smallest time value
value this scheme
requires a search
find the lru
write to memory
access the times
aintained when page
tables are changed
due to cpu
stack another approach
approach to implementing
implementing lru replacement
stack of page
page is referenced
stack and put
recently used page
implement this approach
tail pointer removing
removing a page
page and putting
stack then requires
changing six pointers
pointers at worst
worst each update
tail pointer points
page this approach
software or microcode
implementations of lru
replacement like optimal
class of page-replacement
anomaly a stack
set of pages
frames for lru
recently referenced pages
frames is increased
implementation of lru
conceivable without hardware
standard tlb registers
registers the updating
stack to record
recent page references
fields or stack
software to update
update such data
slow every memory
slowing every user
factor of ten
ten few systems
systems could tolerate
tolerate that level
level of overhead
overhead for memory
management 9.4.5 lru-approximation
9.4.5 lru-approximation page
lru-approximation page replacement
replacement few computer
systems provide sufficient
provide sufficient hardware
sufficient hardware support
support for true
true lru page
replacement some systems
provide no hardware
bits are cleared
user process executes
referenced is set
determine which pages
examining the reference
algorithms that approximate
approximate lru replacement
replacement 9.4.5.1 additional-reference-bits
9.4.5.1 additional-reference-bits algorithm
gain additional ordering
additional ordering information
information by recording
recording the reference
bits at regular
table in memory
memory at regular
timer interrupt transfers
interrupt transfers control
operating system shifts
shifts the reference
bit and discarding
discarding the low-order
bit these 8-bit
8-bit shift registers
history of page
shift register value
history register value
interpret these 8-bit
bytes as unsigned
method to choose
bits of history
make the updating
updating as fast
9.4.5.2 second-chance algorithm
algorithm the basic
algorithm of second-chance
inspect its reference
proceed to replace
replace this page
give the page
chance and move
reference pages reference
pages reference pages
reference pages bits
pages bits bits
bits bits circular
bits circular queue
queue of pages
pages circular queue
bit is cleared
reference bit set
implement the second-chance
queue a poi11ter
frame is needed
finds a page
clears the reference
page is found
page is replaced
page is inserted
bits are set
giving each page
chance it clears
bits before selecting
replacement second-chance replacement
second-chance replacement degenerates
degenerates to fifo
set 9.4.5.3 enhanced
9.4.5.3 enhanced second-chance
enhanced second-chance algorithm
enhance the second-chance
four possible classes
modified -best page
page to replace
recently used hut
out before replacement
out to disk
replaced each page
classes when page
examine the class
belongs we replace
replace the first
first page encountered
lowest nonempty class
nonempty class notice
scan the circular
queue several times
find a page
replaced the major
simpler clock algorithm
modified to reduce
required 9.4.6 counting-based
9.4.6 counting-based page
counting-based page replacement
number of references
page and develop
page-replacement algorithm requires
count be replaced
replaced the reason
actively used page
large reference count
count a problem
count and remains
remains in memory
needed one solution
shift the counts
bit at regular
exponentially decaying average
decaying average usage
average usage count
algorithm is based
mfu nor lfu
replacement is common
common the implementation
algorithms is expensive
approxinlate opt replacement
9.4.7 page-buffering algorithms
algorithms other procedures
specific page-replacement algorithm
pool of free
frame is chosen
page is read
victim is written
out this procedure
process to restart
frame is added
list of modified
device is idle
page is selected
disk its modify
reset this scheme
increases the probability
selected for replacement
out another modification
remember which page
frame is written
reused directly fronc
fronc the free-frame
frame is reused
i is needed
frame and read
algorithm mistakenly replaces
replaces a page
buffer provides protection
algorithm this method
versions of vax
implement the reference
reference bit correctly
correctly some versions
method in conjunction
reduce the penalty
wrong victim page
selected 9.4.8 applications
applications and page
applications accessing data
system s virtual
virtual memory perform
memory perform worse
operating system provided
provided no buffering
i buffering applications
understand their memory
algorithms for general-purpose
system is buffering
application is doing
warehouses frequently perform
frequently perform massive
perform massive sequential
massive sequential disk
sequential disk reads
computations and writes
writes the lru
removing old pages
pages and preserving
reading older pages
pages than newer
starts its sequential
efficient than lru
operating systems give
systems give special
give special programs
programs the ability
large sequential array
array of logical
file-system data structures
structures this array
array is termed
raw i raw
raw i bypasses
file i demand
i demand paging
efficient when implementing
special-purpose storage services
regular file-system services
issue of allocation
allocate the fixed
composed of pages
size this system
frames the operating
process under pure
pure demand paging
initially be put
user process started
process started execution
generate a sequence
sequence of page
faults the first
list was exhausted
operating system allocate
buffer and table
support user paging
free frames reserved
swap is taking
user process continues
execute other variants
strategy is clear
allocated any free
frame 9.5.1 minimum
9.5.1 minimum number
frames our strategies
frames are constrained
requirement one reason
reason for allocating
frames involves performance
page-fault rate increases
ilcstruction is complete
frames to hold
ilcstruction can reference
instructions may reference
reference in addition
one-level indirect addressing
addressing is allowed
instruction on page
address on page
frames per process
frames the minimum
frames is defined
straddle two pages
pages in addition
location to storage
pages the block
block of characters
characters to move
pages this situation
situation would require
require six frames
frames the worst
worst case occurs
instruction that straddles
frames the worst-case
worst-case scenario occurs
occurs in computer
levels of indirection
1-bit indirect indicator
simple load instruction
instruction could reference
reference an indirect
page in virtual
entire virtual memory
memory to overcome
overcome this difficulty
place a limit
limit an instruction
16levels of indirection
first indirection occurs
counter is set
reduces the maximum
references per instruction
number is defined
left with significant
choice in frame
allocation 9.5.2 allocation
9.5.2 allocation algorithms
algorithms the easiest
split m frames
frames for instance
free-frame buffer pool
pool this scheme
1-kb frame size
small student process
two processes running
make much sense
sense to give
give each process
frames the student
wasted to solve
memory for process
frames to process
required by tl1e
tl1e instruction set
sum not exceeding
equal and proportional
allocation may vary
level is increased
process will lose
lose some frames
frames to provide
provide the memory
multiprogramming level decreases
remaining processes notice
equal or proportional
process is treated
give the high-priority
process more memory
memory to speed
speed its execution
detriment of low-priority
processes one solution
proportional allocation scheme
ratio of frames
sizes of processes
priorities of processes
combination of size
size and priority
priority 9.5.3 global
9.5.3 global versus
global versus local
versus local allocation
allocation another important
processes is page
replacement with multiple
multiple processes competing
competing for frames
classify page-replacement algorithms
two broad categories
local global replacement
local replacement requires
set of allocated
processes to select
frames from low-priority
processes for replacement
replacement a process
process can select
select a replacement
process this approach
process to increase
increase its frame
local replacement strategy
change with global
process may happen
happen to select
select only frames
increasing the number
choose its frames
frames for replacement
global replacement algorithm
rate the set
process may perform
totally external circuntstances
local replacement algorithm
algorithm under local
process is affected
process local replacement
replacement might hinder
hinder a process
replacement generally results
results in greater
greater system throughput
method 9.5.4 non-uniform
9.5.4 non-uniform memory
memory is created
access some sections
sections of main
main memory faster
differences are caused
cpus and memory
memory are interconnected
system is made
memory the system
boards are interconnected
ranging from system
busses to high-speed
high-speed network connections
connections like infiniband
memory access times
access times vary
collectively as systems
slower than systems
memory and cpus
cpus are located
managing which page
frames are stored
significantly affect performance
performance in numa
memory as uniform
cpus may wait
wait significantly longer
longer for memory
modify memory allocation
memory allocation algorithms
numa into account
system the goal
memory frames allocated
allocated as close
running the definition
definition of close
cpu the algorithmic
algorithmic changes consist
track the last
schedule each process
improved cache hits
hits and decreased
decreased memory access
times will result
result the picture
complicated once threads
threads are added
threads may end
case solaris solves
solves the problem
problem by creating
creating an entity
kernel each lgroup
gathers together close
hierarchy of lgroups
amount of latency
schedule all threads
allocate all memory
picks nearby lgroups
latency is minimized
cpu cache hit
cache hit rates
rates are maximized
low-priority process falls
minimum number required
suspend that process
out its remaining
frames this provision
introduces a swap-in
level of intermediate
intermediate cpu scheduling
scheduling in fact
num.ber of frames
pages in active
replace some page
replace a page
back in immediately
immediately this high
high paging activity
process is thrashing
paging than executing
thrashing thrashing results
results in severe
severe performance problems
behavior of early
early paging systems
systems the operating
operating system monitors
system monitors cpu
monitors cpu utilization
utilization if cpu
increase the degree
multiprogramming by introducing
system a global
global page-replacement algorithm
pages without regard
belong now suppose
frames it starts
faulting and taking
processes these processes
processes these faulting
device to swap
ready queue empties
empties as processes
cpu utilization decreases
decreases the cpu
cpu scheduler sees
sees the decreasing
decreasing cpu utilization
utilization and increases
increases the degree
started by taking
frames from running
causing more page
thrashing has occurred
system throughput plunges
plunges the pagefault
pagefault rate increases
rate increases tremendously
m.emory-access time increases
increases no work
processes are spending
paging this phenomenon
phenomenon is illustrated
utilization is plotted
utilization also ilccreases
maximum is reached
multiprogramming is increased
utilization drops sharply
increase cpu utilization
utilization and stop
decrease the degree
limit the effects
effects of thrashing
process starts thrashing
solved if processes
fault will increase
longer average queue
thrashing to prevent
provide a process
teclmiques the working-set
frames a process
defines the locality
locality of process
execution the locality
locality model states
moves from locality
locality to locality
locality a locality
references are made
exit the function
leaves this locality
variables and instructions
longer in active
localities are defined
structures the locality
programs will exhibit
exhibit this basic
basic memory reference
memory reference structure
reference structure note
book if accesses
types of data
data were random
suppose we allocate
allocate enough frames
process to accommodate
accommodate its current
frames to accommodate
accommodate the size
process will thrash
9.6.2 working-set model
model as mentioned
assumption of locality
locality this model
define the vrindovv
vrindovv the idea
references the set
program s locality
set has changed
working set depends
encompass the entire
page reference table
compute the working-set
dis the total
demand for frames
frames each process
wss ; frames
demand is greater
thrashing will occur
model is simple
simple the operating
monitors the working
process and allocates
set enough frames
working-set sizes increases
exceeding the total
process to suspend
suspend the process
process s pages
pages are written
frames are reallocated
processes the suspended
working-set strategy prevents
strategy prevents thrashing
thrashing while keeping
keeping the degree
multiprogramming as high
optimizes cpu utilization
utilization the difficulty
model is keeping
set the working-set
oldest reference drops
end a page
approximate the working-set
fixed-interval timer interrupt
equals 10,000 references
copy and clear
clear the reference-bit
examine the current
current reference bit
two in-memory bits
bits to determine
working set note
reduce the uncertainty
uncertainty by increasing
number of history
frequency of interrupts
bits and interrupts
cost to service
frequency 9.6.3 page-fault
9.6.3 page-fault frequency
frequency the working-set
model is successful
thrashilcg a strategy
approach the specific
prevent thrashilcg thrashing
high page-fault rate
control the page-fault
upper and lower
desired page-fault rate
actual page-fault rate
page-fault rate exceeds
exceeds the upper
allocate the process
process another frame
page-fault rate falls
remove a frame
measure and control
rate to prevent
suspend a process
page-fault rate ilccreases
select some process
process and suspend
distributed to processes
processes with high
high page-fault rates
standard system calls
system calls open
file access requires
requires a system
call and disk
memory techniques discussed
i as routine
accesses this approach
lead to significant
significant performance increases
increases when performing
sets and page
typically as shown
working set ofa
set ofa process
references to data
code sections move
memory to store
store the working
processis 11.ot thrashing
tbe page-fault rate
process will transition
transition between peaks
peaks and valleys
behavior is shown
page fault rate
fault rate working
rate working set
set time figure
page-fault rate occurs
fault rate rises
set is loaded
memory the span
start of thenext
thenext peak represents
represents the transition
9.7.1 basic mechanism
basic mechanism memory
mechanism memory mapping
mapping a file
file is accomplished
accomplished by mapping
mapping a disk
memory initial access
proceeds through ordinary
ordinary demand paging
file is read
systems may opt
opt to read
chunk of memory
file are handled
handled as routine
simplifying file access
access and usage
usage by allowing
allowing the system
system to manipulate
files through memory
incurring the overhead
l is done
done in memory
memory as opposed
calls that involve
note that writes
mapped in memory
disk some systems
systems may choose
choose to update
update the physical
system periodically checks
page in memory
file is closed
data are written
back to disk
disk and ren
process some operating
systems provide memory
provide memory mapping
specific system call
calls to perform
choose to memory-map
memory-map a file
maps the file
opened and accessed
ordinary system calls
memory-maps the file
file is mapped
kernel address space
treats all file
i as memory-mapped
allowing file access
efficient memory subsystem
memory subsystem multiple
subsystem multiple processes
allowed to map
modify the data
data in virtual
discussions of virtual
sharing of memory-mapped
sections of memory
memory is implemented
virtual memory map
sharing process points
physical memory-the page
page that holds
holds a copy
block this memory
sharing is illustrated
memory-mapping system calls
support copy-on-write functionality
share a file
file in read-only
data they modify
j---r  -rl..-r
.....c.c ~ ..----r
disk file figure
memory-mapped files process
process b virtual
memory-mapped file figure
memory in windows
windows using memory-mapped
data is coordinated
mechanisms for achieving
achieving mutual exclusion
mutual exclusion described
files is similar
similar to shared
mapping is accomplished
memory is achieved
howeve1 ~ shared
memory is accomplished
accomplished by memory
memory mapping files
spaces the memorymapped
memorymapped file serves
memory using memory-mapped
files 9.7.2 shared
9.7.2 shared memory
api the general
outline for creating
creating a region
memory using memorymapped
win32 api involves
api involves first
involves first creating
creating a file
establishing a view
process s virtual
open and create
create a view
space the mapped
mapped file represents
represents the shared-menwry
illustrate these steps
process first creates
creates a shared-memory
api the producer
producer then writes
writes a message
message to shared
consumer process opens
opens a mapping
object and reads
reads the message
consum.er to establish
establish a memory-mapped
process first opens
opens the file
process then creates
creates a mapping
mapping is established
process then establishes
establishes a view
function the view
represents the portion
file being mapped
hmapfile ; lpvoid
lpmapaddress ; hfile
hfile = createfile
genericjread i generic_write
existing file file_attribute_normal
file attributes null
file template hmapfile
hmapfile = createfilemapping
access to mapped
map entire file
shared memory object
memory object lpmapaddress
lpmapaddress = mapviewdffile
object handle filejmap_all_access
view of entire
write to shared
shared memory sprintf
shared memory message
win32 api -the
api -the entire
-the entire file
mapped we illustrate
illustrate this sequence
checking for code
call to createfilemapping
creates a named
named shared-memory object
object called sharedobj
ect the consumer
process will communicate
segment by creating
creating a mapping
object the producer
producer then creates
creates a view
space by passing
passing the last
last three parameters
parameters the value
offset and size
creating a view
loaded # include
hmapfile = openfilemapping
mapped file object
file object lpmapaddress
lpmapaddress = mapviewoffile
read from shared
shared memory printf
reading from shared
api into memory
producer process writes
message shared memory
memory a program
consumer process establishes
object is shown
create a mapping
existii1g named shared-memory
object the consumer
process did ii1
ii1 the program
consumer then reads
reads from shared
memory the message
memory message thatwas
message thatwas written
remove the view
call to unmapviewoffile
chapter using shared
memory with memory
api 9.7.3 memory-mapped
i controller includes
controller includes registers
special i instructions
instructions allow data
registers and system
devices1 many computer
computer architectures provide
ranges of memory
addresses are set
device registers reads
registers this method
screen is mapped
n1.emory location displaying
location displaying text
easy as writing
writing the text
memory-mapped locations memory-mapped
serial and parallel
modems and printers
computer the cpu
cpu transfers data
kinds of devices
devices by reading
i to send
out a long
string of bytes
memory-mapped serial port1
port1 the cpu
writes one data
register and sets
sets a bit
register to signal
takes the data
clears the bit
cpu can transfer
cpu uses polling
polling to watch
watch the control
method of operation
poll the control
receives an interrupt
device is ready
user rnode requests
rnode requests additional
additional memory pages
pages are allocated
free page frames
page frames maintained
kernel this list
free pages scattered
user process requests
requests a single
memory internal fragmentation
granted an entire
entire page frame
page frame kernel
kernel memory however1
satisfy ordinary user-mode
ordinary user-mode processes
two primary reasons
kernel requests memory
memory for data
structures of varying
page in size
result1 the kernel
conservatively and attempt
attempt to minimize
minimize waste due
due to fragmentation
subject kernel code
allocated to user-mode
contiguous physical memory
however certain hardware
hardware devices interact
directly with physical
memory-without the benefit
virtual memory interface-and
require memory residing
physically contiguous pages
examine two strategies
strategies for managing
managing free memory
assigned to kernel
system and slab
9.8.1 buddy system
buddy system tbe
system tbe buddy
tbe buddy system
buddy system allocates
system allocates memory
fixed-size segment consisting
contiguous pages memory
requests in units
request in units
sized is rounded
simple example assume
assume the size
memory the segment
two 64-kb buddiesbland
two 32-kb buddies
request this scheme
scheme is illustrated
request an advantage
quickly adjacent buddies
combined to form
form larger segments
coalescing in figure
system can coalesce
segment this segment
turn be coalesced
segment the obvious
fragmentation within allocated
segment in fact
due to internal
explore a memory
memory allocation scheme
space is lost
fragmentation physically contiguous
buddy system allocation
9.8.2 slab allocation
strategy for allocating
nwre physically contiguous
pages a consists
data structure -for
data structure representing
structure representing process
representing process descriptors
cache for file
cache for semaphores
cache is populated
structure the cache
cache representing semaphores
representing semaphores stores
semaphores stores instances
instances of semaphore
cache representing process
process descriptors stores
descriptors stores instances
instances of process
process descriptor objects
relationship between slabs
objects is shown
shows two kernel
two kernel objects
size these objects
objects are stored
caches the slab-allocation
algorithm uses caches
caches to store
store kernel objects
cache is created
number of objects-which
marked as free-are
cache the number
number of objects
continguous 4-kb pages
cache are marked
marked as free
structure is needed
allocator can assign
assign any free
cache to satisfy
request the object
cache is marked
descriptor in linux
type struct task_struct
linux kernel creates
struct task_struct object
cache the cache
cache will fulfill
free in linux
kernel objects slabs
slabs 3-kb objects
objects 7-kb objects
7-kb objects figure
allocation physically contiguous
full all objects
slab are marked
empty all objects
partial the slab
allocator first attempts
attempts to satisfy
object is assigned
slab is allocated
allocated from contiguous
contiguous physical pages
pages and assigned
cache ; memory
object is allocated
slab the slab
two main benefits
memory is wasted
fragmentation fragn entation
cache is made
divided into chunks
chunks the size
objects being represented
slab allocator returns
returns the exact
required to represent
represent the object
object memory requests
quickly the slab
slab allocation scheme
memory when objects
allocated and deallocated
case with requests
kernel the act
act of allocating-and
objects are created
created in advance
kernel has finished
object and releases
free and returned
kernel the slab
allocator first appeared
user-mode memory requests
requests in solaris
beginning with version
linux kernel adopted
adopted the slab
allocator the major
prepaging an obvious
property of pure
faults that occur
process is started
started this situation
locality into memory
times for instance
attempt to prevent
prevent this high
level of initial
paging the strategy
bring into memory
needed some operating
operating systerns-notably solaris-prepage
solaris-prepage the page
frames for small
process a list
lack of free
remember the working
i has finished
memory its entire
entire working set
set before restarting
restarting the process
prepaging may offer
cases the question
cost of servicing
memory by prepaging
pages are prepaged
saved page faults
faults is greater
cost of prepaging
wins 9.9.2 page
9.9.2 page size
size the designers
existing machine seldom
single best page
set of factors
factors that support
support various sizes
sizes page sizes
size one concern
virtual memory space
decreasing the page
page size increases
number of pages
size is desirable
utilized with smaller
allocated memory starting
units of allocation
creating internal fragmentation
independence of process
size and page
wasted this loss
bytes to minimize
minimize internal fragmentation
small page size
size another problem
required to read
write a page
composed of seek
transfer times transfer
page size howeve1
latency and seek
milliseconds to transfer
milliseconds and seek
percent is attributable
actual transfer doubling
doubling the page
milliseconds it takes
milliseconds to read
read the sam.e
desire to minimize
larger page size
smaller page size
improved a smaller
page to match
match program locality
locality more accurately
transferred and allocated
allocate and transfer
size should result
total allocated memory
byte a process
memory would generate
102,400 page faults
byte each page
page fault generates
generates the large
amount of overhead
needed for processing
processing the interrupt
replacing a page
tables to minimize
minimize the number
size other factors
relationship between page
size and sector
bound on page
common page size
section 9.9.3 tlb
9.9.3 tlb reach
reach in chapter
percentage of virtual
virtual address translations
ratio is related
increase the hit
construct the tlb
expensive and power
power hungry related
tlb reach refers
simply the number
process will spend
spend a considerable
resolving memory references
double the number
double the tlb
insufficient for storing
storing the working
set another approacl1
approacl1 for increasing
increasing the tlb
increase the size
page or provide
provide multiple page
increase the page
quadruple the tlb
increase in fragmentation
ultrasparc supports page
supports page sizes
4-mb page sizes
reach for solaris
majority of applications
8-kb page size
size is sufficient
maps the first
two 4-mb pages
4-mb pages solaris
applications-such as databases-to
databases-to take advantage
large 4-mb page
4-mb page size
page size providing
size providing support
page sizes requires
requires the operating
operating system -not
-not hardware-to manage
manage the tlb
tlb entry managing
tlb in software
cost in performance
increased hit ratio
ratio and tlb
tlb reach offset
offset the performance
move toward softwaremanaged
tlbs and operating-system
sizes the ultrasparc
alpha architectures employ
architectures employ software-managed
employ software-managed tlbs
tlbs the powerpc
powerpc and pentium
tlb in hardware
hardware 9.9.4 inverted
9.9.4 inverted page
page tables section
section 8.5.3 introduced
introduced the concept
table the purpose
form of page
reduce the amount
needed to track
track virtual-to-physical address
virtual-to-physical address translations
translations we accomplish
accomplish this savings
savings by creating
creating a table
entry per page
virtual memory page
page is stored
page tables reduce
store this information
table no longer
longer contains complete
memory demand paging
demand paging requires
requires this information
information to process
process page faults
external page table
traditional per-process page
per-process page table
page is located
external page tables
page tables negate
negate the utility
utility of inverted
tables are referenced
virtual memory n1.anager
n1.anager to generate
generate another page
locate the virtual
store this special
special case requires
case requires careful
requires careful handling
processing 9.9.5 program
9.9.5 program structure
program structure demand
structure demand paging
paging is designed
nature of memory
underlying demand paging
contrived but informative
informative example assume
assume that pages
words in size
program whose function
code is typical
array is stored
stored row major
127j for pages
takes one page
preceding code zeros
zeros one word
operating system allocates
system allocates fewer
execution will result
16,384 page faults
faults in contrast
suppose we change
change the code
code to inti
page before starting
reducing the number
selection of data
structures and programming
structures can increase
lower the page-fault
stack has good
top a hash
designed to scatter
producing bad locality
locality of reference
heavily weighted factors
weighted factors include
factors include search
include search speed
compiler and loader
effect on paging
paging separating code
data and generating
generating reentrant code
reentrant code means
means that code
modified clean pages
replaced the loader
loader can avoid
avoid placing routines
routines across page
keeping each routine
routines that call
page this packaging
problem of operations
pack the variable-sized
variable-sized load segments
references are minimized
large page sizes
sizes the choice
choice of programming
language can affect
tend to randomize
diminishing a process
process s locality
locality some studies
studies have shown
shown that object-oriented
programs also tend
interlock when demand
separate i processor
usb storage device
bytes to transfer
sequence of events
processes cause page
replaces the page
process the pages
pages are paged
i request advances
two common solutions
problem one solution
i to user
copied between system
memory and user
memory i takes
i takes place
device to write
write a block
block on tape
copy the block
block to system
tape this extra
copying may result
unacceptably high overhead
overhead another solution
locked into memory
frame is locked
lock into memory
memory the pages
block the system
continue as usual
usual locked pages
i is complete
pages are unlocked
reason why frames
kernel is locked
tolerate a page
page fault caused
lock bit involves
bit involves normal
involves normal page
normal page replacement
low-priority process faults
process faults selecting
selecting a replacement
paging system reads
ready to continue
low-priority process enters
queue and waits
low-priority process waits
high-priority process faults
paging system sees
sees a page
referenced or modified
process just brought
replace the low-priority
delaying the low-priority
wasting the effort
spent to bring
decide to prevent
newly brought-in page
bit to implement
implement this mechanism
bit is turned
frame becomes unusable
overuse of locking
locking would hurt
doing the locking
locking multiuser systems
trusting of users
users for instance
solaris allows locking
free to disregard
disregard these hints
individual process requests
pages be locked
locked in memory
describe how windows
solaris implement virtual
implement virtual memory
memory 9.10.1 windows
windows xp windows
implements virtual memory
memory using demand
paging with clustering
clustering handles page
handles page faults
faults by bringing
process is first
assigned a working-set
minimum and maximum
pages the process
process is guaranteed
memory if sufficient
value of working-set
minimum and working-set
allowed to exceed
exceed its working-set
virtual memory manager
memory manager maintains
sufficient free memory
memory manager allocates
allocates a page
working-set rnaximum incurs
incurs a page
local page-replacement policy
free memory falls
restore the value
threshold automatic working-set
automatic working-set trimming
working-set trimming works
works by evaluating
evaluating the number
allocated more pages
memory manager removes
manager removes pages
reaches its working-set
minimum a process
list once sufficient
determine which page
page to remove
type of processor
processor on single-processor
single-processor 80x86 systems
clock algorithm discussed
9.4.5.2 on alpha
alpha and multiprocessor
multiprocessor x86 systems
clearing the reference
bit may require
translation look-aside buffer
incurring this overhead
fifo algorithm discussed
9.4.2 9.10.2 solaris
solaris in solaris
assigns a page
pages it maintains
represents a threshold
threshold to begin
paging the lotsfree
memory four times
number of free
free pages falls
falls below lotsfree
second-chance algorithm described
hands while scanning
pageout process works
scans all pages
setting the reference
examines the reference
appending each page
page whose reference
list and writing
writing to disk
disk its contents
contents if modified
modified solaris maintains
maintains a cache
list of pages
overwritten the free
list contains frames
invalid contents pages
list the pageout
parameters to control
control the rate
pages are scam
scanrate is expressed
ranges from slowscan
slowscan to fastscan
fastscan when free
occurs at slowscan
progresses to fastscan
value of slowscan
total physical pages
clock is determil
handspread the amount
slowscan minfree desfree
minfree desfree amount
free memory figure
solaris page scanner
clearing a bit
hand s investigating
investigating its value
handspread if scam-ate
seconds can pass
uncommon this means
clearing and investigating
investigating a bit
seconds as mentioned
pageout process checks
process checks memory
falls below desfree
intention of keeping
desfree free memory
process is unable
memory at desfree
kernel begins swapping
begins swapping processes
freeing all pages
allocated to swapped
processes in general
system is unable
unable to maintain
maintain the amount
memory at minfree
page recent releases
kernel have provided
enhancement involves recognizing
involves recognizing pages
pages from shared
shared libraries pages
libraries pages belonging
belonging to libraries
process another enhancement
enhancement concerns distinguishing
concerns distinguishing pages
processes from pages
allocated to regularfiles
process whose logical
space is larger
address space virtual
space virtual memory
map a large
smaller physical menlory
physical menlory virtual
menlory virtual memory
run extremely large
extremely large processes
raise the degree
increasing cpu utilization
frees application programmers
programmers from worrying
worrying about memory
availability in addition
processes can share
share system libraries
libraries and memory
memory also enables
type of process
child processes share
processes share actual
share actual pages
implemented by demand
demand paging pure
paging pure demand
paging never brings
referenced the first
system the operating-system
operating-system kernel consults
consults an internal
table to determine
finds a free
frame and reads
reads the page
store the page
table is updated
updated to reflect
instruction that caused
caused the page
fault is restarted
restarted this approach
entire memory image
performance is acceptable
paging to reduce
process this arrangement
arrangement can increase
allowing more processes
least-the cpu utilization
memory requirements exceed
total available physical
memory such processes
run in virtual
memory if total
total memory requirements
exceed the capacity
capacity of physical
pages from memory
memory to free
pages various page-replacement
replacement is easy
easy to program
program but suffers
suffers from belady
anomaly optimal page
page replacement requires
replacement requires future
future knowledge lru
knowledge lru replacement
approximation of optimal
implement most page-replacement
approximations of lru
replacement in addition
policy is needed
suggesting local page
local page replacement
suggesting global replacement
replacement the working-set
working-set model assumes
assumes that processes
execute in localities
localities the working
allocated enough frames
current working set
providing enough frames
process to avoid
thrashing may require
require process swapping
swapping and schedulil
systems provide features
features for memory
memory mappil1g files
access the win32
win32 api implements
api implements shared
implements shared memory
memory through memory
mappil1g files kernel
files kernel processes
processes typically req1.1ire
typically req1.1ire memory
allocated using pages
contiguous the buddy
memory to kernel
processes in units
results in fragmentation
fragmentation slab allocators
slab allocators assign
allocators assign kernel
assign kernel data
structures to caches
pages with slab
addition to reqmnng
solve the major
problems of page
replacement and frame
paging systern requires
segment where memory
system using figure
draw a tree
requests are allocated
bytes next modify
modify the tree
releases of memory
memory perform coalescing
virtual and physical
addresses with 256-byte
pages the list
equivalent physical addresses
addresses in hexadecimal
hexadecimal all numbers
algorithm should minimize
achieve this minimization
minimization by distributing
heavily used pages
frame a counter
counter a define
define a page-replacement
idea specifically address
address these problems
counters increased iii
page faults occur
four page frames
optimal pagereplacement strategy
string in part
cpu utilization paging
utilization paging disk
improve cpu utilization
cpu utilization explain
explain your answers
answers a install
install a faster
cpu b install
install a bigger
bigger paging disk
disk c increase
multiprogramming d decrease
install more main
n1.enl0ry f install
faster hard disk
disk or multiple
controllers with multiple
multiple hard disks
disks g add
algorithms h increase
demand-paged computer system
fixed at four
four the system
measured to determine
disk the results
multiprogramming be increased
increased to increase
increase the cpu
helping a cpu
percent ; disk
percent b cpu
percent c cpu
access and transfer
table in main
microsecond per memory
page table takes
takes two accesses
accesses to improve
added an associative
memory that reduces
associative memory assume
effective memory access
view of thread
states is ready
i.e is waiting
assuming a thread
thread change state
thread state diagram
diagram for exercise
generates a tlb
reference is resolved
discuss the hardware
hardware support required
page reference string
faults would occur
first unique pages
pages will cost
cost one fault
fault each lru
lru replacement fifo
replacement fifo replacement
fifo replacement optimal
replacement optimal replacement
system that allocates
scheme what modifications
memory system provide
frequently used page-replacement
page-replacement algorithm generates
algorithm generates fewer
generates fewer page
fewer page faults
recently used page-replacement
algorithm also discuss
circumstances the opposite
circumstances do page
faults occur describe
machine provides instructions
access memory locations
indirect addressing scheme
scheme what sequence
faults is ilccurred
indirect memory-load operation
per-process frame allocation
frame allocation technique
support for user-level
user-level and kernellevel
threads the mapping
multithreaded process consist
feature what hardware
support is required
required to implement
implement this feature
paged memory system
system with pages
pages of size
process that manipulates
manipulates the matrix
resides in page
faults are generated
replacement and assuming
assuming that page
system detect thrashing
eliminate this problem
monitoring the rate
pointer is moving
fast b pointer
algorithm for resident
recently used pages
pool is managed
recently used replacement
replacement policy answer
free space generated
newly requested page
resident page set
free-france pool managed
managed to make
number of resident
pages is set
object type assuming
cache per object
done to address
address this scalability
memory the page
table is held
held in registers
registers it takes
milliseconds to service
page is modified
replaced is modified
maximum acceptable page-fault
acceptable page-fault rate
segmentation is similar
similar to paging
variable-sized pages define
define two segment-replacement
two segment-replacement algorithms
segment-replacement algorithms based
based on fifo
fifo and lru
lru pagereplacement schemes
pagereplacement schemes remember
leave enough consecutive
segment consider strategies
strategies for systems
systems where segments
relocated and strategies
techniques and structures
structures are good
answers a stack
stack b hashed
hashed symbol table
table c sequential
search d binary
search e pure
code f vector
operations a indirection
requesting the page
page must block
block while waiting
brought from disk
disk into physical
physical memory assume
exists a process
mapping of user
threads to kernel
user thread incurs
fault while accessing
accessing its stack
user user threads
user threads belonging
process first starts
first starts execution
characterize the page
rate c assume
free memory identify
identify some options
options system designers
designers could choose
handle this situation
referenced an address
address in virtual
virtual memory describe
describe a scenario
scenario can occur
page fault tlb
fault tlb miss
miss and page
fault tlb hit
hit and page
bytes the computer
bytes of physical
implemented by paging
bytes a user
user process generates
generates the virtual
physical location distinguish
distinguish between software
list the costs
costs to exceed
exceed the benefits
illustrates the problem
problem with restarting
restarting the move
move character instruction
regions are overlapping
define the working-set
effect of setting
number of active
processes currently executing
two working sets
representing code explain
examine each page
discard that page
lru or second-chance
implements the fifo
lru page-replacement algorithms
page-replacement algorithms presented
random pagereference string
string where page
page numbers range
apply the random
random page-reference string
record the number
page faults incurred
implement the replacement
frames can vary
assume that demand
integer sequence c11
first catalan numbers
formula generating c11
design two programs
programs that communicate
communicate with shared
api as outlined
outlined in section
9.7.2 the producer
process will generate
generate the catalan
sequence and write
read and output
sequence from shared
passed an integer
numbers to produce
command line means
means the producer
generate the first
first five catalan
paging was first
first used iil
iil the atlas
manchester university muse
university muse computer
early demand-paging system
system was multics
researchers to observe
fifo replacement strategy
strategy may produce
anomaly that bears
demonstrated that stack
subject to belady
anomaly the optimal
optimal replacement algorithm
algorithm was presented
optimal by mattson
allocation ; prieve
prieve and fabry
presented an optimal
algorithm for situations
allocation can vary
vary the enl
enl lanced clock
lanced clock algorithm
algorithm was discussed
discussed by carr
carr and hennessy
model was developed
developed by denning
model were presented
presented by denning
scheme for monitoring
monitoring the page-fault
rate was developed
developed by wulf
applied this technique
burroughs bssoo computer
bssoo computer system
computer system wilson
presented several algoritluns
algoritluns for dynamic
memory allocation jolmstone
jolmstone and wilson
described various memory-fragmentation
issues buddy system
buddy system memory
system memory allocators
allocators were described
described in knowlton
peterson and norman
discussed the slab
bonwick and adams
extended the discussion
discussion to multiple
processors other memory-fitting
found in stephenson
survey of memory-allocation
found in wilson
described how windows
windows implements virtual
virtual memory mcdougall
discussed virtual memory
memory in solaris
solaris virtual memory
techniques in linux
linux and bsd
bsd were described
described by bovet
ganapathy and schimmel
discussed operating system
operating system support
page sizes ortiz
described virtual memory
real-time embedded operating
operating system jacob
implementations of virtual
architectures a companion
described the hardware
implementation of virtual
including the ultrasparc
main memory modern
memory modern computer
primary on-line storage
medium for information
disks a file
creator the files
files are mapped
system onto physical
physical devices files
directories for ease
aspects some devices
transfer a character
randomly some transfer
read-write they vary
greatly in speed
slowest major component
devices one key
provide the simplest
system because devices
file system consists
two distinct parts
collection of files
storing related data
system file systems
file systems live
live on devices
explore fully irl
chapters but touch
aspects of files
major directory structures
discuss the semantics
semantics of sharing
files among multiple
ways to handle
handle file protection
accessed to explain
explain the function
function of file
describe the interfaces
interfaces to file
discuss file-system design
file-system design tradeoffs
including access methods
structures to explore
explore file-system protection
file-system protection computers
uniform logical view
devices these storage
contents are persistent
persistent through power
failures and system
recorded on secondary
user s perspective
allotment of logical
logical secondary storage
written to secondary
rigidly in general
sequence of bits
file s creator
creator and user
user the concept
general the information
file is defined
types of information
defined which depends
type a text
sequence of characters
organized into lines
sequence of subroutines
subroutines and functions
organized as declarations
statements an object
organized in.to blocks
in.to blocks nnderstandable
system s linker
linker an executable
series of code
loader can bring
execute 10.1.1 file
10.1.1 file attributes
attributes a file
file is named
string of characters
example.c some systems
differentiate between uppercase
uppercase and lowercase
characters in names
system that created
user might create
create the file
user might edit
edit that file
file s owner
owner might write
write the file
system a file
humanreadable form identifier
identifier this unique
identifies the file
type this information
information is needed
needed for systems
support different types
types of files
location this information
size the current
possibly the maximum
maximum allowed size
size are included
attribute protection access-control
protection access-control information
access-control information determines
identification this information
monitoring the information
resides on secondary
directory entry consists
identifier the identifier
identifier in turn
kilobyte to record
record this information
megabytes because directories
device and brought
needed 10.1.2 file
10.1.2 file operations
operations a file
define a file
performed on files
files the operating
basic file operations
renaming a file
file two steps
create a file
file we discuss
file in chapter
file to write
write a file
make a system
searches the directory
directory to find
find the file
file s location
location the system
place the write
write occurs reading
reading a file
file to read
call that specifies
directory is searched
pointer is updated
current operation location
space and reducing
reducing system complexity
system complexity repositioning
file the directory
pointer is repositioned
involve any actual
i this file
file seek deleting
deleting a file
file to delete
search the directory
file having found
release all file
erase the directory
truncating a file
file the user
erase the contents
forcing the user
user to delete
delete the file
attributes to remain
remain unchanged -except
-except for file
file length-but lets
lets the file
file be reset
reset to length
file space released
basic operations comprise
comprise the minimal
set of required
required file operations
operations other common
common operations include
operations include appending
appending new information
file and renaming
renaming an existing
file these primitive
combined to perform
perform other file
operations for instance
user to determine
determine the status
file s length
file operations mentioned
operations mentioned involve
mentioned involve searching
searching the directory
file to avoid
avoid this constant
call be made
file is first
first used actively
actively the operating
operation is requested
searching is required
operating system removes
removes its entry
open-file table create
delete are system
calls that work
work with closed
files some systems
systems implicitly open
open a file
made the file
job or program
program that opened
opened the file
terminates most systems
takes a file
copying the directory
table the open
accept accessmode information-create
mode is checked
file s permissions
mode is allowed
process the open
call typically returns
table this pointer
searching and simplifying
simplifying the system-call
interface the implementation
processes may open
levels of internal
table the perprocess
perprocess table tracks
tracks all files
process has open
table is information
process for instance
current file pointer
file is found
found here access
file and accounting
included each entry
table in turn
system-wide open-file table
table the system-wide
table contains process-independent
system-wide table includes
includes an entry
executes an open
process s open-file
open-file table pointing
open each close
decreases this open
open count reaches
file s entry
entry is removed
table in summary
pieces of information
open file file
file file pointer
pointer on systems
include a file
offset as part
systein must track
last readwrite location
pointer this pointer
pointer is unique
on-disk file attributes
file attributes file-open
attributes file-open count
count as files
files are closed
system must reuse
reuse its open-file
open-file table entries
out of space
table because multiple
opened a file
system must wait
file to close
close before removing
removing the open-file
open-file table entry
entry the file-open
file-open counter tracks
number of opens
opens and closes
closes and reaches
close the system
remove the entry
entry disk location
file most file
file operations require
system to modify
file the information
needed to locate
locate the file
operation access rights
rights each process
opens a file
mode this information
information is stored
subsequent i requests
requests some operating
systems provide facilities
facilities for locking
locking an open
lock a file
file and prevent
prevent other processes
processes from gaining
system log file
accessed and modified
system file locking
locking in java
acquiring a lock
lock requires firstobtaini
i..lechannel fbr thefile
locked the loc
lock the api
method is filelock
begin and end
gi1iningand ending positions
region being locked
settingshared to true
isfb ~ shared
locks ; setting
shared to false
lock exclusively tice
exclusively tice lock
released by invoking
invoking the release
illusttates file locking
acquires two locks
locks on thefilefile
txt the first
first half of.the
half of.the file
file is acquired
file locks provide
locks provide functionality
provide functionality similar
similar to reader-writer
6.6.2 a shared
lock is akin
processes can acquire
concurrently an exclusive
exclusive lock behaves
provide both types
systems only provide
provide exclusive file
exclusive file locking
systems may provide
provide either mandatory
mandatory or advisory
advisory file-locking mechanisms
lock is n1.andatory
acquires an exclusive
system will prevent
accessing the locked
assume a process
file system .log
open system .log
text editor-the operating
editor-the operating system
released this occurs
explicitly to acquire
lock is advisory
prevent the text
editor from acquiring
lock before accessing
scheme is mandatory
system ensures locking
ensures locking integrity
integrity for advisory
ensure that locks
operating systems adopt
systems adopt mandatory
adopt mandatory locking
unix systems employ
systems employ advisory
employ advisory locks
file locks requires
precautions as ordinary
ordinary process synchronization
developing on systems
systems with mandatory
careful to hold
hold exclusive file
exclusive file locks
processes from accessing
acquire file locks
locks 10.1.3 file
10.1.3 file types
design a file
entire operating system-we
system should recognize
recognize and support
support file types
operating system recognizes
recognizes the type
file in reasonable
common mistake occurs
print the binary-object
program this attempt
attempt normally produces
attempt can succeed
program a common
technique for implementing
implementing file types
include the type
type as part
period and terminated
extension of additional
additional characters file
file name examples
examples include resume.doc
instance the .com
.com and .exe
forms of binary
binary executable files
operating system ms-dos
system ms-dos recognizes
assemblers expect source
expect source files
microsoft word word
word word processor
word processor expects
expects its files
ready ~ to-run
machineor none language
language program object
program object obj
linked source code
languages batch bat
command interpreter text
interpreter text txt
doc textual data
documents wo rdprocessor
wordcprocessor doc formats
doc formats library
formats library lib
dll libraries o.troutines
o.troutines for .programmers
print or view
ascii or binary
format for printing
printing or viewing
viewing archive arc
related files grouped
grouped into .one
.one file,sometimes compressed
archiving or storage
storage multimedia mpeg
file containing mp3
common file types
file types end
extension these extensions
extension it expects
considered as hints
applications that operate
utility of file
tops-20 operating system
execute an object
program whose source
file was produced
automatically this function
user always runs
runs an up-to-date
up-to-date object file
user could waste
waste a significant
discriminate the source
file was created
created or last
determine the language
program that created
attribute is set
enforced and supported
opens that file
double-clicking the mouse
representing the file
processor is invoked
edited the unix
roughly the type
files have magic
enforced nor depended
users in determining
determining what type
type of contents
contents the file
file contains extensions
application s programmer
programmer 10.1.4 file
10.1.4 file structure
file structure file
structure file types
file as mentioned
files have structures
structures that match
match the expectations
programs that read
files must conform
operating system requires
memory to load
operating systems extend
extend this idea
set of system-supported
system-supported file structures
sets of special
operations for manipulating
structures for instance
dec s vms
vms operating system
supports three defined
defined file structures
structures this point
system support multiple
support multiple file
multiple file structures
system is cumbersome
code to support
support these file
structures in addition
define every file
file types supported
applications require information
require information structured
structured in ways
ways not supported
problems may result
supports two types
composed of ascii
ascii characters separated
return and line
executable binary files
define an encrypted
file to protect
protect the contents
read by unauthorized
find neither file
ascii text lines
circumvent or misuse
misuse the operating
system s file-type
mechanism or abandon
abandon our encryption
scheme some operating
operating systems impose
number of file
structures this approach
adopted in unix
considers each file
bits is made
systenl this scheme
scheme provides maximum
support each application
program must include
code to interpret
interpret an input
systems must support
load and run
programs the macintosh
system also supports
supports a minimal
structures it expects
fork contains information
information of interest
user for instance
holds the labels
program a foreign
re-label these buttons
system provides tools
fork the data
fork contains program
code or data-the
data-the traditional file
traditional file contents
contents to accomplish
unix or ms-dos
change and recompile
recompile the source
user-changeable data file
save the programmer
programmer substantial effort
structures make programming
make programming inconvenient
bloat and programmer
confusion 10.1.5 internal
10.1.5 internal file
internal file structure
locating an offset
operating system disk
system disk systems
well-defined block size
block size determined
sector all disk
i is performed
performed in units
physical record size
match the length
desired logical record
logical record logical
record logical records
vary in length
paddng a number
number of logical
records into physical
defines all files
streams of bytes
bytes each byte
logical record size
byte the file
system automatically packs
packs and unpacks
bytes into physical
physical disk blockssay
bytes per block-as
physical block size
packing technique determine
block the packing
user s application
considered a sequence
sequence of blocks
basic i functions
operate in terms
terms of blocks
blocks the conversion
conversion from logical
records to physical
simple software problem
problem because disk
allocated in blocks
allocated four blocks
wasted the waste
units of blocks
file systems suffer
larger the block
greater the internal
internal fragmentation files
fragmentation files store
files store information
accessed and read
read into computer
memory the information
ways some systems
method for files
files other systems
support many access
choosing the right
major design problem
beginning current position
current position end
rewind ~ read
write ~ figure
file 10.2.1 sequential
10.2.1 sequential access
access the simplest
simplest access method
file is processed
processed in order
mode of access
editors and compilers
compilers usually access
file a read
read operation-read next-reads
advances a file
write operation-write next-appends
file and advances
newly written material
end of file
backward n records
file and works
10.2.2 direct access
file is made
programs to read
order the direct-access
method is based
disks allow random
block for direct
file is viewed
blocks or records
order of reading
reading or writing
direct-access file direct-access
file direct-access files
access to large
amounts of information
compute which block
read that block
directly to provide
provide the desired
seats for flight
stored in block
file to store
compute a hash
people s names
names or search
search a small
small in-ncemory index
index to determine
determine a block
block to read
read and search
modified to include
include the block
simulation of sequential
direct-access file access
add an operation
operation position file
effect a read
relative block number
first relative block
absolute disk address
relative block numbers
system to decide
helps to prevent
prevent the user
user from accessing
file some systems
start their relative
request for record
record nina file
nina file assuming
logical record length
assuming the first
easy to read
delete a record
support both sequential
sequential and direct
access for files
sequential file access
access some systems
file be defined
defined as sequential
sequential or direct
easily simulate sequential
simulate sequential access
keeping a variable
defines our current
simulating a direct-access
inefficient and clumsy
10.2.3 other access
methods other access
method these methods
methods generally involve
involve the construction
blocks to find
find a record
search the index
access the file
file might list
list the universal
prices each record
consists a 10-digit
records per block
block a file
records would occupy
keeping the file
sorted by upc
define an index
block this index
logical record last
last name number
number adams arthur
social ~ security
index file relative
file relative file
relative file figure
irdex and relative
relative files find
find the price
make a binary
record and access
access that block
block this structure
search a large
large file doing
i with large
create an index
file the primary
primary index file
pointers to secondary
secondary index files
actual data items
ibm s indexed
indexed sequential-access method
small master index
index that points
points to disk
index the secondary
secondary index blocks
index blocks point
actual file blocks
blocks the file
key to find
index this block
block is read
find the block
block is searched
two direct-access reads
direct-access reads figure
shows a similar
situation as implemented
implemented by vms
index and relative
general-purpose computer stores
billions of files
files are stored
stored on random-access
random-access storage devices
including hard disks
disks a storage
subdivided for finer-grained
quarter can hold
hold a file
file system storage
system storage devices
sets that provide
disks are subdivided
collected into raid
raid sets partitioning
limiting the sizes
sizes of individual
individual file systems
putting multiple file-system
multiple file-system types
space or unformatted
partition a files
partition c files
partition b files
typical file-system organization
file-system organization space
organization space partitions
disk any entity
multiple devices linked
set each volume
virtual disk volumes
store multiple operating
allowing a system
system to boot
boot and run
system each volume
system this information
records information -such
type-for all files
shows a typical
organization 10.3.1 storage
10.3.1 storage structure
multiple storage devices
hold file systems
file systems computer
systems computer systems
dozens of file
dozen different types
file system list
list in fig1-1re
general-purpose file systems
special-purpose file systems
types of file
solaris example mentioned
tmpfs-a temporary file
temporary file system
created in volatile
volatile main memory
reboots or crashes
crashes objfs-a virtual
objfs-a virtual file
virtual file system
essentially an interface
access to kernel
symbols dfs-a virtual
dfs-a virtual file
system that maintains
maintains contract information
information to manage
manage which processes
run during operation
system contract ctfs
etc svc tmpfs
system object objfs
solaris file system
file system lofs-a
system lofs-a loop
loop back file
back file system
accessed in place
prods-a virtual file
system that presents
file system ufs
zfs-general-purpose file systems
systems the file
systems of computers
files into groups
groups and manage
manage and act
groups this organization
explore the topic
topic of directory
structure 10.3.2 directory
10.3.2 directory overview
overview the directory
table that translates
translates file names
examine several schemes
schemes for defining
defining the logical
mind the operations
search a directory
structure to find
find the entry
file since files
files have symbolic
relationship between files
find all files
files whose names
file new files
created and added
list a directory
list the files
rename a file
represents its contents
file changes renaming
access every directory
structure for reliability
idea to save
save the contents
contents and structure
system at regular
copyin.g all files
files to magn.etic
tape this technique
copy in case
case of system
failure in addition
copied to tape
released for reuse
directory 10.3.3 single-level
10.3.3 single-level directory
directory the simplest
simplest directory structure
directory all files
files are contained
easy to support
support and understand
directory has significant
number of files
two users call
call their data
data file test
rule is violated
assign2 although file
selected to reflect
reflect the content
limited in length
complicating the task
task of making
making file names
file names unique
unique the ms-dos
11-character file names
names ; unix
directory may find
find it difficult
difficult to remember
remember the names
directory files figure
hundreds of files
number of additional
system keeping track
task 10.3.4 two-level
10.3.4 two-level directory
directory often leads
leads to confusion
confusion of file
users the standard
two-level directory structure
ufds have similar
single user w11en
w11en a user
user job starts
searched the mfd
mfd is indexed
indexed by user
ufd is searched
ufd are unique
unique to create
operating system searches
user s ufd
ufd to ascertain
exists to delete
operating system confines
confines its search
delete another user
user s file
special system program
program is run
information the program
ufd and adds
adds an entry
mfd the execution
restricted to system
administrators the allocation
allocation of disk
space for user
directory structure solves
solves the name-collision
disadvantages this structure
structure effectively isolates
isolates one user
local user files
users if access
user s directory
mfd its direct
ufds the descendants
descendants of user
user file directory
file directory figure
file name defines
defines a path
file name define
define a path
user a wishes
test file named
file named test
test to access
test of user
directory-entry name userb
syntax for naming
files in directories
syntax is needed
file for instance
ms-dos a volume
userb \ fest
fest some systems
separate the volume
file name parts
specification for instance
number other systems
systems simply treat
treat the volume
directory and file
test a special
system files programs
files programs provided
provided as part
on-are generally defined
defined as files
files are read
loader and executed
executed many command
interpreters simply treat
file to load
system is defined
ufd one solution
copy the system
files would waste
waste an enormous
amount of space
system files require
users would require
complicate the search
search procedure slightly
slightly a special
special user directory
directory is defined
system first searches
searches the local
system automatically searches
searches the special
files the sequence
sequence of directories
list of directories
directories to search
unix and ms-dos
path 10.3.5 tree-structured
10.3.5 tree-structured directories
view a two-level
extend the directory
tree of arbitrary
generalization allows users
users to create
organize their files
common directory structure
structure the tree
tree-structured directory structure
structure a directory
set of files
files or subdirectories
subdirectories a directory
simply another file
format one bit
directory entry defines
defines the entry
special system calls
directories in normal
process when reference
file is needed
change the current
holding that file
file to change
call is provided
provided that takes
takes a directory
redefine the current
user can change
change his current
change directory system
directory system call
open system calls
system calls search
search the current
entry that stands
directory the initial
initial current directory
user is designated
searches the accounting
find an entry
user s initial
directory this pointer
pointer is copied
user that specifies
specifies the user
spawned the current
spawned path names
absolute and relative
relative an begins
giving the directory
path a defi11es
defi11es a path
tree-structured file system
system of figure
allowing a user
user to define
files this structure
structure might result
result in separate
directories for files
subdirectory was created
created to hold
hold the text
forms of information
bin may store
interesting policy decision
tree-structured directory concerns
handle the deletion
directory is empty
simply be deleted
suppose the directory
delete a directory
exist this procedure
approach can result
work an alternative
unix rm command
provide an option
made to delete
directory s files
files and subdirectories
deleted either approach
entire directory structure
command is issued
issued in error
assuming a backup
tree-structured directory system
allowed to access
file of user
path names user
change her current
directory and access
names a path
users to access
remember these long
operating system automates
automates the search
search for executable
programs one method
maintain a file
disk is added
network is accessed
operating system traverses
traverses the directory
searching for executable
device and recording
recording the pertinent
information this mechanism
supports the double-dick
double-dick execution functionality
execution functionality described
functionality described previously
previously a double-dick
program is started
input 10.3.6 acyclic-graph
10.3.6 acyclic-graph directories
project the files
projects and files
acyclic-graph directory structure
directories the common
shared a shared
directory or file
file will exist
tree structure prohibits
prohibits the sharing
sharing of files
directories an acyclic
acyclic graph -that
directories to share
subdirectories and files
file or subdirectory
two different directories
directories the acyclic
tree-structured directory scheme
programmer can view
view the copy
actual file exists
important for subdirectories
subdirectories when people
people are working
directory the ufd
directory of shared
organization may require
project shared files
ways a common
link a link
effectively a pointer
entry is marked
file is included
information we resolve
resolve the link
locate the real
real file links
type on systems
pointers the operating
operating system ignores
ignores these links
links when traversing
traversing directory trees
trees to preserve
preserve the acyclic
system another common
implementing shared files
simply to duplicate
duplicate all information
entries are identical
identical and equal
link the link
original directory entry
equal duplicate directory
duplicate directory entries
make the original
indistinguishable a major
problem with duplicate
entries is maintaining
file is modified
modified an acyclic-graph
simple tree structure
complex several problems
carefully a file
multiple absolute path
absolute path names
distinct file names
file this situation
problem for programming
traverse the entire
file system-to find
find a file
copy all files
files to backup
backup storage-this problem
problem becomes significant
traverse shared structures
problem involves deletion
file be deallocated
deallocated and reused
reused one possibility
remove the file
action may leave
leave dangling pointers
now-nonexistent file worse
remaining file pointers
pointers contain actual
actual disk addresses
pointers may point
system where sharing
sharing is implemented
implemented by symbolic
easier to handle
affect the original
link is removed
file is deallocated
leaving the links
links and remove
leave the links
fail to resolve
access is treated
file is deleted
case of unix
links are left
user to realize
replaced microsoft windows
approach another approach
approach to deletion
preserve the file
deleted to implement
mechanism for determining
entries or symbolic
entry is established
entry is added
link or directory
entry is deleted
remove its entry
list the file
list is empty
empty the trouble
potentially large size
entire list -we
directory entry increments
increments the reference
count ; deleting
deleting a link
link or entry
decrements the count
keeping a reference
file information block
effectively prohibiting multiple
prohibiting multiple references
references to directories
maintain an acyclic-graph
structure to avoid
directories or links
graph 10.3.7 general
10.3.7 general graph
general graph directory
structure is ensuring
tree-structured directory results
adding new files
existing tree-structured directory
tree-structured directory preserves
preserves the tree-structured
tree-structured nature howeve1
structure is destroyed
simple graph structure
algorithms to traverse
traverse the graph
avoid traversing shared
traversing shared sections
searched a major
major shared subdirectory
file without finding
searching that subdirectory
cycles are allowed
allowed to exist
searching any component
reasons of correctness
poorly designed algorithm
algorithm might result
loop continually searching
terminating one solution
arbitrarily the number
number of directories
search a similar
similar problem exists
deleted with acyclic-graph
acyclic-graph directory structures
reference count means
file or directory
possibility of self-referencing
reallocated garbage collection
garbage collection involves
collection involves traversing
traversing the entire
similar marking procedure
traversal or search
search will cover
disk-based file system
extremely time consuming
seldom attempted garbage
attempted garbage collection
easier to work
links are added
lir1k will complete
complete a cycle
cycles in graphs
storage a simpler
case of directories
directories and links
links during directory
directory traversal cycles
cycles are avoided
overhead is incurred
out of multiple
mounted to make
file-system name space
space the mount
procedure is straightforward
straightforward the operating
attached some operating
operating systems require
file system type
type be provided
inspect the structures
device and determine
determine the type
directory for instance
user s home
access the directory
precede the directory
motmting that file
operating system verifies
valid file system
driver to read
read the device
directory and verifying
operating system notes
system is n1.ounted
point this scheme
enables the operating
system to traverse
traverse its directory
switching among file
systems of varying
illustrate file mounting
file system depicted
triangles represent subtrees
subtrees of directories
shows an existing
existing file system
shows an unmounted
unmounted volume residing
shows the effects
effects of mounting
volume the volume
volume is unmounted
system is restored
systems impose semantics
semantics to clarify
system may disallow
disallow a mount
make the mounted
mounted file system
directory and obscure
obscure the directory
directory s existing
system is unmounted
system and allowing
mount per file
classic macintosh operating
encounters a disk
disks are found
found at boot
mounts the file
adding a folder
newly mounted file
file system mac
based all file
systems are mounted
directory the mac
hides this fact
fact and shows
shows the file
level the microsoft
microsoft windows family
maintains an extended
extended two-level directory
devices and volumes
volumes assigned drive
assigned drive letters
drive letters volumes
graph directory structure
letter the path
specific file takes
form of drive-letter
unix does windows
discover all devices
devices and mount
mount all located
located file systems
systems at boot
commands are explicit
explicit a system
system configuration file
list of devices
points for automatic
mounting at boot
executed manually issues
issues concerning file
file system mounting
explored the motivation
motivation for file
involved in allowing
files such file
desirable for users
reduce the effort
required to achieve
achieve a computing
user-oriented operating systems
systems must accommodate
files in spite
examine more aspects
aspects of file
sharing we begin
discussing general issues
issues that arise
arise when multiple
multiple users share
users share files
files once multiple
users are allowed
sharing to multiple
multiple file systems
including remote file
remote file systems
discuss that challenge
conflicting actions occurring
occurring on shared
files for instance
users are writing
writes be allowed
allowed to occurf
operating system protect
protect the users
users  actions
10.5.1 multiple users
operating system accommodates
system accommodates multiple
accommodates multiple users
issues of file
protection become preeminent
shared by users
system must mediate
mediate the file
sharing the system
user to access
access the files
users by default
default or require
user specifically grant
specifically grant access
issues of access
control and protection
sharing and protection
system must maintain
maintain more file
file and directory
meet this requirement
systems have evolved
concepts of file
group the owner
attributes and grant
file the group
group attribute defines
defines a subset
subset of users
system can issue
file s group
group can execute
execute one subset
users can execute
execute another subset
subset of operations
executed by group
users is definable
owner more details
details on permission
attributes are included
section the owner
owner and group
requests an operation
attribute to determine
compared the result
permissions are applicable
applicable the system
system then applies
applies those permissions
systems have multiple
multiple local file
local file systems
volumes on multiple
multiple attached disks
checking and permission
mounted 10.5.2 remote
10.5.2 remote file
advent of networks
communication among remote
world one obvious
resource to share
share is data
form of files
evolution of network
network and file
remote file-sharing methods
methods have changed
changed the first
first implemented method
implemented method involves
involves manually transferring
manually transferring files
files between machines
machines via programs
programs like ftp
directories are visible
first a browser
browser is needed
needed to gain
essentially a wrapper
wrapper for ftp
transfer files ftp
anonymous and authenticated
user to transfer
system the world
web uses anonymous
anonymous file exchange
exchange almost exclusively
exclusively dfs involves
accessing the remote
providing the files
files this integration
integration adds complexity
10.5.2.1 the client-server
client-server model remote
model remote file
computer to mom1.t
machine seeking access
client the client-server
relationship is common
common with networked
clients and specifies
clients a server
server can serve
serve multiple clients
facility the server
server usually specifies
volume or directory
directory level client
level client identification
difficult a client
result of spoofing
server more secure
secure solutions include
solutions include secure
include secure authentication
client via encrypted
including ensuring compatibility
security of key
difficulty of solving
solving these problems
unsecure authentication methods
network file system
authentication takes place
client networking information
user s ids
server must match
unable to determine
determine access rights
rights to files
server a request
server will determine
determine if user
basing the determination
granted or denied
based on incorrect
incorrect authentication information
information the server
server must trust
trust the client
client to present
present the correct
user id note
protocols allow many-to-many
servers can provide
clients in fact
remote file system
system is mounted
file operation requests
user the server
server then applies
applies the standard
standard access checks
checks to determine
user has credentials
credentials to access
requested the request
allowed or denied
handle is returned
file the client
closes the file
file when access
access is completed
completed the operating
system may apply
apply semantics similar
local file-system mount
semantics 10.5.2.2 distributed
10.5.2.2 distributed information
distributed information systems
systems to make
make client-server systems
client-server systems easier
provide unified access
needed for remote
including the world
dns became widespread
e-mail or ftp
hosts this methodology
16.5.1 other distributed
information systems provide
systems provide user
distributed facility unix
facility unix systems
systems have employed
employed a wide
variety of distributed-information
distributed-information methods sun
methods sun microsystems
sun microsystems introduced
microsystems introduced yellow
introduced yellow pages
storage of user
including sending user
sending user passwords
user passwords unencrypted
sun s nis
replacement for nis
conjunction with user
requested file system
user names m.u.st
names m.u.st match
match from machine
two distributed naming
distributed naming structures
structures to provide
provide a single
single name space
space for users
users the older
older naming technology
distributed naming facility
servers to authenticate
users the industry
industry is moving
secure distributed naming
distributed naming mechanism
mechanism in fact
active is based
based on ldap
ldap sun microsystems
sun microsystems includes
microsystems includes ldap
employed for user
retrieval of information
availability of printers
distributed ldap directory
organization to store
store all user
user and resource
organization s computers
computers the result
enter their authentication
ease system-administration efforts
efforts by combining
distributed information services
services 10.5.2.3 failure
10.5.2.3 failure modes
failure modes local
modes local file
systems can fail
collectively called disk-controller
host-adapter failure user
user or system-administrator
lost or entire
directories or volumes
host to crash
required to repair
repair the damage
damage remote file
complexity of network
interactions between remote
problems can interfere
operation of remote
case of networks
hosts such interruptions
interruptions can result
result from hardware
poor hardware configuration
networking implementation issues
networks have built-in
including multiple paths
paths between hosts
interrupt the flow
flow of dfs
performing directory lookups
lookups to open
data to files
reachable this scenario
system to act
local file system
system were lost
terminate all operations
server or delay
reachable these failure
semantics are defined
plemented as part
remote-file-system protocol termination
result in users
users  losing
losing data-and patience
protocols either enforce
delaying of file-system
operations to rencote
implement this kind
kind of recovery
recovery from failure
server and client
client maintain knowledge
activities and open
remotely rnounted exported
rnounted exported file
exported file systems
systems and opened
takes a simple
implementing a dfs
dfs in essence
open the nfs
nfs protocol carries
file and perform
perform the requested
track which clients
exported volumes mounted
stateless approach makes
approach makes nfs
makes nfs resilient
makes it unsecure
requisite mount request
request and permission
place these issues
issues are addressed
industry standard nfs
standard nfs version
nfs is made
stateful to improve
improve its security
functionality 10.5.3 consistency
10.5.3 consistency semantics
consistency semantics represent
represent an important
criterion for evaluating
evaluating any file
supports file sharing
sharing these semantics
access a shared
shared file simultaneously
modifications of data
users these semantics
implemented as code
file system consistency
system consistency semantics
algorithms of chapter
case of file
latencies and slow
slow transfer rates
rates of disks
disks and networks
performing an atomic
disk could involve
involve several network
systems that attempt
set of functionalities
tend to perform
poorly a successful
implementation of complex
complex sharing semantics
andrew file system
series of file
operations the series
series of accesses
sketch several prominent
examples of consistency
10.5.3.1 unix semantics
semantics the unix
unix file system
user are visible
open one mode
mode of sharing
sharing allows users
share the pointer
pointer of current
image that interleaves
interleaves all accesses
single physical image
exclusive resource contention
image causes delays
delays in user
processes 10.5.3.2 session
10.5.3.2 session semantics
semantics the andrew
allowed to perform
perform both read
constraints are enforced
enforced on scheduling
accesses 10.5.3.3 immutable-shared-files
10.5.3.3 immutable-shared-files semantics
semantics a unique
file is declared
declared as shared
cam1ot be modified
modified an immutable
two key properties
immutable file signifies
file are fixed
fixed the implementation
sharing is disciplined
safe from physical
issue of reliability
issue of protection
provided by duplicate
copies of files
files many computers
computers have systems
copy disk files
files to tape
tape at regular
day or week
week or month
maintain a copy
accidentally destroyed file
destroyed file systems
damaged by hardware
errors in reading
surges or failures
deleted accidentally bugs
reliability is covered
small single-user system
removing the floppy
disks and locking
drawer or file
mechanisms are needed
types of access
ability to access
access files systems
provide complete protection
protection by prohibiting
provide free access
protection both approaches
extreme for general
needed is protection
protection mechanisms provide
mechanisms provide controlled
provide controlled access
access by limitin.g
limitin.g the types
access is permitted
permitted or denied
type of access
types of operations
file write write
write or rewrite
rewrite the file
file execute load
execute it append
write new information
file delete delete
file and free
free its space
reuse list list
file other operations
editing the file
program that makes
makes lower-level system
lower-level system calls
system calls protection
protection is provided
level for instance
copying a file
user with read
application a small
small computer system
types of protection
large corporate computer
operations we discuss
discuss some approaches
approaches to protection
sections and present
treatment in chapter
10.6.2 access control
make access dependent
user different users
implement dependent access
acju specifying user
user requests access
checks the access
user is listed
access is allowed
protection violation occurs
job is denied
file this approach
advantage of enabling
enabling complex access
complex access methodologies
methodologies the main
problem with access
read a file
list all users
users with read
access this technique
two undesirable consequences
tedious and unrewarding
advance the list
list of users
system the directory
previously of fixed
complicated space management
management these problems
list to condense
condense the length
recognize three classifications
classifications of users
users in connection
owner the user
user who created
created the file
group a set
sharing the file
work group universe
constitute the universe
common recent approach
combine access-control lists
universe accesscontrol scheme
scheme just described
categories of access
access by default
added to specific
fine-grained access control
control is desired
desired to illustrate
hired three graduate
project the text
file named book
book the protection
invoke all operations
allowed to delete
sara is interested
interested in letting
read the text
achieve such protection
textwith members jim
set in accordance
grant temporary access
access to chapter
give him access
add another group
group to chapter
nith the addition
addition of access-control-list
access control list
list of chapter
permissions and access
tightly this control
created and modified
control is achieved
achieved through human
file can create
modify the access-control
access-control list access
list access lists
lists are discussed
limited protection classification
fields are needed
needed to define
collection of bits
prevents the access
unix system defines
defines three fields
bits each -rwx
controls read access
controls write access
execution a separate
bits per file
file are needed
record protection information
rand w bits
set one difficulty
difficulty in combining
user interface users
optional acl permissions
permissions are set
appends the regular
pbg-la.ptof \ users
permissions for gue
full contml h-1odi
a.d g execute
r.ead vi spec
permissions orfor advanced
orfor advanced settings
advanced settings click
settings click .a.dva.nced
click .a.dva.nced .a.dva.nced
.a.dva.nced .a.dva.nced figure
windows xp access-control
access-control list management
file1 a separate
set of commands
setfacl and getfacl
manage the acls
windows xp users
users typically manage
typically manage access-control
manage access-control lists
shows a file-permission
window on windows
ntfs file system
specifically denied access
lo.tex another difficulty
difficulty is assigning
precedence when permission
permission and acls
acl granting joe
granting joe read
write by joe
joe be granted
solaris gives acls
assigned by default
rule that specificity
10.6.3 other protection
approaches another approach
associate a password
passwords are chosen
randomly and changed
effective in limiting
number of passwords
remember may permissions
protection and file
protection are handled
user can list
list the content
subdirectory is set
field a sample
sample directory listing
environment is shown
first field describes
describes the protecti.on
s11bdirectory also shown
number of links
file in bytes
date of last
finally the file
-rw-rw-r l pbg
-rwxr-xr-x l pbg
drwx ~ -x--x
making the scheme
files are accessible
accessible ; protection
basis some systems
user to associate
ibmvm operating system
access some single-user
single-user operating systencs-such
systencs-such as ms-dos
ms-dos and versions
prior to mac
mac os x-provide
terms of file
protection in scenarios
networks file sharing
sharing and communication
designing a feature
easier than adding
adding a feature
multilevel directory structure
collections of files
files in subdirectories
mechanism for directory
protection the directory
control the creation
deletion of files
directory in addition
user can determine
determine the existence
file is significant
listing the contents
path name refers
file in systems
systems where files
numerous path names
acyclic or general
data type defined
sequence of logical
records a logical
complex data item
item the operating
support various record
leave that support
program the major
map the logical
logical file concept
concept onto physical
physical storage devices
tape or disk
order logical records
system or left
program each device
table of contents
device directory listing
listing the location
device in addition
organized a single-level
system causes naming
two-level directory solves
solves this creating
files the directory
includes the file
directory a tree-structured
user to create
subdirectories to organize
organize files acyclic-graph
files acyclic-graph directory
directory structures enable
structures enable users
files but complicate
searching and deletion
deletion a general
general graph structure
structure allows complete
requires garbage collection
collection to recover
recover unused disk
unused disk space
disk space disks
disks are segmented
left raw file
raw file systems
system s naming
structures to make
naming scheme varies
varies by operating
system once mounted
unmounted to disable
maintenance file sharing
file sharing depends
limits on sharing
sharing distributed file
systems allow client
hosts to mount
volumes or directories
directories from servers
network remote file
file systems present
systems present challenges
challenges in reliability
security distributed information
information systems maintain
servers can share
share state information
information to ncanage
access since files
main information-storage mechanism
protection is needed
type of access-read
provided by access
systems provide file
provide file sharing
sharing by maintaining
maintaining a single
maintain several copies
discuss the relative
systems automatically open
job terminates discuss
describe the protection
arise b suggest
suggest a scheme
scheme for dealing
systems keep track
implement multiple file
multiple file types
types which system
supports 5,000 users
5,000 users suppose
access one file
scheme in unix
suggest another protection
provided by unix
disadvantages of providing
providing ncandatory locks
locks whose usage
usage is left
left to users
users  discretion
information about files
operating system maintain
maintain a separate
maintain one table
references to files
two different programs
programs or users
benefit from operatingsystem
support for random
access to indexed
disadvantages of associating
associating with remote
stored on file
set of failure
simulate a multilevel
single-level directory structure
arbitrarily long names
multilevel directory scheme
explain what prevents
prevents your simulation
simulation s success
change if file
names were limited
implications of supporting
supporting unix consistency
unix consistency semantics
semantics for shared
stored on remote
operating system knew
access file data
exploit this information
information to improve
disk space reclaimed
reclaimed while links
file still exist
exist what problems
problems may occur
problems be avoided
disadvantages of supporting
links to files
files that cross
cross mount points
file link refers
disadvantages of recording
discussions concerning file
systems are offered
offered by grosshans
golden and pechura
describe the structure
structure of microcomputer
microcomputer file systems
file systems database
systems database systems
structures are described
described in full
full in silberschatz
structure was first
systems now implement
structures these include
designed by sun
spread across networked
networked computer systems
computer systems nfs
described in rfc3505
discussion of solaris
solaris file systems
systems is found
sun system administration
system administration guide
devices and file
sun com app
dns was first
adding several major
major features eastlake
proposed security extensions
dns hold security
hold security keys
security keys ldap
x.soo distributed directory
distributed directory protocol
defined by yeong
operating systems interesting
systems interesting research
research is ongoing
area of file-system
relating to file
naming and attributes
system from bell
makes all objects
display a list
user simply lists
lists the contents
type the file
file i dev
storage and access
access to file
programs the file
designed to hold
hold a large
amount of data
permanently this chapter
concerned with issues
issues surrounding file
surrounding file storage
common secondary-storage medium
disk we explore
ways to structure
allocate disk space
recover freed space
track the locations
locations of data
interface other parts
system to secondary
secondary storage performance
storage performance issues
issues are considered
chapter to describe
describe the details
details of implementing
implementing local file
systems and directory
structures to describe
describe the implementation
implementation of remote
discuss block allocation
allocation and free-block
algorithms and trade-offs
trade-offs disks provide
provide the bulk
system is maintained
characteristics that make
medium for storing
storing multiple files
rewritten in place
read a block
modify the block
place a disk
disk can access
directly any block
block of information
simple to access
access any file
moving the read-write
heads and waiting
disk to rotate
rotate we discuss
discuss disk structure
structure in great
improve i efficiency
transfers between memory
memory and disk
disk are performed
blocks each block
sector size varies
bytes provide efficient
efficient and convenient
disk by allowing
easily a file
file system poses
user this task
task involves defining
defining a file
problem is creating
algorithms and data
structures to map
logical file system
physical secondary-storage devices
devices the file
levels the structure
design each level
features of lower
levels to create
create new features
levels the lowest
handlers to transfer
system a device
translator its input
consists of high-level
consists of lowlevel
system the device
driver usually writes
writes specific bit
specific bit patterns
patterns to special
controller s memory
controller which device
location to act
details of device
infrastructure are covered
issue generic commands
write physical blocks
disk each physical
block is identified
numeric disk address
layer also manages
manages the memory
buffers and caches
hold various file-system
blocks a block
block application programs
programs ~ logical
system ~ file-organization
module ~ basic
basic file system
control devices figure
layered file system
buffer is allocated
block can occur
anager must find
find more buffer
ncemory or free
free up buffer
i to complete
metadata to improve
managing their contents
contents is critical
critical for optimum
optimum system performance
blocks by knowing
knowing the type
module can translate
translate logical block
logical block addresses
physical block addresses
system to transfer
transfer each file
file s logical
blocks are numbered
match the logical
translation is needed
locate each block
block the file-organization
module also includes
includes the free-space
tracks unallocated blocks
module when requested
manages metadata information
metadata information metadata
information metadata includes
file system manages
manages the directory
structure to provide
provide the fileorganization
maintains file structure
structure via file-control
blocks a flle-corttml
unix file systems
contents the logical
responsible for protection
duplication of code
code is minimized
basic file-system code
systems each file
file-system and file-organization
layering can introduce
introduce more operating
operating system overhead
result in decreased
including the decision
challenge in designing
designing new systems
systems many file
today most operating
cd-roms are written
standard format agreed
manufacturers in addition
addition to removable-media
removable-media file systems
diskbased file systems
file systems unix
berkeley fast file
fast file system
support disk file-system
disk file-system formats
formats of fat
windows nt file
floppy-disk file-system formats
formats although linux
supports over forty
forty different file
standard linux file
linux file system
versions being ext2
ext2 and ext3
server is mounted
network file-system research
file-system research continues
area of operating-system
implementation coogle created
system to meet
meet the company
company s specific
flexibility in file-system
implementing and executing
executing file systems
systems as user-level
code using fuse
user can add
variety of operating
system to manage
manage her files
systems implement open
calls for processes
processes to request
structures and operations
implement file-system operations
operations 11.2.1 overview
overview several on-disk
on-disk and in-memory
implement a file
system these structures
structures vary depending
general principles apply
apply on disk
operating system stored
number of blocks
number and location
location of free
structures are detailed
typically the first
volume in ufs
count and free-block
count and fcb
pointers in ufs
organize the files
files in ufs
includes file names
numbers in ntfs
master file table
table a per-file
unique identifier number
entry in ntfs
relational database structure
row per file
file the in-memory
management and performance
improvement via caching
caching the data
data are loaded
loaded at mount
updated during file-system
discarded at dismount
dismount several types
types of structures
included an in-memory
volume contains information
mounted an in-memory
in-memory directory-structure cache
directory-structure cache holds
holds the directory
recently accessed directories
volumes are mounted
file owner group
acl file data
file data blocks
blocks or pointers
pointers to file
data blocks figure
typical file-control block
information buffers hold
buffers hold file-system
hold file-system blocks
read from disk
disk or written
disk to create
application program calls
calls the logical
system the logical
structures to create
file-system implementation creates
creates all fcbs
fcbs at file-system
fcb is allocated
set of free
system then reads
directory into memory
disk a typical
fcb is shown
treat a directory
type field indicating
directory other operating
includii g windows
implement separate system
separate system calls
directories and treat
directories as entities
separate from files
larger structural issues
system can call
call the file-organization
module to map
map the directory
i into disk-block
opened the open
passes a file
system the open
call first searches
searches the system-wide
per-process open-file table
entry is created
existing system-wide open-file
table this algorithm
algorithm can save
save substantial overhead
structure is searched
cached in memory
speed directory operations
fcb is copied
memory this table
stores the fcb
entry is made
fields may include
file is open
open the open
user space kernel
space kernel memory
secondary storage secondary
storage secondary storage
secondary storage figure
in-memory file-system structures
file read file-system
read file-system table
table all file
pointer the file
fcb is located
located on disk
entry varies unix
varies unix systems
per-process table entry
entry s open
metadata is copied
disk-based directory structure
removed some systems
complicate this scheme
open-file table holds
holds the inodes
information for files
holds similar information
information for network
connections and devices
purposes the caching
aspects of file-system
overlooked most systems
actual data blocks
memory the bsd
bsd unix system
system is typical
caches wherever disk
saved its average
average cache hit
cache hit rate
implementing the bsd
fully in appendix
implementation are summarized
summarized in figure
partitions and mounting
mounting the layout
system a disk
sliced into multiple
volume can span
span multiple partitions
partitions on multiple
layout is discussed
considered a form
form of raid
unix swap space
format on disk
file system likewise
databases use raw
disk and format
format the data
data to suit
hold information needed
needed by disk
disk raid systems
bit maps indicating
indicating which blocks
blocks are mirrored
miniature database holding
database holding raid
holding raid configuration
raid configuration information
disks are members
raid set raw
set raw disk
section 12.5.1 boot
12.5.1 boot information
file-system code loaded
interpret the file-system
series of blocks
image into memory
find and load
load the kernel
kernel and start
start it executing
boot a specific
specific operating system
boot a boot
loader that understands
understands multiple file
systems and multiple
systems can occupy
occupy the boot
space once loaded
disk the disk
mounted at boot
system as part
successful mount operation
format is invalid
in-memory mount table
system the details
operating system microsoft
system microsoft windows-based
microsoft windows-based systems
windows-based systems mount
mount each volume
separate name space
colon to record
operating system places
places a pointer
specifies the driver
operating system finds
pointer and traverses
device to find
directory later versions
windows can mount
mount a file
existing directory structure
mounting is implemented
implemented by setting
setting a flag
directory the flag
point a field
field then points
indicating which device
device is mounted
mount table entry
device this scheme
seamlessly among file
types 11.2.3 virtual
11.2.3 virtual file
virtual file systems
systems the previous
previous section m.akes
clear that modern
concurrently support multiple
support multiple types
system allow multiple
users seamlessly move
move between file-system
navigate the file-system
details an obvious
obvious but suboptimal
method of implementing
implementing multiple types
techniques to simplify
modularize the implementation
dissimilar file-system types
including network file
network file systems
users can access
contained within multiple
network data structures
structures and procedures
isolate the basic
basic systemcall functionality
file-system implementation consists
schematically in figure
layer the vfs
vfs layer serves
serves two important
two important functions
separates file-system-generic operations
implementation by defining
defining a clean
clean vfs interface
interface several implementations
interface may coexist
allowing transparent access
file systems mounted
systems mounted locally
representing a file
network the vfs
vfs is based
network-wide unique file
inodes are unique
single file system
uniqueness is required
required for support
support of network
systems the kernel
maintains one vnode
vfs distinguishes local
distinguishes local files
files from remote
types the vfs
vfs activates file-system-specific
activates file-system-specific operations
operations to handle
handle local requests
types and calls
calls the nfs
nfs protocol procedures
procedures for remote
remote requests file
requests file handles
handles are constructed
passed as arguments
procedures the layer
file system file-system
system file-system type
examine the vfs
architecture in linux
four main object
main object types
object types defined
represents an individual
file the file
represents an open
file the superblock
represents an entire
system the dentry
individual directory entry
four object types
defines a set
set of operations
implemented every object
table the function
function table lists
lists the addresses
functions that implement
implement the defined
file object include
-open a file
file ssize_t read
file ssize_t write
file int mmap
-memory-map a file
file an implementation
specific file type
type is required
implement each function
definition ofthe file
ofthe file object
struct f ile_operat
vfs software layer
layer can perform
perform an operation
objects by calling
object s function
kind of object
represents a disk
file s read
layer will call
call that function
function without caring
read the selection
selection of directory-allocation
directory-allocation and directory-management
algorithms significantly affects
affects the efficiency
discuss the trade-offs
involved in choosing
algorithms 11.3.1 linear
11.3.1 linear list
list the simplest
implementing a directory
list of file
names with pointers
blocks this method
method is simple
simple to program
program but time-consuming
time-consuming to execute
execute to create
directory to delete
release the space
reuse the directory
mark the entry
entry as unused
free directory entries
copy the last
decrease the length
directory a linked
required to delete
file the real
list of directory
finding a file
requires a linear
linear search directory
search directory information
users will notice
notice if access
slow in fact
implement a software
cache to store
recently used directory
information a cache
cache hit avoids
reread the information
information from disk
disk a sorted
search and decreases
decreases the average
sorted may complicate
move substantial amounts
amounts of directory
information to maintain
maintain a sorted
sophisticated tree data
tree data structure
sorted directory listing
separate sort step
step 11.3.2 hash
11.3.2 hash table
table another data
linear list stores
stores the directory
hash data structure
hash table takes
takes a value
decrease the directory
search time insertion
insertion and deletion
made for collisions-situations
file names hash
generally fixed size
make a linear-probing
linear-probing hash table
table that holds
entries the hash
hash function converts
converts file names
names into integers
create a 65th
enlarge the directory
directory hash table-say
map file narnes
reorganize the existing
existing directory entries
entries to reflect
chained-overflow hash table
collisions by adding
linked list lookups
list of colliding
colliding table entries
directory the direct-access
nature of disks
implementation of files
disk the main
space is utilized
effectively and files
quickly three major
methods of allocating
allocating disk space
indexed each method
method has advantages
disadvantages some systems
general s rdos
line of computers
type 11.4.1 contiguous
11.4.1 contiguous allocation
contiguous allocation requires
occupy a set
set of contiguous
blocks on disk
disk disk addresses
disk addresses define
define a linear
job is accessil1.g
accessil1.g the disk
requires no head
movement when head
movement is needed
number of disk
disk seeks required
required for accessing
accessing contiguously allocated
contiguously allocated files
files is minimal
needed the ibm
ibm vm operatil1.g
vm operatil1.g system
system uses contiguous
good performance contiguous
performance contiguous allocation
long and starts
starts at location
accessing a file
contiguously is easy
easy for sequential
file system remembers
remembers the disk
last block referenced
access to block
file that starts
starts at block
immediately access block
supported by contiguous
directory file start
file start length
start length count
disk space contiguous
space contiguous allocation
difficulty is finding
file the system
chosen to manage
manage free space
free space determines
task is accomplished
systems are discussed
general problem discussed
involves to satisfy
efficient than worst
files are allocated
allocated and deleted
free disk space
broken into pieces
exists whenever free
broken into chunks
largest contiguous chunk
chunk is insufficient
request ; storage
storage is fragncented
number of holes
store the data
amount of disk
average file size
problem one strategy
strategy for preventing
loss of significant
amounts of disk
space to external
copy an entire
disk or tape
tape the original
creating one large
large contiguous free
contiguous free space
copy the files
disk by allocating
allocating contiguous space
hole this scheme
effectively all free
solving the fragmentation
severe for large
large hard disks
function be done
file system unmounted
compaction is avoided
costs on production
machines most modern
defragmentation can perform
normal system operations
substantial another problem
problem with contiguous
allocation is determining
space is needed
found and allocated
program or person
copying an existing
difficult to estimate
best-fit allocation strategy
make the file
larger in place
place two possibilities
possibilities then exist
message the user
allocate more space
space and run
costly to prevent
overestimate the amount
resulting in considerable
considerable wasted space
find a larger
copy the contents
release the previous
space this series
series of actions
long as space
inefficient a file
months or years
allocated enough space
amount of internal
fragmentation to minimize
minimize these drawbacks
modified contiguous-allocation scheme
chunk of space
chunk of contiguous
added the location
file s blocks
file can set
set the extent
results in inefficiencies
owner is incorrect
incorrect internal fragm.entation
problem as extents
extents of varying
sizes are allocated
deallocated the commercial
veritas file system
system uses extents
extents to optimize
standard unix ufs
ufs 11.4.2 linked
11.4.2 linked allocation
linked allocation solves
solves all problems
problems of contiguous
allocation with linked
list of disk
disk the directory
blocks might start
start at block
continue at block
block these pointers
user sees blocks
bytes to create
ile the directory
directory with linked
first disk block
file this pointer
pointer is initialized
initialized to nil
end-of-list pointer value
signify an empty
file the size
free-space management system
system to filed
filed a free
block is written
simply read blocks
pointers from block
block to block
fragmentation with linked
request the size
created a file
file can continue
continue to grow
long as free
compact disk space
disk space linked
space linked allocation
files to filed
file and follow
follow the pointers
block each access
requires a disk
require a disk
inefficient to support
support a direct-access
capability for linked-allocation
files another disadvantage
information each file
slightly more space
blocks into multiples
blocks for instance
system may define
define a cluster
blocks and operate
cluster units pointers
file s disk
space this method
logical-to-physical block mapping
mapping to remain
improves disk throughput
fewer disk-head seeks
seeks are required
decreases the space
needed for block
allocation and free-list
management the cost
increase in internal
space is wasted
partially full clusters
improve the disk-access
algorithms as welt
problem of linked
allocation is reliability
files are linked
pointer were lost
lost or damaged
damaged a bug
disk hardware failure
failure might result
result in picking
pointer this error
result in linking
file one partial
doubly linked lists
store the file
file an important
variation on linked
simple but efficient
method of disk-space
os operating systems
systems a section
volume is set
table the table
indexed by block
number the fat
list the directory
file the table
table entry indexed
file this chain
reaches the last
special end-of-file value
entry an unused
matter of finding
finding the first
first 0-valued table
0-valued table entry
entry and replacing
replacing the previous
previous end-of-file value
value an illustrative
fat structure shown
consisting of disk
entry name start
fat allocation scheme
scheme can result
disk head seeks
fat is cached
cached the disk
head must move
volume to read
read the fat
fat and find
block in question
blocks a benefit
head can find
block by reading
reading the information
fat 11.4.3 indexed
11.4.3 indexed allocation
indexed allocation linked
allocation linked allocation
solves the external-fragmentation
external-fragmentation and size-declaration
support efficient direct
efficient direct access
blocks are scattered
retrieved in order
solves this problem
problem by bringil1.g
array of disk-block
index block points
find and read
1lz index-block entry
entry this scheme
scheme is similar
paging scheme described
scheme described il1
described il1 section
block are set
set to nil
block is first
block is obtained
address is put
index-block entry indexed
entry indexed allocation
indexed allocation supports
allocation supports direct
supports direct access
suffering from external
disk can satisfy
space indexed allocation
allocation does suffer
suffer from wasted
overhead of linked
blocks with linked
lose the space
pointer per directory
directory file jeep
block with indexed
entire index block
non-nil this point
raises the question
large the index
hold enough pointers
scheme an index
small header giving
index a variant
variant of linked
first-level index block
block to point
set of second-level
second-level index blocks
blocks to access
access a block
index to find
find a second-level
second-level index block
block to find
desired data block
block this approach
desired maximum file
maximum file size
size with 4,096-byte
store 1,024 four-byte
1,024 four-byte pointers
block two levels
levels of indexes
1,048,576 data blocks
4gb combined scheme
scheme another alternative
file s inode
inode the first
point to direct
addresses of blocks
data for small
separate index block
point to indirect
blocks the first
single indirect block
double indirect block
blocks the last
triple indirect block
exceeds the amount
four-byte file pointers
systems a 32-bit
32-bit file pointer
file pointer reaches
64-bit file pointers
file pointers pointers
size allow files
files and file
terabytes in size
size a unix
inode is shown
indexed-allocation schemes suffer
volume 11.4.4 performance
performance the allocation
efficiency and data-block
data-block access times
criteria in selecting
selecting the proper
method or methods
system to implement
inode before selecting
selecting an allocation
file in memory
immediately the disk
read it directly
directly for linked
block in memory
memory and read
directly this method
block might require
require i disk
reads this problem
application requiring direct
requiring direct access
systems support direct-access
support direct-access files
allocation and sequential-access
created for sequential
created for direct
support both direct
access and sequential
algorithms to support
support both allocation
allocation methods files
file are copied
file renamed indexed
renamed indexed allocation
keeping the index
memory requires considerable
requires considerable space
first the index
two index-block reads
extremely large file
accessing a block
file would require
needed data block
performance of indexed
indexed allocation depends
desired some systems
systems combine contiguous
combine contiguous allocation
allocation with indexed
allocation for small
file grows large
files are small
allocation is efficient
efficient for small
good for instance
system from sun
microsystems was changed
file-system allocation algorithm
algorithm the performance
maximum disk throughput
cpu and produced
produced a disk
space in clusters
transfer on sun
allocation reduced external
reduced external fragmentation
seek and latency
times in addition
routines were optimized
optimized to read
clusters the inode
structure was left
read-ahead and free-behind
percent less cpu
throughput substantially improved
disparity between cpu
speed and disk
unreasonable to add
thousands of extra
system to save
disparity is increasing
point where hundreds
thousands of instructions
optimize head movements
movements since disk
space is limited
reuse the space
space from deleted
write-once optical disks
track of free
free-space list records
records all free
free disk blocks-those
blocks-those not allocated
directory to create
search the free-space
space and allocate
allocate that space
file this space
space is added
list the free-space
11.5.1 bit vector
list is implemented
block is represented
block is free
disk where blocks
blocks are allocated
allocated the free-space
free-space bit map
efficiency in finding
first free block
consecutive free blocks
computers supply bit-manipulation
supply bit-manipulation instructions
intel family starting
motorola family starting
instructions that return
return the offset
processors have powered
pcs and macintosh
technique for finding
bit-vector to allocate
check each word
bits and represents
first non-0 word
word is scanned
block the calculation
bits per word
number of 0-value
offset of first
hardware features driving
features driving software
driving software functionality
vectors are inefficient
occasionally for recovery
necessarily for larger
disk with 512-byte
track its free
clustering the blocks
blocks in groups
reduces this number
4-kb blocks requires
store its bit
size constantly increases
problem with bit
vectors will continue
continue to escalate
1-pb file system
manage its free
space 11.5.2 linked
11.5.2 linked list
list another approach
approach to free-space
free disk blocks
keeping a pointer
disk and caching
memory this first
free disk block
recall our earlier
blocks were allocated
pointer to block
free block block
point to block
traverse the list
read each block
traversing the free
allocate that block
fat method incorporates
method incorporates free-block
incorporates free-block accounting
allocation data structure
structure no separate
method is needed
needed 11.5.3 grouping
grouping a modification
free-list approach stores
stores the addresses
block the first
free the last
linked free-space list
list on disk
unlike the situation
standard linked-list approach
counting another approach
approach takes advantage
allocated or freed
keeping a list
free disk addresses
free contiguous blocks
blocks that follow
follow the first
block each entry
list then consists
requires more space
simple disk address
list is shorter
method of tracking
tracking free space
space is similar
method of allocating
blocks these entries
list for efficient
deletion 11.5.5 space
11.5.5 space maps
space maps sun
system was designed
designed to encompass
encompass huge numbers
numbers of files
create file-system hierarchies
resulting data structures
large and inefficient
large performance impact
performance impact conside1
1gb of data
thousands of blocks
blocks of bit
combination of techniques
free-space managem.ent algorithm
algorithm to control
control the size
size of data
structures and minimize
needed to manage
manage those structures
creates to divide
divide the space
device into chucks
chucks of manageable
hundreds of metaslabs
metaslabs each metaslab
space map zfs
algorithm to store
information about free
write count structures
structures to disk
log-structured file system
file system techniques
techniques to record
countil g format
format when zfs
decides to allocate
allocate or free
map into memory
indexed by offset
replays the log
structure the in-memory
in-memory space map
allocated and free
zfs also condenses
condenses the map
combining contiguous free
contiguous free blocks
sil gle entry
list is updated
updated on disk
disk as part
operations of zfs
collection and sortmg
satisfies these requests
log in essence
discussed various block-allocation
block-allocation and directorymanagement
effect on performance
performance and efficient
disk use disks
tend to represent
represent a major
bottleneck in system
slowest main computer
main computer component
discuss a variety
variety of techniques
performance of secondary
storage 11.6.1 efficiency
efficiency the efficient
disk space depends
allocation and directory
inodes are preallocated
lost to inodes
preallocating the inodes
inodes and spreading
improve the file
performance this improved
improved performance results
allocation and free-space
file s data
block to reduce
reconsider the clustermg
clustermg scheme discussed
aids in file-seek
file-seek and file-transfer
cost of internal
fragmentation to reduce
reduce this fragmentation
bsd unix varies
varies the cluster
grows large clusters
file this system
described in appendix
file s directory
entry also require
last write date
date is recorded
last access date
file was last
read the result
result of keeping
keeping this information
means the block
operations on disks
opened for reading
frequently accessed files
weigh its benefit
cost when designing
designing a file
effect on efficiency
efficiency is affected
data most systems
system these pointer
pointer sizes limit
limit the length
systems implement 64-bit
implement 64-bit pointers
pointers to increase
increase this limit
space to store
make the allocation
allocation and free-space-management
difficulties in choosing
choosing a pointer
fixed allocation size
effects of changing
10-mb hard drive
ms-dos file system
disk capacities increased
32mb as hard
disks with capacities
100mb became common
disk data structures
algorithms in ms-dos
larger file systems
entry was expanded
initial file-system decisions
decisions were made
made for efficiency
advent of ms-dos
millions of computer
users were inconvenienced
larger file system
file system sun
capable of storing
bytes using atomic-level
evolution of sun
sun s solaris
allocated at system
startup these structures
included the process
table became full
opened the system
system would fail
fail to provide
services to users
users table sizes
recompiling the kernel
kernel and rebooting
rebooting the system
release of solaris
eliminating these artificial
limits on system
manipulate these tables
allocate and deallocate
deallocate table entries
functionality 11.6.2 performance
basic file-system algorithms
disk controllers include
controllers include local
include local memory
memory to form
form an on-board
store entire tracks
seek is performed
track is read
disk cache starting
tile system figure
unified buffer cache
controller then transfers
transfers any sector
system once blocks
controller into main
system may cache
cache the blocks
section of main
shortly other systems
systems cache file
cache file data
cache uses virtual
techniques to cache
data as pages
file-system-oriented blocks cachii
cachii lg file
data using virtual
efficient than caching
caching through physical
physical disk blocks
interface with virtual
system several systems-including
caching to cache
cache both process
pages and file
illustrate the benefits
alternatives for opening
opening and accessing
file one approach
system calls read
cache the memory-mapping
two caches-the page
caches-the page cache
cache a memory
memory mapping proceeds
proceeds by reading
reading in disk
system and storing
cache this situation
requires caching file-system
caching file-system data
wastes significant cpu
i cycles due
extra data movement
movement within system
caches can result
result in corrupt
files in contrast
cache is provided
buffer cache file
cache file system
file system figure
buffer cache caching
manage file-system data
data the unified
cache is shown
caching disk blocks
blocks or pages
reasonable general-purpose algorithm
algorithm for block
block or page
solaris page-caching algorithms
page-caching algorithms reveals
reveals the difficulty
difficulty in choosil1.g
choosil1.g an algorithm
cache to share
share unused memory
unused memory versions
memory versions earlier
earlier than solaris
solaris 2.5.1 made
made no distmction
distmction between allocatmg
process and allocating
memory for caching
page cache-when free
cache-when free memory
free memory ran
memory ran low
ran low solaris
optionally implemented priority
implemented priority paging
scanner gives priority
priority to process
page cache solaris
applied a fixed
limit to process
file-system page cache
changed the algorithms
algorithms to maximize
thrashing another issue
file system occur
synchronously or asynchronously
disk subsystem receives
routine must wait
data to reach
reach the disk
caller asynchronous writes
writes are done
done the majority
synchronous operating systems
systems frequently include
include a flag
open system call
request that writes
writes be performed
feature for atomic
assure that data
data reach stable
reach stable storage
order some systems
optimize their page
file a file
file being read
read or written
replaced in lru
optimized by techniques
free-behind and read-ahead
removes a page
page is requested
requested the previous
waste buffer space
read and cached
cached these pages
page is processed
retrieving these data
transfer and caching
caching them saves
saves a considerable
controller would elincinate
latency and overhead
involved in making
making many small
cache to main
performing a read-ahead
read-ahead remains beneficial
beneficial the page
interactions when data
pages are buffered
disk driver sorts
sorts its output
driver to minimize
minimize disk-head seeks
data at times
optimized for disk
rotation unless synchronous
disk simply writes
system asynchronously writes
writes the data
data to disk
disk when convenient
convenient the user
user process sees
writes when data
data are read
block i system
input for large
counter to intuition
loss of data
inconsistency we deal
system can recover
failure a system
inconsistencies among on-disk
on-disk file-system data
free fcb pointers
pointers many file
structures in place
place a typical
involve many structural
disk directory structures
structures are modified
fcbs are allocated
blocks are decreased
structures can result
free fcb count
compounding this problem
caching that operating
optimize i performance
directly to disk
addition to crashes
bugs in file-system
applications can corrupt
corrupt a file
file system file
systems have varying
methods to deal
deal with corruption
algorithms we deal
11.7.1 consistency checking
detect the problems
system can confirm
confirm or deny
deny the consistency
minutes or hours
system can record
record its state
system can clear
clear that bit
status bit remains
bit remains set
checker is run
run the systems
unix or chkdsk
chkdsk in windows-compares
windows-compares the data
fix any inconsistencies
inconsistencies it finds
finds the allocation
free-space-management algorithms dictate
dictate what types
problems the checker
checker can find
recreated in contrast
contrast the loss
indexed allocation system
unix caches directory
caches directory entries
entries for reads
write that results
results in space
blocks are written
write is interrupted
crash 11.7.2 log-structured
11.7.2 log-structured file
log-structured file systems
systems computer scientists
scientists often fin.d
fin.d that algorithms
algorithms and technologies
database log-based recovery
log-based recovery algorithms
recovery algorithms described
6.9.2 these logging
consistency -.ilc .ll
.ll the resulting
file systems note
consistency-checking approach discussed
essentially allow structures
structures to break
break and repair
irreparable the consistency
recover the structures
resulting in loss
loss of files
entire directories consistency
directories consistency checking
checking can require
require human intervention
intervention to resolve
system can remain
proceed consistency checking
checking also takes
system and clock
terabytes of data
hours of clock
required the solution
apply log-based recovery
log-based recovery techniques
techniques to file-system
file-system metadata updates
updates both ntfs
included in recent
versions of ufs
ufs on solaris
solaris in fact
written each set
operations for performing
performing a specific
call can return
entries are replayed
actual filesystem structures
actions have completed
entire committed transaction
overwriting older values
buffer to write
write over data
scenario is avoided
avoided the log
separate disk spindle
decreasing head contention
contention and seek
transactions any transactions
completed the transactions
work is complete
file-system structures remain
structures remain consistent
transaction was aborted
preserving the consistency
system this recovery
ating any problems
problems with consistency
checking a side
logging on disk
disk metadata updates
proceed much faster
on-disk data structures
structures the reason
improvement is found
advantage of sequential
i over random
i the costly
costly synchronous random
synchronous random meta
random meta data
meta data writes
writes are turned
costly synchronous sequential
synchronous sequential writes
system s loggil
loggil g area
turn are replayed
asynchronously via random
gain in performance
performance of metadata-oriented
11.7.3 other solutions
solutions another alternative
alternative to consistency
checking is employed
employed by network
appliance s wafl
system and sun
system these systems
systems never overwrite
writes all data
data and metadata
transaction is complete
structures that pointed
blocks are updated
updated to point
blocks and make
pointers and blocks
update took place
place this solution
solution should require
require no consistency
update is done
done atomically wafl
approach to disk
case with wafl
metadata and data
blocks this solution
combined with raid
assures that data
details on zfs
zfs are found
found in section
backup and restore
restore magnetic disks
disks sometimes fail
hard disk recovery
data from backup
backup to minimize
minimize the copying
entry for instance
file was done
file s last
typical backup schedule
medium all files
changed since day
day n copy
back to day
set of backup
restore an entire
disk by starting
backup and continuing
larger the value
greater the number
number of media
restore an added
restore any file
file accidentally deleted
cycle by retrieving
retrieving the deleted
day the length
amount of backup
backup medium needed
number of days
done to decrease
number of tapes
perform a full
recent incremental backup
incremental backups needed
needed the trade-off
modified each day
successive incremental backup
incremental backup involves
involves more files
media a user
user ncay notice
file is missing
missing or corrupted
damage was done
idea to store
store these permanent
backups to protect
protect against hazard
fire that destroys
destroys the computer
backup cycle reuses
cycle reuses media
times-if the media
restore any data
backups network file
systems are commonplace
structure and interface
client system nfs
well-implemented client-server network
client-server network file
explore the implementation
details of network
file systems nfs
system for accessing
accessing remote files
files across lans
nfs is part
part of onc
support the implementation
version of unix
unix svr4 running
running on sun
tcp or udp
implementation are intertwined
description of nfs
nfs whenever detail
detail is needed
description is general
versions of nfs
latest being version
deployed 11.8.1 overview
11.8.1 overview nfs
overview nfs views
views a set
set of interconnected
set of independent
machines with independent
independent file systems
systems the goal
degree of sharing
transparent manner sharing
sharing is based
relationship a machine
sharing is allowed
pair of machines
machines to ensure
ensure machine independence
file system affects
out a mount
operation the semantics
operation involve mounting
mounting a remote
operation is completed
replacing the subtree
directory the local
newly mounted directory
mounted directory specification
users on machine
totally transparent manner
manner to illustrate
interest the figure
shows three independent
systems of machines
depicts the view
file system notice
mount is complete
usr usr usr
usr usr figure
dir1 the original
longer visible subject
subject to access-rights
remotely on top
local directory diskless
directory diskless workstations
roots from servers
servers cascading mounts
local a machine
machine is affected
give the client
exhibit a transitivity
property in figure
illustrate cascading mounts
mounts the figure
shows the result
result of mounting
files within dir2
mounting in nfs
shared file system
user can log
environment this property
goals of nfs
architectures the nfs
specification is independent
encourages other implementations
implementations this independence
independence is achieved
rpc primitives built
external data representation
two implementation-independent interfaces
consists of heterogeneous
machines and file
interfaced to nfs
locally and remotely
remotely the nfs
nfs specification distinguishes
actual remote-file-access services
two separate protocols
protocol for remote
remote file accesses
sets of rpcs
rpcs these rpcs
implement transparent remote
transparent remote file
11.8.2 the mount
protocol the establishes
establishes the initial
initial logical connection
client in sun
sun s implementation
performing the protocol
functions a mount
mount operation includes
server machine storing
request is mapped
mount server running
specific server machine
machine the server
specifies local file
exports for mounting
names of machines
permitted to mount
include access rights
simplify the maintenance
maintenance of export
lists and mount
distributed naming scheme
hold this information
information and make
exported file system
machine a component
receives a mount
request that conforms
client a file
handle that serves
accesses to files
distinguish an individual
file it stores
stores in unix
file handle consists
identify the exact
exact mounted directory
system the server
server also maintains
directories this list
administrative purposes-for instance
notifying all clients
addition and deletion
deletion of entries
state be affected
static mounting preconfiguration
established at boot
etc in solaris
actual mount procedure
mount protocol includes
unmount and return
return export list
11.8.3 the nfs
protocol the nfs
set of rpcs
rpcs for remote
remote file operations
operations the procedures
reading a set
set of directory
directory entries manipulating
entries manipulating links
links and directories
directories accessing file
accessing file attributes
file attributes reading
files these procedures
remotely mounted directory
established the omission
omission of open
operations is intentional
intentional a prominent
feature of nfs
parallels to unix
unix s open-files
table or file
file structures exist
provide a full
set of arguments
including a unique
unique file identifier
absolute offset inside
inside the file
operations the resulting
design is robust
recover a server
crash file operations
purpose every nfs
allowing the server
server to determine
request is duplicated
maintaining the list
list of clients
violate the statelessness
include inconsistent data
indirection and status
server s disk
disk before results
results are returned
client can cache
cache write blocks
reached the server
server s disks
disks the server
server must write
write all nfs
nfs data synchronously
crash and recovery
server is managing
intact the consequent
consequent performance penalty
advantages of caching
caching are lost
increased using storage
disk controller ackiwwledges
ackiwwledges the disk
write is stored
cache in essence
fast synchronous write
write these blocks
blocks remain intact
storage to disk
periodically a single
single nfs write
nfs write procedure
write procedure call
call is guaranteed
file the nfs
provide concurrency-control mechanisms
mechanisms a write
client server figure
architecture be broken
write or read
data and udp
packets are limited
two users writing
intermixed the claim
nfs should provide
users are advised
advised to coordinate
files using mechanisms
scope of nfs
nfs is integrated
open remote file
file is handled
initiates the operation
regular system call
call the operating-system
operating-system layer maps
maps this call
vnode the vfs
vfs layer identifies
procedure an rpc
nfs service layer
server this call
call is reinjected
local and invokes
operation this path
path is retraced
retraced to return
return the result
result an advantage
server are identical
server is performed
performed by kernel
threads 11.8.4 path-name
11.8.4 path-name translation
translation in nfs
involves the parsing
txt into separate
separate directory entries
dir1 path-name translation
translation is done
done by breaking
breaking the path
path into component
names and perform.ing
perform.ing a separate
separate nfs lookup
nfs lookup call
pair of component
point is crossed
expensive path-name-traversal scheme
scheme is needed
client s logical
logical name space
space is unique
mounts the client
client has performed
itluch more efficient
efficient to hand
hand a server
server a path
receive a target
point is encountered
client of whicb
whicb the stateless
server is unaware
lookup is fast
client side holds
holds the vnodes
vnodes for remote
remote directory names
names this cache
speeds up references
cache is discarded
discarded when attributes
match the attributes
cached vnode recall
recall that mounting
system on top
mounted remote file
implementations of nfs
client must establish
establish a direct
direct client-server com1ection
mounting the desired
lookup is performed
server has mounted
mounted a file
sees the underlying
directory 11.8.5 remote
11.8.5 remote operations
exception of opening
opening and closing
regular unix system
nfs protocol rpcs
remote file operation
buffering and caching
techniques are employed
sake of performance
performance no direct
direct correspondence exists
blocks and file
attributes are fetched
cached locally future
locally future remote
future remote operations
subject to consistency
fetch or revalidate
revalidate the cached
attributes the cached
cached file blocks
date the attribute
cache is updated
server cached attributes
seconds both read-ahead
read-ahead and delayed-write
free delayed-write blocks
delayed-write is retained
tuning the system
system for performance
makes it difficult
difficult to characterize
characterize the consistency
semantics of nfs
nfs new files
open for reading
reading new opens
emulation of unix
session sen antics
antics of andrew
utility and good
widely used multi-vendor-distributed
system in operation
impact on system
lot of attention
attention from system
designers some file
systems are general
provide reasonable performance
performance and functionality
optimized for specific
attempt to provide
areas than general-purpose
systems the wafl
system from network
sort of optimization
elegant file system
file system optimized
optimized for random
random writes wafl
exclusively on network
network file servers
file servers produced
produced by network
nfs and cifs
protocols to talk
demand for random
writes the nfs
cifs protocols cache
protocols cache data
data from read
concern to file-server
file-server creators wafl
servers that include
include an nvram
cache for writes
writes the wafl
designers took advantage
advantage of running
architecture to optimize
optimize the file
system for random
cache in front
principles of wafl
appliance its creators
creators also designed
functionality that creates
multiple read-only copies
inodes to describe
files each inode
pointers to blocks
inode each file
lives in files
free-inode root inode
free blotk map
map i figure
limited in location
system is expanded
expanded by addition
addition of disks
tree of blocks
creates a copy
inode any file
file or metadata
overwriting their existing
root inode points
points to metadata
instant the snapshot
snapshot was made-and
extra disk space
disk space occupied
standard file systems
bit per block
block are deleted
reused used blocks
write can occur
free block nearest
nearest the current
current head location
optimizations in wafl
snapshots can exist
month a user
snapshots can access
times the snapshots
wafl s snapshot
require that copy-on-write
block is modified
modified other file
file systems provide
systems provide snapshots
efficiency wafl snapshots
snapshots are depicted
versions of wafl
techniques as shapshots
read-only snapshot captures
captures the state
snapshot any writes
clone are stored
clone s pointers
pointers are updated
blocks the original
snapshot is unmodified
giving a view
clone was updated
promoted to replace
replace the original
original file system
testing and upgrades
version is left
test is done
fails another feature
file system implementation
duplication and synchronization
system is duplicated
easy to update
update the remote
snapshot these blocks
remote system adds
adds these blocks
system and updates
updates its pointers
repeating this process
maintains the remote
snapshots in wafl
system such replication
system be destroyed
note that sun
file system supports
supports similarly efficient
similarly efficient snapshots
replication the file
disk physical disks
segmented into partitions
partitions to control
spindle these file
file system architecture
architecture to make
layered or modular
structure the lower
lower levels deal
properties of storage
storage devices upper
devices upper levels
upper levels deal
deal with symbolic
symbolic file names
names and logical
properties of files
files intermediate levels
intermediate levels map
logical file concepts
concepts into physical
physical device properties
properties any file-system
algorithms a vfs
layers to deal
file-system type uniformly
system s directory
structure and acted
indexed allocation contiguous
allocation contiguous allocation
allocation can suffer
external fragmentation direct
fragmentation direct access
inefficient with linked
linked allocation indexed
allocation indexed allocation
allocation may require
require substantial overhead
block these algorithms
ways contiguous space
enlarged through extents
extents to increase
decrease external fragmentation
external fragmentation indexed
fragmentation indexed allocation
done in clusters
clusters of multiple
blocks to increase
number of index
index entries needed
entries needed indexing
indexing in large
clusters is similar
similar to contiguous
allocation with extents
extents free-space allocation
free-space allocation methods
methods also influence
influence the efficiency
efficiency of disk-space
reliability of secondary
storage the methods
methods used include
include bit vectors
vectors and linked
linked lists optimizations
lists optimizations include
optimizations include grouping
places the linked
contiguous area directory-management
area directory-management routines
reliability a hash
commonly used method
fast and efficient
crash can result
result in inconsistency
disk s contents
contents a consistency
damage operating-system backup
operating-system backup tools
tools allow disk
user to recover
recover from data
disk loss due
due to hardware
operating system bug
user error network
error network file
directories from remote
file systems system
systems system calls
client are translated
translated into network
protocols and retranslated
retranslated into file-system
networking and multiple-client
multiple-client access create
access create challenges
areas of data
consistency and performance
role that file
file systems play
play in system
reliability are crucial
structures and cachirtg
cachirtg help improve
structures and raid
raid improve reliability
reliability the wafl
optimization of performance
performance to match
specific i load
modifed contiguous-allocation scheme
scheme with support
support for extents
extents a file
collection of extents
set of blocks
blocks a key
degree of variability
size is predetermined
predetermined b extents
dynamically c extents
sizes are predetermined
systems allow disk
levels of granularity
granularity for instance
system could allocate
single 4-kb block
flexibility to improve
performance what modifications
free-space management scheme
scheme in order
order to support
support this feature
fat to chain
file currently consisting
case of indexed
disk i operations
operations are required
required for contiguous
room to grow
end also assume
added is stored
block is added
block is removed
inodes to represent
represent files disk
files disk blocks
disk block requires
bytes this file
direct disk blocks
triple indirect disk
indirect disk blocks
cache that caches
translations from file
handles what issues
account in implementing
m.edium all files
subsequent backups copy
first full backup
restore operations made
operations made easier
map for file
physical block sizes
answer these questions
logical-to-physical address mapping
address mapping accomplished
last block accessed
accessed was block
access logical block
allocate its internal
system for doing
explain why logging
logging metadata updates
metadata updates ensures
updates ensures recovery
eliminated by recompaction
information typical disk
typical disk devices
relocation or base
relocate files give
give three reasons
reasons why recompacting
recompacting and relocation
relocation of files
system where free
list a suppose
list is lost
reconstruct the free-space
free-space list explain
file system similar
unix with indexed
small local file
cached c suggest
result of memory
user must preallocate
preallocate enough space
file structure consisting
initial contiguous area
area is filled
system automatically defines
defines an overflow
area is allocated
compare this implementation
contiguous and linked
discuss how performance
optimizations for file
systems might result
result in difficulties
difficulties in maintaining
maintaining the consistency
event of com.puter
crashes the ms-dos
ms-dos fat system
system is explained
explained in norton
norton and wilton
found in iacobucci
ibm allocation methods
methods are described
described in deitel
unl  system
system are covered
covered in full
full in mckusick
mcvoy and kleiman
made in solaris
solaris the coogle
coogle file system
described in ghemawat
workloads in distributed
systems are examined
examined in baker
discusses the role
role of distributed
state in networked
networked file systems
file systems log-structured
systems log-structured designs
designs for networked
systems are proposed
proposed in hartman
described in vahalia
explained in solomon
ext2 file system
linux is described
described in bovet
system in hitz
found at http
logically as consisting
parts in chapter
examined the user
user and programmer
described the internal
internal data structures
implement this interface
discuss the lowest
tertiary storage structures
describe the physical
structure of magenetic
describe disk-scheduling algorithms
schedule the order
order of disk
discuss disk formatting
formatting and management
management of boot
examine secondary storage
secondary storage structure
covering disk reliability
reliability and stablestorage
implementation we conclude
description of tertiary
tertiary storage devices
problems that arise
system uses tertiary
storage to describe
structure of secondary
devices to explain
explain the performance
characteristics of mass-storage
devices to discuss
discuss operating-system services
operating-system services provided
provided for mass
raid and hsm
devices 12.1.1 magnetic
12.1.1 magnetic disks
magnetic disks provide
storage for modern
flat circular shape
common platter diameters
platter diameters range
arm assembly rotation
assembly rotation figure
moving-head disk mechanism
platter are covered
material we store
platters a read
read -write head
-write head flies
platter the heads
heads are attached
unit the surface
divided into circular
set of tracks
arm position makes
thousands of concentric
hundreds of sectors
sectors the storage
capacity of common
common disk drives
drives is measured
measured iil gigabytes
drive motor spins
speed most drives
move the disk
sector to rotate
disks can transfer
transfer several megabytes
megabytes of data
times and rotational
disk head flies
extremely thin cushion
cushion of air
measured in microns
head will make
platters are coated
thin protective laye1
damage the magnetic
surface this accident
replaced a disk
allowing different disks
mounted as needed
needed removable magnetic
removable magnetic disks
disks generally consist
case to prevent
drive are inexpensive
inexpensive removable magnetic
soft plastic case
platter the head
drive generally sits
disk transfer rates
aspects of computingf
computingf published performance
published performance numbers
numbers for disks
real-world performance numbers
performance numbers stated
numbers stated transfer
stated transfer rates
blocks are delivered
operating system surface
drive is designed
designed to rotate
drive to reduce
reduce the wear
surface the storage
normal hard disks
measured in gigabytes
gigabytes a disk
drive is attached
set of wires
kinds of buses
buses the data
bus are carried
out by special
special electronic processors
drive to perform
perform a disk
disk i operation
places a command
typically using memory-mapped
memory-mapped i portsf
portsf as described
9.7.3 the host
controller then sends
sends the command
command via messages
disk controller operates
operates the disk-drive
hardware to carry
out the command
command disk controllers
built-in cache data
cache data transfer
fast electronic speeds
controller 12.1.2 magnetic
12.1.2 magnetic tapes
early secondary-storage medium
quantities of dataf
dataf its access
memory and magnetic
disk in addition
access to magnetic
thousand times slower
slower than random
secondary storage tapes
infrequently used information
medium for transferring
past a read-write
read-write head moving
drives can write
data at speeds
comparable to disk
disk drives tape
drives tape capacities
tape capacities vary
kind of tape
double the effective
effective storage tapes
categorized by width
lt0-2 and sdlt
sdlt tape storage
fire wire refers
designed for connecting
connecting peripheral devices
digital video cameras
computer system fire
system fire wire
wire was first
developed by apple
originalfirewire standard provided
standard provided bandwidth
standardfirewire 2-has emerged
ieee 1394b standard
1394b standard firewire
double the data
original firewire-800 megabits
modern disk drives
drives are addressed
addressed as large
large one-dimensional arrays
unit of transfer
transfer the size
logical block size
bytes this option
option is described
12.5.1 the one-dimensional
blocks is mapped
disk sequentially sector
cylinder the mapping
proceeds in order
cylinders from outermost
outermost to innermost
theory-convert a logical
logical block number
old-style disk address
address that consists
track in practice
difficult to perform
perform this translation
two reasons first
substituting spare sectors
number of sectors
sectors per track
constant on smne
reason on media
density of bits
bits per track
track is uniform
uniform the farther
farther a track
greater its length
move from outer
track decreases tracks
zone typically hold
percent more sectors
zone the drive
increases its rotation
rate of data
head this method
cd-rom and dvd-rom
disk rotation speed
speed can stay
tracks to outer
data rate constant
constant this method
increasing as disk
disk technology improves
number of cylinders
cylinders per disk
increasing ; large
disks have tens
tens of thousands
thousands of cylinders
computers access disk
access disk storage
common on small
12.3.1 host-attached storage
host-attached storage host-attached
storage host-attached storage
storage is storage
accessed through local
local i ports
ports these ports
technologies the typical
i bus architecture
architecture called ide
ide or ata
ata this architecture
supports a maximum
bus a newer
cabling is sata
sata high-end workstations
sophisticated i architectures
scsi and fiber
architecture its physical
number of conductors
scsi protocol supports
devices per bus
include one controller
common scsi target
ability to address
target a typical
logical unit addressing
commands to components
array or components
removable media library
sendil g commands
high-speed serial architecture
operate over optical
four-conductor copper cable
large switched fabric
24-bit address space
space this variant
variant is expected
expected to dominate
hosts and storage
devices can attach
allowing great flexibility
drives and controllers
devices are suitable
hard disk drives
commands that initiate
initiate data transfers
host-attached storage device
device are reads
writes of logical
logical data blocks
data blocks directed
specifically identified storage
identified storage units
target logical unit
12.3.2 network-attached storage
storage a network-attached
special-purpose storage system
clients access network-attached
access network-attached storage
nfs for unix
systems or cifs
cifs for windows
machines the remote
carried via tcp
carries all data
clients the networkattached
networkattached storage unit
array with software
software that implements
implements the rpc
easiest to thil
simply another storage-access
scsi device driver
driver and scsi
protocols to access
system using nas
rpc over tcp
network-attached storage network-attached
storage network-attached storage
lan to share
share a pool
ease of naming
naming and access
enjoyed with local
local host-attached storage
direct-attached storage options
latest network-attached storage
network-attached storage protocol
protocol in essence
protocol to carry
carry the scsi
networks-rather than scsi
interconnects between hosts
hosts can treat
treat their storage
storage is distant
host 12.3.3 storage-area
12.3.3 storage-area network
network one drawback
drawback of network-attached
network-attached storage systems
storage i operations
i operations consume
operations consume bandwidth
increasing the latency
latency of network
communication this problem
acute in large
large client-server installations-the
client-server installations-the communication
communication between servers
servers and clients
competes for bandwidth
communication among servers
servers and storage
devices a storage-area
flexibility multiple hosts
hosts and multiple
multiple storage arrays
arrays can attach
allocated to hosts
hosts a san
host is running
low on disk
configured to allocate
allocate more storage
host sans make
clusters of servers
servers to share
arrays to include
include multiple direct
multiple direct host
direct host com1.ections
host com1.ections sans
common san interconnect
simplicity of iscsi
iscsi is increasing
special-purpose bus architecture
bus architecture named
architecture named infiniband
support for highspeed
highspeed interconnection networks
networks for servers
meeting this responsibility
storage-area network fast
network fast access
large disk bandwidth
bandwidth the access
two major components
arm to move
move the heads
rotate the desired
head the disk
bandwidth by managing
managing the order
disk i requests
requests are serviced
issues a system
system the request
specifies several pieces
operation is input
desired disk drive
drive and controller
drive or controller
controller is busy
queue of pending
request is completed
operating system chooses
chooses which pending
request to service
operating system make
make this choice
12.4.1 fcfs scheduling
scheduling the simplest
form of disk
provide the fastest
queue with requests
i to blocks
blocks on cylinders
14,124,65,67 head starts
fcfs disk scheduling
initially at cylinder
total head movement
cylinders this schedule
schedule is diagrammed
requests for cylinders
improved 12.4.2 sstf
12.4.2 sstf scheduling
reasonable to service
current head position
position before moving
moving the head
sstf algorithm selects
selects the request
position since seek
seek time increases
chooses the pending
pending request closest
initial head position
request at cylinder
served next continuing
scheduling method results
needed for fcfs
improvement in performance
performance sstf scheduling
essentially a form
form of shortest-job-first
remember that requests
requests may arrive
arrive in theory
stream of requests
request for cylinder
sstf disk scheduling
pending-request queue grows
queue grows longer
reduces the total
cylinders 12.4.3 scan
12.4.3 scan scheduling
reaches each cylinder
direction of head
movement is reversed
continues the head
head continuously scans
disk the scan
disk arm behaves
reversing to service
illustrate before applying
scan to schedule
schedule the requests
requests on cylinders
movement in addition
head s current
current position assuming
arm is moving
arm will reverse
assuming a uniform
distribution of requests
density of requests
reaches one end
end and reverses
immediately in front
recently been serviced
serviced the heaviest
scan disk scheduling
disk these requests
waited the longest
algorithm 12.4.4 c-scan
12.4.4 c-scan scheduling
variant of scan
moves the head
disk without servicing
servicing any requests
c-scan scheduling algorithm
algorithm essentially treats
treats the cylinders
list that wraps
first one queue
c-scan disk scheduling
c-look disk scheduling
12.4.5 look scheduling
themf both scan
scan and c-scan
disk in practicef
practicef neither algorithm
commonlyf the arm
reverses direction immediatelyf
versions of scan
c-scan that follow
follow this pattern
request before continuing
continuing to move
sstf is common
performance over fcfs
systems that place
place a heavy
list of requestsf
define an optimal
order of retrievat
needed to find
find an optimal
justify the savings
savings over sstf
sstf or scan
scheduling algoritlunf howeverf
algoritlunf howeverf performance
howeverf performance depends
number and types
requests for instance
outstanding request thenf
thenf all scheduling
scheduling algorithms behave
behave the samef
behave like fcfs
fcfs scheduling requests
requests for disk
method a program
contiguously allocated file
file will generate
generate several requests
resulting in limited
limited head movement
movement a linked
linked or indexed
fik in contrastf
contrastf may include
resulting in greater
greater head movement
movement the location
location of directories
directories and index
usedf and opening
opening a file
file requires searching
structuref the directories
filef s data
casef the disk
move the entire
move only one-half
one-half the width
caching the directories
blocks in main
reduce disk-arm movement
algorithm the scheduling
scheduling algorithms described
distances for modern
schedule for improved
improved rotational latency
disclose the physical
location of logical
logical blocks disk
blocks disk manufacturers
alleviating this problem
implementing disk-scheduling algorithms
controller hardware built
operating system sends
sends a batch
batch of requests
controller can queue
responsibility of disk
hardware in practice
order for requests
priority over application
urgent than reads
cache is running
out of free
desirable to guarantee
guarantee the order
set of disk
writes to make
file system robust
face of system
operating system allocated
allocated a disk
application wrote data
chance to flush
flush the modified
inode and free-space
disk to accommodate
accommodate such requirements
spoon-feed the requests
i the operating
aspects of disk
discuss disk initialization
booting from disk
recovery 12.5.1 disk
12.5.1 disk formatting
magnetic recording material
disk can store
divided into sectors
controller can read
write this process
low-level formatting fills
fills the disk
special data structure
sector the data
sector typically consists
trailer the header
header and trailer
trailer contain information
writes a sector
sector of data
data during normal
ecc is updated
sector is read
ecc is recalculated
recalculated and compared
stored and calculated
bits of data
enable the controller
controller to identify
identify which bits
bits have changed
changed and calculate
reports a recoverable
written most hard
disks are low-level-formatted
process this formatting
enables the manufacturer
manufacturer to test
test the disk
initialize the mapping
mapping from logical
logical block numbers
numbers to defect-free
controller is instructed
instructed to low-level-format
low-level-format the disk
bytes of data
space to leave
1,024 bytes formatting
formatting a disk
larger sector size
sector size means
means that fewer
sectors can fit
headers and trailers
trailers are written
data some operating
systems can handle
disk to hold
steps the first
groups of cylinders
cylinders the operatiltg
system can treat
treat each partition
disk for instance
partition can hold
hold a copy
system s executable
holds user files
step is icgicz
operating system stores
stores the iltitial
iltitial file-system data
disk these data
structures may include
maps of free
free and allocated
fat or inodes
initial empty directory
directory to increase
file systems group
systems group blocks
frequently called disk
done via blocks
done via clusters
sequential-access and fewer
fewer random-access characteristics
characteristics some operating
database systems prefer
systems prefer raw
prefer raw iio
control the exact
exact disk location
record is stored
make certain applications
applications more efficient
efficient by allowing
services 12.5.2 boot
12.5.2 boot block
start running-for instance
simple it initializes
bootstrap program finds
kernel on disk
loads that kernel
kernel into memory
address to begin
begin the operating-system
bootstrap is stored
location is convenient
processor can start
executing when powered
rom is read
virus the problem
changing this bootstrap
store a tiny
tiny bootstrap loader
bootstrap loader program
full bootstrap program
disk the full
program is stored
boot rom instructs
instructs the disk
controller to read
read the boot
blocks into memory
drivers are loaded
executing that code
code the full
location on disk
start the operating
operating system ruru1ing
full bootstrap code
process in windows
places its boot
system and device
device drivers bootil1g
drivers bootil1g begins
system by running
system s rom
memory this code
directs the system
system to read
mbr in addition
listing the partitions
indicating which partition
partition the system
identifies the boot
reads the first
subsystems and system
system services mbr
services mbr partition
boot code partition
code partition table
partition table boot
table boot partition
boot partition figure
disk in windows
12.5.3 bad blocks
blocks because disks
disks have moving
parts and small
failure is complete
restored from backup
sectors become defective
defective most disks
disks even conle
factory with depending
disk and controller
blocks are handled
ways on simple
disks with ide
manually for instance
ms-dos format command
format command performs
command performs logical
performs logical formatting
scans the disk
disk to find
find bad blocks
blocks if format
finds a bad
writes a special
block if blocks
blocks go bad
bad during normal
manually to search
data that resided
lost more sophisticated
smarter about bad-block
recovery the controller
list of bad
list is initialized
disk low-level formatting
formatting also sets
sets aside spare
sectors not visible
system the controller
told to replace
replace each bad
sectors this scheme
typical bad-sector transaction
read logical block
calculates the ecc
ecc and finds
sector is bad
bad it reports
reports this finding
system is rebooted
command is run
controller to replace
replace the bad
system requests logical
requests logical block
request is translated
sector s address
controller could invalidate
invalidate any optimization
system s disk-scheduling
disks are formatted
formatted to provide
block is remapped
alternative to sector
sector some controllers
instructed to replace
replace a bad
suppose that logical
first available spare
spare follows sector
sector slipping remaps
copied into sector
slipping the sectors
space of sector
lost soft errors
errors may trigger
trigger a process
data is made
block is spared
spared or slipped
slipped an unrecoverable
unrecoverable howeverf results
results in lost
data whatever file
instancef by restoration
requires manual intervention
manual intervention swapping
swapping was first
discussed moving entire
moving entire processes
processes between disk
disk and main
main memory swapping
physical memory reaches
critically low point
point and processes
moved from memory
memory to swap
space to free
free available memory
memory in practicef
systems implement swapping
rathel ~ systems
systems now combine
swapping with virtual
necessarily entire processes
processes in fact
fact some systems
swapping and paging
paging interchangeablyf reflecting
reflecting the merging
system virtual memory
memory uses disk
memory since disk
slower than memory
accessf using swap
space significantly decreases
significantly decreases system
decreases system performance
performance the main
implementation of swap
sectionf we discuss
discuss how swap
space is usedf
usedf where swap
space is located
located on diskf
space is managed
managed 12.6.1 swap-space
swap-space use swap
operating systemsf depending
space to hold
hold an entire
entire process imagef
process imagef including
including the code
data segments paging
segments paging systems
simply store pages
memory the amount
swap space needed
megabytes of disk
space to gigabytesf
amow1.t of physical
memoryf the amount
amount of virtual
safer to overestimate
underestimate the amount
swap space requiredf
out of swap
forced to abort
crash entirely overestimation
overestimation wastes disk
wastes disk space
harm some systems
recommend the amount
swap space solarisf
solarisf for examplef
examplef suggests setting
suggests setting swap
setting swap space
swap space equal
virtual memory exceeds
memory exceeds pageable
exceeds pageable physical
pageable physical memory
linux has suggested
suggested setting swap
space to double
double the amount
considerably less swap
space in factf
set aside swap
operating systems-including linux-allow
multiple swap spaces
spaces these swap
put on separate
system by paging
systemfs i devices
12.6.2 swap-space location
location a swap
space can reside
normal file system
separate disk partition
simply a large
normal file-system routines
allocate its space
space this approach
implement is inefficient
navigating the directory
diskallocation data structures
data structures takes
extra disk accesses
disk accesses external
accesses external fragmentation
greatly increase swapping
increase swapping times
times by forcing
forcing multiple seeks
seeks during reading
performance by caching
caching the block
block location information
information in physical
tools to allocate
allocate physically contiguous
physically contiguous blocks
cost of traversing
traversing the file-system
data structures remains
partition no file
system or directory
separate swap-space storage
swap-space storage manager
deallocate the blocks
partition this manager
manager uses algorithms
optimized for speed
space is accessed
frequently than file
fragmentation may increase
trade-off is acceptable
life of data
system since swap
space is reinitialized
reinitialized at boot
fragmentation is short-lived
short-lived the raw-partition
raw-partition approach creates
creates a fixed
space during disk
disk partitioning adding
adding more swap
swap space requires
requires either repartitioning
repartitioning the disk
partitions or destroying
adding another swap
systems are flexible
file-system space linux
policy and implementation
implementation are separate
allowing the machine
machine s administrator
administrator to decide
decide which type
type of swapping
convenience of allocation
allocation and management
performance of swapping
swapping in raw
partitions 12.6.3 swap-space
12.6.3 swap-space management
illustrate how swap
evolution of swapping
systems the traditional
unix kernel started
implementation of swapping
swapping that copied
copied entire processes
processes between contiguous
contiguous disk regions
regions and memory
unix later evolved
combination of swapping
paging as pagiltg
designers changed standard
changed standard unix
standard unix methods
methods to improve
efficiency and reflect
reflect technological developments
pages containing code
code are brought
accessed in main
selected for pageout
efficient to reread
reread a page
store for pages
includes memory allocated
versions of solaris
solaris the biggest
solaris now allocates
allocates swap space
page is forced
out of physical
page is first
partition or swap
swap file swap
file swap map
1---------swap area--------1 page
page i slot
structures for swapping
swapping on linux
systems this scheme
performance on modern
memory than older
systems and tend
tend to page
page less linux
linux is similar
similar to solaris
regions of memory
established a swap
regular file system
partition each swap
swap area consists
hold swapped pages
array of integer
slot is occupied
page the value
ij.l.dicates the number
number of mappings
page is mapped
page is storing
storing a region
systems are shown
drives have continued
smaller and cheaper
feasible to attach
attach many disks
number of disks
system presents opportunities
opportunities for improving
improving the rate
disks are operated
operated in parallel
offers the potential
potential for improving
improving the reliability
reliability of data
stored on multiple
lead to loss
collectively called disks
address the performance
composed of small
disks were viewed
alternative to large
disks ; today
reliability and higher
higher data-transfer rate
stands for ij.l.dependent
ij.l.dependent 12.7.1 improvement
improvement of reliability
reliability via redundancy
reliability of raids
raids the chance
disks will fail
structuring raid raid
raid raid storage
disks directly attached
system or system
software can implement
implement raid flmctionality
intelligent host controller
controller can control
control multiple attached
disks in hardware
standard ata scsi
controllers this common
system and software
software without raid
raid software layers
simplicity and flexibility
disk will fail
failure will result
loss is unacceptable
unacceptable the solution
problem of reliability
store extra information
event of failure
disk to rebuild
rebuild the lost
lost the simplest
approach to introducing
duplicate every disk
disk this technique
logical disk consists
two physical disks
write is carried
disks the result
first failed disk
disk is replaced
mirrored volume-where failure
replace a failed
restore the data
mirrored disk system
assumption of independence
independence of disk
valid power failures
failures and natural
result in damage
batch of disks
failures as disks
probability of failure
increasing the chance
repaired in spite
n1.irrored-disk systems offer
offer much higher
singledisk systems power
systems power failures
source of concern
mirroring of disks
state one solution
write one copy
add a cache
array this write-back
cache is protected
protected from data
loss during power
assuming the nvram
kind of error
protection and correction
ecc or mirroring
mirroring 12.7.2 improvement
performance via parallelism
access to multiple
multiple disks improves
disks improves performance
performance with disk
handled is doubled
number of reads
reads per unit
doubled with multiple
improve the transfer
byte across multiple
byte to disk
disk with sectors
times the normal
times the access
number of accesses
access can read
read eight times
single disk bit-level
disk bit-level striping
generalized to include
include a number
file are striped
striped across multiple
levels of striping
sector or sectors
achieved through striping
two main goals
increase the throughput
throughput of multiple
multiple small accesses
load balancing reduce
reduce the response
accesses 12.7.3 raid
12.7.3 raid levels
raid levels mirroring
mirroring provides high
striping provides high
high data-transfer rates
improve reliability numerous
reliability numerous schemes
schemes to provide
redundancy at lower
disk striping combined
combined with parity
l1.ave been proposed
proposed these schemes
memory-style error-correcting codes
block-interleaved distributed parity
disks  worth
worth of data
store redundant information
information for failure
failure recovery raid
recovery raid level
refers to disk
arrays with striping
level of blocks
mirroring or parity
raid ievell raid
ievell raid level1
raid level1 refers
disk mirroring figure
shows a mirrored
organization  raid
raid level2 raid
level2 raid level2
organization memory systems
detected certain errors
bits each byte
byte is damaged
match the stored
stored parity bit
bit is damaged
match the computed
errors are detected
error-correcting schemes store
reconstruct the data
damaged the idea
idea of ecc
directly in disk
arrays via striping
striping of bytes
bytes across disks
stored in disk
bit in disk
bit is stored
bits are stored
disks this scheme
pictorially in figure
labeled p store
store the error-correction
reconstruct the damaged
damaged data note
note that raid
disks  overhead
disks of data
unlike raid level
requires four disks
overhead raid level
improves on level
taking into account
account the fact
unlike memory systems
controllers can detect
single parity bit
detection the idea
sectors is damaged
computing the parity
bits from sectors
bits is equal
good as level
number of extra
extra disks required
practice this scheme
advantages over level
disk is needed
disk in level1
byte are spread
out over multiple
disks with n-way
striping of data
rate for reading
writing a single
times as fast
raid level3 supports
level3 supports fewer
problem with raid
levels-is the expense
expense of computing
computing and writing
writing the parity
parity this overhead
significantly slower writes
non-parity raid arrays
arrays to moderate
moderate this performance
raid storage arrays
storage arrays include
include a hardware
controller with dedicated
dedicated parity hardware
hardware this controller
offloads the parity
array the array
store the blocks
parity is computed
buffer the writes
spindles this combination
combination can make
make parity raid
fast as non-parity
non-parity in fact
caching array doing
array doing parity
doing parity raid
raid can outperform
outperform a non-caching
non-caching non-parity raid
non-parity raid raid
raid raid level
diagramed in figure
disks to restore
restore the blocks
disk a block
block read accesses
allowing other requests
access is slowe1
multiple read accesses
accesses can proceed
proceed in parallel
rate the transfer
rates for large
reads are high
read in parallel
parallel ; large
high transfer rates
data and parity
written in parallel
parallel small independent
small independent writes
performed in parallel
parallel an operatingsystem
write of data
block be read
back the parity
single write requires
requires four disk
four disk accesses
two to read
two old blocks
two to write
two new blocks
level allows disks
raid set seamlessly
disks are initialized
initialized with blocks
correct raid levels
raid levels raid
levels raid levels
differs from level
disks and parity
stores the parity
block is stored
disks store actual
store actual data
block this setup
setup is shown
disks a parity
parity for blocks
failure would result
recoverable by spreading
spreading the parity
avoids potential overuse
single parity disk
occur with raid
common parity raid
parity raid system
raid system raid
system raid level
stores extra redundant
extra redundant information
information to guard
guard against disk
bits of redundant
bits of datacompared
bit in level
5-and the system
system can tolerate
tolerate two disk
two disk failures
disk failures raid
failures raid levels
combination of raid
performance than raid
common in enviromnents
reliability are important
doubles the number
needed for storage
expensive in raid
set of disks
disks are striped
stripe is mirrored
single disk failure
failure ua mirror
disk failure figure
commercially is raid
disks are mirrored
mirrored in pairs
resulti.j.l.g mirrored pairs
pairs are striped
striped this scheme
advantages over raid
single disk fails
fails in raid
stripe is inaccessible
failure in raid
disk is unavailable
disk that mirrors
basic raid schemes
raid schemes described
confusion may exist
levels the implementation
implementation of raid
area of variation
implemented volume-management software
system software layer
hardware can provide
provide a minimum
minimum of features
full raid solution
raid solution parity
solution parity raid
slow when implemented
disks directly connected
set this solution
solution is low
low in cost
array the storage
array can create
create raid sets
slice these sets
sets into smaller
implement the file
allowing multiple hosts
array s features
san interconnect layer
layer by disk
disk virtualization devices
storage it accepts
servers and manages
writing each block
two separate storage
separate storage devices
devices other features
involves the automatic
duplication of writes
writes between separate
sites for redundancy
redundancy and disaster
disaster recovery replication
asynchronous in synchronous
write is considered
writes are grouped
written periodically asynchronous
periodically asynchronous replication
replication can result
primary site fails
limitations the implementation
features differs depending
raid is implemented
out and manage
replication if replication
replication is implemented
host s data
hot spare disk
disk or disks
replacement in case
case disk failure
failure for instance
rebuild a mirrored
repaired without human
intervention 12.7.4 selecting
selecting a raid
system designers choose
choose a raid
level one consideration
consideration is rebuild
needed to rebuild
rebuild its data
supply of data
data is required
high-performance or interactive
interactive database systems
rebuild performance influences
failure rebuild performance
rebuild performance varies
level used rebuilding
rebuilding is easiest
easiest or raid
array to rebuild
failed disk rebuild
disk rebuild times
hours for raid
rebuilds of large
large disk sets
disk sets raid
sets raid level
applications where data
critical raid level1
level1 is popular
popular for applications
applications that require
require high reliability
reliability with fast
fast recovery raid
reliability are important-for
small databases due
due to raid
inserv storage array
storage array im1ovation
effort to provide
lines that separated
separated previous technologies
disks be configured
specific raid level
disk is broken
256-mb chunklets ram
level a disk
participate in multiple
multiple volumes inserv
system the format
format of inserv
system without needing
copy are copy-on-write
expand or shrink
change requires copying
requires copying data
data an administrator
administrator can configure
inserv to provide
provide a host
amount of logical
disks are allocated
original logical level
level the host
large fixed storage
fixed storage space
create its file
added or removed
system by inserv
file systems noticing
noticing the change
change this feature
feature can reduce
number of drives
needed by hosts
delay the purchase
purchase of disks
needed high space
high space overhead
preferred for storing
storing large volumes
volumes of data
offer better reliability
reliability than levels
levels raid system
raid system designers
designers and administrators
administrators of storage
rates are higher
bits are protected
space overhead due
due to parity
bits is lower
disk is repaired
repaired is greater
loss 12.7.5 extensions
extensions the concepts
concepts of raid
arrays of tapes
broadcast of data
data over wireless
systems when applied
applied to arrays
array is damaged
damaged when applied
applied to broadcast
block of data
data is split
split into short
robots containing multiple
multiple tape drives
drives will stripe
drives to increase
throughput and decrease
problems with raid
users a pointer
wrong incomplete writes
system s structures
protects against physical
physical media errors
errors as large
landscape of software
perils for data
system the solaris
solaris zfs file
file system takes
takes an innovative
approach to solving
verify the integrity
integrity of data
data zfs maintains
zfs maintains internal
maintains internal checksums
metadata these checksums
inode with pointers
data are mirrored
update the bad
entry that points
inode any problem
inode is detected
directory is accessed
accessed this checksumming
checksumming takes places
level of consistency
found in raid
raid disk sets
sets or standard
systems the extra
calculation and extra
extra block read-modify-write
block read-modify-write cycles
performance of zfs
fast another issue
implementations is lack
lack of flexibility
array with twenty
twenty disks divided
disks each set
four separate data
checksums all metadata
holding a file
large to fit
five-disk raid level
disks and volumes
storage array allowed
allowed the entire
set of twenty
large raid set
set other issues
issues could arise
arise several volumes
change a volume
volume s size
issue described above-mismatched
described above-mismatched file-system
above-mismatched file-system sizes
sizes some volume
volume n lanagers
lanagers allow size
growth or shrinkage
shrinkage the volumes
volumes could change
zfs combines file-system
combines file-system management
management and volume
unit providing greater
providing greater functionality
functions allows disks
partitions of disks
storage a pool
pool can hold
zfs file systems
systems the entire
pool s free
model of malloc
malloc and free
free to allocate
allocate and release
system as blocks
limits on storage
relocate file systems
systems between volumes
volumes or resize
resize volumes zfs
zfs provides quotas
quotas to limit
limit the size
system and reservations
reservations to assure
system can grow
file system owner
depicts traditional volumes
volumes and file
shows the zfs
zfs and pooled
pooled storage figure
pool and file
introduced the write-ahead
requires the availability
availability of stable
storage by definition
lost to implement
implement such storage
replicate the required
information on multiple
coordinate the writing
writing of updates
force all copies
consistent and correct
disk write results
completion the data
data were written
correctly on disk
disk partial failure
failure a failure
midst of transfer
sectors were written
sector being written
corrupted total failure
failure the failure
disk write started
previous data values
disk remain intact
occurs during writing
invoke a recovery
procedure to restore
restore the block
maintain two physical
two physical blocks
block an output
write the information
first physical block
first write completes
physical block declare
declare the operation
write completes successfully
successfully during recovery
pair of physical
blocks is examined
detectable error exists
replace its contents
differ in content
replace the content
recovery procedure ensures
write to stable
storage either succeeds
completely or results
extend this procedure
arbitrarily large number
number of copies
block of stable
copies further reduces
reduces the probability
reasonable to simulate
simulate stable storage
copies the data
data in stable
storage are guaranteed
copies because waiting
waiting for disk
writes to complete
storage arrays add
arrays add nvram
memory is nonvolatile
unit s power
trusted to store
data en route
stable storage writes
buy a dvd
disk sealed inside
cost low cost
characteristic of tertiary
section 12.9.1 tertiary-storage
12.9.1 tertiary-storage devices
devices because cost
storage is built
examples are floppy
cds and dvds
kinds of tertiarystorage
including removable devices
data in flash
memory and interact
interface 12.9.1.1 removable
12.9.1.1 removable disks
removable disks removable
disks removable disks
kind of tertiary
tertiary storage floppy
storage floppy disks
flexible disk coated
coated with magnetic
material and enclosed
protective plastic case
case although common
common floppy disks
disks can hold
fast as hard
kind of removable
disk it records
rigid platter coated
disk the magneto-optic
magneto-optic head flies
magnetic disk head
material is covered
thick protective layer
layer of plastic
plastic or glass
glass this arrangement
makes the disk
resistant to head
crashes the magneto-optic
magneto-optic disk drive
coil that produces
produces a magnetic
weak to magnetize
magnetize a bit
disk to write
write a bit
disk head flashes
flashes a laser
surface the laser
laser is aimed
written the laser
heats this spot
makes the spot
weak magnetic field
field can record
record a tiny
bit the magneto-optic
surface to read
data by detecting
detecting the tiny
tiny magnetic fields
reads a bit
property of laser
beam is bounced
beam is rotated
clockwise or counterclockwise
field this rotation
detects to read
read a bit
bit another category
category of removable
altered by laser
dark or bright
spots one exarnple
exarnple of optical-disk
state the crystalline
beam is brighter
ltlaterial and bounces
layer the phase-change
drive uses laser
power to read
power to erase
erase the disk
disk by melting
melting and refreezing
refreezing the recording
power to melt
melt the medium
state to write
cd-rw and dvd-rw
dvd-rw the kinds
kinds of disks
disks just described
make a worm
manufacture a thin
thin aluminum film
aluminum film sandwiched
glass or plastic
platters to write
light to burn
burn a small
aluminum this burning
destroy the information
disk by burning
impossible to alter
detect such additions
additions worm disks
disks are considered
durable and reliable
platters and magnetic
damage the recording
recording a newer
newer write-once technology
write-once technology records
organic polymer dye
dye absorbs laser
absorbs laser light
light to form
marks this technology
cd-r and dvd-r
bits are pressed
durable most removable
disks are slower
counterparts the writing
process is slower
12.9.1.2 tapes magnetic
tapes magnetic tape
type of removable
holds more data
optical or magnetic
magnetic disk cartridge
disk cartridge tape
cartridge tape drives
drives and disk
drives have similar
similar transfer rates
rates but random
access to tape
requires a fast-forward
fast-forward or rewind
operation that takes
tens of seconds
typical tape drive
typical disk drive
cartridge is lower
capacity of magnetic
disks so tape
medium for purposes
require fast random
fast random access
random access tapes
hold backup copies
copies of disk
large supercomputer centers
centers to hold
hold the enornwus
large commercial enterprises
commercial enterprises large
enterprises large tape
large tape installations
typically use robotic
robotic tape changers
changers that move
tapes between tape
drives and storage
library these mechanisms
give the computer
computer automated access
cartridges a robotic
robotic tape library
library can lower
cost of data
storage a diskresident
cost per gigabyte
gigabyte is lower
back into disk
storage for active
performance of on-line
on-line magnetic disks
cost of off-line
off-line tapes sitting
sitting on shelves
room 12.9.1.3 future
12.9.1.3 future technology
growing in importance
common simply described
hard drive depending
nonvolatile the memory
technology also affects
affects performance nonvolatile
performance nonvolatile ssds
characteristics as traditional
traditional hard disks
parts and faster
latency in addition
expensive per megabyte
megabyte than traditional
larger hard disks
life-spans than hard
arrays to hold
metadata which requires
journaling file system
file system ssds
added to notebook
computers to make
make them smaller
efficient another promising
promising storage technology
phk uses laser
light to record
record holographic photographs
photographs on special
array of pixels
pixels each pixel
represents one bit
hologram are transferred
flash of laser
data transfer rate
high with continued
viable another technology
technology under active
research is based
apply the fabrication
technologies that produce
produce electronic chips
manufacture of small
small datastorage machines
machines one proposal
10,000 tiny disk
tiny disk heads
centimeter of magnetic
magnetic storage material
storage material suspended
material is moved
track of data
material the storage
slightly to enable
heads to access
provide a nonvolatile
nonvolatile data-storage technology
faster than magnetic
disk and cheaper
cheaper than semiconductor
removable magnetic disk
provide several capabilities
media for data
storage these capabilities
capabilities are discussed
12.9.2 12.9.2 operating-system
12.9.2 operating-system support
support two major
two major jobs
manage physical devices
present a virtual
virtual machine abstraction
abstraction to applications
array of data
operating system queues
schedules the interleaved
media are removable
removable 12.9.2.1 application
12.9.2.1 application interface
interface most operating
handle removable disks
cartridge is inserted
empty file system
disk this file
hard disk tapes
differently the operating
system usually presents
presents a tape
raw storage medium
medium an application
exits or closes
closes the tape
device this exclusivity
exclusivity makes sense
interleaving random accesses
accesses to tapes
drive is presented
provide file-system services
services the application
application must decide
array of blocks
program that backs
disk to tape
tape might store
store a list
names and sizes
copy the data
organize a tape
full of data
names and file
file names stored
sizes in binary
binary or ascii
tremendously long string
operations are read
set of basic
operation the tape
positions the tape
specific logical block
entire track locating
locating to block
rewinding the tape
kinds of tape
partly filled tape
manage their physical
place empty sectors
written most tape
variable block size
block is detern
area of defective
tape is encountered
encountered during writing
area is skipped
written area -the
area -the positions
positions and numbers
operation that returns
returns the logical
located many tape
drives also support
support a space
operation for relative
two logical blocks
writing a block
write in practice
side effect means
updating a block
block the tape
tape drive implements
implements this appending
appending by placing
placing an end-of-tape
written the drive
refuses to locate
past the eot
start writing doing
doing so overwrites
mark and places
blocks just written
written in principle
property of tape
tape 12.9.2.2 file
12.9.2.2 file naming
naming another question
files on removable
file name consists
molmt table enables
system to discover
drive the file
file is located
disk is removable
knowing what drive
contained the cartridge
two serial numbers
digits in length
memorize a 12-digit
12-digit serial number
difficulty is knowing
knowing the contents
contents and data
machines or drives
problems can arise
drives are compatible
computers may store
encodings for binary
ascii on pcs
pcs versus ebcdic
ebcdic on mainframes
today s operating
systems generally leave
leave the name-space
name-space problem unsolved
unsolved for removable
media and depend
depend on applications
applications and users
users to figure
access and interpret
interpret the data
kinds of removable
drive data cds
operating-system device driver
programmed to handle
comn1on formats dvd
formats dvd fonnats
12.9.2.3 hierarchical storage
hierarchical storage management
enables the computer
computer to change
change the removable
drive without human
assistance two major
backups and hierarchical
hierarchical storage systems
jukebox for backups
backups is simple
cartridge becomes full
instructs the jukebox
jukebox to switch
cartridge some jukeboxes
jukeboxes hold tens
tens of drives
drives and thousands
thousands of cartridges
robotic arms managing
managing the movement
movement of tapes
drives a hierarchical
hierarchical storage system
storage system extends
extends the storage
hierarchy beyond primary
memory and secondary
incorporate tertiary storage
tertiary storage tertiary
storage tertiary storage
jukebox of tapes
disks this level
hierarchy is larger
manner to tertiary
out in practice
practice the reason
delay is intolerable
intolerable for demand
forms of virtual
extend the file
file system small
frequently used files
remain on magnetic
continues to exist
file no longer
longer occupy space
space in secondary
call is suspended
operation returns control
found in installations
work in hsm
hsm includes extending
move from disk
sites save e-mail
backup tape ilm
tape ilm centralizes
ilm centralizes knowledge
locations 12.9.3 performance
12.9.3 performance issues
aspects of tertiary-storage
performance are speed
cost 12.9.3.1 speed
speed the speed
speed of tertiary
bandwidth and latency
latency we measure
measure the bandwidth
bandwidth in bytes
average data rate
calculates the average
jukebox in essence
stream actually flows
data rate provided
drive the bandwidth
bandwidth for removable
tlce bandwidth ranges
range of bandwidths
aspect of speed
faster than tapes
tapes disk storage
open a disk
access simply moves
moves the ann
cylinder and waits
milliseconds by contrast
storage is three-dimensional
tape is accessible
bits are buried
buried below hundreds
hundreds or thousands
thousands of layers
layers of tape
reel a random
access on tape
tape requires winding
winding the tape
selected block reaches
reaches the tape
tens or hundreds
hundreds of seconds
access on disk
jukebox is involved
drive must stop
arm must switch
switch the disk
drive must spin
cartridge this operation
takes several seconds-about
hundred times longer
disk so switching
high performance penalty
penalty for tapes
generally must rewind
tape is loaded
drive to calibrate
slow tape jukebox
tape to generalize
latency of tens
latency of hundreds
seconds ; switching
tapes is expensive
expensive tape jukeboxes
jukeboxes can rewind
item of data
latency seem reasonable
focus our attention
find a terrible
first the bandwidth
bandwidth the bandwidth-to-storage-capacity
disk to read
large hard disk
hour to read
large tape library
years the situation
situation with respect
respect to access
bad to illustrate
requests are queued
hour the low
cost of tertiary
tertiary storage results
cheap cartridges share
infrequently used data
library can satisfy
requests per hour
hour 12.9.3.2 reliability
good pe1jormance means
pe1jormance means high
means high speed
aspect of performance
performance is reliability
read some data
drive or media
purposes the access
important to understand
understand the reliability
reliability of removable
removable media removable
media removable n1.ag
fixed hard disks
exposed to harmful
harmful environmental conditions
temperature and humidity
shock and bending
bending optical disks
considered very reliable
layer that stores
stores the bits
bits is protected
layer the reliability
reliability of magnetic
magnetic tape varies
kind of drive
drive some inexpensive
inexpensive drives wear
wear out tapes
drives are gentle
millions of reuses
reuses by comparison
spot a disk
tape the scrubbing
tape can wear
out the head
thousands or tens
thousands of hours
hours in summary
removable-disk or tape
fixed magnetic disk
weakness a head
disk generally destroys
destroys the data
drive or optical-disk
drive often leaves
leaves the data
data cartridge unharmed
unharmed 12.9.3.3 cost
12.9.3.3 cost storage
cost storage cost
media may lower
storage cost suppose
disk that holds
platters the storage
manufacture the platters
capacity is lox
expensive to make
make a removable
gigabyte of removable
drive is averaged
removable cartridges figures
show cost trends
trends per megabyte
megabyte for dram
magnetic hard disks
drives the prices
lowest prices found
found in advertisements
year these prices
reflect the smallcomputer
prices are low
low by comparison
mainframe and minicomputer
case of tape
cost of tape
tapes are purchased
2oos year figure
price per megabyte
megabyte of dram
huge tape library
library containing thousands
cost is dominated
cost of dram
dram fluctuates widely
excess production caused
caused a glut
marketplace caused sigrtificant
caused sigrtificant price
sigrtificant price increases
case of hard
steadier tape-drive prices
prices also fell
price per gigabyte
gigabyte of inexpensive
inexpensive tape drives
drives has ceased
ceased its dramatic
price of mid-range
mid-range tape technology
continued to fall
megabyte of magnetic
magnetic hard disk
in.expensive drives tape-drive
drives tape-drive prices
shown for years
prices are targeted
cost of storage
storage has fallen
dramatically by comparing
comparing the graphs
price of disk
storage has plummeted
price of dram
dram and tape
tape the price
magnetic disk storage
disk storage improved
improvement for main
magnitude main memory
main memory today
expensive than disk
rapidly for disk
magnetic disk drive
drive is approaching
small and medium-sized
medium-sized tape libraries
higher storage cost
cost than disk
systems with equivalent
capacity the dramatic
fall in disk
largely rendered tertiary
rendered tertiary storage
tertiary storage obsolete
tertiary storage technology
magnitude less expensive
expensive than magnetic
disk it appears
revival of tertiary
storage must await
await a revolutionary
revolutionary technology breakthrough
storage will find
limited to purposes
drives and archival
storage in enormous
enormous tape libraries
exceed the practical
practical storage capacity
capacity of large
large disk farms
disk farms disk
farms disk drives
secondary-storage i devices
computers most secondary
secondary storage devices
disks or n1.agnetic
n1.agnetic tapes modern
tapes modern disk
drives are structured
structured as large
arrays of logical
logical disk blocks
i are generated
system each request
specifies the address
block number disk-schedliling
number disk-schedliling algorithms
algorithms can improve
improve the effective
variance in response
response time algorithms
c-look are designed
designed to make
make such improvements
improvements through strategies
strategies for disk-queue
disk-queue ordering performance
harmed by external
fragmentation some systems
systems have utilities
utilities that scan
scan the file
system to identify
identify fragmented files
decrease the fragmentation
badly fragmented file
fragmented file system
significantly improve performance
progress sophisticated file
sophisticated file systems
unix fast file
incorporate many strategies
strategies to control
fragmentation during space
needed the operating
manages the disk
formatted to create
create the sectors
raw hardware-new disks
disk is partitioned
allocated to store
store the system
system s bootstrap
block is corrupted
out that block
efficient swap space
key to good
systems usually bypass
bypass the file
raw disk access
access for paging
i some systems
dedicate a raw
raw disk partition
partition to swap
user or system
administrator to make
make the decision
decision by providing
providing both options
amount of storage
required on large
frequently made redundant
redundant via raid
algorithms these algorithms
disk failure raid
failure raid algorithms
algorithms are organized
combination of reliability
reliability and high
rates the write-ahead
log scheme requires
storage to implement
replicate the needed
multiple nonvolatile storage
nonvolatile storage devices
update the information
manner to ensure
recover the stable
failure during data
transfer or recovery
recovery tertiary storage
built from disk
including magnetic tape
magnetic and magneto-optic
disks for removable
including space management
management and requestqueue
drive this convention
convention is simpler
potentially more confusing
identifies a specific
cartridge for tapes
interface many operating
support for jukeboxes
privileged application designed
designed for backups
hsm three important
aspects of performance
performance are bandwidth
reliability many bandwidths
generally much greater
disk switching cartridges
ratio of drives
drives to cartridges
reading a large
long time optical
protect the sensitive
generally more robust
robust than magnetic
expose the magnetic
material to physical
storage has decreased
past two decades
notably for disk
effects on cost
cost and performance
performance if tape
density as disk
number of gigabits
gigabits per square
medium in fact
fact the suitability
device for random
random access depends
size the term
term streaming transfer
streaming transfer rate
transfer rate denotes
denotes the rate
excluding the effect
effect of access
latency by contrast
effective transfer rate
ratio of total
bytes per total
access latency suppose
megabytes per seconds
seconds a random
device to decrease
data are transferred
ratio of effective
rate to streaming
transfer rate calculate
calculate the utilization
four transfer sizes
compute the smallest
smallest transfer size
size for disk
device for transfers
larger than ______
device for s1naller
transfers e compute
compute the minimum
minimum transfer sizes
sizes that give
give acceptable utilization
utilization for cache
tape a random-access
described in terms
measured in drive-hours
drive-hours per failure
1,000 disk drives
750,000 hour mtbf
failure will occur
1,000 of dying
deduce the mtbf
convert this figure
figure from hours
hours to years
model of disk
system could maintain
maintain a free-space
tape-resident file system
file system assume
marks and locate
read position commands
commands as described
holographic storage drive
invented the drive
cartridge the size
holds 40,000 images
square black-and-white picture
drive can read
write one picture
kinds of storage
term fast wide
fast wide scsi-ii
wide scsi-ii denotes
denotes a scsi
bus that operates
moves a packet
packet of bytes
wide scsi-ii disk
scsi-ii disk drive
disk drive spins
track a estimate
estimate the sustained
sustained transfer rate
drive in megabytes
tracks per cylinde1
information to give
give an accurate
transfer c suppose
workload that reads
reads individual sectors
disk d calculate
calculate the random-access
random-access i operations
reduce the average
average seek distance
seek distance suppose
workload is reading
reading 8-kilobyte pages
scheduling algorithm reduces
reduces the average
milliseconds now calculate
compare the performance
performance of write
write operations achieved
raid level1 organization
serving a request
disk arm moves
moves to satisfy
algorithms a fcfs
fcfs b sstf
c-scan f c-look
elementary physics states
object is subjected
relationship between distance
disk in exercise
accelerates the disk
decelerates the disk
disk can perform
perform a seek
head moves explain
distance b write
write an equation
distance this equation
distance in cylinders
cylinders c calculate
calculate the total
schedules in exercise
determine which schedule
smallest total seek
schedule over fcfs
accelerating seek described
described in exercise
typical of hard-disk
drives by contrast
hard disks manufactured
fixed rate suppose
milliseconds a write
scb.edule over fcfs
average rotational latency
found or part
one-sided 5.25-inch optical-disk
5.25-inch optical-disk cartridge
gigabit per square
inch further suppose
megabits per square
1,800 feet long
feet long calculate
calculate an estimate
storage media suppose
optical tape exists
disk what volume
volume of data
optical tape hold
magnetic tape cost
program that simulates
simulates the disk-scheduling
disk-scheduling algorithms discussed
considered in disk
c-scan to include
include latency optimization
remapping bad blocks
blocks by sector
sparing or sector
slipping can influence
influence perfonnance suppose
drive in exercise
sectors at random
sector is mapped
estimate the number
random-access workload consisting
assuming a queue
choice of scheduling
sector on performance
disadvantages of sector
sparing and sector
performance of c-scan
c-scan and scan
request s service
variation in response
sizes of seek
assertion is true
true b describe
scan to ensure
fairness c explain
explain why fairness
system d give
examples of circumstances
system be unfair
unfair in serving
serving i requests
comprising five disks
parity for sets
four disks stored
blocks are accessed
accessed in order
order to perform
blocks of data
system generally treats
generally treats removable
treats removable disks
disks as shared
shared file systems
systems but assigns
assigns a tape
explain this difference
difference in treatment
treatment of disks
describe the additional
shared file-system access
sharing the tape
files were disk-resident
ram disk affect
affect your selection
algorithm what factors
apply to hard-disk
file system stores
recently used blocks
cache in main
estimates to compare
compare the cost
terabyte storage system
storage system made
incorporates tertiary storage
tertiary storage suppose
magnetic disk holds
average access latency
milliseconds also suppose
tape library costs
compute the total
maximum total data
total data rate
pure disk system
describe and justify
reside on disk
percent are archived
library further suppose
disk system handles
mixed configuration comprising
configuration comprising disks
comprising disks organized
organized as raid
levell and raid
raid levels disks
levels disks assume
system has flexibility
flexibility in deciding
deciding which disk
file which files
disks in order
order to optimize
involved in rereading
rereading code pages
file system versus
versus using swap
expect a cylinder
scheduling algorithms discussed
answer b propose
propose a disk-scheduling
performance by taking
disk c file
systems typically fil1.d
typically fil1.d data
fil1.d data blocks
fat in dos
dos or inodes
inodes in unix
indirection to improve
improve disk performance
discuss the reasons
system might require
require accurate information
blocks are stored
operating system improve
system improve file
improve file system
file system performance
compare the throughput
raid levels organization
raid levell organization
operations on single
blocks b read
operations on multiple
multiple contiguous blocks
performance for read
discussions of redundant
arrays of independent
presented by patterson
survey of chen
architectures for high-performance
computing are discussed
discussed by katz
enhancements to raid
discussed in wilkes
teorey and pinkerton
present an early
early comparative analysis
analysis of disk-scheduling
simulations that model
model a disk
choice for queue
c-look is good
good for queue
ways to improve
improve the seek
moving the disk
jacobson and wilkes
addition to seek
seek time scheduling
optimizations that exploit
exploit disk idle
disk idle times
times are discussed
discussed in lumb
discuss disk performance
performance and show
show the negligible
negligible performance impact
impact of defect
management the placement
placement of hot
data to improve
improve seek times
considered by ruemmler
ruemmler and wilkes
akyurek and salenl
describe an accurate
accurate performance model
modern disk drive
disk drive worthington
determine low-level disk
low-level disk properties
advanced by schindler
schindler and gregory
disk power management
power management issues
issues are discussed
discussed in douglis
1994l and golding
size and randomness
influence on disk
report numerous interesting
numerous interesting workload
interesting workload characteristics
files are smalt
newly created files
files are deleted
reading are read
seeks are short
describe the berkeley
techniques to obtain
obtain good performance
variety of workloads
discuss further improvements
basic ffs quinlan
system on worm
magnetic disk cache
cache ; richards
discusses a file-system
approach to tertiary
tertiary storage maher
integration of distributed
systems and tertiary
storage the concept
years for instance
paper by mattson
describes a mathematical
approach to predicting
predicting the performance
storage hierarchy alt
describes the accommodation
accommodation of removable
commercial operating system
miller and katz
describe the characteristics
characteristics of tertiary-storage
supercomputing environment benjamin
massive storage requirements
project at nasa
disks and programmable
disks are discussed
discussed in gibson
1997b t gibson
1998t and lee
lee and thekkath
holographic storage technology
article by psaltis
psaltis and mok
collection of papers
assembled by sincerbox
asthana and finkelstein
describe several emerging
emerging storage technologies
including holographic storage
electron trapping toigo
description of modern
modern disk technology
potential future storage
future storage technologies
two main jobs
i and processing
incidental for instance
browse a web
page or edit
edit a file
read or enter
enter some information
compute an answer
answer the role
system in computer
manage and control
control i operations
devices although related
pieces to paint
paint a complete
describe the basics
hardware interface places
interface places constraints
i services provided
operating system bridges
bridges the gap
discuss the unix
system v streams
enables an application
application to assemble
pipelines of driver
driver code dynamically
principles of operating-system
design that improve
improve i performance
performance to explore
explore the structure
subsystem to discuss
principles and complexities
hardware to explain
software the control
control of devices
concern of operating-system
i devices vary
function and speed
methods are needed
needed to control
kernet which separates
separates the rest
complexities of managing
managing i devices
exhibits two conflicting
two conflicting trends
standardization of software
interfaces this trend
11s to incorporate
incorporate improved device
improved device generations
generations into existing
computers and operating
increasingly broad variety
unlike previous devices
challenge to incorporate
systems this challenge
challenge is met
combination of hardware
techniques the basic
basic i hardware
i hardware elements
accommodate a wide
devices to encapsulate
encapsulate the details
details and oddities
system is structured
modules the present
present a uniform
uniform deviceaccess interface
provide a standard
system computers operate
operate a great
great many kinds
devices most fit
categories of storage
military fighter jet
human gives input
joystick and foot
computer sends output
sends output commands
motors to move
concepts to understand
devices are attached
software can control
control the hardware
hardware a device
system by sending
air the device
port if devices
rigidly defined protocol
protocol that specifies
specifies a set
set of messages
wires in terms
messages are conveyed
conveyed by patterns
patterns of electrical
electrical voltages applied
wires with defined
timings when device
cable that plugs
plugs into device
device c plugs
chain usually operates
widely in computer
architecture and vary
methods a typical
typical pc bus
bus structure appears
common pc system
connects the processor-memory
connects relatively slow
keyboard and serial
serial and usb
disks are c01mected
scsi bus plugged
controller other common
interconnect main parts
collection of electronics
operate a port
device a serial-port
simple device controller
computer that controls
controls the signals
bus structure wires
port by contrast
scsi bus controller
protocol is complex
separate circuit board
memory to enable
process the scsi
scsi protocol messages
messages some devices
circuit board attached
side this board
controller it implements
implements the disk
kind of com1ection-scsi
com1ection-scsi or ata
processor give commands
commands and data
controller to accomplish
transfer the short
registers for data
data and control
signals the processor
controller by reading
writing bit patterns
communication can occur
byte or word
i instruction triggers
instruction triggers bus
triggers bus lines
lines to select
select the proper
controller can support
registers are mapped
processor the cpu
executes i requests
standard data-transfer instructions
instructions to read
write the device-control
registers some systems
techniques for instance
instructions to control
control some devices
devices and memory-mapped
control others figure
shows the usual
usual i port
addresses for pcs
pcs the graphics
ports for basic
basic control operations
large memory558 chapter
000-00f dma controller
controller 020-021 interrupt
020-021 interrupt controller
controller 040-043 timer
timer 200-20f game
200-20f game controller
controller 2f8-2ff serial
2f8-2ff serial port
320-32f hard-disk controller
controller 378-37f parallel
378-37f parallel port
port 3d0-3df graphics
3d0-3df graphics controller
controller 3f0-3f7 diskette-drive
3f0-3f7 diskette-drive controller
controller 3f8-3ff serial
3f8-3ff serial port
locations on pcs
region to hold
hold screen contents
contents the process
process sends output
screen by writing
region the controller
generates the screen
screen image based
technique is simple
millions of bytes
faster than issuing
ease of writing
memory-mapped i controller
controller is offset
type of software
memory-mapped device register
register is vulnerable
vulnerable to accidental
protected memory helps
helps to reduce
reduce this risk
port typically consists
input is written
host to send
host these bits
bits indicate states
command has completed
host to start
start a command
change the nlode
device for instance
serial port chooses
chooses between full-duplex
full-duplex and half-duplex
bit enables parity
enables parity checking
sets the word
port the data
size some controllers
controllers have fifo
hold several bytes
bytes of input
data to expand
expand the capacity
register a fifo
chip can hold
hold a small
burst of data
device or host
receive those data
polling the complete
protocol for interaction
basic handshaking notion
notion is simple
simple we explain
coordinate the producer-consumer
host the controller
set a bit
means to write
clear a bit
sets the busy
working and clears
clears the busy
ready to accept
comm.and the host
signals its wishes
register the host
sets the command-ready
controller to execute
host writes output
controller by handshaking
host repeatedly reads
reads the busy
bit becomes clear
clear the host
sets the write
register and writes
writes a byte
bit the controller
reads the command
register and sees
sees the write
command it reads
reads the data-out
device the controller
clears the command-ready
clears the error
device i succeeded
finished this loop
loop is repeated
byte in step
reading the status
controller and device
host must service
service the device
lost for instance
data are streaming
controller will overflow
overflow and data
long before returning
returning to read
read the bytes
cycles are sufficient
sufficient to poll
poll a device
read a device
logical-and to extract
extract a status
basic polling operation
operation is efficient
efficient but polling
polling becomes inefficient
finds a device
ready for service
cpu processing remains
processing remains undone
efficient to arrange
controller to notify
notify the cpu
device becomes ready
require the cpu
cpu to poll
completion the hardware
mechanism that enables
enables a device
device to notify
cpu device driver
device driver initiates
cpu executing checks
checks for interrupts
interrupts between instructions
instructions cpu resumes
cpu resumes processing
processing of interrupted
cycle 13.2.2 interrupts
interrupts the basic
basic interrupt mechanism
interrupt mechanism works
senses after executing
executing every instruction
controller has asserted
asserted a signal
performs a state
save and jumps
address in memory
memory the interrupt
interrupt handler determines
executes a return
return from interrupt
instruction to return
return the cpu
device controller raises
raises an interrupt
interrupt by asserting
asserting a signal
interrupt request line
catches the interrupt
interrupt and dispatches
clears the interrupt
interrupt by servicing
servicing the device
summarizes the interrupt-driven
interrupt-driven i cycle
cycle this basic
interrupt mechanism enables
enables the cpu
cpu to respond
controller becomes ready
nlore sophisticated interrupthandling
sophisticated interrupthandling features
ability to defer
defer interrupt handling
handling during critical
proper interrupt handler
device without first
raised the interrupt
system can distinguish
distinguish between high
high and low-priority
degree of urgency
urgency in modern
modern computer hardware
features are provided
two interrupt request
interrupt request lines
reserved for events
unrecoverable memory errors
execution of critical
critical instruction sequences
interrupted the maskable
controllers to request
service the interrupt
interrupt mechanism accepts
accepts an number
number that selects
selects a specific
specific interrupt-handling routine
addresses of specialized
specialized interrupt handlers
handlers the purpose
vectored interrupt mechanism
single interrupt handler
handler to search
sources of interrupts
interrupts to determine
service in practice
vector a common
technique of interrupt
interrupt vector points
list of interrupt
il1.terrupt is raised
request this structure
huge interrupt table
inefficiency of dispatching
interrupt handler figure
illustrates the design
design of theinterruptvector
intel pentium processor
processor the events
signal various error
conditions the events
interrupts the interrupt
mechanism also implements
implements a system
cpu to defer
defer the handling
handling of low-priority
interrupts without maskii1.g
interrupts and makes
interrupt to preempt
preempt the execution
interrupt a modern
operating system interacts
ways at boot
operating system probes
buses to determine
determine what devices
devices are present
present and installs
device controllers raise
controllers raise interrupts
service these interrupts
signify that output
output has cornpleted
detected the interrupt
handle a wide
accessing a protected
protected or nonexistent
nonexistent memory address
attempting to execute
instruction from user
mode the events
events that trigger
occurrences that induce
induce the cpu
execute an urgent
urgent self-contained routine
routine an operating
mechanism that saves
saves a small
amount of processor
19-31 32-255 breakpoint
32-255 breakpoint into-detected
breakpoint into-detected overflow
into-detected overflow bound
overflow bound range
bound range exception
range exception invalid
exception invalid opcode
invalid opcode device
double fault coprocessor
fault coprocessor segment
coprocessor segment overrun
invalid task state
task state segment
state segment segment
segment not present
present stack fault
stack fault general
fault general protection
general protection page
protection page fault
floating-point error alignment
error alignment check
alignment check machine
check machine check
maskable interrupts figure
figure i3.4 intel
i3.4 intel pentium
pentium processor event-vector
processor event-vector table
event-vector table calls
calls a privileged
mechanism for virtual
virtual memory paging
paging a page
exception that raises
interrupt the interrupt
suspends the current
process and jumps
kernel this handler
moves the process
performs page-cache management
operation to fetch
fetch the page
schedules another process
process to resume
implementation of system
program uses library
calls to issue
calls the library
library routines check
check the arguments
build a data
structure to convey
convey the arguments
operand that identifies
identifies the desired
desired kernel service
executes the trap
interrupt hardware saves
switches to supervisor
routine that implements
implements the requested
service the trap
low interrupt priority
interrupt priority compared
assigned to device
interrupts-executilcg a system
call on behalf
urgent than servicing
servicing a device
fifo queue overflows
overflows and loses
loses data interrupts
manage the flow
complete a disk
read one step
data from kernel
buffer this copying
block other high-priority
handling another step
drive this step
step has higher
previous one completes
pair of interrupt
interrupt handlers implen
handlers implen ents
ents the kernel
code that completes
completes a disk
read the high-priority
high-priority handler records
clears the device
raises a low-priority
interrupt to complete
complete the work
occupied with high-priority
completes the userlevel
i by copying
calling the scheduler
scheduler to place
place the application
queue a threaded
threaded kernel architecture
suited to implement
implement multiple interrupt
multiple interrupt priorities
enforce the precedence
precedence of interrupt
handling over background
processing in kernel
kernel and application
routines we illustrate
kernel in solaris
handlers are executed
executed as kernel
threads a range
range of high
priorities is reserved
threads these priorities
priorities give interrupt
give interrupt handlers
interrupt handlers precedence
precedence over application
code and kernel
housekeeping and implement
implement the priority
relationships among interrupt
handlers the priorities
solaris thread scheduler
scheduler to preempt
preempt lowpriority interrupt
lowpriority interrupt handlers
handlers in favor
favor of higher-priority
threaded implementation enables
implementation enables multiprocessor
enables multiprocessor hardware
hardware to run
run several interrupt
interrupt handlers concurrently
concurrently we describe
describe the interrupt
architecture of windows
unix in chapter
systems to handle
handle asynchronous events
trap to supervisor-mode
kernel to enable
system of interrupt
interrupt priorities device
priorities device controllers
calls all raise
interrupts to trigger
trigger kernel routines
routines because interrupts
heavily for time-sensitive
efficient interrupt handling
handling is required
required for good
good system performance
performance 13.2.3 direct
13.2.3 direct memory
expensive general-purpose processor
processor to watch
watch status bits
register one byte
time-a process termed
termed many computers
computers avoid burdening
burdening the main
cpu with pio
pio by offloading
initiate a dma
writes a dma
dma command block
block into memory
memory this block
transferred the cpu
writes the address
work the dma
dma controller proceeds
proceeds to operate
operate the memory
bus to perform
cpu a simple
simple dma controller
component in pcs
high-speed dma hardware
dma hardware handshaking
controller is performed
pair of wires
wires called dma-request
dma-request and dma-acknowledge
dma-acknowledge the device
device controller places
places a signal
word of data
transfer this signal
controller to seize
place the desired
place a signal
iia -acknowledge wire
device controller receives
receives the dma-acknowledge
signat it transfers
transfers the word
memory and removes
removes the dma-request
transfer is finished
dma controller interrupts
interrupts the cpu
cpu this process
process is depicted
dma controller seizes
seizes the memory
prevented from accessing
accessing main memory
access data items
primary and secondary
offloading the data-transfer
controller generally improves
improves the total
total system performance
performance some computer
architectures use physical
physical memory addresses
addresses for dma
mercwry using virtual
translation to physical
physical addresses dvma
dvma can perform
perform a transfer
two memory-mapped devices
memory on protected-mode
system generally prevents
generally prevents processes
processes from issuing
issuing device commands
device commands directly
directly this discipline
discipline protects data
data from access-control
protects the system
system from erroneous
operating system exports
system exports functions
sufficiently privileged process
access low-level operations
hardware on kernels
kernels without memory
processes can access
access device controllers
device controllers directly
directly this direct
avoid kernel communication
layers of kernelsoftware
interferes with system
security and stability
stability the trend
trend in general-purpose
memory and devices
guard against erroneous
erroneous or malicious
dma controller transfers
controller transfers bytes
bytes to buffer
increasing memory address
address and decreasing
driver is told
told to transfer
transfer disk data
data to buffer
buffer at address
device driver tells
--  disk
controller to transfer
transfer c bytes
bytes from disk
disk to buffer
dma interrupts cpu
cpu to signal
signal transfer completion
2..c ~ li.ip
rc-c ~ .,.,---j
.,.,---j = ,._
disk controller initiates
controller initiates dma
initiates dma transfer
dma transfer cg
cg ! ,or
disk controller sends
sends each byte
byte to dma
dma controller figure
i are complex
complex when considered
detail of electronics-hardware
described are sufficient
sufficient to enable
features of operating
review the main
bus a controller
registers the handshaking
controller the execution
interrupts the offloading
controller for large
transfers we gave
gave a basic
handshaking that takes
section in reality
poses a problem
problem for operating-system
implementers each kind
kind of device
set of capabilities
protocols for interacting
attach new devices
computer without rewriting
rewriting the operating
operating system give
give a convenient
uniform i interface
applications we address
address those questions
discuss structuring techniques
techniques and interfaces
system that enable
enable i devices
application can open
disk without knowing
knowing what kind
kind of disk
cmnputer without disruption
complex software-engineering problems
approach here involves
devices by identifying
kinds each kind
kind is accessed
set of functions-an
functions-an the differences
differences are encapsulated
encapsulated in kernel
modules called device
internally are custom-tailored
custom-tailored to specific
standard interfaces figure
kernel are structured
structured in software
layers the purpose
hide the differences
differences among device
system calls encapsulate
encapsulate the behavior
behavior of devices
hide hardware differences
differences from applications
simplifies the job
benefits the hardware
design new devices
existing host controller
host controller interface
write device drivers
drivers to interface
hardware to popular
kernel i structure
structure operating systems
attach new peripherals
computer without waiting
vendor to develop
develop support code
support code unfortm1ately
unfortm1ately for device-hardware
type of operating
device may ship
ship with multiple
multiple device drivers-for
device drivers-for instance
drivers for ms-dos
solaris devices vary
character-stream or block
block a character-stream
character-stream device transfers
device transfers bytes
block device transfers
transfers a block
block of bytes
sequential or random
access a sequential
sequential device transfers
device transfers data
fixed order determined
device can instruct
instruct the device
device to seek
data storage locations
storage locations synchronous
asynchronous a synchronous
synchronous device performs
device performs data
performs data transfers
transfers with predictable
predictable response times
times an asynchronous
asynchronous device exhibits
device exhibits irregular
irregular or unpredictable
unpredictable response times
response times sharable
sharable or dedicated
dedicated a sharable
operation device speeds
device speeds range
perform both input
data transfer direction
transfer direction access
direction access method
access method transfer
method transfer schedule
schedule i direction
synchronous asynchronous dedicated
asynchronous dedicated sharable
dedicated sharable latency
sharable latency seek
seek time transfer
transfer rate delay
delay between operations
read only write
write only read-write
read-write tape keyboard
tape keyboard tape
keyboard tape keyboard
tape keyboard cd-rom
keyboard cd-rom figure
purpose of application
differences are hidden
devices are grouped
types the resulting
styles of device
exact system calls
calls may differ
differ across operating
standard the major
major access conventions
access conventions include
conventions include block
memory-mapped file access
network sockets operating
sockets operating systems
provide special system
calls to access
timer some operating
provide a set
calls for graphical
devices most operating
transparently passes arbitrary
passes arbitrary conunands
driver in unix
call is ioctl
system call enables
application to access
access any functionality
call the ioctl
descriptor that connects
connects the application
driver by referring
hardware device managed
integer that selects
arbitrary data structure
structure in memory
memory that enables
enables the application
application and driver
driver to communicate
information or data
data 13.3.1 block
block and character
devices the captures
accessing disk drives
devices the device
device is expected
expected to understand
block to transfer
applications normally access
capture the essen.tial
behaviors of block-storage
applications are insulated
devices the operating
prefer to access
simple linear array
blocks this mode
unneeded buffering likewise
locking of file
blocks or regions
operating-system locking services
worst to avoid
avoid these conflicts
raw-device access passes
access passes control
letting the operating
operating system step
device a compromise
file that disables
buffering and locking
layered on top
top of block-device
interface provides access
access to disk
bytes in main
call that maps
maps a file
returns the virtual
virtual memory address
file the actual
actual data transfers
transfers are performed
needed to satisfy
transfers are handled
virtual memory access
efficient memory mapping
convenient for programmers-access
simple as reading
writing to memory
memory operating systems
systems that offer
offer virtual memory
interface for kernel
services for instance
maps the executable
executable into memory
executable the mapping
access to swap
space on disk
disk a keyboard
enable an application
character on top
built that offer
offer line-at-a-time access
buffering and editing
types a backspace
character is removed
style of access
access is convenient
convenient for input
modems that produce
data for input
input spontaneously -that
necessarily be predicted
application this access
good for output
printers and audio
fit the concept
bytes 13.3.2 network
13.3.2 network devices
performance and addressing
characteristics of network
network i differ
provide a network
network i interface
disks one interface
socket for electricity
socket interface enable
create a socket
connect a local
plugs this application
application to plug
connection to support
implementation of servers
function called select
manages a set
set of sockets
sockets a call
call to select
sockets have room
room to accept
accept a packet
eliminates the polling
polling and busy
i these functions
encapsulate the essential
behaviors of networks
facilitating the creation
creation of distributed
underlying network hardware
hardware and protocol
approaches to interprocess
communication and network
implemented for instance
network interface card
ground for network
find half-duplex pipes
a.9 13.3.3 clocks
clocks and timers
timers most computers
computers have hardware
timers that provide
provide three basic
give the current
current time give
give the elapsed
elapsed time set
set a timer
timer to trigger
calls that implement
implement these functions
standardized across operating
systems the hardware
hardware to measure
set to wait
generate an interrupt
repeat the process
process to generate
generate periodic interrupts
interrupts the scheduler
mechanism to generate
slice the disk
invoke the periodic
flushing of dirty
dirty cache buffers
buffers to disk
congestion or failures
failures the operating
interface for user
timers the operating
system can support
support more timer
number of timer
timer hardware chan11els
chan11els by simulating
simulating virtual clocks
timer device driver
list of interrupts
sorted in earliest-time-first
order it sets
sets the timer
signals the requester
requester and reloads
reloads the timer
interrupt rate generated
resolution is coarse
computer can execute
hundreds of millions
millions of instructions
precision of triggers
triggers is limited
overhead of maintaining
maintaining virtual clocks
maintain the system
system time-of-day clock
clock can drift
clock is constructed
case the counter
considered a highresolution
offers accurate measurements
intervals 13.3.4 blocking
blocking and nonblocking
system-call interface relates
choice between blocking
i and nonblocking
application is suspended
suspended the application
application is moved
system s run
system call completes
eligible to resume
receive the values
call the physical
physical actions performed
varying or unpredictable
systems use blocking
blocking system calls
blocking application code
code is easier
understand than nonblocking
nonblocking application code
code some user-level
interface that receives
keyboard and mouse
input while processing
processing and displaying
application that reads
decompressing and displaying
displaying the output
writer can overlap
application some threads
threads can perform
perform blocking system
executing the solaris
technique to implement
implement a user-level
library for asynchronous
freeing the application
task some operating
systems provide nonblocking
nonblocking i system
calls a nonblocking
halt the execution
extended time h1.stead
bytes were transferred
transferred an alternative
nonblocking system call
asynchronous system call
call an asynchronous
asynchronous call returns
complete the application
execute its code
code the completion
signal or software
linear control flow
application the difference
difference between nonblocking
nonblocking and asynchronous
asynchronous system calls
data are available-the
available-the full number
requests a transfer
two i methods
methods are shown
call for network
sockets this system
system call takes
takes an argument
argument that specifies
specifies a maximum
application can poll
poll for network
kernel user user
user user kernel
asynchronous without blocking
introduces extra overhead
call only checks
kind of read
command a variation
fotmd in mach
blocking multiple-read call
call it specifies
specifies desired reads
call and returns
completes kernels provide
provide many services
i several services-scheduling
error handlil1.g-are provided
subsystem and build
hardware and devicedriver
responsible for protectil1.g
processes and malicious
scheduling to schedule
schedule a set
i requests means
means to determine
determine a good
applications issue system
scheduling can improve
improve overall system
share device access
fairly among processes
applications issue blocking
issue blocking read
blocking read calls
requests a block
disk the operating
system can reduce
reduce the distance
disk ann travels
travels by serving
serving the applications
rearrangil1.g the order
order of service
i scheduling operating-system
scheduling operating-system developers
operating-system developers implement
developers implement scheduling
scheduling by maintaining
maintaining a wait
queue of requests
issues a blocking
blocking i system
i system call
i scheduler rearranges
rearranges the order
queue to improve
response time experienced
experienced by applications
applications the operating
device-status table system
receives especially poor
give priority service
service for delay-sensitive
virtual memory subsystem
requests several scheduling
algorithms for disk
i are detailed
detailed in section
kernel supports asynchronous
system might attach
attach the wait
manages this table
type of request
i subsystem improves
improves the efficiency
scheduling i operations
space in main
disk via teclul.iques
teclul.iques called buffering
spooling 13.4.2 buffering
area that stores
buffering is done
reasons one reason
data stream suppose
received via modem
modem for storage
disk the modem
buffer is created
created in main
mernory to accumulate
accumulate the bytes
buffer of data
data has arrived
place to store
store additional incoming
additional incoming data
fills the first
write is requested
requested the modem
modem then starts
starts to fill
buffer is written
modem has filled
modem can switch
decouples the producer
producer of data
relaxing timing requirements
decoupling is illustrated
lists the enormous
differences in device
speeds for typical
typical computer hardware
adaptations for devices
sizes such disparities
common in computer
widely for fragmentation
reassembly of messages
message is fragmented
fragmented into small
small network packets
packets the packets
receiving side places
buffer to form
form an image
support copy semantics
semantics for application
clarify the meaning
meaning of copy
copy semantics suppose
wishes to write
write to disk
disk it calls
calls the write
providing a pointer
bytes to write
disk is guaranteed
application system calt
system calt independent
application s buffer
buffer a simple
system can guarantee
guarantee copy semantics
call to copy
copy the application
application i system
system bus hype
pci ~ xpress
lnfi ! l.i
buffer before returning
application the disk
write is performed
copying of data
data between kernel
buffers and application
application data space
space is common
efficiently by clever
virtual memory mapping
mapping and copy-on-write
copy-on-write page protection
protection 13.4.3 caching
region of fast
memory that holds
copies of data
efficient than access
original for instance
process are stored
cached ilc physical
ilc physical memory
cpu s secondary
secondary and primary
caches the difference
buffer may hold
copy on faster
item that resides
resides elsewhere caching
caching and buffering
buffering are distinct
sometinces a region
purposes for illstance
preserve copy semantics
enable efficient scheduling
scheduling of disk
system uses buffers
buffers in maill
memory to hold
hold disk data
data these buffers
efficiency for files
shared by applications
written and reread
receives a file
file i request
kernel first accesses
accesses the buffer
avoided or deferred
writes are accumulated
transfers are gathered
efficient write schedules
schedules this strategy
strategy of delayilcg
writes to improve
efficiency is discussed
context of remote
spooling and device
buffer that holds
accept ilcterleaved data
ilcterleaved data streams
prillter can serve
print their output
operating system solves
problem by intercepting
intercepting all output
printer each application
application s output
output is spooled
separate disk file
application finishes printing
spooling system queues
queues the correspondilcg
correspondilcg spool file
file for output
printer the spooling
spooling system copies
copies the queued
queued spool files
spooling is managed
system daemon process
interface that enables
users and system
administrators to display
display the queue
remove unwanted jobs
printer is serviced
drives and printers
requests of multiple
multiple concurrent applications
concurrent applications spooling
systems can coordinate
coordinate concurrent output
deal with concurrent
concurrent device access
provide explicit facilities
facilities for coordination
coordination some operating
support for exclusive
exclusive device access
access by enabling
process to allocate
allocate an idle
deallocate that device
needed other operating
operating systems enforce
enforce a limit
open file handle
device many operating
systems provide functions
functions that enable
processes to coordinate
coordinate exclusive access
access among thenlselves
thenlselves for instance
calls to wait
call that declares
declares the types
applications to avoid
deadlock 13.4.5 error
13.4.5 error handling
handling an operating
memory can guard
kinds of hardware
hardware and application
complete system failure
minor mechanical glitch
mechanical glitch devices
transfers can fail
network becomes overloaded
controller becomes defective
defective operating systems
effectively for transient
failures for instance
protocol so specifies
important component experiences
experiences a permanent
call will return
return one bit
bit of information
signifying either success
success or failure
additional integer variable
integer variable named
variable named errno
return an error
values-indicating the general
out of range
file not open
provide highly detailed
highly detailed error
detailed error information
current operating systems
designed to convey
convey this information
application for instance
device is reported
levels of detail
key that identifies
identifies the general
states the category
category of failure
bad command parameter
hardware subsystem failed
failed its self-test
scsi devices maintain
devices maintain internal
maintain internal pages
pages of error-log
protection a user
attempt to disrupt
disrupt the normal
systern by attempting
attempting to issue
illegal i instructions
camlot take place
users from performing
issue i instructions
call to request
operating system perform
executing in monitor
request is valid
requested the operating
system then returns
trap to monitor
monitor kernel perform
return to user
user user program
user program figure
call to perform
i port memory
port memory locations
protected from user
memory-protection system note
deny all user
access most graphics
games and video
editing and playback
software need direct
access to memory-mapped
memory-mapped graphics controller
graphics controller memory
speed the performance
provide a locking
section of graphics
representing a window
window on screen
13.4.7 kernel data
structures the kernel
variety of in-kernel
in-kernel data structures
open-file table structure
structure from section
structures to track
track network connections
i activities unix
unix provides file-system
variety of entities
spaces of processes
supports a read
differ for instance
read a user
probe the buffer
cache before deciding
i to read
read a raw
disk sector size
boundary to read
read a process
memory unix encapsulates
encapsulates these differences
teclucique the open-file
pointer to read
pointer to select
pointer to ioctl
ioctl function file
function file descriptor
file descriptor .,_
pointer to close
user-process memory networking
pointer to network
read and write.functions
select function pointer
ioctl function pointer
close f..un ction
kernel memory figure
kernel structure figure
file some operating
systems use object-oriented
extensively for instance
request is converted
change the message
contents for output
written for input
buffer to receive
receive the data
data the message-passing
approach can add
comparison with procedural
shared data structures
simplifies the structure
structure and design
system and adds
flexibility 13.4.8 kernel
i subsystem summary
summary in summary
i subsystem coordinates
coordinates an extensive
collection of services
i subsystenc supervises
supervises these procedures
space for files
devices access control
control to files
devices operation control
file-system space allocation
space allocation device
allocation device allocation
spooling i scheduling
i scheduling device-status
scheduling device-status monitoring
failure recovery device-driver
recovery device-driver configuration
configuration and initialization
initialization the upper
i subsystem access
subsystem access devices
uniform interface provided
described the handshaking
operating system connects
connects an application
set of network
specific disk sector
file from disk
disk the application
file system maps
directories to obtain
obtain the space
table entry tells
tells which disk
file in unix
hardware port address
memory-mapped controller registers
simple operating system
system the first
preceding the colon
string that identifies
specific hardware device
primary hard disk
disk the fact
represents the primary
disk is built
specific port address
device name space
space is separate
space this separation
makes it easy
system to associate
associate extra functionality
easy to invoke
space is incorporated
file-system name services
system provides ownership
ownership and access
devices have owners
owners and access
control since files
stored on devices
two levels names
access the devices
devices unix represents
unix represents device
represents device names
unlike an ms-dos
portion in fact
prefixes of path
names with specific
specific device names
names to resolve
resolve a path
find the longest
longest ncatchilcg prefix
space when unix
file-system directory structures
minor device number
number the m.ajor
m.ajor device number
device number identifies
identifies a device
device the minor
driver to index
device controller modern
controller modern operating
operating systems obtain
systems obtain significant
obtain significant flexibility
stages of lookup
physical device controller
controller the mechanisms
mechanisms that pass
requests between applications
applications and drivers
drivers are general
introduce new devices
devices and drivers
computer without recompiling
kernel in fact
ability to load
load device drivers
drivers on demand
demand at boot
system first probes
describe the typical
typical life cycle
blocking read request
i operation requires
requires a great
great many steps
consume a tremendous
number of cpu
cycles a process
previously the system-call
checks the parameters
parameters for correctness
case of input
irl the buffer
data are returned
performed the process
process is removed
request is scheduled
i subsystem sends
sends the request
device driver depending
message the device
device driver allocates
driver allocates kernel
allocates kernel buffer
kernel buffer space
space to receive
data and schedules
driver sends commands
controller by writing
registers the device
device controller operates
operates the device
hardware to perform
perform the data
transfer the driver
driver may poll
poll for status
status and data
transfer into kernel
memory we assume
transfer is managed
generates an interrupt
completes the correct
correct interrupt handler
interrupt handler receives
receives the interrupt
signals the device
interrupt the device
device driver receives
request has completed
determines the request
request s status
signals the kernel
completed the kernel
kernel transfers data
data or return
process and moves
system call device-controller
call device-controller commands
device-controller commands user
commands user process
user process kernel
subsystem device driver
device driver interrupt
driver interrupt handler
interrupt handler device
handler device controller
device controller return
return from system
system call interrupt
interrupt ~ -------tim_e
moving the process
ready queue unblocks
unblocks the process
assigns the process
process resumes execution
system call unix
call unix system
dynamically a stream
process it consists
controls the device
stream user process
modules _j figure
pair of queues
queues -a read
write queue message
queue message passing
data between queues
queues the streams
structure is shown
provide the functionality
functionality of streams
call for examplef
examplef a process
process can open
open a serial-port
module to handle
handle input editing
editing because messages
messages are exchanged
exchanged between queues
queues in adjacent
module may overflow
overflow an adjacent
queue to prevent
queue may support
support without flow
accepts all messages
module without buffering
queue supporting flow
supporting flow control
flow control buffers
control buffers messages
messages without sufficient
sufficient buffer space
process involves exchanges
exchanges of control
messages between queues
modules a user
user process writes
process writes data
call the write
system call writes
call writes raw
writes raw data
stream head copies
message and delivers
module in line
line this copying
user process reads
process reads data
call if read
queue and returns
returns ordinary data
unstructured byte stream
process if getmsg
message is returned
i is asynchronous
user process communicates
stream ~ head
head when writing
queue uses flow
room to copy
copy the message
block when reading
end-like the stream
head and modules-has
modules-has a read
end must respond
respond to interrupts
frame is ready
unlike the stream
unable to copy
copy a message
queue in line
end must handle
handle all incoming
incoming data drivers
drivers must support
support flow control
device s buffer
buffer is fult
fult the device
device typically resorts
resorts to dropping
dropping incoming messages
card whose input
full the network
drop further messages
ample buffer space
store incoming messages
messages the benefit
modular and incremental
approach to writing
writing device drivers
drivers and network
network protocols modules
ethernet network card
wireless network card
streams allows support
support for message
boundaries and control
information when communicating
communicating between modules
modules most unix
unix variants support
variants support streams
method for writing
protocols and device
unix and solaris
implement the socket
mechanism using streams
factor in system
performance it places
places heavy demands
execute device-driver code
block and unblock
unblock the resulting
resulting context switches
context switches stress
stress the cpu
i also exposes
exposes any inefficiencies
kernel in addition
bus during data
copies between controllers
controllers and physical
copies between kernel
data space coping
architect although modern
computers can handle
handle many thousands
thousands of interrupts
task each interrupt
system to perform
perform a state
execute the interrupt
restore state programmed
efficient than internjpt-driven
number of cycles
spent in busy
completion typically unblocks
unblocks a process
context switch network
switch network traffic
high context-switch rate
character is typed
interrupt is generated
character is passed
process the user
user process issues
issues a network
network i system
call to send
send the character
machine the character
layers that construct
construct a network
network device driver
driver the network
device driver transfers
transfers the packet
sends the character
character and generates
interrupt is passed
network l system
call to complete
system s network
network hardware receives
receives the packet
generated the character
character is unpacked
daemon the network
network daemon identifies
identifies which remote
remote login session
session is involved
involved and passes
passes the packet
switches and state
echoes the character
doubles the work
work to eliminate
eliminate the context
context switches involved
involved in moving
moving each character
character between daemons
solaris developers reimplemented
reimplemented the daemon
daemon using in-kernel
in-kernel threads sun
threads sun estimates
improvement sending system
sending system receiving
system receiving system
receiving system figure
increased the maximum
number of network
server other systems
systems use separate
separate for terminal
i to reduce
reduce the interrupt
cpu for instance
multiplex the traffic
traffic from hundreds
hundreds of remote
special-purpose cpu found
found in mainframes
systems the job
offload i work
cpu the idea
main cpu remains
cpu remains free
free to process
process the data
controllers and dma
dma controllers found
found in smaller
channel can process
process more general
general and sophisticated
employ several principles
principles to improve
number of context
context switches reduce
times that data
copied in memory
memory while passing
passing between device
device and application
reduce the frequency
controllers or channels
channels to offload
offload simple data
simple data copying
cpu move processing
move processing primitives
primitives into hardware
operation in device
concurrent with cpu
cpu and bus
bus operation balance
operation balance cpu
greatly in complexity
complexity for instance
mouse is simple
simple the mouse
movements and button
clicks are converted
converted into numeric
passed from hardware
mouse device driver
application by contrast
windows nt disk
disk device driver
driver is complex
manages individual disks
implements raid arrays
converts an application
application s read
implements sophisticated error-handling
error-handling and data-recovery
algorithms and takes
takes many steps
steps to optimize
optimize disk performance
functionality be implemented
-in the device
observe the progression
experimental i algorithms
code is f1exible
f1exible and application
reboot or reload
reload device drivers
code an application-level
overhead o context
advantage of internal
internal kernel data
device functionality progression
functionality progression kernel
progression kernel functionality
efficient in-kernel messaging
algorithm has demonstrated
demonstrated its worth
complex software system
debugged to avoid
avoid data corruption
corruption and system
crashes the highest
implementation in hardware
controller the disadvantages
hardware implementation include
include the difficulty
difficulty and expense
expense of making
making further improvements
flexibility for instance
hardware raid controller
provide any means
kernel to influence
influence the order
order or location
location of individual
individual block reads
kernel has special
performance the basic
basic hardware elements
hardware elements involved
i are buses
work of moving
data between devices
devices and main
memory is perform.ed
cpu as programmed
controller the kernel
module that controls
controls a device
driver the system-call
provided to applications
applications is designed
handle several basic
categories of hardware
including block devices
programmed interval timers
calls usually block
block the processes
processes that issue
sleep while waiting
complete the kernel
subsystem provides num.erous
handling another service
makes the connections
connections between hardware
applications it involves
involves several levels
levels of mapping
mapping that translate
translate from character-string
specific device drivers
drivers and device
ports or bus
controllers this mapping
mapping may occur
implementation and methodology
protocols through streams
bidirectionally for processing
processing i system
costly in terms
layers of software
application these layers
layers imply overhead
switching to cross
cross the kernel
kernel s protection
signal and interrupt
handling to service
system to copy
including the queueing
queueing and management
management of timer
kernel and applications
i to device
device control registers
interrupt is raised
two separate pieces
pieces the first
first piece executes
completes and schedules
design of interrupt
system use interrupt-driven
manage a single
single serial port
port and polling
i to manage
manage a front-end
kinds of performance
servicing an interrupt
coordinates the activities
kernel i components
components by manipulating
manipulating shared in-kernel
shared in-kernel data
object-oriented message passing
passing between kernel
i components discuss
discuss three pros
user programs access
programs access memory
memory through virtual
system uses raw
raw physical addresses
addresses to access
completion can waste
waste a large
iterates a busy-waiting
loop many times
catching and dispatching
dispatching an interrupt
describe a hybrid
strategy that combines
i device service
describe a computing
multitasking operating system
drive containing user
card with direct
direct bus connection
accessible through memory-mapped
design the operating
i or interrupt-driven
interrupt-driven i give
i give reasons
handshaking in section
implement this handshaking
describe the protocol
bit is insufficient
disadvantages of guaranteeing
guaranteeing reliable transfer
transfer of data
data between modules
dma controllers support
controllers support direct
support direct virtual
direct virtual memory
translation from virtual
address is performed
complicate the design
advantages of providing
providing such functionality
important to scale
scale up system-bus
system-bus and device
speeds as cpu
cpu speed increases
discuss what issues
considered in assigning
describe three circumstances
i and networking
networking in unix
structures and methods
employed in bsd
bsd unix milenkovic
discusses the complexity
methods and implementation
interprocesscommunication and network
protocols in unix
unix are explored
explored in stevens
documents the windows
windows nt application
sample minix operating
minix operating system
described in tanenbaum
tanenbaum and woodhull
includes detailed information
i for details
details of hardware-level
handling and memory-mapping
processor reference manuals
describe multiprocessor systems
systems and cache-consistency
cache-consistency issues tanenbaum
hardware i design
sargent and shoemaker
provide a programmer
programmer s guide
guide to low-level
low-level pc hardware
software the ibm
ibm pc device
device i address
i address map
issue of ieee
computer is devoted
discussion of streams
protection mechanisms control
mechanisms control access
system by limiting
limiting the types
file access permitted
permitted to users
users in addition
protection must ensure
operate on memory
mechanism that controls
controls the access
means of enforcing
enforcing them security
ensures the authentication
authentication of system
users to protect
protect the integrity
system the security
security system prevents
system prevents unauthorized
prevents unauthorized access
alteration of data
chapter the processes
activities to provide
system protection refers
enforcement we distinguish
distinguish between protection
measure of confidence
focus on protection
protection security assurance
discuss the goals
goals and principles
explain how protection
access to examine
capability and language-based
language-based protection systems
systems as computer
sophisticated and pervasive
protect their integrity
adjunct to multiprogramming
multiprogramming operating systems
directory of files
physical name space
memory modern protection
modern protection concepts
concepts have evolved
evolved to increase
increase the reliability
system that makes
prevent the mischievous
program component active
system uses system
consistent with stated
policies this requirement
reliable system protection
system provides means
usage the role
role of protection
policies governing resource
files and programs
programs a protection
flexibility to enforce
enforce a variety
variety of policies
policies for resource
vary by application
longer the concern
system the application
guard resources created
created and supported
subsystem against misuse
mechanisms the operating
system should provide
protection software note
note that mechanisms
mechanisms are distinct
distinct from policies
policies mechanisms determine
done ; policies
done the separation
policy and mechanism
mechanism is important
important for flexibility
change from place
place to place
mechanism using general
general mechanisms enables
principle simplifies design
simplifies design decisions
consistent and easy
easy to understand
understand a key
time-tested guiding principle
principle for protection
dictates that programs
privileges to perform
key will result
result in minimal
passkey allows access
greater an operating
implements its features
failure or compromise
done the overflow
process to fail
execution of code
process s stack
enable a remote
user to gain
gain maximum privileges
privileges and access
calls and services
written with fine-grained
fine-grained access controls
mechanisms to enable
needed also beneficial
creation of audit
privileged function access
access the audit
officer to trace
trace all protection
system managing users
privilege entails creating
back up files
system has access
commands and files
needed to accomplish
accomplish the job
systems implement role-based
implement role-based access
role-based access control
functionality computers implemented
limited to running
running specific services
accessing specific remote
specific remote hosts
hosts via specific
restrictions are implemented
implemented through enabling
enabling or disabling
disabling each service
access control lists
described in sections
secure computing environment
complex protection scheme
holes by comparison
solaris is considered
considered relatively secure
variant of unix
historically was designed
protection in mind
mind one reason
lines of code
services than solaris
secure and protect
protect another reason
scheme in windows
irtcomplete or protects
protects the wrong
leaving other areas
vulnerable a computer
processes and objects
objects by objects
well-defined and meaningful
meaningful operations objects
essentially abstract data
types the operations
execute memory segments
read tape drives
rewound data files
deleted ; program
deleted a process
reqllires to complete
limiting the amount
amount of damage
damage a faulty
process p invokes
formal parameters passed
variables of process
invokes a compiler
compiler to compile
file the compiler
subset of files
accounting or optimization
purposes that process
access the need-to-know
principle is similar
minimize the risks
violations 14.3.1 domain
14.3.1 domain structure
structure to facilitate
facilitate the scheme
access each domain
set of objects
object the ability
execute an operation
collection of access
access right file
executing in domain
share access rights
domains can print
processes in domain
process is fixed
process s lifetime
establishing dynamic protection
dynamic protection domains
complicated than establishing
establishing static protection
static protection domains
association between processes
processes and domains
domains is fixed
change the content
domain the reason
two different phases
phase and write
domain is static
define the domain
domain to include
include both read
principle is violated
domain always reflects
reflects the n1inimum
n1inimum necessary access
association is dynamic
enabling the process
process to switch
effect by creating
content and switching
change the domain
content a domain
user domain switching
domain switching occurs
user is changed
process domain switching
response each procedure
local variables defined
procedure domain switching
discuss domain switching
switching in greater
detail in section
model of operating-system
executes in monitor
execute privileged instructions
gain complete control
system in contrast
executes in user
invoke only nonprivileged
predefined memory space
two modes protect
multiprogrammed operating system
two protection domains
domains are insufficient
needed we illustrate
scheme by examining
examining two influential
two influential operating
influential operating systems-unix
systems-unix and multics
implement these concepts
switching the domain
corresponds to changing
changing the user
user identification temporarily
temporarily this change
change is accomplished
tbough the file
executes that file
user with userid
executing a file
process is set
userid is set
temporary userid change
userid change ends
domains in operating
mechanism this mechanism
general user population
population for instance
access a network
network without letting
letting them write
causing the user
program was run
run the user
user with network
network access privilege
manages to create
file with user
user id root
system the setuid
mechanism is discussed
place privileged programs
directory the operating
designed to change
change the user
equivalent of root
directory this eliminates
eliminates one security
problem with setuid
create and hide
hide such programs
change of user
access to privileged
facilities for instance
started at boot
user id users
users then run
run a separate
facility this method
writing privileged programs
programs any oversight
oversight can result
lack of protection
attacked by people
feature we discuss
domains are organized
structure each ring
rings are numbered
two domain rings
subset of dj
two rings exist
scheme is equivalent
n1ode of execution
monitor mode corresponds
user mode corresponds
segmented address space
rings a segm.ent
segm.ent description includes
entry that identifies
identifies the ring
number in addition
includes three access
bits to control
execution the association
association between segments
segments and rings
identifying the ring
multics ring structure
structure in ring
access a segment
segment domain switching
switching in multics
calling a procedure
process could start
executing in ring
controlled domain switching
modify the ring
descriptor to include
bracket a pair
pair of integers
limit an integer
list of gates
identifies the entry
ring i calls
call is allowed
current ring number
operating system occurs
allowed to occur
parameters are passed
segments not accessible
designated entry points
gates this scheme
scheme allows processes
processes with limited
limited access rights
rights to call
procedures in lower
carefully controlled mmmer
enforce the need-to-know
accessible in domain
multics protection system
generally more complex
systems if protection
complex protection system
university to process
students  grades
students for classwork
classwork a similar
similar protection system
prefer to separate
separate the mechanism
complex or simple
simple protection depending
users to separate
mechanism from policy
model of protection
protection our model
access matrix represent
matrix represent domains
columns represent objects
objects each entry
set of access
column defines objects
omit the object
right the entry
defines the set
invoke on object
illustrate these concepts
access matrix shown
four objects-three files
write onto files
policies the mechanism
consists of implementing
implementing the access
read read write
read write write
write write figure
matrix and ensuring
entries the access
matrix can implement
implement policy decisions
decisions concerning protection
protection the policy
policy decisions involve
involve which rights
decide the domain
executes this last
system the users
users normally decide
decide the contents
creator the user
user may decide
decide to enter
enter some rights
entries in cohum1
needed the access
mechanism for defining
defining and implementing
implementing strict control
static and dynamic
switch a process
executing an operation
control domain switching
switching by including
performing an operation
including the access
execute these operations
switching from domain
access right switch
switch e access
switch to domain
process in domain
switch to d2
d2 allowing controlled
allowing controlled change
access-matrix entries requires
requires three additional
control we examine
examine these operations
read read switch
print switch switch
read switch write
switch write write
matrix of figure
domains as objects
execute read execute
read execute execute
execute execute read
matrix with copy
rights the ability
ability to copy
copy an access
right the copy
right is defined
copy the read
right is copied
copied from access
removed from access
created a process
copy the right
system may select
rights and removal
rights the owner
owner right controls
controls these operations
operations if access
includes the owner
add and remove
remove any right
entry in column
add and delete
delete any valid
right in column
remove any valid
owner write execute
write execute read
execute read read
owner owner write
write execute owner
execute owner read
read owner write
owner write write
matrix with owner
rights the copy
copy and owner
process to change
change the entries
column a mechanism
needed to change
row the control
right is applicable
objects if access
includes the control
remove any access
right from row
include the control
right in access
executil1.g in domain
read switch print
switch print switch
switch switch control
switch control read
control read execute
read execute write
execute write write
write write switch
write switch figure
modified access matrix
owner rights provide
mechanism to limit
limit the propagation
propagation of access
tools for preventing
preventing the propagation
information the problem
problem of guaranteeing
information initially held
object can migrate
illustrate the ability
implementation and control
control of dynamic
dynamic protection requirements
requirements new objects
dynamically and included
basic mechanism exists
exists ; system
designers and users
users must make
make the policy
matrix be implemented
effectively in general
empty although datastructure
representing sparse matrices
describe several methods
methods of implementing
compare the methods
methods 14.5.1 global
14.5.1 global table
table the simplest
global table consisting
set of ordered
ordered triples domain
table is searched
triple is found
operation is allowed
condition is raised
raised this implementation
drawbacks the table
needed virtual memory
managing this table
table in addition
advantage of special
groupings of objects
objects or domains
domain 14.5.2 access
14.5.2 access lists
lists for objects
objects each column
discarded the resulting
consists of ordered
ordered pairs domain
define all domains
object this approach
easily to define
define a list
attempted in domain
search the access
list for object
entry is found
check the default
exception condition occurs
occurs for efficiency
default set first
list 14.5.3 capability
14.5.3 capability lists
lists for domains
associating the columns
objects as access
associate each row
domain a ltst
list of objects
allowed on tbose
objects an object
executes the operation
means that access
allowed the capability
system and accessed
user only indirectly
indirectly capability-based protection
capability-based protection relies
allowed to migrate
space directly accessible
capabilities are secure
object they protect
secure against unauthorized
unauthorized access capabilities
kind of secure
foreseen as multiprogrammed
age the idea
inherently protected pointer
fom1dation for protection
level to provide
provide inherent protection
kinds of objects
higher-level programs run
programs run capabilities
capability or accessible
data the tags
application program hardware
hardware or firmware
enforce this restriction
distinguish between capabilities
hardware can distinguish
part is accessible
program s normal
data and instructions
system a segmented
segmented memory space
approach several capability-based
capability-based protection systems
version of capability-based
14.5.4 a lock-key
compromise between access
lists and capability
lists each object
list of unique
unique bit patterns
domain can access
access an object
key that matches
list of keys
system on behalf
allowed to examine
examine or modify
modify the list
directly 14.5.5 comparison
choosing a technique
implementing an access
access matrix involves
involves various trade-offs
table is simple
domains access lists
access lists correspond
creates an object
domains can access
operations are allowed
determining the set
domain is difficult
difficult in addition
requiring a search
system with long
long access lists
consuming capability lists
process attempting access
access must present
present a capability
capability is valid
revocation of capabilities
lists the mechanism
effective and flexible
keys the keys
freely from domain
domain to domain
domain in addition
technique of changing
combination of access
lists and capabilities
list is searched
searched if access
access is denied
capability is created
created and attached
process additional references
capability to demonstrate
swiftly that access
capability is destroyed
destroyed this strategy
searched to find
permission is checked
information is recorded
process the operation
returns an index
newly opened file
file all operations
file are made
made by specification
table the entry
table then points
table is maintained
carmot accidentally corrupt
user can access
access is checked
protection is ensured
ensured this strategy
system the right
right to access
or1 each access
capability for read
made to write
identifies this protection
violation by com.paring
com.paring the requested
entry in section
described how access
system each file
directory are assigned
assigned an owner
possibly a list
information is assigned
assigned a similar
system a good
found in solaris
advances the protection
sun microsystems operating
microsystems operating system
adding the principle
revolves around privileges
privileges a privilege
right to execute
execute a system
file with write
assigned to processes,limiting
perform their work
privileges and programs
assigned to users
users are assigned
based on passwords
role that enables
enables a privilege
allowing the user
user to run
program to accomplish
accomplish a specific
implementation of privileges
decreases the security
superusers and setuid
setuid programs user1
programs user1 executes
executes with role
privileges ~ figure
control in solaris
facility is similar
access matrix described
dynamic protection system
revoke access rights
rights to objects
users various questions
questions about revocation
revocation may arise
delayed does revocation
delayed if revocation
revocation is delayed
place selective versus
selective versus general
object is revoked
group of users
users whose access
revoked partial versus
partial versus total
object be revoked
revoke all access
object temporary versus
temporary versus permanent
permanent can access
access be revoked
revocation is easy
easy the access
general or selective
total or partial
permanent or temporary
howeve1 ~ present
difficult revocation problem
capabilities are distributed
revoke them schemes
schemes that implement
revocation for capabilities
capabilities are deleted
deleted the process
reacquire the capability
capability if access
back-pointers a list
pointers is maintained
object when revocation
revocation is required
follow these pointers
changing the capabilities
scheme was adopted
implementation is costly
indirection the capabilities
objects each capability
object we implement
revocation by searching
searching the global
entry and deleting
access is attempted
capability is found
found to point
illegal table entry
table entry table
entry table entries
capabilities without difficulty
object the object
entry must match
match this scheme
selective revocation keys
keys a key
unique bit pattern
capability this key
key is defined
modified nor inspected
owns the capability
defined or replaced
capability is exercised
key is compared
raised revocation replaces
replaces the master
invalidating all previous
object this scheme
associate a list
group all keys
table of keys
keys a capability
matches some key
table we implement
revocation by removing
removing the matching
providing maximum flexibility
flexibility in key-based
operations of defining
object to set
set the keys
object this choice
system can implement
survey two capability-based
two capability-based protection
types of policies
provide interesting proving
interesting proving grounds
grounds for protection
capability-based protection system
flexibility the system
implements a fixed
including such basic
forms of access
right to read
execute a memory
segment in addition
declare other rights
rights the interpretation
interpretation of user-defined
rights is performed
user s program
system provides access
rights these facilities
constitute a significant
development in protection
protection technology operations
operations on objects
objects are defined
procedurally the procedures
procedures that implement
implement such operations
form of object
indirectly by capabilities
capabilities the names
names of user-defined
deal with objects
object is made
krtown to hydra
names of operations
type become auxiliary
capability it holds
operation being invoked
rights this restriction
restriction enables discrin
enables discrin lination
lination of access
instance-by-instance and process-by-process
process-by-process basis hydra
type on behalf
process that holds
holds a right
execute the procedure
procedure the rights
procedure are independent
allowed to act
procedures or program
amplification allows implementation
implementation procedures access
holds a capability
capability may include
include an auxiliary
right to invoke
invoke some operation
so-called kernel rights
segment that represents
process a means
means of indirect
invokes the operation
capability for access
amplified as control
access the storage
storage segment representing
implement the operation
type the code
calling process cmmot
cmmot on return
originat unamplified state
state this case
process for access
segment must change
performed the dynamic
adjustment of rights
performed to guarantee
programmer-defined abstraction amplification
amplification of rights
hydra operating system
passes an object
modify the object
implement this restriction
readily by passing
passing an access
amplification may occur
right to modify
circumvented in generat
user may trust
performs its task
correctly this assumption
software errors hydra
errors hydra solves
problem by restricting
amplifications the procedure-call
mechanism of hydra
hydra was designed
mutually suspicious subsystems
subsystems this problem
problem is defined
program is provided
invoke this service
program will malfunction
data or retain
retain some access
som.e private files
calling user program
user program hydra
hydra provides mechanisms
problem a hydra
subsystem is built
components a subsystem
kernel through calls
set of kernel-defined
primitives that define
define access rights
rights to resources
subsystenl the subsystem
designer can define
resources by user
policies are enforceable
standard access protection
access protection afforded
capability system programmers
programmers can make
system after acquainting
reference rnanual hydra
library of system-defined
user programs programmers
explicitly incorporate calls
interfaced to hydra
cambridge cap system
approach to capability-based
cap system cap
cap s capability
system is simpler
superficially less powerful
closer examination shows
provide secure protection
protection of user-defined
user-defined objects cap
kinds of capabilities
capabilities the ordinary
access to objects
individual storage segments
object data capabilities
capabilities are interpreted
interpreted by microcode
kind of capability
programmer as part
kind of rights
procedure when executing
executing the code
process temporarily acquires
acquires the right
rights amplification corresponds
seal and unseal
primitives on capabilities
subject to type
verification to ensure
type are passed
procedure universal trust
machine s microcode
notes for references
capability is left
variety of protection
implemented although programmers
programmers can define
compromised the basic
basic protection system
protected procedure access
insecure protected procedure
procedure has responsibility
system have noted
software capabilities allowed
realize considerable economies
economies in formulating
formulating and implementing
implementing protection policies
protection policies commensurate
requirements of abstract
study a reference
case with hydra
learn the principles
principles and techniques
techniques of protection
library of procedures
degree that protection
provided in existing
existing computer systems
agent to inspect
inspect and validate
validate each attempt
access a protected
resource since comprehensive
comprehensive access validation
source of considerable
give it hardware
support to reduce
reduce the cost
designer to compromise
compromise the goals
goals is difficult
flexibility to implement
implement protection policies
policies is restricted
support mechanisms provided
environments are made
secure greater operational
greater operational efficiency
efficiency as operating
attempted to provide
provide higher-level user
higher-level user interfaces
refined the designers
designers of protection
systems have drawn
heavily on ideas
ideas that originated
originated in programming
concepts of abstract
types and objects
objects protection systems
newest protection systems
set of system-defined
standard file-access methods
subject to change
longer be considered
considered a matter
matter of concern
guarded against tampering
error 14.9.1 compiler-based
14.9.1 compiler-based enforcement
programming languages enter
enter the picture
control of access
system is making
making a declarative
resource this kind
kind of statement
facility when protection
protection is declared
requirements for protection
program is composed
stated this approach
sequence of calls
calls on procedures
operating system protection
system protection requirements
system the means
means for enforcement
subsystem a declarative
notation is natural
natural because access
concept of data
type a variety
implementation to enforce
degree of support
suppose a language
code to run
storage reference made
underlying hardware occurs
capability this restriction
accessing a resource
program may impose
impose arbitrary restrictions
implement such restrictions
readily by usin.g
usin.g the software
software capabilities provided
provided by cap
cap a language
implementation might provide
provide standard protected
standard protected procedures
procedures to interpret
interpret software capabilities
realize the protection
language this scheme
scheme puts policy
puts policy specification
implementing its enforcement
provide a protection
kernel as powerful
hydra or cap
implementing protection specifications
language the principal
system a compiler
compiler can separate
violation could occur
treat them differently
differently the security
merits of enforcement
opposed to enforcement
compiler security enforcement
generation of protectionchecking
rests on correctness
mechanism of storage
management that protects
protects the segments
code is executed
security of files
softwaresupported protection kernel
kernel may reside
reside in fixed
fixed physical storage
physical storage segments
computation is performed
immune to protection
system software malfunction
software malfunction flexibility
kernel in implementing
implementing a user-defined
supply adequate facilities
declared and enforcem.ent
provided as needed
provide sufficient flexibility
extended or replaced
system in service
operating-system kernel efficiency
efficiency the greatest
efficiency is obtained
obtained when enforcement
enforcement of protection
protection is supported
directly by hardware
advantage that static
static access enforcement
off-line at compile
compiler can tailor
tailor the enforcement
mechanism to meet
overhead of kernel
avoided in summary
specification of protection
description of policies
resources a language
implementation can provide
software for protection
enforcement when automatic
automatic hardware-supported checking
checking is unavailable
unavailable in addition
interpret protection specifications
specifications to generate
system is provided
object of computation
privilege of creating
creating or examining
examining these software
capabilities a capability-creating
execute a primitive
seal a data
privilege such components
components might copy
structure or pass
pass its address
contents the reason
reason for introducing
introducing such software
bring a protection
concept as proposed
unseal operations takes
takes a procedural
protection a nonprocedural
nonprocedural or declarative
dynamic access-control mechanism
mechanism for distributing
capabilities to system
resources among user
processes to contribute
efficient this requirement
requirement has led
number of language
programmer to declare
declare various restrictions
specific managed resource
constructs provide mechanisms
efficiently among customer
granted a capability
process may invoke
set of rights
process to enlarge
enlarge its set
give two processes
processes different restrictions
resource the incorporation
incorporation of protection
concepts into programming
tool for system
matter of greater
systems with distributed
increasingly stringent requirements
requirements on data
importance of suitable
suitable language notations
express protection requirements
recognized more widely
widely 14.9.2 protection
protection in java
java because java
java was designed
virtual machine-or jvm-has
jvm-has many built-in
built-in protection mechanisms
protection mechanisms java
mechanisms java programs
programs are composed
collection of data
fields and functions
fields the jvm
loads a class
class in response
request to create
features ofj ava
dynamically loading untrusted
loading untrusted classes
executing mutually distrusting
mutually distrusting classes
capabilities of java
paramount concern classes
concern classes running
process is insufficient
request to open
class has requested
requested the open
open the operating
operating system lacks
lacks this knowledge
decisions are handled
assigns the class
class the protection
class is assigned
class was loaded
signatures are covered
configurable policy file
policy file determines
determines the permissions
file access permissions
jvm to determine
determine what class
class is responsible
request to access
protected resource accesses
allowed to open
open network connections
call a system
library to request
request the load
url the jvm
jvm must decide
open a network
library the philosophy
adopted in java
require the library
permit a network
order to access
sequence that resulted
assert the privilege
privilege to access
resource by doing
method takes responsibility
perform whatever checks
ensure the safety
method is allowed
allowed to assert
assert a privilege
method can assert
allowed to exercise
exercise the privilege
privilege this implementation
executes an access
dopri vileged block
block to perform
perform the access
directly or indirectly
indirectly dopri vileged
passed a class
method to invoke
block is entered
method is annotated
block are executed
method it calls
call to checkpermissions
invoke stack inspection
inspection to determine
allowed the inspection
inspection examines stack
examines stack frames
thread s stack
recently added frame
frame and working
frame is first
allowing the access
access is disallowed
method s class
throws an accesscontrolexception
stack inspection exhausts
exhausts the stack
stack without finding
finding either type
type of frame
implementations may disallow
inspection is illustrated
untrusted applet protection
applet protection domain
protection domain performs
performs two operations
url loader protection
loader protection domain
permitted to open
sessions to sites
lucent com domain
proxy server proxy
server proxy .lucent
invocation will succeed
networking library encounters
encounters the stack
performed its open
applet s open
invocation will result
finds no dopri
dopri vileged annotation
annotation before encountering
encountering the stack
inspection to work
unable to modify
modify the annotations
manipulations of stack
differences between java
directly access memory
manipulations are made
well-defined interfaces compliance
compliance is enforced
collection of load-time
load-time and run-time
manipulate its run-time
java s load-time
run-time checks enforce
enforce of java
java classes type
classes type safety
type safety ensures
ensures that classes
integers as pointers
past the end
memory in arbitrary
program can access
f01mdation of java
enables a class
protect its data
data and methods
defined as private
package type safety
enforced computer systems
protected from misuse
right is permission
permission to perform
object a domain
access rights processes
rights processes execute
execute in domains
domain to access
domain or allowed
allowed to switch
mechanisnc for protection
protection without imposing
users the separation
important design property
property the access
matrix is sparse
include dynamic protection
dynamic protection model
capability list real
list real systems
model and tend
tend to provide
unix is representative
structure in addition
addition to file
file access hydra
mach are capability
systems that extend
protection to user-defined
user-defined software objects
software objects solaris
implements the principle
privilege via role-based
role-based access controt
controt a form
access matrix language-based
matrix language-based protection
protection provides finer-grained
arbitration of requests
requests and privileges
single java jvm
jvm can run
run several threads
class it enforces
enforces the resource
requests through sophisticated
sophisticated stack inspection
played by students
computer center staff
scheme for implementing
implementing this policy
defined a tree
assume the set
rights is represented
defines the access
rights of process
xis a descendant
role-based access-control facility
access-control facility similar
amplification in hydra
hydra provides greater
scheme in enforcing
enforcing protection policies
scheme in multics
implement the system
typical operating system
system and store
higher-numbered ring invokes
procedure in ring
discuss the strengths
weaknesses of implementing
matrix using capabilities
matrix using access
process can switch
enjoy the access
privileges of domain
equivalent to including
implement the principle
failures that lead
lead to security
creation of protection
object are deleted
longer be accessed
point the object
space it occupies
suggest an efficient
systems allow module
designers to enforce
multics ring-protection scheme
scheme b hydra
hydra s capabilities
capabilities c jvm
jvm s stack-inspection
process with number
object with number
type of protection
system to adhere
efficient capability manipulation
java protection model
program were allowed
alter the annotations
burroughs b7000 mcp
b7000 mcp file
tagged as sensitive
area is overwritten
protection between domains
domains and objects
objects was developed
developed by lampson
saltzer and schroeder
provided excellent surveys
subject of protection
model to enable
protection system mathematically
mathematically the concept
evolved from iliffe
jodeit s codewords
rice university computer
iliffe and jodeit
capability was introduced
introduced by dennis
dennis and horn
system was described
described by wulf
described by needham
needham and walker
discussed the multics
multics ring-protection system
ring-protection system revocation
revocation was discussed
discussed by redell
redell and fabry
cohen and jefferson
ekanadham and bernstein
principle of separation
mechanism was advocated
designer of hydra
examined by lipner
control was suggested
first by morris
unseal operations discussed
kieburtz and silberschatz
mcgraw and andrews
proposed various language
constructs for dealing
dealing with general
general dynamic-resource-management schemes
dynamic-resource-management schemes jones
jones and liskov
static access-control scheme
language that supports
supports abstract data
minimal operating-system support
support to enforce
protection was advocated
strictly an internal
access to programs
adequate protection system
operates a protection
system is ineffective
ineffective if user
authentication is compromised
unauthorized user computer
user computer resources
guarded against unauthorized
inconsistency these resources
resources include information
include information stored
start by examining
explore a key
key security enabler
security enabler -cryptography
mechanisms to guard
attacks to discuss
discuss security threats
threats and attacks
attacks to explain
explain the fundamentals
fundamentals of encryption
hashing to examine
cryptography in computing
computing to describe
describe various countermeasures
countermeasures to security
ensuring the security
system is worth
worth considerable effort
considerable effort large
effort large commercial
large commercial systems
systems containing payroll
data are inviting
targets to thieves
pertaining to corporate
interest to unscrupulous
accident or fraud
impair the ability
corporation to function
function in chapter
data these mechanisms
accessed as intended
circumstances unfortunately total
mechanisms to make
make security breaches
breaches a rare
norm security violations
categorized as intentional
easier to protect
protect against accidental
part protection mechanisms
core of protection
protection from accidents
includes several forms
forms of accidental
accidental and malicious
malicious security violations
discussion of security
intruder and cracker
attempting to breach
security in addition
attempt to break
break security breach
breach of confidentiality
confidentiality this type
type of violation
violation involves 1mauthorized
involves 1mauthorized reading
reading of data
theft of information
intruder capturing secret
capturing secret data
information or identity
information for identity
directly in money
breach of integrity
integrity this violation
violation involves unauthorized
involves unauthorized modification
modification of data
data such attacks
result in passing
passing of liability
party or modification
important commercial application
commercial application breach
breach of availability
availability this violation
involves unauthorized destruction
destruction of data
data some crackers
havoc and gain
status or bragging
rights than gain
gain financially web-site
financially web-site defacement
type of security
security breach theft
service this violation
install a daemon
system that acts
file server denial
denial of service
violation involves preventing
involves preventing legitimate
system or attacks
accidental the original
original internet worm
internet worm turned
failed to delay
delay its rapid
spread we discuss
discuss dos attacks
section 15.3.3 attackers
attempts to breach
breach the correctness
correctness of identification
allowed or escalate
escalate their privileges-obtain
entitled another common
replay a captured
exchange of data
data a consists
malicious or fraudulent
valid data transmission
comprises the entire
normal attacker masquerading
attacker masquerading attacker
masquerading attacker man-in-the-middle
attacker man-in-the-middle attacker
man-in-the-middle attacker figure
standard security attacks
attacks the damage
request for authentication
user s information
kind of attack
active communication session
session is intercepted
intercepted several attack
methods are depicted
system from malicious
made sufficiently high
high to deter
deter most intruders
preferable to prevent
prevent the attack
attack but sufficient
sufficient to detect
detect the attack
protect a system
physical the site
site or sites
secured against armed
armed or surreptitious
entry by intruders
terminals or workstations
carefully to assure
system even authorized
tricked into allowing
allowing one type
type of social-engineering
e-mail or web
web page misleads
misleads a user
user into entering
entering confidential information
information another teclucique
teclucique is human
authorization appropriate users
term for attempting
information in order
order to gain
gain unauthorized access
finding phone books
notes containing passwords
problems are management
management and personnel
pertaining to operating
systems operating system
system must protect
accidental or purposeful
purposeful security breaches
breaches a runaway
process could constitute
constitute an accidental
accidental denial-of-service attack
attack a query
service could reveal
passwords a stack
unauthorized process list
network much computer
data in modern
modern systems travels
travels over private
private leased lines
dial-up lines intercepting
intercepting these data
harmful as breaking
communications could constitute
constitute a remote
remote denial-of-service attack
first two levels
inaintained if operating-system
ensured a weakness
circumvention of strict
link is true
true of system
countermeasures are created
created and deployed
attacks for incidents
section tools needed
needed to block
ranging from passwords
passwords for authentication
authentication through guarding
guarding against viruses
viruses to detecting
intrusions we start
exploration of security
security threats processes
means of accomplishing
program that creates
creates a breach
breach of security
causing a normal
change its behavior
behavior and create
create a breach
goal of crackers
crackers in fact
nonprogram security events
causing a program
exploit is blocked
describe common methods
methods which programs
programs cause security
security breaches note
conventions of security
common or descriptive
terms 15.2.1 horse
15.2.1 horse systems
systems have mechanisms
mechanisms for allowing
allowing programs written
written by users
users may misuse
misuse these rights
rights a text-editor
code to search
search the file
edited for certairl
special area accessible
editor a code
segment that misuses
misuses its environment
long search paths
common on unix
exacerbate the trojanhorse
trojanhorse the search
search path lists
lists the set
set of directories
file is executed
include the current
search has set
set her current
friend s directory
normal system commanct
commanct be executed
user is allowed
user s instance
modern windows operating
systems another variation
horse is spyware
spyware sometimes accompanies
accompanies a program
user has chosen
chosen to install
freeware or shareware
included with commercial
software the goal
goal of spyware
ads to display
user s system
sites are visited
system and return
category of attacks
surreptitious communication occurs
system could result
daemon the spyware
spyware could contact
contact a central
list of recipient
deliver the spam
machine this process
discovers the spyware
percent of spam
method this theft
considered a crime
countries ! spyware
install network daemons
daemons such daemons
daemons are installed
two mistakes first
user may run
case of human
human error-a common
error-a common security
common security weakness
default more privileges
case of poor
poor operating-system design
decisions an operating
software in general
access and security
easy to manage
manage and understand
inconvenient or inadequate
inadequate security measures
measures are bound
designed to implement
implement 15.2.2 trap
15.2.2 trap door
door the designer
program or system
system might leave
leave a hole
movie war games
games for instance
code inight check
check a specific
circumvent normal security
normal security procedures
security procedures programmers
arrested for embezzling
embezzling from banks
banks by including
including rounding errors
occasional half-cent credited
accounts this account
credititrg can add
amount of money
number of transactions
large bank executes
executes a clever
clever trap door
compiler the compiler
compiler could generate
generate standard object
standard object code
code being compiled
compiled this activity
reveal any problems
information trap doors
trap doors pose
pose a difficult
systems may consist
millions of lines
15.2.3 logic bomb
program that initiates
initiates a security
hard to detect
set of parameters
parameters were met
created this scenario
code to detect
site 15.2.4 stack
stack and buffer
overflow the stack
stack or buffer-overflow
network or dial-up
system an authorized
exploit for privilege
exploits a bug
program the bug
neglected to code
code bounds checking
sends more data
program was expecting
trial and error
examining the source
determines the vulnerability
vulnerability and writes
writes a program
overflow an input
daemon-wl.til it writes
overwrite the current
current return address
exploit code loaded
loaded in step
write a simple
set of code
stack that includes
includes the commands
wishes to execute-for
spawn a shell
shell the result
program s execution
privileged command execution
execution for instance
web-page form expects
expects a user
attacker could send
send the user
characters to overflow
overflow the buffer
buffer and reach
reach the stack
address to load
code the attacker
buffer-reading subroutine returns
returns from execution
code is run
simple c program
program in fig1-1re
creates a character
character array size
array size buffer_size
buffer_size and copies
byte to store
store the null
program works properly
line is longer
longer than buffer_size
function will begin
copying from argv
encounters a null
copied data overflow
stdio.h # define
program with buffer-overflow
buffer-overflow condition note
performed bounds checking
size of argv
replacing the line
good bounds checking
lack of bounds
compromise the integrity
function is invoked
typical computer architecture
exits are stored
frame the layout
typical stack frame
frame is shown
examining the stack
frame from top
automatic variables declared
bottom ~ frame
frame pointer grows
pointer grows top
grows top figure
exits the frame
pointer can vary
saved frame pointer
pointer allows relative
access to parameters
parameters and automatic
cracker could execute
execute a bufferoverflow
replace the return
program the programmer
programmer first writes
writes a short
short code segment
bin \ sh
code segment creates
creates a shell
program being attacked
runs with system-wide
newly created shell
shell will gain
gain complete access
process this code
assembly language instructions
modified the primary
remove unnecessary features
reducing the code
frame this assembled
assembled code fragment
stack frame appears
appears as shown
programmer then finds
finds the copied
hypothetical stack frame
frame for figure
address of buffer
stack that address
attacker wants executed
executed the binary
sequence is appended
amount of no-op
fill the stack
location of buffer
added the attack
attack is complete
constructed binary sequence
sequence as input
process then copies
copies the binary
sequence from argv
returns from main
modified shell code
process ! figure
ways to exploit
exploit potential buffer-overflow
potential buffer-overflow problems
considered the possibility
attackedthe code shown
15.2-ran with system-wide
segment that runs
modified might perform
perform any type
type of malicious
opening network ports
buffer-overflow attack reveals
reveals that considerable
knowledge and programming
skill are needed
needed to recognize
recognize exploitable code
programmers to launch
launch security attacks
cracker can determine
determine the bug
write an exploit
rudimentary computer skills
skills and access
launch the attack
attack at target
systems the buffer-overflow
run between systems
travel over allowed
allowed communication channels
channels such attacks
attacks can occur
occur within protocols
detect and prevent
bypass the security
added by firewalls
feature that disallows
memory recent versions
versions of sun
sun s sparc
sparc chip include
include this setting
code there attempts
attempts to execute
exception is generated
program is halted
error recent versions
versions of amd
amd and intel
intel x86 chips
x86 chips include
feature to prevent
prevent this type
type of attack
feature is supported
x86 operating systems
windows xp sp2
sp2 the hardware
hardware implementation involves
cpus this bit
page as nonexecutable
feature becomes prevalent
diminish 15.2.5 viruses
viruses another form
form of program
fragment of code
legitimate program viruses
viruses are self-replicating
designed to infect
infect other programs
system by modifying
modifying or destroying
files and causing
causing system crashes
crashes and program
specific to architectures
problem for users
multiuser operating systems
susceptible to viruses
programs are protected
protected from writing
virus does infect
system are protected
borne via e-mail
spread when users
users download viral
download viral programs
viral programs internet
programs internet file-sharing
internet file-sharing services
services or exchange
exchange infected disks
disks another common
form of virus
transmission uses microsoft
microsoft office files
microsoft word documents
documents these documents
macros visual basic
visual basic programs
office suite powerpoint
macros can run
run largely unconstrained
deleting user files
user s contact
sample that shows
shows the simplicity
simplicity of writing
writing a visual
visual basic macro
format the hard
macro was opened
dim ofs set
ofs set ofs
ofs = createobject
reaches a target
inserts the virus
system the virus
reasons but installing
installing the virus
activity once installed
number of things
thousands of viruses
main categories note
file a standard
standard file virus
file virus infects
infects a system
system by appending
noticed file viruses
leave no full
leave the host
program still functional
boot virus infects
infects the boot
system is booted
system is loaded
loaded it watches
boot virus works
virus works macro
macro most viruses
viruses are written
basic these viruses
viruses are triggered
executing the macro
macro is run
spreadsheet file source
file source code
code a source
source code virus
code and modifies
include the virus
spread the virus
boot-sector computer virus
computer virus polymorphic
polymorphic a polymorphic
installed to avoid
detection by antivirus
affect the virus
virus s functionality
change the virus
virus s signature
identify a virus
typically a series
virus code encrypted
encrypted an encrypted
encrypted virus includes
virus includes decryption
includes decryption code
detection the virus
virus first decrypts
stealth this tricky
tricky virus attempts
detection by modifying
modify the read
read system call
modified is read
code is returned
infected code tunneling
tunneling this virus
attempts to bypass
anti virus scanner
scanner by installing
interrupt-handler chain similar
chain similar viruses
similar viruses install
multipartite a virus
infect nmltiple parts
including boot sectors
files this makes
armored an armored
virus is coded
coded to ncake
hard for antivirus
researchers to unravel
unravel and understand
compressed to avoid
detection and disinfection
disinfection in addition
hidden via file
attributes or unviewable
unviewable file names
names this vast
variety of viruses
grow in fact
virus was detected
detected it exploited
exploited three separate
operation this virus
started by infecting
hundreds of windows
including many trusted
running microsoft internet
microsoft internet information
internet information server
vulnerable microsoft explorer
microsoft explorer web
explorer web browser
web browser visiting
visiting those sites
received a browser
download the browser
browser virus installed
installed several back-door
records all things
including and credit-card
installed a daemon
unlimited remote access
allowed an intruder
intruder to route
infected desktop computer
disruptive security attacks
spread the active
increasing the threat
caused by security
intrusions this monoculture
monoculture supposedly consists
consists of microsoft
monoculture even exists
exists today program
today program threats
system to attack
programs in contrast
network threats involve
involve the abuse
abuse of services
services and network
network comcections system
network threats create
create a situation
resources and user
files are inisused
launch a program
operating system is-the
is-the more services
functions it allows-the
operating systems strive
enabled by default
system was installed
services are disabled
disabled at installation
specifically be enabled
enabled system administrators
reduce the system
system s set
set of ways
discuss some examples
examples of system
note that masquerading
masquerading and replay
launched over netvvorks
netvvorks between systems
systems in fact
effective and harder
harder to counter
counter when multiple
systems are involved
determine the sender
sender and receiver
change when multiple
controlled by attackers
difficult in general
keys to encryption
required for authentication
authentication and encryption
secrets is easier
easier in environments
secure sharing methods
sharing methods exist
exist these methods
methods include shared
include shared memory
memory and interprocess
interprocess comnmnications creating
comnmnications creating secure
creating secure communication
communication and authentication
authentication is discussed
discussed in sections
mechanism to ravage
ravage system performance
performance the worm
worm spawns copies
processes on computer
causing the loss
loss of system
system and system-administrator
system-administrator time worth
millions of dollars
workday on november
robert tappan morris
first-year cornell graduate
cornell graduate student
unleashed a worm
internet targeting sun
targeting sun microsystems
microsystems  sun
workstations and vax
vax computers running
computers running variants
variants of version
worm quickly spread
spread over great
consumed system resources
point of bringing
machines although robert
robert morris designed
designed the self-replicating
program for rapid
reproduction and distribution
unix networking environment
networking environment provided
provided the means
means to propagate
propagate the worm
chose for in.itial
infection an internet
internet host left
host left open
worm program exploited
program exploited flaws
system s security
advantage of unix
utilities that simplify
simplify resource sharing
sharing in local-area
networks to gain
access to thousands
connected sites morris
morris s methods
methods of attack
attack are outlined
worm was made
main program ll.c
grappling hook consisted
compiled and run
machine it accessed
accessed once established
system under attack
grappling hook connected
originated and uploaded
uploaded a copy
main program proceeded
proceeded to search
newly infected system
system could connect
exploited the unix
unix networking utility
networking utility rsh
rsh for easy
easy remote task
remote task execution
execution by setting
setting up special
files that list
host-login name pairs
users can omit
entering a password
access a remote
list the worm
searched these special
files for site
rsh attack finger
attack finger attack
finger attack sendmail
attack sendmail attack
sendmail attack worm
worm sent target
target system infected
system infected system
infected system figure
morris internet worm
password where remote
shells were established
program was uploaded
uploaded and began
began executing anew
anew the attack
attack via remote
infection methods built
two methods involved
methods involved operating-system
involved operating-system bugs
finger and sendmail
programs the finger
finger utility functions
electronic telephone directory
command finger user-name
finger user-name hostname
user-name hostname returns
returns a person
person s real
real and login
office and home
address and telephone
clever quotation finger
quotation finger runs
site and responds
responds to queries
internet the worm
executed a buffer-overflow
attack on finger
finger the program
program queried finger
536-byte string crafted
crafted to exceed
exceed the buffer
allocated for input
overwrite the stack
resided before morris
morris s calt
calt the finger
daemon was routed
invading 536-byte string
string now residing
gave the worm
worm a remote
machine under attack
attack the bug
exploited in sendmail
sendmail also involved
process for malicious
malicious entry sendmail
entry sendmail sends
routes electronic mail
electronic mail debugging
mail debugging code
utility permits testers
testers to verify
verify and display
system the debugging
left on morris
arsenal a call
call to debug
debug that -instead
normal in testing-issued
testing-issued a set
set of cornmands
cornmands that mailed
mailed and executed
executed a copy
worm systematically attempted
discover user passwords
passwords it began
password or passwords
constructed of account-user-name
favorite password choices
standard unix on-line
unix on-line dictionary
password this elaborate
elaborate and efficient
efficient three-stage password-cracking
three-stage password-cracking algorithm
password-cracking algorithm enabled
enabled the worm
worm to gain
system the wontt
wontt then searched
searched for rsh
rsh data files
newly broken accounts
previously to gain
access to user
accounts on remote
worm program searched
remained undetected allowing
allowing every seventh
duplicate to proceed
possibly to confound
efforts to stop
stop its spread
baiting with fake
created a wholesale
infestation of sun
sun and vax
unix network environment
environment that assisted
worm s propagation
propagation also helped
helped to stop
stop its advance
ease of electronic
mechanisms to copy
files to remote
code and human
human expertise allowed
expertise allowed cooperative
allowed cooperative efforts
efforts to develop
develop solutions quickly
methods of halting
halting the invading
program were circulated
circulated to system
internet within days
specific software patches
exploited security flaws
unleash the worm
worm the action
prank gone awry
criminal offense based
worm s release
spread was unintentional
unintentional the worm
program took elaborate
steps to cover
cover its tracks
contained no code
aimed at damaging
damaging or destroying
destroying the systems
ran the author
expertise to include
include such commands
structures were present
trojan-horse or virus
programs the behavior
program may lead
lead to interesting
provide a sound
basis for inferring
open to speculation
federal court convicted
court convicted morris
morris and handed
years  probation
hours of community
10,000 fine morris
morris s legal
costs probably exceeded
100,000 security experts
security experts continue
continue to evaluate
methods to decrease
decrease or eliminate
shows that worms
fact of life
occurred during august
released by persons
fastest-spreading worm released
released to date
peak mfecting hundreds
thousands of computers
seventeen e-mail messages
internet it clogged
clogged e-mail inboxes
number of hours
hours to clean
clean up sobig.f
sobig.f was launched
stolen credit card
photo the virus
virus targeted microsoft
targeted microsoft windows
engine to e-mail
variety of subject
making it difficult
message which machine
infected source sobig.f
source sobig.f included
included an attachment
target e-mail reader
reader to click
variety of names
payload was executed
stored a program
program called winppr32.exe
default windows directory
modified the windows
registry the code
attempt to connect
servers and download
download and execute
servers were disabled
downloaded the content
code was malevolent
number of machines
resulted 15.3.2 port
15.3.2 port scanning
port scanning port
scanning port scanning
cracker to detect
detect a system
system s vulnerabilities
vulnerabilities to attack
attack port scanning
typically is automated
involving a tool
tool that attempts
create a tcp
tcp lip connection
range of ports
sendmail a cracker
cracker could launch
launch a port
connection was successful
attempt to communicate
bug now imagine
imagine a tool
operath g system
system was encoded
encoded the tool
tool could attempt
service that answered
allowing the creation
privileged command shell
cracker could install
install trojan horses
tools that perform
database of bugs
scan a range
determine the services
attempt to attack
bugs it generates
perform the final
step of exploiting
exploiting the found
scans are detectable
frequently are launched
serving their owners
including denial-of-service attacks
attacks and spam
spam relay zombies
relay zombies make
zombies make crackers
crackers particularly difficult
difficult to prosecute
prosecute because determining
determining the source
person that launched
reasons for securing
securing inconsequential systems
systems containing valuable
information or services
service as mentioned
attacks are aimed
information or stealing
system or facility
attacks involve systems
launching an attack
attack that prevents
easier than breaking
machine or facility
facility denial-of-service attacks
generally network based
based they fall
two categories attacks
click could download
download a java
applet that proceeds
pop up windows
category involves disrupting
disrupting the network
successful denial-of-service attacks
kind against major
major web sites
sites these attacks
result from abuse
functionality of tcp
lip for instance
sends the part
start a tcp
standard the connection
partially started tcp
started tcp sessions
sessions are launched
legitimate tcp connections
connections such attacks
hours or days
partial or full
failure of attempts
facility the attacks
updated to reduce
reduce their vulnerability
impossible to prevent
prevent denial-of-service attacks
attacks the attacks
mechanisms as normal
difficult to prevent
prevent and resolve
attacks are launched
launched from multiple
typically by zombies
zombies ddos attacks
attempts a site
offer to halt
halt the attack
attack in exchange
exchange for money
surge in system
successful advertising campaign
greatly increases traffic
considered a ddos
aspects of dos
authentication algorithm locks
locks an account
access the account
purposely making incorrect
making incorrect attempts
access all accounts
blocks certain kinds
kinds of traffic
induced to block
block that traffic
suggest that programmers
programmers and systems
computer science classes
classes are notorious
sources of accidental
accidental system dos
system dos attacks
first programming exercises
learn to create
subprocesses or threads
threads a common
common bug involves
bug involves spawning
involves spawning subprocesses
spawning subprocesses infinitely
infinitely the system
system s free
memory and cpu
stand a chance
defenses against computer
running the gamut
gamut from methodology
methodology to technology
technology the broadest
users is cryptography
discuss the details
details of cryptography
sender and recipient
recipient of ali
ali interprocess communication
controls all communication
network of computers
networked computer receives
computer receives bits
determining what machine
machine or application
computer sends bits
infer the potential
receivers of network
network messages network
messages network packets
network packets arrive
names the intended
applications where security
packet reliably determines
received that packet
packet a rogue
computer can send
falsified source address
receive a packet
destination will receive
receive the packet
grant a request
trust the named
supposed to provide
request or data
receive the response
response or message
contents it sends
generally considered infeasible
infeasible to build
build a network
addresses of packets
trust the network
job of cryptography
constrain the potential
and or receivers
cryptography is based
based on secrets
distributed to computers
process messages cryptography
messages cryptography enables
enables a recipient
message to verify
message was created
sender can encode
encode its message
key can decode
decode the message
destination unlike network
unlike network addresses
keys are designed
feasible to derive
means of constraining
receivers of messages
note that cryptography
field of study
large and small
complexities and subtleties
parts of cryptography
cryptography that pertain
pertain to operating
systems 15.4.1 encryption
solves a wide
variety of communication
communication security problems
aspects of modern
modern computing encryption
encryption a means
means for constraining
message an encryption
encryption algorithm enables
enables the sender
message to ensure
key can read
read the message
encryption of messages
back to ancient
describe important modern
important modern encryption
modern encryption principles
principles and algorithms
two users communicating
trusted third party
15.4.1.4 an encryption
encryption algorithm consists
keys a set
messages a set
ciphertexts a function
function for generating
ciphertexts from messages
efficiently computable functions
functions a function
messages from ciphertexts
functions an encryption
algorithm must provide
provide this essential
computer can compute
write ----1 rnessage
message ml figure
i5.7 a secure
computer not holding
ciphertexts since ciphertexts
infeasible to derive
two main types
types of encryption
asymmetric we discuss
discuss both types
sections 15.4.1.1 symmetric
15.4.1.1 symmetric encryption
past several decades
commonly used symmetric
symmetric encryption algorithm
states for civilian
institute of stantechxwlogy
works by taking
taking a 64-bit
key and performing
performing a series
series of transformations
transformations these transformations
transformations are based
based on substitution
substitution and permutation
generally the case
case for symmetric
symmetric encryption transformations
algorithms are hidden
hidden in fact
s-boxes are classified
united states government
states government messages
government messages longer
bits are broken
broken into 64-bit
chunks because des
chunk of bits
encrypting an extended
anwunt of data
vulnerable to attack
block would result
key and encryption
block before encryption
searched with moderate
moderate computing resources
created a modification
algorithm is repeated
repeated three times
effective key length
bits triple des
widespread use today
replace des aes
symmetric block cipher
bits and works
works on 128-bit
blocks it works
works by performing
rounds of transformations
algorithm is compact
compact and efficient
symmetric block encryption
block encryption algorithms
today bear mentioning
mentioning the algorithm
algorithm is fast
variable key length
blocks can vary
vary in key
number of transformations
basic computational operations
variety of crus
common stream cipher
designed to encrypt
encrypt and decrypt
decrypt a stream
bytes or bits
communication would make
make a block
cipher too slow
slow the key
key is input
algorithm that attempts
attempts to produce
produce random bits
bits the output
generator when fed
fed a key
set of keys
input plaintext stream
plaintext stream rc4
steams of data
wireless lan protocol
communications between web
browsers and web
amount of con1.puter
vulnerabilities 15.4.1.2 asymmetric
15.4.1.2 asymmetric encryption
encryption and decryption
block-cipher public-key algorithm
widely used asymmetrical
asymmetrical algorithm asymmetrical
algorithm asymmetrical algorithms
asymmetrical algorithms based
based on elliptical
curves are gaining
amount of cryptographic
write i messlge
read ~ figure
decryption using rsa
rsa asymmetric cryptography
randomly chosen prime
chosen prime numbers
icc satisfies leekd
satisfies leekd mod
values is shown
encrypting the message
public key results
asymmetric encryption begins
destination for bidirectional
publish its public
public key publication
simple as handing
complex the private
holding that key
key can decrypt
decrypt any message
matching public key
seemingly small difference
difference in key
asymmetric and symmetric
large in practice
practice asymmetric cryptography
based on mathematical
expensive to execute
computer to encode
encode and decode
usual symmetric algorithms
algorithm in truth
encryption of large
encryption of small
sections 15.4.1.3 authentication
constraining the set
set of potential
complementary to encryption
encryption in fact
prove the identity
produces a valid
message must hold
hold ke authentication
sort of authentication
authentication is similar
distinct from user
discuss in section
authentication algorithm consists
authenticators a functions
authenticators from messages
messages both sand
function for verifying
authenticators on messages
functions the critical
algorithm must possess
computer can generate
generate an authenticator
two main varieties
varieties of authentication
algorithms the first
first in understanding
understanding these algorithms
explore hash functions
creates a small
message m hash
hash functions work
work by taking
taking a message
message in n-bit
blocks and processing
processing the blocks
blocks to produce
produce an n-bit
resistant on m-that
infeasible to find
modified common message-digest
common message-digest functions
message-digest functions include
include which produces
produces a 128-bit
outputs a 160-bit
160-bit hash message
hash message digests
detecting changed messages
authentication algorithm takes
takes the message
digest and encrypts
first main type
type of authentication
algorithm uses symmetric
checksum is generated
generated from message
secret key knowledge
secret a simple
cam10t be derived
message could create
mac a suitable
suitable verification algorithm
needed to compute
authenticators thus produced
computationally to derive
vis a one-way
key and lc5
rsa digital-signature algorithm
rsa encryption algorithm
reversed the digital
message is derived
derived by computing
encryption can prove
separate authentication algorithms
primary reasons authentication
reasons authentication algorithms
algorithms generally require
generally require fewer
require fewer computations
exception of h.sa
h.sa digital signatures
amounts of plaintext
efficiency can make
make a huge
difference in resource
needed to authenticate
authenticate a message
message the authenticator
ciphertext this improves
transmission time efficiency
company could provide
provide a software
sign that patch
patch to prove
nt been modified
aspects of security
performed an action
action a typical
involves the filling
out of electronic
signing of paper
paper contracts nonrepudiation
contracts nonrepudiation assures
out an electronic
15.4.1.4 key distribution
battle between cryptographers
keys with symmetric
performed cut-or-band -say
conversation these methods
key-management challenge suppose
suppose a user
wanted to communicate
privately that user
change those keys
reasons for efforts
efforts to create
create asymmetric key
asymmetric key algorithms
keys be exchanged
exchanged in public
matter of managing
managing a public
distribution of public
public keys requires
requires some care
man-in-the-middle attack shown
receive an encrypted
encrypted message sends
out his public
attacker also sends
sends her bad
bad public key
matches her private
send the encrypted
key to encrypt
encrypt the message
message the attacker
owns a public
solve that problem
key digitally signed
party the trusted
trusted party receives
proof of identification
encryption __ key
__ key kbad
key kbad attacker
kbad attacker decryption
attacker decryption key
key kd __
decryption ... key
... key kbad
key kbad .,......_read
attack on asymmetric
cryptography and certifies
trust the certifier
public keys i.j.l.cluded
i.j.l.cluded within web
consumers of certificates
distributed the certificate
signing the public
creating a web
web of trust
trust the certificates
standard x.509 digital
x.509 digital certificate
digital certificate format
parsed by computer
computer this scheme
secure web communication
15.4.3 15.4.2 implementation
implementation of cryptography
cryptography network protocols
generates a message
message to send
hands its message
stack for delivery
packets are passed
connection ip encapsulates
encapsulates the tcp
peer then delivers
delivers the tcp
model for data
model of networking
networking in chapter
shows a diagram
iso model ssl
transport layer networklayer
layer networklayer security
defines ip packet
insertion of authenticators
encryption of packet
protocol for key
two ipsec endpoints
endpoints is encrypted
encrypted to make
make a private
public numerous protocols
coded to implement
stack in general
benefit from protections
protections placed lower
packets encapsulate tcp
encapsulate tcp packets
hides the contents
encapsulated tcp packets
detect the modification
modification of contaii1.ed
contaii1.ed tcp header
tcp header information
protection at lower
stack may give
give insufficient protection
protection to higher-layer
server that runs
runs over ipsec
authenticate the client
requests are received
authenticate a user
required to type
type a password
problem of e-mail
e-mail e-mail delivered
industry standard smtp
standard smtp protocol
protocol is stored
stored and forwarded
frequently multiple times
network for e-mail
security is independent
transports that carry
protocol that enables
enables two computers
computers to corrumjj1icate
limit the sender
commonly used cryptographic
securely with web
servers for completeness
note that ssl
ssl was designed
designed by netscape
industry standard tls
standard tls protocol
ssl and tls
simplified and abstract
server can establish
establish a secure
man-in-the-middle and replay
attacks for added
added cryptographic strength
keys are forgotten
session is completed
completed another communication
two will generation
keys the ssl
protocol is initiated
obtained a certificate
public encryption algorithm
server the public
server a validity
validity interval interval
interval interval durirtg
valid a digital
made by theca-that
client is presumed
obtained the public
public verification algorithm
user s browser
browser is shipped
algorithms and public
authorities the user
add or delete
sends a 28-byte
28-byte random value
cert5 the client
tests are satisfied
server has proved
proved its identity
generates a random
46-byte and sends
server recovers pms
cmnpute a shared
one-way and collision-resistant
collision-resistant function server
client can compute
server both compute
compute the keys
symmetric encryption key
ypt for encrypting
client a symmetric
rypt for encrypting
server a mac
recovers and accepts
true this protocol
enables the server
limit the recipients
client that generated
limit the senders
messages it accepts
client can limit
messages it sends
verify the identity
field contains information
determine the identityfor
name-of the server
communicating for applications
supports an option
send a certificate
competitor in ssl
ssl vpns ipsec
ipsec is good
good for point-to-point
encryption of traffic-say
two company offices
company offices ssl
offices ssl vpns
individual employee working
office our earlier
discussion of authentication
authentication involves messages
messages and sessions
major security problem
problem for operating
protection system depends
ability to identify
identify the programs
programs and processes
identify each user
user the system
system users identify
determine a user
authentication is based
user s possession
identifier and password
retina or signature
user a user
user-supplied password matches
matches the password
complete protection schemes
considered a special
keys or capabilities
capabilities for instance
password is correct
access is granted
granted different passwords
files in practice
gain full rights
trade-off between security
security and convenience
convenience if security
makes something inconvenient
circumvented 15.5.2 password
15.5.2 password vulnerabilities
password vulnerabilities passwords
two common ways
ways to guess
guess a password
human or program
people use obvious
cats or spouses
combinations of valid
valid password characters
-until the password
password is found
found short passwords
variations on average
guessing 5,000 times
times would produce
produce a correct
hit a program
password every millisecond
seconds to guess
guess a four-character
four-character password enumeration
successful where systems
systems allow longer
passwords that include
include both uppercase
large password space
letters in addition
result of visual
visual or electronic
monitoring an intruder
user is logging
learn the password
easily by watching
watching the keyboard
add a network
watch all data
network including user
including user ids
ids and passwords
encrypting the data
copied for off-system
trojan-horse program installed
system that captures
captures every keystroke
keystroke before sending
password is written
read or lost
systems force users
users to select
user to record
record the password
security than systems
select easy passwords
type of password
result of human
nature most computer
rule that forbids
accounts this rule
implemented for accounting
aimed at improving
security for instance
suppose one user
security breach occurs
user per user
user might notice
account and detect
detect the break-in
users break account-sharing
break account-sharing rules
behavior can result
accessed by unauthorized
users -possibly harmful
harmful ones passwords
system or selected
user system-generated passwords
users may write
easy to guess
systems will check
check a proposed
password for ease
ease of guessing
guessing or cracking
cracking before accepting
administrators occasionally check
occasionally check user
check user passwords
passwords and notify
notify a user
password is easy
guess some systems
systems also age
users to change
change their passwords
passwords at regular
passwords the solution
record a password
system could record
record the last
last n passwords
reuse several variants
simple password schemes
changed more frequently
password is changed
changed from session
session to session
password is selected
password is misused
discovers the security
security violation steps
repair the breached
security 15.5.3 encrypted
15.5.3 encrypted passwords
passwords one problem
difficulty of keeping
keeping the password
store a password
presents her password
password the unix
system uses encryption
encryption to avoid
avoid the necessity
necessity of keeping
keeping its password
password list secret
secret each user
password the system
extremely difficult-the designers
difficult-the designers hope
designers hope impossible-to
hope impossible-to invert
simple to compute
easy to compute
compute the function
impossible to compute
encode all passwords
passwords only encoded
passwords are stored
presents a password
encoded and compared
stored encoded password
cam1ot be decoded
secret the functionf
typically an encryption
rigorously the flaw
system no longer
longer has control
passwords are encrypted
file can run
run fast encryption
fast encryption routines
routines against it-encrypting
it-encrypting each word
comparing the results
user has selected
selected a password
password is cracked
sufficiently fast computers
clusters of slow
well-known encryption algorithm
cache of passwords
store the encrypted
encrypted password entries
programs that compare
compare a presented
stored password run
password run setuid
setuid to root
include a salt
recorded random number
algorithm the salt
salt is added
password to ensure
two plaintext passwords
ciphertexts another weakness
unix password methods
unix systems treat
first eight characters
characters as significant
important for users
space to avoid
avoid the dictionary
dictionary encryption method
words as passwords
passwords a good
generate your password
easily remembered phrase
number or punctuation
punctuation mark thrown
phrase my mother
katherine might yield
yield the password
password is hard
hard to crack
crack but easy
user to remember
remember 15.5.4 one-time
15.5.4 one-time passwords
passwords to avoid
avoid the problems
problems of password
sniffing and shoulder
set of paired
system randomly selects
selects and presents
presents one part
user is challenged
challenge this approach
password the algorithm
selects a random
integer and presents
user the user
applies a function
function and replies
result the system
system also applies
applies the function
two results match
allowed such algorithmic
susceptible to reuse
user can type
intercepting that password
share a secret
secret the secret
number or alphanumeric
sequence the seed
computer the secret
function is transmitted
becallse the computer
user is authenticated
seed is generated
instance anyone capturing
capturing the password
session will fail
fail one-time passwords
ways to prevent
prevent improper authentication
improper authentication clue
clue to password
password exposure one-time
exposure one-time password
one-time password systems
systems are implemented
ways commercial implementations
calculators are shaped
include a display
user to enter
enter the shared
keypad the display
display then shows
shows the one-time
one-time password generator
types of components
components are needed
case two-factor authentication
two-factor authentication offers
protection than single-factor
authentication another variation
variation on one-time
list of single-use
passwords each password
out or erased
code book based
source of one-time
user must protect
protect his code
book 15.5.5 biometrics
biometric measures palm
palm or hand-readers
secure physical access-for
center these readers
readers match stored
match stored parameters
read from hand-reader
pads the parameters
parameters can include
include a temperature
patterns these devices
large and expensive
normal computer authentication
computer authentication fingerprint
authentication fingerprint readers
accurate and cost-effective
future these devices
devices read finger
read finger ridge
finger ridge patterns
patterns and convert
sequence of numbers
store a set
set of sequences
sequences to adjust
scan a finger
pad and compare
compare its features
sequences to determine
scanner can differentiate
accurate two-factor authentication
two-factor authentication scheme
result from requiring
requiring a password
information is encrypted
encrypted in transit
resistant to spoofing
spoofing or replay
place her finger
pad and plug
plug the usb
normal passwords recall
sufficient to guarantee
user an authenticated
threats to system
solutions the solutions
run the gamut
gamut from improved
improved user education
software most security
security professionals subscribe
layers of defense
kind of security
resistance to threats
threats 15.6.1 security
15.6.1 security policy
policy toward improving
improving the security
aspect of computing
include a statement
policy might state
share their passwords
policy in place
impossible for users
allowed the policy
map to security
people it affects
guide the policy
reviewed and updated
periodically to ensure
15.6.2 vulnerability assessment
execute a vulnerability
assessment such assessments
assessments can cover
cover broad ground
engineering through risk
assessment to port
port scans rlsl
endeavors to value
value the assets
entity in question
determine the odds
incident will affect
affect the entity
entity and decrease
decrease its value
odds of suffering
suffering a loss
secure the entity
entity the core
., ~ --in
entity is scanned
book is concerned
concerned with operating
software that runs
aspects of vulnerability
vulnerability assessment vulnerability
assessment vulnerability scans
typically are done
done at times
times when computer
minimize their impact
induce unhappy behavior
systems or network
devices a scan
system can check
check a variety
variety of aspects
short or easy-to-guess
easy-to-guess passwords unauthorized
passwords unauthorized privileged
unauthorized privileged programs
setuid programs unauthorized
programs unauthorized programs
programs in system
directories unexpectedly long-running
unexpectedly long-running processes
long-running processes improper
processes improper directory
improper directory protections
protections on user
system directories improper
directories improper protections
protections on system
system data files
kernel itself dangerous
program search path
trojan horse discussed
system programs detected
detected with checksum
checksum values unexpected
unexpected or hidden
hidden network daemons
daemons any problems
automatically or reported
system networked computers
susceptible to security
directly connected terminals
unknown and large
points-a potentially severe
potentially severe security
severe security problem
connected to telephone
lines via modems
exposed in fact
u.s government considers
considers a system
connection for instance
building also considered
top-secret the system
loses its topsecret
communication call occur
environment some government
facilities take extreme
extreme security precautions
precautions the connectors
connectors that plug
plug a terminal
computer are locked
physical lock combination
administrators and computer-security
impossible to lock
lock a machine
room and disallow
disallow all remote
access for instance
network currently connects
millions of computers
companies and individuals
internet a club
club with millions
millions of members
members the bad
attempt to gain
worm vulnerability scans
applied to networks
networks to address
problems with network
security the scans
search a network
network for ports
ports that respond
request if services
services are enabled
disabled the scans
scans then determine
determine the details
testing those vulnerabilities
vulnerabilities can determine
system is ncisconfigured
ncisconfigured or lacks
lacks needed patches
security these tools
crackers find vulnerabilities
detect port scans
challenge to security
harm in fact
people advocate stating
written to test
approach to security
crackers could write
reasonable that security
security through obscurity
obscurity be considered
layers of security
company could publish
publish its entire
entire network configuration
keeping that information
information secret makes
makes it harder
harder for intruders
information will remain
remain a secret
sense of security
security 15.6.3 intrusion
15.6.3 intrusion detection
detection and facilities
linked to intrusion
strives to detect
attempted or successful
intrusions into computer
initiate appropriate responses
intrusions intrusion detection
intrusion detection encompasses
encompasses a wide
array of techniques
techniques that vary
number of axes
detection occurs detection
detection can occur
occur in real
intrusion is occurring
fact the types
types of inputs
examined to detect
detect intrusive activity
include user-shell commands
process system calls
network packet headers
headers or contents
contents some forms
forms of intrusion
sources the range
range of response
response capabilities simple
capabilities simple forms
forms of response
response include alerting
alerting an administrator
potentially intrusive activity-for
killing a process
fonn of response
divert an intruder
intruder s activity
false resource exposed
attacker the resource
resource appears real
attacker and enables
enables the system
system to monitor
monitor and gain
attack these degrees
degrees of freedom
space for detecting
range of solutions
ids systems raise
raise an alarm
intrusion is detected
idp systems act
act as routers
point that traffic
traffic is blocked
constitutes an intrusion
defining a suitable
specification of intrusion
idss and idps
idps today settle
two less ambitious
input or network
traffic is examined
specific behavior patterns
attacks a simple
detection is scanning
scanning network packets
binaries or network
packets for lmown
typically called attempts
techniques to detect
detect anomalous behavior
behavior within computer
anomalous system activity
intrusions often induce
induce anomalous behavior
detection is monitoring
monitoring system calls
process to detect
system-call behavior deviates
deviates from normal
daemon to corrupt
corrupt its behavior
monitoring shell commands
commands to detect
detect anomalous commands
user or detecting
detecting an anomalous
attacker has succeeded
succeeded in gaining
user s account
account signature-based detection
signature-based detection attempts
attempts to characterize
characterize dangerous behaviors
anomaly detection attempts
approaches yield idss
detection can find
find previously unknown
previously unknown methods
methods of intrusion
so-called signature-based detection
signatures were generated
generated will evade
evade signature-based detection
detection this problem
vendors of virus-detection
release new signatures
signatures with great
viruses are detected
manually anomaly detection
superior to signature-based
challenge for systems
attempt anomaly detection
benchmark normal system
normal system behavior
system behavior accurately
system is benchinarked
influence from intrusive
behaviorf the benchmark
benchmark must give
fairly complete picture
picture of normal
excessive to illustrate
illustrate the impact
marginally high rate
rate of false
hundred unix workstations
events are recorded
recorded for purposes
purposes of intrusion
detection a small
generate a million
million audit records
records per day
administrator s investigation
attack is reflected
reflected in ten
ten audit recordsf
compute the rate
rate of occurrence
occurrence of audit
audit records reflecting
reflecting truly intrusive
recor s mtrus10n
probability of occurrence
occurrence of intrusive
denote the raising
ids an accurate
ids should maximize
impact ofthe false-alarm
ofthe false-alarm rate
good true-alarm rate
seemingly good falsealarm
good falsealarm rate
security administrator ilwestigates
ilwestigates each alarm
alarms-called a christmas
christmas tree effect
tree effect -is
-is exceedingly wasteful
teach the admilcistrator
admilcistrator to ignore
illustrates a general
principle for idss
extremely low false-alarm
low false-alarm rate
false-alarm rate achieving
sufficiently low false-alarm
challenge for anomaly-detection
adequately benchmarking normal
benchmarking normal system
research contil ues
ues to improve
improve anomalydetection techniques
anomalydetection techniques intrusion
techniques intrusion detection
intrusion detection software
software is evolving
evolving to implement
combine the results
results to arrive
accurate anomaly-detection rate
rate 15.6.4 virus
15.6.4 virus protection
havoc on systems
protection from viruses
important security concern
security concern antivirus
concern antivirus programs
programs are effective
viruses they work
work by searching
pattern of instructions
remove the instructions
program antivirus programs
catalogs of thousands
search both viruses
viruses and antivirus
antivirus software continue
sophisticated some viruses
infect other software
software to avoid
avoid the basic
basic pattern-match approach
approach of antivirus
antivirus programs antivirus
programs antivirus programs
programs ill turn
families of patterns
pattern to identify
virus in fact
antivirus programs implement
implement a variety
variety of detection
decompress compressed viruses
viruses before checking
anomalies a process
opening an executable
file for writing
writing is suspicious
compiler another popular
controlled or emulated
tripwire file system
tool for unix
developed at purdue
purdue university tripwire
university tripwire operates
result in modification
modification of system
directories and files
attacker might modify
modify the system
copies with trojan
insert new programs
programs into directories
directories commonly found
found in user-shell
user-shell search paths
intruder might remove
remove system log
system log files
files to cover
cover his tracks
tool to monitor
monitor file systems
systems for added
alert system administrators
modifications the operation
operation of tripwire
tripwire is controlled
tw.config that enumerates
enumerates the directories
additions each entry
configuration file includes
includes a selection
permissions be monitored
mask can instruct
instruct thatthe file
file be monitored
monitoring the hash
good as monitoring
monitoring the file
itselt but storing
hashes of files
room than copying
copying the files
takes as input
input the tw.config
file and computes
computes a sign.ature
attributes and hash
signatures are stored
database when run
inputs both tw.config
previously stored database
recomputes the signature
named in tw.conf
compares this signature
previously compl.j-ted database
compl.j-ted database events
database events reported
include any monitored
directory whose signature
directory no longer
class of attacks
protect the tripwire
server where logins
convenient to update
update the database
database after authorized
updates to monitored
system log files-are
log files-are supposed
supposed to change
attack that modifies
tripwire s detection
detectcertain obvious inconsistencies
shrinking log file
free and commercial
versions of tripwire
system the antivirus
antivirus software analyzes
analyzes the behavior
sandbox before letting
letting it run
unmonitored some antivirus
programs also put
system they search
search boot sectors
inbound and outbound
devices or media
protection against computer
viruses is prevention
practice of purchasing
purchasing unopened software
software from vendors
vendors and avoiding
free or pirated
copies from public
sources or disk
disk exchange offer
offer the safest
route to preventing
copies of legitimate
legitimate software applications
immune to virus
company have infected
infected the master
copies of software
company for macro
exchange microsoft word
alternative file format
format called unlike
unlike the native
native word format
word format rtf
include the capability
capability to attach
macros another defense
opening any e-mail
attachments from unknown
history has shown
shown that e-mail
love bug virus
widespread by traveling
traveling in e-mail
messages that pretended
opened the attached
attached visual basic
visual basic script
propagated by sending
receiver s e-mail
e-mail contact list
clogging e-mail systems
systems and users
users  inboxes
negate the defensive
strategy of opening
effective defense method
code some companies
companies now enforce
policy by removing
removing all incoming
attachments to e-mail
messages another safeguard
permit early detection
detection a user
user must begin
reformatting the hard
targeted for viral
attack only secure
software is uploaded
secure message-digest computation
computation the resulting
free from unauthorized
operating system recomputes
signature and compares
infection this technique
high-overhead antivirus scan
passes the test
logging can decrease
decrease system performance
including security logging
general or specific
specific all system-call
logged for analysis
analysis of program
logged authentication failures
failures and authorization
lot about break-in
administrator s kit
tum can reveal
reveal security problems
early unix computer
unix computer break-ins
break-ins was detected
detected by cliff
exam5ning accounting logs
logs and spotted
spotted an anomaly
anomaly we turn
network one solution
firewall to separate
trusted and unh
unh usted systems
router that sits
untrusted a network
network firewall limits
firewall limits network
limits network access
two and monitors
monitors and logs
logs all connections
limit coru1.ections based
based on source
servers use http
http to communicate
communicate with web
browsers a firewall
http to pass
firewall the morris
protocol to break
break into computers
allowed to pass
firewall can separate
separate a network
network into multiple
domains a common
semitrusted and semisecure
company s computers
coru1.ections are allowed
internet or dmz
query a database
access is contained
access the company
company computers internet
computers internet internet
internet internet access
access from company
computers r---------i company
r---------i company computers
company computers access
access between dmz
dmz and company
separation via firewall
secure and attack-proof
ability to secure
travel within protocols
protocols or com1ections
connection is allowed
connection that house
house the attack
denialof service attacks
attacks can affect
machines another vulnerability
vulnerability of firewalls
unauthorized host pretends
host by meeting
meeting some authorization
host and identifies
identifies that host
host could send
firewall in addition
common network firewalls
kinds of firewalls
layer either included
system or added
communication between security
host a user
user could add
add a personal
understands the protocols
protocols that applications
transfer an application
application proxy accepts
accepts a com1ection
initiates a connection
original destination smtp
destination smtp server
monitor the traffic
forwards the message
disabling illegal commands
attempts to exploit
firewalls are designed
purpose of analyzing
analyzing xml traffic
traffic and blocking
disallowed or malformed
malformed xml sit
sit between applications
monitoring system-call execution
privilege feature implements
implements a list
fifty system calls
calls that processes
allowed to make
make a process
spawn other processes
instance the u.s
department of defense
defense trusted computer
trusted computer system
computer system evaluation
system evaluation criteria
four security classifications
classifications in systems
determine the security
model security solutions
classification is division
minimal protection division
division d includes
failed to meet
meet the requirements
classes for instance
ms-dos and windows
division d division
level of security
protection and accountability
accountability of users
audit capabilities division
c1-class system incorporates
incorporates some form
form of controls
protect private information
reading or destroying
destroying their data
cooperating users access
users access data
levels of sensitivity
sensitivity most versions
enforce a security
system controls access
access between users
users and files
files by allowing
sharing of objects
objects by named
individuals or defined
groups in addition
start any activities
tcb is expected
expected to mediate
mediate this identification
identification is accomplished
mechanism or password
protects the authentication
inaccessible to unauthorized
users a c2-class
c2-class system adds
adds an individual-level
individual-level access control
individual in addition
audit the actions
based on individual
identity the tcb
tcb also protects
user who accesses
accesses a storage
system some speciat
speciat secure versions
level division-b mandatory-protection
division-b mandatory-protection systems
attach a sensitivity
object the bl-class
bl-class tcb maintains
maintains the security
pertaining to mandatory
mandatory access control
sensitive secret level
level the tcb
tcb also denotes
denotes the sensitivity
top and bottom
output in addition
normal user-namepassword authentication
user-namepassword authentication information
tcb also maintains
maintains the clearance
clearance and authorizations
authorizations of individual
levels of security
security these levels
user may access
access any objects
objects that carry
carry sensitivity labels
sensitivity labels equal
user could access
access controls processes
distinct address spaces
spaces a b2-class
b2-class system extends
extends the sensitivity
storage objects physical
objects physical devices
devices are assigned
maximum security levels
enforce constraints imposed
devices are located
located in addition
system supports covert
supports covert channels
auditing of events
channel a b3-class
creation of access-control
lists that denote
users or groups
groups not granted
object the tcb
mechanism to monitor
violation of security
policy the mechanism
notifies the security
terminates the event
manner the highest-level
formal design specifications
specifications and verification
granting a high
degree of assurance
correctly a system
system beyond class
designed and developed
facility by trusted
tcb merely ensures
system can enforce
computing environment develops
develops a security
national computer security
computer security center
center certain computing
environments may require
require other certification
supplied by tempest
guards against electronic
system has terminals
shielded to prevent
prevent electromagnetic fields
fields from escaping
escaping this shielding
ensures that equipment
room or building
terminal is housed
housed camwt detect
detect what information
terminal microsoft windows
general-purpose operating system
operating system designed
designed to support
support a variety
variety of security
features and methods
features that windows
perform security functions
information and background
background on wilcdows
windows xp security
model is based
notion of windows
number of user
denied as desired
users are identified
windows xp creates
includes the security
user has examples
examples of special
special privileges include
privileges include backing
compute1 ~ logging
changing the system
clock every process
process that windows
windows xp runs
runs on behalf
user will receive
receive a copy
token the system
token to permit
permit or deny
process on behalf
design of windows
development of custom
custom authentication packages
subject to ensure
ensure that programs
user is authorized
track and manage
user s access
acting on behalf
user since windows
windows xp operates
classes of subjects
typical application program
logs on simple
subject is assigned
assigned a based
security access token
client when acting
client s behalf
behalf as mentioned
security technique windows
common security threats
monitored examples include
examples include failure
include failure auditing
auditing for login
login and logoff
events to detect
detect random password
random password break-ins
detect login activity
activity at strange
success and failure
failure write-access auditing
auditing for executable
files to track
track a virus
auditing for file
access to detect
access to sensitive
object in windows
change the access
discretionary access-control list
list that identifies
groups are allowed
system access-control list
list that controls
controls which auditing
messages the system
system will generate
-all access group
access group cs-read-write
group cs-read-write access
cs-read-write access user
user cliff-no access
access in addition
list of audit
list is composed
composed of access-control
mask that defines
value of accessallowed
accessallowed or accessdenied
files in windows
degree of control
control over access
windows xp classifies
objects or noncontainer
objects by default
object is created
object inherits permissions
copies a file
file will inherit
inherit the permissions
destination directory inherit
permission is changed
apply to existing
desires the system
administrator can prohibit
windows xp performance
spot approaching problems
problems in general
job of providing
ensure a secure
myriad security breaches
breaches on windows
windows xp systems
systems another reason
windows xp starts
starts at system
system boot tiine
typically are installed
windows xp system
real multiuser environment
administrator should formulate
formulate a security
plan and implement
security tools protection
internal problem security
protected from unauthorized
protect against malicious
data absolute protection
access that information
information without proper
authority several types
types of attacks
launched against programs
programs and agaitlst
agaitlst individual computers
stack and buffer-overflow
techniques allow successful
attackers to change
change their level
level of system
system access viruses
worms are self-perpetuating
computers denial-of-service attacks
denial-of-service attacks prevent
attacks prevent legitimate
target systems encryption
systems encryption limits
limits the domain
domain of receivers
receivers of data
domain of senders
confidentiality of data
data being stored
stored or transferred
transferred symmetric encryption
symmetric encryption requires
requires a shared
private key authentication
combined with hashing
prove that data
changed user authentication
user authentication methods
identify legitimate users
addition to standard
user-name and password
change from session
session to avoid
avoid replay attacks
replay attacks two-factor
attacks two-factor authentication
two-factor authentication requires
requires two forms
forms of authentication
activation pin multifactor
pin multifactor authentication
forms these methods
methods greatly decrease
decrease the chance
chance of authentication
authentication forgery methods
methods of preventing
preventing or detecting
detecting security incidents
security incidents include
incidents include intrusiondetection
include intrusiondetection systems
auditing and logging
logging of system
monitoring of system
judicial sentence handed
creation and execution
internet worm discussed
discuss a means
managers of systems
internet could design
design their systems
systems to limit
limit or eliminate
eliminate the damage
done by worms
drawbacks of making
making the change
commonly used computer
programs are prone
prone to man-in-themiddle
man-in-themiddle attacks discuss
attacks discuss solutions
solutions for preventing
preventing this form
form of attack
unix program cops
program cops scans
holes and alerts
alerts the user
two potential hazards
system for security
problems be limited
limited or eliminated
make a list
bank s computer
relates to physicat
operating-system ~ security
addition to unix
user to connect
connect a program
file the watchdog
watchdog is invoked
program requests access
grants or denies
discuss two pros
watchdogs for security
asymmetric encryption algorithm
goals a authentication
generated the message
message b secrecy
receiver can decrypt
decrypt the message
message c authentication
authentication and secrecy
encryption be put
system that generates
day also assume
attacks per day
percentage of alarms
correspond to real
salt be stored
discussions concerning security
pfleeger and pfleeger
russell and gangemi
text by lobel
networking is discussed
discussed in kurose
design and verification
verification of secure
discussed by rushby
microcomputer is described
described by schell
distributed secure system
described by rushby
rushby and randell
morris and thompson
discuss password security
password security morshedian
methods to fight
fight password pirates
password pirates password
pirates password authentication
communications is considered
considered by lamport
issue of password
cracking is examined
break-ins are discussed
discussed by lehmann
related to trusting
trusting computer programs
programs are discussed
discussed in thompson
discussions concerning unix
security are offered
offered by grampp
grampp and morris
filipski and hanko
bershad and pinkerton
present the watchdog
extension to bsd
unix the cops
cops security-scanning package
package for unix
unix was written
written by farmer
farmer at purdue
program from host
ftp.uu.net in directory
security i cops
detailed technical discussion
worm the spafford
spafford article appears
worm in communications
suite are described
described in bellovin
prevent such attacks
attacks are discussed
discussed in cheswick
approach to protecting
networks from insider
topology or route
route discovery kent
zapata and asokan
solutions for secure
secure routing savage
examine the distributed
distributed denialof service
denialof service attack
attack and propose
propose ip trace-back
solutions to address
address the problem
proposes an approach
approach to diagnose
network contains malicious
malicious routers information
information about viruses
sites containing up-to-date
up-to-date security information
security information diffie
diffie and hellman
researchers to propose
public-key encryption scheme
scheme the algorithm
15.4.1 is based
developed by rivest
denning and demting
cryptography in computer
computer systems discussions
discussions concerning protection
protection of digital
signatures are offered
offered by akl
concerned about security
security the department
describes a set
set of security
security rating reading
good starting point
point for understanding
understanding security concerns
concerns the microsoft
windows nt workstation
workstation resource kit
describes the security
model the rsa
algorithm is presented
presented in rivest
information about nist
nist s aes
slightly and presented
request for comments
section 15.6.3 illustrating
illustrating the impact
impact of false-alarm
effectiveness of idss
idss is based
based on axelsson
description of tripwire
tripwire in section
15.6.5 is based
based on kim
kim and spafford
research into system-call-based
system-call-based anomaly detection
detection is described
described in forrest
local-area or wide-area
networks the processors
distributed system vary
vary in size
size and function
function such systems
systems may include
include small handheld
handheld or real-time
large mainframe computer
mainframe computer systems
systems a distributed
single centralized data
centralized data repository
multiple independent storage
independent storage devices
devices the benefits
distributed system include
system include giving
include giving users
giving users access
speeding up computation
computation and improving
improving data availability
system is distributed
memory the processors
buses or telephone
discuss the general
structure of distributed
networks that interconnect
contrast the main
differences in operating-system
systems and centralized
discuss distributed file
describe the methods
systems to coordinate
coordinate their actions
actions to provide
provide a high-level
loosely coupled processors
coupled processors interconnected
resources are local
local the processors
system may vary
include small microprocessors
large general-purpose cornputer
general-purpose cornputer systems
systems these processors
processors are referred
number of names
machine and host
site a site
site c network
network communication site
site b figure
four major reasons
reasons for building
building distributed systems
16.1.1 resource sharing
user at site
laser printer located
located at site
file that resides
system provides mechanisms
mechanisms for sharing
files at remote
remote specialized hardware
specialized hardware devices
high-speed array processor
performing other operations
operations 16.1.2 computation
16.1.2 computation speedup
partitioned into subcomputations
distribute the subcomputations
provide in addition
overloaded with jobs
lightly loaded sites
sites this movement
movement of jobs
automated load sharing
system automatically moves
automatically moves jobs
comnlon in commercial
systems 16.1.3 reliability
sites can continue
giving the system
system better reliability
system is composed
composed of multiple
multiple large autonomous
large autonomous installations
affect the rest
composed of sncall
crucial system function
failure may halt
halt the operation
system in general
hardware and data
system can continue
sites have failed
failed the failure
needed to recover
failure the system
site in addition
transfer of function
function occurs correctly
failed site recovers
actions present difficult
present difficult problems
solutions 16.1.4 communication
sites are connected
opportunity to exchange
passed between systems
messages are passed
passed between processes
single-computer message system
message system discussed
higher-level flmctionality found
found in standalone
expanded to encompass
encompass the distributed
system such functions
functions include file
include file transfer
out over great
distances two people
geographically distant sites
sites can collaborate
transferring the files
systems to run
mail to coordinate
coordinate the work
minimize the limitations
inherent in longdistance
work we wrote
book by collaborating
manner the advantages
advantages of distributed
systems have resulted
trend toward dovmslzing
dovmslzing many companies
companies are replacing
replacing their mainframes
mainframes with networks
networks of workstations
workstations or personal
personal computers companies
flexibility in locating
resources and expanding
two general categories
categories of network-oriented
network-oriented operating systems
network operating systems
systems and distributed
operating systems network
systems network operating
systems are simpler
simpler to implement
generally more difficult
difficult for users
access and utilize
provide more features
features 16.2.1 network
16.2.1 network operating
systems a operating
multiplicity of machines
access remote resources
machine or transferring
machines 16.2.1.1 remote
16.2.1.1 remote login
login an important
users to log
log in remotely
remotely the internet
p1.npose to illustrate
illustrate this facility
user at westminster
westminster college wishes
wishes to compute
compute on cs.yale.edu
located at yale
machine to log
issues the command
cs.yale.edu this command
machine at westminster
networking software creates
creates a transparent
process on cs.yale.edu
user the process
remote machine asks
asks the user
16.2.1.2 remote file
remote file transfer
transfer another major
mechanism for remote
computer at yale
university of vermont
vermont the internet
file transfer protocol
user on cs.uvm.edu
copy a java
java program server
program server java
java that resides
resides on cs.yale.edu
cs.yale.edu the user
invoke the ftp
program by executing
cs.yale.edu the program
program then asks
user must connect
file server java
server java resides
file by executing
executing get server
user ; users
real file sharing
copy a file
file may exist
waste of space
space tn addition
copies are modified
permission on cs.yale.edu
computer to copy
copy files remotely
remotely this remote
copying is accomplished
anonymous ftp method
public to read
file a user
user who wishes
wishes to copy
user is asked
password once anonymous
login is accomplished
partially authorized user
access inappropriate files
tree of user
anonymous any files
usual file-protection scheme
machine anonymous users
camlot access files
directory tree implementation
mechanism is similar
similar to telnet
implementation a daemon
remote site watches
watches for requests
requests to corulect
system s ptp
ptp port login
port login authentication
authentication is accomplished
execute commands remotely
unlike the telnet
executes any command
ptp daemon responds
set of file-related
commands these include
get-transfer a file
local machine put-transfer
machine cd -change
-change the current
commands to change
change transfer modes
determine connection status
status an important
point about telnet
telnet and ptp
require the user
user to change
change paradigms ptp
paradigms ptp requires
normal operating-system commands
operating-system commands telnet
commands telnet requires
requires a smaller
machine who tehlets
machine must switch
switch to unix
telnet session facilities
commands distributed operating
designed to address
problem 16.2.2 distributed
16.2.2 distributed operating
users access remote
access local resources
local resources data
data and process
system 16.2.2.1 data
16.2.2.1 data migration
data migration suppose
user on site
reside at site
system can transfer
transfer the data
two basic methods
methods one approach
transfer the entire
file to site
file is local
user no longer
back to site
transferred this mechanism
automated ftp system
system this approach
transfer to site
portion is required
note the similarity
similarity to demand
sun microsystems network
microsystems network file
versions of andrew
andrew the microsoft
microsoft smb protocol
microsoft netbeui protocol
smb is described
approach is preferable
preferable if significant
efficient to copy
copy the entire
data migration includes
perform various data
two sites involved
representations or represent
number or order
order of bits
16.2.2.2 computation migration
transfer the computation
access various large
obtain a summary
efficient to access
reside and return
return the desired
itiated the computation
data is longer
execute the remote
file at site
site a access
file is carried
out at site
rpc an rpc
execute a routine
invokes a predefilced
procedure at site
returns the results
message to site
operatil g system
system at site
out the designated
task when process
process q completes
completes its execution
sends the needed
concurrently with process
sites either method
access several files
sites one rpc
rpc might result
transfer of messages
turn would create
create another process
process this process
repeat the cycle
cycle 16.2.2.3 process
16.2.2.3 process migration
migration a logical
extension of computation
process is submitted
submitted for execution
initiated the entire
sites this scheme
balancing the processes
workload computation speedup
number of subprocesses
total process turnaround
reduced hardware preference
preference the process
suitable for execution
microprocessor software preference
process may require
expensive to move
move the process
process data access
computation are numerous
techniques to move
system can attempt
attempt to hide
hide the fact
process has migrated
client this scheme
code her program
explicitly to accomplish
accomplish the migration
migration this method
employed for achieving
achieving load balancing
balancing and computation
speedup among homogeneous
execute programs remotely
process should migrate
migrate this method
moved to satisfy
satisfy a hardware
migration for instance
client could trigger
trigger a database
form of process
executed a network
makes them seamless
accessible the result
powerful and easy-to-use
basically two types
geographically distributed local-area
distributed local-area networks
networks are composed
composed of processors
distributed over small
number of adjacent
number of autonomous
autonomous processors distributed
differences imply major
imply major variations
speed and reliability
distributed operating-system design
design 16.3.1 local-area
16.3.1 local-area networks
local-area networks local-area
networks local-area networks
local-area networks emerged
substitute for large
single large system
complement of peripheral
disks and printers
form of data
step to connect
connect these small
designed to cover
cover a small
systems are close
communication links tend
speed and lower
lower error rate
cou.rjerparts in wide-area
wide-area networks high-quality
cables are needed
needed to attain
attain this higher
exclusively for data
data network traffic
traffic over longer
cable is enormous
network are twisted-pair
twisted-pair and fiberoptic
star networks communication
networks communication speeds
communication speeds range
bluetooth local radio
local radio network
ethernet ten megabits
speed of requires
requires a higher-quality
cable but runs
common also growing
optical-fiber-based fddi networking
networking the fddi
network is token-based
token-based and runs
lan may consist
mainframes to laptops
laptops or pdas
shared peripheral devices
printers and magnetic-tape
lans an ethernet
network the ethernet
protocol is defined
spectrum for designing
designing local-area networks
local-area networks wireless
networks allow constructing
constructing a network
router for transmitting
signals between hosts
hosts each host
wireless adapter networking
adapter networking card
systems often run
networks typically run
run at slower
workstation workstation workstation
workstation workstation printer
workstation printer laptop
printer laptop file
laptop file server
file server figure
network several ieee
standards for wireless
ilc practice data
practice data rates
half that amount
amount the recent
recent 802.11n standard
theoretically much higher
higher data rates
practice 802.11n networks
networks have typical
typical data rates
rates of wireless
wireless spectrum wireless
spectrum wireless networks
advantage over wired
wired ethernet networks
run to connect
connect communicatilcg hosts
networks are popular
popular in homes
libraries and internet
cafes 16.3.2 wide-area
16.3.2 wide-area networks
wide-area networks wide-area
networks wide-area networks
wide-area networks emerged
academic research project
project to provide
provide efficient communication
communication among sites
community of users
users the first
arpanet has grown
four-site experimental network
network of networks
large geographical area
slow and unreliable
unreliable typical links
links are telephone
channels these communication
links are controlled
controlled by special
responsible for defilcing
defilcing the interface
netwot k host
host communication processor
communication processor figure
internet wan enables
wan enables hosts
geographically separated sites
sites to communicate
computers typically differ
generally on lans
internet via regional
networks the regional
il1 the northeast
northeast united states
form the worldwide
worldwide network connections
connections between networks
line for sites
sites requiring faster
requiring faster internet
faster internet access
tls are collected
units that work
work in parallel
parallel to provide
provide more throughput
throughput for instance
control the path
path each message
net this routing
increase commmlication efficiency
reduce security risks
computed other wans
wans use standard
standard telephone lines
means of communication
communication are devices
accept digital data
side and convert
destination site converts
converts the analog
back to digital
receives the data
data the unix
unix news network
systems to communicate
transferred to specific
slower than lans
transmission rates range
superseded by ppp
point-to-point protocol ppp
protocol ppp functions
functions over modem
internet the sites
ways each configuration
configuration has advantages
compare the configurations
cost the cost
linking the sites
system communication cost
money to send
message from site
site b availability
availability the extent
links or sites
topologies are depicted
graphs whose nodes
correspond to sites
sites an edge
edge from node
node b corresponds
direct communication link
fully connected network
number of sites
huge installation cost
fully connected networks
networks are impractical
ntially direct links
direct links exist
exist between some-but
some-but not all-pairs
all-pairs of sites
configuration is lower
sequence of communication
links this requirement
higher communication cost
communication link fails
reach their destination
system is split
partially connected network
connected network types
network types include
types include tree-structured
include tree-structured networks
characteristics and installation
installation and communication
communication costs installation
network can result
links must fail
fail for partition
partition to occur
degree of availability
cost is high
cross a large
single link results
failure the star
low communication cost
network partially connected
tree-structured network star
network star network
network f ring
ring network figure
central site fails
system become disconnected
discussed the physical
aspects of networking
workings the designer
network must address
address five basic
two processes locate
communicate routing strategies
network packet strategies
strategies are packets
sequence connection strategies
two processes send
send a sequence
resolve conflicting demands
network s lise
issues 16.5.1 naming
resolution the first
component of network
process at site
process identifier beca
beca use networked
networked systems share
share no memory
hosts to solve
processes on remote
network and identifier
host a host
make it easier
easier for users
hosts named homer
easier to remember
names are convenient
convenient for humans
computers prefer numbers
numbers for speed
speed and simplicity
describes the destination
hardware this mechanism
binding that occurs
occurs during program
case of host
names and addresses
similar to binding
binding at compile
adding or removing
removing a host
network requires updati.n.g
updati.n.g the data
hosts the alternative
distribute the information
information among systems
protocol to distribute
distribute and retrieve
retrieve the information
information this scheme
binding the first
specifies the naming
name-to-address resolution hosts
addressed with multipart
addresses the parts
address progress frorn
separating the fields
fields for instance
refers to host
depattment of science
science at brown
domain edu domains
systems the resolves
resolves in reverse
returns the address
host in host-id
host-id is returned
communicate with bob.cs.brown.edu
bob.cs.brown.edu would result
kernel of system
system a issues
issues a request
server for brown.edu
nance server returns
brown.edu name server
resides the kernel
kernel on system
address and asks
asks about cs.brown.edu
cs.brown.edu an address
address is returned
address for bob.cs.brown.edu
returns an host-id
server to speed
speed the process
resolve two portions
returning a pointer
cs.brown.edu name server
server is moved
optimizations have occurred
back-up name servers
servers that duplicate
duplicate the contents
service was introduced
file that contained
contained the names
periodically all hosts
copy the updated
file from sri-nic
contact new systems
systems or find
hosts whose addresses
addresses had changed
site is responsible
responsible for updating
updating the host
domain for instance
retrieve the updated
contact brown.edu directly
directly within domains
distribute the responsibility
responsibility for host-name
host-name and host-id
host-id changes java
api to design
program that maps
maps ip names
host or returns
returns a message
resolved an inetaddress
java class representing
address the static
static method getbyname
class is passed
passed a string
inetaddress the program
program then invokes
invokes the gethostaddress
internally uses dns
responsible for accepting
processes a message
destined for host
transferring that message
host the kernel
responsible for transferring
transferring the message
identifier this exchange
i.e java dnslookup
java dnslookup www.wiley.com
www.wiley.com i public
public class dnslookup
system err println
java program illustrating
illustrating a dns
lookup 16.5.2 routing
16.5.2 routing strategies
star or tree-structured
multiple physical paths
routing options exist
exist each site
indicating the alternative
sites the table
table may include
programs that exchange
exchange routing information
common routing schemes
routing a path
hardware failure disables
path is chosen
costs are minimized
minimized virtual routing
sessions involving messages
paths a session
remote-login period dynamic
period dynamic routing
routing the path
decision is made
assigned different paths
make a decision
decision to send
send the message
decide to send
site will deliver
deliver the message
schem.es fixed routing
adapt to link
failures or load
remedy this problem
dynamic routing fixed
routing fixed routing
routing and virtual
virtual routing ensure
ensure that ncessages
messages may arrive
problem by appending
appending a sequence
message dynamic routing
complicated to set
routing in complicated
complicated environments unix
hosts within simple
networks and dynamic
routing for complicated
complicated network environments
mix the two
reach the system
system that connects
connects the local
routing to reach
reach any host
network a router
computer network responsible
responsible for routing
messages a router
computer with routing
two network cmmections
router it makes
makes this determination
determination by examining
examining the destination
destination internet address
message the router
checks its tables
tables to determine
case of static
table is changed
routers to inform
update their routing
routing tables automatically
tables automatically gateways
gateways and routers
typically are dedicated
dedicated hardware devices
devices that run
out of firmware
firmware 16.5.3 packet
16.5.3 packet strategies
packet strategies messages
messages generally vary
length to simplify
simplify the system
commonly implement communication
communication with fixed-length
case the sender
reached its destination
packet is returned
long to fit
connection is established
exchange of multiple
packets 16.5.4 connection
16.5.4 connection strategies
reach their destinations
processes can institute
institute to exchange
exchange information pairs
pairs of processes
number of ways
permanent physical link
link is allocated
party a calls
communication is terminated
message transfer physical
transfer physical links
links are allocated
dynamically among correspondents
correspondents as needed
periods each message
data with system
network to deliver
correctly this scheme
post-office mailing system
system each letter
address and source
address many messages
link packet switching
switching one logical
number of packets
packets each packet
include a source
network the packets
reassembled into messages
harmful for data
broken into packets
schemes circuit switching
circuit switching requires
switching requires substantial
requires substantial set-up
waste network bandwidth
incurs less overhead
overhead for shipping
shipping each message
message and packet
packet switching require
require less set-up
incur more overhead
overhead per message
divided into packets
reassembled packet switching
bandwidth 16.5.5 contention
16.5.5 contention depending
link may cmmect
ring or multiaccess
multiaccess bus network
retransmit the information
provisions are made
resulting in degraded
developed to avoid
avoid repeated collisions
including collision detection
detection and token
csma before transmitting
transmitting a message
site must listen
listen to determine
link is free
site can start
continue to listen
sites begin transmitting
transmitting each site
random time interval
interval the main
collisions may occur
common local area
area network system
system one strategy
strategy for limiting
limiting the number
number of collisions
number of hosts
hosts per ethernet
ethernet network adding
adding more hosts
network could result
result in poor
poor network throughput
throughput as systems
systems get faster
send more packets
systems per ethernet
generally is decreasing
reasonable token passing
passing a unique
unique message type
information must wait
removes the token
ring and begins
begins to transmit
transmit its messages
completes its round
round of message
retransmits the token
token this action
site to receive
receive and remove
remove the token
start its message
token gets lost
system must detect
detect the loss
loss and generate
choose a unique
present one election
algorithm a token-passing
systems the benefit
performance is constant
adding new sites
network may lengthen
lengthen the waiting
large performance decrease
happen on ethernet
lightly loaded networks
systems can send
designing a communication
complexity of coordinating
coordinating asynchronous operations
asynchronous operations communicating
slow and error-prone
environment in addition
network must agree
set of protocols
protocols for determining
determining host names
simplify the design
partitioning the problem
problem into multiple
layers each layer
place between peer
environment iso environment
iso environment real
environment real systems
real systems environment
systems environment figure
two computers communicating
iso network model
protocol the protocols
software for instance
shows the logical
lowest-level layers implemented
international standards organization
layer the physical
layer is responsible
responsible for handling
systems must agree
stream of electrical
properly as binary
data this layer
networking device data-link
device data-link layer
layer the data-link
responsible for handlingfiames
parts of packets
including any error
recovery that occurs
physical layer network
layer network layer
layer the network
responsible for providing
handling the addresses
addresses of outgoing
decoding the addresses
addresses of incoming
maintaining routing information
information for proper
response to changing
changing load levels
load levels routers
levels routers work
layer transport layer
layer the transport
responsible for low-level
messages between clients
including partitioning messages
messages into packets
maintaining packet order
generating physical addresses
physical addresses session
addresses session layer
layer the session
responsible for implementing
process-to-process communication protocols
communications for remote
file and mail
layer the presentation
responsible for resolving
resolving the differences
differences in formats
including character conversions
half duplex-full duplex
duplex-full duplex modes
layer the application
responsible for interacting
directly with users
users this layer
deals with file
transfe1 ~ remote-login
schemas for distributed
distributed databases figure
summarizes the set
set of cooperating
protocols-showing the physical
data as mentioned
logically each layer
protocol stack communicates
layer and end-user
end-user application process
application process distributed
process distributed information
distributed information transfer-syntax
information transfer-syntax negotiation
transfer-syntax negotiation data-representation
negotiation data-representation transformations
data-representation transformations dialog
dialog and synchronization
control for application
application entities network-independent
entities network-independent message-interchange
network-independent message-interchange service
end-to ~ end
end message transfer
set-up and clearing
clearing application layer
application layer presentation
layer presentation layer
presentation layer session
layer session layer
session layer transport
transport layer network
network layer data-link
layer data-link control
link layer mechanical
mechanical and electrical
electrical networkcinterface connections
networkcinterface connections physical
connections physical connection
connection to network
network termination equipment
termination equipment physical
equipment physical layer
iso protocol stack
data-link -layer header
-layer header network-layer
header network-layer header
network-layer header transport-layer
header transport-layer header
header f-------1 session-layer
f-------1 session-layer header
header f-------1 presentation
f-------1 presentation layer
layer f-------1 application
f-------1 application layer
application layer message
_____j data-link -layer
data-link -layer trailer
-layer trailer figure
iso network message
level in turn
turn each layer
layer may modify
modify the message
message and il1.clude
il1.clude message-header data
reaches the data-network
target system receives
receives these data
message is moved
stripped of headers
reaches the application
process the iso
iso model formalizes
earlier work done
done in network
widely adopted protocol
adopted protocol stack
virtually all internet
sites the tcp
stack has fewer
combilles several functions
efficient than iso
networking the relationship
iso and tcp
models is shown
application layer identifies
identifies several protocols
protocols ill widespread
smtp the transport
transport layer identifies
identifies the unreliable
connectionless user datagram
user datagram protocol
connection-oriented transmission control
transmission control protocol
routing ip datagrams
internet the tcp
identify a link
link or physical
laye1 ~ allowing
traffic to run
network in section
ethernet network security
modern communication protocol
protocol both strong
encryption are needed
needed for secure
secure communication strong
communication strong authentication
strong authentication ensures
protects the contents
communication from eavesdropping
eavesdropping weak authentication
authentication and clear-text
iso presentation session
presentation session physical
physical tcp http
ftp not defined
defined not defined
tcp-udp not defined
protocol stacks common
stacks common protocols
protocols were designed
frequently less important
important than performance
efficiency strong authentication
strong authentication requires
requires a multistep
multistep handshake protocol
protocol or authentication
protocol modern cpus
efficiently perform encryption
systems frequently offload
frequently offload encryption
encryption to separate
separate cryptography processors
compromised longdistance communication
secure by authenticating
authenticating the endpoints
endpoints and encrypting
encrypting the stream
stream of packets
virtual private network
15.4.2 lan communication
lan communication remains
communication remains unencrypted
includes strong native
strong native authentication
improve even lan
security a distributed
system may suffer
types of hardware
types to ensure
system is robust
computation can continue
link is repaired
repaired 16.7.1 failure
16.7.1 failure detection
unable to differentiate
differentiate among link
failures has occurred
application to detect
link and site
suppose that sites
direct physical link
m.essage if site
receive this message
predetermined time period
assume that site
period to receive
receive an j-am-up
send an are-you-up
received an j-am-up
type of failure
differentiate between link
failure and site
failure by sending
sending an are-you-up
immediately replies positively
positively this positive
positive reply tells
advance how long
message to travel
sends the are-you-up
receives the reply
sih1ations has occurred
events has occurred
occurred 16.7.2 reconfiguration
16.7.2 reconfiguration suppose
initiate a procedure
system to reconfigure
continue its normal
site has failed
reached no longer
site the failure
site that serves
requires the election
site is part
camwt be reached
two sites serve
network is partitioned
initiate conflicting actions
coordinators are responsible
implementing mutual exclusion
sections 16.7.3 recovery
link or site
site is repaired
gracefully and smoothly
accomplish this notification
repeating the handshaking
handshaking procedure described
section 16.7.1 suppose
wlcen it recovers
sites to update
update its local
list of sites
messages and mail
required 16.7.4 fault
16.7.4 fault tolerance
tolerance a distributed
system must tolerate
level of failure
failure and continue
continue to function
types of failures
making a facility
facility fault tolerant
fault tolerant starts
term fault tolerance
broad sense communication
sense communication faults
stops before performing
performing an erroneous
decays of storage
failures the degradation
failures that caused
system that grinds
difficult and expensive
multiple redundant communication
redundant communication paths
paths and network
switches and routers
routers are needed
needed to avoid
avoid a cmnmunication
failure a storage
data storage units
units can include
include redundant hardware
redundant hardware components
case of failure
systems can ensure
ensure continued access
failure without redundancy
facility to stop
operation the inost
inost simple system
simple system failure
system failure involves
involves a system
running only stateless
applications these applications
compromising the operation
applications can run
operation can continue
computation-centric in contrast
systems involve running
involve running applications
applications that access
data-centric computing facilities
difficult to make
make fault tolerant
tolerant they failure-monitoring
infrastructure for instance
cluster and sun
sun cluster include
set of shared
disk the running
application s node
node has exclusive
application s data
data on disk
application is monitored
camwt be restarted
entire computer fails
node s exclusive
data is terminated
cluster the application
application is restarted
node the application
loses whatever state
system s memory
state it last
user s point
service was interrupted
data missing specific
missing specific applications
applications may improve
functionality by implementing
implementing lock management
clustering with lock
application can run
run on multiple
data on shared
shared disks concurrently
disks concurrently clustered
concurrently clustered databases
databases frequently implement
implement this functionality
functionality if anode
transactions can continue
notice no interruption
cluster any noncommitted
node are lost
designed to retry
retry noncommitted transactions
detect a failure
database node making
making the multiplicity
multiplicity of processors
processors and storage
transparent distributed system
distinguish between local
local and remote
resources were local
responsible for locating
locating the resources
interaction another aspect
aspect of transparency
transparency is user
machine a transparent
distributed system facilitates
system facilitates user
facilitates user mobility
mobility by bringiicg
user s environment
system from cmu
cmu and project
athena from mit
scale ; nfs
nfs can provide
system to adapt
adapt to increased
increased service load
service load systems
systems have bounded
saturated under increased
server s cpu
high utilization rate
accurately a scalable
scalable system reacts
gracefully to increased
reach a saturated
accommodate an ever-growing
ever-growing load adding
adding new resources
resources might solve
generate additional indirect
additional indirect load
system can clog
clog the network
network and increase
increase service loads
expanding the system
call for expensive
expensive design modifications
modifications a scalable
potential to grow
ability to scale
expanding the network
network by adding
adding new machines
machines or interconnecting
interconnecting two networks
networks is commonplace
commonplace in short
design should withstand
withstand high service
high service load
enable simple integration
integration of added
added resources scalability
scalability is related
related to fault
heavily loaded component
paralyzed and behave
shifting the load
component s backup
backup can saturate
resources is essential
essential for ensuring
handling peak loads
peak loads gracefully
gracefully an inherent
potential for fault
tolerance and scalability
multiplicity of resources
design can obscure
obscure this potential
fault-tolerance and scalability
scalability considerations call
design demonstrating distribution
distribution of control
control and data
data very large-scale
large-scale distributed systems
theoretical no magic
magic guidelines ensure
ensure the scalability
easier to point
out why current
discuss several designs
designs that pose
problems and propose
propose possible solutions
context of scalability
scalability one principle
principle for designing
designing very large-scale
number of nodes
system any service
mechanism whose load
demand is proportional
system is destined
adding more resources
problem the capacity
mechanism simply limits
limits the growth
system another principle
principle concerns centralization
concerns centralization central
centralization central control
central control schemes
schemes and central
examples of centralized
entities are central
central authentication servers
central naming servers
central file servers
file servers centralization
form of functional
asyrrunetry among machines
constituting the system
system the ideal
functionally symmetric configuration
degree of autonomy
principle for instance
incorporating diskless machines
diskless machines violates
machines violates functional
violates functional symmetry
autonomy and symmetry
symmetry are important
servers are supposed
supposed to operate
efficiently in peak
hundreds of active
simultaneously a single-process
request necessitates disk
assigning a process
expense of frequent
frequent context switches
considered a related
related problem occurs
group of lightweight
processes as multiple
serves single requests
scheduling of threads
nonpreemptive if threads
threads are allowed
run to completion
explicit locking mechanism
form of lightweight-process
scheme is essential
essential if servers
name-resolution issue raised
raised in section
16.5.1 and examine
examine its operation
operation with respect
needed to transfer
transfer a packet
packet between hosts
explained in section
describing the host
host-id is split
number the proportion
internet adrninistrators assign
assign a network
number is free
free to assign
host-ids the sending
sending system checks
checks its routing
tables to locate
locate a router
router to send
send the frame
host-id to transfer
transfer the packet
network the destination
system then receives
packet the packet
reassembled and passed
layer for transmission
move from sender
host or router
receiver ethernet device
unique byte number
addressing two devices
networking software generates
system this packet
network a broadcast
special network address
hosts should receive
receive and process
process the packet
re-sent by gateways
local network receive
arp request responds
responds and sends
back its mac
system that initiated
initiated the query
query for efficiency
caches the ip-mac
ip-mac address pair
table the cache
forgotten for added
heavily used hosts
device has announced
announced its host-id
host-id and address
communication can begin
begin a process
communicate networking software
networking software takes
lookup the message
detection of packet
device the data
headers that compose
compose the message
source to destination
included as data
find the ethernet
place the packet
wire the destination
destination ethernet device
device then sees
sees its address
packet and reads
source system finds
network and sends
sends the packet
packet there routers
routers then pass
pass the packet
1-mtil it reaches
reaches its bytes
address or broadcast
broadcast ethernet address
ethernet address length
length in bytes
bytes message data
message data message
long for error
error detection figure
network the router
router that connects
connects the destination
destination network checks
checks its arp
finds the ethernet
header may change
packet is received
received and processed
kernel a distributed
buses and telephone
lines the processors
large general-purpose computer
systems the processors
system are connected
ways the network
bus the communication-network
design must include
routing and com1ection
solve the problems
problems of contention
contention and security
resources the system
provided by data
process migration protocol
migration protocol stacks
network layering models
massage the message
reaches its destination
destination a naming
needed to translate
translate the network
network device address
systems are located
located on separate
needed to pass
packets from source
network to destination
network a distributed
detect hardware failures
failures and reconfigure
failure is repaired
devices for routers
routers and gateways
idea for gateways
gateways to pass
pass broadcast packets
packets between networks
advantages of doing
layer that senses
collisions and retransmits
immediately on detection
collision what problems
problems could arise
specifies seven layers
layers of functionality
systems use fewer
layers to implement
implement a network
layers what problems
network model provide
model provide datagram
provide datagram service
guarantees for messages
messages a transport-layer
provide reliability discuss
supporting reliable message
reliable message delivery
lowest possible layer
disadvantages of making
making the computer
computer network transparent
network more effective
differences in architectures
architectures and operating
operating systems describe
describe a method
method for process
topologies in terms
bandwidth for concurrent
communications c installation
cost d load
balance in routing
dynamic routing strategy
routing strategy affect
strategy affect application
affect application behavior
type of applications
original http protocol
protocol used tcp
underlying network protocol
separate tcp session
session was constructed
overhead of building
building and destroying
destroying tcp lip
tcp lip connections
performance problems resulted
make to improve
improve http performance
kinds of applications
applications is circuit
switching a viable
static host tables
tables what problems
problems or complications
servers what methods
decrease the amount
amount of traffic
traffic name servers
generate to satisfy
satisfy translation requests
make each host
read each packet
packet to determine
determine that packet
packet s destination
difference between computation
migration and process
www.wiley.com www.cs.yale.edu www.apple.com
www.apple.com www.westminstercollege.edu www.ietf.org
build a robust
robust distributed system
kinds of failures
failures can occur
occur a list
types of failure
explain why doubling
doubling the speed
segment may result
decreased network performance
servers are organized
longer than normal
normal what implications
recovery in distributed
distributed systems tanenbaum
computer networks williams
covers computer networking
viewpoint the internet
protocols are described
described in comer
coverage of tcp
found in stevens
unix network programming
programming is described
discussions concerning distributed
distributed operating-system structures
offered by coulouris
balancing and load
sharing are discussed
discussed by i-iarchol-balter
i-iarchol-balter and downey
vee and i-isu
i-iarish and owens
describes load-balancing dns
load-balancing dns servers
dns servers process
servers process migration
migration is discussed
discussed by jul
han and ghosh
distributed virtual machine
machine for distributed
examined in sirer
discussed network construction
low-level protocols needed
transfer between systems
files and storage
kind of sharing
discuss common concepts
dfss are based
illustrate our concepts
concepts by examining
examining one influential
influential dfs-the andrew
dfs-the andrew file
explain the naming
transparency and independence
independence to describe
methods for accessing
accessing distributed files
files to contrast
stateful and stateless
stateless distributed file
distributed file servers
servers to show
show how replication
replication of files
redundancy for improving
availability to introduce
introduce the andrew
loosely coupled computers
coupled computers interconnected
network these computers
computers can share
share physically dispersed
physically dispersed files
commercial transarc dfs
transarc dfs product
refers to nfs
explain the structure
define the terms
software entity running
machines and providing
type of function
function to clients
service software running
invoke a service
operations that form
actual cross-machine interaction
system provides file
services to clients
clients a client
service is formed
set of primitive
primitive file operations
primary hardware concponent
file server controls
set of local
local secondary-storage devices
clients  requests
requests a dfs
system whose clients
multiple and independent
configuration and implementation
dfs may vary
run on dedicated
client a dfs
implemented as part
layer whose task
manage the communication
communication between conventional
conventional operating systems
systems and file
systems the distinctive
multiplicity and autonomy
autonomy of clients
centralized file system
system the multiplicity
multiplicity and dispersion
dfs to locate
locate the files
data a dfs
dfs facilitates user
mobility by bringing
bringing a user
important performance measure
satisfy service requests
requests in conventional
consists of disk-access
amount of cpu-processing
additional overhead attributed
structure this overhead
deliver the request
overhead of running
running the communication
communication protocol software
software the performance
dfs s transparency
conventional file system
system the fact
set of dispersed
dispersed storage devices
key distinguishing feature
storage space managed
dfs is composed
remotely located smaller
located smaller storage
smaller storage spaces
constituent storage spaces
storage spaces correspond
correspond to sets
sets of files
files a cmnpm1.c
units all files
unit must reside
mapping between logical
objects for instance
deal with logical
logical data objects
data objects represented
represented by file
system manipulates physical
manipulates physical blocks
lower-level numerical identifier
turn is mapped
mapped to disk
blocks this multilevel
mapping provides users
file that hides
disk the file
file is stored
dimension is added
network the file
range is expanded
include the specific
concept of treating
files as abstractions
returns a set
file s replicas
existence of multiple
locations are hidden
hidden 17.2.1 naming
17.2.1 naming structures
differentiate two related
two related notions
reveal any hint
file s physical
physical storage location
level of naming
user-level textual names
names and system-level
system-level numerical identifiers
location-independent naming scheme
two different times
transparency in practice
current dfss provide
provide a static
mapping for user-level
names these systems
changing the location
automatically is impossible
notion of location
independence is irrelevant
disk blocks files
moved between machines
file migration implies
implies an automatic
action only afs
experimental file systems
file systems support
systems support location
support location independence
independence and file
file mobility afs
mobility afs supports
supports file mobility
purposes a protocol
protocol provides migration
migration of afs
afs component units
units to satisfy
satisfy high-level user
high-level user requests
differentiate location independence
independence and static
static location transparency
divorce of data
data from location
exhibited by location
abstraction for files
files a file
denote the file
location location-independent files
viewed as logical
logical data containers
specific storage location
transparency is supported
denotes a specific
set of physical
disk blocks static
blocks static location
transparency provides users
share data users
users can share
share remote files
naming the files
files were local
sharing the storage
space is cumbersome
attached to physical
storage devices location
devices location independence
location independence promotes
independence promotes sharing
objects when files
system-wide storage space
single virtual resource
ability to balance
balance the utilization
utilization of disks
system location independence
location independence separates
separates the naming
structure by contrast
names are transparent
expose the correspondence
correspondence between component
units and machines
machines the machines
machines are configured
structure this configuration
configuration may restrict
restrict the architecture
um1.ecessarily and conflict
considerations a server
server in charge
hierarchy and contradicts
contradicts decentralization guidelines
clients can access
access files residing
residing on remote
remote server systems
rely on servers
servers to provide
provide all files
including the operatingsystem
operatingsystem kernel special
kernel special protocols
protocols are needed
workstation the diskless
code to retrieve
retrieve the kernel
special boot protocol
invoked it enables
networking and retrieves
kernel or boot
kernel is copied
network and loaded
advantages of diskless
including lower cost
client machines require
require no disks
operating-system upgrade occurs
performance loss resulting
disk the current
disks and remote
remote file servers
file servers operating
software are stored
locally ; file
systems containing user
data-and possibly applications-are
possibly applications-are stored
systems some client
systems may store
commonly used applications
processors and web
remote file server
client on demand
demand the main
reason for providing
clients with local
pure diskless systems
increasing in capacity
capacity and decreasing
decreasing in cost
appearing every year
systems are growing
needed to limit
limit network access
access to improve
improve system throughput
throughput 17.2.2 naming
17.2.2 naming schemes
approaches to naming
file is identified
guarantees a unique
path this naming
transparent nor location
files the dfs
dfs is structured
collection of isolated
isolated component units
entire conventional file
component 1-mits remain
1-mits remain isolated
means are provided
approach was popularized
popularized by sun
sun s network
component of onc
networking package supported
unix vendors nfs
means to attach
attach remote directories
directories to local
giving the appearance
coherent directory tree
tree early nfs
early nfs versions
nfs versions allowed
previously mmmted remote
mmmted remote directories
mounts are done
done on demand
table of mount
points and file-structure
file-structure names components
components are integrated
integrated to support
support transparent sharing
integration is limited
machine may attach
attach different remote
tree the resulting
structure is versatile
achieve total integration
component file systems
global name structure
composed file-system structure
system in practice
unix device files
files and machine-specific
machine-specific binary directories
make this goal
difficult to attain
attain to evaluate
evaluate naming structures
local directory tree
server becomes unavailable
machines becomes unavailable
separate accreditation mechanism
accreditation mechanism controls
controls which machine
machine is allowed
allowed to attach
attach which directory
remote directory tree
client 17.2.3 implementation
17.2.3 implementation techniques
implementation techniques implementation
implementation of transparent
transparent naming requires
requires a provision
files into component
units and provide
provide the mapping
basis this aggregation
aggregation serves administrative
serves administrative purposes
hierarchical directory tree
tree to provide
provide name-to-location mapping
recursively into directories
enhance the availability
crucial mapping information
location independence means
replicating the mapping
makes a simple
simple yet consistent
impossible a teclllcique
teclllcique to overcome
low-level me textual
textual file names
names are mapped
mapped to lower-level
lower-level file identifiers
unit the file
belongs these identifiers
replicated and cached
invalidated by migration
migration of component
units the inevitable
level of mapping
maps component units
units to locations
consistent update mechanism
update mechanism implementing
implementing unix-like directory
unix-like directory trees
low-levet location-independent identifiers
location-independent identifiers makes
invariant under component-unit
component-unit location mapping
mapping a common
implement low-level identifiers
names these names
names are bit
parts the first
first part identifies
identifies the component
invariant of structured
times by taking
sufficiently more bits
done in apollo
view this process
taking a location-transparent
adding another level
level of abstraction
abstraction to produce
produce a location-independent
naming scheme aggregating
scheme aggregating files
lower-level locationindependent file
locationindependent file identifiers
identifiers are techniques
exemplified in afs
user who requests
file the server
storing the file
actual data transfer
achieve this transfer
requests for accesses
accesses are delivered
server machine performs
performs the accesses
results are forwarded
ways of implementing
implementing remote service
direct analogy exists
exists between disk-access
methods in conventional
conventional file systems
method is analogous
analogous to performing
performing a disk
request to ensure
ensure reasonable performance
form of caching
caching in conventional
rationale for caching
reduce both network
traffic and disk
implementation of caching
dfs and contrast
basic remote-service paradigm
17.3.1 basic caching
basic caching scheme
scheme the concept
concept of caching
caching is simple
satisfy the access
data is brought
client system accesses
accesses are performed
copy the idea
retain recently accessed
recently accessed disk
accessed disk blocks
additional network traffic
traffic a replacement
cache size bounded
bounded no direct
exists between accesses
accesses and traffic
master copy residing
file are scattered
copy is modified
copy to preserve
preserve the relevant
relevant consistency semantics
semantics the problem
problem of keeping
keeping the cached
cached copies consistent
section 17.3.4 dfs
17.3.4 dfs caching
sincilarly to demand-paged
remote server nfs
notwithstanding the resulting
resulting performance penalty
penalty the granularity
dfs can vary
vary from blocks
data are cached
satisfy a single
data this procedure
afs caches files
files in large
chapter support caching
caching of individual
driven by client
client demand increasing
increasing the caching
caching unit increases
increases the hit
increases the miss
requires more data
transferred it increases
increases the potential
potential for consistency
selecting the unit
unit of caching
involves considering parameters
network transfer unit
rpc protocol service
protocol service unit
units of cached
disassembled for delivery
delivery and reassembled
reassembled on reception
reception block size
size and total
total cache size
importance for blockcaching
schemes in unix-like
common block sizes
large block sizes
beneficial for smaller
result in fewer
lower hit ratio
ratio 17.3.2 cache
17.3.2 cache location
data be stored-on
memory disk caches
advantage over main-memory
modifications to cached
data are lost
volatile memory moreove1
main-memory caches permit
caches permit workstations
technology is moving
moving toward larger
memory the resulting
resulting performance speedup
speedup is predicted
predicted to outweigh
outweigh the advantages
advantages of disk
caches the server
speed up disk
caches are located
build a single
single caching nl.echanism
servers and users
users many remote-access
hybrids of caching
caching and remote
service in nfs
implementation is based
based on remote
augmented with client
client and server-side
server-side memory caching
caching for performance
performance similarly sprite
sprite s implementation
based on caching
method is adopted
evaluate the degree
method is emphasized
emphasized the nfs
provide disk caching
disk caching recent
caching recent solaris
recent solaris implementations
solaris implementations ofnfs
include a clientside
clientside disk-caching option
nfs client reads
client reads blocks
copy is flushed
cache is referenced
server to retrieve
retrieve the block
cache for client
17.3.3 cache-update policy
policy the policy
write modified data
modified data blocks
data blocks back
server s master
reliability the simplest
cache the advantage
information is lost
client system crashes
requires each write
access to wait
poor write performance
write performance caching
caching with write-through
write-through is equivalent
service for write
accesses and exploiting
caching for read
accesses an alternative
master copy modifications
modifications are written
advantages over write-through
writes are made
write accesses complete
delayed-write schemes introduce
schemes introduce reliability
introduce reliability problems
user machine crashes
machine crashes variations
delayed-write policy differ
blocks are flushed
server one alternative
flush a block
client s cache
cache this option
option can result
result in good
blocks can reside
cache a long
server a compromise
scan the cache
cache at regular
nfs server network
server network workstation
network workstation figure
caching its local
local cache sprite
30-second interval nfs
policy for file
write is issued
durilcg a cache
write must reach
reach the server
considered complete nfs
complete nfs treats
nfs treats meta
treats meta data
data and file-attribute
differently any metadata
loss and directory-structure
corruption are avoided
crashes for nfs
nfs with cachefs
local disk cache
disk cache area
cachefs improves performance
performance over standard
cachefs cache hit
hit but decreases
high cache hit
rate to gain
gain performance figure
shows how cachefs
cachefs uses write-through
write-through and write-back
variation on delayed
case of files
open for short
significantly reduce network
reduce network traffic
traffic in addition
write-on-close policy requires
requires the closing
process to delay
file is written
reduces the performance
advantages of delayed
writes for files
policy over delayed
flushing are apparent
apparent 17.3.4 consistency
consistency a client
machine is faced
locally cached copy
data is consistent
client machine determines
out of date
longer be served
data an up-to-date
approaches to verifying
verifying the validity
validity of cached
approach the client
initiates a validity
contacts the server
server and checks
data are consistent
copy the frequency
approach and determines
determines the resulting
resulting consistency semantics
check is delayed
initiated at fixed
fixed time intervals
check can load
server server-initiated approach
approach the server
parts of files
detects a potential
react a potential
potential for inconsistency
two different clients
clients in conflicting
conflicting modes cache
cache a file
resolve the potential
play an active
role the server
open the server
simultaneously in conflicting
modes by disabling
disabling caching results
results in switching
17.3.5 a comparison
comparison of caching
choice between caching
remote service trades
potentially increased performance
performance with decreased
simplicity we evaluate
evaluate this tradeoff
tradeoff by listing
listing the advantages
cache can handle
handle a substantial
remote accesses efficiently
accesses efficiently capitalizing
capitalizing on locality
locality in file-access
file-access patterns makes
patterns makes caching
served as fast
servers are contacted
load and network
traffic are reduced
potential for scalability
scalability is enhanced
enhanced by contrast
access is handled
network the penalty
penalty in network
performance is obvious
obvious total network
total network overhead
overhead is lower
lower for transmitting
transmitting big chunks
chunks of data
done in caching
series of responses
responses to specific
segments of data
random disk blocks
blocks the cache-consistency
drawback of caching
caching when access
access patterns exhibit
patterns exhibit infrequent
exhibit infrequent writes
caching is superior
writes are frequent
employed to overcome
overcome the consistency
consistency problem incur
problem incur substantial
incur substantial overhead
overhead in terms
terms of performance
caching will confer
confer a benefit
out on machines
disks or large
large main memories
main memories remote
memories remote access
access on diskless
method in caching
transferred en masse
lower-level intermachine interface
upper-level user interface
interface the remote-service
local file-system interface
intermachine interface mirrors
mirrors the user
approaches for storing
storing server-side information
client accesses remote
accesses remote files
tracks each file
file being accessed
simply provides blocks
client without knowledge
provided is stateful
stateless the typical
typical scenario involving
client must perform
perform an open
file before accessing
accessing that file
server fetches information
client a connection
fetches the inode
table of inodes
subsequent accesses ru1.til
ru1.til the session
ends a stateful
service is characterized
closing the file
server must reclaim
reclaim the main-memory
active the key
point regarding fault
stateful service approach
server keeps main-memory
stateful file service
service a avoids
avoids state information
information by making
making each request
full the server
table of open
files in main
establish and terminate
terminate a com1.ection
com1.ection through open
file operation stands
session a client
process would open
remote message reads
place as remote
local operation nfs
stateless file service
service the advantage
service is increased
performance file information
information is cached
cached in main
saving disk accesses
accesses in addition
open for sequential
blocks stateless servers
stateless servers cmmot
client s requests
requests the distinction
distinction between stateful
crash that occurs
activity a stateful
stateful server loses
ensuring the graceful
server involves restoring
restoring this state
recovery protocol based
dialog with clients
clients less graceful
graceful recovery requires
occurred be aborted
problem is caused
caused by client
failures the server
reclaim space allocated
allocated to record
record the state
state of crashed
crashed client processes
processes this phenomenon
stateless computer server
computer server avoids
avoids these problems
newly reincarnated server
server can respond
effects of server
failures and recovery
client s point
view the client
client keeps retransmitting
retransmitting its request
receives no response
response the penalty
robust stateless service
service is longer
longer request messages
messages and slower
processing of requests
i,_lformation to speed
speed the processing
processing in addition
stateless service imposes
service imposes additional
imposes additional constraints
identifies the target
low-level naming scheme
remote to local
clients retransmit requests
requests for file
effect and return
output if executed
executed several times
times consecutively self-contained
consecutively self-contained read
accesses are idempotent
absolute byte count
withilc the file
file they access
done in unix
careful when implementing
implementing destructive operations
make them idempotent
employs the server-initiated
method for cache
camcot provide stateless
provide stateless service
maintains a record
files are cached
descriptors and implicit
inherently stateful servers
servers must mailctain
tables to map
map the file
descriptors to inodes
store the current
file this requirement
employs a stateless
include an explicit
improving availability multimachine
availability multimachine replication
replication can benefit
selecting a nearby
replica to serve
serve an access
access request results
results in shorter
reside on failure-independent
ourcov,era.geofnfs thus .far
0p1y considered version
standard is version
vious versimi.s jhe
jhe most significant
maintains the.state ofthe
the.state ofthe client
ofthe client session
file is 0pt
ned untij itis
untij itis closed
itis closed th.t1s
operations ; previous
ersions of nfs
.np such operations
preytous \ cersions
lounting remote fil
fil ~ systews
lockii1g remote files
prqtocol in patticular
protocol was elimin
elimin ; 1.ted
work with network
notorimis security hole
hole in nps
enhan edthe ability
edthe ability of.dients
of.dients jo cache
file data local
che rgther thanh
thanh ; lvingto
request the client
maintains the loci
lea.st = expires
systems .provide advisory
.provide advisory jile
advisory jile locking
windows operatirg systen1
rylockil1g to allov
v4t1qw.p.rovides mandatory locking
locking as vvell
lockinga11d caching mec
mec ~ anisms
anisms are based
whe ~ eby
eby the server
server delegates responsibilities
file s lockand
contents to .the
.the client thatrequested
client thatrequested tnel
ckcrhat delegated client
delegated client maintains
maintains in cache
cache the .current
version of .the
client for lock
egated client reli11quishesth
reli11quishesth ~ lock
andde ~ egation
npsarebasedon the udj
udj network ptqtocol
based on .tcp,whioh
betteraclj \ lstto
lstto varying traffic
varying traffic loads
loads on thel
peleg2lting these responsibilities
responsibilities to cliel
cliel ! cts
reduces the foado11the
foado11the s.eryet and.i
and.i ~ proves.cache.coherency
replicas this obvious
obvious requirement implies
implies that replication
inherently a location-opaque
location-opaque activity provisions
provisions for placing
placing a replica
desirable to hide
hide the details
details of replication
replication from users
mapping a replicated
scheme the existence
existence of replicas
invisible to higher
levels at lower
names another transparency
requirement is providing
providing replication control
control at higher
higher levels replication
levels replication control
replication control includes
control includes determination
degree of replication
placement of replicas
expose these details
details to users
administrators with mechanisms
mechanisms to control
control the replication
replicas is updating
relevant consistency sen1antics
preserved when accesses
accesses to replicas
replicas are viewed
viewed as virtual
replicas  logical
files if consistency
sacrificed for availability
availability and performance
area of fault
creating a potential
potential for indefinite
sake of guaranteed
guaranteed progress locus
extensively and sacrifices
case of network
sake of availability
availability of files
files for read
write accesses ibis
approach the domain
local replica exists
mapping is relative
two identical identifiers
identical identifiers ibis
identifiers ibis supports
ibis supports demand
supports demand replication
automatic replication-control policy
replication-control policy similar
similar to whole-file
caching under demand
nonprimary replica updates
updates are performed
atomic and serialized
valid to satisfy
satisfy remote write
remote write accesses
migrate the primary
requesting machine andrew
distributed computing environment
computing environment designed
implemented at carnegie
university the andrew
constitutes the underlying
underlying information-sharing mechanism
mechanism among clients
environment the transarc
development of afs
purchased by ibm
produced several commercial
implementations of afs
result was part
ibm s transarc
transarc lab announced
announced that afs
ibm public license
dfs was canceled
commercial product openafs
linux and microsoft
systems many unix
support the dce
based on afs
work is ongoing
ongoing to make
dce a cross-platform
universally accepted dfs
dfs as afs
afs and transarc
dfs is named
named specifically afs
specifically afs seeks
seeks to solve
feature-rich nonexperimental dfs
dfs it features
features a uniform
uniform name space
location-independent file sharing
caching with cache
authentication via kerberos
includes server-side caching
form of replicas
availability through automatic
server is unavailable
attributes of afs
afs is scalability
system is targeted
targeted to span
workstations between afs
hundreds of implementations
worldwide 17.6.1 overview
17.6.1 overview afs
overview afs distinguishes
distinguishes between client
dedicated server machines
server machines servers
clients originally ran
systems the clients
servers are interconnected
network of lans
lans or wans
clients are presented
space of file
collectively called vice
software they run
present the shared
shared name space
location-transparent file hierarchy
hierarchy the local
local name space
root file system
space descends workstations
descends workstations run
run the virtue
protocol to communicate
communicate with vice
stores its local
collectively are responsible
storage and management
space the local
space is small
system programs essential
essential for autonomous
performance also local
local are temporary
files and files
store locally viewed
servers are structured
structured in clusters
wan each cluster
collection of workstations
representative of vice
cluster is com1.ected
router the decomposition
decomposition into clusters
clusters is done
primarily to address
problem of scale
scale for optimal
making cross-cluster file
cross-cluster file references
references relatively infrequent
infrequent the file-system
based on considerations
considerations of scale
scale the basic
light of experience
indicating that server
server cpu speed
system s bottleneck
feature reduces file-open
reduces file-open latency
involving the servers
design of afs
client mobility clients
workstation a client
client may notice
notice some initial
initial performance degradation
performance degradation due
caching of files
files when accessil
accessil g files
files a workstation
usual one security
security the vice
interface is considered
considered the boundary
boundary of trustworthiness
executed on vice
vice machines authentication
authentication and secure-transmission
functions are provided
connectionbased communication package
communication package based
paradigm after mutual
communicate via encrypted
encrypted messages encryption
encryption is performed
performed by hardware
information about clients
clients and groups
groups is stored
protection database replicated
server protection afs
unlxbits for file
protection the access
access list ncay
ncay contain information
access a directory
users not allowed
jim can access
directory afs supports
supports the access
access types read
delete heterogeneity defining
defining a clear
interface to vice
key for integration
integration of diverse
diverse workstation hardware
heterogeneity is facilitated
directory are symbolic
symbolic links pointing
pointing to machine-specific
machine-specific executable files
executable files residing
residing in vice
17.6.2 the shared
afs s shared
space is made
unusually small component
small component units
client few volumes
single disk partition
shrink in size
volumes are glued
unix m01mt mechanism
difference is significant
entire disk partition
key administrative unit
unit and play
role in identifying
identifying and locating
locating an individual
file a vice
directory is identified
fid each afs
afs directory entry
directory entry maps
maps a path-name
fid a fid
uniquifier the vnode
inodes of files
reuse of vnode
keeping certain data
data structures compact
structures compact fids
fids are location
movements from server
server to server
invalidate cached directory
cached directory contents
directory contents location
contents location information
server a client
client can identify
system by querying
querying this database
database the aggregation
aggregation of files
files into volumes
size to balance
space and utilization
utilization of servers
migrated among disk
partitions and servers
volume is shipped
server is left
left with temporary
temporary forwarding information
site the volume-movement
operation is atomic
operation is aborted
aborted read-only replication
volume is supported
supported for system-executable
vice name space
space the volume-location
volume-location database specifies
specifies the server
list of read-only
read-only replication sites
sites 17.6.3 file
17.6.3 file operations
operations and consistency
semantics the fundamental
fundamental architectural principle
principle in afs
caching of entire
files from servers
client workstation interacts
interacts with vice
closing of files
remote-service n lethod
distinction has far-reaching
ramifications for performance
semantics of file
operations the operating
workstation intercepts file-system
intercepts file-system calls
calls and forwards
workstation this process
files from vice
opened and stores
stores modified copies
venus may contact
closed ; reading
writing of individual
file are performed
copy and bypass
exploited for future
cached file venus
file venus assumes
assumes that cached
valid unless notified
open to validate
validate the cached
copy the mechanism
mechanism to support
support this policy
reduces the number
number of cache-validation
cache-validation requests received
received by servers
servers it works
caches a file
updates its state
information to record
record this caching
notifies the client
client before allowing
allowing another client
client to modify
modify the file
removes the callback
client a client
file for open
closes a file
file after modifying
caching this file
lose their callbacks
readin.g and writing
file are done
kernel without venus
venus s intervention
cached copy venus
copy venus regains
venus regains control
updates the file
venus contacts vice
contacts vice servers
opens of files
locally modified files
afs implements session
implements session semantics
exceptions are file
completes in spite
amount of cached
cached validation traffic
replace callbacks lost
machine or network
workstation is rebooted
considers all cached
generates a cache-validation
entry the callback
callback mechanism forces
forces each server
server to maintain
maintain callback information
client to maintain
maintain validity information
amount of callback
server is excessive
server can break
callbacks and reclaim
reclaim some storage
unilaterally notifying clients
clients and revoking
revoking the validity
callback state maintained
maintained by venus
out of sync
inconsistency may result
venus also caches
contents of directories
directories and syncbolic
translation each component
callback is established
venus does lookups
fids no requests
requests are forwarded
cache with callbacks
future open calls
file will involve
involve no network
callback is broken
directory for reasons
reasons of integrity
integrity the vice
interface has well-defined
purposes venus reflects
copy to avoid
re-fetching the directory
directory 17.6.4 implementation
17.6.4 implementation client
implementation client processes
processes are interfaced
calls the kernel
kernel is modified
slightly to detect
references to vice
forward the requests
client-level venus process
workstation venus carries
carries out path-name
out path-name translation
path-name translation component
component by component
cache that associates
volumes to server
locations in order
avoid server interrogation
contacts any server
requests the location
enters that information
cache unless venus
connection to fetch
fetch the file
directory connection establishment
establishment is needed
needed for authentication
authentication and security
found and cached
copy is created
local disk venus
venus then returns
opens the cached
copy and returns
returns its handle
process the unix
low-level storage system
clients the client
workstation s disk
directory are files
names are placeholders
entries both venus
venus and server
server processes access
processes access unix
access unix files
inodes to avoid
avoid the expensive
expensive path-name-to-inode translation
path-name-to-inode translation routine
internal inode interface
visible to client-level
processes are client-level
set of additional
additional system calls
calls was added
reliability over ufs
ufs venus manages
manages two separate
two separate caches
bounded in size
file is flushed
server to remove
remove the callback
file the status
servicing of stat
calls the data
cache is resident
unix i buffering
i buffering mechanism
caching of disk
blocks in memory
transparent to venus
venus a single
single client-level process
file server services
services all file
req1.1ests from clients
clients this process
package with non-preemptible
scheduling to service
service many client
client requests concurrently
concurrently the rpc
package is integrated
allowing the file
make or service
service one rpc
rpc per lightweight
process the rpc
package is built
low-level datagram abstraction
datagram abstraction whole-file
abstraction whole-file transfer
transfer is implemented
calls one rpc
rpc connection exists
exists per client
binding of lightweight
pool of lightweight
lightweight processes services
processes services client
services client requests
single multithreaded server
multithreaded server process
caching of data
data structures needed
single server process
effect of paralyzing
server a dfs
data a transparent
transparent dfs facilitates
dfs facilitates client
facilitates client mobility
bringing the client
client s environment
files are named
popularized by nfs
directory tree requests
requests to access
two complementary methods
methods with remote
client with caching
bounded the problem
approaches to server-side
stateless service paradigms
service time afs
feature-rich dfs characterized
characterized by location
independence and location
imposes significant consistency
significant consistency semantics
consistency semantics caching
caching and replication
discuss whether afs
afs and nfs
discuss whether clients
systems can obtain
inconsistent or stale
occur a afs
afs b sprite
sprite c nfs
stateful distributed file
system what actions
performed to recover
crash in order
order to preserve
preserve the consistency
disadvantages of path-name
ships the entire
requesting a translation
prefer a locationtransparent
prefer a location-independent
location-independent dfs discuss
chapter would handle
handle a large
multiclient database application
benefits of mapping
objects into virtual
compare and contrast
contrast the teclmiques
teclmiques of caching
totally reliable network
consistency and recovery
control for replicated
files are examined
examined by davcev
davcev and burkhard
management of replicated
environncent is covered
covered by brereton
discusses the issue
issue of file
placement on distributed
distributed computer systems
systems a detailed
centralized file servers
file servers appears
appears in svobodova
described by callaghan
discussed by morris
information about openafs
covered in detail
including unix united
locus unix united
united is described
described by brownbridge
discussed by popek
popek and walker
systems for mobile
mobile storage devices
devices are discussed
discussed in kistler
kistler and satyanarayanan
performed on cluster-based
cluster-based distributed file
distributed storage systems
systems for large-scale
settings are presented
presented in dabek
described various mechanisms
processes to synchronize
discussed a number
number of schemes
schemes to ensure
ensure the atomicity
transaction that executes
transactions in chapter
described various methods
examine how centralized
centralized synchronization mechanisms
describe various methods
methods for achieving
explain how atomic
system to show
concurrency-control schemes discussed
environment to present
schemes for handling
handling deadlock prevention
two events occurred
single common memory
memory and clock
clock many applications
applications may require
aft-er the resource
granted a distributed
events occurred first
first the happened-before
events in distributed
ability to define
define a total
ordering is crucial
present a distributed
algorithm for extending
extending the happened-before
consistent total ordering
18.1.1 the happened-before
law of causality
define the happenedbefore
set of events
assuming that sending
sending and receiving
receiving a message
constitutes an event
event of sending
sending a message
event of receiving
receiving that message
a + band
irreflexive partial ordering
events were executed
event b causally
causally a space-time
illustrate the definitions
definitions of concurrency
concurrency and happened-before
happened-before the horizontal
horizontal direction represents
direction represents space
vertical direction represents
labeled vertical lines
vertical lines denote
lines denote processes
labeled dots denote
dots denote events
events a wavy
wavy line denotes
denotes a message
events are concurrent
relation il figure
two concurrent events
event can affect
concurrent processes happened
processes happened first
processes that care
concurrent events agree
agree on son1.e
order 18.1.2 implementation
implementation to determine
event a happened
perfectly synchronized clocks
first we associate
define the requirement
pair of events
enforce the global
global ordering requirement
environment we define
lci the logical
simple counter incremented
two successive events
successive events executed
assigns a unique
event a occurs
occurs before event
event bin process
event this scheme
process the global
orderil g requirement
met across processes
processes to illustrate
illustrate the problem
logical clock ticks
violates our requirement
resolve this difficulty
require a process
process to advance
advance its logical
message whose timestamp
timestamp is greater
clock in particulm
process pi receives
tlcenit should advance
advance its clock
realize a total
process identity numbers
numbers to break
create a total
algorithms for implementing
environment we assume
processor to simplify
simplify our discussion
assume that processes
one-to-one mapping exists
exists between processes
processes and processors
18.2.1 centralized approach
approach to providing
providing mutual exclusion
system is chosen
chosen to coordinate
coordinate the entry
section each process
invoke mutual exclusion
mutual exclusion sends
sends a request
section after exiting
exiting its critical
sends a release
coordinator and proceeds
execution on receiving
receiving a request
coordinator immediately sends
request is queued
receives a release
sends a reply
algorithm ensures mutual
ensures mutual exclusion
exclusion in addition
coordinator is fair-such
fair-such as first-come
starvation can occur
occur this scheme
requires three messages
messages per critical-section
coordinator process fails
place in section
describe some algorithms
algorithms for electing
electing a unique
unique new coordinator
system to reconstruct
reconstruct its request
computation can resume
18.2.2 fully distributed
fully distributed approach
distribute the decision
complicated one approach
event-ordering scheme described
send a reply
sending a reply
queueing incmning requests
requests and deferring
sends reply messages
requests the decision
decision whether process
process pi replies
message or defers
defers its reply
reply is based
incoming request made
reply is deferred
deferred this algorithm
exclusion is obtained
deadlock is ensured
freedom from starvation
starvation is ensured
section is scheduled
ordering the timestamp
timestamp ordering ensures
ensures that processes
processes are served
order the number
represents the minimum
number of required
entry when processes
independently and concurrently
concurrently to illustrate
critical sections process
process p3 sends
logical clocks described
process p2 receives
receives these request
immediately when process
process p1 receives
receives the request
message is greater
process p3 receives
reply to process
requires the participation
joins the group
group of processes
process must receive
receive the names
group this task
group the interested
reader is referred
entire scheme collapses
monitoring the state
processes are notified
longer send request
send request messages
initiate the procedure
rejoin the group
entered their critical
section must pause
frequently to assure
assure other processes
intend to enter
suited for small
sets of cooperating
processes 18.2.3 token-passing
18.2.3 token-passing approach
approach another method
method of providilcg
providilcg mutual exclusion
circulate a token
ilc the system
passed from process
entitles the holder
holder to enter
logically organized ilc
physical communication network
processes are connected
implement a logical
ring to implement
pass the token
receives the token
keeping the token
token is passed
receiving the token
passes the token
neighbor this scheme
similar to algorithm
token is substituted
ring is unidirectional
ensured the number
exclusion may vary
message per entry
case of high
case of low
token is lost
lost an election
established in section
present an election
algorithm for reconstructing
reconstructing the ring
ring is left
ensuring the atomicity
system this difficulty
transaction the failure
communication link connecting
connecting the sites
result in erroneous
erroneous computations ensuring
distributed system preserves
system preserves atomicity
local transaction coordinator
responsible for coordinating
coordinating the execution
coordinator is responsible
starting the execution
breaking the transaction
number of subtransactions
subtransactions and distributing
distributing these subtransactions
sites for execution
coordinating the termination
transactions being committed
sites or aborted
sites we assume
local site maintains
maintains a log
log for recovery
18.3.1 the two-phase
two-phase commit protocol
protocol for atomicity
executed must agree
sites to ensure
widely used commit
discuss next assume
initiated at site
completes its execution-that
-then c starts
2pc protocol phase
adds the record
log and forces
forces the record
record onto stable
sends a prepare
executed on receiving
receiving the message
commit its portion
adds a record
responds by sending
sending an abort
storage the transaction
manager then replies
committed or aborted
received a ready
log and forced
forced onto stable
receives that message
records the message
log a site
unconditionally abort tat
coordinator the ready
site to follow
follow the coordinator
coordinator s order
order to commit
tor to abort
site can make
stored in stable
crashes after sending
unable to make
promise since unanimity
unanimity is required
required to commit
commit a transaction
responds with abort
unilaterally to abort
executed the final
writes that verdict
sends an acknowledge
coordinator has received
received the acknowledge
log 18.3.2 failure
18.3.2 failure handling
examine in detail
failure may result
result in blocking
recovers 18.3.2.1 failure
examine its log
determine the fate
midst of execution
failure occurred suppose
commit t record
site executes redo
abort t record
site executes undo
ready t record
site must consult
out the fate
sending a query-status
system on receiving
tted or aborted
abort nor commit
postponed until s1c
s1c can obtain
resend the query-status
information the site
inforn1.ation the log
absence of control
control records implies
implies that s1c
failed before responding
failure of s1c
s1c must execute
protocol for transaction
sites must decide
decide the fate
sites must wait
decided to commit
draw this conclusion
decided to abort
preferable to abort
tin this case
preceding cases holds
additional control records
coordinator has failed
impossible to determine
is-until the coordinator
fate oft remains
remains in doubt
continue to hold
hold system resources
locks on data
data at active
situation is undesirable
undesirable because hours
days may pass
data are unavailable
amount of unavailable
unavailable data increases
grows this situation
pending the recovery
recovery of site
network may partition
exist the coordinator
participants may remain
participants may belong
coordinator are lost
reducing the case
failure we move
issue of concurrency
environment the transaction
distributed database system
database system manages
access data stored
manager is responsible
responsible for maintaining
maintaining a log
scheme to coordinate
coordinate the concurrent
concurrency schemes described
modified to accommodate
accommodate the distribution
distribution of transactions
transactions 18.4.1 locking
18.4.1 locking protocols
protocols the two-phase
two-phase locking protocols
needed is iil
manager is implemented
schemes the first
replication is allowed
case where data
18.4.1.1 nonreplicated scheme
data are replicated
locking schemes described
maintains a local
local lock manager
manager whose function
administer the lock
data items stored
wishes to lock
lock data item
item qat site
manager at site
requesting a lock
request is delayed
lock n1.anager sends
advantage of simple
implementation it requires
requires two message
two message transfers
transfers for handling
handling lock requests
transfer for handling
handling unlock requests
deadlock-handling algorithms discussed
modifications are discussed
18.4.1.2 single-coordinator approach
approach several concurrency-control
maintains a single
single lock manager
manager that resides
single chosen site-say
requests are made
made at site
lock a data
sends a lock
lock manager determines
request was initiated
initiated the transaction
transaction can read
data item resides
writing the scheme
implementation this scheme
requires two messages
messages for handling
message for handling
handling lmlock requests
lmlock requests simple
requests simple deadlock
simple deadlock handling
environment the disadvantages
bottleneck the site
processed there vulnerability
site si fails
controller is lost
lost either processing
processing must stop
function is distributed
sites each lock
lock manager administers
administers the lock
items this distribution
reduces the degree
complicates deadlock handling
site 18.4.1.3 majority
18.4.1.3 majority protocol
protocol the majority
nonreplicated data scheme
data scheme presented
scheme presented earlier
earlier the system
maintains a lock
site each manager
controls the locks
data or replicas
replicas of data
send a lock
request to nlore
nlore than one-half
stored each lock
lock manager detern1.ines
response is delayed
granted the transaction
obtained a lock
deals with replicated
avoiding the drawbacks
drawbacks of central
implementation the majority
complicated to implement
schemes it requires
unlock requests deadlock
requests deadlock handling
locked to illustrate
sites and full
full replication suppose
suppose that transactions
exclusive mode transaction
succeed in locking
wait to acquire
occurred 18.4.1.4 biased
18.4.1.4 biased protocol
protocol the biased
protocol is similar
protocol the difference
requests for shared
requests for exclusive
locks the system
manages the locks
shared and exclusive
locks are handled
handled differently shared
differently shared locks
requests a lock
granted the scheme
advantage of imposing
imposing less overhead
overhead on read
protocol this advantage
significant in common
frequency of reads
frequency of writes
overhead on writes
biased protocol shares
shares the majority
protocol s disadvantage
disadvantage of complexity
complexity in handling
deadlock 18.4.1.5 primary
18.4.1.5 primary copy
precisely one site
call the primary
granted this scheme
handle concurrency control
unreplicated data implementation
accessible 18.4.2 timestamping
timestamping the principal
timestamping scheme discussed
decide the serialization
order our first
generalizing the centralized
develop a method
method for generating
generating unique timestamps
timestamps our previous
environment 18.4.2.1 generation
generation of unique
timestamps two primary
two primary methods
generate unique timestamps
site is chosen
chosen for distributing
distributing the timestamps
timestamps the site
generates a local
local unique timestamp
clock the global
global unique timestamp
timestamp is obtained
obtained by concatenation
order of concatenation
concatenation is important
position to ensure
global timestamps generated
compare this technique
technique for generating
18.1.2 for generating
generating unique na1nes
site generates local
generates local timestamps
site s logical
sites a mechanism
mechanism is needed
needed to ensure
ensure that local
timestamps are generated
accomplish the fair
generation of timestamps
generates the local
clocks are synchronized
site local unique
unique timestamp site
timestamp site identifier
global unique identifier
unique identifier figure
timestarnp x,y visits
site and xis
site si advances
advances its logical
timestamps are assigned
clock that runs
fast or slow
slow since clocks
clock 18.4.2.2 timestamp-ordering
18.4.2.2 timestamp-ordering scheme
scheme the basic
basic timestamp scheme
timestamp scheme introduced
rollbacks may result
prevent a transaction
transaction from reading
reading a data
data item value
committed to eliminate
eliminate cascading rollbacks
bine the basic
protocol of section
obtain a protocol
rollbacks we leave
leave the development
property that conflicts
conflicts between transactions
transactions are resolved
resolved through rollbacks
waits to alleviate
place without causing
aborts a read
exists a transaction
perform a wri
requires each site
site to maintain
maintain a read
write queue consisting
delayed to preserve
preserve the property
property just described
present the scheme
deadlock-detection algorithms presented
presented in chapter
algorithms 18.5.1 deadlock
18.5.1 deadlock prevention
prevention and avoidance
avoidance the deadlock-prevention
deadlock-prevention and deadlock-avoidance
deadlock-avoidance algorithms presented
modifications are made
resource-ordering deadlock-prevention technique
defining a global
system are assigned
assigned unique numbers
holding a resource
unique number greater
systenl by designating
process that maintains
maintains the information
out the banker
algorithm every resource
banker the global
global resource-ordering deadlock-prevention
resource-ordering deadlock-prevention scheme
scheme is simple
simple to implement
environment and requires
requires little overhead
overhead the banker
system we turn
deadlock-prevention scheme based
approach with resource
approach can handle
handle any deadlock
type to control
control the preemption
assign a unique
process these numbers
back this scheme
scheme prevents deadlocks
exist one difficulty
starvation some processes
extremely low priorities
back this difficulty
timestamps each process
system is assigned
created two complementary
two complementary deadlock-prevention
complementary deadlock-prevention schemes
schemes using timestamps
scheme this approach
approach is based
teclmique when process
resource currently held
allowed to wait
back the wound-wait
approach when process
wait both schemes
schemes can avoid
avoid starvation provided
process is rolled
timestamp since timestamps
timestamps always increase
two schemes operate
release its resource
older the process
wait by contrast
process never waits
process pi dies
requested a resource
die several times
times before acquiring
acquiring the needed
needed resource contrast
contrast this series
series of events
wound-wait scheme process
wounded and rolled
resource it holds
restarted and requests
fewer rollbacks occur
scheme the major
rollbacks may occur
occur 18.5.2 deadlock
18.5.2 deadlock detection
detection the deadlock-prevention
algorithm may preempt
occurred to prevent
prevent um ecessary
algorithm we construct
construct a wait-for
wait-for graph describing
describing the resourceallocation
wait-for graph represents
represents a deadlock
deadlock the main
system is deciding
graph we illustrate
illustrate this problem
problem by describing
describing several common
techniques to deal
issue these schemes
require each site
local wait-for graph
graph the nodes
holding or requesting
maintaining its local
wait-for graph note
note that processes
processes have requested
sites these local
local wait-for graphs
graphs are constructed
manner for local
processes and resources
graph of site
two local wait-for
global wait-for graph
graph for figure
occurred the fact
find no cycles
graph is acyclic
system to prove
graphs is acyclic
acyclic the graph
two wait-for graphs
graphs of figure
state a number
number of methods
organize the wait-for
system we describe
describe several common
18.5.2.1 centralized approach
graph is constructed
types of wait-for
graphs the real
real graph describes
describes the real
real but unknown
observer the constructed
algorithm the constructed
results are correct
correct by correct
deadlock is reported
construct such correct
algorithms the wait-for
invoke the cycledetection
searches its global
victim is selected
coordinator must notify
selected as victiitl
victiitl the sites
back the victim
graph-construction options listed
coordinator to notify
modification on receiving
updates its global
site can send
send a number
single message periodically
message periodically returning
process will maintain
maintain the global
graph as depicted
inserts the edge
similarly when site
deletes the edge
released a resource
false may exist
graph to illustrate
system as depicted
holding in site
coordinator may discover
discover the false
aborted for reasons
exceeded its allocated
decides to abort
coordinator has discovered
discovered a cycle
cycle and picked
centralized deadlock-detection algorithm
algorithm using option
detects all deadlocks
detect false deadlocks
deadlocks to avoid
avoid the report
report of false
require that requests
requests coordinator figure
local and global
global wait-for graphs
sites be appended
appended with unique
message with timestamp
received the request
grant the requested
resource a request
site is handled
sends an initiating
receiving this message
sends its local
graph the graph
reflects an instantaneous
synchronized with respect
controller has received
constructs a graph
algorithm was invoked
invoked as result
18.5.2.2 fully distributed
equally the responsibility
responsibility for detecting
deadlock every site
constructs a waitfor
graph that represents
represents a part
system the idea
graphs we present
construction of partial
site each site
graph a local
add one additional
additional node pex
graph an arc
site being held
site is waiting
acquire a resource
site to illustrate
illustrate this situation
cycle involving pex
implies the possibility
augmented local wait-for
graphs from figure
deadlock does exist
invoke a distributed
distributed deadlock -detection
deadlock -detection algorithm
-detection algorithm suppose
cycle involving node
involving node pex
pex this cycle
acquire a data
data item located
sj on discovering
discovering this cycle
site si sends
sends to site
message containing information
cycle when site
site si receives
receives this deadlock-detection
updates its local
newly constructed wait-for
constructed wait-for graph
cycle not involving
deadlock is found
scheme is iiwoked
pex is discovered
transmits a deadlock-detection
repeats the procedure
number of rounds
deadlock is discovered
deadlock-detection computation halts
halts to illustrate
illustrate this procedure
discovers the cycle
item in site
deadlock-detection message describing
describing that cycle
cycle is transmitted
transmitted from site
obtaining the wait-for
include node pex
discovered the cycle
sites will discover
discover the cycle
two deadlock-detection messages
results in unnecessary
unnecessary message transfer
transfer and overhead
overhead in updating
graphs and searching
searching for cycles
graph in site
5.z of figure
reduce message traffic
site sk discovers
form it sends
sends a deadlock-detection
site s1c continues
continues its normal
leaving the burden
burden of initiating
initiating the deadlock-detection
illustrate this scheme
wait-for graphs maintained
maintained at sites
suppose that suppose
suppose both sites
discover these local
cycle in site
send a deadlock-detection
wait-for graph site
graph and discovers
out in section
distributed algorithms employ
employ a coordinator
process that performs
performs functions needed
systenc these functions
functions include enforcing
include enforcing mutual
enforcing mutual exclusion
maintaining a global
replacing a lost
controlling an input
process fails due
site the algorithms
algorithms that determine
election algorithms assume
system for ease
ease of notation
number of process
assume a one-to-one
correspondence between processes
processes and sites
processes the coordinator
largest priority number
algorithm must elect
elect that active
number this number
process to identify
identify the current
examples of election
two different configurations
configurations of distributed
systems the first
first algorithm applies
applies to systems
process can send
require n2 messages
system we assume
takes appropriate actions
actions to rejoin
rejoin the set
set of active
bully algorithm suppose
coordinator this task
task is completed
sends an election
higher priority number
priority number process
response is received
processes with numbers
failed and elects
coordinator and sends
message to inform
inform all active
processes with priority
answer is received
waiting to receive
process is electing
electing itself coordinator
report the results
number is assumed
restart the algorithm
messages from process
records this information
started an election
sends a response
election the process
process that completes
completes its algorithm
processes with lower
failed process recovers
immediately begins execution
processes with higher
recovered process forces
forces all processes
algorithm is termed
demonstrate the operation
processes are active
fail p2 determines
failed by sending
sending a request
begins its election
algorithm by sending
sending an election
response and begins
sends the number
receive the number
recovers and notifies
sends no election
18.6.2 the ring
algorithm the assumes
links between processes
processes are unidirectional
sends its messages
right the main
main data structure
detects a coordinator
right and adds
adds the number
first elect message
j-thatis,ifthe message received
-then pi adds
list and forwards
-then the active
determine the largest
list to identify
process this algorithm
recovering process determines
determines the number
current coordinator process
process one solution
requires a recovering
process to send
send an inquiry
message this message
message is forwarded
processes to agree
resulting in lost
lost or garbled
resultilcg lie unpredictable
lie unpredictable process
unpredictable process behavior
stopping their execution
execution without deviating
normal execution pattern
processes may send
garbled or incorrect
situation several divisions
divisions byzantine army
surround an enemy
camp the byzantine
generals must reach
attack the enemy
enemy at dawn
divisions would result
result lie defeat
generals can communicate
messengers who run
run from camp
camp to camp
camp the generals
two major reasons
unable to deliver
deliver their messages
messages this situation
corresponds to unreliable
section 18.7.1 generals
prevent the loyal
generals from reaching
reaching an agreement
agreement this situation
corresponds to faulty
faulty processes lie
lie a computer
18.7.1 unreliable communications
medium is unreliable
received the message
decide to compute
compute a functionfoo
received its message
compute a function
out a message
sends an acknowledgment
receives the acknowledgment
retransmit its message
message and wait
acknowledgment this procedure
system that site
compute boo note
two viable alternatives
situations has occurred
received its acknowledgment
presence of failure
environment for processes
states to prove
prove this claim
sequence of message
message transfers exists
agree to compute
message will arrive
sequence without affecting
affecting the decision
contradicting our assumption
assumption and showing
sequence the processes
foo 18.7.2 faulty
18.7.2 faulty processes
medium is reliable
processes can fail
fail in unpredictable
devise an algorithm
construct a vector
delay for reaching
agreement is proportionate
delays the number
required for reaching
agreement is large
large no single
process is trustworthy
processes must collect
collect all information
presenting a general
present an algorithm
requires two rounds
rounds of information
sends its private
sends the information
processes a faulty
refuse to send
process can choose
choose an arbitrary
value and pretend
rounds are completed
construct its vector
reported for process
rounds of exchange
value of ai,f
determine the exact
two events occur
occur the happened-before
distributed system timestamps
consistent event ordering
event ordering mutual
ordering mutual exclusion
making is distributed
applicable to ring-structured
approach for atomicity
sites or aborts
execute a commit
case of locking
case of timestamping
timestamping and validation
mechanism for generating
generating unique global
unique global timestamps
timestamps the mechanism
concatenate a local
identification or advance
advance local clocks
timestamp the primary
method for dealing
environment is deadlock
detection the main
problem is deciding
wait-for graph methods
methods for organizing
organizing the wait-for
wait-for graph include
include a centralized
approach some distributed
distributed algorithms require
maintaining a backup
ready to assume
fails another approach
failed the algorithms
algorithms two algorithms
coordinator in case
case of failures
hierarchical deadlock-detection algorithm
graph is distributed
tree each non-leaf
non-leaf controller maintains
maintains a wait-for
lowest common ancestor
suppose that node
node ti appears
graph of controllers
graph of controller
exists a path
company is building
building a comp1.1ter
asked to develop
develop a scheme
explain your choice
derive an election
algorithm for bidirectional
messages are needed
building a computer
asked to write
write an algorithm
algorithm for achieving
achieving distributed mutual
distributed mutual exclusion
exclusion which scheme
model for faulty
faulty processors processors
processors processors follow
follow the prescribed
fail at unexpected
simply stop functioning
continue to participate
algorithm for reaching
set of processors
discuss the conditions
wait-die scheme perform
scheme for granting
failure that occurs
2pc ensures transaction
ensures transaction atomicity
logical clock timestamp
clock timestamp scheme
timestamp scheme presented
order two events
two events based
timestamps the fact
timestamp of event
event c happened
happened before event
system discuss ways
extended to distinguish
distinguish concurrent events
events from events
relation the distributed
system was developed
characterize the behavior
behavior of distributed
found in fidge
babaoglu and marzullo
schwarz and mattern
first general algorithm
lamport s scheme
ricart and agrawala
proposed a distributed
algorithm that requires
messages their algorithm
18.2.2 a squareroot
algorithm for distributed
exclusion is described
described by maekawa
algorithm for rilcg-structured
rilcg-structured systems presented
systems presented ilc
presented ilc section
18.2.3 was developed
developed by lann
carvalho and roucairol
discusses mutual exclusion
exclusion in computer
agrawal and abbadi
describes an efficient
efficient and fault-tolerant
solution of distributed
exclusion a simple
taxonomy for distributed
distributed mutual-exclusion algorithms
algorithms is presented
presented by raynal
issue of distributed
synchronization is discussed
discussed by reed
reed and kanodia
totally disjoint processes
problem is presented
presented by chang
protocol was developed
lampson and sturgis
two modified versions
commit and presume
2pc by defilling
defilling default assumptions
fate of transactions
mohan and lindsay
problems of implementillg
implementillg the transaction
database were presented
spector and schwarz
offer comprehensive discussions
discussions of distributed
distributed concurrency control
concurrency control rosenkrantz
timestamp distributed deadlock-prevention
distributed deadlock-prevention algorithm
fully distributed deadlock-detection
distributed deadlock-detection scheme
deadlock-detection scheme presented
presented ill section
18.5.2 was developed
developed by obermarck
hierarchical deadlock-detection scheme
scheme of exercise
appears in menasce
menasce and muntz
surveys of deadlock
detection in distributed
distributed systems deadlocks
detected by takilcg
takilcg global snapshots
discussed ill chandy
chandy and lamport
byzantine generals problem
problem is discussed
presented by garcia-molina
system was written
written by larue
coverage of operating-system
general-purpose computing systems
systems with requirements
described a real-time
system that requires
deadline period results
period results produced
deadline has passed-even
passed-even if correct-may
traditional operating-system scheduling
operating-system scheduling algorithms
modified to meet
meet the stringent
stringent timing deadlines
deadlines a multimedia
multimedia data multimedia
data multimedia data
consist of continuous-media
conventional data continuous-media
data continuous-media data-such
demands of handling
handling continuous-media data
continuous-media data require
data require significant
notably in memory
desktop and server
turn our attention
attention to real-time
real-time computing systems
systems the requirements
requirements of real-time
real-time systems differ
largely because real-time
systems must produce
provide an overview
overview of real-time
real-time computer systems
systems and describe
describe how real-time
constructed to meet
stringent timing requirements
systems to explain
explain the timing
systems to distinguish
distinguish between hard
hard and soft
soft real-time systems
discuss the defining
characteristics of real-time
describe scheduling algorithms
algorithms for hard
hard real-time systems
deadline has passedeven
passedeven if correct-may
value to illustrate
robot that delivers
vision-control system identifies
identifies a wall
robot has walked
identifying the wall
met its requirement
contrast this timing
interactive desktop computer
desktop computer system
desirable to provide
provide a quick
timing requirements whatsoever
requirements whatsoever real-time
whatsoever real-time systems
real-time systems executing
executing on traditional
traditional computer hardware
applications in addition
embedded in specialized
ordinary home appliances
ovens and dishwashers
consumer digital devices
telephones and blackberry
blackberry handheld devices
present in larger
automobiles and airplanes
airplanes an embedded
user to illustrate
system for controlling
controlling a home
dishwasher the embedded
options for scheduling
scheduling the operation
dishwasher-the water temperature
type of cleaning
light or heavy
dishwasher is unaware
fact a computer
embedded system controlling
system controlling antilock
controlling antilock brakes
automobile each wheel
sliding and traction
traction are occurring
sensor continually sends
sends its data
system controller taking
taking the results
tells the braking
pressure to apply
embedded computer system
systems are real-time
real-time requirements whatsoever
whatsoever some real-time
systems are identified
identified as safety-critical
incorrect operation-usually due
missed deadline -results
sort of catastrophe
examples of safety-critical
safety-critical systems include
systems include weapons
include weapons systems
antilock brake systems
health-related embedded systems
system must respond
respond to events
injury-or worse-might occur
majority of embedded
qualify as safety-critical
including fax machines
missing deadline requirements
deadline requirements results
unhappy user real-time
user real-time computing
soft a hard
hard real-time system
guaranteeing that critical
critical realtime tasks
tasks be completed
deadlines safety-critical systems
typically hard real-time
systems a soft
soft real-time system
critical real-time task
task will receive
retain that priority
completes many commercial
linux-provide soft real-time
soft real-time support
explore the characteristics
systems and address
address issues related
related to designing
designing both soft
soft and hard
hard real-time operating
real-time operating systencs
characteristics are typical
single purpose small
purpose small size
size inexpensively mass-produced
inexpensively mass-produced specific
mass-produced specific timing
specific timing requirements
system typically serves
brakes or delivering
real-time system controlling
controlling an airliner
airliner s navigation
operating system reflects
reflects its single-purpose
simple many real-time
real-time systems exist
exist in environments
environments where physical
space is constrained
result of space
real-time systems lack
cpu processing power
standard desktop pcs
real-time systems run
gigabytes of physical
required to run
run the operating
memory is limited
found in home
appliances and consumer
consumer devices devices
thermostats are mass-produced
microprocessors for real-time
mass-produced one technique
technique for reducing
reducing the cost
technique for organizing
organizing the components
organizing the computer
mechanism intercom1ectin.g individual
intercom1ectin.g individual components
embedded system controllers
memorymouse keyboard printer
keyboard printer figure
attached peripheral ports
single integrated circuit
circuit the soc
typically less expensive
organization of figure
final characteristic identified
soft real-time operating
support the timing
issue real-time operating
operating systems meet
systems meet tim.ing
meet tim.ing requirements
algorithms that give
give real-time processes
processes the highest
highest schedulil1.g priorities
schedulers must ensure
addressing timing requirements
minimizing the response
discuss the features
supports real-time processes
typically not needed
system we begin
begin by examining
examining several features
operatil1.g systems discussed
windows these systems
systems typically provide
typically provide support
dvd drives protection
security mechanisms multiple
mechanisms multiple users
multiple users supporting
supporting these features
features often results
sophisticated -and large-kernel
forty million lines
lines of source
code in contrast
typical real-time operating
written in thousands
expect these simple
systems to il1.clude
il1.clude the features
nt real-time systems
real-time systems provide
crucial to standard
real-time systems serve
serve a single
features found il1
il1 a desktop
support a disk
drive or dvd
typical real-time system
include the notion
system simply supports
supports a small
input from hardware
supported by standard
standard desktop operating
desktop operating systems
systems are impossible
impossible to provide
provide without fast
processors and large
unavailable in real-time
real-time systems due
due to space
earlier in addition
realtime systems lack
systems lack sufficient
lack sufficient space
space to support
support peripheral disk
peripheral disk drives
drives or graphical
systems may support
support file systems
systems using nonvolatile
supporting features common
common in standard
translation in real-time
increase the cost
cost of real-time
make such systems
systems economically impractical
economically impractical additional
impractical additional considerations
additional considerations arise
real-time system providing
system providing virtual
providing virtual memory
virtual memory features
features as described
include a memory-management
mmus typically increase
cost and power
required to translate
miss-may be prohibitive
hard real-time environment
examine several approaches
approaches for translating
addresses in real-time
real-time systems figure
managing address translation
designers of real-time
generates logical address
bypass logical addresses
cpu generate physical
generate physical addresses
physical addresses directly
directly this teclmique-kn.own
teclmique-kn.own as real-addressing
mode-does not employ
employ virtual memory
problem with real-addressil1.g
absence of memory
protection between processes
processes real-addressing mode
require that programmers
programs are loaded
spent on address
address translation real-addressing
translation real-addressing mode
common in embedded
systems with hard
hard real-time constraints
constraints in fact
operating systems rum1.ing
rum1.ing on microprocessors
mmu actually disable
disable the mmu
mmu to gain
gain the performance
benefit of referencing
referencing physical addresses
strategy for translating
dynamic relocation register
relocation register shown
loaded the physical
generated by adding
adding the contents
real-time systems configure
configure the mmu
mmu to perform
easily translate logical
system still suffers
lack of memory
provide full virtual
full virtual memory
virtual memory functionality
functionality as described
address translation takes
translation takes place
place via page
tlb in addition
allowing a program
processes for systems
systems without attached
attached disk drives
features using nvram
nvram flash memory
memory the lynxos
systems are examples
examples of real-time
operating systems providing
systems providing full
providing full support
support for virtual
virtual memory keeping
keeping in mind
identify the features
implementing a real-time
systems provide fewer
provide fewer preemptive
priority-based scheduling preemptive
scheduling preemptive kernel
preemptive kernel minimized
kernel minimized latency
latency one notable
feature we omit
list is networking
support networking protocols
provide networking capabilities
system that gathers
gathers real-time data
data and transmits
include networking features
self-contained embedded system
embedded system requiring
requiring no interaction
obvious networking requirencent
examine the basic
basic requirements listed
system 19.4.1 priority-based
19.4.1 priority-based scheduling
requires the cpu
system must support
support a priority-based
algorithm with preemption
recall that priority-based
scheduling algorithms assign
assign each process
process a priority
assigned higher priorities
deemed less important
scheduler also supports
algorithms are discussed
discussed in detail
soft real-time scheduling
real-time scheduling features
systems assigns real-time
assigns real-time processes
highest scheduling priority
highest levelspriority values
reserved for real-time
real-time processes solaris
linux have similar
similar prioritization schemes
prioritization schemes note
providing a preemptive
scheduler only guarantees
guarantees soft real-time
soft real-time functionality
real-time functionality hard
functionality hard real-time
guarantee that real-time
serviced in accord
requirem ~ ents
making such guarantees
guarantees may require
require additional scheduling
additional scheduling features
cover scheduling algorithms
systems 19.4.2 preemptive
19.4.2 preemptive kernels
preemptive kernels nonpreemptive
kernels nonpreemptive kernels
nonpreemptive kernels disallow
kernels disallow preemption
cpu in contrast
kernel mode designing
mode designing preemptive
designing preemptive kernels
traditional user-oriented applications
require such quick
quick response times
commercial desktop operating
desktop operating systems-such
windows xp-are nonpreemptive
meet the timing
hard real-time systems-preemptive
real-time systems-preemptive kernels
kernels are mandatory
wait an arbitrarily
task was active
strategies for making
making a kernel
preemptible one approach
insert preemption points
points in long-duration
long-duration system calls
calls a preemption
preemption point checks
context switch takes
switch takes place
high-priority process terminates
interrupted process continues
system call preemption
call preemption points
strategy for making
data being updated
updated are protected
process 19.4.3 minimizing
19.4.3 minimizing latency
event in real
events may arise
expires-or in hardware-as
remote-controlled vehicle detects
approaching an obstruction
antilock brake system
wheel first detects
controlling the antilock
milliseconds to respond
control the situation
situation any response
response that takes
longer might result
automobile s veering
out of control
control in contrast
first occurs event
occurs event latency
event latency real-time
latency real-time system
real-time system responds
event latency system
latency system controlling
system controlling radar
airliner might tolerate
tolerate a latency
seconds two types
types of latencies
performance of real-time
interrupt latency dispatch
latency dispatch latency
dispatch latency interrupt
latency interrupt latency
interrupt latency refers
routine that services
services the interrupt
occursf the operating
executing and determine
interrupt that occurred
process before servicing
servicing the interrupt
specific interrupt service
total time required
perform these tasks
crucial for real-time
task t running
determine or interrupt
interrupt type owitocontiex
owitocontiex t interrupt
ish i figure
systems to minimize
minimize interrupt latency
latency to ensure
ensure that real-time
real-time tasks receive
receive immediate attention
attention one important
important factor contributing
contributing to interrupt
disabled while kernel
updated real-time operating
require that interrupts
interrupts be disabled
fact be bounded
bounded to guarantee
guarantee the deterministic
deterministic behavior required
required of hard
hard real-time kernels
kernels the amount
schedulil g dispatcher
dispatch latency providing
latency providing real-time
providing real-time tasks
mandates that real-time
operating systems minimize
minimize this latency
technique for keeping
keeping dispatch latency
dispatch latency low
provide preemptive kernels
kernels in figure
diagram the makeup
makeup of dispatch
latency the conflict
phase of dispatch
release by low-priority
processes of resources
latency with preemption
milliseconds with preemption
millisecond one issue
affect dispatch latency
dispatch latency arises
beil g accessed
processes as kernel
kernel event response
response to event
event ~ --------response
process made interrupt
interrupt available processing
----1 ~ _....
_.... time figure
dispatch latency real-time
latency real-time process
real-time process execution
resource r howevet
lower priority -process
priority -process m-has
-process m-has affected
protocol allows process
relinquishes its inherited
assumes its original
priority as resource
process h -not
coverage of scheduling
primarily on soft
systems as mentioned
preference over noncritical
noncritical processes hard
processes hard real-time
systems have stricter
requirements a task
deadline ; service
deadline has expired
scheduling for hard
define certain characteristics
processes are considered
cpu at constant
fixed processing timet
acquires the cpu
period1 d period2
task time period3
illustrates the execution
relationship and assign
deadline or rate
form of scheduling
announce its deadline
scheduler either admits
admits the process
process will complete
rejects the request
request as impossible
explore scheduling algorithms
algorithms that address
address the deadline
requirements of hard
systems 19.5.1 rate-monotonic
19.5.1 rate-monotonic scheduling
scheduling the rate-monotonic
rate-monotonic scheduling algorithm
scheduling algorithm schedules
algorithm schedules periodic
schedules periodic tasks
static priority policy
policy with preemption
preempt the lower-priority
process upon entering
entering the system
task is assigned
assigned a priority
priority inversely based
period the shorter
shorter the period
longer the period
priority the rationale
assign a higher
priority to tasks
tasks that require
rate-monotonic scheduling assumes
complete its cpu
schedule these tasks
meets its deadlines
measure the cpu
-the cpu utilization
total cpu utilization
meet their deadlines
leave the cpu
suppose we assign
first and completes
completes its cpu
scheduler has caused
miss its deadline
deadline now suppose
scheduling of tasks
figure 19.8 rate-monotonic
19.8 rate-monotonic scheduling
scheduling the execution
meeting its first
deadline p2 starts
point and runs
burst p1 completes
point the scheduler
deadline the system
system is idle
scheduled again rate-monotonic
scheduling is considered
algorithm that assigns
assigns static priorities
examine a set
rate-monotonic algorithm assume
scheduling would assign
period the total
shows the scheduling
running and n.ms
cpu burst process
process p1 n.ms
misses the deadline
deadline for completion
utilization is bounded
maximize cpu resources
resources the worst-case
worst-case cpu utilization
utilization for scheduling
scheduling n processes
percent combined cpu
combined cpu utilization
two processes scheduled
scheduled in figures
algorithm is guaranteed
guaranteed to schedule
deadlines with rate-monotonic
scheduled in figure
deadlines 19.5.2 earliest-deadline-first
19.5.2 earliest-deadline-first scheduling
earliest-deadline-first scheduling earliest-deadline-first
scheduling dynamically assigns
dynamically assigns priorities
deadline the earlier
earlier the deadline
process becomes runnable
adjusted to reflect
reflect the deadline
newly rmmable process
rmmable process note
differs from rate-monotonic
priorities are fixed
fixed to illustrate
illustrate edf scheduling
schedule the processes
meet deadline requirements
requirements under rate-monotonic
rate-monotonic scheduling recall
priority is higher
process p2 process
process p2 begins
scheduling allows process
meet their first
first deadlines process
meeting its deadline
unlike the rate-monotonic
require that processes
processes be periodic
require a constant
a1mom1ce its deadline
runnable the appeal
appeal of edf
process can meet
meet its deadline
requirements and cpu
percent in practice
impossible to achieve
achieve this level
level of cpu
cpu utilization due
cost of context
switching between processes
processes and interrupt
interrupt handling deadlines
19.5.3 proportional share
proportional share scheduling
share scheduling proportional
scheduling proportional share
proportional share schedulers
share schedulers operate
operate by allocating
allocating t shares
applications an application
application can receive
receive n shares
shares of timef
timef thus ensuring
shares this scheme
percent o total
percent proportional share
schedulers must work
work in conjunction
admission control policy
policy to guarantee
receives its allocated
admit a client
number of shares
shares if sufficient
process d requested
controller would deny
deny d entry
system 19.5.4 pthread
19.5.4 pthread scheduling
scheduling the posix
pthread api related
related to scheduling
scheduling real-time threads
real-time threads pthreads
threads pthreads defines
defines two scheduling
classes for real-time
sched __fifo sched_rr
__fifo sched_rr sched__fifo
sched_rr sched__fifo schedules
sched__fifo schedules threads
queue as outlined
slicing among threads
highest-priority real-time thread
granted the cpu
terminates or blocks
sincilar to sched_fifo
equal priority pthreads
class-scheddther-but its implementation
implementation is undefined
undefined and system
systems the pthread
pthread api specifies
setting the scheduling
current scheduling policy
function both functions
functions return non-zero
return non-zero values
policy ; pthread_t
unable to set
api this program
determines the current
sets the scheduling
algorithm to scheddther
popular real-time operating
providing hard real-time
hard real-time support
real-time support vxworks
developed by wind
wind river systems
consumer and industrial
rovers-spirit and opportunity-that
opportunity-that began exploring
exploring the planet
organizationofvxworks is shown
vxworks is centered
wind microkernel recall
discussion in section
2.7.3 that microkernels
microkernels are designed
features ; additional
provided in libraries
offers many benefits
minimizing the size
kernel-a desirable feature
requiring a small
footprint the wind
wind microkernel supports
processes the wind
microkernel provides support
support for individual
similar to linux
tasks embedded real-time
embedded real-time application
real-time application figure
organization of vxworks
operating .systent isbe
incre ~ singlyinreai-time
enviroft ~ ments.yve
hav ~ alreadycovered
alreadycovered its softr
softr ~ fil-ti,nteschedv,ling.fe
fil-ti,nteschedv,ling.fe ~ tur
,whereby real-time tasl
real-time tasl sareassignt
sareassignt ; d.thehj.ghe
d.thehj.ghe ~ tpriorityi
release ofthe kernel
ofthe kernel makelinux
kernel makelinux even,more
makelinux even,more suitilb
suitilb le fot
fot .embedded systems
.embedded systems thes
fullr pree ptive
pree ptive kernel
tinte regardless ofthe
arc ~ itecttlresbydi
itecttlresbydi \ tlcljng
tlcljng another strategy
integrah1lg linux iftto
linux iftto reanill1e
iftto reanill1e .envirof
operat ~ s,.systt
s,.systt ; it1
vith a mallreal-.ti
mallreal-.ti ! fle
fle ~ ernet
tht ; reby
cts as botl
real-tipte ~ ystem
ystem this .is
ppt ; rat
systerrl in .rtlinux
standard lirn.tx kernel
lirn.tx kernel run
real ~ htt1eikerllelj
alliftterrupts.-,-directing each interrupt
ndarclkerrtel.or to anintef
anintef ~ rupt.randler
prevents the shtndar
shtndar \ i.linuxkernel
difft ; rent
schec1ul ~ j1g
earliest ~ deadline-first
scheduling the wind
two separate scheduling
separate scheduling models
scheduling and nonpreemptive
nonpreemptive round-robin scheduling
levels the scheduler
supports the posix
api for real-time
section 19.5.4 interrupts
interrupts the wind
microkernel also manages
interrupts to support
support hard real-time
hard real-time requirements
interrupt and dispatch
dispatch latency times
times are bounded
bounded interprocess communication
communication the wind
wind micro kernel
passing as mechanisms
mechanisms for communication
communication between separate
tasks to communicate
mechanism that behaves
communicate by writing
fik the pipe
pipe to protect
protect data shared
shared by separate
vxworks provides semaphores
semaphores and mutex
priority inheritance protocol
prevent priority mversion
microkernet vxworks includes
includes several component
libraries that provide
allowing the designer
system to customize
customize the system
system this strategy
include only required
minimizing the size-or
footprint-of the operating
operating system vxworks
system vxworks takes
takes an interesting
approach to memory
supporting two levels
levels of virtual
basis this policy
pages as non-cacheable
non-cacheable when data
separate tasks running
data can reside
reside in separate
separate caches local
local to individual
supports a cache-coherency
policy to ensure
maintain a consistent
level of virtual
virtual memory requires
requires the optional
optional virtual memory
virtual memory component
memory component vxvmi
component is loaded
task to mark
mark certain data
areas as private
private a data
data area marked
marked as private
task it belongs
vxworks allows pages
pages containing kernel
declared as read-only
giving an application
entire address space
system a real-time
computer system requiring
requiring that results
period ; results
deadline has passed
passed are useless
useless many real-time
systems are embedded
embedded in consumer
types of real-time
real-time systems soft
systems soft real-time
assigning real-time tasks
real-time tasks higher
tasks higher scheduling
higher scheduling priority
tasks hard real-time
systems must guarantee
tasks are serviced
periods in addition
addition to strict
strict timing requirements
purpose and running
running on small
devices to meet
meet timing requirements
systems must employ
employ various techniques
techniques the scheduler
higher-priority real-time tasks
real-time tasks real-time
tasks real-time operating
systems also address
address specific timing
specific timing issues
issues by minimizing
minimizing both interrupt
latency real-time scheduling
real-time scheduling algorithms
scheduling algorithms include
algorithms include rate-monotonic
rate-monotonic and earliestdeadline
earliestdeadline first scheduling
first scheduling rate-monotonic
scheduling rate-monotonic scheduling
rate-monotonic scheduling assignb
scheduling assignb tasks
priority than tasks
earliest-deadline-first scheduling assigns
scheduling assigns priority
upcoming deadlines-the earlier
priority proportional share
technique of dividing
dividing up processor
shares and assigning
assigning each process
process a number
guaranteeing each process
process its proportional
share of cpu
features for scheduling
explain why interrupt
identify whether hard
hard or soft
household b control
nuclear power plant
plant c fuel
fuel economy system
automobile d landing
processes be scheduled
scheduled using rate-monotonic
rate-monotonic scheduling illustrate
illustrate your answer
19.7-19.10 b illustrate
illustrate the scheduling
processes using earliestdeadline
system also discuss
proportional share scheduler
circumstances is rate-monotonic
rate-monotonic scheduling inferior
inferior to earliest-deadline-first
scheduling in meeting
meeting the deadlines
processes the scheduling
rate monotonic scheduling
scheduling and earliest-deadline-first
presented in liu
operating systems handle
systems handle conventional
handle other kinds
kinds of data
conventional files continuous-media
files continuous-media data
continuous-media data differ
demands of continuous-media
affect the design
multimedia systems chapter
systems chapter objectives
objectives to identify
identify the characteristics
characteristics of multimedia
data to examine
examine several algorithms
compress multimedia data
data to explore
explore the operating
cpu and disk
scheduling and network
multimedia the term
term multimedia describes
mp3 audio files
applications also include
include live web
live web casts
including personal digital
delivered in real
explore several characteristics
systems and examine
examine how multimedia
standards for representing
video and audio
files 20.1.1 media
20.1.1 media delivery
media delivery multimedia
delivery multimedia data
data the major
accessing the regular
regular file requires
video is represented
series of images
displayed in rapid
succession the faster
faster the frames
frames are displayed
smoother the video
appears in general
smooth to human
retains the image
presentation the video
requirements as multimedia
delivery as examples
examples include watching
watching a dvd
computer or listening
mp3 audio file
handheld mp3 player
comprise a regular
system and played
viewed or listened
system multimedia files
server and delivered
cellular telephone data
data from live
live continuous media
continuous media -such
-such as live
live webcams -are
-are also streamed
server to clients
types of streaming
download and real-time
file containing audio
video is downloaded
downloaded and stored
client s local
back the media
small media files
video clips differs
differs from progressive
file is streamed
-and not stored
-by the client
streaming is preferable
preferable to progressive
download for media
videos and internet
broadcasts both progressive
client to move
fast-forward and rewind
controller to move
5-minute streaming video
video or replay
clip the ability
ability to move
streaming and ondemand
deliver an event
occurring a radio
radio program broadcast
live real-time stream
stream in fact
text regularly listens
favorite radio station
station from vermont
home in utah
internet live real-time
live real-time streaming
webcams and video
video conferencing due
type of real-time
clients random access
stream in addition
live delivery means
client who wishes
wishes to view
progress will join
join the session
missing earlier portions
missed the first
broadcast on-demand streaming
deliver media streams
movies and archived
lectures the difference
difference between live
live and on-demand
event is occurring
watching a live
watching a news
watching an on-demand
viewing a movie
notion of arriving
arriving late depending
type of on-demand
examples of well-known
well-known streaming media
streaming media products
media products include
products include realplayer
windows media player
player these products
include both servers
servers that stream
stream the media
media and client
client media players
playback 20.1.2 characteristics
systems the demands
systems are unlike
unlike the demands
demands of traditional
applications in general
100-minute mpeg-1 video
mpeg-1 video file
video file requires
1.125gb of storage
minutes of high-defuution
storage a server
server storing hundreds
thousands of digital
digital video files
require several terabytes
terabytes of storage
storage continuous media
media may require
require very high
high data rates
rates consider digital
frame of color
video is displayed
bits to represent
represent the color
bandwidth in excess
mbps is required
required multimedia applications
applications are sensitive
sensitive to timing
delays during playback
file is delivered
delivery must continue
rate during playback
listener or viewer
subjected to pauses
presentation 20.1.3 operating-system
20.1.3 operating-system issues
system to deliver
deliver continuous-media data
guarantee the specific
rate and timing
requirements-of continuous media
continuous media providing
providing these qos
qos guarantees affects
affects several components
system and influences
influences such operating-system
issues as cpu
network management specific
management specific examples
specific examples include
compression and decoding
decoding may require
require significant cpu
significant cpu processing
cpu processing multimedia
processing multimedia tasks
priorities to ensure
meeting the deadline
requirements of continuous
efficient to meet
meet the rate
continuous media network
media network protocols
protocols must support
support bandwidth requirements
requirements while minimizing
delay and jitter
related to qos
techniques for compressing
compressing multimedia data
data as suggested
compression makes significant
makes significant demands
size and rate
space for storage
client more quickly
content is beilcg
cormection in discussing
discussing file compression
original file size
accessed a feature
compress the file
decompression compression algorithms
algorithms are classified
file is decoded
lossless compression ensures
form in generat
generat lossy techniques
lossy techniques provide
provide much higher
higher cone pression
cone pression ratios
data can tolerate
tolerate lossy compression-namely
video lossy compression
lossy compression algorithms
algorithms often work
work by eliminating
eliminating certain data
high or low
detect some lossy
operate by storing
differences between successive
successive frames lossless
frames lossless algorithms
compressing text files
restore these compressed
lossy compression schemes
schemes for continuous-media
moving picture experts
picture experts group
mpeg mpeg refers
set of file
formats and compression
standards for digital
video because digital
standards is divided
media file layer
player to multiplex
multiplex the audio
synchronized during playback
major mpeg standards
stream the resolution
quality slightly lower
conventional vcr videos
vcr videos mp3
videos mp3 audio
mpeg-1 for video
mpeg-1 can achieve
achieve a compression
practice compression ratios
require high data
download short video
compressing dvd movies
movies and digital
including high-definition television
identifies a number
number of levels
levels and profiles
profiles of video
compression the refers
characterizes the video
video s quality
quality in general
higher the level
level of resolution
higher the required
required data rate
data rate typical
rate typical bit
typical bit rates
mpeg-2 encoded files
mpeg-2 requires higher
requires higher rates
lmsuitable for delivery
delivery of video
two-dimensional and three-dimensional
three-dimensional animation layers
animation layers animation
layers animation makes
users to interact
file during playback
potential home buyer
buyer can download
moving from room
room to room
chooses another appealing
level of quality
slow network connections
56-i bps modems
high-speed local area
local area networks
networks with rates
providing a scalable
delivered to wireless
including handheld computers
mpeg standards discussed
discussed here perform
perform lossy compression
compression to achieve
achieve high compression
high compression ratios
ratios the fundamental
idea behind mpeg
store the differences
cover further details
mpeg performs compression
encourage the interested
reader to consult
applications often require
levels of service
system that differ
requirements of traditional
tin1.ing and rate
issues of foremost
playback of audio
video data demands
data be delivered
fixed rate traditional
rate traditional applications
rate constraints tasks
tasks that request
data at constant
video might require
require a rate
maintaining this rate
frame be delivered
context of deadlines
assume that frame
frame f1 succeeds
deadline for displaying
unable to display
display the frame
stream as mentioned
requirements and deadlines
quality of service
makes a best-effort
attempt to satisfy
satisfy the requirements
guarantees are made
made this level
treats different types
types of traffic
giving certain traffic
traffic streams higher
streams higher priority
made the quality-of-service
requirements are guaranteed
guaranteed traditional operating
traditional operating systems-the
operating systems-the systems
provide only best-effort
amount of resources
workload would demand
demand if demand
demand exceeds resource
exceeds resource capacity
system however next-generation
next-generation multimedia systems
make such assumptions
assumptions these systems
provide continuous-media applications
explore various techniques
techniques that enable
enable multimedia systems
systems to provide
provide such service-level
number of parameters
parameters defining qos
qos for multimedia
interval for multimedia
request is first
result is produced
requests a media
stream is delivered
jitter is related
related to delay
client must wait
wait to receive
receive a stream
refers to delays
delays that occur
occur during playback
stream certain multimedia
on-demand real-time streaming
tolerate this sort
sort of delay
generally considered unacceptable
unacceptable for continuous-media
long pauses-or lost
pauses-or lost frames-during
lost frames-during playback
frames-during playback clients
compensate for jitter
jitter by buffering
amount of data-say
seconds  worth-before
worth-before beginning playback
beginning playback reliability
playback reliability refers
errors are handled
handled during transmission
transmission and processing
processing of continuous
continuous media errors
due to lost
network or processing
cpu in these-and
packets typically arrive
arrive too late
levels of quality
higher the quality
rate a client
client may negotiate
negotiate a specific
specific data rate
quality during playback
client to configure
configure the player
client s connection
client to receive
receive a streaming
data rate specific
client is negotiating
provider to provide
provide qos guarantees
simply the practice
practice of admitting
admitting a request
server has sufficient
resources to satisfy
theater only admits
situations in everyday
life where admission
system becomes unable
unable to meet
meet its qos
guarantees in chapter
discussed using semaphores
implementing a simple
simple admission-control policy
exist a finite
number of nonshareable
resource is requested
semaphores to implement
implement an admission-control
policy by first
initializing a semaphore
resource is made
resource is released
invocation of signal
server a common
implementing admission control
server may include
include the cpu
note that resources
exclusive or shared
single or multiple
client must make
make a reservation
resource il1 advance
reservation is denied
denied an admission-control
admission-control scheme assigns
type of resource
required data rates
resource manager determines
resource can meet
meet the qos
level of qos
request is accepted
resource manager reserves
reserves the resources
assuring the client
desired qos requirements
met in section
examine the admission-control
ensure qos guarantees
cineblitz multimedia storage
multimedia storage server
covers real-time systems
systems simply give
simply give scheduling
give scheduling priority
priority to critical
processes a soft
real-time system ensures
scheduled a typical
requirement of continuous
deadline ; data
deadline are unusable
unusable multimedia systems
systems thus require
require hard real-time
hard real-time scheduling
scheduling to ensure
withii1 a guaranteed
scheduling issue concerns
distinction first discussed
process will remain
static priority scheduling
algorithms that assign
assign dynamic priorities
priorities allow priorities
priorities to change
systems use dynamic
priorities when scheduling
scheduling non-real-time tasks
intention of giving
giving higher priority
priority to interactive
scheduling real-time tasks
systems assign static
assign static priorities
real-time scheduling strategies
scheduling strategies discussed
rate and deadline
deadline qos requirements
requirements of continuous-media
first discussed disk
discussed disk scheduling
scheduling in chapter
primarily on systems
systems that handle
goals are fairness
traditional disk schedulers
disk schedulers employ
employ some form
algorithn l continuous-media
constraints that conventional
conventional data files
deadlines and rate
satisfied to preserve
preserve qos guarantees
conflict continuous-media files
files typically require
high disk-bandwidth rates
rates to satisfy
satisfy their data-rate
requirements because disks
low transfer rates
high latency rates
schedulers must reduce
reduce the latency
times to ensure
ensure high bandwidth
reducing latency times
times may result
explore two diskscheduling
two diskscheduling algorithms
algorithms that meet
requirements for continuous-media
systems 20.5.1 earliest-deadline-first
20.5.1 earliest-deadline-first scheduling
presented the earliest-deadline-first
queue to order
edf is similar
similar to shortest-seek-time-first
deadline is serviced
first a problem
deadline may result
result in higher
higher seek tim.es
heads may move
suppose a disk
queue of cylinders
strict edf scheduling
head will move
passes over cylinder
serviced the request
route to cylinder
preserved the deadline
requirement for cylinder
20.5.2 scan-edf scheduling
scheduling the fundamental
problem with strict
ignores the position
heads will swil
leading to unacceptable
unacceptable seek times
negatively affect disk
affect disk throughput
disk throughput recall
faced with fcfs
context of cpu
address this issue
issue by adopting
adopting scan schedulil
whereil the disk
disk arm reaches
reaches the end
direction this strategy
strategy optimizes seek
optimizes seek times
seek times scan-edf
algorithm that combines
edf with scan
scan scheduling scan-edf
scheduling scan-edf starts
starts with edf
ordering but services
usil g scan
scan-edf may batch
ordering to service
techniques for batching
requests with similar
prevent a request
deadline if deadlines
organized in groups
requests per batch
batch another approach
requests whose deadlines
followil g requests
head is moving
moving toward cylinder
last batch requests
first service request
request d note
downward in cylinder
heads begin moving
begin moving upward
upward in cylinders
servicing requests hand
foremost qos issue
issue with multimedia
multimedia systems concerns
systems concerns preserving
concerns preserving rate
preserving rate requirements
view a video
service greatly depends
system s ability
ability to deliver
deliver the frames
rate our coverage
coverage of issues
cpu and disk-scheduling
algorithms has focused
meet the quality-ofservice
network-perhaps the internet-issues
delivers the multimedia
affect how qos
demands are met
explore several network
network issues related
demands of continuous
noting that computer
networks in general
-and the internet
internet in particular
provide network protocols
ensure the delivery
delivery of data
data with timing
protocols-notably those running
running on cisco
prioritized to meet
meet qos requirements
requirements such proprietary
data are routed
transmission will encounter
network traffic issues-issues
data for multimedia
delivering the content
playing it back
back one protocol
protocol that addresses
addresses timing issues
standard for delivering
delivering real-time data
transporting media formats
files and video
video files compressed
compressed using mpeg
provide any qos
guarantees ; rathe1
receiver to remove
remove jitter introduced
introduced by delays
delays and congestion
two other approaches
approaches for handling
handling the unique
media 20.6.1 unicasting
unicasting and multicasting
multicasting in general
methods for delivering
delivers the content
server must establish
establish a separate
,  nh
receive the content
group of receivers
unicasting and broadcasting
broadcasting an issue
issue with unicast
separate unicast session
wasteful for live
server must make
make several copies
receive the stream
server to deliver
deliver a single
difficulty with multicasting
routers that relay
relay the content
client must cross
cross intermediate routers
incurred during routing
routing may result
result in violation
client is connected
unable to receive
receive the multicast
media are delivered
delivered across unicast
server and clients
connected to multicasting
reasonable physical proximity
routers the organization
deliver a presentation
chief executive officer
officer using multicasting
multicasting 20.6.2 real-time
20.6.2 real-time streaming
real-time streaming protocol
protocol in section
described some features
features of streaming
access a media
replaying or pausing
answer this question
clients one approach
standard web server
hypertext transport protocol
play media streamed
client first requests
uniform resource locatm
streaming media file
file this metafile
metafile is delivered
client s web
browser then starts
type of media
real audio stream
stream would require
require the realplayer
play back streaming
back streaming windows
streaming windows media
media the media
player then contacts
contacts the web
server and requests
requests the streaming
media the stream
conventional web server
server is delivered
player using standard
standard http requests
requests this process
process is outlined
outlined in figure
problem with delivering
delivering streaming media
http is considered
considered a protocol
maintain the state
client to pause
delivery of streaming
streaming media content
pausing would require
require the web
stream to begin
wished to resume
playback an alternative
specifically for streaming
media one protocol
designed for communication
communication between streaming
servers and media
significant advantage rtsp
pause or seek
seek to random
media using rtsp
rtsp is similar
similar to delivery
delivery using http
media is delivered
protocol the operation
operation of rtsp
rtsp is shown
defines several commands
commands as part
rtsp streaming server
server the commands
server allocates resources
delivers a stream
client session established
command the server
server suspends delivery
stream but maintains
maintains the resources
session the server
connection and frees
frees up resources
states are triggered
client using rtsp
http for streaming
streaming media offers
related to networking
text we encourage
encourage interested readers
readers to consult
chapter for sources
information the cineblitz
server that supports
supports both continuous
media with rate
text and images
refers to clients
clients with rate
rate constraints cine
constraints cine blitz
cine blitz guarantees
guarantees to meet
clients by implementing
implementing an admission
admitting a client
explore the cineblitz
disk-schedulu1.g and admission-control
admission-control algorithms setup
algorithms setup play
setup play tear
tear down pause
finite-state machine representing
machine representing rtsp
20.7.1 disk scheduling
scheduling the cineblitz
cineblitz disk scheduler
disk scheduler services
scheduler services requests
discussions of c-scan
disk heads move
reach the end
pure scan disk
disk 20.7.2 admission
20.7.2 admission control
control the admission-control
algorithm in cil
eblitz must monitor
real-time and non-real-time
classes of clients
clients receive service
controller must provide
provide the rate
rate guarantees required
required by real-time
clients to ensure
explore the admission
controller for real-time
term client refers
client the admission
controller in cineblitz
monitors various system
bandwidth and disk
space the cineblitz
cineblitz admission controller
admission controller admits
admits a client
bandwidth and buffer
space to retrieve
required rate cineblitz
rate cineblitz queues
cineblitz queues requests
requests for continuous
continuous media files
request r requests
queue are served
served in cyclic
order in rounds
rounds of time-length
measured in seconds
retrieve the data
client this process
process is illustrated
total buffer space
space b required
fundamental idea behil
requests for entry
estimated a request
request is admitted
estimated service times
exceed the duration
duration of service
cycle t lett
bits be retrieved
clients currently active
controller must ensure
f---1 double buffer
double buffer total
buffer total buffer
buffering in cinebiitz
disk blocks thatcanberetrievedforrequest
blocks thatcanberetrievedforrequest r1c
thatcanberetrievedforrequest r1c duringeachcycleis
bits to span
span the last
causing two blocks
disk block involves
contailling the block
desired track arrive
head as described
c-scan disk-scheduling algorithm
blocks are retrieved
disk if tscek
tscek and trot
seek and rotational
rotational delay times
maximum latency incurred
incurred for servicil1g
servicil1g n requests
tseek component refers
maximum disk-seek latency
disk-seek latency incurred
reflects the sum
disk blocks multiplied
worst-case rotational delay
data for request
bits for requests
sum of equation
cineblitz only admits
bits of free
free buffer space
equation is satisfied
systems multimedia files
multimedia files include
files include video
delivered to systems
desktop computersf personal
computersf personal digital
personal digital assistantsf
assistantsf and cell
phones the primary
distinction between multimedia
data and conventional
data have specific
deadline requiren ents
ents because multimedia
files have specific
specific timing requirementsf
requirementsf the data
compressed before delivery
client for playback
playback multimedia data
streaming the timing
qualityof service requirementsf
requirementsf and conventional
make quality-of-service guarantees
guarantees to provide
quality of servicef
servicef multimedia systems
provide a form
form of admission
accepts a request
meet the quality-of-service
request providing quality-of-service
providing quality-of-service guarantees
quality-of-service guarantees requires
guarantees requires evaluating
operating system performs
system performs cpu
performs cpu schedulingf
cpu schedulingf disk
schedulingf disk schedulingf
schedulingf and network
management both cpu
scheduling criterion network
criterion network management
network management requires
protocols that handle
allowing a client
pause or move
stream during playback
traditional internet protocols
protocols for transmitting
sufficient to provide
provide the quality-of-service
quality-of-service guarantees required
multimedia system discuss
provide the qos
contrast unicastingf multicastingf
multicastingf and broadcasting
broadcasting as techniques
techniques for delivering
compress a digital
digital video file
technology the target
target bit rate
represent each colorf
ratio to achieve
achieve the desired
desired bit rate
represent each color
deliver this file
file next assuming
deliver the compressed
multimedia application consists
minutes of videof
minutes of audio
audio the compressed
videof and audio
images were compressed
audio were compressed
audio before compression
real-time streaming applications
applications can tolerate
tolerate jitter live
jitter live real-time
real-time streaming on-demand
streaming on-demand real-time
distinguish between progressive
number of requests
deadlines and cylinders
requests with deadlines
batched the disk
scan-edf disk scheduling
order of requests
cine blitz system
system in performing
performing admission control
control for requests
requests for media
chart b illustrate
illustrate the schedulil1.g
overview of multimedia
multimedia systems topics
systems topics related
multimedia through networks
found in kurose
support for multimedia
multimedia is discussed
discussed in steinmetz
management for resources
capability and memory
buffers is discussed
discussed in mercer
druschel and peterson
reddy and wyllie
give a good
overview of issues
multimedia system discussions
model for developing
developing multimedia applications
applications are presented
presented in regehr
admission control system
scheduler is considered
considered in lauzac
present a system
system for serving
serving video data
data and discuss
discuss the schedule-management
details of part
book by describing
two such systems
systems are covered
covered in great
detaiilinux and windows
represents a full-featured
full-featured unix system
student of operating
systems an opportunity
opportunity to read-and
read-and modifyrea operating-system
modifyrea operating-system source
operating-system source code
detail this recent
recent operating system
system from microsoft
microsoft is gaining
market we chose
highly influential operating
chosen the order
order of presentation
presentation to highlight
highlight the similarities
similarities and differences
reflect the relative
provide on-line coverage
systems the freebsd
linux combines features
freebsd is based
model of unix
unix freebsd source
freebsd source code
compatibility with bsd
bsd unix windows
microsoft for intel
compatible with ms-dos
ms-dos and microsoft
microsoft windows applications
presents an in-depth
system by exam.ining
exam.ining a complete
popularity in recent
history and development
development of linux
linux and cover
cover the user
interfaces that linux
owe a great
discuss the internal
implements these interfaces
rapidly evolving operating
evolving operating system
system this chapter
chapter describes developments
released in late
explore the history
linux is derived
designed to examine
examine the linux
linux process model
model and illustrate
illustrate how linux
linux schedules processes
management in linux
linux to explore
explore how linux
implements file systems
systems and manages
major design goal
systems its development
wrote and christened
small but self-contained
true 32-bit processor
processor in intel
intel s range
range of pc-compatible
code was made
made available free
linux s history
implemented a small
unix system services
system has grown
grown to include
include much unix
linux development revolved
operating-system kernel-the core
executive that n1.anages
n1.anages all system
kernel to produce
produce a full
full operating systeitl
make the distinction
developed from scratch
includes a multitude
multitude of components
written from scratch
created in collaboration
teams the basic
basic linux system
environment for applications
applications and user
enforce any standard
means of managing
linux has matured
layer of functionality
functionality on top
distributions a includes
set of administrative
tools to simplify
simplify the initial
installation and subsequent
upgrading of linux
installation and removal
system a modern
typically includes tools
tools for management
management of file
management of user
administration of networks
21.1.1 the linux
kernel the first
first linux kernel
linux kernel released
public was version
80386-compatible intel processors
extremely limited device-driver
limited device-driver support
support the virtual
basic and included
included no support
support for memorymapped
early incarnation supported
incarnation supported shared
supported shared pages
pages with copy-on-write
file system supported
minix file system
file system -the
-the first linux
first linux kernels
kernels were cross-developed
kernel did implement
implement proper unix
proper unix processes
processes with protected
protected address spaces
released on march
culminated three years
years of rapid
biggest new feature
feature was networking
support for unix
unix s standard
standard tcp lip
tcp lip networking
lip networking protocols
bsd-compatible socket interface
interface for networking
networking programming device-driver
programming device-driver support
support was added
added for running
ppp or slip
lines or modems
kernel also included
enhanced file system
original minix file
system and supported
supported a range
range of scsi
controllers for high-performance
high-performance disk access
access the developers
extended the virtual
subsystem to support
paging to swap
mapping of arbitrary
read-only memory mapping
mapping was implemented
range of extra
extra hardware support
intel pc platform
support had grown
floppy-disk and cd-rom
range of mice
international keyboards floating-point
keyboards floating-point emulation
emulation was provided
coprocessor ; system
system v unix-style
unix-style inclllding shared
inclllding shared memory
implemented simple support
loadable and unloadable
unloadable kernel modules
modules was supplied
numerous bug-fix patches
patches were released
pattern was adopted
standard numbering convention
convention for linux
linux kernels kernels
odd minor-version number
evennumbered minor-version numbers
numbers are stable
kernels are intended
kernels may include
functionality in march
kernel was released
released this release
improvement in functionality
pci hardware bus
hardware bus architecture
bus architecture developers
architecture developers added
added another pc-specific
cpu s virtual8086
mode-to allow emulation
dos operating system
updated the networking
stack to provide
protocol and made
implementation more complete
complete by including
accounting and firewalling
final pc-only linux
pc-only linux kernel
kernel the source
distribution for linux
included partially implemented
partially implemented support
support for sparc
released the linux
concentrated on wider
wider hardware support
implementations of existing
main kernel source
kernel this work
released as linux
major version-number increment
increment on account
major new capabilities
including a 64-bit
64-bit native alpha
native alpha port
support for multiprocessor
multiprocessor architectures linux
architectures linux distributions
linux distributions based
motorola 68000-series processors
systems a derived
version of linux
microkernel also runs
improved to provide
provide a unified
cache for file-system
file-system data independent
caching of block
offered greatly increased
greatly increased file-system
file-system and virtual
virtual memory performance
caching was extended
extended to networked
writable memory-mapped regions
included much improved
protocols were added
including apple talk
ax.25 anlateur radio
anlateur radio networking
support the ability
ability to mount
mount remote netware
netware and smb
volumes was added
added other major
support for internal
internal kernel threads
dependencies between loadable
loading of modules
modules on demand
demand dynamic configuration
kernel at run
standardized configuration interface
additional new features
features included file-system
included file-system quotas
quotas and posix-compatible
posix-compatible real-time process-scheduling
real-time process-scheduling classes
process-scheduling classes improvements
classes improvements continued
release of linux
port for ultrasparc
systems was added
networking was enhanced
routing and traffic
support for tcp
tcp large window
window and selective
selective acks acorn
nfs was enhanced
kernel-mode nfs daemon
nfs daemon added
daemon added signal
added signal handling
i were locked
improve symmetric multiprocessor
kernel include increased
include increased support
journaling file systems
system the process
scheduler was modified
modified in version
providing an efficient
preempted while running
21.1.2 the linux
linux kernel forms
forms the core
complete linux operating
kernel is composed
software that makes
exclusive to linux
number of unix-like
unix-like operating systems
developed as part
part of berkeley
berkeley s bsd
bsd operating system
foundation s gnu
project this sharing
sharing of tools
tools has worked
directions the main
main system libraries
libraries of linux
linux were originated
community greatly improved
improved the libraries
libraries by addressing
bugs other components
sufficiently high quality
directly in linux
linux the networkingadministration
tools under linux
linux were derived
derived from code
code first developed
recent bsd derivatives
code from linux
linux in return
return examples include
include the intel
intel floating-point-emulation math
floating-point-emulation math library
sound-hardware device drivers
drivers the linux
network of developers
groups or individuals
individuals having responsibility
responsibility for maintaining
maintaining the integrity
integrity of specific
components a small
number of public
public internet file-transfer-protocol
archive sites act
facto standard repositories
components the document
means of ensuring
components this standard
directory names configuration
names configuration files
run-time data files
stored 21.1.3 linux
21.1.3 linux distributions
distributions in theory
install a linux
system by fetching
fetching the latest
sites and compiling
linux s early
out as linux
individuals and groups
groups have attempted
attempted to make
make this job
job less painful
painful by providing
sets of packages
packages for easy
installation these collections
typically include extra
include extra system-installation
system-installation and management
precompiled and ready-to-install
common unix tools
text-processing and editing
games the first
first distributions managed
managed these packages
providing a means
means of unpacking
contributions of modem
modem dish ibutions
advanced package management
package management today
linux distributions include
include a package-tracking
painlessly the sls
days of linux
collection of linux
lacked the packagemanagement
tools now expected
expected of linux
distributions the distribution
represented a great
poor package management
widely installed distributions
community since slackware
commercial and noncommercial
noncommercial limlx distributions
commercial linux support
linux support company
free-software linux community
commercially supported versions
versions of linux
linux include distributions
distributions from cz,ldera
germany has resulted
dedicated german-language distributions
distributions in circulation
variety of distributions
compatibility across linux
rpm package file
package file format
majority of distributions
commercial applications distributed
installed and run
accept rpm files
files 21.1.4 linux
21.1.4 linux licensing
licensing the linux
kernel is distributed
gnu general public
general public license
out the free
free software fmmdation
software fmmdation linux
public-domain software implies
authors have waived
waived copyright rights
rights in linux
linux is free
sense that people
people can copy
restrictions the main
implications of linux
linux s licensing
creating a derivative
derivative of linux
make the derived
derived product proprietary
product proprietary software
proprietary software released
camwt be redistributed
software that includes
includes any components
make source code
code available alongside
alongside any binary
selling-binary-only software distributions
reasonable distribution charge
nonmicrokernel unix implementation
set of unix-compatible
unix-compatible tools linux
linux s file
file system adheres
adheres to traditional
traditional unix semantics
standard unix networking
unix networking model
model is implemented
fully the internal
details of linux
system s development
development although linux
variety of platforms
architecture a great
development was carried
out by individual
development or research
start linux attempted
attempted to squeeze
limited resources today
linux can run
machine with hundreds
hundreds of megabytes
megabytes of main
gigabytes of disk
capable of operating
ram as pcs
memory and hard
disks became cheaper
minimalist limix kernels
limix kernels grew
grew to implement
implement more unix
unix functionality speed
speed and efficiency
important design goals
recent and current
work on linux
linux has concentrated
diversity of unix
source code written
compile or run
calls are present
two different unix
posix standards comprise
set of specifications
aspects of operating-system
documents for common
common operating-system functionality
threads and real-time
real-time operations linux
relevant posix documents
two linux distributions
distributions have achieved
achieved official posix
official posix certification
presents few surprises
familiar with unix
detail these interfaces
linux by default
linux programming interface
programming interface adheres
adheres to svr4
svr4 unix semantics
behavior a separate
set of libraries
implement bsd semantics
semantics in places
two behaviors differ
behaviors differ significantly
certification of linux
linux with respect
slowed because certification
involved in certifying
certifying an operating
system s compliance
standards is substantial
supporting a wide
base of applications
applications is important
implementation of standards
goal for linux
certified in addition
linux currently supports
posix threading extensions-pthreads
-and a subset
real-time process control
control 21.2.1 components
bodies of code
traditional unix implementations
kernel is responsible
including such things
things as virtual
memory and processes
processes system libraries
libraries the system
system libraries define
define a standard
applications can interact
kernel these functions
privileges of kernel
kernel code system
code system utilities
utilities the system
utilities are programs
programs that perform
specialized management tasks
tasks some system
initialize and configure
configure some aspect
system ; othersknown
othersknown as daemons
daemons in unix
terminology -may run
handling such tasks
tasks as responding
responding to incoming
incoming network connections
accepting logon requests
requests from terminals
updating log files
log files figure
components that make
full linux system
kernel code executes
processor s privileged
mode with full
computer linux refers
mode as kernel
kernel under linux
code is built
kernel any operating-system-support
systems have adopted
adopted a messagepassing
kernel is created
binary the main
iil a single
single address space
calls an operating-system
interrupt is delivered
delivered linux kernel
linux kernel loadable
kernel loadable kernel
kernel modules figure
scheduling and virtual
virtual memory code
including all device
kernel components share
room for modularity
applications can load
load shared libraries
libraries at run
kernel can load
dynamically at run
advance which modules
independent loadable components
components the linux
services to give
arbitrated and protected
access to hardware
resources the kernel
required to qualify
features of unix
unix application expects
operating-system interface visible
visible to running
applications make calls
call the operatingsystem
system libraries provide
provide many types
types of functionality
applications to make
make kernel-system service
kernel-system service requests
service requests making
making a system
system call involves
call involves transferring
involves transferring control
control from tmprivileged
tmprivileged user mode
mode to privileged
privileged kernel mode
vary from architecture
architecture to architecture
architecture the libraries
libraries take care
care of collecting
collecting the system-call
arranging those arguments
make the system
call the libraries
provide more complex
language s buffered
buffered file-handling functions
providing more advanced
control of file
basic kernel system
kernel system calls
calls the libraries
libraries also provide
correspond to system
support the running
running of unix
applications are implemented
libraries the limix
limix system includes
includes a wide
variety of user-mode
user-mode programs-both system
programs-both system utilities
utilities and user
system utilities include
initialize the system
configure network devices
load kernel modules
modules continually running
running server programs
programs also com1.t
com1.t as system
programs handle user
handle user login
user login requests
standard utilities serve
utilities serve key
serve key system-administration
key system-administration functions
functions the unix
unix user environment
number of standard
simple everyday tasks
moving and deleting
displaying the contents
file more complex
utilities can perform
perform text-processing functions
sorting textual data
data and performing
performing pattern searches
searches on input
form a standard
standard tool set
set that users
users can expect
perform any operating-system
basic limix system
load and unload
unload arbitrary sections
sections of kernel
code on demand
demand these loadable
kernel modules run
run in privileged
consequence have full
run in theory
module is allowed
module might implement
implement a device
networking protocol kernel
protocol kernel modules
modules are convenient
code is free
wanting to write
write kernel code
compile a modified
reboot to load
reloading the entire
cycle to undertake
kernel to test
driver is written
users can benefit
rebuild their kernels
released with proprietary
proprietary components added
demand the kernel
kernel s module
parties to write
write and distribute
drivers or file
gpl kernel modules
standard minimal kernet
extra device drivers
device drivers built
system at startup
startup or loaded
system on demand
demand and unloaded
mounted and unloaded
unloaded from memory
system the module
support under linux
drivers to reserve
reserve hardware resources
protect those resources
resources from accidental
driver 21.3.1 module
21.3.1 module management
module management loading
loading a module
loading its binary
contents into kernel
references the module
makes to kernel
symbols or entry
points are updated
kernel s address
address space linux
space linux deals
updating by splitting
splitting the job
job of module
two separate sections
management of sections
sections of module
code in kernel
handling of symbols
symbols that modules
modules are allowed
allowed to reference
maintains an internal
internal syncbol table
kernel this symbol
set of symbols
kernel the set
set of exported
exported symbols constitutes
constitutes a well-defined
module can interact
kernel although exporting
kernel function requires
requires an explicit
effort is needed
needed to import
import those symbols
module a module
standard external linking
external symbols referenced
marked as unresolved
final module binary
module binary produced
utility first scans
scans the module
references all symbols
resolved are looked
kernel s symbol
kernel are substituted
module s code
kernel for loading
resolve any references
module is rejected
rejected the loading
module is performed
two stages first
moduleloader utility asks
asks the kernel
kernel to reserve
reserve a continuous
area of virtual
virtual kernel memory
module the kernel
address to relocate
relocate the module
module s machine
correct loading address
call then passes
passes the module
kernel the module
previously allocated space
loaded the final
final module-management component
requestor the kernel
defines a communication
program can connect
kernel will inform
inform the management
requests a device
give the manager
manager the opportunity
opportunity to load
load that service
service the original
original service request
request will complete
module is loaded
loaded the manager
process regularly queries
queries the kernel
dynamically loaded module
unloads that module
longer actively needed
needed 21.3.2 driver
21.3.2 driver registration
lets the rest
kernel maintains dynamic
maintains dynamic tables
calls a module
module s startup
loaded and calls
calls the module
module s cleanup
module is unloaded
routines are responsible
responsible for registering
registering the module
module s functionality
functionality a module
module may register
register many types
types of drivers
register two separate
two separate mechanisms
mechanisms for accessing
accessing the device
device registration tables
registration tables include
drivers these drivers
drivers include character
include character devices
including all disk
network interface devices
interface devices file
devices file systems
linux s virtual-file-system
virtual-file-system calling routines
implement a format
format for storing
system whose contents
contents are generated
file system network
system network protocols
protocols a module
module may implement
implement an entire
entire networking protocot
set of packet-filtering
network firewall binary
firewall binary format
format this format
type of executable
addition a module
module can register
set of entries
sysctl and tables
21.3.3 conflict resolution
conflict resolution commercial
resolution commercial unix
commercial unix implementations
sold to run
hardware one advantage
number of configurations
drivers for devices
controllers and video
video display adapters
adapters the problem
problem of managing
managing the hardware
severe when modular
modular device drivers
set of devices
dynamically variable linux
central conflict-resolution mechanism
resources its aims
modules from clashing
clashing over access
resources to prevent
auto-detect device configuration-from
device configuration-from interfering
interfering with existing
existing device drivers
drivers to resolve
conflicts among multiple
parallel printer driver
parallel printer port
kernel maintains lists
lists of allocated
allocated hardware resources
hardware i address
i address space
expected to reserve
reserve the resource
kernel database first
first this requirement
administrator to determine
point a module
module is expected
mechanism to reserve
reserve in advance
advance any hardware
reservation is rejected
fail its initialization
initialization and request
alternative hardware resources
activity is serviced
process model similar
unix linux operates
review the traditional
traditional unix process
unix process model
21.4.1 the fork
model the basic
principle of unix
unix process management
separate two operations
call to exec
two distinctly separate
distinctly separate functions
created with fork
program being run-the
run-the new subprocess
subprocess simply continues
process be created
process may call
process this model
advantage of great
call that runs
runs that program
program simply runs
parent process wishes
wishes to modify
modify the environment
running the original
make any system
calls it requires
requires to modify
modify that child
program under unix
maintain to track
track the context
program under linux
number of specific
process properties fall
context 21.4.1.1 process
21.4.1.1 process identity
identity a process
process identity consists
identifier the pid
call to signal
process additional identifiers
additional identifiers associate
associate the process
single user command
login session credentials
credentials each process
groups are discussed
determine the rights
process to access
access system resources
resources and files
personality process personalities
found on unix
linux each process
modify the semantics
system calls personalities
libraries to request
request that system
calls be compatible
varieties of unix
group and session
group or session
session its credentials
security checks howeve1
process is unchangeable
identifies that process
process until termination
termination 21.4.1.2 process
21.4.1.2 process environment
environment a process
process s environment
environment is inherited
two null-terminated vectors
vector the argument
vector simply lists
lists the command-line
invoke the running
pairs that associates
associates named environment
named environment variables
variables with arbitrary
arbitrary textual values
values the environment
held in kernel
user-mode address space
stack the argument
argument and environment
inherit the environment
completely new environment
environment is set
program is invoked
invoked on calling
supply the environment
program the kernel
passes these enviromnent
replacing the process
environment the kernel
kernel otherwise leaves
leaves the environment
environment and command-line
command-line vectors alone-their
vectors alone-their interpretation
interpretation is left
libraries and applications
applications the passing
passing of environment
process provide flexible
provide flexible ways
ways to pass
information to components
user-mode system software
software various important
important environment variables
variables have conventional
meanings to related
variable is set
type of terminal
user s login
variable to determine
user s display
moving the cursor
cursor and scrolling
scrolling a region
region of text
programs with multilingual
language to display
display system messages
messages for programs
programs that include
include multilingual support
support the environment-variable
environment-variable mechanism custom-tailors
custom-tailors the operating
users can choose
languages or select
21.4.1.3 process context
context the process
identity and environment
exits a process
process may choose
choose to change
change some aspects
alter its environment
environment in contrast
constantly process context
process context includes
scheduling context-the information
suspend and restart
process this information
information includes saved
includes saved copies
process s registers
registers floating-point registers
registers are stored
incur the overhead
overhead of saving
saving that state
state the scheduling
context also includes
information about scheduling
outstanding signals waiting
process a key
process s kernel
area of kernel
kernel memory reserved
exclusively by kernel-mode
code both system
calls and interrupts
interrupts that occur
accounting the kernel
kernel maintains accounting
maintains accounting information
total resources consumed
table the file
array of pointers
pointers to kernel
kernel file structures
structures when making
making file-i system
table file-system context
file table lists
lists the existing
existing open files
file-system context applies
applies to requests
requests to open
open new files
files the current
root and default
searches are stored
stored here signal-handler
signal-handler table unix
table unix systems
systems can deliver
deliver asynchronous signals
process in response
events the signal-handler
signal-handler table defines
defines the routine
specific signal arrives
signal arrives virtual
arrives virtual memory
virtual memory context
context the virtual
memory context describes
describes the full
process s private
private address space
flags that determine
call the lack
lack of distinction
distinction between processes
hold a process
process s entire
main process data
process data structure
holds the context
context within independent
process s file-system
context are held
held in separate
separate data structures
structures the process
simply contains pointers
share a subcontext
subcontext by pointing
subcontext the arguments
subcontexts to copy
create new subcontext
subcontext data struch1res
data struch1res initialized
subcontext data structures
parent the fork
case of clone
copies all subcontexts
sharing none scheduling
job of allocating
running and interrupting
interrupting of processes
aspect of scheduling
important to linux
kernel tasks kernel
tasks kernel tasks
kernel tasks encompass
encompass both tasks
process and tasks
tasks that execute
internally on behalf
driver 21.5.1 process
21.5.1 process scheduling
process scheduling linux
two separate process-scheduling
separate process-scheduling algorithms
algorithm for fair
scheduling among multiple
designed for real-time
important than fairness
fairness the scheduling
routine time-sharing tasks
time-sharing tasks received
received a major
overhaul with version
kernel earlier versions
grows the overhaul
scheduler with version
including processor affin.ity
affin.ity and load
length the linux
priorities unlike schedulers
linux scheduler assigns
scheduler assigns higher-priority
rum able task
runqueue data structure
runqueue and schedules
two priority arrays-active
arrays-active and expired
expired the active
priority arrays includes
includes a list
array and vice-versa
assigned dynamic priorities
minus a value
ether a value
value is added
task s nice
nice value depends
task a task
interactivity is determined
favors such interactive
two active array
scheduling is simpler
simpler still linux
two realtime scheduling
realtime scheduling classes
scheduling classes required
required by posix.lb
priority irt addition
scheduling class processes
priorities can compete
extent in time-sharing
scheduler always runs
priority among processes
processes of equal
difference between fcfs
fcfs and round-robin
fcfs processes continue
exit or block
unlike routine time-sharing
static priorities linux
linux s real-time
scheduling is soft-rather
soft-rather than hard-real
scheduler offers strict
offers strict guarantees
priorities of real-time
offer any guarantees
quickly a reahim.e
runnable 21.5.2 kernel
21.5.2 kernel synchronization
processes a request
request for kernel-mode
execution can occur
ways a running
program may request
request an operating-system
call or implicitly-for
controller may deliver
deliver a hardware
cpu to start
executing a kernel-defined
interrupt the problem
access the sanl.e
sanl.e internal data
middle of accessing
accessing some data
access or modify
data without risking
risking data corruption
corruption this fact
idea of critical
sections-portions of code
code that access
access shared data
kernel synchronization involves
scheduling a framework
framework is required
tasks to run
run without violating
violating the integrity
integrity of shared
nonpreernptive kernet meaning
run with version
kernel the limix
task disables kernel
release the spinlock
preemption this pattern
pattern is summarized
structure that includes
includes the field
task the counter
acquired and decremented
value of preemplcount
preempt the kernet
calls to preempt_disable
disabling of kernel
kernel preemption -are
held for longer
applies to critical
sections that occur
occur in interrupt
routines the basic
processor s interrupt-control
hardware by disabling
risk of concurrent
penalty for disabling
enable and disable
instructions are expensive
long as interrupts
interrupts remain disabled
i is suspended
waiting for servicing
wait until interrupts
degrades the linux
long critical sections
sections to run
disabled this ability
code an interrupt
driver can signal
signal the arrival
entire network packet
deal of code
code being executed
executed to disassemble
forward that packet
kernel-system service routines
interrupt protection levels
protection levels linux
levels linux implements
implements this architecture
architecture by separating
separating interrupt service
normal interrupt service
routine that runs
runs with recursive
recursive interrupts disabled
disabled ; interrupts
priority may interrupt
interrupt the routine
priority are disabled
routine is run
scheduler that ensures
ensures that bottom
halves never interrupt
scheduler is invoked
service routine exits
exits this separation
kernel can complete
complete any complex
done in response
interrupt without worrying
half is executing
interrupt can request
bottom half execute
completes each execution
similar bottom half
architecture is completed
mechanism for disabling
disabling selected bottom
selected bottom halves
halves while executing
foreground kernel code
code the kernel
kernel can code
code critical sections
system interrupt handlers
handlers can code
code their critical
sections as bottom
enter a critical
disable any relevant
relevant bottom halves
halves to prevent
sections from interrupting
kernel can reenable
reenable the bottom
halves and run
run any bottom-half
queued by top-half
top-half interrupt service
critical section figure
levels of interrupt
kernel each level
interrupted by code
time-sharing scheduling interrupt
scheduling interrupt occurs
occurs 21.5.3 symmetric
21.5.3 symmetric multiprocessing
multiprocessing the linux
first stable linux
stable linux kernel
kernel to support
allowing separate processes
execute in parallel
parallel on separate
implementation of smp
imposed the restriction
executing kernel-mode code
single kernel spinlock
bkl for big
big kernel lock
level of locking
granularity later releases
made the smp
implementation more scalable
scalable by splitting
splitting this single
spinlock into multiple
kernel s data
structures such spinlocks
spinlocks are described
kernel provided additional
provided additional smp
additional smp enhancements
affinity and load-balancing
load-balancing algorithms memory
algorithms memory management
management under linux
components the first
deals with allocating
freeing physical memory-pages
groups of pages
blocks of memory
handles virtual memory
space of running
examine the mechanisms
program are brought
brought il lto
lto a process
memory in response
call 21.6.1 management
management of physical
physical memory due
due to specific
specific hardware characteristics
linux separates physical
separates physical memory
zone_dma zone_normal zone_highmem
zone_highmem these zones
zones are architecture
intel 80x86 architecture
industry standard architecture
access the lower
memory using dma
physical memory comprise
memory comprise zonldma
comprise zonldma zone_normal
zonldma zone_normal identifies
zone_normal identifies physical
identifies physical memory
cpu s address
space this zone
routine memory requests
requests for architectures
limit what dma
dma can access
refers to physical
32-bit intel architecture
4-gb address space
kernel is mapped
memory is referred
allocated from zone_highmem
zone_highmem the relationship
relationship of zones
zones and physical
request for physical
physical memory arrives
satisfies the request
zone the priinary
priinary physical-memory manager
lil lux kernel
allocator each zone
responsible for allocating
freeing all physical
capable of allocating
pages on request
request the allocator
units of allocatable
memory are paired
allocatable memory region
two allocated partner
allocated partner regions
regions are freed
form a larger
larger region-a buddy
region-a buddy heap
heap that larger
combine to form
larger free region
small memory request
satisfied by allocation
existing small free
small free region
partners to satisfy
request separate linked
separate linked lists
record the free
free memory regions
smallest size allocatable
single physical page
physical page figure
smallest available region
region is broken
kernel are ncade
drivers that reserve
reserve a contiguous
area of memory
memory during system
allocator to reserve
memory several specialized
specialized memory-management subsystems
underlying page allocator
allocator to manage
pools of memory
memory for kernel
caching pages belonging
belonging to files
files many components
allocate entire pages
memory are required
required the kernel
16kb 4kb figure
splitting of memory
allocator for arbitrary-sized
language s malloc
service allocates entire
allocates entire pages
pages on demand
pieces the kernel
lists of pages
service allocating memory
allocating memory involves
memory involves determining
taking the first
first free piece
list or allocating
page and splitting
memory regions clainled
system are allocated
reallocate or reclaim
reclaim these regions
regions in response
response to memory
shortages another strategy
adopted by linux
linux for allocating
allocation a slab
objects the relationship
relationship among slabs
objects the slab-allocation
objects are allocated
contiguous 4-kb pages
free kernel objects
3-kb i objects
allocator in linux
linux physically contiguous
objects the slab
two other main
subsystems in linux
kernel s main
cache for block
devices is performed
native linux diskbased
linux diskbased file
nfs networked file
networked file system
cache the page
page cache stores
cache stores entire
stores entire pages
pages of file
limited to block
cache networked data
data the virtual
memory system manages
manages the contents
two systems interact
reading a page
page of data
page cache requires
cache requires mapping
requires mapping pages
system in greater
detail 21.6.2 virtual
21.6.2 virtual memory
memory the limn
limn virtual memory
maintaining the address
address space visible
pages of virtual
demand and manages
loading those pages
pages from disk
disk and swapping
disk as required
required under linux
maintains two separate
two separate views
set of separate
pages the first
system has received
address space consists
set of nonoverlapping
representing a continuous
space each region
region is described
single vm_area_struct structure
structure that defines
defines the properties
including the process
process s read
region the regions
space are linked
balanced binary tree
address the kernel
space this view
view is stored
hardware page tables
process the pagetable
pagetable entries identify
exact current location
page of virtual
memory the physical
view is managed
kernel s software-interrupt
tables each vm_area_struct
table of functions
implement the key
key page-management functions
virtual memory region
region all requests
requests to read
write an unavailable
central memorymanagement routines
details of managing
type of memory
region 21.6.2.1 virtual
21.6.2.1 virtual memory
virtual memory regions
memory regions linux
regions linux implements
implements several types
types of virtual
regions one property
property that characterizes
characterizes virtual memory
regions are backed
type of virtual
region represents demand-zero
represents demand-zero memory
read a page
back a page
page of memory
filled with zeros
zeros a region
table is filled
kernel s page
process s page
mapped that file
space any number
processes can map
purpose a virtual
reaction to writes
writes the mapping
private or shared
privately mapped region
process in contrast
shared region result
result in updating
mapping that object
object 21.6.2.2 lifetime
space the kernel
kernel will create
case is easy
completely empty virtual
empty virtual address
routines for loading
loading the program
program to populate
populate the address
space with virtual
process with fork
creating a concplete
copies the parent
process s vm_area_struct
child the parent
parent s page
tables are copied
covered is incremented
spaces a special
special case occurs
copying operation reaches
reaches a virtual
privately any pages
process has written
region are private
update the page
regions are copied
marked for copy-on-write
modifies these pages
two processes share
modify a copy-on-write
page is checked
copies the page
page s contents
ensures that private
private data pages
pages are shared
shared between processes
copies are made
paging an important
inemory is needed
needed early unix
unix systems performed
performed this relocation
relocation by swapping
out the contents
contents of entire
movement of individual
memory between physical
implement whole-process swapping
newer paging mechanism
paging mechanism exclusively
exclusively the paging
two sections first
out the transfer
transfer and pages
pages data back
back into physical
needed again linux
linux s pageuut
9.4.5.2 under linux
clock the age
precisely a measure
page s youthfulness
activity the page
recently frequently accessed
frequently accessed pages
pages will attain
attain a higher
higher age value
infrequently accessed pages
pages will drop
pass this age
pager to select
pages to page
page out based
policy the paging
paging mechanism supports
mechanism supports paging
dedicated swap devices
devices and partitions
significantly slower due
extra overhead incurred
file system blocks
maintained in physical
times the allocator
write out pages
pages to continuous
runs of disk
blocks for improved
performance the allocator
records the fact
tables on modern
entry s page-not-present
allowing the rest
written 21.6.2.4 kernel
21.6.2.4 kernel virtual
kernel virtual memory
virtual memory linux
memory linux reserves
process the page-table
entries that map
marked as protected
visible or modifiable
processor is running
mode this kernel
virtual memory area
regions the first
translation from physical
physical to virtual
virtual addresses occurs
occurs when kernel
run the core
normal page allocator
region the remainder
kernel s reserved
section of address
specific purpose page-table
purpose page-table entries
kernel to point
areas of memory
memory the kernel
pair of facilities
memory the vmalloc
allocates an arbitrary
number of physical
virtually contiguous kernel
contiguous kernel memory
memory the vremap
maps a sequence
sequence of virtual
addresses to point
driver for memory-mapped
i 21.6.3 execution
execution and loading
loading of user
programs the linux
kernel s execution
programs is triggered
call this exec
commands the kernel
kernel to run
overwriting the current
current execution context
program the first
process has permission
file being executed
invokes a loader
routine to start
running the program
program the loader
load the contents
file into physical
program into virtual
routine in linux
linux for loadil1.g
function the opportunity
made the initial
format for linux
linux s binary
files was changed
changed older linux
older linux kernels
linux kernels understood
format for binary
files-a relatively simple
simple format common
common on older
older unix systems
unix systems newer
systems newer linux
newer linux systems
modern elf format
current unix implementations
unix implementations elf
number of advantages
flexibility and extensibility
extensibility new sections
add extra debugging
extra debugging information
causing the loader
confused by allowing
registration of multiple
multiple loader routines
support the elf
out binary formats
single rmming system
running of elf-format
binaries the procedure
procedure for loading
binaries is simpler
similar in operation
operation 21.6.3.1 mapping
mapping of programs
memory under linux
load a binary
file are mapped
mapped into regions
regions of virtual
page fault result
page into physical
kernel s binary
loader to set
initial memory mapping
mapping an elf-format
elf-format binary file
binary file consists
sections the elf
elf loader works
works by reading
reading the header
header and mapping
mapping the sections
file into separate
shows the typical
layout of memory
memory regions set
address space sits
sits the kernet
region of virtual
virtual memory inaccessible
inaccessible to normal
normal user-mode programs
programs the rest
rest of virtual
kernel s memory-mapping
functions to create
regions that map
map a portion
data the loader
loader s job
program to start
start the regions
il1.clude the stack
program s text
text and data
regions the stack
stack is created
user-mode virtual memory
downward toward lower-numbered
addresses it includes
arguments and environment
il1 the exec
regions are created
end of virtual
memory the sections
contail1 program text
invisible to user-mode
user-mode code figure
data are mapped
mapped into memory
write-protected region writable
region writable initialized
writable initialized data
private demand-zero region
region that programs
programs can expand
expand as needed
needed to hold
hold data allocated
allocated at run
processes can extend
extend or contract
contract their brk
single system call
system call -sbrko
initializes the process
process s program-counter
starting point recorded
scheduled 21.6.3.2 static
functions are embedded
program s executable
executable binary file
statically linked executables
executables can commence
loaded the main
disadvantage of static
common system library
system library functions
memory and disk-space
load the system
libraries into ltl.emory
loading to happen
happen linux implements
linux implements dynamic
implements dynamic linking
linking in user
special linker library
dynamically linked program
statically linked function
starts this static
function just maps
maps the link
library into memory
memory and runs
runs the code
link library determines
determines the dynamic
dynamic libraries required
variables and functions
libraries by reading
contained in sections
maps the libraries
middle of virtual
memory and resolves
resolves the references
memory these shared
libraries are mapped
compiled into position-independent
memory linux retains
linux retains unix
standard file-system model
model in unix
disk or fetched
capable of handling
handling the input
stream of data
data device drivers
channels or network
user the linux
linux kernel handles
files by hiding
hiding the implementation
single file type
cover the virtual
discuss the standard
linux file system-ext2fs
vfs is designed
designed around object-oriented
set of definitions
objects are allowed
layer o software
software to manipulate
manipulate the objects
objects the vfs
defines four main
inode object represents
file object represents
file a superblock
superblock object represents
system a dentry
dentry object represents
ldividual directory entry
operations every object
object s operations
file the complete
object the vfs
represents a networked
read the inode
inode and file
files an inode
structure containing pointers
actual file contents
represents a point
point of access
access an inode
contents without first
obtaining a file
file object pointing
inode the file
object keeps track
track of sequential
asked for write
file was opened
opened and tracks
tracks the process
process s activity
fetching file data
data into memory
requests the data
improve performance file
performance file objects
objects typically belong
vfs to improve
future all cached
cached file data
data are linked
object the inode
inode also maintains
maintains standard information
recently modified directory
modified directory files
files are dealt
files the unix
unix programming interface
programming interface defines
defines a number
number of operations
operations on directories
directory the system
open the files
unlike the case
case for reading
data the vfs
vfs therefore defines
defines these directory
object the superblock
represents a connected
files that form
form a self-contained
self-contained file system
operating-system kernel maintains
single superblock object
disk device mounted
system currently connected
connected the main
access to inodes
inodes the vfs
identifies every inode
unique file-system number
object to return
return the inode
represents a directory
values is represented
separate dentry object
wishes to open
editor because linux
linux treats directory
treats directory names
names as files
translating this path
path requires first
requires first obtaining
obtaining the inode
file to obtain
obtain the inode
continue this process
obtains the inode
linuxmaintains a cache
cache of dentry
consulted during path-name
path-name translation obtaining
read the on-disk
21.7.2 the linux
linux ext2fs file
ext2fs file system
system the standard
standard on-disk file
on-disk file system
historical reasons linux
minix-compatible file system
ease exchanging data
minix development system
restricted by 14-character
14-character file-name limits
maximum file-system size
system was superseded
christened the extended
extended file system
performance and scalability
missing features led
bsd fast file
mechanism for locating
locating the data
storing data-block pointers
pointers in indirect
contents are interpreted
differently each block
directory file consists
list of entries
refers the main
differences between ext2fs
ext2fs and ffs
policies in ffs
disk is allocated
allocated to files
files in blocks
blocks are subdivided
subdivided into fragments
storage of small
partially filled blocks
ends of files
allocations in smaller
units the default
default block size
size on ext2fs
supported to maintain
maintain high performance
perform i operations
operations in large
clustering physically adjacent
adjacent l requests
l requests clustering
requests clustering reduces
reduces the per-request
per-request overhead incurred
incurred by device
1-kb i request
i request size
small to maintain
maintain good performance
ext2fs uses allocation
allocation policies designed
designed to place
place logically adjacent
logically adjacent blocks
physically adjacent blocks
operation the ext2fs
ext2fs allocation policy
system is partitioned
partitioned into multiple
multiple block groups
block groups ffs
concept of cylinder
modern disk-drive technology
disk-drive technology packs
technology packs sectors
fixed-sized cylinder groups
disk s geometry
geometry when allocating
allocating a file
select the block
file for data
attempts to allocate
allocate the file
allocated for inode
selects the block
file s parent
parent directory resides
nondirectory files directory
files directory files
groups these policies
policies are designed
out the disk
disk s block
groups to reduce
reduce the fragmentation
allocations physically contiguous
maintains a bitmap
group when allocating
allocating the first
extending a file
continues the search
file the search
search is performed
entire free byte
fails to find
bit the search
search for free
free bytes aims
aims to allocate
space in chunks
search is extended
block is encountered
byte is found
backward extension prevents
extension prevents ext2fs
ext2fs from leaving
leaving a hole
recently allocated block
previous nonzero byte
bit or byte
extends the allocation
blocks and preallocates
allocating scattered free
scattered free blocks
free blocks allocating
blocks allocating continuous
allocating continuous free
continuous free blocks
free blocks block
block fj block
allocator ___ bitmap
___ bitmap search
bitmap search bit
search bit boundary
bit boundary byte
boundary byte boundary
byte boundary figure
ext2fs block-allocation policies
policies these extra
file this preallocation
fragmentation during in.terleaved
writes to separate
reduces the cpu
cost of disk
allocation by allocating
allocating multiple blocks
multiple blocks simultaneously
simultaneously the preallocated
blocks are returned
illustrates the allocation
policies each row
represents a sequence
sequence of set
set and unset
find any free
matter how fragmented
blocks are close
run than allocating
allocating isolated blocks
blocks to separate
files once large
large free areas
areas become scarce
scarce on disk
found a free
free block close
allocated that byte
end up creating
creating a fragmented
area of free
make this allocation
forward to satisfy
satisfy the default
blocks 21.7.3 journaling
journaling one popular
system is journaling
journal a set
operations that performs
transaction is written
system call modifying
modifying the file
journal entries relating
transaction are replayed
actual file-system structures
transaction is concpleted
journal the journal
separate read-write heads
transactions may remain
journal those transactions
recovers the transactions
eliminating all problems
consistency checking journaling
checking journaling file
faster than non-journaling
i costly synchronous
synchronous random writes
system are turned
system s journal
performance of file-system
file-system metadata-oriented operations
provided in ext2fs
common file system
based on ext2fs
unux process file
process file system
system the flexibility
linux vfs enables
functionality the linux
linux process file
computed on demand
file i requests
unique to linux
linux svr4 unix
svr4 unix introduced
kernel s process
process debugging support
support each subdirectory
file system corresponded
system a listing
file system reveals
reveals one directory
directory per process
asch decimal representation
process s unique
system but extends
greatly by adding
adding a number
directories and text
system s root
programs to access
information as plain
plain text files
standard unix user
environment provides powerful
tools to process
process such files
unix ps command
command for listing
listing the states
reads the process
kernel s virtual
memory under lim1x
parses and formats
formats the information
system must implement
implement two things
directory inodes identified
file system nmst
system nmst define
define a unique
unique and persistent
persistent inode number
operation is required
perform a lookup
inode when data
system will collect
buffer the mapping
mapping from inode
number to information
information type splits
splits the inode
fields in linux
bits the top
number are interpreted
remaining bits define
define what type
process a pid
inode contains global-rather
global-rather than process-specificinformation
process-specificinformation separate global
separate global files
global files exist
files exist iil
drivers currently numing
range are reserved
reserved the kernel
kernel can allocate
maintaining a bitmap
bitmap of allocated
allocated in ode
maintains a tree
structure of registered
global i pro
pro c file-system
entries each entry
generate the file
file s contents
drivers can register
register and deregister
kernel variables files
tree are managed
set of common
administrator can tune
tune the value
value of kernel
simply by writing
out in ascii
subtree is made
special system call
variables in binary
file system sysctl
dynamic entry tree
tree to identify
identify the variables
application is referring
system in linux
normal files users
users can open
open an access
administrator can create
create special files
specific device driver
normal file-protection device
file-protection device driver
device driver driver
user application character
application character device
character device file
device file character
file character device
character device driver
.  network
device driver figure
device-driver block structure
access which file
administrator can set
set access permissions
device linux splits
splits all devices
network devices figure
device-driver system include
include all devices
disks and floppy
flash memory block
memory block devices
store file systems
programs can create
create and repair
repair the file
device contains applications
access these block
application may prefer
prefer to perform
out of data
general-purpose file system
file system include
mice and keyboards
keyboards the fundamental
difference between block
devices is random
random access-block devices
dvd but makes
makes no sense
mouse are dealt
differently from block
character devices users
directly transfer data
data to network
indirectly by opening
opening a connection
kernel s networking
subsystem we discuss
discuss the interface
interface to network
separately in section
21.8.1 block devices
block devices block
devices block devices
block devices provide
provide the main
important for disks
functionality to ensure
ensure that disk
functionality is achieved
context of block
represents the unit
performs i wl1en
wl1en a block
buffer the request
manages the reading
writing of buffer
driver a separate
list of requests
algorithm that exploits
exploits the order
requests are inserted
lists the request
lists are maintained
maintained in sorted
order of increasing
increasing starting-sector number
accepted for processing
fronc the list
point the driver
request ncanager attempts
attempts to merge
lists the scheduling
i operations changed
kernel the fundamental
i operations concentrated
disk can result
starvation of requests
disk the deadline
deadline i scheduler
associates a deadline
addressing the starvation
issue by default
deadline for read
seconds the deadline
sched ~ uler
maintains a sorted
pending i operations
i operations ordered
ordered by sector
two other queues-a
queues-a read queue
queue for read
queue for write
queues are ordered
i operations occur
operations are scheduled
request this policy
operation will wait
21.8.2 character devices
devices a character-device
offer random access
access to fixed
data any character-device
character-device drivers registered
register a set
file i operations
driver can handle
handle the kernel
passes the request
device in question
question and lets
lets the device
request the main
subset of character-device
drivers that implement
implement terminal devices
devices the kernel
maintains a standard
drivers by means
set of tty
tty struct structures
structures provides buffering
buffering and flow
device and feeds
feeds those data
common line discipline
glues the terminal
terminal s data
user s running
allowing those processes
user s terminal
terminal this job
job is complicated
tty line discipline
discipline is responsible
responsible for attaching
attaching and detaching
detaching the terminal
terminal s input
suspended or awakened
process the ppp
protocols are ways
ways of encoding
encoding a networking
line these protocols
protocols are implemented
implemented under linux
linux as drivers
system as line
system as network-device
network-device driver linux
matter of letting
letting another process
involve transferring data
synchronization and signals
signals the standard
standard lim.ix mechanism
mechanism for informing
informing a process
restrictions on signals
number of signals
signal has occurred
processes the kernel
kernel also generates
send a signal
process when data
signals to communicate
communicate with processes
ruml.ing in kernel
process is expecting
expecting an event
event to occm
signals to receive
communication about incoming
incoming asynchronous events
kernel takes place
states and wai
wai t_queue structures
structures these mechanisms
mechanisms allow kernel-mode
processes to inform
generated by device
event to complete
event and tells
tells the scheduler
event has completed
wait this procedure
procedure allows multiple
successfully although signals
mechanism for communicating
communicating asynchronous events
events among processes
linux also implements
implements the semaphore
mechanism of system
unix a process
process can wait
numbers of semaphores
shared among multiple
multiple independent processes
standard linux wait
linux wait queue
wait queue mechanism
queue mechanism synchronizes
mechanism synchronizes processes
communicating with semaphores
passing of data
data among processes
processes linux offers
offers several mechanisms
mechanisms for passing
processes the standard
standard unix mechanism
process to inherit
inherit a communication
parent ; data
type of inode
inode to virtual-filesystem
pair of wait
queues to synchronize
synchronize the reader
unix also defines
set of networking
streams of data
remote processes networking
networking is covered
process communications method
large or small
data any data
shared memory region
mapped that region
space the main
disadvantage of shared
offers no synchronization
synchronization a process
piece of shared
write occurs shared
occurs shared memory
synchronization a shared-memory
region in linux
created or deleted
deleted by processes
object is treated
independent address space
space the linux
linux paging algorithms
algorithms can elect
elect to page
disk shared-memory pages
process s data
pages the shared-memory
shared-memory object acts
store for shared-memory
file can act
memory-mapped memory region
mapped into virtual
shared-memory mappings direct
mappings direct page
direct page faults
faults to map
map in pages
persistent shared-memory object
sharedmemory objects remember
remember their contents
virtual memory networking
area of functionality
functionality for linux
support the standard
standard internet protocols
implements a number
number of protocols
non-unix operating systems
primarily on pcs
appletalk and ipx
kernel is implemented
socket interface protocol
interface protocol drivers
protocol drivers network-device
drivers network-device drivers
user applications perform
perform all networking
interface this interface
interface is designed
bsd socket layer
sockets will run
interface is described
a.9.1 the bsd
bsd socket interface
general to represent
represent network addresses
range of networking
protocols this single
linux to access
implemented on standard
standard bsd systems
similar in organization
organization to bsd
bsd  sown
networking data arrive
application s socket
data are expected
protocols can communicate
internet protocol set
separate protocols manage
protocols manage routing
retransmission of lost
data the protocol
layer may rewrite
create new packets
split or reassemble
packets into fragments
simply discard incoming
discard incoming data
layer has finished
processing a set
set of packets
data are destined
connection or downward
remotely the protocol
protocol layer decides
socket or device
send the packet
packet all communication
stack is performed
passing single skbuff
set of pointers
single continuous area
representing a buffer
inside which network
constructed the valid
skbuff s buffer
end the networking
code can add
result still fits
skbuff this capacity
important on modern
improvements in cpu
outstripped the performance
performance of main
memory the skbuff
architecture allows flexibility
flexibility in manipulating
manipulating packet headers
headers and checksums
checksums while avoiding
avoiding any unnecessary
unnecessary data copying
linux networking system
suite this suite
comprises a number
number of separate
protocol implements routing
network on top
protocol are built
built the udp
protocols the udp
udp protocol carries
protocol carries arbitrary
carries arbitrary individual
arbitrary individual datagrams
datagrams between hosts
hosts the tcp
tcp protocol implements
protocol implements reliable
implements reliable connections
connections between hosts
hosts with guaranteed
guaranteed in-order delivery
delivery of packets
packets and automatic
data the icmp
carry various error
error and status
messages between hosts
hosts each packet
stack s protocol
software is expected
internal identifier indicating
indicating the protocol
packet is relevant
relevant different networking-device
networking-device drivers encode
encode the protocol
protocol for incoming
driver the device
protocol new protocols
table as kernel-loadable
kernel-loadable modules incoming
incoming ip packets
packets are delivered
driver the job
routing after deciding
forwards the packet
internal protocol driver
locally or injects
selected network-device-driver queue
host it performs
performs the routing
persistent forwarding information
forwarding information base
cache of recent
recent routing decisions
decisions the fib
fib holds routing-configuration
holds routing-configuration information
specific destination address
wildcard representing multiple
representing multiple destinations
destinations the fib
fib is organized
set of hash
hash tables indexed
indexed by destination
searched first successful
first successful lookups
table are added
wildcards are stored
quickly an entry
route cache expires
software passes packets
code for management-selective
filtering of packets
purposes the firewall
firewall manager maintains
maintains a number
chains are reserved
reserved for separate
packets being input
host each chain
chain is held
list of rules
data for matching
two other functions
reassembly of large
maintains an ipfrag
datagram being assembled
assembled incoming fragments
fragments are matched
fragment is added
ipq is created
fragment has arrived
completely new skbuff
skbuff is constructed
constructed to hold
packet is passed
driver packets identified
host are passed
drivers the udp
udp and tcp
tcp protocols share
share a means
means of associating
packets with source
destination port numbers
numbers the socket
lists are linked
linked to hash
hash tables keyed
four address-port values
values for socket
lookup on incoming
packets the tcp
deal with unreliable
maintains ordered lists
lists of unacknowledged
unacknowledged outgoing packets
packets to retransmit
incoming out-of-order packets
data have arrived
linux s security
related to typical
typical unix security
unix security mechanisms
mechanisms the security
access the system
system without first
entry rights access
rights access control
access control providing
providing a mechanism
mechanism for checking
object and preventing
objects as required
required 21.11.1 authentication
21.11.1 authentication authentication
authentication in unix
typically been performed
publicly readable password
readable password file
user s password
password is combined
random salt value
result is encoded
one-way transformation function
function and stored
one-way function means
original password cam1ot
cam1ot be deduced
password is recombined
salt value stored
file and passed
matches the contents
password is accepted
combine a dictionary
commonly used passwords
chance of matching
gaining lmauthorized access
encrypted password secret
methods of encoding
encoding the password
password other authentication
introduced that limit
limit the times
user is permitted
permitted to connect
exist to distribute
distribute authentication information
developed by unix
vendors to address
address authentication problems
problems the system
system is based
users an implementation
pam allows authentication
loaded on demand
system-wide configuration file
mechanism is added
21.11.2 access control
access control access
control access control
control under unix
unique numeric identifiers
identifiers a user
identifies a single
rights a group
identify rights belonging
control is applied
system every file
standard access-control mechanism
mechanism in addition
sections and semaphores
system every object
system under user
user and group
group access control
process s uid
matches the uid
matches the gid
object linux performs
linux performs access
performs access control
control by assigning
specifies which access
granted to processes
processes with owner
access but denied
denied write access
uid a process
uid is granted
granted automatic access
bypassing normal access
normal access checks
checks such processes
perform privileged operations
reading any physical
memory or opening
opening reserved network
reserved network sockets
sockets this mechanism
prevent normal users
users from accessing
accessing these resources
kernel s key
key internal resources
root uid linux
uid linux implements
implements the standard
standard unix setuid
unix setuid mechanism
setuid mechanism described
a.3.2 this mechanism
run with privileges
submits a job
system s print
running that program
implementation of setuid
process s real
real and effective
uid the real
owner under linux
mechanism is augmented
two ways first
implements the posix
specification s saved
saved user-id mechanism
process to drop
drop and reacquire
reacquire its effective
effective uid repeatedly
repeatedly for security
waiving the privileges
perform selected operations
privileges standard unix
standard unix implementations
unix implementations achieve
achieve this capacity
swapping the real
previous effective uid
uid is remembered
program s real
program saved uids
process to set
set its effective
modify the real
provided by linux
characteristic that grants
rights are granted
granted to files
property is set
uid or gid
gid is set
fsuid and fsgid
files on behalf
user without taking
mechanism to serve
killed or suspended
mechanism for flexible
passing of rights
program to another-a
local network socket
process a file
receives a duplicate
duplicate file descriptor
file this mechanism
client to pass
process without granting
granting that process
user who submits
pass the server
server file descriptors
denying the server
free operating system
operating system based
based on unix
reliably on common
common pc hardware
interface and user
user interface compatible
compatible with standard
standard unix systems
run a large
number of unix
including an increasing
number of comm.ercially
comm.ercially supported applications
supported applications linux
vacuum a complete
complete linux system
linux system includes
includes many components
independently of linux
linux the core
core linux operating-system
linux operating-system kernel
existing free unix
free unix software
software to run
entire unix-compatible operating
unix-compatible operating system
operating system free
free from proprietary
code the linux
traditional monolithic kernel
kernel for performance
loaded and unloaded
unloaded at run
run time linux
processes and running
running multiple processes
scheduler newly created
newly created processes
share selective parts
allowing multithreaded programming
multithreaded programming interprocess
programming interprocess communication
communication is supported
system v mechanisms-message
shared memory-and bsd
bsd s socket
socket interface multiple
interface multiple networking
multiple networking protocols
interface the memory-management
system uses page
sharing and copy-on-write
copy-on-write to minimize
minimize the duplication
duplication of data
out to backing
algorithm if physical
file system appears
tree that obeys
obeys unix semantics
layer to manage
manage multiple file
file systems device-oriented
systems are supported
supported device-oriented file
device-oriented file systems
file systems access
systems access disk
symbols defined inside
inside a kernel
loadable kernel module
linux scheduler implements
scheduler implements soft
implements soft real-time
scheduling what features
real-time programming tasks
tasks are missing
linux setuid feature
setuid feature differ
feature in standard
implement an intercomputer
intercomputer file-transfer program
program what type
copy-on-write attribute enabled
costs are incurred
creation and scheduling
platforms what steps
steps must linux
system is portable
processors and memory-management
minimize the ammmt
ammmt of architecture-specific
architecture-specific kernel code
commonly used programming
programming technique describe
ways to implement
user process request
request an operation
operation that results
demand-zero memory region
loading kernel modules
disadvantages of writing
shared libraries perform
perform many operations
advantage of keeping
keeping this functionality
out of kernel
memory what effect
kernel s design
system could include
including the linux
support different file-system
file-system types affect
affect the structure
classify linux threads
threads as user-level
kernel-level threads support
support your answer
disk-layout optimizations based
position of disk
optimize for sequential
sequential data access
characteristics does sequential
access take advantage
optimization no longer
supported by linux
support both processes
system-call sequence fork
preferable the linux
documentation on linux
key sites reference
linux cross-reference pages
maintain current listil1.gs
fully crossreferenced linux-hq
amount of information
linux 2.x kernels
kernels this site
site also includes
major mailing lists
lists the linux
linux documentation project
lists many books
books on linux
format as part
project the project
project also hosts
hosts the linux
linux how-to guides
hints and tips
relating to aspects
aspects of linux
linux the kernel
hackers  guide
guide to kernel
internals in general
constantly expandil1.g site
site is located
located at http
kernel newbies website
resource for introducing
introducing the linux
kernel to newcomers
newcomers many mailing
mailing lists devoted
devoted to linux
important are maintained
e-mail address maj
address maj ordomo
maj ordomo vger
ordomo vger rutgers
rutgers edu send
mail s body
body for information
access the list
finally the linux
internet complete linux
complete linux distributions
community also maintains
archives of current
current system components
addition to investigating
investigating internet resources
kernel in bovet
32-i 64-bit preemptive
64-bit preemptive multitasking
preemptive multitasking operating
system for amd
microprocessors the successor
successor to windows
intended to replace
replace the windows
discuss the key
goals of windows
interface to explore
explore the principles
principles underlying windows
explain how windows
run programs designed
windows xp file
illustrate the networking
networking protocols supported
supported in windows
describe the interface
microsoft and ibm
cooperated to develop
language for single-processor
decided to make
make a fresh
system that supported
posix application-programming interfaces
dec vax operating
vax operating system
charter of building
api as nts
nts native environment
32-bit windows api
reflecting the popularity
popularity of windows
windows nt version
adopted the windows
interface and incorporated
incorporated internet web-server
web-server and webbrowser
software in addition
code were moved
kernel to improve
effect of decreased
decreased system reliability
reliability although previous
released in february
supported only intel
due to marketplace
marketplace factors windows
added active directory
x.soo-based directory service
networking and laptop
support for plug-and-play
memory in october
desktop operating system
replacement for windows
windows .net server
windows xp updated
updated the graphical
recent hardware advances
features were added
automatically repair problems
problems in applications
networking and device
including zero-configuration wireless
dramatic performance improvements
desktop and large
reliability and security
security than earlier
earlier windows operating
operating systems windows
implement multiple operating-system
multiple operating-system personalities
processes called subsystems
subsystems the subsystem
architecture allows enhancements
personality without affecting
affecting the application
multiuser operating system
supporting simultaneous access
access through distributed
windows terminal server
versions of wil,dows
wil,dows xp support
support simultaneous terminal
simultaneous terminal server
terminal server sessions
sessions from windows
windows desktop systems
systems the desktop
versions of terminal
terminal server multiplex
multiplex the keyboard
monitor between virtual
virtual terminal sessions
user this feature
fast user switching
users to preempt
version of windows
windows to ship
ship a 64-bit
version the native
native nt file
integers where appropriate-so
appropriate-so the major
64-bit in wil,dows
two desktop versions
windows xp professional
premium desktop system
system for power
users at work
windows xp personal
reliability and ease
advanced features needed
needed to work
seamlessly with active
directory or run
run posix applications
applications the mernbers
.net server family
versions but add
add a range
range of features
print file servers
large datacenter machines
machines the large
processors on ia32
processors on ia64
ia64 systems microsoffs
systems microsoffs design
microsoffs design goals
goals for windows
windows xp included
posix application compatibility
support we discuss
sections 22.2.1 security
22.2.1 security windows
windows xp goals
receive a c-2
c-2 security classification
signifies a moderate
protection from defective
software and malicious
extensive code review
review and testing
testing were combined
combined with sophisticated
sophisticated automatic analysis
automatic analysis tools
tools to identify
identify and investigate
investigate potential defects
represent security vuh1erabilities
vuh1erabilities 22.2.2 reliability
22.2.2 reliability windows
stable operating system
extensive stress testing
errors in drivers
drivers the requirements
requirements for windows
microsoft used extensive
manual and automatic
automatic code review
review to identify
issues not detected
detected by testing
set about reviewing
reviewing each area
area to verify
windows xp extended
extended driver verification
verification to catch
catch more subtle
improved the facilities
facilities for catching
catching programming errors
errors in user-level
subjected third-party applications
rigorous certification process
certification process furthermme
windows xp added
facilities for monitoring
monitoring the health
including downloading fixes
fixes for problems
encountered by users
users the perceived
reliability of windows
improved by making
making the graphical
user interface easier
users can discover
perform common tasks
tasks 22.2.3 windows
compatibility as mentioned
update of windows
primarily on compatibility
compatibility for business
applications the requirements
applications that ran
ran on windows
implementation of apis
latent application bugs
windows xp introduced
introduced a compatibility
layer that falls
falls between applications
apis this layer
layer makes windows
compatible with previuus
windows windows xpf
xpf like earlier
earlier nt releasesf
releasesf maintains support
support for running
running many 16-bit
thunkingf or conversionf
layer that translates
translates 16-bit api
16-bit api calls
calls into equivalent
equivalent 32-bit calls
32-bit calls similarlyf
similarlyf the 64-bit
translates 32-bit api
32-bit api calls
calls into native
native 64-bit calls
calls in additionf
additionf posix support
support in windows
subsystem called interix
unix-compatible software compiles
compiles and runs
runs under interix
interix without modification
modification 22.2.4 high
22.2.4 high performance
high performance windows
provide on desktop
multithreaded and multiprocessor
locking and cache-line
management are keys
keys to scalability
satisfy performance requirements
protocols for networks
caching of file-system
data the memory-management
memory-management and synchronization
algorithms were designed
performance considerations related
related to cache
lines and multiprocessors
performance by reducing
reducing the code-path
length in critical
algorithms and per-processor
per-processor data structures
coloring for numa
non-uniform n1emory access
implementing more scalable
scalable locking protocols
locking protocols helped
protocols helped reduce
helped reduce system
reduce system bus
system bus cycles
cycles and included
included lock-free lists
lists and queues
atomic read-modify-write operations
advanced locking techniques
techniques the subsystems
subsystems that constitute
windows xp communicate
highperformance message passing
kernel dispatcherf threads
subsystems of windows
preempted by higherpriority
quickly to external
events in addition
designed for symmetrical
22.2.5 extensibility refers
advances in computing
technology to facilitate
change over tim.e
developers implemented windows
architecture the windows
windows xp executive
runs in kernel
kernel or protected
basic system services
services on top
server subsystems operate
emulate different operating
written for ms-dos
posix all run
run on windows
information on environmental
additional environmental subsystems
added without affecting
affecting the executive
executive in addition
system is running
system and supports
supports distributed processing
processing by remote
open software foundation
foundation 22.2.6 portability
portability an operating
code is isolated
dynamic link library
process the upper
windows xp portability
portability the hal
hal manipulates hardware
isolating the rest
rest of windows
market reasons windows
intel ia32 compatible
ia32 compatible platforms
tested on ia32
ia32 and dec
dec alpha platforms
prior to release
release to ensure
ensure portability windows
runs on ia32-compatible
ia32-compatible and ia64
ia64 processors microsoft
processors microsoft recognizes
recognizes the importance
importance of multiplatform
development and testing
22.2.7 international support
international support windows
api provides specialized
routines to format
money in accordance
accordance with national
national customs string
customs string comparisons
comparisons are specialized
specialized to acc01mt
acc01mt for varying
varying character sets
character sets unicode
unicode is windows
native character code
character code windows
windows xp supports
supports ansi characters
characters by converting
characters before manipulating
system text strings
replaced to localize
localize the system
languages multiple locales
important to multilingual
individuals and businesses
businesses the architecture
system of modules
run in protected
collection of subsystems
subsystems and services
services that run
mode the user-mode
user-mode subsystems fall
provide security functions
advantages of type
type of architecture
interactions between modules
simple the remainder
describes these layers
layers and subsystems
package t security
security account manq.ger
account manq.ger database
manq.ger database figure
windows xp block
diagram 22.3.1 hardware-abstraction
22.3.1 hardware-abstraction layer
layer the hal
software that hides
hides hardware differences
differences from upper
windows xp portable
portable the hal
exports a virtual
virtual machine interface
drivers one advantage
driver is required-it
platforms without porting
porting the driver
code the hal
support for symmetric
symmetric multiprocessing device
multiprocessing device drivers
device drivers map
drivers map devices
devices and access
details of mapping
configuring i buses
setting up dma
coping with motherboard-specific
interfaces 22.3.2 kernel
kernel of windows
four main responsibilities
interrupt and exception
low-level processor synchronization
failure the kernel
kernel is object
oriented an object
type in windows
system-defined data type
functions or operations
type the kernel
performs its job
set of kernel
objects whose attributes
store the kernel
perform the kernel
22.3.2.1 kernel dispatcher
dispatcher the kernel
out of ncemmy
preempted its main
thread sched llling
implementation of synchronization
asynchronous and deferred
deferred procedure calls
dispatching 22.3.2.2 threads
threads and scheduling
threads for executable
code each process
including actual priority
thread is waiting
waiting to run
run the highest-priority
highest-priority ready thread
thread is moved
state a thread
processor it runs
execution time ends
signaling i completion
completion a thread
waits for resources
execution a thread
enters the state
execution the dispatcher
class and real-time
class the variable
class contains threads
dispatcher skips past
executes a special
clock interrupt queues
queues a quantum-end
quantum-end deferred procedure
deferred procedure call
processor in order
order to reschedule
reschedule the processor
base priority lowering
lowering the thread
thread s priority
large priority increase
user s active
active gui window
gui window receives
ready or wait
priority or processor
higher-priority real-tince thread
thread is preempted
thread will start
start to execute
limit 22.3.2.3 implementation
synchronization primitives key
primitives key operating-system
key operating-system data
operating-system data structures
structures are managed
managed as objects
objects using common
facilities for allocation
security control dispatching
dispatching and synchronization
record an event
synchronize this occurrence
action notification events
notification events signal
signal all waiting
synchronization events signal
signal a single
single waiting thread
kernel-mode or user-mode
user-mode mutual exclusion
notion of ownership
deadlock-free mutual exclusion
exclusion the defsemaphore
defsemaphore object acts
counter or gate
gate to control
control the number
threads that access
encapsulates a virtual
timeouts when operations
objects are accessed
accessed from user
handle the user-mode
user-mode code polls
polls or waits
waits on handles
handles to synchronize
22.3.2.4 software interrupts
implements two types
types of software
asynchronous procedure calls
calls and deferred
calls an asynchronous
asynchronous procedure call
thread and calls
apcs are queued
queued to specific
system to execute
execute both system
process s context
context deferred procedure
postpone interrupt processing
processing after handling
handling all blocked
blocked device-interrupt processes
schedules the remaining
processing by queuing
queuing a dpc
dispatcher schedules software
schedules software interrupts
block other lsrs
lsrs in addition
addition to deferring
deferring deviceinterrupt processing
dispatcher uses dpcs
dpcs to process
process timer expirations
preempt thread execution
scheduling quantum execution
execution of dpcs
dpcs prevents threads
apcs from signaling
signaling the completion
completion of dpc
maintains a pool
pool of worker
worker threads isrs
isrs and dpcs
dpcs queue work
queue work itencs
worker threads dpc
threads dpc routines
routines are restricted
call system services
attempt to block
object unlike apcs
dpc routines make
make no assumptions
context the processor
processor is executing
executing 22.3.2.5 exceptions
exceptions and interrupts
interrupts the kernel
handling for exceptions
generated by hardware
windows xp defines
defines several architectureindependent
memory-access violation integer
violation integer overflow
integer overflow floating-point
overflow floating-point overflow
underflow integer divide
illegal instruction data
instruction data misalignment
data misalignment privileged
misalignment privileged instruction
privileged instruction page-read
instruction page-read error
page-read error access
error access violation
access violation paging
violation paging file
paging file quota
file quota exceeded
quota exceeded debugger
exceeded debugger breakpoint
debugger breakpoint debugger
breakpoint debugger single
debugger single step
step the trap
trap handlers deal
deal with simple
simple exceptions elaborate
exceptions elaborate exception
elaborate exception handling
handling is performed
kernel s exception
dispatcher the neve
creates an exception
exception an exception
handler to deal
occurs in kernel
dispatcher simply calls
calls a routine
routine to locate
locate the exception
handler is found
fatal system error
system error occurs
user is left
infamous blue screen
screen of death
death that signifies
signifies system failure
system failure exception
failure exception handling
complex for user-mode
exception handler sends
sends the exception
handle that exception
attempts to find
catch the error
error for debugging
debugger is running
process s exception
port to give
give the environmental
subsystem a chance
chance to translate
translate the exception
posix environment translates
environment translates windows
windows xp exception
signals before sending
thread that caused
caused the exception
kernel simply terminates
terminates the process
exception the interrupt
kernel handles interrupts
interrupts by calling
kernel trap-handler routine
routine the interrupt
interrupt is represented
handle the interrupt
interrupt object makes
easy to associate
associate interrupt-service routines
access the interrupt
interrupt hardware directly
directly different processor
intel and dec
types and numbers
numbers of interrupts
interrupts for portability
interrupt dispatcher maps
maps the hardware
set the interrupts
interrupts are prioritized
serviced in priority
interrupt request levels
represent hardware interrupts
windows xp interrupts
interrupts are defined
defined in figure
bind each interrupt
compute1 ~ windows
separate interrupt-dispatch table
processor s irql
independently to mask
mask out interrupts
interrupts all interrupts
processor are blocked
irql is lowered
returning from interrupt
interrupt processing windows
windows xp takes
interrupts to deliver
apcs and dpcs
perform system functions
start thread dispatches
check or bus
bus error power
error power fail
power fail interprocessor
fail interprocessor notification
request another processor
processor to act
act ; e.g
dispatch a process
process or update
update the tlb
traditional pc irq
irq hardware interrupts
hardware interrupts dispatch
dispatch and deferred
windows xp interrupt
executive the windows
services are grouped
procedure call facility
security reference monitor
plug-and-play and power
booting 22.3.3.1 object
22.3.3.1 object manager
manager for managing
managing kernel-mode entities
set of interfaces
manipulated by user-mode
user-mode programs windows
windows xp calls
calls these entities
component that manipulates
table containing entries
entries that track
track the objects
process user-mode code
user-mode code accesses
accesses these objects
apis object handles
created by duplicating
duplicating an existing
examples of objects
objects are semaphores
dispatcher objects threads
threads can block
kernel dispatcher waiting
signaled the process
virtual memory apis
apis use process
handles to identify
identify the process
objects include files
internal i objects
objects file objects
maintain the open
state of files
map files open
files open files
files are described
file objects local-communication
objects local-communication endpoints
endpoints are implemented
implemented as port
objects the object
object manager maintains
maintains the windows
windows xp internal
internal name space
space in contrast
contrast to unix
roots the system
system name space
abstract name space
space and connects
connects the file
systems as devices
devices the object
manager provides interfaces
interfaces for defining
defining both object
types and object
names to objects
maintaining the abstract
directories and symbolic
managing object creation
counts in protected-mode
code and handles
handles in user-mode
user-mode code howeve1
apis as user-mode
handles to manipulate
handle and stored
process the abstract
persist across reboots
configuration information stored
plug-and-play device discovery
creation of objects
objects by system
components the windows
process ncay create
create a named
object and shares
first process processes
objects by duplicating
handles between processes
case the objects
temporary a perrnanent
perrnanent name represents
represents an entity
process is accessing
temporary nance exists
holds a handle
names are structured
structured like file
file path names
names in ms-dos
ms-dos and unix
unix name space
directories are represented
directory the object
object name space
space is extended
addition of device
device objects representing
objects representing volumes
volumes containing file
file systems objects
objects are manipulated
functions with implementations
manager to search
make security checks
opens or closes
closes an object
duplicates a handle
object the parse
extend the abstract
space to include
files the translation
file object begins
space path-name components
components are separated
separated by whack
unix each component
component is looked
current parse directory
space internal nodes
directories or symbolic
object is found
path-name components remaining
object is returned
object s parse
procedure is invoked
path name parse
-most notably -device
notably -device objects
-device objects representing
objects representing file
representing file systems
systems the parse
device object type
object type allocates
allocates a file
object and mitiates
mitiates an open
open or create
create i operation
system if successful
file object fields
fields are filled
describe the file
file in summary
traverse the object-manager
translatilcg the original
original absolute path
pair this pair
object the file
handle unix file
permit multiple nicknamesor
multiple nicknamesor aliases-for
file the implemented
windows xp object
files with aliases
directory in unix
map standard ms-dos
standard ms-dos drive
ms-dos drive letters
letters to drive
drive names drive
names drive letters
letters are symbolic
remapped to suit
suit the convenience
user or administrator
administrator drive letters
space in windows
global each logged-on
set of drive
users can avoid
server sessions share
share all processes
session basenamedobj ects
named objects created
manager s parse
access a named
attencpts to open
open an object
object that resides
object manager calls
calls the parse
redirector this results
operation that accesses
accesses the file
network as mentioned
objects are instances
object type specifies
specifies how instances
objects these functions
functions implement operations
closing and deleting
security the object
manager keeps track
object the pointer
number of distinct
distinct references made
object protected-mode code
code that refers
refers to objects
objects to ensure
number of handle
handle table entries
table entries referring
object each handle
object is closed
object s close
handle the cleanup
cleanup operation tells
tells the file
accessed by user
removed each handle
handle close removes
removes a reference
internal system components
components may retain
retain additional references
reference is removed
object s delete
manager to send
send the file
system a close
system to deallocate
deallocate any internal
temporary object completes
object is deleted
deleted from memory
memory the object
manager can make
make an object
taking an extra
manager is removed
object manager removes
removes the extra
deleted permanent objects
objects are rare
directory and symbolic
symbolic link objects
objects the job
calls the object
manager s open
reference is inserted
process s object
returned a process
handle by creating
creating an object
opening an existing
receiving a duplicated
inheriting a handle
descriptor these handles
rights and states
process s open
descriptor in unix
process that confers
confers the ability
manipulate a system
system resource handles
whert child processes
out-of-process execution contexts
contexts are implemented
entity that generates
generates object handles
place to check
object manager checks
open the object
manager also enforces
charging a process
objects and refusing
refusing to allocate
accumulated charges exceed
exceed the process
process s quota
login process authenticates
authenticates a user
token is attached
process the access
token contains information
default access-control list
list the services
services and objects
objects a user
access are determined
attributes the token
token that controls
making the access
token is missing
missing and defaults
code on behalf
threads to impersonate
impersonate a client
client s token
token in windows
object is protected
ids and access
access rights granted
compares the security
thread s access
object s access-control
list to determine
determine whether access
permitted the check
check is performed
object is opened
open occurs operating-system
occurs operating-system components
operating-system components executing
kernel mode bypass
bypass the access
code is assumed
code must avoid
avoid security vulnerabilities
leaving checks disabled
disabled while creating
creating a user-modeaccessible
determines the access-control
type s open
user s access-token
object the access
field that controls
auditing of object
object accesses operations
audited are logged
user an administrator
monitors this log
log to discover
attempts to break
access protected objects
objects 22.3.3.2 virtual
22.3.3.2 virtual memory
manager the executive
component that manages
physical memory allocation
underlying hardware supports
hardware supports virtual-to-physical
supports virtual-to-physical mapping
transparent cache coherence
coherence on multiprocessor
allowing multiple pagetable
multiple pagetable entries
entries to map
manager in windows
page-based management scheme
pages of data
disk or mapped
local or remote
file system pages
fills the page
page with zeros
contents on la32
4-gb virtual address
space the upper
access the operating-system
data structures key
structures key areas
references a process
page using physical
physical page-frame numbers
maps the page
single 4-mb region
accessed through virtual
virtual addresses hyperspace
addresses hyperspace maps
maps the current
process s working-set
kernel-mode address space
address space session
space session space
share the win32
system the lower
user and kernel-mode
threads certain configurations
configurations of windows
windows xp reserve
3gb of address
address space rum1ing
rum1ing the system
mode drastically reduces
reduces the amount
applications that manage
larger user-mode address
worth the loss
loss of caching
caching the windows
allocate user memory
first step reserves
reserves a portion
commits the allocation
allocation by assigning
assigning virtual memory
memory or space
windows xp limits
limits the amount
consumes by enforcing
enforcing a quota
quota on committed
process decommits memory
free up virtual
processes the apis
reserve virtual addresses
addresses and commit
commit virtual memory
process to control
control the virtual
environmental subsystems manage
manage the memory
lock selected pages
pages in physical
paging file processes
processes also allocate
allocate raw physical
raw physical mernory
address space ia32
space ia32 processors
physical address extension
64gb of physical
system this memory
windows xp makes
address windowing extension
allocate physical memory
space onto part
memory the awe
sql database windows
memory by defining
maps the memory
space this portion
redefines its view
object to gain
process can control
shared-memory section object
ways the maximum
bounded the section
backed by disk
meaning the section
attempting to access
protection of pages
no-access page raises
raises an exception
exception if accessed
faulty program iterates
user-mode memory allocator
special kernel allocator
configured to map
map each allocation
page to detect
detect buffer overruns
overruns the copy-on-write
copy-on-write mechanism enables
memory more efficiently
processes want independent
places a single
single shared copy
copy into virtual
memory and activates
activates the copy-on-write
makes a private
process the virtual
virtual address translation
translation in windows
multilevel page table
table for ia32
physical address extensions
address extensions enabled
size each pde
size each pte
4-kb in physical
memory the total
pages out individual
out individual tables
tables to disk
structure the page
directory and page
hardware via physical
addresses to improve
self-maps the page
addresses the self-map
manager to translate
translate a virtual
pde or pte
pte without additional
additional memory accesses
context is changed
single page-directory entry
changed to map
directory or page
page table occupy
occupy a sii
sii gle page
number of pdes
pdes or ptes
ptes that fit
determine how virtual
addresses on ia32-compatible
value can represent
value can select
select any entry
table this property
virtual address pointer
pointer is translated
memory a 32-bit
32-bit virtual-memory address
address is split
directory this address
selects one page-directory
table the memory-management
address to select
select a pte
page table layout
layout the pte
specifies a page
frame in physical
memory the remaining
frame the mmu
creates a pointer
byte in physical
memory by concatenating
bits to describe
describe the state
page the ia32
ia32 hardware reserves
system the rest
accessed or written
page is globat
pte is valid
valid ia32 processors
ia32 processors running
running with pae
pdes and ptes
ptes in order
order to represent
represent the larger
larger 24-bit page-frame
24-bit page-frame number
page-frame number field
secondlevel page directories
address space requires
requires an extra
level of page
four pdes translation
top-level directory index
second-level page directories
tables to avoid
avoid the overhead
overhead of translating
translating every virtual
pde and pte
associative memory cache
cache for mapping
mapping virtual pages
pages to ptes
unlike the ia32
tlb is maintained
virtual-to-physical address translation
translation on ia32
invokes a software-trap
supply translations missing
flexibility in choosing
choosing the data
three-level tree structure
structure is chosen
chosen for rnapping
rnapping user-mode virtual
user-mode virtual addresses
ia64 on ia64
bits  worth
bits of top-level
bits of second-level
bits of page
space for windows
processor but represents
represents a tradeoff
memory references required
required to handle
handle tlb misses
address space supported
supported a physical
transition a valid
process a free
pte a zeroed
satisfy zero-on-demand faults
faults a modified
process a standby
copy of information
information already stored
disk standby pages
prefetched to exploit
locality a bad
page is unusable
page frame allocated
allocated in physical
defines the format
bits invalid pages
number of states
represented by bits
pte page-file pages
marked zero-ondemand files
zero-ondemand files mapped
mapped through section
section objects encode
encode a pointer
section object pages
information to find
pte is shown
bits for page
bits for page-file
bits to select
select the paging
bits that describe
describe the page
state a page-file
pte is marked
invalid virtual address
mmu since executable
code and memorymapped
copy on disk
system data structure
file and offset
page state invalid
state invalid virtual
invalid virtual addresses
number of temporary
page is removed
page-file page-table entry
entry the valid
list if written
page is reclaimed
manager uses idle
idle cpu cycles
list and move
zeroed list transition
list transition pages
allocated a physical
awaiting the completion
marked as valid
objects to describe
sharable between processes
virtual page tables
object also includes
process page table
table is marked
hardware mmu reads
directly from memory
pte is edited
edited to point
object the page
object are virtual
created and trimmed
trimmed as needed
prototype pies needed
greatly improves performance
kernel virtual addresses
addresses the prototype
protection and state
shared page generates
generates a page
copy-on-write page marked
makes a copy
page and marks
marks the pte
page any longer
longer shared pages
pages of physical
memory in system
system the entry
n1.anager can maintain
page page frames
frames not referenced
pte are linked
linked to lists
shared physical page
page is marked
count of valid
finds a physical
page to hold
data for zero-on-demand
list is chosen
page is zeroed
read in fron1
unmapped or trimmed
standby or modified
list the thread
thread either waits
reclaims the page
issued to read
read the page
file or file
standby list pages
disk and transferred
working-set manager trims
manager trims pages
memory is unmapped
pages from processes
assigned a default
default minimum working-set
minimum working-set size
windows xp monitors
monitors the page
size and adjusts
adjusts the working-set
replaces and trims
age the age
page is determin.ed
cycles have occurred
pte trimmed pages
pages are moved
page s pte
page immediately needed
immediately needed research
needed research shows
array or fetching
fetching sequential instructions
instructions that form
form the executable
pages this prefetching
reduce the total
page faults writes
clustered to reduce
independent t operations
operations in addition
addition to managing
managing committed memory
manages each process
process s reserved
space each process
tree that describes
describes the ranges
ranges of virtual
manager to fault
fault in page
tables as needed
process s tree
information to fill
pte and retrieve
retrieve the page
allocated and initialized
manager 22.3.3.3 process
22.3.3.3 process manager
manager the windows
windows xp process
manager provides services
services for creating
kn.owledge about parent-child
relationships or process
refinements are left
subsystem that owns
owns the process
setting the priorities
priorities and affinities
affinities in processes
created thread scheduling
thread scheduling takes
dispatcher each process
collected into large
objects allows limits
affinities that control
control multiple processes
manage large data-center
large data-center machines
win32 api environncent
win32 api application
api application calls
application calls createprocess
win32 api subsystem
subsystem to notify
process then calls
calls an api
create the process
process manager calls
manager to create
create a process
object and returns
returns the object
handle to win32
win32 api win32
api win32 api
win32 api calls
calls the process
process and returns
thread the windows
windows xp apis
apis for manipulating
manipulating virtual memory
memory and threads
subsystems can perform
operations on behalf
call is delivered
thread to prompt
prompt the start
start of execution
user-mode image loader
loader the loader
library automatically mapped
created process windows
supports a unix
style of process
creation in order
support the posix
posix environmental subsystem
win32 api environment
api environment calls
apis to create
manager also implements
implements the queuing
queuing and delivery
delivery of asynchronous
system to initiate
initiate thread execution
threads and processes
attach debuggers user-mode
debuggers user-mode code
queue an apc
thread for delivery
delivery of signal-like
notifications to support
manager provides apis
apis that send
alerts to threads
threads to unblock
calls the debugger
process manager includes
includes the capability
capability to suspend
suspend and resume
threads that begin
set a thread
thread s register
context and access
access another process
virtual memory threads
originating a work
manager also supports
impersonation a thread
security token belonging
user can set
set a thread-specific
thread-specific token belonging
user this facility
facility is fundamental
clientserver computing model
act on behalf
variety of clients
22.3.3.4 local procedure
facility the implementation
implementation of windows
nlodel the environn
environn ental subsystems
subsystems are servers
servers that implement
implement particular operating-system
personalities the client-server
implementing a variety
variety of operating-system
environmental subsystems security
subsystems security management
features are implemented
model to reduce
reduce the memory
user-mode thread-pool facilities
facilities to share
threads and wait
wait for messages
facility to pass
requests and results
results between client
windows xp subsystems
lpc is similar
systems for distributed
processing across networks
lpc is optimized
system the windows
windows xp implementation
local machine lpc
mechanism the server
server process publishes
globally visible connection-port
visible connection-port object
client wants services
subsystem s corn1.ection-port
object and sends
sends a connection
port the server
creates a channel
channel and returns
client the charn1.el
pair of private
private communication ports
server-to-client messages communication
messages communication channels
communication channels support
support a callback
server can accept
expecting a reply
channel is created
technique is suitable
sharedmemory section object
size information referring
object this avoids
copy large messages
messages the sender
sender places data
views them directly
ique uses apis
apis that read
space the lpc
lpc provides functions
functions and synchronization
server can access
client the win32
win32 api window
api window manager
form of message
executive lpc facilities
dedicated server thread
thread to handle
64-kb section object
object an event-pair
subsysten to provide
thread has copied
copied a message
win32 api server
versa the section
section object passes
passes the messages
event-pair object performs
object performs synchronization
performs synchronization window-manager
synchronization window-manager messaging
section object eliminates
object eliminates message
eliminates message copying
represents a region
memory the event-pair
event-pair object eliminates
eliminates the overhead
object to pass
messages containing pointers
pointers and lengths
lengths the dedicated
server thread eliminates
overhead of determining
determining which client
thread is calling
calling the server
thread per client
kernel gives scheduling
dedicated server threads
threads to improve
22.3.3.5 i manager
responsible for file
systems are loaded
requests it works
manager to provide
provide memory-mapped file
i and controls
controls the windows
entire i system
models of asynchronous
asynchronous i completion
setting of events
delivery of apcs
apcs to initiating
i completion ports
thread to process
process i completions
threads device drivers
drivers are arranged
converts the requests
requests it receives
forwards the irp
stack for processing
processes the irp
forward the irp
processing is finished
complete the operation
driver is performing
performing its part
forced to block
queue the irp
thread to continue
returns a status
request is pending
thread can continue
operation an irp
processed in interrupt-service
routines and completed
context that initiated
final i processing
thread the stack
stack is built
opportunity to insert
stack as filter
drivers can examine
l operation mount
operation mount management
striping and mirroring
examples of functionality
implemented using filter
drivers that execute
beneath the file
stack file-system filter
file-system filter drivers
filter drivers execute
storage management single
management single instancing
instancing of files
files for remote
dynamic forncat conversion
conversion third parties
drivers to implement
implement virus detection
virus detection device
detection device drivers
drivers for windows
windows driver model
specification this model
requirements for device
layer filter drivers
share common code
code for handling
power and plug-and-play
build correct cancellation
correct cancellation logic
writing a full
full wdm device
wdm device driver
device can involve
involve an excessive
makes it unnecessary
class of similar
shares a common
port driver implements
calls device-specific routines
implement device-specific functionality
functionality 22.3.3.6 cache
22.3.3.6 cache manager
caching is done
centralized caching facility
facility the works
provide cache services
i manager caching
caching in windows
based on files
blocks the size
address space comprise
comprise the system
cache manager maps
manager maps files
manager to handle
i the cache
cache is divided
divided into blocks
block can hold
hold a view
file each cache
block is described
stores the virtual
address and file
view the vacbs
single array maintained
cache manager maintains
maintains a separate
separate vacb index
vacb index array
array that describes
describes the caching
file this array
s-entry vacb index
array an entry
index array points
i manager receives
file s user-level
user-level read request
i manager sends
sends an irp
resides the file
file system attempts
request specifically asks
cache manager calculates
calculates which entry
file s vacb
index array corresponds
request the entry
entry either points
cache manager allocates
allocates a cache
maps the view
block the cache
manager then attempts
attempts to copy
caller s buffer
page fault figure
send a non
non cached read
cached read request
sends another request
requesting a paging
bypasses the cache
manager and reads
reads the data
manager upon completion
vacb is set
set to point
page the data
original i request
shows an overview
operations on cached
i is handled
parallels the normal
i but calls
irp is involved
reaches the file
system and calls
calls the cache
attempts the operation
normal irp path
path a kernel-level
kernel-level read operation
operation is similar
buffer in user
structures that describe
manager s mapping
interface to read
read the metadata
manager s pinning
interface a page
locks the page
physical-memory page frame
move or page
out the page
page after updating
updating the metadata
file system asks
asks the cache
manager to unpin
unpin the page
page a modified
flushes the page
page to disk
disk the metadata
metadata are stored
file to improve
history of read
attempts to predict
predict future requests
cache manager finds
finds a pattern
previous three requests
sequential access forward
forward or backward
request is submitted
finds its data
wait for disk
i the win32
win32 apt openfile
passed the file_flag_sequentialscan
thread s requests
windows xp performs
performs i operations
operations in chunks
amount the cache
responsible for telling
manager to flush
flush the contents
manager s default
behavior is write-back
thread when write-through
caching is needed
process can set
set a flag
flag when opening
opening the file
process can call
call an explicit
explicit cache-flush function
function a fast-writing
free cache pages
chance to wake
flush the pages
pages to disk
disk the cache
cache writer prevents
prevents a process
process from flooding
flooding the system
w11en the amount
free cache memory
memory becomes low
manager temporarily blocks
temporarily blocks processes
blocks processes attempting
data and wakes
wakes the cachewriter
thread to flush
retransmitted this retransmission
retransmission would waste
bandwidth to prevent
prevent such waste
redirectors can instruct
instruct the cache
manager to limit
limit the backlog
backlog of writes
interface to move
move the data
data directly moving
directly moving data
data directly avoids
buffer 22.3.3.7 security
22.3.3.7 security reference
reference monitor centralizing
monitor centralizing management
management of system
object manager enables
manager enables windows
mechanism to perform
perform run-time access
run-time access validation
validation and audit
checks the process
process s security
rights the srm
responsible for manipulating
manipulating the privileges
privileges in security
security tokens special
tokens special privileges
privileges are required
required for users
users to perform
backup or restore
operations on file
users restricted tokens
restrict the damage
done by execution
execution of untrusted
code another responsibility
srm is logging
logging security audit
security audit events
c-2 security rating
security rating requires
ability to detect
detect and log
log all attempts
easier to trace
attempts at unauthorized
srm is responsible
responsible for making
making access checks
log 22.3.3.8 plug-and-play
managers the operating
plug--and-play to recognize
recognize and adapt
configuration for pnp
pnp to work
driver must support
support the pnp
standard the pnp
manager automatically recognizes
automatically recognizes installed
recognizes installed devices
devices and detects
operates the manager
track of resources
care of loading
drivers this management
management of hardware
hardware resources-primarily interrupts
i memory ranges-has
ranges-has the goal
goal of determining
determining a hardware
manager will assign
study system resources
resources before installing
installing new hardware
determine which devices
resources the proliferation
proliferation of pcmcia
devices also dictates
dictates the support
dynamically configurable resources
resources the pnp
pnp manager handles
manager handles dynamic
handles dynamic reconfiguration
loads the installed
sends an add-device
device the pnp
pnp manager figures
out the optimal
optimal resource assignments
assignments and sends
sends a start-device
pnp manager sends
sends a query-stop
asks the driver
driver can disable
disable the device
operations are completed
operations are prevented
prevented from starting
sends a stop
reconfigure the device
request the pnp
supports other requests
query-remove this request
ready to eject
eject a pccard
similar to query-stop
query-stop the surprise-remove
removes a pccard
device without stopping
stopping it first
first the remove
remove request tells
tells the driver
driver to stop
device and release
release all resources
supports sophisticated power
sophisticated power management
systems to reduce
reduce power consumption
extending the battery
life of laptops
laptops the system
system and individual
moved to low-power
standby or sleep
directed at physical
retention the system
system can turn
packets are received
opens a laptop
laptop or pushes
pushes a soft
soft power button
power button windows
hibernate a system
system by storing
storing physical memory
physical memory contents
contents to disk
restoring the system
point before execution
continues further strategies
strategies for reducing
reducing power consumption
consumption are supported
cpu is idle
windows xp moves
moves the system
state requiring lower
requiring lower power
lower power consumption
cpu is underutilized
windows xp reduces
cpu clock speed
save significant power
power 22.3.3.9 registry
22.3.3.9 registry windows
hives for system
default user preferences
required to boot
boot the system
system successfully boots
saves the system
hive as last
last known good
user installs software
produces a system-hive
last-known-good configuration damage
hive from installing
installing third-party applications
common that windows
saves the hives
states like driver
executables and configuration
previously working state
state in cases
operates as expected
expected 22.3.3.10 booting
booting the booting
bios begins executing
executing from rom
rom the bios
booted and loads
loads and executes
executes the bootstrap
disk this loader
format to load
load the ntldr
system device ntldr
determines what device
drivers are needed
needed to boot
ntldr begins kernel
begins kernel execution
execution the kernel
initializes the system
system and creates
creates two processes
internal worker threads
mode the first
first user-mode process
user-mode process created
created is smss
process in unix
establishing the paging
files and loading
loading device drivers
creates the winlogon
winlogon and csrss
csrss processes csrss
api subsystem winlogon
subsystem winlogon brings
including the lsass
lsass security subsystem
remaining services needed
needed to run
run the system
optimizes the boot
process by pre-loading
files from disk
based on previous
system disk access
disk access patterns
patterns at boot
lay out system
out system files
files on disk
disk to reduce
i operations required
required the processes
required to start
start the system
system are reduced
reduced by grouping
reduction in system
sleep and hibernation
capabilities of windows
users to power
left off environmental
subsystems are user-mode
user-mode processes layered
services to enable
including 16-bit windows
posix each environmental
vironm.en t windows
win32 api subsysten1
main operating environment
starts all processes
application is executed
api subsystem calls
manager to load
load the application
application s executable
code the memory
memory manager returns
status to win32
indicating the type
native win32 api
win32 api executable
api environment checks
subsystem is running
process the subsystem
subsystem then takes
startup the environmental
facility to provide
provide operatingsystem services
services to client
processes the windows
architecture keeps applications
applications from mixing
mixing api routines
environments for instance
api application cam1.ot
application cam1.ot make
posix system call
subsystem is run
separate user-mode process
processes the exception
exception is win32
graphical display capabilities
disabled and requires
requires a reboot
reboot the win32
api environment categorizes
environment categorizes applications
graphical or character
thinks interactive output
window win32 api
win32 api transforms
transforms the output
window this transformation
transformation is easy
environmental subsystem calls
calls a win32
routine to display
display the text
api environment performs
performs this function
transfer screen text
text between windows
clipboard this transformation
works for ms-dos
posix command-line applications
applications 22.4.1 ms-dos
22.4.1 ms-dos environment
environment the ms-dos
windows xp environmental
application the vdm
execute or emulate
routines to emulate
emulate the ms-dos
ms-dos rom bios
bios and int
virtual device drivers
ports the vdm
vdm is based
based on ms-dos
application the windows
windows xp command
creates a window
run both 16-bit
16-bit and 32-bit
application is run
command shell starts
starts a vdm
program if windows
ms-dos graphical applications
graphical applications run
run in full-screen
run full screen
ms-dos applications run
ms-dos applications access
access the disk
fail to run
access is restricted
restricted to protect
protect the file
directly access hardware
hardware will fail
fail to operate
operate under windows
hog the cpu
delays or pauses
pauses in execution
execution the scheduler
kernel dispatcher detects
detects such delays
throttles the cpu
application to operate
22.4.2 16-bit windows
16-bit windows environment
environment the win16
win16 execution environment
environment is provided
vdm that incorporates
incorporates additional software
software called windows
windows on windows
routines and stub
routines for window-manager
window-manager and graphical-device-interface
functions the call
win32 api subroutines-converting
addresses into 32-bit
32-bit addresses applications
16-bit window manager
manager or gdi
underlying win32 api
win32 api implementation
true 16-bit windows
16-bit windows wow32
wow32 can multi
processes on windows
applications are single
tlueaded and reside
queue these features
application that stops
stops receivil1.g input
input will block
application can crash
crash other win16
applications by corrupting
corrupting the address
space the user
user can enable
enable multiple win16
multiple win16 environments
environments to coexist
usil1.g the command
applications that users
run on wmdows
mclude common installation
wow32 environment conti11.ues
conti11.ues to exist
il1.stalled on windows
22.4.3 32-bit windows
32-bit windows environment
environment on ia64
ia64 the native
windows on ia64
native ia64 il1.struction
ia64 il1.struction set
set to execute
execute ia32 programs
requires a thunking
layer to translate
translate 32-bit win32
32-bit win32 api
calls-just as 16-bit
16-bit applications require
applications require translation
64-bit windows supports
supports the wow64
environment the implementations
implementations of 32-bit
processor provides direct
execution of ia32
achieves a higher
level of compatibility
compatibility than wow32
wow32 22.4.4 win32
22.4.4 win32 environment
environment as mentioned
subsystem in windows
runs win32 api
win32 api applications
applications and manages
manages all keyboard
robust several features
win32 api contribute
queue the window
window manager dispatches
dispatches all input
process s input
enables the user
user to terminate
needed the win32
api also validates
validates all objects
invalid or wrong
handle the win32
api subsystem verifies
verifies the type
object the reference
object manager prevent
manager prevent objects
deleted to achieve
achieve a high
compatibility with windows
applications be run
modifies the win32
approximate the behavior
system and fail
applications have latent
behavior much closer
closer to windows
-though with reduced
performance and limited
22.4.5 posix subsystem
subsystem the posix
subsysten1 is designed
posix applications written
written to follow
follow the posix
model posix applications
application posix applications
posix subsystem server
subsystem server psxss
server psxss exe
posix dynamic link
link library psxdll
library psxdll dll
posix console session
console session manager
exe although tl1e
tl1e posix standard
windows xp redirection
mechanism posix applications
applications have access
posix environment enforces
environment enforces unix-like
enforces unix-like permissions
permissions on directory
directory trees due
due to scheduling
system in windows
separately for professional
professional desktop systems
systems and servers
compatibility with unix
applications than previous
commonly available unix
run without change
version of interix
interix 22.4.6 logon
logon and security
objects on windows
winlogon is responsible
responsible for responding
secure attention sequence
n1echanism for keeping
keeping an application
application from acting
horse only winlogon
winlogon can intercept
intercept this sequence
sequence in order
order to put
lock the workstation
account and provide
provide the password
card and personal
personal identification number
policies in effect
domain the local
local security authority
security authority subsystem
process that generates
generates access tokens
tokens to represent
system it calls
authentication using information
subsystem or network
database and checks
correct the security
subsystem then generates
generates the access
opening a handle
privileges and quotas
quotas the default
default authentication package
package for windows
windows xp domains
domains is kerberos
responsibility for implementing
implementing security policy
encryption of data
data and keys
system the 16-bit
16-bit fat file
fat file system
including internal fragmentation
lack of access
protection for files
files the 32-bit
32-bit fat file
system has solved
solved the size
size and fragmentation
performance and features
weak by comparison
comparison with modern
modern file systems
systems the ntfs
designed to include
include many features
including data recovery
multiple data streams
volume shadow copies
file compression windows
windows xp continues
advantages of ntfs
important for interoperability
interoperability of media
media with windows
supports additional file-system
additional file-system types
media 22.5.1 ntfs
22.5.1 ntfs internal
layout the fundamental
entity in ntfs
volume a volume
volume is created
windows xp logical
logical disk management
disk management utility
logical disk partition
partition a volume
volume may occupy
occupy a portion
occupy an entire
span several disks
deal with individual
units of disk
size is configured
system is formatted
formatted the default
default cluster size
size for volumes
volumes this cluster
small size reduces
lost to internal
wo11ld be lost
lost when storing
addresses it assigns
system can calculate
calculate a physical
physical disk offset
multiplying the lcn
size a file
file in ntfs
simple byte stream
structured object consisting
consisting of typed
typed each attribute
independent byte stream
written some attribute
types are standard
including the file
file has aliases
descriptor that specifies
specifies access control
access control user
control user data
data is stored
stored in data
attributes most traditional
traditional data files
unnamed data attribute
additional data streams
created with explicit
names for instance
macintosh files stored
windows xp server
named data stream
stream the iprop
component object model
stream to store
properties on ordinary
thumbnails of images
images in general
attribute syntax ntfs
syntax ntfs returns
returns the size
response to file-query
rmming the dir
command every file
ntfs is described
record is determined
system is created
attributes are stored
unnamed bulk data
extent is stored
attribute may fit
inside the mft
pointers are needed
needed to point
fragments -one record
file is described
pointers to overflow
hold the additional
pointers and attributes
attributes each file
quantity that consists
48-bit file number
16-bit sequence number
mft that describes
describes the file
file the sequence
number is incremented
entry is reused
reused the sequence
sequence number enables
number enables ntfs
ntfs to perform
perform internal consistency
internal consistency checks
catching a stale
file 22.5.1.1 ntfs
namespace is organized
hierarchy of directories
directories each directory
store an index
cost of reorganizing
reorganizing the tree
tree is eliminated
level contains pointers
pointers to disk
hold the remainder
tree each entry
timestamp and file
file s resident
information are stored
gather these attributes
files 22.5.1.2 ntfs
22.5.1.2 ntfs metadata
metadata the ntfs
volume s metadata
stored in files
files the first
mft is damaged
special in purpose
purpose they include
include the files
records all metadata
version of ntfs
ntfs that formatted
formatted the volume
bit that tells
checked for consistency
volume are allocated
code for windows
simple rom bootstrap
rom bootstrap loader
loader the boot
volume ; ntfs
record for error
recovery 22.5.2 recovery
simple file systems
damage the file-system
volume is scrambled
scrambled many versions
unix store redundant
store redundant metadata
recover from crashes
program to check
structures and restore
consistent state restoring
involves deleting damaged
deleting damaged files
files and freeing
freeing data clusters
written with user
system s metadata
structures this checking
data ntfs takes
approach to file-system
robustness in ntfs
filesystem data-structure updates
performed inside transactions
structure is altered
writes a log
writes a commit
log to signify
system can restore
restore the file-system
state by processing
processing the log
redoing the operations
operations for committed
undoing the operations
operations for transactions
log the system
checkpoint to recover
grow without bounds
bounds the first
volume is accessed
ntfs automatically performs
automatically performs file-system
performs file-system recovery
recovery this scheme
contents are correct
undamaged and reflect
reflect some consistent
state that existed
extend the transaction
scheme to cover
cover user files
future the log
log is stored
fixed maximum size
queue of log
holds context information
area where ntfs
ntfs should start
recovery in fact
restart area holds
holds two copies
copy is damaged
crash the logging
functionality is provided
addition to writing
writing the log
records and performing
performing recovery actions
service keeps track
log-file service queues
service queues pending
queues pending transactions
in-progress operations complete
flush all data
resets the log
file and performs
performs the queued
transactions 22.5.3 security
security the security
volume is derived
model each ntfs
ntfs file references
references a security
states the access
access privileges granted
user having access
file in normal
permissions on traversal
traversal of directories
directories in file
enabled traversal checks
inherently more expensive
parsing of file
names uses prefix
opening of directory
names 22.5.4 volume
22.5.4 volume management
management and fault
fault tolerance ftdisk
fault-tolerant disk driver
driver for windows
ways to combine
combine multiple disk
multiple disk drives
reliability 22.5.4.1 volume
22.5.4.1 volume set
combine multiple disks
logically to form
form a large
large logical volume
128001-7833611 d logical
two drives volume
partitions a volume
extended without disturbance
data already stored
system the bitmap
extended to cover
newly added space
added space ntfs
space ntfs continues
single physical disk
ftdisk driver supplies
supplies the mapping
disk 22.5.4.2 stripe
22.5.4.2 stripe set
combine multiple physical
multiple physical partitions
interleave their blocks
blocks in round-robin
fashion to form
volume are stored
lcns 0-15 lcns
lcns 16-31 lcns
lcns 32-47 lcns
lcns 48-63 lcns
lcns 64-79 lcns
set with parity
drives physical partition
partition has contributed
allocation wraps ar01md
block a stripe
stripe set forms
forms one large
layout can improve
data in parallel
parallel 22.5.4.3 stripe
22.5.4.3 stripe set
parity a variation
raid levels suppose
disks will store
store data stripes
disk will store
store a parity
stripe the parity
stripes is destroyed
system can reconstruct
data by calculating
calculating the exclusive
ability to reconstruct
reconstruct data makes
data in case
disk failure notice
stripe also requires
stripe seven concurrent
stripes thus require
disks to avoid
creating this bottleneck
spread the parity
disks by assigning
style to build
build a stripe
equal-sized partitions located
disks 22.5.4.4 disk
22.5.4.4 disk mirroring
comprises two equal-sized
two equal-sized partitions
application writes data
partitions are identical
copy safely stored
mirror mirror sets
copy of drive
drives be split
giving each mirror
workload to protect
two separate disk
separate disk controllers
controllers this arrangement
22.5.4.5 sedor sparing
sparing and cluster
remapping to deal
deal with disk
technique called sector
technique called cluster
hardware capability provided
creates a map
map from logical
numbers to good
leaves extra sectors
extra sectors unmapped
drive to substitute
substitute a spare
software technique performed
disk goes bad
block by changing
changing any affected
ntfs also makes
makes a note
block goes bad
loss but sector
sparing or cluster
combined with fault-tolerant
volumes to mask
mask the failure
reconstructs the missing
data by reading
reading the mirror
exclusive or parity
parity the reconstructed
obtained by sector
remapping 22.5.5 compression
compression and encryption
ntfs can perform
perform data compression
compression on individual
directory to compress
compress a file
divides the file
unit is written
algoritln11 is applied
version is stored
stored when reading
ntfs can determine
determine whether data
stored compression unit
clusters to improve
performance when reading
reading contiguous compression
contiguous compression units
prefetches and decompresses
requests for sparse
files or files
technique to save
save space clusters
allocated or stored
gaps are left
sequence of virtual-duster
virtual-duster numbers stored
file when reading
finds a gap
zero-fills that portion
buffer this technique
unix ntfs supports
ntfs supports encryption
encryption of files
files individual files
files or entire
encryption the security
security system manages
manages the keys
retrieve lost keys
keys 22.5.6 mount
22.5.6 mount points
mount points mount
points mount points
form of symbolic
symbolic link specific
specific to directories
directories on ntfs
ntfs they provide
mechanism for organizing
organizing disk volumes
point is implemented
points will supplant
supplant drive letters
long transition due
scheme 22.5.7 change
22.5.7 change journal
change journal ntfs
file system user-mode
system user-mode services
services can receive
identify what files
files have changed
changed the content-indexing
journal to identify
re-indexed the filereplication
network 22.5.8 volume
22.5.8 volume shadow
shadow copies windows
implements the capability
capability of bringing
bringing a volume
creating a shadow
making a shadow
form of copy-on-write
created are stored
copy to achieve
achieve a consistent
requires the cooperation
cooperation of applications
restarted the server
maintain old versions
versions of files
existed at earlier
feature to recover
out a backup
supports both peer-to-peer
peer-to-peer and client-server
facilities for network
management the networking
components in windows
windows xp provide
provide data transport
ability to send
send print jobs
jobs to remote
printers 22.6.1 network
22.6.1 network interfaces
interfaces to describe
networking in windows
internal networking interfaces
3com to separate
separate network adapters
adapters from transport
changed without affecting
data-link and network
model and enables
enables many protocols
protocols to operate
adapters in terms
enables any session-layer
similar reasoning led
mechanism in unix
supports both connection-based
connection-based and connectionless
functions to send
send any type
type of data
data 22.6.2 protocols
22.6.2 protocols windows
implements transport protocols
protocols as drivers
practice the system
discuss a number
variety of network
functionality 22.6.2.1 server-message
22.6.2.1 server-message block
block the protocol
protocol was first
introduced in ms-dos
protocol to send
network the smb
four message types
message types session
types session control
session control messages
messages are commands
commands that start
start and end
end a redirector
server a redirector
redirector uses file
messages to access
server printer messages
remote print queue
receive status information
workstation the smb
protocol was published
number of operating
systems 22.6.2.2 network
22.6.2.2 network basic
basic input system
interface for networks
bios hardware-abstraction interface
hardware-abstraction interface devised
devised for pcs
pcs running ms-dos
running ms-dos netbios
becmne a standard
standard network-programming interface
network-programming interface netbios
establish logical names
establish logical connections
two logical names
support reliable data
reliable data transfer
netbios or smb
22.6.2.3 netbios extended
netbios extended user
extended user interface
introduced by ibm
efficient networking protocol
protocol for windows
windows for workgroups
limitations of netbeui
routing 22.6.2.4 transmission
22.6.2.4 transmission control
control protocol protocol
protocol the transmission
facto standard networking
standard networking infrastructure
networking infrastructure windows
lip to connect
systems and hardware
platforms the windows
windows xp tcp
tcp lip package
lip package includes
includes the simple
simple network-management protocol
dynamic host-configuration protocol
internet name service
support 22.6.2.5 point-to-point
22.6.2.5 point-to-point tunneling
point-to-point tunneling protocol
communicate remote-access server
remote-access server modules
server modules running
running on windows
internet the remote-access
servers can encrypt
internet 22.6.2.6 novell
22.6.2.6 novell netware
novell netware protocols
protocols then ovell
ovell n etware
ipx datagram service
spx transport layer
lans the windows
windows xp nwlink
nwlink protocol connects
connects the netbios
netbios to netware
networks in combination
microsoft s client
service for netware
netware or novell
novell s netware
client for windows
enables a windows
windows xp client
client to connect
server 22.6.2.7 web-distributed
22.6.2.7 web-distributed authoring
authoring and versioning
versioning protocol web-distributed
protocol web-distributed authoring
protocol for collaborative
windows xp builds
builds a webdav
file system building
building this support
file system enables
system enables webdav
webdav to work
encryption personal files
place 22.6.2.8 appletalk
22.6.2.8 appletalk protocol
ocoi was designed
connection by apple
computers to share
share files windows
systems can share
files and printers
printers with macintosh
computers via apple
network is running
running the windows
services for macintosh
22.6.3 distributed-processing mechanisms
mechanisms although windows
support distributed applications
distributed applications mechanisms
mechanisms that support
support distributed processing
processing on windows
windows xp include
pipes and mailslots
microsoft interface definition
interface definition language
netbios in windows
applications can communicate
network using netbeui
22.6.3.2 named pipes
connection-oriented messaging mechanism
messaging mechanism named
mechanism named pipes
interface to netbios
network a process
pipes to communicate
machine since na1ned
pipes are accessed
apply to named
pipes the format
format of pipe
typical remote file
file name format
server_name \ share_name
identifies a server
network ; share_name
identifies any resource
normal file path
connectionless messaging mechanism
unreliable when accessed
intended recipient receives
receives it mailslots
windows computer browser
computer browser service
service 22.6.3.4 winsock
windows xp sockets
sockets api winsock
compatible with unix
windows xp extensions
winsock-compliant protocol stack
stack 22.6.3.5 remote
22.6.3.5 remote procedure
calls a remote
ake a procedure
call to code
machine the client
calls a local
local procedure-a stub
procedure-a stub routine-which
stub routine-which packs
packs its arguments
process the client-side
client-side stub routine
routine then blocks
unpacks the message
calls the procedure
packs the return
stub the client
client stub unblocks
unpacks the results
rpc and returns
caller this packing
packing of argunlents
windows xp rpc
widely computing-environment standard
standard for rpc
windows xp rpcs
portable the rpc
standard is detailed
detailed it hides
differences among computers
sizes of binary
order of bytes
bytes and bits
bits in computer
standard data formats
formats for rpc
rpc messages windows
send rpc messages
messages using netbios
winsock on tcp
pipes on lan
lan manager networks
networks the lpc
similar to rpc
case of lpc
lpc the messages
computer 22.6.3.6 microsoft
22.6.3.6 microsoft interface
tedious and error-prone
error-prone to write
code to marshal
marshal and transmit
unmarshal and execute
marshal and send
send the return
unmarshal and return
return results windows
describe the remote
remote procedure names
results the compiler
language generates header
generates header files
files that declare
declare the stubs
arguments and return-value
generates source code
unmarshaller and dispatcher
application is linked
routines are included
executes the rpc
generated code handles
handles the rest
rest 22.6.3.7 component
22.6.3.7 component object
model the jbjecj
mechanism for interprocess
communication was developed
developed for windows
windows com objects
provide a well-defined
interface to manipulate
manipulate the data
object for instance
microsoft s technology
technology for inserting
spreadsheets into microsoft
network utilizing rpc
rpc to provide
provide a transparent
method of developing
developing distributed applications
applications 22.6.4 redirectors
redirectors and servers
servers in windows
api to access
computer is running
running a cifs
provided by windows
earlier windows systems
object that forwards
forwards i requests
requests to remote
server for performance
performance and security
remote file occurs
manager to request
file be opened
standard unc format
i manager builds
i request packet
i manager recognizes
file and calls
calls a driver
redirectors a redirector
mup to avoid
cache to remember
remember which redirector
redirector can handle
handle this file
file the redirector
sends the network
system the remote-system
remote-system network drivers
network drivers receive
receive the request
request and pass
driver the server
server driver hands
hands the request
proper local file-system
local file-system driver
driver the proper
proper device driver
data the results
sends the data
redirector the redirector
redirector then returns
returns the data
manager a similar
similar process occurs
occurs for applications
win32 api network
api network api
mup for portability
api for network
transport the requests
smb protocol mentioned
22.6.2 the list
list of redirectors
redirectors is maintained
system registry database
database 22.6.4.1 distributed
22.6.4.1 distributed file
file system unc
system unc names
multiple file servers
names explicitly include
supports a protocol
administrator to serve
serve up files
files multiple servers
distributed name space
space 22.6.4.2 folder
22.6.4.2 folder redirection
redirection and client-side
caching to improve
experience for business
switch among computers
administrators to give
users  preferences
settings on servers
store a user
user s documents
server this works
takes a laptop
airplane to give
give users off-line
users off-line access
computer is online
performance the files
files are pushed
computer becomes disconnected
server is deferred
tinle the computer
online 22.6.5 domains
domains many networked
environments have natural
groups of users
laboratory at school
school or employees
access shared resources
group to manage
manage the global
global access rights
maps internet host
internet host names
windows xp domain
group of windows
windows xp workstations
servers that share
common security policy
policy and user
database since windows
protocol for trust
trust and authentication
kerberos realm previous
realm previous versions
idea of primary
primary and backup
backup domain controllers
controllers in addition
previous versions required
required the setup
setup of one-way
trusts between domains
hierarchical approach based
based on dns
hierarchy this approach
number of trusts
trust the domain
controller to give
give correct information
retain the ability
ability to restrict
22.6.5.1 domain trees
trees and forests
manage multiple domains
contiguous dns naming
dns naming hierarchy
hierarchy for managing
managing multiple domains
research.bell-labs.com and pez.bell-labs.com
pez.bell-labs.com as children-domains
research and pez
set of noncontiguous
trees bell-labs.conz andlucent.com
andlucent.com a forest
22.6.5.2 trust relationships
trust relationships trust
relationships trust relationships
allowed only one-way
relationship is configured
band b trusts
trusts are two-way
two-way by default
default transitive trusts
trusts are enabled
authentication traffic suppose
suppose that domains
standard transitive trust
requests must traverse
two leaf nodes
trust the authentications
node 22.6.6 active
22.6.6 active directory
directory ,.,.,cu i.n
implementation of services
services active directory
active directory stores
stores the topology
accounts and passwords
store for technologies
administrators use group
policies to establish
establish uniform standards
standards for desktop
preferences and software
corporate information-technology groups
uniformity drastically reduces
reduces the cost
cost of computing
conjunction with group
class of user
22.6.7 name resolution
process of converting
converting a computer
including windows internet
describe only wins
wins servers maintain
maintain a dynamic
database of name-to-if
name-to-if address bindings
software to query
query the servers
service can survive
survive a server
spread over multiple
multiple machines wins
dhcp updates address
updates address configurations
dhcp client starts
broadcasts a discover
message each dhcp
server that receives
address and configuration
configurations and sends
selected dhcp server
server the dhcp
dhcp server responds
information it gave
address the lease
client the right
attempts to renew
renew the lease
client must obtain
describes five main
objects between processes
sa.lpsecuritydescriptor = null
null ; sa.binherithandle
sa.binherithandle = true
true ; handle
a_semaphore = createsemaphore
ostring a_semaphore ends
ends ; createprocess
enabling a child
child to share
share an object
object by inheriting
handle 22.7.1 access
services that application
application programs obtain
obtain these services
services by manipulating
manipulating kernel objects
objects a process
process gains access
kernel object named
object named xxx
xxx by calling
calling the createxxx
function to open
open a handle
handle to xxx
xxx this handle
handle is unique
return a special
special constant named
constant named invalid.j1andllvalue
invalid.j1andllvalue a process
process can close
close any handle
handle by calling
calling the closehandle
system may delete
delete the object
count of processes
22.7.2 sharing objects
ways to share
processes the first
inherit a handle
calls the createxxx
supplies a securities__attributes
blnheri thandle field
thandle field set
true this field
creates an inheritable
value of true
function s binheri
binheri thandle argument
thandle argument figure
shows a code
sample that creates
creates a semaphore
semaphore handle inherited
child process assuming
assuming the child
handles are shared
child can achieve
achieve interprocess communication
first command-line argument
shares the semaphore
process to give
give the object
process to open
space is global
type for instance
applications 1nay create
object named pipe
distinct-and possibly differentobjects
differentobjects are desired
desired named objects
advantage that unrelated
first process calls
functions and supplies
handle to share
process a handle
handle a_semaphore createsemaphore
process b handle
handle b_semaphore opensemaphore
code for sharing
sharing an object
lookup the object
object by calling
function this method
method of interprocess
communication to pass
pass the duplicated
method is shown
22.7.3 process management
management in windows
unit of code
threads a process
calls the createprocess
routine this routine
loads any dynamic
process and creates
creates a additional
process b access
semaphore ii process
send the value
semaphore to process
message or shared
object ii process
process_a = openprocess
b_semaphore ; duplicatehandle
b_semaphore to access
object by passing
passing a handle
argument to create
functions maintain state
state in static
guard against unsynchronized
access the wrapper
wrapper function beginthreadex
synchronization 22.7.3.1 instance
22.7.3.1 instance handles
handles every dynamic
library or executable
executable file loaded
loaded an application
module to getmodulehandle
null is passed
process is returned
returned the lowest
de-reference a null
access violation priorities
environment are based
chosen win32 api
four priority classes
real time_priority _class
exe would run
run the cbserver
realtime_ pridrity _class
_class only users
increase scheduling priority
scheduling priority privilege
privilege can move
move a process
administrators and power
privilege by default
default 22.7.3.2 scheduling
22.7.3.2 scheduling rule
normalpriority _class windows
22.7.3.3 thread priorities
priorities a thread
initial priority determined
class the priority
specifies a priority
two other designations
adjust the priority
two priority classes
variable-priority class thread_priority
class thread_priority _idle
thread_priority _idle sets
sets the priority
variable-priority threads thread_pridritltimlcritical
threads thread_pridritltimlcritical sets
adjusts the priority
thread dynamically depending
bound the win32
method to disable
disable this adjustment
adjustment via setprocesspriori
functions 22.7.3.4 thread
22.7.3.4 thread synchronization
synchronization a thread
makes it eligible
function the suspend
opposite these functions
set a counter
thread is suspended
synchronize the concurrent
objects by threads
kernel provides synchronization
semaphores and mutexes
mutexes in addition
synchronization of threads
functions another method
method of synchronization
section a critical
region of code
establishes a critical
section by calling
calling ini tializecri
ini tializecri ticalsection
application must call
call entercri ticalsection
section and leavecri
two routines guarantee
attempt to enter
permitted to proceed
routine the critical-section
mechanism is faster
allocate kernel objects
first encounters contention
section 22.7.3.5 fibers
user-defined scheduling algorithm
algorithm a process
threads a major
difference between threads
threads and fibers
threads can execute
tin1e is permitted
permitted to execute
mechanism is included
included in windows
facilitate the porting
legacy unix applications
model the system
creates a fiber
fiber by calling
calling either convertthreadtofi
executing the fiber
created to begin
call swi tchtofiber
application can terminate
terminate a fiber
22.7.3.6 thread pool
thread pool repeated
pool repeated creation
deletion of threads
expensive for applications
applications and services
services that perform
perform small amounts
amounts of work
instantiation the thread
pool provides user-mode
callbacks to waitable
registerwai tforsingleobj ect
apis to bind
callbacks to timeouts
pool s goal
increase performance threads
executing one thing
thread pool attempts
attempts to reduce
number of outstanding
slightly delaying work
delaying work requests
reusing each thread
providing enough threads
utilize the machine
machine s cpus
cpus the wait
wait and timer-callback
devote one thread
thread to servicing
servicing each waitable
handle or timeout
timeout 22.7.4 lnterprocess
22.7.4 lnterprocess communication
lnterprocess communication win32
communication win32 api
api applications handle
applications handle interprocess
handle interprocess communication
sharing kernel objects
popular for windows
windows gui applications
applications one thread
thread can send
window by calling
.posting a message
message and sending
routines are asynchronous
delivered the send
routines are synchronous
block the caller
delivered and processed
processed in addition
addition to sending
message since processes
processes have separate
separate address spaces
copied the system
system copies data
data by calling
message of type
copydatastruct data structure
length and address
windows xp copies
process unlike threads
win32 api thread
input is received
address space void
space void buf
buf = virtualalloc
mem_reserve i mem_top_down
commit the upper
allocated space virtualalloc
buf + ox800000
decommit the memory
allocated address space
address space virtualfree
fragments for allocating
allocating virtual memory
memory via messages
shared input queue
application to block
marks the application
22.7.5 memory management
management the win32
storage 22.7.5.1 virtual
22.7.5.1 virtual memory
memory an application
application calls virtualalloc
reserve or commit
memory and virtualfree
decommit or release
release the memory
memory these functions
enable the application
allocated they operate
operate on multiples
memory page size
greater than ox10000
process may lock
pages into physical
memory by calling
pages a process
process can lock
process first calls
first calls setprocessworkingsetsize
increase the maximum
maximum working-set size
size 22.7.5.2 memory-mapping
22.7.5.2 memory-mapping files
memory-mapping a file
address space memory
space memory mapping
memory memory mapping
map some address
share a memory
needed the process
process calls createfilemapping
handle of oxffffffff
size the resulting
resulting file-mapping object
shared by inheritance
file or create
exist handle hfile
generic_read i generic_write
file_share_read i file_share_write
8mb in size
size handle hmap
hmap = createfilemapping
space mapped void
mapped void buf
buf = mapviewoffile
unmap the file
fragments for memory
file 22.7.5.3 heaps
heaps heaps provide
memory a heap
region of reserved
win32 api process
process is initialized
win32 api functions
heap is synchronized
synchronized to protect
protect the heap
heap s space-allocation
space-allocation data structures
damaged by concurrent
updates by multiple
multiple threads win32
threads win32 api
process can allocate
allocate and manage
manage a private
heap these functions
functions are heapcreate
functions to enable
thread to gain
gain exclusive access
heap unlike virtuallock
perform only synchronization
memory 22.7.5.4 thread-local
22.7.5.4 thread-local storage
storage the fourth
thread-local storage mechanism
storage mechanism functions
rely on global
global or static
data typically fail
fail to work
environment for instance
runtime function strtok
position while parsing
parsing a string
two concurrent threads
threads to execute
separate current position
current position variables
variables the thread-local
storage mechanism allocates
mechanism allocates global
allocates global storage
dynamic and static
methods of creating
creating thread-local storage
storage the dynamic
method is illustrated
thread-local static variable
declares the variable
reserve a slot
variable dword var_index
var_index = t1salloc
value int var
int var t1sgetvalue
release the index
code for dynamic
dynamic thread-local storage
thread-local storage microsoft
storage microsoft design.ed
microsoft design.ed windows
operating system -one
techniques and hardware
supports multiple operating
multiple operating environments
environments and symmetric
including both 32-bit
processors and numa
objects to provide
provide basic services
support for client-server
support a wide
variety of application
run programs compiled
compiled for ms-dos
preemptive scheduling windows
supports a security
security model stronger
previous microsoft operating
systems and includes
includes internationalization features
internationalization features windows
windows xp nms
variety of computers
choose cu1.d upgrade
cu1.d upgrade hardware
hardware to match
match their budgets
budgets and performance
requirements without needing
needing to alter
alter the applications
applications they run
describe the booting
managed in windows
no-access page facility
page facility provided
provided in windows
procedure calls facility
main architectural layers
layers of windows
environment what limitations
limitations are imposed
programs executing inside
inside this environment
protection guarantees provided
applications executing inside
inside the win16
application executing inside
fiber abstraction provided
describe two user-mode
two user-mode processes
processes that enable
run programs developed
describe the management
manager improve performance
call what settings
ntfs handle data
handle data structures
recovery takes place
processes that windows
processors contain registers
address a 64-bit
limits the address
space of user
ntfs directory structure
directory structure differ
obtain a handle
overview of windows
detail about system
server resource kit
six-volume set helpful
microsoft developer network
developer network library
supplies a wealth
wealth of information
information on windows
microsoft products iseminger
windows xp active
active directory richter
discussion on writing
win32 api silberschatz
understand the fundamental
concepts of operating
position to examine
highlights the similarities
chronological or ordered
ordered by importance
describe early systems
reading the papers
style and flavor
flavor to explain
explain how operating-system
operating-system features migrate
large computer systems
systems to smaller
historically important operating
important operating systems
systems one reason
reason to study
study early architectures
eventually have made
i11.to very small
examination of operating
systems for mainframes
mainframes and microcomputers
adopted for microcomputers
classes of computers
handhelds to understand
understand modern operating
recognize the theme
theme of feature
feature migration started
information and computing
operating system multics
multics was developed
institute of technology
migration of operating-system
concepts and features
features a computing
complex mainframe computer
developed for multics
development of multics
design of unix
unix the unix
basis for unix-like
systems on microcomputers
features are included
recent operatirlg systems
systems for microcomputers
mac osx operating
osx operating system
operating system linux
system linux includes
found on pdas
pdas we turn
overview of early
history of computing
computers with looms
looms and calculators
described in frah
graphically in frauenfelder
devices were designed
implemented to perform
fixed tasks modifying
required a great
deal of effort
effort and manual
1940s when alan
turing and john
john von neumann
store provides instructions
data this fundamental
fundamental computer concept
concept quickly generated
generated a number
number of general-purpose
machines is blurred
development during world
first working stored-program
working stored-program general-purpose
stored-program general-purpose computer
first commercial computer
early computing efforts
efforts are described
described by rojas
rojas and hashagen
physically enormous machines
enormous machines run
run from consoles
consoles the programmer
operate the program
operator s console
manually into memory
front panel switches
pushed to set
set the starting
start the execution
programmer i operator
operator could monitor
monitor its execution
console if errors
errors were discovered
programmer could halt
halt the program
examine the contents
memory and registers
debug the program
output was printed
punched onto paper
tape or cards
printing 23.2.1 dedicated
23.2.1 dedicated computer
dedicated computer systems
hardware were developed
developed card readers
tape became commonplace
linkers were designed
designed to ease
ease the programming
programming task libraries
libraries of common
functions were created
created common functions
providing software reusability
reusability the routines
routines that performed
requiring careful programming
programming a special
subroutine-called a device
device driver-was written
device a device
driver a simple
reading a character
involve complex sequences
sequences of device-specific
compilers for fortran
making the programming
task much easier
computer more complex
complex to prepare
prepare a fortran
program for execution
load the fortran
computer the compiler
drive the program
reader and written
tape the fortran
fortran compiler produced
compiler produced assembly-language
produced assembly-language output
assembled this procedure
procedure required mounting
mounting another tape
assembler the output
linked to supporting
supporting library routines
binary object form
memory and debugged
job each job
loading the fortran
fortran compiler tape
compiler tape running
running the compiler
unloading the compiler
compiler tape loading
loading the assembler
assembler tape running
running the assembler
unloading the assembler
assembler tape loading
loading the object
object program running
running the object
beginning each job
step might involve
involve the loading
loading and unloading
unloading of magnetic
cards the job
problem while tapes
programmer was operating
operating the console
cpu sat idle
sat idle remember
expensive a computer
including the operational
costs of power
wanted their computers
investments 23.2.2 shared
23.2.2 shared computer
shared computer systems
systems the solution
solution was twofold
professional computer operator
operator was hired
hired the programmer
operated the machine
job was finished
operator could start
experience with mounting
reduced the programmer
provided whatever cards
cards or tapes
tapes were needed
debug an incorrect
understand the program
case of program
dumping the memory
allowed the operator
operator to continue
job but left
left the programmer
difficult debugging problem
jobs with similar
group to reduce
suppose the operator
received one fortran
load the compiler
two fortran programs
observing the console
memory and register
restart the computer
idle to overcome
overcome this idle
first rudimentary operating
rudimentary operating systems
created to transfer
computer was turned
monitor was invoked
program to execute
data were introduced
introduced to provide
provide this information
monitor the idea
idea is simple
simple in addition
program or data
included the control
resident monitor indicating
indicating what program
normal user program
program might require
separate control card
ftn-execute the fortran
compiler $ asm-execute
asm-execute the assembler
assembler $ run-execute
run-execute the user
program these cards
monitor which program
tvw additional control
additional control cards
cards to define
define the boundaries
job $ end-final
defirte the job
operator to load
load or unload
unload a tape
tape one problem
problem with conh
conh ol cards
data or program
cards the usual
character or pattern
card several systems
identify a control
ibm s job
job control language
first two columns
two columns figure
sample card-deck setup
simple batch system
system a resident
responsible for reading
reading and carrying
out the insh
point of execution
interpreter to load
load system programs
system programs an.d
programs an.d application
an.d application programs
memory at intervals
programs are linked
saving memory space
space and programming
batch systems work
monitor provides automatic
automatic job sequencing
memory and transfers
cycle is repeated
cards are interpreted
monitor automatically continues
job the switch
switch to batch
sequencing was made
made to improve
performance the problem
desirable to replace
replace human operation
operation with operating-system
operating-system software automatic
software automatic job
job sequencing elim.inates
idle the problem
mechanical i devices
slower than electronic
slow cpu works
fast card reader
read 1,200 cards
cards per minute
difference in speed
improvements in technology
resulted in faster
faster i devices
cpu speeds increased
increased even faster
exacerbated 23.2.3 overlapped
replace slow card
slow card readers
units most computer
1960s were batch
batch systems reading
reading from card
readers and writing
writing to line
printers or card
punches the cpu
card was needed
needed for input
record was read
output was written
tape were pri
readers and lilce
printers were operated
advantage of off-line
readers and line
faster magnetic tape
magnetic tape units
tape units card
units card reader
card reader line
reader line printer
card reader tape
reader tape drives
tape drives tape
drives tape drives
tape drives iine
drives iine printer
iine printer figure
online and off-line
gain in off-line
reader-to-tape and tape-to-printer
cpu can process
reader can read
two readers working
simultaneously can produce
produce enough tape
however-a longer delay
run the job
first be read
read onto tape
jobs are read
tape to fill
free tape drive
drive this process
unreasonable for batch
computer although off-line
preparation of jobs
systems disk systems
improved on off-line
operation the problem
problem with tape
rewound and read
nature devices disk
devices disk systems
disk systems eliminated
eliminated this problem
head is moved
reader to store
store new cards
cpu to read
cards are read
disk the location
location of card
images is recorded
job is executed
operating system satisfies
satisfies its requests
requests for card-reader
input by reading
printer to output
output a line
line is copied
job is cmttpleted
printed this form
form of processing
acronym for simultaneous
simultaneous peripheral operation
peripheral operation on-line
operation on-line spooling
buffer for reading
storing output files
accept them disk
disk line printer
line printer figure
data at remote
sites the cpu
data via communication
accepts an entire
entire input job
remote card reader
intervention the cpu
processing is completed
batch of data
data spooling overlaps
reading the input
job while printing
printing the output
reading its cards
cards from disk
disk and printing
printing its output
direct beneficial effect
i devices working
higher rates spooling
rates spooling leads
naturally to multiprogramming
systems the atlas
atlas operating system
university of manchester
manchester in england
parts of modern
operating systems device
systems device drivers
calls were added
set of special
instructions called extra
extra codes atlas
batch operating system
system with spooling
spooling spooling allowed
allowed the system
availability of peripheral
paper tape readers
paper tape punches
feature of atlas
memory management core
drum for primary
memory the atlas
amount of core
drum demand paging
information between core
automatically the atlas
computer with 48-bit
48-bit words addresses
encoded in decimal
extremely large address
large address space
space the physical
memory for atlas
words of core
memory was divided
divided into 512-word
frames in physical
memory an associative
implemented the mapping
page fault occurred
invoked one memory
transfer could start
immediately the page-replacement
page-replacement algorithm attempted
attempted to predict
predict future memory-accessing
future memory-accessing behavior
memory-accessing behavior based
based on past
behavior a reference
frame was set
frame was accessed
accessed the reference
bits were read
retained this history
last two references
pages were chosen
chosen for replacement
page is considered
page-replacement algorithm assumes
assumes that programs
memory in loops
reference is expected
xds-940 operating system
lichtenberger and pirtle
paging for memory
unlike the atlas
system the paging
paging the virtual
process was made
memory was made
words each page
page was made
words the page
registers since physical
memory was larger
larger than virtual
increased by sharing
sharing of pages
contained read-only reentrant
read-only reentrant code
reentrant code processes
system was constructed
xds-930 the modifications
modifications were typical
properly a user-monitor
ltlode was added
added certain instructions
i and halt
privileged an attempt
mode would trap
system a system-call
instruction was added
user-mode instruction set
set this instruction
create new resources
allowing the operating
manage the physical
physical resources files
allocated in 256-word
drum a bit
manage free drum
free drum blocks
blocks each file
block with pointers
data blocks index
blocks index blocks
blocks were chained
system also provided
provided system calls
subprocesses a programmer
programmer could construct
system of processes
processes separate processes
processes could share
memory for communication
communication and synchronization
synchronization process creation
process creation defined
subprocesses are nodes
create more subprocesses
mckeag and wilson
batch system running
words the system
set of concurrent
concurrent processes employing
processes employing semaphores
system was static
static the operating
processes were created
created that served
agents to compile
print user programs
process would return
queue to select
select another job
job a priority
priority cpu-scheduling algorithm
priorities were recomputed
scheme gave higher
gave higher priority
processes memory management
management was limited
lack of hardware
system was limited
limited and user
software paging scheme
compiler automatically generated
automatically generated calls
calls to system
drum a 512-word
lru page-replacement strategy
strategy another major
system was deadlock
control the banker
provide deadlock avoidance
avoidance closely related
semaphores to synchronize
processes the lower
design were implemented
implemented in microcode
howeve1 ~ providing
system the memory
management was changed
changed to paged-segmented
computer by regnecentralen
design a batch
specific system rathel
create an operating-system
complete operating system
structure was layered
levels-comprising the kernel-were
provided the kernel
supported a collection
collection of concurrent
processes a round-robin
round-robin cpu scheduler
processes could communicate
exchanging fixed-sized rnessages
words in length
length all messages
stored in buffers
common buffer pool
pool a message
process it contained
messages were removed
queue in fifo
order the system
supported four primitive
four primitive operations
last two operations
two operations allowed
operations allowed processes
exchange several messages
service its message
processes were handling
handling its messages
messages to remove
remove these restrictions
provided two additional
two additional communication
additional communication primitives
primitives that allowed
allowed a process
process to wait
answer and service
service its queue
treated as processes
processes the device
drivers were code
code that converted
converted the device
interrupts and registers
registers into messages
process would write
terminal by sending
sending that terminal
terminal a message
driver would receive
message and output
output the character
terminal an input
character would interrupt
interrupt the system
system and transfer
driver would create
create a message
character and send
process the compatible
compatible time-sharing system
designed at mit
experimental time-sharing system
users the users
users were provided
set of interactive
commands that allowed
32-kb memory made
words the monitor
users user memory
user memory images
images were swapped
swapped between memory
fast drum cpu
drum cpu scheduling
cpu scheduling employed
employed a multilevelfeedback
multilevelfeedback queue algorithm
quantum for level
first the initial
program was determined
succeeded in demonstrating
convenient and practical
mode of computing
computing one result
result of ctss
ctss was increased
development of time-sharing
systems another result
multics the multics
multics operating system
corbato and vyssotsky
extension of ctss
early tin e-sharing
tin e-sharing systems
desire to proceed
quickly to bigger
systems as larger
designers of ctss
out to create
create a time-sharing
time-sharing utility computing
utility computing service
provided like electrical
electrical power large
power large computer
connected by telephone
wires to terminals
terminals in offices
offices and homes
city the operating
time-shared system running
vast file system
system of shared
multics was designed
team from mit
sold its computer
department to honeywell
computer was modified
addition of pagedsegmentation
pagedsegmentation memory hardware
hardware in multics
address was composed
18-bit segment number
16-bit word offset
offset the segments
paged in 1-kb-word
pages the second-chance
second-chance page-replacement algorithm
segmented virtual address
space was merged
segments were addressed
multilevel tree structure
structures like ctss
queue for cpu
cpu scheduling protection
protection was accomplished
set of protection
rings for executing
processes the system
allowing a cpu
out of service
service for maintenance
system continued running
running the longest
line of operating-system
computers the early
early ibm computers
development of common
common l subroutines
simple batch processing
processing these systems
systems were developed
ibm was faced
ibm was designed
designed to alter
alter this situation
family of computers
spanning the complete
range from small
small business machines
machines to large
large scientific machines
set of software
arrangement was intended
intended to reduce
reduce maintenance problems
problems for ibm
users to move
programs and applications
file system included
included a type
field that defined
defined the type
types were defined
defined for fixed-length
fixed-length and variable-length
blocked and unblocked
unblocked files contiguous
files contiguous allocation
guess the size
file the job
making it incomprehensible
user the memory-management
routines were hampered
base-register addressing mode
program could access
modify the base
addresses were generated
cpu this arrangement
arrangement prevented dynamic
prevented dynamic relocation
program was bound
bound to physical
memory at load
two separate versions
system were produced
regions the system
language by thousands
thousands of programmers
resulting in millions
code the operating
system itself required
required large amounts
code and tables
tables operating-system overhead
overhead often consumed
total cpu cycles
versions were released
released to add
add new features
fixing one error
error often caused
remained fairly constant
fairly constant virtual
constant virtual memory
memory was added
architecture the underlying
underlying hardware provided
provided a segmented-paged
segmented-paged virtual memory
memory new versions
ways os created
created one large
space and ran
ran os lie
lie that virtual
programs os release
provided each user
virtual memory mvs
basically a batch
system the ctss
system was run
developers at mit
ibm s successor
small for multics
switched vendors ibm
ibm then decided
decided to create
lett and konigsford
tss was supposed
utility the basic
architecture was modified
memory several sites
tss was delayed
developed as temporary
ibm s cambridge
cambridge scientific center
scientific center developed
center developed cms
machine to run
meyer and seawright
site would switch
sharing on ibm
tso under mvs
tss nor multics
multics achieved commercial
achieved commercial success
purposes minicomputers died
replaced by general
general and special-purpose
servers although personal
personal computers continue
continue to increase
increase in capacity
capacity and performance
tend to stay
number and speed
servers typically run
run in data
centers or machine
personal computers sit
desks and talk
network the desktop
rivalry between apple
apple and microsoft
microsoft continues today
windows and mac
usability and application
functionality other operating
two leading desktop
leading desktop operating
continues to gain
gain in popularity
technical users -and
users on systems
children s connected
connected computer network
freiberger and swaine
operating system traces
traces its ancestry
accent operating system
operating system developedatcarnegiemellon
system developedatcarnegiemellon university
rashid and robertson
mach s communication
system and philosophy
philosophy are derived
derived from accent
system and task
task and thread
1989l and accetta
scheduler was described
described in detail
detail by tevanian
shared-memory and memory-mapping
system was presented
presented by tevanian
goals in mind
system can run
correctly under mach
supports many memory
parallel and distributed
simpler and easier
easier to modify
mach s development
path from bsd
bsd unix systems
unix systems mach
systems mach code
initially developed inside
inside the 4.2bsd
kernet with bsd
bsd kernel components
kernel components replaced
replaced by mach
components were completed
completed the bsd
components were updated
memory and communication
subsystems were running
dec vax computer
vax computer family
including multiprocessor versions
workstations followed shortly
multimax and sequent
sequent balance multiprocessor
balance multiprocessor versions
first official releases
mach provided compatibility
systems by including
features and capabilities
capabilities of mach
made the kernels
bsd kernels mach
moved the bsd
microkernel this system
implements only basic
basic mach features
evicted to run
run in user-mode
user-mode servers excluding
servers excluding unix-specific
excluding unix-specific code
rom the kernel
replacement of bsd
multiple operating-system interfaces
interfaces on top
microkernel in addition
addition to bsd
developed for dos
osf this approach
approach has similarities
virtual machine concept
machine is defined
defined by software
mach kernel interface
hardware with release
variety of systems
including single processor
single processor sun
machines and multiprocessor
encore systems mach
mach was propelled
forefront of industry
brainchild of steve
apple computer fame
release of osf
occurred a year
system of choice
members osf members
osf members i.j.l.cluded
members i.j.l.cluded key
i.j.l.cluded key technological
key technological companies
changed its direction
kernel unlike unix
developed without regard
regard for multiprocessing
mach incorporates multiprocessing
incorporates multiprocessing support
ranging rom shared-memory
rom shared-memory systems
systems to systems
shared between processors
mach uses lightweight
form of multiple
multiprocessing and parallel
computation its extensive
communication method ensures
ensures that protection
mechanisms are complete
complete and efficient
efficient by integrating
mach also ensures
ensures that messages
system use messages
messages to communicate
managing the backing
mach provides great
tasks by providing
buik mach reduces
reduces the size
kernel while permitting
permitting operating-system emulation
ibm s virtual-machine
systems some previous
editions of operating
system concepts included
included an entire
chapter on mach
mach this chapter
properties the mcp
mcp operating system
language it supported
segmentation and multiple
cpus the scope
scope operating system
system the coordination
coordination and synchronization
surprisingly well designed
history is littered
littered with operating
systems that suited
suited a purpose
replaced by operating
supported newer hardware
trend will continue
page replacement algorithm
ctss and multics
operation and blocks
units are allocated
scheduled for execution
minimize the discrepancy
discrepancy between cpu
speeds on early
evolution of operating
systems to gain
foundation for unix
summer usenix conference
transactions on computer
promise of internet
processing encrypted data
glance at recent
akyurek and salem
adaptive block rearrangement
conference on data
media in solaris
winter usenix conference
performance of spin
spin lock alternatives
alternatives for shared-money
ieee trans parallel
trans parallel distrib
parallel distrib sysl
implications of thread
thread management alternatives
alternatives for shared-memory
transactions on computers
effective kernel support
management of parallelism
symposium on operati11g
operati11g systems principles
serverless network file
symposium on operating
operating systems principles
interposed request routing
routing for scalable
scalable network storage
operating systems design
design and implementalion
apple technical introduction
macintosh family addison-wesley
thana and finkelstein
superdense optical storage
real time scheduling
deadline monotonic approach
workshop on real-time
real-time operating systerns
systerns and software
implications for intrusion
conference on computer
computer and commuuications
marzullo  consistent
consistent global states
states of distributed
concepts and mechanisms
pages 55-96 addison-wesley
annual tee cal
distribl1ted file system
acm s tjnzposiwn
tjnzposiwn on operating
lvi f kaashoek
data in p2p
implementing lock-free shared
lock-free shared data
algorithms and architectures
fast mach network
mach network ipc
network ipc implementation
user-level network interface
interface for parallel
proceedings of tlze
tlze acm sy1nposium
sy1nposium on operating
comparison of next-fit
study of replacement
ibm systems journal
anomaly in space-time
communications of tlze
tcp lip protocol
lip protocol suite
computer comnzunication.s reuiew
principles of concurrent
concurrent and distributed
role of optical
optical storage technology
technology for nasa
systems and applimtions
bernstein and goodman
algorithms for concurrency
control in distributed
distributed database systems
control and recovery
recovery in database
considerations for non-blocking
non-blocking concurrent objects
ieee international conference
conference on distributed
distributed computing systems
extending the unix
tlze winter usenix
lightweight remote procedure
safety and performance
spln operating system
tile acm symposium
operating stjstems principles
mutlithreading in win32
introduction to programming
programming with threads
implementing remote procedure
concepts and evolution
support for concurrency
concurrency and parallelism
paged time sharing
distributed schedule management
ttger vtdeo .fileserver
symposiwn on operating
object-caching kernel memory
kernel memory allocator
magazines and vmem
extending the slab
cpus and arbitrary
nix annual technical
annual technical conference
understanding the linux
oreilly & associates
understanding the limtx
win32 system services
implementation of tbe
tbe .first-fit strategy
strategy for dynamic
transactions on programming
languages and systems
management of replicated
-practice and experience
com7 ! 1ltnications
operating system principles
the newcastle connection
connection or unixes
practice and experience
exclusion with linear
waiting using binary
binary shared variables
programming with posjx
high pe7formance cluster
pe7formance cluster computing
architectures and systems
instrumation of production
wsc ! ock-a
simple and effective
algoritlun for virtual
virtual memory management
carvalbo and roucairol1983
on mutual exclusion
history of modem
determining global states
exercise in distributed
architecture and programming
single-address-space operating system
reliable secondary storage
acm computing surveys
portable real-time operating
firewalls and internet
repelling the wily
cheung and loong
issues of operating
operating systems structuring
microkemel to extensible
operating systems review
advances in computer
computer mass storage
mass storage technology
win32 multithreaded programming
introduction and overview
afips fall joint
fall joint computer
joint computer conference
experimental time sharing
time sharing system
aflps fall joint
introduction to algorithms
distributed systems concepts
concepts and designs
control with readers
parallel computer architecture
morgan kaufmann publishers
inside the windows
wide-area cooperative storage
storage with cfs
applying the rsa
rsa digital signature
signature to electronic
problem in concurrent
programming and control
introduction to operating
working set model
model for program
working sets past
past and present
transactions on software
cryptography and data
protecting public keys
keys and signature
signatures with rsa
denning and denning
design of multiprogrammed
semantics for mu.ltiprogrammed
pietro and mancini
security and privacy
issues o handheld
handheld and wearable
wearable wireless devices
diffie and hellman1976
directions in cryptography
transactions on information
privacy and authentication
concurrent programming control
ordering of sequential
evaluation criteria department
optimizing the idle
transparent process migration
taube1 ~ storage
alternatives for mobile
adaptive disk spin-down
disk spin-down policies
policies for mobile
symposium on mobile
mobile and location
location independent computing
high-bandwidth cross domain
cross domain transfer
domain transfer facility
system security extensions
network working group
request for comm.ents
comments on dijksh
programming control problem
signal stack trick
trick for user-space
user-space thread creation
usenix annual technical
notions of consistency
consistency and predicate
reevaluating online superpage
online superpage promotion
superpage promotion witl1
promotion witl1 hardware
witl1 hardware support
symposium on high-pejformance
high-pejformance computer architecture
security for superusers
break the unix
issues and strategies
strategies for users
making unix secure
technique for global
global microcode compaction
folk and zoellick
sense of sel
proceedings of lite
lite ieee sy1uposiwn
sy1uposiwn on security
handbook of lan
universal history ofcol
ofcol ! lpuling
wiley and sons
computer-an illustrated histon
searching for denser
laser optical disk
revolution in on-line
optical file cabinet
random-access file system
system for write-on
write-on optical disks
ganapathy and schimmel1998
general purpose operating
purpose operating system
usenix technical conference
fast and flexible
flexible application-level networking
networking on exokernel
elections in distributed
unix & lntemel
1nposiwn on operating
network-attached secure disks
gibson et al.1997b
file server scaling
scaling with network-attached
measurement and modeling
modeling of computer
sealing for infonnation
secrecy and authentication
concurrency in practice
environment for untrusted
untrusted helper applications
6th usenix security
usenix security syrnposiwn
colden and pechura
structure o microcomputer
networks in action
ieee internet computini
java development kit
synzposium on internet
technologies and systems
efficient synchronization primitives
primitives for large-scale
large-scale cache-coherent multiprocessors
conference on architectural
support for programming
languages and operaling
tlzejava language specification
covindan and anderson
scheduling and ipc
mechanisms for continuous
crampp and morris
unix operating-system security
at&t bell laboratories
bell laboratories technical
laboratories technical journal
notes on data
data base operating
base operating systems
the transaction concept
virtues and limitations
communications in unix
system r database
modeling power management
management for hard
symposium on modeling
modeling and simulation
simulation of computer
computer telecomnnmimtion systems
file systems design
prevention of system
scheduling to minimize
minimize average completion
off-line and on-line
symposium on discrete
analysis of virtual
virtual versus physical
versus physical process-migration
physical process-migration strategies
strategies for distributed
simulation of mob.ile
mob.ile computing networks
harchol-balter and downey
exploiting process lifetime
process lifetime distributions
distributions for dynamic
dynamic load balancing
harish and owens
load balancing dns
century of disk
disk file imwvation
journal of research
java network programming
protection in operating
windows system programming
zebra striped network
striped network file
network file system
acm ti ansactions
deadlock in multitasking
ibm systems joumal
adding c2 security
features to unix
summer use nix
fair share scheduler
at&t bell labomtories
bell labomtories technical
labomtories technical joumal
methodology for implementing
implementing highly concurrent
highly concurrent data
concurrent data objects
programming and systems
support for lock-free
lock-free data structures
twentiefh annual intemational
annual intemational symposium
symposium on computer
file system design
file server appliance
infonnation storage tedmology-a
theory of parallel
hoare and perrott
operating system structuring
system structuring concepf
comllwnications ofl-lie acm
comments on prevention
properties of computer
yarning java threads
scale and performance
manchester university atlas
university atlas operating
user s description
secure path vector
path vector routing
vector routing scheme
scheme for securing
proceedings of acm
acm sigcomm conference
secure on-demand routing
on-demand routing protocol
oft he annual
annual international conference
conference on mobile
computing and networking
columbus chicken statute
technical reference ibm
reference ibm corporation
andj g jodeit
storage allocation system
programmer s reference
reference manual intel
manual intel corporation
user s manual
reference intel corporation
i486 microprocessor programmer
pentium processor user
architecture and programming
programming manual intel
active directory services
services for microsoft
software-mm1aged address translation
symposium on high
high performance computer
performance computer architecture
architecture and implementation
memory in contemporary
ieee micro magazine
issues of implementation
ieee computer magazine
uniprocessor virtual memory
memory without tlbs
disk scheduling algorithms
scheduling algorithms based
based on rotational
time-driven scheduling model
model for real-time
ieee real-time systems
real-time systems symposium
johnstone and wilson
memory fragmentation problem
first international symposium
symposium on memory
extension for expressing
constraints on data
performance and flexibility
flexibility on exokernel
disk system architectures
architectures for high
high performance computing
kay and lauder
fair share scheduler
internals and data
secure border gateway
border gateway protocol
joumal on selected
areas in comrnunications
optical disk data
disk data storage
alternative to event
queues for synchronization
synchronization in monitors
access right expressions
languages and syslems
implementation of tripwire
file system integrity
system integrity checker
disk arm movement
movement in anticipation
anticipation of future
acm il ansactions
ansactions on computer
coda file system
fast storage allocator
art of computer
sorting and searching
disk file allocation
file allocation based
32-way multithreaded sparc
multithreaded sparc processor
non-blocking write protocol
write protocol nbw
real-time synchronisation problem
limitations of dijkstra
dijkstra s semaphore
primitives and petri
retaining suid programs
summer usenjx conference
architecture for global-scale
global-scale persistent storage
proc of architectural
languages and operating
computer networking-a top-down
networking-a top-down approach
top-down approach featuring
featuring the intemet
solution of dijkstra
dijkstra s concurrent
concurrent progra1mning problem
synchronization of independent
implementation of reliable
reliable distributed multiprocess
distributed multiprocess systems
1978bj l lamport
ordering of events
authentication with lnsecure
mutual exclusion problem
fast mutual excll
excll ! sion
acm ij ansactions
ansactions on progrmnming
dynamic protection stmctures
tlze afips fall
annual princeton conference
conference on information
information systems science
lampson and redell1979
experience with processes
processes and monitors
monitors in mesa
7th acm symposium
distributed data storage
data storage system
xerox research center
models of computer
systems-toward a formal
larson and kajla
method guaranteeing retrieval
improved rate-monotonic admission
rate-monotonic admission control
ti-ansnctions on computers
perspective on file-sharing
distributed virtual disks
seventh international conference
programming and operating
4.3bsd unix operating
rate yionotonic scheduling
yionotonic scheduling algorithm
characterization and average
average case behaviour
proceedings of 10th
10th ieee real-time
ieee real-time sijstenzs
real-time sijstenzs stjmposiwn
cryptology in transition
support distributed multimedia
distributed multimedia applications
journal of selected
areas in communications
policy i mechanism
separation in hydra
progrmmning with threads
sun microsystems press
progrmmning with jaw
lichtenberger and lvl
lvl w pirtle
facility for experimentation
experimentation in man-machine
aflps fall joirll
fall joirll computer
joirll computer conference
java virtuallvlachine specificalioll
analysis of optimal
optimal thread pool
thread pool size
synchronization primitive systems
primitive systems phd
systems phd thesis
venus operating system
liu and layland
andj w layland
hard real-time environment
foiling the system
security and access
future of peer-to-peer
linux kernel development
developer s library
linux kemel development
multiflow trace scheduling
trace scheduling compiler
journal of supercomputing
giant black book
book of computer
american eagle publications
book of email
higher disk head
disk head utilization
extracting free bandwidth
bandwidth from busy
busy disk drives
square root algorithm
algorithm for mutual
exclusion in decentralized
acm ti ansnctions
ansnctions on computer
viass storage systems
mass storage systems
first-class user-level threads
13th acm symposium
operating systems principle
techniques for storage
mauro and mcdougall2007
solar is internals
core kernel arcl1itecture
mccanne and jacobson
the bsd packet
bsd packet filter
architecture for user-level
user-level packet capture
processors are here
usenjx ; login
control in parallel
studies in operating
algorithm for disk
caching with limited
design and imple
111cl1talion of l11e
l11e frcebsd unix
frcebsd unix operating
system for unlx
dual-threaded ltanium processor
algorithms for scalable
synchronization on shared-memory
locking and deadlock
distributed data bases
processor capacity reserves
computing and systems
virtual machine time-sharing
machine time-sharing system
microsoft ms-dos user
user s reference
reference and microsoft
microsoft ms-dos programmer
reference microsoft press
resource kit microsoft
kit microsoft press
developer network development
network development library
development library microsoft
library microsoft press
concepts and design
analysis of file
unix supercomputing environment
acm computing survcljs
names-concepts and facilities
model of distributed
symposium on principles
principles of database
fundamental design problems
problems of distributed
real-time environment phd
environment phd thesis
institute of teclmology
protection in programming
distributed personal computing
personal computing environment
risc microprocessor user
mullendej ~ distributed
myers and beigl2003
transparent operating system
support for superpages
usenix on operating
cambridge cap computer
sprite network file
peter norton programmer
distributed deadlock detection
deadlock detection algorithm
transactions on database
mass storage system
virtual optical disks
optical disks solve
solve the on-line
on-line storage crunch
embedded oss gain
gain the inside
ousterhout the role
cmu computer science
25th anniversary commemorative
bsd file system
sprite network-operating system
storage and virtual
virtual machine concepts
smokers  problem
problem without conditional
limitations and capabilities
capabilities of dijkstra
primitives for coordination
coordination among processes
case for redundant
arrays of inexpensive
acm sigmod international
sigmod international conference
conference on tlze
management of data
presence of faults
estimating file access
network layer protocols
protocols with byzantine
byzantine robustness phd
robustness phd thesis
myths aboutthe mutual
aboutthe mutual exclusion
information processing letters
security in computing
scheduling for cache
support for programrning
pinilla and gill2003
independent vs performance
operating system review
locus distributed system
distributed system arclzilecturc
vmin-an optimal variable
optimal variable space
variable space page-replacement
space page-replacement algoritlun
file replication facility
facility for berkeley
software-practice and experience
ands m stigler
propertieso.f the buddy
system v network
rig to accent
accent to mach
eee computer society
conm1unication-oriented network operating
mutual exclusion algorithms
raynal and singhal1996
causality in distributed
iria tntemotional workshop
workshop on protection
implementing atomic actions
actions on decentralized
synchronization with eventcounts
eventcounts and sequences
programming model matters
recent widespread computer
widespread computer break-ins
an optimal algoritlun
algoritlun for mutual
file system approach
approach for integrating
integrating removable media
removable media devices
devices and jukeboxes
optical information systems
storage for large-scale
large-scale data mining
mining and multimedia
proceedings of 24th
24th lnternntional conference
large data bases
mapping the gnutella
ieee internet volume
on digital signatures
signatures and public
public key cryptosystems
scheduler for freebsd
tlze usenix bsdcon
usenix bsdcon conference
schroedet ~ automatic
.reconfiguration in autonet
symposium on opeml
opeml ing systenzs
ing systenzs principles
first and architectures
acm symposiunt oil
symposiunt oil opera
oil opera ling
opera ling systems
ling systems principles
system level concurrency
level concurrency control
control for distributed
a11d j wilkes
unix disk access
oft he wiuler
wiuler usenjx confereuce
introduction to disk
disk drive modeling
17-29 ! rush
mposiwn on opemti11g
opemti11g srjstcujs principles
rushby and randell1983
computer security basics
microsofl windows internals
protection of information
information in computer
proceedings of tile
sun network file
implementation and experience
sun nelwork filesystem
removable hard disks
hard disks replace
replace the floppy
highly available distributed
distributed file access
practical network support
automated disk drive
disk drive characterization
asynchronous message passing
message passing primitives
principles of distributed
schneide1 ~ synchwnization
synchwnization in distributed
feedback to lower
lower priority queues
detecting causal relationships
causal relationships i11
relationships i11 distributed
i11 distributed computations
game of wits
disk scheduling revisited
winter use nix
system for unix
file system logging
system logging versus
logging versus clustering
reliable remote procedure
procedure call mechanism
process scheduling challenges
era of multi-core
fntd technology journal
database systen1 concepts
l and memory
memory caching subsystem
subsystem for netbsd
annual technical conference-freenjx
technical conference-freenjx tracie
papers on holographic
optical engineering press
machine for networked
disk cache-miss ratio
cache-miss ratio analysis
analysis and design
distributed mobile storage
mobile storage system
conference on file
file and storage
inside microsoft windows
crisis and aftermath
construct for reliable
reliable distributed computing
acm sigops operating
sigops operating systems
local and metropolitan
metropolitan area networks
cryptography and network
principles and practice
softvvare communication mechanisms
procedure calls versus
calls versus messages
directions in real-time
real-time and embedded
message passing communication
passing communication versus
communication versus procedure
versus procedure call
procedure call communication
analyzing the multimedia
multimedia operating system
method for dynamic
nix network programming-volume
unix network programming-volume
unix network programrning
network programrning inter
programrning inter process
inter process communications
process communications volume
proportional share resource
share resource allocation
resource allocation algorithm
algorithm for real-time
ieee real-tim.e systems
real-tim.e systems symposium
inside the machine
system for internet
virtualizing i devices
devices on vmware
workstation s hosted
hosted virtual machine
virtual machine monitor
network programming guide
programming guide sun
guide sun microsystems
servers for network-based
network-based distributed systems
andy a khalidi
table for 64-bit
fine-grained dynamic instrumentation
instrumentation of commodity
commodity operating system
design and tmplementation
structured computer organization
modem operating systerns
principles and paradigms
tanenbaum and woodhull1997
survey of remote
analysis of disk
disk scheduling policies
battle for control
interface for shared
memory and memory
memory mapped files
files under mach
model for future
scalable distributed file
reflections on trusting
communications of acm
languages for mobile
avoiding a data
transactions and consistency
consistency in distributed
distributed database management
database management systems
mpeg-2 video compression
video compression tutorial
coloquium on mpeg-2
vee and hsu
locality-preserving load-balancing mechanisms
mechanisms for synchronous
simulations on shared-memory
inside the java
efficient software based
software based fault
based fault isolation
efficient software based
extensible security architectures
architectures for java
autorald hierarchical storage
acm transacl ions
ions on computer
systems architec networ
networ ! cing
implementation o schedlller
netbsd operating system
survey and critical
workshop on memory
unix system security
controllability of computer
computer performance tradeoffs
performance tradeoffs obtained
obtained using controlled-share
controlled-share queue schedulers
andy n patt
algoritlm1s for modern
conference on measurernent
measurernent and modeling
extraction of scsi
scsi disk drive
disk drive parameters
sigmetrics on measurement
monitors for multiprogramming
experimental computer systern
lightweight directory access
directory access protocol
request for cormnents
eppinge1 ~ the
duality of memory
multiprocessor operating system
capacity for performance
thread performance comparison
2nd usenix windows
windows nt synzposium
securing ad hoc
hoc routing protocols
worlcshop on wireless
hermesy and patterson
morgan kaufmam1 publishers
reprinted with permission
adapted with permission
permission from sun
international business machines
business machines corporation
machines corporation reprinted
reprinted by permission
permission of ibm
ibm corporation figure
pentiwn processor user
permission of intel
intel corporation figures
scheduling in sunos
proceedings of winter
derived with permission
due to dan
sections of chapter
database systern concepts
commit protocol lobaset
protocol lobaset ethernet
876-877 50-percent rule
file access access
access access control
841-843 access-control list
598-602 and access
602-605 and revocation
606-607 access rights
operating system service
440-443 adaptive mutex
additional sense code
additional sense-code qualifier
318-319 address resolution
address resolution protocol
logical vs physical
824-825 address-space identifiers
793-794 admission-control algorithms
advanced encryption standard
advanced technology attachment
471-479 contiguous allocation
471-473 indexed allocation
476-477 linked allocation
473-476 and performance
398-399 analytic evaluation
718-723 file operations
720-721 anomaly detection
procedure calls api
application program interface
program interface apple
interface apple computers
apple macintosh computer
569-570 network devices
568-569 application layer
658-660 multistep processing
66-67 with virtual
56-57 application proxy
application proxy firewalls
12-18 clustered systems
16-18 multiprocessor systems
13-16 single-processor systems
12-13 of windows
archived to tape
address-space identifiers assignment
identifiers assignment edge
642-643 asymmetric multiprocessing
854-855 asynchronous thread
asynchronous thread cancellation
733-736 atomic transactions
257-267 and checkpoints
262-267 and locking
264-265 and serializability
262-264 and timestamp-based
265-267 system model
257-260 write-ahead logging
denial-of-service attacks man-in-the-middle
643-645 in linux
automatic work-set trimming
xplt 4-6 automount
4-6 automount feature
607-608 back door
base file record
basic file systems
bayes  theorem
335-336 bit-interleaved parity
bit-interleaved parity organization
517-518 boot control
block-interleaved parity organization
526-527 block-level striping
boot control block
bottom half interrupt
half interrupt service
122-123 bourne shell
39-40 b1 tree
879-880 buddy heap
bus-mastering i boards
483-484 and remote
location of cache
711-712 update policy
484-485 in windows
870-872 cache coherency
cachefs file system
166-167 cancellation points
607-610 cambridge cap
607-609 capability lists
sense with multiple
constant angular velocity
collision detection central
detection central processing
central processing unit
cpu certificate authorities
836-837 character-stream devices
common internet file
internet file system
792-794 cipher-block chaining
292-294 claim edge
dtrace command-line interface
447-448 client-side caching
page-replacement algorithm clones
c-look scheduling algorithm
closed-source operating systems
constant linear velocity
object model combined
model combined scheme
combined scheme index
scheme index block
52-53 commit protocol
i11 distributed operating
interprocess communication systems
communication systems programs
communication system calls
472-473 compiler-based enforcement
782-784 in windows
884-885 compression ratio
678-679 computation speedup
34-37 client-server computing
35-36 peer-to-peer computing
34-35 web-based computing
application programs computer
programs computer system
12-13 distributed systems
30-31 file-system management
25-26 i structure
11-13 memory management
24-25 operating system
operating system viewed
7-9 process management
29-30 special-purpose systems
32-34 handheld systems
33-34 multimedia systems
real-tim.e embedded systems
9-11 storage management
27-29 i systems
736-740 with locking
736-739 with timestamping
739-740 concurrency-control algorithms
conflict resolution module
811-812 connectionless messages
conservative timestamp-ordering scheme
713-714 consistency checker
486-487 consistency semantics
689-690 contention scope
582-583 contiguous disk
disk space allocation
471-473 contiguous memory
367-369 copy protection
315-317 cpu-bound processes
184-185 cpu schedule1
short-term scheduler cpu
scheduler cpu scheduling
multilevel feedback-queue scheduling
198-199 multilevel queue
196-197 priority scheduling
192-193 round-robin scheduling
194-196 shortest-job-first scheduling
213-217 deterministic modeling
213-215 and implementation
786-787 multiprocessor scheduling
202-203 preemptive scheduling
185-186 in real-time
768-774 earliest-deadline-first schedufu1g
772-774 rate-monotonic scheduling
769-771 short-term schedule1
schedule1 ~ role
110-115 critical sections
229-230 and semaphores
235-238 priority inversion
234-235 and synchronization
231-234 cross-link trust
638-639 and encryption
multiple access ctss
access ctss operating
ctss operating system
914-915 current directory
184-185 cycle stealing
677-678 data-out register
294-300 with banker
296-297 with safe-state
742-747 algorithm usage
303-304 several instances
301-303 single instance
290-291 with mutex
285-286 necessary conditions
290-294 and circular-wait
292-294 and hold-and-wait
291-292 and mutual-exclusion
304-306 by process
304-305 by resource
305-306 system model
283-285 system resource-allocation
system resource-allocation graphs
graphs for describing
287-289 deadlock-detection coordinator
84-85 using dtrace
85-88 dedicated devices
default signal handlers
854-855 deferred thread
deferred thread cancellation
361-367 basic mechanism
404-405 and page
400-401 and performance
365-367 and prepagil
399-400 and program
364-365 and tlb
401-402 demand-zero memory
213-215 development kernels
directories device drivers
device-management system calls
107-108 device reservation
file system digital
system digital certificates
645-646 digital rights
digital rights management
248-249 direct access
431-432 direct blocks
440-443 general graph
436-437 tree-sh uctured
437-438 directory objects
mass-storage structure allocation
allocation of space
477-479 bad blocks
516-517 free-space management
509-510 performance improvement
534-535 scheduling algorithms
883-884 disk scheduling
787-789 disk striping
733-736 and concurrency
736-740 and deadlocks
742-747 prevention avoidance
747-750 and event
727-730 and mutual
730-732 reaching algorithncs
707-710 remote file
710-715 basic scheme
711-712 distributed file
caching vs remote
714-715 and consistency
stateful vs stateless
distributed naming services
distributed lock manager
information systems distributed
systems distributed operating
677-679 distributed-processing mechanisms
888-889 distributed systems
677-679 network operating
link libraries dlm
memory access dma
access dma controller
direct-memory-access controller dmca
891-892 domain-name system
denial-of-service attacks double
attacks double buffering
793-794 double caching
double indirect blocks
dynamic random-access memory
580-581 driver registration
driver registration module
85-88 dtrace command-line
320-321 dynamic priority
dynamic storage-allocation problem
enabling control blocks
error-correcting code edf
code edf scheduling
earliest-deadline-first scheduling effective
scheduling effective access
539-540 effective memory-access
effective memory-access lime
482-483 eide buses
747-750 electronic disk
scan scheduling algorithm
scheduling algorithm embedded
algorithm embedded systems
651-652 encrypted viruses
643-645 key distribution
884-885 enhanced integrated
enhanced integrated drive
integrated drive electronics
850-851 environment vector
programmable read-only mem01y
525-526 error detection
765-766 event objects
exclusive lock mode
165-166 executable files
file system extended
system extended file
writing of block
533-534 failure analysis
734-736 failure modes
449-450 false negatives
fast i mechanism
475-476 fault tolerance
881-884 fault-tolerant systems
first-served scheduling algorithm
scheduling algorithm feature
algorithm feature migration
896-897 fiber channel
373-375 50-percent rule
directories accessing information
430-433 direct access
431-432 sequential access
429-430 locking open
451-456 via file
486-490 storage structure
434-435 file access
451-456 file-allocation table
475-476 file-control block
427-428 file handle
file-management system calls
716-718 file session
446-451 and consistency
450-451 with multiple
446-447 with networks
448-450 and client-server
448-449 and failure
449-450 file systems
file systems extended
467-468 virh1al systems
828-834 log-based transaction-oriented
496-498 file system
file system hierarchy
system hierarchy standard
hierarchy standard document
676-677 file transfer
676-677 file viruses
869-870 fine-grained multithreading
661-662 firewall chains
511-512 first-fit strategy
506-507 flow control
forward-mapped page tables
382-385 equal allocation
global vs local
384-385 proportional allocation
383-384 frame-allocation algorithm
628-629 free-behind technique
485-486 free objects
479-482 bit vectm
480-481 linked list
481-482 front-end processors
transfer protocol full
protocol full backup
distributed deadlock-detection algorithm
745-747 fuse file-system
gnu c compiler
general graph directories
38-39 gnu portable
gnu portable threads
52-54 grappling hook
480-481 group policies
user interfaces hal
hardware-abstraction layer handheld
layer handheld computers
hands-on computer systems
interactive computer systems
computer systems happened-before
systems happened-before relation
728-729 hard affinity
120-121 hard errors
556-565 direct memory
231-234 for virtualization
470-471 hash value
337-340 hierarchical storage
873-874 hold-and-wait condition
326-327 holographic storage
hot spare disks
intrusion-detection systems ike
systems ike protocol
information life-cycle management
immutable shared files
69-70 of real-time
764-768 and minimizing
765-768 and preemptive
764-765 of transparent
transparent naming techniques
709-710 of virtual
indexed disk space
476-477 index root
879-880 indirect blocks
information-maintenance system calls
i input queue
315-316 instruction-execution unit
windows xp networking
404-405 intermachine interface
646-647 interprocess communication
116-123 in client-server
128-140 remote procedure
128-130 in linux
124-126 in message-passing
119-120 posix shared-memory
123-124 in shared-memory
818-819 interrupt chaining
interrupt-driven data transfe1
interrupt-driven operating systems
20-23 interrupt-handler routine
766-767 interrupt priority
interrupt priority levels
656-658 intrusion-detection systems
656-658 intrusion-prevention systems
50-51 i ports
571-578 procedures supervised
577-578 i system
555-556 application interface
576-577 error handling
834-837 block devices
835-836 character devices
836-837 streams mechanism
580-582 and system
transformation of requests
internet protocol ipc
interprocess communication ipsec
692-693 iso reference
iso reference model
425--426 language-based protection
164-165 java virtual
102-103 job objects
866-867 job pool
832-833 journaling file
log-based transaction-oriented file
transaction-oriented file systems
file systems just-in-time
574-575 task synchronization
kernel memory allocation
396-399 kernel mode
809-812 conflict resolution
811-812 driver registration
809-810 kernel threads
645-646 key ring
610-615 compiler-based enforcement
local-area networks latency
71-73 lazy swapper
logical cluster numbers
lightweight directory-access protocol
directory-access protocol ldt
local descriptor table
lfu page-replacement algorithm
linked disk space
473-476 linked lists
linked scheme index
dynamic vs static
801-843 adding system
adding system call
call to linux
95-97 design principles
805-808 file systems
804-805 first kernel
805-806 system description
837-838 i system
836-837 kernel modules
809-812 memory management
826-827 physical memory
820-823 virtual memory
823-826 network structure
838-840 on pentium
348-349 process management
814-815 process representation
815-820 kernel synchronization
815-817 symmetric multiprocessing
211-213 security model
840-843 access control
173-174 linux distributions
802-804 limlx system
320-321 in linux
826-828 load sharing
679-681 local descriptor
868-869 local replacement
priority replacement algorithm
location-independent file identifiers
736-739 lock-key scheme
487-488 log files
260-261 logging area
319-320 logical blocks
virtual memory logical
memory logical records
782-783 lossy compression
782-783 low-level formatted
low-level formatted disks
procedure calls lru-approximation
calls lru-approximation page
medium access control
919-920 macintosh operating
918-919 macro viruses
535-536 magneto-optic disks
9-10 and address
318-319 contiguous allocation
324-325 and fragmentation
321-322 and dynamic
320-321 and hardware
316-318 intel pentium
345-348 and logical
paging for nwnagement
328-341 basic method
332-334 hashed page
337-340 intel pentium
346-348 inverted page
335-336 and shared
segmentation for management
342-345 basic method
344-345 intel pentium
345-348 and swapping
322-324 majority protocol
mandatory file-locking mechanisms
many-to-many multithreading model
158-159 many-to-one multithreading
many-to-one multithreading model
26-27 mass-storage structure
505-508 disk attachment
509-510 storage-area network
519-520 boot block
formatting of disks
516-517 disk scheduling
512-513 disk structure
505-507 magnetic tapes
522-532 performance improvement
531-532 raid levels
524-529 reliability improvement
522-524 stable-storage implementation
533-534 swap-space management
534-543 future tedmology
536-537 magnetic tapes
535-536 and operating
536-538 performance issues
539-543 removable disks
534-535 master book
master book record
master file directory
68-69 media players
main memory over-allocation
unified virtual memory
virtual memory memory-address
memory memory-address register
325-327 memory management
24-25 in linux
826-828 physical memory
823-826 in windows
862-863 memory-mapped files
390-396 basic mechanism
395-396 in linux
827-828 in win32
393-395 memory-mapping files
memory-style error-correcting organization
525-526 memory transactions
micro-electronic mechanical systems
distributed operating systencs
148-152 message-passing model
119-120 message queue
mfu page-replacement algorithm
73-75 microsoft interface
memory-management unit mobility
244-252 dining-philosophers solution
resumption of processes
245-247 monitor calls
system calls monoculture
467-468 mount points
492-493 mount table
204-205 multicore programming
156-157 multics operating
feedback-queue scheduling algorithm
198-199 multilevel index
779-780 operating system
operating system issues
779-780 multimedia data
780-781 multimedia systems
782-784 cpu scheduling
786-787 disk scheduling
784-786 network management
multiple universal-naming-convention provider
819-820 multiprocessor scheduling
208-211 and load
203-204 and ntulticore
204-205 and processor
202-203 and virtualization
205-206 multiprocessor systems
tightly coupled systems
168-170 and scheduler
170-171 and signal
167-168 and thread-specific
285-286 mutual exclusion
730-732 centralized approach
730-732 token-passing approach
857-858 named pipes
network device interface
device interface specification
netbiosextended user interface
690-694 communication structure
684-690 and connection
688-689 and contention
685-686 and packet
699-701 in linux
679-680 in windows
886-892 active directory
509-510 network basic
netbios network computers
490-496 mount protocol
492-493 nfs protocol
493-494 path-name translation
494-495 remote operations
network information service
789-792 network operating
675-677 network virtual
network virtual memory
systems nfs protocol
memory access nvram
602-603 in cache
hardware vs software
857-860 object files
linking and embedding
compaction of space
laptop per child
one-to-one multithreading model
37-40 open virtual
5-6 design goals
904-911 dedicated computer
909-911 shared computer
906-909 feature migration
21-23 and time1
32-33 as resource
70-75 layered approach
74-76 simple structure
system s view
52-55 optimal page
event ordering orphan
ordering orphan detection
detection and elimination
out-of-band key delivery
336-337 page allocator
380-381 page cache
390-391 page-fault rate
allocation and application
370-373 counting-based page
378-380 lru page
376-378 optimal page
374-376 and page-buffering
380-381 page replacement
400-401 page slots
hardware for storing
page-table base register
page-table length register
329-332 hardware support
340-342 in linux
825-826 and memory
pluggable authentication modules
multiprocessor systems para-virtualization
partially connected networks
partition boot sector
439-440 path-name translation
control blocks pci
blocks pci bus
199-200 pc systems
digital assistants pdes
582-585 with tertiary-storage
539-541 of windows
persistence of vision
page-fault-frequency phase-change disks
319-320 physical formatting
820-823 physical security
plug-and-play and managers
managers point-to-point tunneling
168-170 pop-up browser
pop-up browser windows
123-124 message passing
148-152 in windows
185-186 premaster secret
399-400 presentation layer
592-593 priority-based scheduling
764-765 priority-inheritance protocol
192-193 private keys
kernel mode probes
interprocess communication components
813-814 and context
101-102 threads performed
104-105 in windows
199-200 process control
task control blocks
103-104 process-control system
process-control system calls
60-64 process file
process file systems
833-834 process identifier
110-111 process identity
812-813 process management
23-24 in linux
814-815 process manager
866-867 process migration
202-203 processor sets
815-817 thread scheduling
225-227 and atomic
261-262 concurrent transactions
262-267 log-based recovery
260-261 system model
257-260 bounded-buffer problem
227-229 hardware solution
229-230 dining-philosophers problem
245-247 readers-writers problem
234-239 process termination
304-305 production kernels
application programs program
programs program counters
programmable interval timer
625-633 logic bombs
stack or buffer
buffer overflow attacks
627-630 trap doors
630-633 progressive download
451-456 access mah
602-605 capability-based systems
607-609 in computer
595-596 error handling
575-576 language-based systems
613-615 as operating
51-52 in paged
static vs dynamic
658-660 protection domain
203-204 pure code
524-529 performance improvement
531-532 reliability improvement
769-771 raw disk
913-914 reaching algorithms
750-752 read-ahead technique
241-242 readers-writers problem
241-242 reading files
read only devices
ready thread state
32-33 real-time range
790-792 real-time systems
759-760 address translation
760-762 cpu scheduling
features not needed
774-776 real-time transport
real-time transport protocol
489-490 and consistency
486-487 from deadlock
305-306 from failure
raid redundant arrays
raid reed-solomon codes
873-874 relative block
relative path names
439-440 relative speed
674-675 in multimedia
711-712 and cache-update
713-714 remote file
676-677 remote login
888-889 remote-service mechanism
removable storage media
537-538 application interface
534-535 and file
resource-allocation graph algorithm
296-297 resource allocato1
allocato1 ~ operating
429-430 resource manager
305-306 resource-request algorithm
187-188 restart area
retrofitted protection mechanisms
606-607 rich text
rich text format
749-750 ring structure
654-656 roaming profiles
read-only memory root
memory root partitions
partially cmmected networks
683-684 routing protocols
888-889 rr scheduling
round-robin scheduling algorithm
scheduling algorithm rtf
running thread state
298-299 safety-critical systems
storage-area networks sata
networks sata buses
cpu scheduling disk
scheduling disk scheduling
multiprocessor scheduling nonpreemptive
764-765 proportional share
199-201 in windows
895-897 scheduling rules
small computer-systems interface
378-379 second extended
830-832 section objects
secure single sign-on
access ; program
threats ; protection
protection ; user
user authentication classifications
662-664 in computer
29-30 and firewalling
654-661 and accounting
660-661 and auditing
660-661 and intrusion
656-658 and logging
660-661 and security
658-660 and vulnerability
623-624 in linux
638-649 and encryption
647-649 via user
security access tokens
664-665 secu.rity descriptor
345-348 segment base
implementation of monitors
238-239 and starvation
262-264 serial schedule
49-52 session hijacking
shared lock mode
189-192 shortest-remaining-time-first scheduling
512-513 short-term scheduler
167-168 signaled state
656-657 signature-based detection
656-657 simple operating
70-71 simple subject
single indirect blocks
436-437 single-processor systems
shortest-job-first scheduling algorithm
scheduling algorithm slab
algorithm slab allocation
821-822 sleeping-barber problem
sec symmetric multiprocessing
symmetric multiprocessing snapshots
128-130 socket interface
system-on-chip strategy soft
strategy soft affinity
206-208 swap-space management
253-255 virtual memory
406-407 solid-state disks
special-purpose computer systems
spoofed client identification
reference monitor ssds
solid-state disks ssl
647-649 sstf scheduling
sstf scheduling algorithm
sec shortest-seek-time scheduling
shortest-seek-time scheduling algorithm
scheduling algorithm stable
algorithm stable storage
628-629 stack inspection
standby thread state
indefinite blocking state
mass-storage structure definitions
definitions and notations
26-27 stored program
stored program computers
904-905 stream ciphers
641-642 stream head
780-781 stream modules
580-581 streams mechanism
kernel mode suspended
mode suspended state
520-522 switch architecture
641-642 symmetric mode
process synchronization synchronous
synchronization synchronous devices
synchronous message passing
sec system generation
system generation system
generation system boot
89-90 system calls
55-58 and api
56-57 for communication
65-66 for device
55-56 for information
60-64 system-call firewalls
boot disk system
disk system files
88-89 system hive
kernel mode system-on-chip
66-67 systems programs
system resource-allocation graph
287-289 system restore
470-471 m.aster file
364,862 per-process open-file
535-536 target thread
control blocks tcb
trusted computer base
sec transmission control
protocol tcp sockets
transport driver interface
terminated thread state
534-543 future technology
535-536 tertiary storage
page-fault-frequency sh ategy
390-391 and working-set
814-815 and multicore
168-170 and process
894-897 thread libraries
159-160 java tlueads
160-161 win32 threads
162-163 thread pool
program threats throughput
569-570 timer objects
look-aside buffer tlb
buffer tlb miss
top half interrupt
atomic transactions defined
832-833 in log-structured
487-488 transactional memory
258-259 transarc dfs
transition thread state
863-864 transmission control
438-440 triple des
triple indirect blocks
658-659 trojan horses
625-626 trusted computer
891-892 tunneling viruses
437-438 two-phase commit
733-734 two-phase locking
user interface uma
uniform naming convention
universal serial buses
450--451 domain switching
595-596 feature migration
buses used objects
446-447 user accounts
649-654 with biometrics
653-654 with passwords
649-653 user datagram
user-defined signal handlers
50-55 user mobility
826-827 user rights
virtual address control
address control block
control block vads
virtual address descriptors
virtual dos machine
dos machine vector
machine vector programs
virtual memory fork
sec virtual file
file system victim
system victim frames
824-825 virtual dos
875-876 virtual file
205-206 virtual machines
76-84 basic idea
81-82 virtual memory
357-360 and copy-on-write
367-369 demand paging
paging for conserving
84,7-849 interprocess communication
892-899 interprocess communication
897-898 kernel object
kernel object access
898-899 process management
894-897 sharing objects
255-256 system components
executive hardware-abstraction layer
852-856 tlu eads
171-173 virtual memory
870-872 i manager
869-870 local procedure
868-869 object manager
872-873 process managet
873-874 security reference
680-681 wirte-on-close policy
634-637 worm disks
read-many-times disks worm
741-742 write-ahead logging
260-261 write-back caching
write only devices
362-364 with inverted
365-367 and prepaging
402-403 pure demand
401-402 direct virtual
396-399 in linux
823-826 and memory
395-396 in win32
replacement for conserving
369-381 and application
373-375 lru-approximation page
406-407 and tlu
386-387 page-fault-frequency strategy
390-391 worki1cg-set model
405-406 virtual memory
860-866 virtual memory
virtual private networks
658-660 virus droppe1
sec virtual memory
memory manager vmware
81-82 vmware workstation
volume control block
881-884 volume set
881-882 volume shadow
private networks vulnerability
networks vulnerability scans
774-776 wafl file
496-498 wait-die scheme
741-742 waiting state
waiting thread state
wide-area networks web-based
networks web-based computing
web distributed authoring
681-683 wifi networks
wireless networks win32
networks win32 api
847-900 application compatibility
849-850 design principles
849-851 desktop versions
874-878 16-bit windows
850-851 file systems
878-885 change journal
884-885 mount points
ntfs b1 tree
879-880 ntfs internal
878-879 ntfs metadata
881-884 volume shadow
nicolette avi
avi silberschatz
maddie peter
peter baer
baer galvin
jay greg
greg gagne
gagne abraham
abraham silberschatz
weinberg professor
computer science
yale university
joining yale
vice president
information sciences
sciences research
research center
bell laboratories
chaired professorship
computer sciences
austin professor
professor silberschatz
acm fellow
ieee fellow
ieee taylor
booth education
education award
acm karl
outstanding educator
educator award
acm sigmod
sigmod contribution
contribution award
outstanding level
technical excellence
laboratories president
projects-the qtm
qtm project
datablitz project
netlnventory project
numerous acm
ieee publications
professional conferences
textbook database
database system
system concepts
op-ed articles
york times
boston globe
hartford courant
chief technologist
corporate technologies
computer facility
facility reseller
systems manager
brown university
science department
sun columnist
written articles
written columns
sun world
sysadmin magazines
taught tutorials
system administration
administration worldwide
worldwide greg
westminster college
salt lake
lake city
teaching operating
operating systems
teaches computer
computer networks
distributed systems
software engineering
science educators
industry professionals
professionals operating
essential part
computer system
computer-science education
rapid change
sophisticated planning
planning tools
multinational firms
fundamental concepts
concepts remain
senior undergraduate
undergraduate level
first-year graduate
graduate level
clear description
underlie operating
basic data
data struchues
computer organization
high-level language
hardware topics
topics required
code examples
languages concepts
intuitive descriptions
important theoretical
theoretical results
formal proofs
bibliographical notes
research papers
algorithms covered
conunercial operating
general setting
operating system
large number
im1.ovative operating
including sun
sun microsystems
microsoft windows
windows vista
apple mac
implying windows
feature exists
specific release
explicitly vii
vii viii
text reflects
teaching courses
systems consideration
feedback provided
comments submitted
earlier editions
text corresponds
computing curricula
joint task
task force
ieee computing
computing society
computing machinery
supporting web
web site
sample syllabi
advanced courses
general rule
encourage readers
on-line support
find sample
sample exercises
programming problems
grade problems
operating-system simulators
hands-on lab
lab activities
activities references
major parts
overview chapters
chapters discuss
common features
computer-system operator
individual readers
lower-level classes
internal algorithms
algorithms process
process management
process coordination
coordination chapters
process concept
modern operating
system consists
executing processes
operating-system processes
execute system
system code
user processes
execute user
user code
chapters cover
cover n1.ethods
process scheduling
interprocess communication
process synchronization
deadlock handling
issues related
multicore systems
systems memory
memory management
management chapters
main memory
algorithm depends
situation storage
storage management
file system
mass storage
modern computer
on-line storage
classic internal
practical understanding
-their properties
includes matters
matters related
tertiary storage
computer vary
wide range
discuss system
system design
internal system
system structures
slowest major
major components
performance bottleneck
examine performance
performance issues
devices protection
security chapters
computer systems
gained proper
proper authorization
system protection
resources defined
enforcement security
security protects
information stored
physical resources
1.mauthorized access
malicious destruction
accidental introduction
inconsistency distributed
systems chapters
share memory
distributed system
improve computation
computation speed
data availability
distributed file
file-service system
storage devices
deadlock problems
centralized system
system special-purpose
special-purpose systems
specific purposes
real-time systems
multimedia systems
specific requirements
general-purpose systems
text real-time
computed results
deadline period
period multimedia
systems require
quality-of-service guarantees
guarantees ensuring
multimedia data
case studies
studies chapters
concepts described
earlier chapters
real operating
systems include
include linux
chose linux
toy operating
computer-science departments
chose windows
unix chapter
influential operating
real-world operating
fundamental operating-system
operating-system concepts
microsoft family
including windows
including solaris
significant amount
linux operating
system reflecting
recent version
kernel -version
programs written
programming environments
windows systems
primary programming
programming environment
win32 api
application programming
programming interface
comprehensive set
managing processes
peripheral devices
programs illustrating
rum1.ing windows
portable operating
system inte1jace
standards implemented
unix-based operating
posix programs
linux systems
posix-compliant systems
posix core
core standard
real-time extensions
programn1.ing examples
examples written
posix base
base api
real-time programming
debian linux
compilers java
java java
programming language
rich api
built-in language
language support
thread creation
management java
programs run
system supporting
virtual machine
networking concepts
java programs
programs tested
popular models
java environment
programming examples
expect readers
java languages
programs provided
thread creation-we
creation-we illustrate
specific concept
shared memory
posix api
socket programming
java api
eighth edition
previous editions
changing fields
rewritten material
older material
removing material
substantive revisions
added coverage
open-source operating
practice exercises
included solutions
provide demonstrations
operating-system operation
include multicore
multicore cpus
clustered computers
systems chapter
updated coverage
virtual machines
grub boot
boot loader
operating-system debugging
debugging chapter
communication chapter
multithreaded programming
adds coverage
machine scheduling
multicore architectures
architectures chapter
mutual exclusion
exclusion locks
priority inversion
transactional memory
memory chapter
memory-management strategies
includes discussion
numa xii
xii chapter
virtual-memory management
include solaris
memory managernent
managernent chapter
current technologies
capacities chapter
implementing file
file systems
full description
directories chapter
secondary-storage structure
zfs pools
pools chapter
pcix pci
pci express
hypertransport chapter
distributed operating
wireless networks
networks chapter
limix system
latest version
limix kernel
kernel chapter
increases coverage
early computers
original mac
concepts presented
win32 apis
emphasize processes
programming projects
standard programming
programming exercises
projects include
system call
linux kernel
unix message
message queues
multithreaded applications
producer-consumer problem
simulators designed
san antonio
disk-head schedulil1.g
process creation
address translation
computer systern
simulator includes
system behaves
algorithmic problems
tutorials developed
a&m university
university xiii
teaching supplencents
java source
source code
up-to-date errata
case study
study appendices
distributed communication
communication appendix
additional practice
additional problems
problems students
provided solutions
restricted supplements
solution guide
orne wiley
sons sales
sales representative
representative note
mailman system
mailman.cs.yale.edul mailmanllistinfo
mailman mailing-list
mailing-list system
subscription options
including digest
send messages
send e-mail
mailing list
inappropriate mail
mail students
operating systems-a
obscure bugs
textual errors
suggest improvements
contribute exercises
send correspondence
james peterson
editions include
hamid arabnia
rida bazzi
randy bentson
xiv joseph
joseph boykin
jeff brumfield
gael buckley
roy campbell
john carpenter
gil carrick
bart childs
ajoy kum.ar
kum.ar datta
joe deck
thomas doeppner
caleb drake
racsit eskicioglu
hans flack
robert fowler
scott graham
richard guy
max hailperin
wayne hathaway
don heller
bruce hillyer
mark holliday
dean hougen
michael huangs
ahmed kamet
kamet marty
marty kewstet
kewstet richard
richard kieburtz
carol kroll
westet thomas
thomas leblanc
john leggett
jerrold leichter
gary lippman
carolyn miller
michael molloy
euripides montagne
yoichi muraoka
banu ozden
boris putanec
charles qualline
john quarterman
mike reiter
gustavo rodriguez-rivera
yannis smaragdakis
john stankovic
adam stauffer
john sterling
hal stern
louis stevens
pete thomas
steve vinoski
tommy wagner
jolm werth
yang xiang
xiang parts
unpublished manuscript
stephen tweedie
tweedie chapter
dave probert
cliff martin
silberschatz appendix
martin cliff
unix appendix
cover freebsd
accompanying solutions
arvind krishnamurthy
krishnamurthy mike
mike shapiro
bryan cantrill
jim mauro
mauro answered
solarisrelated questions
questions bryan
microsystems helped
zfs coverage
coverage steve
steve robbins
antonio designed
wileyplus reece
reece newman
text josh
josh dees
rob reynolds
reynolds contributed
contributed coverage
john trona
saint michael
vermont marilyn
marilyn turnamian
turnamian helped
generate figures
presentation slides
slides mark
mark wogahn
latex macros
works properly
associate publisher
dan sayre
provided expert
expert guidance
carolyn weisman
project smoothly
senior production
production editor
editor ken
ken santor
production details
details lauren
lauren sapira
cindy jolmson
material ready
peavler copy-edited
freelance proofreader
freelance indexer
overview chapter
computer-system organization
computer-system architecture
operating-system operations
operating-system services
user operating-system
operating-system interface
system calls
system programs
operating-system design
operating-system structure
computing environments
operating-system generation
system boot
management chapter
ipc systems
clientserver systems
xvi chapter
multithreading models
thread libraries
threading issues
basic concepts
scheduling criteria
scheduling algorithms
thread scheduling
multiple-processor scheduling
operating-system examples
system examples
algorithm evaluation
coordination chapter
critical-section problem
synchronization hardware
classic problems
system model
deadlock characterization
handling deadlocks
deadlock prevention
deadlock avoidance
synchronization examples
atomic transactions
deadlock detection
contiguous memory
memory allocation
page table
intel pentium
xvii chapter
demand paging
page replacement
memory-mapped files
allocating kernel
kernel memory
file concept
access methods
disk structure
file-system mounting
file sharing
file-system structure
file-system implementation
directory implementation
allocation methods
free-space management
wafl file
mass-storage structure
disk attachment
disk scheduling
swap-space management
hardware operations
raid structure
stable-storage implementation
tertiary-storage struchue
xviii part
security chapter
access matrix
access control
system security
security problem
program threats
network threats
security tool
user authentication
implementing security
security defenses
protect systems
access rights
capability-based systems
language-based protection
computer-security classifications
networkbased operating
network structure
network topology
communication structure
communication protocols
design issues
remote file
file access
stateful versus
versus stateless
stateless service
file replication
distributed synchronization
event ordering
concurrency control
election algorithms
reaching agreement
special purpose
purpose systems
system characteristics
real-time kernels
real-time operating
real-time cpu
cpu scheduling
multimedia kernels
network management
studies chapter
linux system
linux history
design principles
kernel modules
system components
environmental subsystems
programmer interface
feature migration
early systems
macintosh operating
bsd unix
unix history
user interface
mach system
system b.l
b.l history
b.s interprocess
interprocess conununication
enviromnental subsystems
alo summary
system acts
computer hardware
execute programs
efficient manner
correct operation
prevent user
user programs
proper operation
major task
design begins
goals form
created piece
delineated portion
defined inputs
application programs
computer user
amazing aspect
tasks mainframe
mainframe operating
optimize utilization
personal computer
systems support
support complex
complex games
business applications
handheld computers
system operation
system structure
basic functions
system startup
basic computer
computer architecture
functional operating
well-delineated portion
general overview
grand tour
basic organization
compiler assembler
assembler text
text editor
editor operating
system database
system figure
abstract view
basic computing
computing resources
web browsers-define
solve users
computing problems
system controls
operating systemfs
systemfs role
explore operating
user view
computer varies
computer users
users sit
system unit
attention paid
software resources
shared performance
single-user experience
multiple users
user sits
sance computer
users share
share resources
exchange information
llclc cases
maximize resource
utilizationto assure
individual user
user takes
fair share
otber cases
dedicated resources
print servers
individual usability
resource utilization
standalone units
individual users
wireless modems
interface limitations
remote operations
battery life
embedded computers
home devices
numeric keypads
turn indicator
indicator lights
show status
user intervention
system view
memory space
file-storage space
resources facing
conflicting requests
specific programs
resource allocation
users access
system emphasizes
control program
prevent errors
defining operating
adequate definition
system operating
systems exist
usable computing
computing system
fundamental goal
solving user
storage definitions
basic unit
computer storage
smallest convenient
convenient chunk
common term
native storage
storage unit
bytes computer
computer manufacturers
bytes problems
problems easier
bare hardware
programs require
common operations
common functions
allocating resources
accepted definition
simple viewpoint
vendor ships
features included
full-screen editor
require gigabytes
graphical windowing
windowing systems
common definition
program running
increasingly important
united states
states deparhnent
justice filed
filed suit
essence claiming
microsoft included
prevented application
application vendors
web browser
integral part
found guilty
operating-system monopoly
limit competition
systems operate
general knowledge
study ofoperating
ofoperating systems
neverbeenarnore interestirighnwtostud
interestirighnwtostud yoperating
yoperating systems
.operating systems
fonnat .this
.this iistindud
is,and part
ilityqf source.code.q,llowsus.tostudyoperq,til
.gsy tems
tems frorrt
rating system
system c.annow
1ter ftmctionmakesitpos
runnmnyoperqtingsystems.ontop.of onecoresystem
method,students call
call tryolit
tryolit hundreds
hundreds ofoperatingsystems.withintheir
ofoperatingsystems.withintheir existing
existing operatingsystems
lrced asvvell
etnd.storcrge .resoj.trces
operafirtg system
...r ....d
decsystemc20 simulator
simulator running
alld comp
rnel art
art interested
interested stltdent
search theint
origillal papers
operating systemand
fogen-source operafirtg
move fromstu
internet connection,a
connection,a student
alleven create
justa fev.r
fev.r years
wmuchtimeand disk
disk space
computer-system operation
modern general-purpose
general-purpose computer
device controllers
controllers connected
common bus
device controller
specific type
disk drives
audio devices
video displays
memory cycles
orderly access
memory controller
synchronize access
start rum
rum ing-for
ing-for instance
initial program
mouse keyboard
keyboard printer
printer monitor
_rlo i-nneh
system program
read-only memory
erasable programmable
programmable read-only
general term
cpu registers
memory contents
bootstrap program
start executing
operatingsystem kernel
first process
software hardware
system bus
bus software
interrupt executing
special operation
immediately transfers
transfers execution
fixed location
starting address
service routine
interrupt service
routine executes
cpu resumes
interrupted computation
important part
computer design
interrupt mechanism
transfer control
straightforward method
generic routine
interrupt information
interrupt-specific handler
predefined number
interrupt routines
interrupt routine
intermediate routine
routine needed
low memory
locations hold
service routines
unique device
device number
interrupt request
cpu user
device process
process executing
interrupt processing
processing idle
transfer done
transfer request
request done
done figure
single process
process doing
doing output
interrupting device
device operating
dispatch interrupts
interrupt architecture
interrupted instruction
interrupt address
location indexed
recent architectures
architectures store
return address
system stack
processor state-for
state-for instance
modifying register
register values-it
current state
saved return
program counter
computation resumes
storage structure
load instructions
general-purpose computers
computers run
rewriteable memory
semiconductor technology
static programs
game cartridges
eeprom camwt
stalled programs
memory provide
address interaction
store instructions
specific memory
memory addresses
load instruction
instruction moves
internal register
store instruction
explicit loads
loads instructions
typical instruction-execution
instruction-execution cycle
first fetches
memory notice
memory unit
unit sees
instruction counter
literal addresses
memory address
addresses generated
running program
main ncemory
ncemory permanently
needed programs
data permanently
permanently main
volatile storage
storage device
systems provide
main requirement
secondary storage
large quantities
common secondary-storage
secondary-storage device
proper management
disk storage
central importance
larger sense
magnetic disks-is
storage systems
magnetic tapes
storage system
main differences
systems lie
wide variety
higher levels
generally increases
another-other properties
expensive memory
early storage
including paper
paper tape
core memories
magnetic tape
semiconductor memory
expensive battery
generator backup
backup systems
hierarchy shown
electronic disk
symmetric multiprocessing
multiprocessing architecture
architecture solaris
significant deterioration
carefully control
data reach
sitting idle
processors share
data structures
multiprocessor system
systems-including windows
linux -now
-now provide
provide support
asymmetric multiprocessing
special hardware
multiple processors
multiple slaves
system sunos
sunos version
hardware multiprocessing
multiprocessing adds
adds cpus
increase computing
computing power
integrated memory
adding cpus
memory access
access model
uniform memory
non-uniform memory
access uma
cpu takes
performance penalty
penalty operating
numa penalty
resource management_
recent trend
cpu design
in.clude multiple
multiple computing
single chip
multiprocessor chips
multiple chips
single cores
on-chip communication
between-chip communication
multiple cores
single-core chips
server systems
web servers
dual-core design
register set
local cache
shared cache
shared caches
architectural considerations
bus contention
standard processors
tendency puts
puts pressure
system designers-and
designers-and application
recent development
multiple processor
processor boards
networking boards
traditional multiprocessor
multiprocessor systems
blade-processor board
board boots
blade-server boards
servers consist
multiple independent
independent multiprocessor
clustered systems
multiple-cpu system
multiple cpus
computational work
work clustered
systems differ
individual systems-or
systems-or nodes-joined
term clustered
commercial packages
packages wrestle
clustered system
computers share
share storage
faster interconnect
infiniband clustering
provide service
cluster fail
high availability
cluster software
software runs
cluster nodes
monitored machine
machine fails
monitoring machine
failed machine
beowulf clusters
clusters beowulf
solving high-performance
high-performance computing
computing tasks
personal computers-that
simple local
local area
area network
beowulf duster
specific software
software package
open-source software
software libraries
con1puting nodes
beowulf cluster
beowulf computing
computing nodes
clusters require
source software
low-cost strategy
performance computing
computing cluster
clusters built
personal computers
cornputing nodes
expensive problems
scientific computing
computing clusterin.g
hot-standby host
host machine
active server
server fails
rmming applications
cluster consists
provide environments
greater computational
computational power
smp systems
separate components
individual computers
computing node
final solution
clusters include
parallel clusters
wide-area network
multiple hosts
shared storage
systems lack
lack support
simultaneous data
data access
special versions
special releases
oracle real
real application
application cluster
parallel cluster
machine runs
runs oracle
software tracks
tracks access
shared disk
full access
shared access
supply access
conflicting operations
operations occur
cluster technology
interconnect interconnect
interconnect computer
computer computer
computer figure
general structure
system cluster
changing rapidly
cluster products
products support
support dozens
clustered nodes
host fails
database cluster
increasing performance
reliability figure
basic information
important aspects
single program
ith_er thg
thg cpu
cpu ortbt
single users
multiple programs
programs running
running il.ul
il.ul increases
increases cpu
cpu utilization
utilization byorganizing
byorganizing jobs
atlng system
generat main
pool consists
processes residing
disk awaiting
awaiting allocation
setofjobs inmemg_ry_canbe
inmemg_ry_canbe asubt
system picks
multiprogramming system
non-multiprogrammed system
sit idle
multiprogrammed system
operatilcg system
first job
job finishes
finishes waiting
cpu back
life situations
papers typed
idle lawyers
lawyers tend
social value
keeping lawyers
lawyers busy
multiprogrammed systems
system resources
user interaction
system is_
caring syste
s,the cpl
switches occur
l.t1sil.mning. -ti1ne
-ti1ne shar
direct communication
input device
output device
te sho
time-shared operating
computer simultaneously
time-shared system
system switches
entire computer
system 11ses
11ses cpu
small portion
time-shared computer
computer eachuserhas
program loaded
process executes
short tirne
user keyboard
people speeds
complete input
typing speed
cpu sit
interactive input
input takes
takes place
multiprogramming require
system selects
job pool
running multiple
multiple jobscoi
ei1hy requires
including process
time-sharing system
reasonable response
common method
goal tec
completely inl1le1yl_cld
main advai1tage
virtual-memory scheme
enables users
run programs
uniform array
physical memory
arrangement frees
frees programmers
memory-storage limitations
time-sharing systems
system resides
disk management
protecting resources
orderly execution
provide mechanisms
job synchronization
happen events
generated interruptca
ler byan
byan error
division byzero
invalid memory
memory acc
specific request
user program
operating-system service
interrupt-driven nature
system defines
separate segments
system determine
infinite loop
subtle errors
erroneous program
designed operating
cute incorrectly
dual-mode operation
proper execution
operating-system code
userdefined code
provide hardware
hardware support
current mode
executed onbehalf
system aicd
computer systel.n1s
systel.n1s executing
user application
user mode
application requests
kernel mode
architectural enhancement
call figure
mode user
mode bit
hardware starts
starts user
user applications
interrupt occurs
hardware switches
system gains
gains control
passing control
dual mode
errant users-and
users-and errant
errant users
cc011lplishthis protection
ofthe machineine
trlijjt cal1_sej
l11 ins
ins trucrci
il1e hardware
spl iyileg
o11ly inkern
privileged instruction
examples include
controt timer
timer management
interrupt management
additional privileged
privileged instructions
life cycle
instruction execution
initial control
control resides
call _5ysiemcalls
_5ysiemcalls proyide
auser program
tasks re_
re_ erved
operating syst
1.lser .12l
functionality provided
underlying processor
request action
specific location
interrupt vector
generic trap
trap instruction
mips r2000
r2000 family
specific syscall
syscall instruction
asystep1 calljs
iltrol passes
systemcaflserv1ce routine
system the-kernel
the-kernel examines
interrupting instruction
additional information
information needed
memory locations
locations passed
kernel vedfies
legat executes
returns control
describe system
hardware-supported dual
program rum1ing
rum1ing awry
disastrous results
recent versions
intel cpu
contemporary operating
operating systemssuch
microsoft vista
-take advantage
dual-mode feature
greater protection
hardware protection
detects errors
violate modes
program fails
illegal instruction
access memory
hardware traps
trap transfers
transfers control
program error
error occurs
program abnormally
user-requested abnormal
abnormal termination
error message
memory dump
timer wer
r1,_ust ensure
ogram to_
kin e1ninfinite
e1ninfinite loop
call syste1n
syste1n seryices
retltrn control
perating system
we_can usea
usea _a_tirn
r_can beset
ified peri
fixed-rate clock
system sets
clock ticks
counter reaches
10-bit counter
1-millisecond clock
system ensures
tij11e_ _il1t
faiaf error
taygi-y_etll.ep_rograrn rnc
simple technique
counter initialized
timer interrupts
system terminates
time-shared user
word-processing program
system task
sending output
time-shared program
provide system
create subprocesses
execute concurrent
resources---including cpu
logical resources
process obtains
initialization data
desired information
process terminates
reusable resources
itselfis nota
nota process
active entity
eaded proc
_pr_ogra111 cou11
cpu executes
process completes
separate execution
execution sequences
multithreaded process
multiple program
program counters
jheseprocesses canp
execute concurrently
concurrently _lly.ij
scheduling processes
cpus creating
system processes
processes suspending
resuming processes
processes providing
providing mechanisms
synchronization providing
process communication
process-management techniques
system main
large array
address main
accessible data
data shared
central processor
processor reads
reads instructions
instruction-fetch cycle
writes data
data-fetch cycle
von neumann
neumann architecture
large storage
access directly
process data
mu.st first
absolute addresses
program executes
accesses program
program instructions
program terminates
memorymanagement schemes
schemes reflect
memory-management scheme
specific system
hardware design
algorithm requires
keeping track
memory allocating
deallocating memory
memory-management techniques
discussed il1
il1 chapters
system convenient
logical view
information storage
system abstracts
physical properties
logical storage
system maps
maps files
physical media
file-system management
management pile
pile management
visible components
system computers
store information
magnetic disk
optical disk
physical organization
disk drive
unique characteristics
properties include
include access
access speed
data-transfer rate
access method
related information
information defined
files represent
represent programs
object forms
data data
data files
binary files
text files
fixed fields
system implements
abstract concept
mass-storage media
file management
deleting files
files creating
deleting directories
organize files
files supporting
supporting primitives
manipulating files
directories mapping
mapping files
storage backing
storage media
file-management teclmiques
mass-storage management
principal on-line
storage medium
programs-including compilers
word processors
management storage
storage allocation
allocation disk
entire speed
disk subsystem
higher capacity
storage backups
disk data
seldom-used data
long-term archival
archival storage
magnetic drives
dvd drives
typical devices
optical platters
systern performance
tertiary-storage management
application progran1s
operating systerns
include mounting
unmounting rnedia
migrating data
storage techniques
important principle
systems information
faster storage
storage system-the
system-the cache-on
temporary basis
internal programmable
programmable registers
index registers
high-speed cache
register-replacement algorithms
instruction cache
instructions expected
similar reasons
high-speed data
data caches
memory hierarchy
hardware-only caches
limited size
important design
design problem
careful selection
cache size
replacement policy
increased performance
performance figure
compares storage
storage performance
large workstations
small servers
replacement algorithms
software-controlled caches
typical size
implementation custom
custom memory
off-chip cmos
cmos dram
disk technology
technology multiple
multiple ports
cmos cmossram
cmossram access
compiler hardware
hardware operating
system backed
cache main
memory disk
tape figure
fast cache
file-system data
storage hierarchy
highest level
electronic ram
ram disks
high-speed storage
file-system interface
magnetic disks
magneticdisk storage
removable disks
data loss
hard-disk failure
file data
tape jukeboxes
storage cost
controlling operating-system
operating-system software
software f_o
r-_s _is_
ahardvvare function
sy-s tern
tern intervention
data-from aisk
ri.g system
11ier2rrchical storage
increment operation
operation proceeds
first issuing
disk block
increment takes
computing environment
arrangement poses
multitasking environment
-forth-among var1ous
var1ous processes
extreme care
updated ___
multiprocessor environment
internal registers
f_a ij.t
simultaneouslyinseyeral caches
,ve-must1nake surethat
value ofa
cache figure
a11 operating
peculiarities ofspecific
ofspecific hardware
subsystem consists
memory-management component
general device-driver
device-driver interface
interface drivers
specific hardware
hardware devices
device driver
specific device
interrupt handlers
device drivers
subsystem interfaces
manages devices
transfers data
concurrent execution
multiple processes
mechanisms ensure
memory segments
memory-addressing hardware
hardware ensures
address space
timer ensures
gain control
relinquishing control
control device-control
device-control registers
protected protection
mechanism rni1st
rni1st provide
provide means
controls protection
improve reliability
detecting latent
latent errors
component subsystems
early detection
interface errors
prevent contamination
healthy subsystem
unprotected resource
incompetent user
protection-oriented system
unauthorized usage
terl _ca1lhave
_ca1lhave adequateprotection
ado_w inappr
authentication information
memory protection
internal attacks
attacks spread
huge range
include viruses
denial-ofservice attacks
legitimate users
identity theft
operatingsystem function
systems leave
additional software
alarming rise
security incidents
operating-system security
security features
features represent
fast-growing area
implementation security
security require
user names
vista parlance
numerical ids
user logs
authentication stage
stage determines
unix system
selected set
users belonging
group group
group functionality
system-wide list
group names
design decisions
group ids
s-l.iffici.e11t hov
extra permissions
fhatis resh
icted,for examp1e.operatmg
examp1e.operatmg systems
privilege escalation
setuid attribute
current user
process runs
extra privileges
system maintains
maintains access
shared resource
increases computation
systems generalize
generalize network
network access
network interface
make users
invoke network
network functions
simplest terms
communication path
systems distributed
systems depend
functionality networks
transport media
media tcp
common network
network protocol
operatingsystem support
protocols varies
support tcp
support proprietary
proprietary protocols
interface device-a
device-a network
network adapter
handle data
book networks
links buildings
global company
offices worldwide
continuing advent
technologies brings
link buildings
city bluetooth
wireless technology
essence creating
carry networks
equally varied
include copper
copper wires
fiber strands
wireless transmissions
microwave dishes
computing devices
cellular phones
infrared communication
rudimentary level
computers communicate
providing network
network connectivity
communication scheme
exchange messages
computer rmming
network operating
networked computers
autonomous envirorunent
systems comm
single operating
cover computer
limited computation
computation domains
real-time embedded
embedded systems
systems embedded
prevalent form
car engines
manufacturing robots
microwave ovens
specific tasks
limited features
managing hardware
automobile engines
robotic arms
vary considerably
standard operating
unix-with special-purpose
special-purpose applications
embedded operating
system providing
functionality desired
integrated circuits
systems continues
entire houses
central computer-either
embedded system-can
system-can control
control heating
alarm systems
coffee makers
makers web
web access
home owner
arrives home
home someday
grocery store
real-time system
control device
dedicated application
application sensors
sensors bring
bring data
adjust controls
sensor inputs
inputs systems
control scientific
scientific experiments
medical imaging
imaging systems
industrial control
control systems
display systems
realtime systems
automobile-engine fuel-injection
fuel-injection systems
home-appliance controllers
weapon systems
constraints processing
defined constraints
robot arm
system functions
correct result
constraints contrast
batch system
great detail
scheduling facility
facility needed
real-time functionality
real-time computing
real-time components
conventional data
word-processing documents
systems multimedia
data consist
video files
conventional files
data differ
multimedia describes
include audio
audio files
dvd movies
short video
video clips
movie previews
news stories
stories downloaded
internet multimedia
multimedia applications
live webcasts
world wide
wide web
sporting events
live webcams
observe customers
paris multimedia
multimedia application
separate audio
video tracks
smaller devices
including pdas
cellular telephones
stock trader
stock quotes
quotes delivered
data affects
handheld systems
personal digital
digital assistants
systems developers
applications face
one-half pound
handheld devices
small amounts
slow processors
small display
display screens
handheld depends
manage memory
memory efficiently
allocated memory
memory manager
virtual memory
write programs
memory techniques
program developers
limited physical
devices processors
devices run
faster processors
processors require
faster processor
handheld device
larger battery
slower processors
last issue
issue confronting
confronting program
program designers
physical space
space limits
limits input
input methods
small keyboards
handwriting recognition
small screen-based
screen-based keyboards
screens limit
limit output
output options
home computer
inches square
familiar tasks
reading e-mail
browsing web
web pages
smaller displays
small subset
web page
allowing remote
remote access
web browsing
browsing cellular
internet fall
wireless access
downloading data
infrared link
network com1ections
digital cameras
mp3 players
major operating-system
operating-system components
traditional computing
computing matures
lines separating
typical office
office environment
environment consisted
pcs connected
servers providing
providing file
print services
services remote
laptop computers
computers terminals
terminals attached
fewer remote
portability options
current trend
environments web
web technologies
computing companies
companies establish
provide web
web accessibility
internal servers
servers ccxepu1as
essentially terminals
web-based computing
computing handheld
con1pany information
information handheld
handheld pdas
web portal
web resources
single computer
slow modem
modem connection
network-connection speeds
great cost
giving home
home users
fast data
data connections
allowing home
home computers
run networks
include printers
client pcs
security breaches
firewalls cost
cost thousands
decade ago
previous century
interactive batch
batch systems
systems processed
processed jobs
predetermined input
interactive systems
systems waited
users shared
systems time-sharing
cycle processes
resources today
traditional time-sharing
scheduling technique
single user
provide services
windows created
client-server computing
system architecture
architecture terminals
terminals connected
centralized systems
user-interface functionality
systems act
satisfy requests
requests generated
structure depicted
compute servers
file servers
client-server system
read data
server executes
back results
server running
client requests
delete files
web server
delivers files
clients running
running web
web browsers
peer-to-peer computing
considered peers
ncay act
service peer-to-peer
peer-to-peer systems
systems offer
traditional client-server
client-server systems
peer-to-peer system
nodes distributed
providing services
requesting services
-other nodes
network determining
general ways
node joins
centralized lookup
lookup service
node desiring
specific service
communication takes
service provider
peer acting
desired service
service responds
peer making
discovery protocol
discover services
services provided
network peer-to-peer
peer-to-peer networks
widespread popularity
file-sharing services
enable peers
exchange files
napster system
first type
type described
centralized server
server maintains
files stored
peer nodes
napster network
actual exchanging
files takes
gnutella system
client broadcasts
broadcasts file
file requests
request respond
exchanging files
files remains
remains uncertain
laws governing
copyrighted material
peerto peer
peer technology
file exchange
wider variety
years ago
ago pcs
prevalent access
handheld pdas1
cell phones
providing access
access web
web computing
networking devices
access devices
faster network
improved networking
networking technology
technology optimized
optimized network
network implementation
distribute network
network connections
similar servers
servers operating
users require
vast number
open-source releases
source-code format
binary code
code linux
famous open
open source
source operating
opposite dosedapproach
dosedapproach starting
system doing
oppositethe source
recovered learning
learning operating
actual source
source code1
reading summaries
excellent learning
learning tool
text indudes
indudes projects
involve modifying
modifying operating
system source
describing algorithms
high level
important operating
system topics
provide pointers
open-source code
deeper study
closed-source code
open-source advocates
advocates argue
bugs tend
fixed faster
faster owing
code companies
earn revenue
programs tend
commercial companies
code revenue
support contracts
early days
modern computing
great deal
open-source format
original hackers
computer enthusiasts
tech model
model railroad
railroad club
club left
homebrew user
user groups
groups exchanged
exchanged code
company-specific user
digital equipment
equipment corporation
accepted contributions
source-code programs
interested ncembers
ncembers computer
software companies
authorized computers
paying customers
customers releasing
files compiled
issue involved
material operating
back movies
electronic books
published laws
u.s digital
digital millennium
millennium copyright
copyright act
reverse-engineer drm
drm code
circumvent copy
copy protection
limit software
richard stallman
gnu project
open-source unixcompatible
unixcompatible operating
gnu manifesto
free exchange
software source
fsf copylefts
encourage sharing
codifies copylefting
common license
free software
gpl requires
gpl license
project produced
unix-compatible tools
including compilers
linus torvalds
rudimentary unix-like
unix-like kernel
gnu compilers
invited contributions
contributions worldwide
internet meant
torvalds releasing
releasing updates
week allowed
so-called linux
spawned hundreds
custom builds
major distributions
distributions include
ubuntu distributions
installed applications
enterprise lim1x
large commercial
cd-an operating
pclinuxos supergamer
supergamer dvd
includes graphics
graphics drivers
compatible system
system resets
system access
linux source
code varies
linux ubuntu
popular linux
linux distribution
founder pays
steps outline
ubuntu kernel
kernel source
free vmware
vmware player
player tool
downloaded file
complicated history
unix releases
binary form
required bsd
open-source version
including freebsd
machine image
ubuntu linux
virtual-memory implementation
implementation code
freebsd kernel
core kernel
kernel component
opensource apple
mac release
open-source components
components posted
mac kernel
kernel revision
mac leopard
www.opensource.apple.coml darwinsource
tar balls
apsll xnu-1228
xnu-1228 tar.gz
tar.gz appl
commercial unix-based
unix sun
sun moved
solaris code
code base
close-sourced components
projects open-source
open-source projects
enable students
modify programs
fix bugs
explore mature
full-featured operating
user interfaces
historic projects
build knowledge
projects gnu
gnu ilinux
cross-pollination occurs
rapid improvements
operating-system projects
open sourcing
cornputer hardware
visible aspect
human user
executing programs
memory main
storage area
main mem.ory
nonvolatile storage
system uniprocessor
uniprocessor systems
single processor
common multiprocessor
multiprocessor design
specialized form
multiple computer
systems connected
systems employ
nmning concurrently
halt instructions
tin1.er prevents
prevents infinite
infinite loops
timer interrupt
basic building
building blocks
fundamental unit
system process
management includes
deleting processes
system manages
manages memory
freeing memory
space storage
storage space
representing files
managing space
mass-storage devices
devices operating
users protection
protection measures
resources made
security measures
attacks distributed
dispersed hosts
hosts connected
computer network
network services
client-server model
peer-to-peer n10del
multiple machines
perform computations
data residing
cluster members
members fails
fails lans
basic types
networks lans
enable processors
processors distributed
small geographical
geographical area
larger area
communicate lans
systems designed
embedded environments
consumer devices
robotics real-time
fixed-time constraints
fail multimedia
systems involve
special requirements
playing audio
synchronized audio
video streams
include web
communication software
integral features
software movement
created thousands
including operating
programs gnu
network computers
traditional personal
computers describe
usage scenarios
network configuration
dormitory floor
university campus
vvbat problems
timesharing system
single-user workstation
mode function
rudimentary form
time-sharing environment
system simultaneously
security problems
time-shared machine
dedicated machine
machine explain
enforcing memory
peer-to-peer models
privileged mode
secure operating
systems give
give arguments
mainframe computers
set value
clear memory
modify entries
device-status table
maintaining coherence
cached data
data manifests
processing environments
single-processor systems
machines belonging
main difficulty
real-time environment
direct memory
execution load
cpu interface
memory operations
dma controller
transferring data
functionalities listed
batch programming
cpus provide
multiple modes
essential properties
utilization shows
systems list
minicomputer systems
workstations connected
smp system
system sincilar
local caches
cluster consisting
nodes running
database describe
manage access
disk discuss
considerable technical
technical detail
detail abmrt
systern internals
components russinovich
solaris operating
system mac
systems includes
file-sharing systems
good coverage
cluster computing
recent advances
issues relating
operating-system support
van renesse
general textbooks
including stallings
describe cmnputer
cmnputer organization
multicore processors
processors hennessy
provide coverage
general blaauw
describe details
ibm stokes
illustrated introduction
architecture cache
cache memories
associative memory
extensive bibliography
subject discussions
magnetic-disk technology
optical disks
floppy disks
general discussions
mass-storage technology
general overviews
networks fortier
detailed discussion
networking hardware
software kozierok
discuss tcp
detail mullender
recent developments
systems issues
full discussion
software foundation
detailed instructions
howtof orge
vantage points
view focuses
operating-system designers
computer starts
specific services
common classes
programs hardware
hardware figure
system services
services task
task easier
easier figure
text commands
window system
pointing device
make selections
enter text
variations program
program execution
indicating error
specific devices
special functions
display screen
devices directly
file-system manipulation
write files
list file
file information
programs include
include permissions
permissions management
deny access
directories based
file ownership
personal choice
specific features
performance characteristics
communication ncay
ncay occur
systems tied
network communications
shared rnenwry
message passing
system error
error detection
errors errors
memory hardware
memory error
power failure
parity error
connection failure
arithmetic overflow
illegal memory
memory location
consistent computing
systems react
correct errors
errors debugging
debugging facilities
system efficiently
operating-system functions
functions exists
efficient operation
gain efficiency
computer resources
users resource
lultiple usersormultiple
usersormultiple jobs
jobs rmuung
d1herent -types
cpu cycles
file storage
special allocation
allocation code
general request
release code
cpu-scheduling routines
allocate printers
usb storage
storage drives
devices accounting
lovy rnl1c
kindsofcomputer resources
record keeping
accumulating usage
usage statistics
statistics usage
valuable tool
improve computing
computing services
services protection
networked computer
separate processes
processes execute
protection iiwolves
systerr1 resources
-controlled security
security starts
gain access
including modems
network adapters
invalid access
access attempts
weakest link
fundamental approaches
command-line interface
enter commands
graphical user
command interpreter
special program
multiple command
command interpreters
bourne shell
bourne-again shell
korn shell
third-party shells
free user-written
user-written shells
shells provide
similar functionality
personal preference
preference figure
shell command
main function
user-specified command
level manipulate
manipulate files
shells operate
command requires
implementing code
alternative approach
systems -implements
unix command
parameter file
file txt
extended device
device statistics
ogi nell
nell idle
un0718days wai
actv svc_t
jcpu pcpu
command-interpreter program
entering commands
users employ
mouse-based windowand
system characterized
user moves
functions depending
mouse pointer
folder-or pull
research taking
taking place
xerox parc
parc research
research facility
first cui
cui appeared
xerox alto
alto computer
graphical interfaces
apple macintosh
macintosh computers
aqua interface
first version
cui interface
ms-dos operating
windows explorer
unix systencs
command-line interfaces
gul interfaces
common desktop
desktop environment
x-windows systems
commercial versions
aix system
significant development
gui designs
gnome desktop
gnome desktops
desktops run
unix systems
open-source licenses
specific license
license terms
gui interface
unix users
users prefer
powerful shell
shell interfaces
windows users
windows gui
gui environment
ms-dos shell
shell interface
nice study
part implemented
unix kernel
interface figure
actual system
friendly user
direct function
operating systenc
fundamental problems
adequate service
systern programs
programs system
services made
routines written
low-level tasks
assembly-language instructions
system makes
makes system
simple program
first input
input file
output file
interactive system
prompting message
icon-based systems
file names
sequence requires
operations requires
error conditions
file exists
existing file
return status
status information
hardware failure
write operation
entire file
final system
simple programs
systems execute
execute thousands
systemcall sequence
applicatiol1 developers
developers design
design program.s
program.s accordir1g
tl1e ajispecifies
functions application
return values
common apis
application programmers
posix-based systems
designing programs
machine note
note that-unless
-the system-call
system-call names
generic examples
application programmer
win32 function
function createprocess
windows kernel
application programnl.er
programnl.er prefer
prefer programming
api concerns
concerns program
program portability
programmer designing
architectural differences
strong correlation
call sequence
sequence acquire
acquire input
write prompt
accept input
input acquire
acquire output
abort create
create output
abort loop
loop read
file write
read fails
fails close
close output
write completion
completion message
standard api
standard apt
win32 api-a
api-a function
function appears
return value
bool readfile
handle lpvoid
lpvoid dword
dword lpdword
lpdword lpoverlapped
lpoverlapped file
parameters bytes
parameters passed
handle file-the
file-the file
lpvoid buffer-a
buffer-a buffer
dword bytestoread-the
bytestoread-the number
buffer lpdword
lpdword bytesread
bytesread -the
-the number
bytes read
last read
read lpoverlapped
lpoverlapped ovl-indicates
native system
windows operating
run-time support
support system
functions built
libraries included
programming languages
system-call interface
calls made
interface intercepts
intercepts function
function calls
interface maintains
call interface
intended system
operating-system kernel
execution rathel
support library
mode kernel
application opeo
call return
return figure
application invoking
call system
system handles
calls occur
desired system
exact type
information vary
memory buffer
general methods
pass parameters
simplest approach
solaris parameters
operating syste1ns
syste1ns prefer
stack method
passed system
major categories
process control
file manipujation
device manipulation
information maintenance
calls support
call load
load address
register operating
chapters figure
ruru1il1g program
program runs
error trap
message generated
program designed
bugs-to determine
abnormal circumstances
invoking command
command mterpreter
gui system
pop-up wmdow
entire job
control cards
special recovery
recovery actions
batch-system concept
program discovers
error level
severe errors
higher-level error
error parameter
normal termination
action automatically
ll1tto joad
joad andexecut
th1s feafl
cmnmand i11terpreter
user command
batch command
interesting question
return control
loaded program
create process
terminate process
process attributes
set process
wait event
signal event
free memory
memory file
delete file
file attributes
set file
device management
request device
release device
device attributes
set device
devices information
system data
set system
attributes communications
delete communication
communication connection
receive messages
transfer status
detach remote
remote devices
devices figure
existing program
continue execution
control returns
memory image
programs continue
calls windows
windows unix
unix process
process createprocesso
createprocesso fork
control exi
exi tprocess
file createfile
manipulation readfile
device setconsolemode
manipulation readconsole
information getcurrentprocessid
maintenance settimero
settimero alarm
communication createpipe
mmapo protection
protection setfilesecurity
multi programmed
submit job
control requires
allowable execution
longer needed
specific event
share data
calls allowing
shared data
calls include
include acquire
acquire lock
release lock
lock system
program invokes
library intercepts
operating system-in
library takes
value returned
stdio.h int
int main
library write
library handling
concurrent processes
job control
examples-one involving
single-tasking system
multitasking system
sincple method
instruction pointer
first instruction
error code
system memory
overwritten resumes
resumes execution
first task
memory command
memory process
process command
ms-dos execution
interpreter makes
previous error
program fre
eley unix
multitasking syst
user s-choiceis
s-choiceis run
accepts commands
executes programs
user requests
__process,_th_es1w1l execu
tem call
selected program
executed depending
receive input
directly fron1
interpreter figure
freebsd running
running process
invoking process
status code
nonzero error
programs processes
common system
call requires
directory structure
organizing files
attributes include
file type
protection codes
accounting information
file attribute
file move
execute-main memory
user process
sufficient resources
resources controlled
physical devices
virtual devices
first request
close system
llnmanaged access
device contention
including unix
combined file-device
file-device structure
special file
directory placement
ncake files
underlying system
calls exist
transferring information
return information
current users
version number
dump memory
program trace
trace lists
microprocessors provide
cpu mode
single step
egl1lar tii
_ee interrupts
program c6l-i
te1 -ls
-ls recorded
frequent timer
statistical picture
process information
nica tion
passing model
shared-memory model
lel t_l
common mailbox
computer comcected
communications network
network identifier
process narne
operating systemcanrefertotheprocess
processid system
close calls
calls provided
specific open
open connection
close connection
connection system
recipient process
accept connection
connection call
receiving connections
special-purpose daemons
systems programs
receiving daenwn
read message
write message
message system
call terminates
tlared memorycreate
memory attach
attach system
2rt1d gain
access toi
toi egions
n1emory owned
processes recall
operatinisystein hiesf
prevei1foiie process-from
process-from accessing
memory shared
memory requires
processes agree
writing data
shared areas
location sirnultaneously
process scheme-threads-in
systems implement
smaller amounts
intercomputer communication
communication shared
maximum speed
memory transfer
transfer speeds
computer problems
problems exist
processes sharing
sharing memory
protection protection
controlling access
resources provided
multiprogrammed computer
providing protection
protection include
include set
set permission
permission settings
deny user
user system
allowed access
cover protection
larger issue
modern system
programs recall
recall figure
logical computer
computer hierarchy
lowest level
system utilities
convenient enviromnenf1orprograrn-aevelopmeiita1inexecuhon
programs create
ncanipulate files
directories status
similar status
detailed performance
debugging information
programs format
output devices
retrieve configuration
configuration information
information file
file modification
text editors
special commands
search contents
perform transformations
text programming-language
programming-language support
support compilers
common programming
visual basic
program loading
absolute loaders
relocatable loaders
linkage editors
overlay loaders
loaders debugging
debugging systems
higher-level languages
machine language
programs provide
virtual comcections
send rnessages
browse web
electronic-mail messages
transfer files
common problems
worg processors
text f6-rinatteis,spreadsheets
database systems
plott1i1g ana
ana s-tafistica
-analysis packages
ancl gan1es
___ tne
tne viewoclne
viewoclne opei
inost users
actual systern
systern calls
mouse-and-windows interface
command-line unix
unix shell
user dual-booting
multiple user
discuss problems
complete solutions
proved successful
design goals
first problem
define goals
general purpose
highest design
design level
basic groups
user goals
system goals
goals users
users desire
obvious properties
general agreement
similar set
unique solution
existence shows
large variety
realtime operating
large multiuser
multiaccess operating
ibm mainframes
creative task
general principles
leter111il1e hcnu
zul1dt wilcbe
wilcbe done
timer construct
-forensill1ng cpu
cpu protection
policy decision
flexibility policies
rri tlle
tlle worst
worst case
underlying mechanism
general mechanism
require redefinition
giving priority
opposite policy
policy microkernel
based operati1lg
operati1lg sy_sh
extreme byimplementing
advanced -1necharnsms
user-created kernel
time-sharing scheduler
loadable tables
tables depending
batch processing
combination making
scheduling mechanism
mechanism general
vast policy
single load-new-table
load-new-table command
extreme is_il_
an_cl_ fe_el
similar interfaces
system libraries
functionality policy
policy decisions
assembly language
first system
master control
burroughs computers
computers mcp
algol multics
small sections
higher-level language
systemsimplementation language
implementing operating
compiler technology
generated code
entire operating
simple recompilation
port-to move
intel x86
x86 family
ms-dos runs
x86 instruction
instruction set
including intel
sun sparc
reduced speed
increased storage
storage requirements
major issue
expert assembly-language
assembly-language programmer
efficient small
small routines
large programs
modern compiler
complex analysis
sophisticated optimizations
produce excellent
excellent code
code modern
modern processors
n1.ultiple functional
functional units
complex dependencies
human mind
major performance
performance improvements
excellent assembly-language
assembly-language code
small amount
high performance
cpu scheduler
critical routines
bottleneck routines
assembly-language equivalents
common approach
small components
monolithic system
well-defined portion
common components
simple structure
commercial operating
operating systen1.s
well-defined structures
systems started
limited systems
original scope
scope ms-dos
modules carefully
carefully figure
appii.cat1on programs
programs aie
freedom leaves
leaves ms-dos
malicio lls
entire system
system crashes
programs fail
base hardware
hardware accessible
limited structuring
original unix
unix operating
operating systein
hard ware
ware ft1il.cfionali.ty
eril.el ai1d
system prograrns
rom bios
bios device
drivers figure
ms-dos layer
layer structure
traditional unix
physical hardware
operating-system fm1ctions
enormous an1ol.lnt
monolithic structure
layered approach
approach withproper
lre support
brokeninto pieces
opriate thar
hose allowed
commands compilers
interpreters system
libraries signals
terminal handling
handling character
terminal drivers
system swapping
swapping block
system disk
tape drivers
drivers cpu
scheduling page
replacement demand
memory figure
layered operating
lj_ix systeill
greater control
computer implementers
creating modular
modular operating
topdown approach
components information
information hiding
leaves programmers
low-level routines
external interface
routine stays
advertised task
ways qne
qne method
broken ii1to
layering structure
operating-system layer
abstract object
object made
typical operating-system
operating-system layer-say
higher-level layers
layers layer
invoke operations
lower-level layers
main advantage
approach simplifies
.system verification
first layer
basic hardware
correct functioning
operations provided
lowerlevel layers
layer hides
major difficulty
approach involves
careful planning
backing store
virtual-memory algorithms
lower level
memory-management routines
management requires
backing-store driver
large system
scheduler m.ay
active processes
backu1.g-store driver
driver routine
final problem
layered implementations
memory-management laye1
tum calls
cpu-scheduling layer
layer adds
net result
nonlayered system
small backlash
recent years
years fewer
fewer layers
modularized code
difficult problems
layer definition
carnegie mellon
mellon university
university developed
operatu1.g system
nonessential cornponentsfrom
cornponentsfrom thekemel
the.reslin is-a
is-a smarrei
user space
microkernels provide
minimal process
communication facility
micro kernel
client program
space communication
program wishes
file server
interact directly
directly rathel
exchanging messages
microkernel approach
require modification
smaller kernel
resulting operating
service fails
system remains
remains untouched
approach tru64
tru64 unix
digital unix
unix interface
mach kernel
kernel maps
maps unix
user-level services
mach micro
qnx nl.icrokernel
low-level network
network communication
hardware interrupts
standard processes
performance decreases
increased system
system function
function overhead
first release
layered microkernel
microkernel organization
version delivered
low performance
performance compared
performance problem
moving layers
kernel space
current methodology
design involves
object-oriented programming
programming techniques
modular kernel
core components
additional services
loadable modules
modern implementations
organized armmd
loadable kernel
scheduling classes
loadable system
executable formats
formats streams
streams modules
miscellaneous device
bus drivers
core services
systems figure
result resembles
layered system
kernel section
protected interfaces
primary module
core functions
invoke message
hybrid structure
layer consists
mach microkernel
top layers
layers include
include application
application environments
services providing
graphical interface
kernel environment
bsd kernel
kernel mach
remote procedure
procedure calls
including message
bsd component
bsd command
command line
line interface
including pthreads
pthreads kernel
environment application
common services
services figure
kernel extensions
bsd facilities
facilities directly
approach described
logical conclusion
fundamental idea
si11.gle computer
interface cards
execution environments
execution environment
private computer
virtual-memory techniques
underlying bare
underlying computer
guest process
single physical
physical machine
run multiple
multiple operating
processes processes
processes kernel
kernel kernel
kernel vm1
vm1 vm2
vm2 vm3
vm3 virtual-machine
virtual-machine implementation
system models
nonvirtual machine
original concepts
facility worth
worth exploring
exploring ibm
ibm vm370
vm370 divided
ncajor difficulty
virtualmachine approach
approach involved
involved disk
disk systems
systems suppose
virtualmachine software
substantial disk
virtual disks-termed
disks-termed minidislcs
system implemented
physical disks
minidisk needed
software packages
underlying machine
ran cms-a
cms-a single-user
interactive operating
important advantage
host system
virus inside
guest operating
protection problems
direct sharing
file-system volume
share files
send information
virtual communications
physical communication
communication networks
virtual-machine system
perfect vehicle
operating-systems research
difficult task
task operating
complex programs
system executes
wrong change
system carefully
entire machine
current system
system load
problem system
system programmers
system development
normal system
operation seldom
workstation concurrently
virtualized workstation
rapid porting
varying enviromnents
enviromnents sinlilarly
quality-assurance engineers
multiple environments
major advantage
production data-center
separate systems
physical-to-virtual conversions
conversions result
resource optimization
machines continues
application deployment
install applications
application developers
customized operating
virh1al machine
virtual environment
release mechanism
application management
technical support
straightforward system
system administrators
environment easier
usual steps
widespread adoption
virtualization platform
open virtual
machine format
unifying virtual-machine
virtual-machine formats
simulation system
system virtualization
system-emulation methodologies
methodologies virtualization
native hardware
guests run
full speed
guest system
outdated computer
important programs
outdated system
native instruction
system emulation
major challenge
instruction-set emulation
magnitude slower
native instructions
ten times
correct emulator
entire cpu
paravirtualization presents
preferred system
paravirtualized hardware
extra work
smaller virtualization
virtualization layer
layer solaris
virtual layer
providing processes
network stacks
network address
user accounts
cpu resources
systemwide processes
processes figure
standard global
global user
space user
programs cpu
resources memory
memory resources
global zone
zone user
programs network
network addresses
addresses device
device access
access cpu
resources user
resources zone
virtual platform
platform device
management figure
virtual-machine concept
exact duplicate
machine remember
virtual-machine software
virtual user
virtual kernel
physical user
real machine
system calt
virtual-machine monitor
monitor gains
gains controt
register contents
major difference
unpredictable ways
extreme case
true virtual
ibm machines
normal instructions
feature rich
major generalpurpose
generalpurpose cpus
amd virtualization
virtualization technology
amd processors
machine software
enable host
host mode
guest virtual
guest mode
virtualized operating
system thinks
virtualized resource
first developed
developed today
solving system
system compatibility
compatibility problems
popular contemporary
contemporary virtual
vmware workstation
design types
types discussed
discussed earlier
design methods-simple
methods-simple layers
virtual machines-are
mutually exclusive
virtualization techniques
techniques discussed
section require
require virtualization
method involves
virtualization tool
machines running
running inside
user-level application
popular commercial
commercial application
abstracts intel
compatible hardware
isolated virtual
machines vmware
workstation runs
host operating
independent virtual
rum ing
virtual cpu
network interfaces
physical disk
identical guest
guest instance
file copying
location protects
original site
site moving
application application
application guest
operating guest
system system
free bsd
devices virtualization
layer hardware
jemgfy figure
vmware architecture
location moves
scenarios show
system resource
machine java
popular object-oriented
language introduced
language specification
large api
api library
virtual machine-or
machine-or jvm
jvm java
java objects
class construct
java program
program consists
java class
compiler produces
architecture-neutral bytecode
bytecode output
abstract computer
class loader
java interpreter
architecture-neutral bytecodes
loader loads
class files
verifier checks
class file
valid java
java bytecode
perform pointer
class passes
passes verification
automatically manages
performing garbage
garbage collection
collection -the
-the practice
reclaiming memory
research focuses
collection algorithms
interpreter interprets
bytecode operations
faster software
software technique
java method
native machine
subsequent invocations
machine instructions
program .class
.class files
.net framework
class libraries
developing software
specific architecture
program written
architecture implementing
environment abstracts
executing program
underlying architecture
common language
language runtime
.net virtual
machine itprovides
languages targeted
framework programs
architecture-independent language
microsoft intermediate
intermediate language
compiled files
ms-il instructions
file extensions
clr loads
loads assemblies
application domain
clr converts
instructions inside
native code
just-in-time compilation
compilation clr
source ms-il
vb.net source
ms-il assembly
assembly host
special java
java chip
software interpreter
just-in-tim.e compiler
fixing errors
system debugging
debugging seeks
fix errors
software performance
performance problems
considered bugs
improve performance
processing taking
hardware debugging
debugging kernel
process errors
failure analysis
process fails
systems write
error information
alert system
system operators
problem occurred
core image
analysis running
running programs
core dumps
tool designed
process debugging
debugging user-level
user-level process
process code
challenge operating
system kernel
kernel debugging
user-level debugging
debugging tools
kernel failure
process failure
log file
memory state
file-system code
common technique
disk set
kernel detects
unrecoverable error
entire contents
kernel-owned parts
disk area
system reboots
crash dump
dump file
performance tuning
identify bottlenecks
monitor system
system performance
performance code
display measures
system behavior
producing trace
trace listings
interesting events
important parameters
analysis program
determine system
improved system
system traces
find errors
operating-system behavior
law debugging
first place
interactive tools
command top
top displays
displays resources
sorted list
top resource-using
resource-using processes
tools display
network traffic
single-purpose tools
information making
running operating
active area
system research
enabling tracing
system problems
problems occur
kernel-enabled performance
performance analysis
analysis tools
emit debugging
debugging data
dynamic tracing
tracing facility
adds probes
running system
i11 user
astonishing amount
system state
process activities
functional calls
call lines
lines ending
mode debugging
kernel code
including areas
affecting system
system reliability
minimum performance
proportional impact
dtrace tool
tool meets
low-impact debugging
debugging environncent
dtrace framework
archaic code
breakpoint feature
halt execution
multiuser operating-system
statistical trends
individual activities
activities code
specific data
specific circumstances
pgrep xclock
xeventsqueued dtrace
probes cpu
cpu function
clear active
releasef ioctl
ioctl ioctl
ioctl xeventsqueued
kernel slows
specific problem
dtrace runs
production systems-systems
critical applications-and
slows activities
pre-debugging state
deep tool
kernel levels
kernel layers
individual cpu
cpu instructions
kernel subroutine
subroutine activities
probes dtrace
dtrace providers
providers create
create probes
probes kernel
kernel structures
structures exist
hash table
table data
data structure
unique probe
probe identifiers
call dtrace_probe
probe identifier
original operation
system-call probe
probe works
user-process probe
probe dtrace
dtrace features
byte code
specific kernel
kernel state
state modifications
specifically requested
dtrace privileges
root users
private kernel
kernel data
modify data
code runs
enables probes
enables consumers
enables communications
ace consumer
consumer requests
provider create
probe fires
emits data
probes fire
multiple ecbs
usual action
probe execution
complete picture
kernel action
probes firing
user-level action
action caused
kernel-level reactions
code optimization
probe consumer
consumer tennil1.ates
ecbs consuming
involves rewriting
dtrace_probe call
original code
probing occurred
occurred dtrace
dtrace takes
takes care
cpu capacity
probe results
exceeding default
maximum limits
limits cpu
offending probes
probes buffers
avoid contention
ofd code
output shows
program shows
dtrace code
enable scheduler
scheduler probes
process running
program nms
on-cpu uid
-cpu self
timestamp self
sched.d dtrace
grwme-settings-d gnome-vfs-daemon
gnome-vfs-daemon dsdm
wnck-applet gnome-panel
clock-applet mapping-daemon
mapping-daemon xscreensaver
xscreensaver meta
meta city
city xorg
gnome-terminal mixer
mixer applet2
applet2 java
open-source solaris
conflicting license
license agreements
unique capabilities
linux derivatives
kernel-tracing functionality
include performance
tracing tools
tools fostered
paradyn project
peripheral configurations
specific computer
computer site
system generation
iso image
sysgen program
program reads
specific configuration
hardware systenc
extended instruction
instruction sets
multiple cpu
cpu systems
boot disk
referencing memory
illegal address
address fault
procedure defines
final legal
legal address
device interrupt
interrupt number
special device
device characteristics
parameter values
cpu-scheduling algorithm
maximum number
system administrator
completely compiled
compiled data
data declarations
conditional compilation
output-object version
system described
tailored level
system description
precompiled library
generated operating
system selection
resulting system
overly general
table driven
selection occurs
generation involves
major differences
generated system
hardware configuration
acquired graphics
drive balanced
small piece
bootstrap loader
loader locates
two-step process
simple bootstrap
loader fetches
complex boot
boot program
turn loads
cpu receives
reset event-for
event-for instance
-the instruction
instruction register
predefined memory
execution starts
initial bootstrap
unknown state
computer virus
run diagnostics
diagnostics pass
booting steps
memory sooner
rom storing
simple supporting
supporting hardware
rugged operation
bootstrap code
code requires
rom hardware
hardware chips
systems resolve
characteristics fall
executing code
slower thart
thart executing
systems store
fast execution
final issue
small ammmts
large operating
general-purpose operating
bootstrap nms
nms diagnostics
single block
program stored
boot block
simple code
single disk
open-source bootstrap
disk-bound bootstrap
boot partition
full bootsh
make requests
system directly
higher level
program commands
batch-mode execution
time-shared mode
mode system
common u.ser
u.ser requests
vary accord
system-call level
manipulation higher-level
higher-level requests
calls system
program controt
controt status
status requests
requests program
program errors
considered implicit
implicit requests
system desired
important designing
good technique
concept takes
ilcg system
entire operating-system
design cycle
separate policy
implementation details
maximum flexibility
feature improves
machine configuration
perform system
generation debugging
debugging process
kernel failures
analyze core
dumps tools
dtrace analyze
analyze production
production systems
fucd bottlenecks
smarter programs
major activities
just-in-time compiler
executing java
functions provided
main categories
interface provided
operating-system designer
virtual-machine architecture
require tight
passing parameters
microkemel approach
services interact
microkernel architecture
experimental synthesis
synthesis operating
assembler incorporated
system-call performance
kernel assembles
assembles routines
system easier
easier discuss
synthesis approach
kernel design
system-performance optimization
kernel approach
systemcall interface
statistical profile
program executing
code discuss
destination file
program works
destilcation files
files write
error checking
including ensuring
source file
traces system
calls linux
ptrace utility
solaris systems
dtrace command
ktrace facility
win32 version
programs communicate
system part
user-mode procedure
procedure call
passing arguments
process continues
result i11
execution context
intel386 architecture
system-call number
eax register
storing arguments
hardware registers
int ox80
assembly instruction
systemcall number
code pointers
handler code
code implementing
expanded privileges
execute kernel
requested services
perform process
call numbers
nr_close corresponds
call close
file descriptor
system-call handlers
heading entry
entry number
number defined
.long denotes
data value
type long
built kernel
activity comprises
code package
suffix corresponds
kernel version
kernel binary
kernel distributions
typical commands
make dep
make bzimage
bzimage add
boatable kernels
kernels supported
ofbootable kernels
machine boot-up
system supports
supports lilo
lilo conf
mykernel root
kernel image
boot-up process
unmodified kernel
ftmction properly
properly part
source files
srcllinux-2 xlkernel
xlkernel directory
existing source
source directory
modify lusr
srcllinux-2 xlkernelimakef
xlkernelimakef ile
created file
compilation process
first approach
modified part
background tasks
booting linux
linux kernels
limited functionality
kernel messages
helloworld system
system-call mechanism
sheds light
kernel create
call include
header files
files linuxllinkage
include linuxllinkage.h
include linuxlkernel.h
linuxlkernel.h asmlinkage
asmlinkage int
int sysjhelloworld
rellli ant
print messages
kernel log
function prototype
call number
added system
constant tracks
kernel add
.long sys_helloworld
invoked system
call add
file helloworld
binary image
created kernel
kernet rename
unmodified kernet
loader configuration
configuration files
call part
defined system
library supports
calls defined
manual intervention
noted earlie1
hardware register
low-level operations
language statements
assembly instructions
wrapper functions
_syscallo macro
macro takes
first specifies
requires arguments
assembly code
code required
call compile
integer value
character string
passing pointers
data stored
registers dijkstra
operating-system desigll
early proponent
complete systems
built system
system instrumentation
dtrace source
covers windows
windows system
detail bsd
systems-including mach-are
mach-are treated
lwww apple
apple comlmacosx
first operating
ibm vmi370
vmi370 operating
microkernel-based operating
present details
exokernel operating
architecture separates
separates management
management issues
untrusted software
exercise control
java language
internal workings
java operating
systems systems
systems consist
process contained
single thread
modem operating
support processes
multiple threads
thread management
early computer
systems allowed
complete control
current-day computer
executed concurrently
evolution required
required firmer
firmer control
modern time-sharing
main concern
system tasks
operatingsystem processes
processes executing
executing system
executing user
including scheduling
describe communication
discussing operating
systems involves
cpu activities,_f
single-user system
word processor
web browse1
e-mail package
programmed activities
processes _the
_the ten
term process
operat1ng-system theory
major activity
job processing
accepted terms
word job
job scheduling
superseded job
program code
text section
current activity
process stack
temporary data
function parameters
return addresses
local variables
data section
global variables
memory thatis
process run
passive entity
instructions stored
executable file
common techniques
executable files
icon representing
prog exe
event completion
completion figure
process state
mail program
browser program
separate process
text sections
stack sections
sections vary
created running
running instructions
executed waiting
processor terminated
finished execution
delineate process
process states
state diagram
control block
cess isrepreserlt
operatir1,g system
process_ coptrol
coptrol blo_ck
specific process
ready runnil
process cpu
mclude accumulators
stack pointers
general-purpose registers
condition-code information
state information
mterrupt occurs
cpu-scheduling information
information includes
process priority
scheduling queues
scheduling parameters
describes process
memory-management information
limit registers
page tables
segment tables
memory system
mformation includes
account numbers
process numbers
devices allocated
open files
process model
model discussed
word-processor program
system interrupt
call process
executing idle
idle figure
diagram showing
showing cpu
cpu switch
simultaneously type
spell checker
modern operatin.g
operatin.g systems
supports threads
include information
support threads
threads chapter
explores multithreaded
multithreaded processes
process nnming
maximize cpu
process scheduler
scheduler selects
single-processor system
job queue
ready queue
process representation
struch1re task_struct
fields include
pid_t pid
int time_slice
scheduling information
struct task_struct
task_struct parent
struct list__head
list__head children
struct files_struct
files_struct files
struct mm_struct
process isrepresented
long state
linked list
kernel maintains
pointer -current
task_struct process
information struct
executing proccess
linux struct
value new_state
ready-queue header
final pcbs
pcb includes
pointer field
queue header
header mag
mag tape
device queues
request suppose
process makes
shared device
processes waiting
device queue
common representation
queueing diagram
rectangular box
box represents
circles represent
queueing-diagram representation
waiting state
ready state
resources deallocated
process migrates
scheduling purposes
selection process
mass-storage device
long-term scheduler
job scheduler
selects processes
short-term scheduler
primary distinction
schedulers lies
cpu frequently
scheduler executes
scheduler controls
average rate
average departure
departure rate
processes leaving
process leaves
longer interval
scheduler make
cpu bound
doing computations
cpu-bound process
scheduler select
good process
process mix
cpu-bound processes
waiting queue
systems depends
physical limitation
self-adjusting nature
human users
performance declines
acceptable levels
multiuser system
simply quit
intermediate level
medium-term scheduler
key idea
remove processes
active contention
scheduler swapping
memory requirements
requiring memory
sw11pped-out processes
out figure
medium-term scheduling
context switch
current task
kernel routine
operations happen
resu.me operations
operations switching
process requires
state save
current process
state restore
switch occurs
kernel saves
saved context
process scheduled
speed varies
memory speed
special instructions
single instruction
typical speeds
context-switch times
sun ultrasparc
multiple sets
current register
register sets
system resorts
copying register
register data
extra data
memory-management method
deleted dynamically
n1.echanisms involved
creating processes
illustrate process
create-process system
creating process
parent process
turn create
windows family
identify processes
unique process
process identifier
integer number
number figure
typical process
process tree
sched process
process creates
managing memory
root parent
dtlogin inetd
networking services
process representing
user login
login screen
dtlogin creates
x-windows session
turns creates
sdt_shel process
command-line shell-the
shell-the c-shell
csh-is created
commandline interface
child processes
cat commands
csh process
netscape browser
emacs editor
complete information
tracing parent
parent processes
inetd pid
dtlogin pid
typical solaris
solaris system
children restricting
child process
resources prevents
file img.jpg
contents out
systems pass
pass resources
terminal device
possibilities exist
parent continues
parent waits
tmique integer
process consists
original process
return code
call loads
binary file
separate ways
child runs
issue await
program shown
previously described
processes running
running copies
include sysltypes.h
include stdio.h
include unistd.h
unistd.h int
fork failed
child complete
unix fork
value greater
actual pid
process inherits
inherits privileges
scheduling attributes
directory listing
invoking exit
process resumes
parent wait
wait resumes
resumes child
include windows.h
windows.h int
allocate memory
memory zeromemory
create child
line null
inherit process
process handle
thread handle
handle false
disable handle
handle inheritance
creation flags
flags null
environment block
block null
existing directory
process failed
complete waitforsingleobject
close handles
handles closehandle
alternative examplef
windows processes
parent creates
process howeverf
process inheriting
parent createprocess
requires loading
creation furthermoref
parametersf createprocess
application mspaint
default values
ten parameters
readers interested
process_information structures
structures startupinfo
startupinfo specifies
window size
standard input
output files
process_information structure
created process
command-line parameters
command-line parameter
parameter specifies
mspaint.exe application
initial parameters
default parameters
inheriting process
thread handles
existing environment
starting directory
process.lnformation structures
structures created
process waits
wai tforsingleobj
tforsingleobj ect
child process-pi
process-pi hprocess-and
hprocess-and waits
process exits
process termination
final statement
status value
process-including physical
system termination
jobs note
task assigned
longer required
parent terminates
including vms
cascading termination
process execution
call returns
terminated child
execution statistics
statistics processes
independent processes
cooperating processes
shares data
cooperating process
process cooperation
information sharing
shared file
concurrent access
information computation
computation speedup
processing elements
modular fashion
parallel cooperating
processes require
exchange data
fundamental models
established processes
shared region
messagepassing model
messages exchanged
communications models
smaller ammmts
avoided message
messagepassing system.s
time-consuming task
kernel irttervention
sharedmemory systems
shared-memory regions
routine memory
memory accesses
ipc models
shared-memory systems
systems interprocess
communicating processes
shared-memory region
region resides
process creating
sharedmemory segment
space recall
excbange information
location simultaneously
common paradigm
producer process
process produces
produces information
consumer process
ncay produce
produce object
object modules
client-server paradigm
server produces
html files
client web
browser requesting
consumer processes
practical limit
fixed buffer
buffer size
bounded buffer
enable processes
variables reside
define buffer_size
typedef struct
item buffer
shared buffer
circular array
logical pointers
free position
out points
first full
full position
local variable
buffer_size items
item nextproduced
address concerns
process attempt
buffer concurrently
sharedmemory environment
message-passing systems
systems lrt
lrt section
shared-memory environment
scheme requires
processes share
message-passing facility
facility message
distributed environment
computers connected
chat program
participants communicate
variable size
fixed-sized messages
system-level implementation
task item
item nextconsumed
variable-sized messages
messages require
1nore complex
complex system-level
programming task
coitlmon kind
operatingsystem design
communication link
physical implementation
hardware bus
logical implementation
indirect communication
asynchronous communication
explicit buffering
naming processes
scheme exhibits
exhibits symmetry
sender process
receiver process
scheme employs
employs asymmetry
sender names
limited modularity
resulting process
process definitions
definitions changing
hard-coding techniques
techniques involving
involving indirection
w1.ique identification
posix message
shared mailbox
share mailbox
answer depends
round robin
turns receiving
receiving messages
unique owner
mailbox terminates
mailbox disappears
longer exists
mailbox send
mailbox delete
receiving privilege
multiple receivers
synchronization communication
processes takes
design options
primitive message
asynchronous blocking
blocking send
sending process
receiving process
mailbox nonblocking
nonblocking send
process sends
resumes operation
operation blocking
blocking receive
receiver blocks
nonblocking receive
receiver retrieves
valid message
mailbox likewise
consumer invokes
asynchronous occur
processes reside
temporary queue
maximum length
messages waiting
recipient receives
message bounded
bounded capacity
finite length
quelie unbounded
unbounded capacity
zero-capacity case
automatic buffering
discuss message
mach operating
posix shared
ipc mechanisms
memory segment
first parameter
shared-memory segment
parameter identifies
successful call
integer identifier
identifier processes
pointer location
memory indicating
shared ncemory
sharedmemory region
read-write mode
beginning location
pointer returned
longer requires
requires access
shared segrnent
flag ipcrmid
posix shared-memory
shared-memory api
program creates
4,096-byte shared-memory
process writes
updated memory
message-based operating
kernel supports
multiple tasks
intertask informationis
informationis carried
messages messages
tailboxes-the kernel
kernel mailbox
kernel sends
sends notification
event occurrences
notify port
message transfer
call sends
,which sends
return message
rpc models
typical subroutine
subroutine procedure
term remote
call creates
allocates space
maximum size
message queue
include syslshm.h
include syslstat.h
syslstat.h int
char shared_memory
int size
program illustrating
api defaults
initially empty
priority mach
mach guarantees
multiple messages
absolute ordering
fixed-length header
variable-length data
data portion
mailbox names
sending thread
thread expects
receiving task
variable part
typed data
data items
objects defined
receive access
task states
memory segments-n
receive operations
thread continues
mailbox wait
return immediately
full mailbox
final option
server tasks
line-printer driver
one-time reply
requested service
service requests
reply mailbox
receive operation
mailbox set
task threads
operation attempts
receiving thread
singleprocessor systems
major problem
message systems
poor performance
performance caused
double copying
mach message
system attempts
double-copy operations
virtual-memory-management techniques
message-management technique
large performance
performance boost
intrasystem messages
extra chapter
chapter posted
modern design
employs modularity
increase functionality
features windows
n1.essage-passing mechanism
considered clients
subsystem server
standard rpc
rpc mechanism
port object
communication channet
inherited windows
connection ports
communication ports
cmmection ports
named objects
give applications
communication channels
communication works
client opens
connection port
client sends
cmmection request
server creates
private conimunication
conimunication ports
port handle
replies windows
rnessage-passing techniques
client specifies
intermediate storage
larger message
large message
client determines
section object
server decides
small message
size information
first method
avoids data
data copying
callback mechanism
asynchronous message
message handling
local procedure
lpc facility
api invoke
invoke standard
standard remote
client server
server connection
connection request
communication port
handle communication
shared section
call lpcs
communication ir1
ir1 client-server
processes communicating
network employ
address concatenated
port number
client-server architecture
server waits
incoming client
server accepts
client socket
com1ection servers
servers implementing
well-known ports
telnet server
server listens
ftp server
standard services
client process
process initiates
host computer
arbitrary number
number greater
assigned port
packets traveling
process based
destination port
com1.ections consist
unique pair
program examples
illustrate sockets
easier interface
rich library
networking utilities
chapter java
socket class
datagram.socket class
mul ticastsocket
ticastsocket class
multicast socket
multiple recipients
date server
connection-oriented tcp
tcp sockets
current date
server returns
server blocks
method waiting
server communicates
printwri ter
ter objectthatitwill
ter object
routine print
server process
method println
server closes
client communicates
import java.net
import java.io
public class
class dateserver
public static
static void
void main
serversocket sock
socket client
socket pout.println
connections client
client close
ioexception ioe
server java
client creates
normal stream
client closes
computer refers
host running
actual host
host namef
sockets-although common
efficient-is considered
low-level form
distributed processes
unstructured stream
communicating threads
server application
higher-level methods
class dateclient
server socket
socket socket
socket sock
bufferedreader bin
socket string
string line
socket connection
connection sock
sock close
idexception ioe
date client
common forms
remote service
rpc paradigm
procedure-call mechanism
ipc mechanism
mechanism described
message-based communication
ipc facility
rpc communication
rpc daemon
daemon listening
remote system
separate message
number included
message packet
rencote process
proper port
system wished
daemon supporting
rpc attached
port-say port
needed information
rpc message
reply message
remote host
procedure locally
rpc system
system hides
client side
separate stub
stub exists
separate remote
client invokes
parameters provided
stub locates
parameters parameter
parameter marshalling
marshalling involves
involves packaging
similar stub
server side
side receives
concerns differences
data representation
server machines
significant byte
byte first
resolve differences
rpc systems
systems define
machine-independent representation
involves converting
machine-dependent data
xdr data
machine-dependent representation
important issue
issue involves
calls fail
extreme circumstances
network errors
history large
repeated messages
detected incoming
incoming messages
protocol described
rpc call
ack messages
issue concerns
standard procedure
binding takes
rpc scheme
similar binding
server port
port numbers
full information
binding information
fixed port
port addresses
rendezvous mechanism
fixed rpc
rpc port
rendezvous daemon
daemon requesting
port address
rpc calls
server crashes
method requires
extra overhead
initial request
approach figure
sample interaction
interaction client
client kejyt
sends rness
rness tqe
matchrnakecto fit
client port
rpcx port
server figure
distriblited file
rpc daemons
system port
file operation
disk operation
usual file-related
file-related system
data resulting
dfs daemon
simple block
block request
conduit allowin.g
communicate pipes
first ipc
early unix
simpler ways
unidirectional communication
bidirectional communication
two-way communication
full duplex
commlmicating processes
pipes communicate
common types
ordinary pipes
standard producerconsumer
producerconsumer fashion
producer writes
consumer reads
one-way communication
pipe sending
sending data
illustrate constructing
constructing ordinary
process reads
message front
function pipe
function creates
file descriptors
write end
parent child
-pip-e -ou
-ou figure
ordinary pipe
pipe unix
unix treats
special type
ordinary read
child inherits
process figure
unix progranc
progranc shown
call creating
call depends
parent writes
child reads
unused ends
important step
process reading
include string.h
define read_end
define write_end
char write_msg
char read_msg
program continues
pipe failed
unused end
unix counterparts
employ parent-child
parent-child relationships
ordinary readfile
wri tefile
creating pipes
separate handles
startupinfo structure
include stdlib.h
handle readhandle
char message
dword written
anonymous pipes
pipes parent
anonymous pipe
unlike unix
pipe created
windows requires
first initializing
security--attributes structure
standard output
read handle
pipe creating
designated handles
unused read
read end
program obtains
invoking getstdhandle
pipes require
parent-child relationship
named pipes
pipes provide
simple communication
communication mechanism
pipes exist
pipe ceases
security attributes
attributes allowing
allowing pipes
create pipe
startjnfo structure
startf _usestdhandles
wri tehandle
inherit handles
error writing
program named
powerful communication
communication tool
named pipe
define buffer_stze
char buffer
dword read
child read
error reading
-child process
typical scenario
pipes continue
support named
implementation vary
vary greatly
systems named
typical files
ordinary open
half-duplex transmission
intermachine communication
required named
richer communication
counterparts full-duplex
full-duplex communication
byte-oriented data
unix ftfo
message-oriented data
data named
practice pipes
unix command-line
command-line environment
command serves
command produces
long directory
directory listings
manages output
space bar
individual processes
moref enabling
large directory
complete command
corrm1and serves
command windows
dos shell
unix cmmterpart
dir command
equivalent command
readyf running
major classes
request queuecc
long-term scheduling
resourceallocation considerations
queue operating
allowing concurrent
processes cooperating
communication mechanisnc
shared mernory
shared-memory method
shared variables
shared-memory system
providing communication
communication rests
message-passing method
system communication
applications consists
communication chamcel
chamcel rpcs
distributed commlmication
rpc occurs
remote application
application ordinary
pipes permit
permit unrelated
unrelated processes
system level
programmer level
asynchronous commmucation
mechanism describe
undesirable consequences
semantic describe
semantic execute
ack message
network problem
problem describe
concurrent processing
processing discuss
major complications
processing adds
ultrasparc processor
multiple register
sets describe
obtain process
command man
task manager
longterm scheduling
initial parent
actual pids
include stdio
pid values
fibonacci sequence
comm_and line
int value
parent invoke
program perform
non-negative number
preceding exercisef
separate program
process outputting
sequence perform
server shown
delivers random
random jokes
multiple lines
client shown
multi-line jokes
jokes returned
joke server
echo server
server echoes
exact data
client-that isf
java networking
networking api
api described
client connection
buffer write
bufferedreader class
class bufferedreader
bufferedreader extends
reader class
reading character
character streams
read characters
binary data
class java
input stream
stream deals
byte level
character level
extends java
inputstrearn class
class returns
parent output
child completes
child makes
fixed-sized array
size malsequence
fibonacci values
generatesequence_ size
define max_sequence
long fib_sequence
int sequence_size
parameter passed
perform error
size shared_data
systen1 call
processes involves
involves synchronization
synchronization issues
child finishes
invoke wait
string message
process reverses
original message
modified message
windows pipes
file-copying program
named filecopy
copied file
input.txt copy.txt
file input
input txt
file copy
copy txt
ipcs command
command lists
communication mechanisms
shared-memory segments
structure struct
struct shmid_ds
structure include
int shm_segsz-size
short shm__nattch-number
segment struct
struct ipc_perm
ipc_perm shm_perm-permission
shm_perm-permission structure
ipc_perm data
short uid
-memory segment
segment unsigned
short mode-permission
mode-permission modes
modes key_t
key_t key
-user-specified key
key identifier
permission modes
call permissions
write permission
read permission
permissionof world
world permissions
statement mode
permission mode
userspecified key
segment created
shm_ds structure
integer segment
segment identifier
int segment_id
shm_ds shmbuffer
error condition
global variable
variable errno
segmentid key
key mode
mode owner
size number
project consists
communicating temperatures
external processes
central process
communicate temperatures
initial temperature
external temp
central temp
temps received
external process
last iteration
final stabilized
stabilized temperature
outer processes
passing system
function converts
internal identifier
identifier returned
subsequent system
facilitate interprocess
typical invocation
parameter instructs
write privileges
existing mailbox
avoid attaching
existing message
omitting ipc_creat
accessible variable
error occurred
process determines
including ipc_creat
current project
standalone pcs
unique ranges
valid msqid
fixed-length portion
variable-length portion
system specifies
message format
data aggregate
first field
integral value
additional fields
process number
process sending
notices stability
recommended struct
struct appears
long priority
int temp
int pid
int stable
stat msgrcv
valid msq
negative value
functions return
successful completion
information bytes
final parameter
individual message
messages-or bytes-so
minimum priority
priority level
process wishes
synchronous operation
message queue-and
unread messages
invoke msgctl
struct msgid_ds
msgid_ds dummyparam
function requires
programmer wishes
substituting ipc_stat
confusing artifact
queue implementation
implementation bears
,any subsequent
subsequent attempts
msqid part
central server
numeric identifier
mailbox named
outer process
process specifies
specifies ipc_creat
invoking msgget
invokes msgget
subsequent calls
removes -via
-via msgctl
unique number
temperature assuming
implementation hints
single outer
vice versa
queue system
failed requests
successfully completes
-for instance
message received
solved processes
correct number
argc parameter
extraneous messages
messages residing
mailboxes relevant
processes begin
ipcrm command
remove message
asynchronous message-passing
message-passing prirnitives
facility implemented
user level
describe interprocess
system russinovich
outline interprocess
systems programming
reliable rpc
discuss procedure
message-passing communication
communication harold
java hart
cover pipes
model introduced
provide features
features enabling
chapter introduces
multithreaded computer
java thread
kernel level
examine issues
threads belonging
code section
operating-system resources
traditional process
modern desktop
desktop pcs
thread display
display images
single-threaded process
process multithreaded
processes text
thread retrieves
retrieves data
displaying graphics
grammar checking
single application
similar tasks
accepts client
busy web
server ran
traditional single-tlu
single-tlu eaded
eaded process
server run
accepts requests
server receives
process-creation method
popular process
existing process
web-server process
separate thread
resume listening
additional requests
vital role
systems recall
ordinary function
rpc servers
concurrent requests
system kernels
threads operate
thread performs
specific task
additional client
requests figure
multithreaded server
server architecture
managing devices
interrupt handling
examplef solaris
solaris creates
kernel thread
responsiveness multithreading
interactive application
lengthy operation
increasing responsiveness
multithreaded web
thread resource
resource sharing
sharing processes
threads share
sharing code
economy allocating
allocating memory
context-switch threads
manage processes
thirty times
context switching
times slower
slower scalability
multiprocessor architecture
multicpu machine
machine increases
increases parallelism
single-core system
multicore programming
place multiple
computing cores
core appears
separate processor
improved concurrency
single computing
computing core
processing core
concurrency means
system designers
cores designers
multiple processing
processing cores
parallel execution
execution shown
existing programs
present challenges
dividing activities
examining applications
find areas
concurrent tasks
individual cores
cores balance
identifying tasks
tasks perform
equal work
equal value
execution core
cost data
data splitting
separate tasks
data accessed
separate cores
cores core
multicore system
data dependency
task depends
execution paths
paths testing
concurrent programs
single-threaded applications
software developers
developers argue
designing software
software systems
treated threads
generic sense
threads user
user threads
kernel support
kernel threads
operating systems-including
systems-including wiridows
-support kernel
common ways
many-to-one model
user-level threads
thread thread
thread library
user figure
user thread
thread figure
one-to-one model
model space
entire process
thread makes
blocking system
thread requires
creating kernel
model restrict
threads supported
system linux
many-to-many model
equal number
-kernel thread
two-level model
model create
true concurrency
greater concurrency
model suffers
popular variation
user-level thread
system supported
managing threads
primary ways
library exist
library results
local function
function call
kernel-level library
library supported
space invoking
typically results
main thread
java pthreads
threads extension
win32 thread
thread api
java threads
basic thread
multithreaded program
non-negative integer
well-known summation
summation function
upper bounds
summation entered
user enters
integer values
pthreads refers
posix standard
thread behavim
implementation operating
numerous systems
pthreads specification
unix shareware
shareware implementations
public domain
basic pthreads
pthreads api
nonnegative integer
pthreads program
separate threads
threads begin
begin execution
program begins
control begins
begins control
global data
data sum
pthreads programs
header file
statement pthread_t
pthread_t tid
tid declares
including stack
stack size
pthread_attr_t attr
attr declaration
declaration represents
call pthread_attr
pthread_attr ini
default attributes
attributes provided
thread identifier
integer parameter
thread performing
include pthread.h
int sum
void runner
void param
int argc
char argv
thread attributes
begin control
summation threadf
parent thread
pthread_j oin
summation thread
function pthread_exi
creating threads
pthreads technique
pthreads version
version shown
separate threads-in
dword data
data type
32-bit integer
win32 defines
function sets
pthreads-a set
attributes il1.clude
il1.clude security
security information
suspended state
thread recall
pthread program
thread wait
cover synchronization
synchronization objects
threads tlu
tlu eads
fundamental model
api provide
rich set
programs comprise
simple java
program consisting
method runs
thread class
runnable interface
public interface
public abstract
abstract void
class implements
java version
summation class
interface thread
stdio.h dword
dword sum
thread runs
separate function
dword winapi
winapi sumrnation
lpvoid param
dword upper
dword threadid
handle threadhandle
int param
basic error
thread threadhandle
default security
default stack
size summation
thread function
function &param
default creation
handle closehandle
class sum
private int
public int
int getsum
return sum
public void
void setsum
this.sum sum
class summation
summation implements
int upper
private sum
sum sumvalue
public summation
void run
class driver
shared sum
sum sumobject
thread thrd
thrd join
summation integer
object instance
runnable object
object creating
thread object
thread calling
allocates memory
method directly
summation program
starts execution
child thread
thread begins
begins execution
thread terminates
method sharing
threads occurs
declared globally
object-oriented language
sharing occurs
passing references
shared object
thread share
sum class
integer object
integer class
parent threads
win32 libraries
wai tforsingledbj
tforsingledbj ect
summation threads
multithreaded programs
duplicate process
calls change
program calls
calls fork
process duplicate
thread invokes
underlying operating
abstract environment
jvm running
many-to-manymodel solaris
to-one model
inany model
model beginning
creating java
entire process-including
calling thread
call exec
thread returns
remaining threads
user presses
threads-each image
stop button
threads loading
target thread
asynchronous cancellation
deferred cancellation
orderly fashion
cancellation occurs
canceled thread
updating data
reclaim system
system-wide resource
signal handling
generated signal
handled examples
synchronous signals
signals include
program performs
process receives
signal asynchronously
asynchronously examples
specific keystrokes
timer expire
asynchronous signal
default signal
signal handler
user-defilced signal
default action
signal handle
signal signals
handling signals
single-threaded programs
delivering signals
options exist
signal applies
applies deliver
process deliver
process assign
specific thread
signal depends
signal generated
thread causing
asynchronous signals
asynchronous signals-such
multithreaded versions
first thread
thread found
standard unix
unix function
int signal
apc facility
thread receives
receives notification
multithreaded environment
thread pools
server nonetheless
potential problems
first issue
system unlimited
unlimited threads
exhaust system
cpu tince
general idea
idea beh_ind
thread pool
process startup
available-and passes
thread completes
free thread
pools offer
existing thread
pool limits
concurrent threads
expected number
concurrent client
sophisticated thread-pool
thread-pool architectures
usage patterns
architectures provide
smaller pool-thereby
pool-thereby consuming
functions related
pool api
thread create
winapi poolfunction
avoid param
function runs
pool executes
queueuserworkitemo function
lpthread_starlroutine function-a
function-a pointer
thread pvoid
pvoid param-the
param-the parameter
ulong flags-flags
flags-flags indicating
manage execution
invoke poolfunction
lightweight process
kamalthcead figure
api include
include utilities
invoke functions
periodic intervals
request completes
java util
util concurrent
concurrent package
pool utility
thread-specific data
data threads
process share
transaction-processing system
unique identifier
thread libraries-including
libraries-including win32
data java
scheduler activations
programs concerns
concerns communication
two-level models
models discussed
systems implementing
model place
intermediate data
lwp-is shown
user-thread library
lwp appears
virtual processor
system schedules
physical processors
thread blocks
lwp blocks
thread attached
run efficiently
cpu-bound application
application running
require multiple
multiple lwps
concurrent blocking
call suppose
file-read requests
requests occur
occur simultaneously
virtual processors
schedule user
upcall handlers
upcall occurs
application thread
kernel makes
application informing
application runs
upcall handler
blocking thread
library informilcg
blocked thread
call handler
1-mblocked thread
application schedules
eligible thread
threads windows
primary api
microsoft operating
section applies
entire family
one-to-one mapping
thread maps
thread belonging
general components
thread include
set representing
user stack
kernel stack
private storage
run-time libraries
dynamic link
link libraries
primary data
ethread-executive thread
thread block
block kthread-kernel
kthread-kernel thread
tee-thread environment
key components
ethread include
thread belongs
thread starts
starts control
kthread ethread
ethread kernel
space figure
kthread includes
synchronization inforn1.ation
kthread exist
access thern
user-space data
thread identifie1
user-mode stack
threadspecific data
linux threads
threads linux
traditional functionality
create threads
term task-rather
thread-when referring
child tasks
flag meaning
meaning clone
file-system information
shared clone
sighand signal
signal handlers
clone files
flags clone_fs
current working
working directory
parent task
task shares
child task
sharing takes
varying level
unique kernel
storing data
signal-handling information
made howevet
task points
flags passed
nptl thread
library nptl
posix-compliant thread
thread model
taking advantage
numa support
start-up cost
traditional linux
support hundreds
multithreading include
include increased
increased responsiveness
scalability issues
cores user-level
kernel-level threads
models relate
relate user
model maps
single kernel
model multiplexes
linux thread
libraries provide
primary thread
win32 threads
threads multithreaded
programs introduce
issues include
include thread
thread cancellation
single-threaded solution
ncultithreaded java
win32 program
prime numbers
number entered
program state
register values
heap memory
stack memory
many-to-many threading
threading rnodel
system discuss
performance implicatiorts
threads allocated
userlevel threads
involves designing
java threading
threading api
concurrent echo
echo clients
current client
client exits
exits modify
server services
separate request
socket-based date
client request
multithreaded solution
multiple user-level
threads achieve
singleprocessor system
system explain
multiple kernel
threads provide
fibonacci numbers
convenient data
thread finishes
finishes execution
sequence generated
techniques described
smmnation function
linux treats
thread depending
solaris-treat processes
threads differently
process contrast
modeling processes
distinct topics-naming
topics-naming service
muliplication project
naming service
service project
host www
www westminstercollege
assignment consists
ling service
net api
inetaddress hostaddress
string ipaddress
client connections
client makes
westminstercollege eduto
server thread
host address
resolve host
host host
telnet session
client responses
telnec localhost
localhost escape
escape character
connection closed
foreign host
telnet act
client application
named nsclient
java nsclient
unknown host
host message
connection project
multiplication project
separate worker
worker thread
involve creating
worker threads
main-or parent-thread
allocate sufficient
sufficient memory
file passing
matrix product
easiest approach
structure appears
passing data
win32 programs
thread passing
class workerthread
workerthread implements
int row
int col
public workerthread
this.b this.c
data pointer
thread sharing
column jto
thread appears
product contained
finish section
libraries win32
thread waits
single child
wai tformultipledbj
tformultipledbj ects
define num_threads
pthread_t workers
pthread code
joining ten
ten threads
flag indicating
timeout duration
handle objects
child threads
simple strategy
pthreads pthread_join
join operation
code depicted
equivalent code
final static
static int
int num_threads
java code
threads threads
long evolution
cheap concurrency
lightweight processes
early examples
thotll system
pilot system
moving threads
major operating
systems implemented
thread performance
support bershad
describe combining
combining threads
rpc engelschall
supporting user-level
optimal thread-pool
thread-pool size
netbsd system_
kernel cooperate
compare windows
solaris threads
symmetric multiprocessor
multiprocessor pinilla
compare java
solaris vahalia
covers threading
unix mcdougall
solaris kernel
kernel russinovich
discuss threading
system family
family bovet
linux handles
handles threading
covers threads
pthreads programming
discuss multithreading
java goetz
concurrent programming
java beveridge
describe multithreading
multiprogrammed operating
basic cpu-scheduling
cpu-scheduling concepts
cpu-scheduling algorithms
introduced threads
kernel-level threads-not
threads-not processes-that
terms process
general scheduling
scheduling concepts
thread-specific ideas
introduce cpu
discuss evaluation
evaluation criteria
process rum1ing
simple computer
sits idle
system takes
load store
store add
add store
store read
file wait
store increment
increment index
index write
burst cpu
cpu burst
burst figure
alternating sequence
bursts process
pattern continues
operating-system function
primary computer
burst cycle
scheduling depends
observed property
execution consists
cpu execution
wait processes
processes alternate
states process
execution begins
final cpu
burst ends
system request
terminate execution
cpu bursts
measured extensively
frequency curve
short cpu
small number
long cpu
burst duration
cpu-burst durations
durations program
process note
fifo queue
priority queue
generally process
control blocks
preemptive scheduling
cpu-scheduling decisions
process switches
running state
numing state
scheduling scheme
nonpreemptive scheduling
scheduling method
subsequent versions
previous versions
system relied
cooperative scheduling
hardware platforms
scheduling incurs
inconsistent state
coordinate access
important kernel
structure chaos
chaos ensues
scheme ensures
kernel structure
kernel-execution model
code affected
accept interrupts
output overwritten
disable interrupts
reenable interrupts
component involved
cpu-scheduling function
process selected
function involves
switching context
mode jumping
proper location
process switch
dispatch latency
substantial difference
criteria include
real system
loaded system
busy executing
short transactions
ten processes
important criterion
turnaround tim.e
periods spent
process spends
queue waiting
queue response
continue computing
previous results
first response
minirnize turnaround
average measure
maximum values
good service
maximum response
timesharing systerns
average response
predictable response
highly variable
variable howeve1
minimize variance
accurate illustration
average waiting
elaborate evaluation
evaluation mechanisms
scheduling deals
first-served scheduling
simplest cpu-scheduling
scheduling algorithm
cpu first
fcfs policy
process enters
fcfs scheduling
negative side
process burst
processes ani
fcfs order
result shown
gantt chart
bar chart
finish times
participating processes
processes arrive
processes cpu
burst times
dynamic situation
situation assume
processes flow
processes wait
process finishes
cpu sits
processes end
convoy effect
big process
effect results
lower cpu
device utilization
shorter processes
first note
fcfs algorithm
regular intervals
extended period
shortest-job-first scheduling
algorithm associates
tie note
shortest-next-cpu-burst algorithm
total length
term sjf
m.ost people
sjf scheduling
minimum average
processes moving
short process
long process
real difficulty
sjf algorithm
cpu request
user specifies
lower value
faster response
time-limit-exceeded error
require resubmission
short-term cpu
short-term scheduling
approximate sjf
predicted cpu
exponential average
measured lengths
previous cpu
nth cpu
predicted value
recent information
t11 stores
past history
relative weight
recent history
current conditions
recent cpu
burst matters
equally weighted
system average
average figure
successive term
choice arises
process arrives
previous process
arrived process
executing process
preemptive sjf
nonpreemptive sjf
shortest-remaining-time-first scheduling
process arrival
times shown
sjf schedule
queue process
priority scheduling
special case
general priority
highest priority
priority equal-priority
equal-priority processes
priority algorithm
versa note
high priority
low priority
priority priorities
fixed range
lowest priority
low numbers
numbers represent
milliseconds priorities
defined priorities
nceasurable quantity
average cpu
computing priorities
external priorities
department sponsoring
politicat factors
factors priority
preemptive priority
nonpreemptive priority
rnajor problem
indefinite blocking
lowpriority processes
waiting indefinitely
loaded computer
steady stream
higher-priority processes
low-priority process
a.m sunday
cornputer systern
unfinished low-priority
low-priority processes
indefinite blockage
aging aging
priorities range
waiting process
initial priority
priority-127 process
priority-0 process
round-robin scheduling
timesharing systems
small unit
circular queue
scheduler picks
cpu voluntarily
quantum expires
runnable process
burst exceeds
processor sharing
processor running
real processor
control data
data corporation
peripheral processors
hardware executes
cycle continues
ten slow
instruction referenced
referenced memory
real processors
scheduling assume
context switches
modern systems
quanta ranging
small fraction
quantum process
quantum context
quantum increases
quantum figure
quantum turnaround
average turnaround
time-quantum size
size increases
processes finish
scheduling degenerates
multilevel queue
queue scheduling
common division
response-time requirements
foreground processes
background processes
algorithm partitions
separate queues
r-.o-c_ e---ss
---------b_a_tc_h_p_r_o_ce_s_s_e_s ______
-------s_tu_d_e_n_t_p_ro_c_e_s_s_es_ _____
_____ _jl
priority figure
scheduling size
process type
foreground queue
background queue
fixed-priority preemptive
absolute priority
processes interactive
interactive processes
interactive editing
editing processes
processes batch
batch processes
processes student
student processes
lower-priority queues
batch queue
editing process
process entered
batch process
foreground-background queue
queue receives
fcfs basis
multilevel feedback
feedback queue
background nature
low scheduling
scheduling overhead
lower-priority queue
scheme leaves
higher-priority queues
higher-priority queue
aging prevents
prevents starvation
queue scheduler
execute processes
process arriving
process entering
burst processes
lower priority
cycles left
feedback queues
higherpriority queue
lowerpriority queue
scheduler makes
general cpu-scheduling
complex algorithm
scheduler requires
select values
system user-level
kernel-level thread
scheduling issues
issues involving
specific examples
contention scope
threads lies
library schedules
process-contention scope
schedules user
physical cpu
system-contention scope
scs scheduling
scheduling takes
system systems
systems usilcg
schedule threads
runnable thread
run user-level
thread priorities
higher-priority thread
equal priority
pthread scheduling
sample postx
postx pthread
posix pthread
pthread api
creation pthreads
pthreads identifies
scope values
pthread_scope_process schedules
schedules threads
pcs scheduling
scheduling pthread_scope_system
pthread_scope_system schedules
pthread_scope_process policy
policy schedules
pthread_scope_system scheduling
scheduling policy
many-to-many systems
mapping threads
one-to-one policy
pthread ipc
getting-and setting-the
setting-the contention
scope policy
int scope
attribute set
pthread_scope_process value
parameter contaiils
current value
functions returns
non-zero value
scheduling api
existing contention
policy note
load sharing
scheduling problem
include pthreadoh
include stdiooh
current scope
scheduling scope
illegal scope
scope valueo
singleprocessor cpu
multiprocessor scheduling
identical-homogeneous-in terms
homogeneous multiprocessors
device attached
private bus
processor processes
n1.ultiprocessor system
scheduling decisions
system activities
activities handled
single processor-the
processor-the master
master server
processors execute
processor accesses
data sharing
common ready
private queue
ready processes
scheduling proceeds
processor examine
common data
support smp
discuss issues
processor affinity
cache memory
specific processor
process populate
successive memory
first processor
high cost
repopulating caches
avoid migration
process rumung
rumting processor
affinity takes
soft affinity
lim.ix -also
-also provide
hard affinity
processors solaris
main-memory architecture
affect processor
affinity issues
issues figure
architecture featuring
featuring non-uniform
faster access
combined cpu
memory boards
memory-placement algorithms
algorithms work
assigned affinity
operating-system textbooks
solid lines
dotted lines
algorithms creating
creating connections
ways aimed
optimizing performance
load balancing
workload balanced
high workloads
processes awaiting
cpu load
balancing attempts
eligible processes
common run
run queue
rmmable process
systems supporting
supporting smp
general approaches
push migration
pull migration
imbalance-evenly distributes
less-busy processors
processors pull
migration occurs
idle processor
processor pulls
waiting task
busy processor
processor push
load-balancing systems
linux scheduler
ule scheduler
freebsd systems
techniql1es linux
linux runs
loadbalancing algorithm
systems engineering
absolute rule
non-idle processor
imbalance exceeds
providing multiple
processor cores
physical chip
architectural state
separate physical
physical processor
processor smp
chip multicore
happen researchers
accesses memory
cache miss
accessing data
memory stall
recent hardware
hardware designs
multithreaded processor
hardware threads
thread stalls
dual-threaded processor
processor core
operating-system perspective
hardware thread
logical processor
software thread
dual-core system
logical processors
compute cycle
stall cycle
cycle thread
system hardware
chccu multithreading
coarse-grained multithreading
thread executes
long-latency event
stall occurs
delay caused
instruction pipeline
instructions fine-grained
multithreading switches
finer level
instruction cycle
architectural design
fine-grained systems
thread switching
small notice
multithreaded multicore
multicore processor
scheduling specifies
core decides
simple roundrobin
roundrobin algorithm
intel itanium
dual-core processor
hvo hardwaremanaged
hardwaremanaged threads
core assigned
dynamic urgency
urgency value
value ranging
lowest urgency
itanium identifies
thread switch
events occurs
thread-switching logic
logic compares
highest urgency
single-cpu system
virtualization software
software presents
virtual cpus
physical cpus
significant variations
virtualization technologies
technologies make
virtualized environments
system creates
system installed
applications running
guest eacb
eacb guest
real-time operation
guest operating-system
operating-system scheduling
time-sharing operating
give users
virtualization system
poor response
response times
users logged
net effect
scheduling layering
individual virtualized
systems receive
time-of-day clocks
dedicated cpus
cpus virtualization
good scheduling-algorithm
scheduling-algorithm efforts
scheduling policies
kernel tlueads
term task
solaris scheduling
scheduling solaris
priority-based thread
fixed priority
default scheduling
scheduling class
time-sharing class
dynamically alters
alters priorities
solaris dispatch
interactive threads
threads slices
inverse relationship
higher priority
good response
good throughput
interactive class
gnome window
dispatch table
classes include
priority levels
table shown
class-dependent priority
interactive classes
higher number
highest tince
tince quantum
quantum expired
priorities lowered
lowered return
table illustrates
waiting thread
processes threads
real-time class
real-time process
guaranteed response
bounded period
processes belong
class solaris
system class
run kernel
paging daemon
system thread
processes rum1ing
fair-share classes
fixed-priority class
priority range
dynamically adjusted
fair-share scheduling
decisions cpu
cpu shares
class includes
scheduler converts
class-specific priorities
global priorities
highest global
global priority
selected thread
thread n.ms
round-robin queue
queue figure
classes relate
priorities notice
servicing interrupts
scheduling windows
scheduler ensures
highest-priority thread
handles scheduling
thread selected
quantum ends
real-time thread
lower-priority thread
preferential access
32-level priority
priority scheme
thread execution
execution priorities
highest lowest
scheduling scheduling
scheduling order
priorities ranging
thread running
scheduling priority
special thread
numeric priorities
api identifies
priority classes
realtime_priority _class
_class higf-lpriority
higf-lpriority _class
_class abovknormalpriority
abovknormalpriority class
class normalpriority
normalpriority class
normal...priority _class
_class idle...priority
idle...priority _class
realtime...priority _class
relative priority
relative priorities
priorities include
time_critical highest
highest above_normal
normal lowest
lowest idle
priority class
top row
left column
nunceric priority
base priority
priority representing
normal relative
base priorities
_normalpriority _class-6
_class-6 idle_priority
typically members
process belongs
idle_priority _class
quantun1 runs
variable-priority class
cpu consumption
compute-bound threads
variablepriority thread
wait operation
dispatcher boosts
boost depends
large increase
thread waiting
devices busy
spare cpu
interacting receives
priority boost
interactive program
good performance
special scheduling
scheduling rule
normalpriority_class windows
foreground process
process moves
scheduling quantum
time-sharing preemption
preemption occurs
linux scheduling
kernel ran
unix scheduling
unix scheduler
adequate support
system grows
constant time-known
increased support
including processor
providing fairness
interactive tasks
priority-based algorithm
separate priority
priority ranges
real-time range
nice value
ranges map
lower values
higher priorities
numeric priority
time-slice length
unlike schedulers
lim1x assigns
assigns higher-priority
higher-priority tasks
lower-priority tasks
tim.e-slice length
runnable task
runnable tasks
processor maintains
priority arrays
active array
expired array
expired tasks
tasks indexed
scheduler chooses
multiprocessor machines
highest-priority task
runqueue structure
versa linux
linux implements
real-time scheduling
real-time tasks
static priorities
array priority
task lists
dynamic priorities
nice values
task determines
longer sleep
sleep times
scheduler favors
favors interactive
shorter sleep
dynamic priority
relative importance
maximizing cpu
maximizing throughput
total execution
selection criteria
evaluation methods
deterministic modeling
major class
analytic evaluation
system workload
method takes
predetermined workload
workload shown
process p11
sjf policy
intermediate value
exact numbers
describing scheduling
providing examples
processing requirements
proved separately
environment described
rninimum waiting
queueing models
static set
simply estimated
mathematical formula
formula describing
arrival-time distribution
average throughput
waiting processes
queues knowing
knowing arrival
arrival rates
service rates
compute utilization
average queue
queue length
average wait
average arrival
arrival rate
steady state
arrival distribution
seconds queueing
queueing analysis
comparing scheduling
fairly limited
complicated algorithms
service distributions
tractable -but
-but unrealistic-ways
independent assumptions
real systems
performance statistics
fcfs performance
sjf performance
cpu schedulers
accurate evaluation
simulations rumung
rumung simulations
simulations involves
system software
software data
structures represent
variable representing
simulator modifies
simulation executes
algorithm performance
random-number generator
generate processes
probability distributions
results define
distribution-driven simulation
successive events
frequency distribution
event occur
trace tapes
trace tape
actual events
simulation trace
tapes provide
real inputs
accurate results
inputs simulations
requiring hours
detailed simulation
large amounts
limited accuracy
conlpletely accurate
approach puts
actual algorithm
operating conditions
required data
changing operating
processes executed
work done
problems change
short processes
larger processes
smaller processes
noninteractive processes
researchers designed
1-second interval
programmer modified
arbitrary character
system gave
terminal output
completely meaningless
flexible scheduling
system managers
specific application
high-end graphical
graphical applications
system manager
system configuration
dispadmin command
classes described
improved performance
general situations
situations cpu
selected process
long processes
processes shortestjob
shortest average
implementing sjf
highest-priority process
starvation aging
prevent starvation
starvation round-robin
scheduling allocates
priority algorithms
nonpreemptive multilevel
queue algorithms
common model
model includes
foreground interactive
interactive queue
background batch
scheduling multilevel
contemporary computer
support multiple
additional issues
scheduling include
include processor
multicore processing
virtualization systems
systems operating
supporting threads
threads-not processes-for
processes-for execution
systems schedule
priority-based scheduling
including support
real-time threads
linux process
real-time support
typically favor
algorithms demands
analytic methods
mathematical analysis
algorithm simulation
simulation methods
methods determine
determine performance
representative sample
resulting performance
reliable technique
real-world environment
cpu-bound programs
algorithm determines
scheduled processes
systenc running
running ten
cpu-bound task
task assume
tasks issue
cpu computing
operation takes
context-switching overhead
long-running tasks
tasks describe
round-robin scheduler
time-quantum sizes
multilevel queueing
queueing system
system implementing
implementing multilevel
user employ
time-sharing threads
scheduler assign
algorithms discriminate
average formula
shortest job
recent past
algorithm favor
realtimeyriority _class
highyriority _class
major advantages
duplicate pointers
gantt charts
smaller priority
priority number
number implies
waiting ti1r1e
algorithms results
scheduler enforces
priority numbers
scheduler recalculates
recalculates process
process priorities
cpu usage
usage refers
value indicating
last recalculated
recalculated assume
scheduler raise
criteria conflict
maximum waiting
algorithm based
changing priorities
larger priority
made process
run process
left idle
waiting durirtg
future-knowledge scheduling
scheduling feedback
ctss system
scheduling system
scheduling techniques
account information
execution times
previous runs
fair-share schedulers
unix freebsd
covers scheduling
lim.ix details
discuss scheduling
windows internals
describe scheduling
pthreads systems
systems siddha
scheduling challenges
systems part
system cooperating
logical address
data inconsistency
data consistency
hardware solutions
atomic transaction
describe mechanisms
ensure atomicity
system consisting
sequential processes
sharing data
original solution
solution allowed
variable counter
consumer routines
statements counter
counter concurrently
consumer execute
execute separately
statement counter
typical machine
counter register1
local cpu
statement register2
register2 counter
counter register2
physical register
interrupt handler
sequential execution
lower-level statements
statements presented
arbitrary order
high-level statement
producer execute
execute register1
execute register2
execute counter
incorrect state
state counter
processes access
execution depends
access takes
race condition
described occur
system manipulate
manipulate resources
increased emphasis
data-are rmming
major portion
common variables
important feature
critical section
critical sections
request permission
remaining code
entry section
exit section
remainder section
important segments
remainder sections
selection carmot
bounded waiting
nonzero speed
kernel-mode processes
race conditions
separate updates
conditions include
include structures
maintaining memory
maintaining process
process lists
kernel developers
preemptive kernels
nonpreemptive kernels
preemptive kernel
nonpreemptive kernel
kernel-mode process
exits kernel
yields control
shared kernel
smp architectures
long period
designing kernel
systems manage
manage preemption
classic software-based
software-based solution
computer architectures
architectures perform
basic machine-language
machine-language instructions
architectures howeve1
good algorithmic
algorithmic description
complexities involved
bomcded waiting
waiting peterson
alternate execution
solution requires
int turn
boolean flag
variable turn
flag array
structures complete
algorithm shown
sets flag
sets turn
eventual value
turn determines
section first
progress requirement
bounded-waiting requirement
prove property
processes -say
additional statement
prove properties
condition flag
set flag
reset flag
resets flag
set turn
software-based solutions
problem requires
simple tool-a
tool-a lock
lock race
critical regions
techniques ranging
softwarebased apis
simple hardware
hardware instructions
problem hardware
hardware features
improve system
system efficiency
uniprocessor environment
prevent interrupts
current sequence
unexpected modifications
shared variable
environment disabling
disabling interrupts
boolean testandset
boolean target
section lock
mutual-exclusion implementation
passing delays
delays entry
efficiency decreases
unin.terruptible unit
simple manner
specific instruction
specific machine
main concepts
important characteristic
machine supports
boolean variable
variable lock
global boolean
local boolean
variable key
algorithms satisfy
mutual-exclusion requirement
critical-section requirements
void swap
boolean temp
instruction boolean
boolean waiting
boolean lock
mutualexclusion requirement
variable waiting
bounded-waiting mutual
arguments presented
process exiting
sets lock
sets waiting
array waiting
cyclic ordering
process waiting
hardware designers
atomic testandset
trivial task
hardware-based solutions
problem presented
synchronization tool
standard atomic
atomic operations
dutch proberen
no-op s
process modifies
semaphore value
usage operating
binary semaphores
counting semaphore
unrestricted domain
binary semaphore
mutex locks
provide mutual
mljltiple processes
counting semaphores
control access
resource consisting
finite number
resource performs
process releases
synchronization problems
numing processes
common semaphore
semaphore synch
statements wait
main disadvantage
semaphore definition
thatit requires
entry code
continual looping
real multiprogramming
section signal
single cpu
ncany processes
processes busy
busy waiting
waiting wastes
wastes cpu
process spins
short times
semaphore operations
block operation
operation places
ready process
implement semaphores
struct process
process list
processes list
operation removes
semaphore operation
operation suspends
operation resumes
blocked process
basic system
calls note
semaphore values
classical definition
fact results
link field
rernove processes
tail pointers
queueing strategy
strategy correct
correct usage
semaphore lists
execute wait
single-processor environment
cpu exists
inhibiting interrupts
scheme works
regain control
diminish performance
alternative locking
spinlocks-to ensure
performed atomically
eliminated busy
limited busy
opera times
waiting occurs
situation exists
casesf busy
extremely inefficient
executes wait
operations cam1ot
deadlock state
resource acquisition
deadlock problem
problem related
semaphore indefinite
scheduling challenge
challenge arises
higher-priority process
modify kernel
lower-priority process-or
lower-priority processes
lower-priority process
priorities follow
requires resource
preempting process
mars pathfinder
pathfinder priority
scheduling inconvenience
real-time systems-see
systems-see chapter
system failure
mars pathfinde1
nasa space
space probe
sojourner rove1
conduct experiments
sojourner began
experience frequent
frequent computer
computer resets
reset reinitialized
including communications
high-priority task
multiple medium-priority
medium-priority tasks
bcdist task
bc_sched task
typical case
enable priority
priority inheritance
software team
team lead
lower priority-process
priority-process m-has
m-has affected
relinquish resource
systems solve
2tic x,u
accessing resources
resources needed
process inherit
priorities revert
original values
priority-inheritance protocol
preventing process
inherited priority
hand assume
original priority
large class
concurrency-control problems
nextp wait
add nextp
process testing
proposed synchronization
synchronization scheme
bounded-buffer problem
synchronization primitives
related programming
programming project
mutex semaphore
buffer pool
full semaphores
semaphores comct
full buffers
semaphore empty
producer producing
consumer producing
empty buffers
readers-writers problem
readers access
adverse effects
exclusive access
shared database
synchronization problem
synchronization primitive
involving priorities
first readers-writers
obtained permission
readerswriters problem
writer performs
start reading
first case
references describing
starvation-free solutions
reader processes
semaphore mutex
int readcount
semaphores mutex
semaphore wrt
writer processes
variable readcount
wrt functions
mutual-exclusion semaphore
last reader
writer process
reader process
writer executes
waiting readers
single waiting
waiting writer
provide locks
systems acquiring
reader-writer lock
write access
read mode
process wishing
write mode
mode multiple
writers reader-writer
reader-writer locks
readerwriter locks
mutual-exclusion locks
increased concurrency
allowing multiple
multiple readers
readers compensates
readerwriter lock
dining-philosophers problem
lives thinking
philosophers share
circular table
table surrounded
performed wait
dining philosophers
single chopsticks
philosopher thinks
right neighbors
cam1ot pick
htmgry philosopher
starts thinking
classic synchronization
practical importance
computer scientists
scientists dislike
dislike philosophers
simple representation
starvation-free mam1er
simple solution
executing await
solution guarantees
deadlock suppose
left chopstick
right chopstick
delayed forever
asymmetric solution
odd philosopher
philosopher picks
ensures freedom
deadlocks note
satisfactory solution
deadlock-free solution
semaphores provide
effective mechanism
timing errors
errors happen
timing problem
problem happened
counter value
value appeared
semaphore solution
variable mutex
sections simultaneously
result note
honest programming
programming error
uncooperative programmer
process interchanges
section wait
sections note
reproducible suppose
process replaces
occur suppose
process omits
examples illustrate
similar problems
synchronization models
language constructs
fundamental high-level
high-level synchronization
synchronization construct-the
construct-the monitor
monitor type
abstract data
adt encapsulates
private data
public methods
programmer-defined operations
values define
procedure defined
variables declared
formal parameters
local procedures
monitor rrwnitor
variable declarations
declarations procedure
initialization code
monitor construct
construct ensures
synchronization constraint
synchronization schemes
additional synchronization
synchronization mechanisms
condition construct
tailor-made synchronization
type condition
process invoking
process invokes
suspended process
figure shared
data operations
operations initialization
schematic view
signaling process
monitor note
condition signal
reasonable arguments
signal-and-continue method
logical condition
longer hold
language concurrent
concurrent pascal
signal operation
immediately resumed
including concurrent
concurrency support
similar mechanism
code figure
condition variables
dining-philosophers solution
illustrate monitor
monitor concepts
solution imposes
variable state
declare condition
condition sel
monitor diningphilosophers
operation pickup
act nlay
nlay result
philosopher process
philosopher invokes
void pickup
void putdown
void test
monitor solution
dining-philosopher problem
operations pickup
solution ensures
nwnitor mechanism
resumed process
additional sernaphore
signaling processes
variable next_count
processes suspended
external procedure
semaphore x_sem
variable x_count
significant improvement
process-resumption order
operation monitor
monitor resourceallocator
boolean busy
void acquire
void release
single resource
suspended processes
fcfs ordering
resumed first
simple scheduling
form x.wait
integer expression
smallest priority
resourceallocator monitor
monitor shown
competing processes
monitor allocates
shortest time-allocation
time-allocation request
type resourceallocator
monitor concept
preceding access
access sequence
first gaining
gaining access
access permission
process ntight
granted access
first releasing
monitor constructs
higher-level programmer-defined
current problem
resourceaccess operations
built-in monitor-scheduling
monitor-scheduling algorithm
processes observe
managed resource
correct sequence
uncooperative process
mutual-exclusion gateway
gateway provided
access protocols
time-dependent errors
static system
dynamic system
access-control problem
additional mechanisms
mechanisms provided
good examples
java monitors
monitors java
monitor-like concurrency
concurrency mechanisn1
thread synchronization
single lock
synchronized method
synchronized keyword
method definition
class simpleclass
public synchronized
synchronized void
void safemethod
method blocks
entry set
set represents
threads waiting
thread exits
lock java
monitor release
api support
concurrency mechanisms
package pthreads
synchronization methods
differing systems
significant ways
adaptive mutexes
turnstiles solaris
solaris implements
implements semaphores
adaptive mlltexes
protects access
critical data
data item
adaptive mutex
mutex starts
standard semaphore
semaphore implemented
thread spins
thread holding
run state
lock held
sleeping thread
lock solaris
adaptive-mutex method
short code
code segments
hundred instructions
code segment
spin-waiting method
exceedingly inefficient
longer code
desired lock
thread issues
thread frees
extra cost
instructions waiting
spinlock reader-writer
protect data
read-only manner
serialize access
data reader-writer
long sections
code solaris
adaptive n1.utex
queue structure
threads blocked
synchronized object
kernel selects
thread blocked
lock requires
separate turnstile
initial thread
free turnstiles
turnstiles maintained
priorityinheritance protocol
locking mechanisms
crucial implementation
implementation difference
protocol kernel-locking
kernel-locking routines
kernel priorityinheritance
priorityinheritance methods
user-level thread-locking
thread-locking mechanisms
optimize solaris
solaris performance
locking methods
crucial kernel
kernel functions
great performance
performance gains
multithreaded kernel
real-time applications
kernel accesses
global resource
uniprocessor system
masks interrupts
global resources
kernel ensures
dispatcher object
threads synchronize
including mutexes
system protects
gain ownership
release ownership
finished semaphores
semaphores behave
desired condition
condition occurs
signaled state
nonsignaled state
state transitions
mutex lock
lock dispatcher
relationship exists
nonsignaled dispatcher
object moves
kernel checks
owner thread
thread releases
releases mutex
lock thread
thread acquires
acquires mutex
lock figure
mutex dispatcher
kernel moves
thread -or
resume executing
queue depends
mutex object
event object
dispatcher objects
thread states
mutex moves
readerwriter versions
smp machines
fundamental locking
locking mechanism
short durations
single-processor machines
disabling kernel
kernel preemption
kernel disables
disables kernel
enables kernel
disable kernel
acquirespin lock
enable kernel
preemption release
release spin
spin lock
lock linux
interesting approach
simple system
-for disabling
enabling kernel
kernel-mode task
task irl
thread-info structure
outstanding calls
short duration
longer period
read-write locks
kernel mutex
locks represent
fundamental synchronization
synchronization technique
section condition
pthreads behave
locks behave
implement pthreads
provide semaphores
pthreads standard
posix sem
sem extension
include spinlocks
pthreads mutex
sections ensures
uninterruptible unit
unknown order
application domains
section forms
single logical
logical unit
funds transfer
debit occur
occurs consistency
database-systems techniques
advanced techniques
database research
hoc techniques
manage files
formal database
database methods
database techniques
general issue
transaction atomicity
logical function
processing transactions
program unit
write operations
operations terminated
commit operation
abort operation
operation signifies
increased pressure
increased risk
alternative strategy
strategy fordeveloping
thread-safe concurrent
concurrent applications
read-write operations
memory transaction
rolled back
features added
function update
modifies shared
semaphores involves
including deadlocks
threads increases
traditional locking
traditional methods
transactional memoi
guaranteeing atomicity
atomic blocks
concurrent read
read access
number ofthreads
hardware software
imp lee
lee ments
memory exclusivelyin
exclusivelyin software
nospecial hardware
needed stm
stm works
inserting instrumentation
instrumentation code
code inside
inside transaction
transaction blocks
specific lowlevellockingis
lowlevellockingis required
required hardware
small htm
coherency protocols
resolve conflicts
conflicts involving
separate processors
processors caches
caches htm
htm requires
special code
code instmmentation
widespread implementation
multi core
core systems
significant amolmt
amolmt ofresearch
ware vendors
microsystems ended
normal execution
logical error
terminated transaction
aborted transaction
executed atomically
transaction started
started executing
relative speed
failure volatile
storage information
information residing
survive system
crashes examples
cache merrwry
merrwry access
survives system
tapes disks
becm1se disk
tape devices
physical motion
access data
data stable
stable storage
replicate information
storage caches
independent failure
failure modes
controlled manner
ensuring transaction
failures result
log-based recovery
information describing
modifications made
log record
record describes
single operation
transaction write
operation data
special log
log records
records exist
significant events
transaction processing
items accessed
actual update
storage note
penalty inherent
physical writes
logical write
write requested
log recording
fast failure
failure recovery
worth tl1e
tl1e price
recovery algorithm
data updated
values redo
log note
redo operations
multiple executions
correct behavior
failure occurs
recovery process
executing undo
updated data
starts record
record transaction
entire log
major drawbacks
searching process
data modifications
write-ahead log
performs checkpoints
storage output
modified data
record checkpoint
checkpoint record
recovery procedure
commits record
record appears
redo operation
previous recovery
recovery routine
routine examines
recent transaction
recent checkpoint
log backward
first checkpoint
start record
undo operations
transactions set
recovery operations
tic commits
commits appears
execute redo
execute undo
multiple transactions
active simultaneously
arbih ary
ary order
transactions share
transaction starts
first action
execute wai
executing transactions
maintaining serializability
ensure serializability
execution sequence
instruction steps
chronological order
right colunm
serial schedule
schedule consists
instructions belonging
valid serial
serial schedules
atomic execution
participating transactions
resulting schedule
longer serial
incorrect execution
consecutive operations
nonserial schedule
operations access
serializable schedule
swapping idea
equivalent schedule
initial system
schedules produce
state continuing
swapping nonconflicting
nonconflicting operations
final result
result implies
final state
conflict serializable
locking protocol
transaction follow
shared-mode lock
exclusive-mode lock
transaction request
exclusive lock
shared lock
exclusive mode
readers-writers algorithm
earlier point
last access
ensures serializability
protocol requires
transaction issue
issue lock
unlock requests
growing phase
obtain locks
locks shrinking
shrinking phase
release locks
transaction acquires
acquires locks
transaction releases
lock requests
two-phase locking
protocol ensures
ensures conflict
conflict serializability
ensure freedom
conflict-serializable schedules
timestamp-based protocols
locking protocols
protocols described
conflicting transactions
serializability order
ordering scheme
fixed timestamp
assigned timestamp
simple methods
system clock
transaction enters
logical counter
transactions determine
schedule produced
timestamp values
largest timestamp
executed wri
timestamp ordering
ordering protocol
conflicting read
timestamp order
protocol operates
issues read
read operation
issues wri
obsolete value
includes transactions
timestamp protocol
protocol howeve1
freedom fron1
fron1 deadlocl
semaphores overcome
obstacle semaphores
problems monitors
monitors provide
synchronization mechanism
sharing abstract
data types
monitor procedure
continue operating
linux provide
system crash
crash occurs
checkpoint scheme
transactions overlaps
concurrency-control scheme
concurrency-control schemes
schemes ensure
ordering schemes
correct software
software sohjtion
section turn
algorithm satisfies
implementing synchronization
software solution
lower bound
enum pstate
pstate flag
initial value
alarm clock
calling program
tirne units
real hardware
hardware clock
procedure hclc
turn break
previous exercise
awkward programming
resource-manager code
function suspends
invoke decrease_count
calling decrease_count
computed values
thread access
terminate explain
exercise implement
modified solution
clock explain
open coru1.ections
socket com1.ections
incoming connection
existing connection
released explain
concurrent connections
multiprocessor environments
minimal busy
single construct
construct await
general boolean
boolean expression
await statement
monitors differ
operation defined
storage differ
user-level programs
unique priority
number write
identical line
line printers
resource type
managed processes
commercial software
packages provide
run concurrently
license count
existing license
license holder
holder terminates
program segment
define max_resources
int available_resources
decrease available_resources
count resources
int decrease_count
int count
available_resources count
increase available_resources
int increase_count
preceding program
segment produces
data involved
semaphoref fix
calling process
cigarette-smokers problem
smoker processes
agent process
tobaccof paperf
infinite supply
agent places
cycle repeats
repeats write
java synchronization
lightweight synchronization
locks favor
order waiting
waiting threads
fifo policy
slim reader-writer
threads ordered
queue explain
process transactions
-back transaction
transaction b-ut
rolled-back transaction
problem propose
causing starvation
condition inside
preceding exercise
exercise differ
term busy
log-based systems
checkpoint mechanism
performed describe
checkpoints affects
disk crash
bounded-buffer monitor
strict mutual
monitor makes
small portions
larger portions
banking system
bank account
account assume
shared bank
account exists
husband calls
wife calls
calls deposit
last statement
procedure suggest
implementation described
sleeping-barber problem
barbershop consists
waiting room
barber roorn
barber chair
customer enters
customer leaves
customer sits
free chairs
customer wakes
barber write
semaphore-based solution
programming solution
solution presented
full slots
actual insertion
standard counting
represent mutex
separate threads-will
threads-will move
move items
mutex structures
fixed-size array
type buffer_i
buffer_i tern
tern objects
int buffer_item
insert_i tern
remove_i tern
consumer threads
skeleton outlining
functions appears
include buffer.h
int insert_item
buffer_item item
buffer return
int remove_item
buffer placing
item return
skeleton program
algorithms outlined
initialization function
mutual-exclusion object
object mutex
separate producer
producer threads
buffer.h int
line arguments
arguments argv
initialize buffer
create producer
producer thread
create consumer
consumer thread
random period
random integer
buffer random
random numbers
produces random
random integers
threads appears
cover details
api pthreads
pthreads thread
creation creating
specific instructions
buffer.h void
void producer
void pararn
random number
report error
producer produced
void consumer
consumer consumed
pthread.h pthread_mutex_t
pthread_mutex_t mutex
code sample
sample pthreads
sample depicted
section pthreads
pthread_mutex_t data
callil1.g thread
owner invokes
invokes pthread_mutex_unlock
mutex ftmctions
ftmctions return
code pthreads
pthreads semaphores
semaphores pthreads
unnamed semaphores
illush ates
include semaphore.h
semaphore.h sem_t
sem_t sem
sem_t mutex
nonzero value
classical wait
operations pthreads
pthreads names
operations sem_wai
section win32
win32 details
instructions win32
win32 mutex
locks mutex
windows.h handle
handle mutex
parameter refers
security attribute
initial owner
lock passing
thread creating
returns null
signaled object
signaled mutex
code demonstrates
lock created
parameter value
value infinite
infinite amount
leas emu
win32 semaphores
semaphores semaphores
signaling mechanism
locks semaphores
handle sem
last parameters
parameters identify
maximum value
null semaphores
semaphore sem
sem created
previous value
increase sem
return nonzero
mutual-exclusion problem
classic paper
-the first
first correct
two-process mutual-exclusion
dutch mathematician
simpler solution
first solution
upper bound
section knuth
first algorithm
bakery algorithm
hardware-solution algorithm
semaphore concept
problems parnas
arguments kosaraju
operations lipton
classic process-coordination
process-coordination problems
boundedbuffer problem
concurrent reading
critical-region concept
complete description
automatic signalil1.g
signalil1.g experience
experience obtained
inversion problem
lockil1.g primitives
shared objects
kernel details
log scheme
timestampbased concurrency-control
timestamp-based concurrency-control
concurrency-control algorithms
multiprogramming environment
process requests
requests resources
change state
law passed
kansas legislature
20th century
trains approach
full stop
describe methods
identify programs
deadlock-prevention facilities
deadlock-free programs
programs deadlock
current trends
larger numbers
resources withirt
long-lived file
database servers
prevent sets
avoiding deadlocks
identical instances
instances memory
resource types
type cpu
type printer
type classes
defined properly
resource class
printer prints
ninth floor
separate resource
resource classes
designated task
resources requested
total number
normal mode
requesting process
calls request
kernelmanaged resource
system checks
system table
table records
deadlocked state
tape drives
ipc facilities
facilities discussed
drives suppose
processes holds
deadlock involving
type deadlocks
dvd drive
drive suppose
deadlock occurs
problem multithreaded
good candidates
shared resources
finish executing
characterize deadlocks
deadlock situation
conditions hold
nonsharable mode
multithreaded pthread
function initializes
unlocked mutex
mutex mutex
thread attempts
locked mutex
lock invokes
pthread....mutex_t second_nmtex
locks thread_one
functions do_work_one
thread_one runs
void do_work_one
thread_one attempts
thread_two attempts
first_mutex deadlock
thread_one acquires
first __mutex
aacquites second__mutex
second__mutex note
second_ mutex
attemptsto acquire
circumstances process
released hold
additional resources
preemption resources
process holding
task circular
circular wait
resource held
circular-wait condition
condition implies
hold-and-wait condition
completely independent
condition separately
resource-allocation graph
graph deadlocks
directed graph
graph consists
vertices vis
vis partitioned
set consisting
directed edge
rectangle note
request edge
edge points
assignment edge
graph shown
rlf p2
r3f rl
p2f r2
resource instances
cycle implies
cycle involves
single instance
process involved
sufficient condition
graph depicted
resource instance
minimal cycles
cycles exist
deadlock processes
deadlocked process
release resource
deadlock observe
problem figure
avoid deadlocks
problem altogether
application developer
handle deadlocks
detailed algorithms
basic approaches
entire spectrum
resource-allocation problems
optimal approach
deadlock-avoidance scheme
methods prevent
prevent deadlocks
additional knowledge
current request
future requests
deadlockavoidance algorithm
undetected deadlock
viable approach
mentioned earlier
deadlocks occur
recovery methods
frozen state
nonpreemptive scheduler
returning control
manual recovery
deadlock recovery
conditions separately
mutual-exclusion condition
nonsharable resources
sharable resources
deadlock read-only
read-only files
sharable resource
processes attempt
read-only file
simultaneous access
intrinsically nonsharable
calls requesting
requesting resources
process precede
alternative protocol
request resources
copies data
disk file
entire execution
main disadvantages
popular resources
implicitly released
preempted resources
desired resources
final condition
total ordering
increasing order
unique integer
one-to-one hmction
natural numbers
includes tape
tape drive
type -say
request instances
function defined
process requesting
single request
wait exists
processes involved
resource r11
r11 held
holding resource
requesting resource
condition means
application program
lock ordering
prevent deadlock
normal order
proper order
lock-order verifier
bsd versions
witness witness
lock orders
second_mutex wih1ess
wih1ess records
witness generates
warning message
system console
guarantee deadlock
transfers funds
void transaction
double amount
semaphore lock1
lock1 getlock
trans action
invoke transaction
situation deadlock-prevention
deadlock-prevention algorithms
restraints ensure
side effects
preventing deadlocks
low device
reduced system
system throughput
alternative method
complete sequence
future deadlock
request requires
approach differ
information required
model requires
process declare
priori information
algorithm defines
deadlock-avoidance approach
deadlock-avoidance algorithm
resource-allocation state
circularwait condition
allocated resources
maximum demands
deadlock-avoidance algorithms
safe state
allocate resources
safe sequence
current allocation
allocation state
resource requests
resources held
needed resources
sequence exists
unsafe state
unsafe states
avoid unsafe
prevent processes
processes controls
controls unsafe
states figure
state spaces
twelve magnetic
ten tape
free tape
safety condition
condition process
finally process
twelve tape
state suppose
additional tape
define avoidance
avoidance algorithms
allocation leaves
resource-allocation-graph algorithm
resource-allocation system
graph defined
assignment edges
claim edge
request resource
edge resembles
dashed line
requests resource
starts executing
claim edges
cycle-detection algorithm
graph requires
cycle exists
occur figure
resourceallocation system
multiple instances
graph scheme
structures encode
matrix defines
maximum demand
remaining resource
task note
equals max
structures vary
matrices allocation
vector allocation
safety algorithm
initialize work
resource-request algorithm
safely granted
request vector
maximum claim
system pretend
requested resources
available request
resulting resource-allocation
ten instances
instances suppose
allocation max
abc abc
sequence plt
safety criteria
criteria suppose
additional instance
safety requirement
resulting state
programming exercise
detection-and-recovery scheme
run-time costs
detection algorithm
potential losses
deadlockdetection algorithm
wait-for graph
resource nodes
graph implies
exists iil
resourceallocation graph
deadlock exists
detect deadlocks
algorithm employs
time-varying data
type allocation
allocation ann
graph request
simplify notation
algorithm described
allocation sequence
completed compare
optimistic attitude
deadlock-detection algorithm
allocation request
additional request
request matrix
request abc
detection-algorithm usage
resources allocated
deadlocked processes
deadlock cycle
grow deadlocks
final request
deadlocked set
resource graph
cycle completed
recent request
identifiable process
resource request
considerable overhead
expensive alternative
utilization drops
cripples system
arbitrary points
processes caused
operator deal
deadlock manually
system recover
deadlock automatically
eliminate deadlocks
system reclaims
terminated processes
processes abort
great expense
partial computations
method incurs
deadlock-detection algorithnc
algorithnc rnust
printing data
correct state
partial termination
termination method
minimum cost
term minimum
resource preemption
process termil
termil ation
minimize cost
cost cost
cost factors
execution rollback
needed resource
simplest solution
total rollback
running processes
processes starvation
victim selection
starvation situation
practical system
common solution
cost factor
state occurs
principal methods
recover ignore
utilize system
maximunl number
preempting resources
selects victims
task researchers
single-lane bridge
bridge connects
vermont villages
north tunbridge
south tunbridge
tunbridge farmers
neighboring town
southbound farmer
vermont farmers
prevents deadlock
northbound farmers
farmers prevent
prevent southbound
southbound farmers
resources show
deadlock free
traffic deadlock
deadlock depicted
deadlock hold
simple rule
real computer
long periods
resources break
resources added
increase max
rnore resources
decrease max
process decides
general banker
multiple-resource-type banker
sil1.gle-resource-type scheme
type individually
resource-allocation policy
policy requests
requestmg process
allocation vector
deadlock occur
blocking occur
occur explain
higherorder resource
threads attempt
include mutexes
sixth object
synchronization lock
circular-wait scheme
deadlock-avoidance schemes
runtime overheads
abcd abcd
scheme deadlocks
jobs terminated
terminated tend
systems programmer
average execution
percent idle
diningphilosophers problem
philosophers obtain
setting discuss
optimistic assumption
assumption made
philosopher assume
causing deadlock
process explain
preceding question
question assume
philosopher requires
eat resource
simple rules
function fix
algorithm discussed
release resources
safe access
project entitled
influential contributors
deadlock area
area holt
first person
allocation-graph model
chapter starvation
recent study
prevention algorithms
resource-ordering scheme
multiple resource
kernel handle
handle deadlock
deadlock solutions
witness lock-order
main purpose
memory-management schemes
schemes exist
situation selection
system depends
algorithms require
require hardware
memorymanagement algorithms
primitive bare-machine
bare-machine approach
segmentation strategies
disadvantages selection
recent designs
detailed description
organizing memory
including paging
pure segmentation
memory consists
cpu fetches
fetches instructions
additional loading
mernory unit
ignore hozu
program generates
coverage includes
hardware issues
symbolic memory
actual physical
physical addresses
linking code
shared libraries
hardware main
registers built
disk addresses
direct-access storage
cpu clock
decode instructions
perform simple
simple operations
clock tick
memory bus
bus completing
data required
fast memory
process base
limit process
limit register
register define
speed differential
protect user
separate memory
legal addresses
base holds
smallest legal
legal physical
base register
register holds
legally access
cpu hardware
hardware compare
address generated
access operating-system
operating-system memory
memory results
fatal error
scheme prevents
special privileged
prevents user
unrestricted access
load users
system monitor-addressing
monitor-addressing error
error memory
hardware address
address protection
modify parameters
address binding
program resides
binary executable
process depending
execution form
normal procedure
input queue
accesses instructions
first address
approach affects
optional-before bein.g
steps addresses
source program
symbolic addresses
relocatable addresses
lin.kage editor
turn bind
generated compiler
compiler code
starting location
ms-dos .com-format
.com-format programs
final binding
changed value
value execution
multistep processing
logical versus
physical address
load-time address-binding
address-binding methods
methods generate
identical logical
execution-time addressbinding
addressbinding scheme
scheme results
virtual address
logical addresses
execution-time address-binding
address-binding scheme
address spaces
spaces differ
run-time mapping
hardware device
dynamic relocation
relocation register
register sections
simple mmu
mmu scheme
base-register scheme
scheme described
address location
system running
relocation registers
real physical
indirect load
program deals
memory-mapping hardware
hardware converts
execution-time binding
final location
base valuer
user generates
proper memory
dynamic loading
entire program
memory-space utilization
relocatable load
load format
main program
calling routine
relocatable linking
linking loader
desired routine
address tables
loaded routine
unused routine
occurring cases
error routines
total program
program size
special support
method operating
providing library
library routines
dynamic linking
libraries figure
system language
language libraries
object module
binary program
program image
language subroutine
subroutine libraries
language library
routines referenced
executable image
requirement wastes
libraryroutine reference
memory-resident library
library routine
needed routine
program loads
stub replaces
library execute
library code
library updates
bug fixes
incompatible versions
version information
library version
programs linked
older library
continued execution
round-robin cpu-scheduling
swap processes
reasonable amounts
swapping policy
store main
occupied previously
swapping requires
fast disk
accommodate copies
memory images
direct access
scheduler decides
dispatcher checks
memory region
dispatcher swaps
desired process
reloads registers
swapping system
fairly high
standard hard
hard disk
transfer rate
actual transfer
memory takes
seconds assuming
average latency
total swap
milliseconds notice
major part
total transfer
memory swapped
resident operating
system taking
seconds required
reducing swap
system informed
dynamic memory
issue system
request memory
release memory
changing memory
completely idle
user memory
swapped assume
out process
main solutions
operating-system buffers
buffers transfers
process memory
head seeks
swap space
standard swapping
reasonable memory-management
memory-management solution
solution modified
modified versions
unix swapping
threshold amount
memory swapping
reduced memory
advanced memory-management
memory-management methods-ran
methods-ran multiple
large processes
modified version
supports concurrent
insufficient main
full swapping
swapped-out process
process remains
user selects
run subsequent
advanced mmu
mmu features
main menlory
section explains
high memory
major factor
factor affecting
single contiguous
contiguous section
memory mapping
discussing memory
register contaitls
smallest physical
mmu maps
mapped address
dispatcher loads
correct values
relocation-register scheme
change dynamically
buffer space
transient operating-system
simplest methods
divide memory
addressing error
error figure
supportfor relocation
free partition
method described
fixed-partition scheme
batch environments
ideas presented
table indicating
large block
allocated space
block sizes
algorithm memory
processes untit
smaller memory
memory blocks
sizes scattered
system searches
arriving process
adjacent holes
larger hole
recombined memory
free hole
first fit
fit allocate
first hole
previous first-fit
first-fit search
search ended
smallest hole
entire list
strategy produces
smallest leftover
leftover hole
hole worst
worst fit
largest hole
largest leftover
smaller leftover
best-fit approach
approach simulations
storage utilization
generally faster
best-fit strategies
allocation suffer
external fragmentation
fragmentation exists
total memory
small holes
fragmentation problem
small pieces
big free
free block
best-fit strategy
problem depending
total amount
memory storage
average process
process size
statistical analysis
allocated blocks
memory fragmentation
multiple-partition allocation
allocation scheme
bytes suppose
requested block
general approach
fixed-sized blocks
units based
block size
memory allocated
requested memory
internal memory
free nlemory
block compaction
relocation requires
base address
simplest compaction
compaction algorithm
holes move
large hole
external-fragmentation problem
complementary techniques
techniques achieve
noncontiguous paging
paging avoids
considerable problem
fitting memory
memory chunks
varying sizes
backin.g store
problem arises
code fragments
fragmentation problems
problems discussed
earlier methods
address foooo
table figure
paging hardware
64-bit microprocessors
basic method
implementing paging
paging involves
involves breaking
logical memory
memory frames
san1.e size
page number
page offset
paging model
page size
frame size
size makes
addressing units
address designate
low-order bits
bits designate
table frame
frame number
number page
table logical
32-byte memory
4-byte pages
paging scheme
free frame
internal fragmentation
fragmentation notice
page boundaries
last frame
frame allocated
completely full
entire frame
one-half page
consideration suggests
small page
page sizes
page-table entry
pages increases
amount data
data sets
larger today
larger page
multiple page
pages researchers
developing support
variable on-the-fly
on-the-fly page
32-bit entry
physical page
page frames
4-byte entries
first page
loaded injo
allocated frames
important aspect
clear separation
program views
views memory
single space
address-translation hardware
system notice
addressing memory
table includes
process owns
allocation details
physical memory-which
memory-which frames
total frames
frame table
page frame
free-frame list
new-process page
free frames
processes operate
user makes
address manually
cpu dispatcher
hardware page
cpu paging
storing page
user registers
correct hardware
page-table values
stored user
user page
hardware implementation
simplest case
high-speed logic
paging-address translation
translation efficient
paging map
major consideration
dispatcher reloads
registers instructions
page-table registers
memory map
address consists
fast registers
contemporary computers
table changing
changing page
tables requires
access location
first index
ptbr offset
number fori
task requires
actual address
desired place
standard solution
fastlookup hardware
hardware cache
high-speed memory
tlb consists
keys simultaneously
value field
page-table entries
percent longer
unmapped memory
memory reference
replacement replacement
replacement policies
policies range
tlb entries
tlbs store
tlb entry
address-space protection
tlb attempts
virtual page
page numbers
process matches
tlb miss
providing address-space
processes simultaneously
separate asids
wrong translation
translation information
tlb hit
hit tlb
miss page
virtual addresses
invalid physical
addresses left
80-percent hit
hit ratio
desired page
mapped-memory access
first access
desired byte
effective access
40-percent slowdown
98-percent hit
increased hit
hit rate
rate produces
percent slowdown
protection memory
paged environment
protection bits
correct frame
frame nuncber
read-only page
hardware trap
memory-protection violation
create hardware
execute-only protection
separate protection
illegal attempts
additional bit
space illegal
illegal addresses
valid -invalid
-invalid bit
disallow access
page suppose
14-bit address
situation shown
valid-invalid bit
flee operating
invalid page
page reference
program extends
illegal howeve1
address range
valuable memory
table value
valid range
shared pages
common code
editor consists
data space
editor-each page
large page
data page
page reentrant
reentrant code
non-self-modifying code
data storage
processes wilt
table maps
physical copy
data pages
total space
space required
significant savings
shared -compilers
window systems
read-only nature
shared code
paging environment
interprocess corrununication
implement shared
pages organizing
numerous benefits
physical pages
hierarchical paging
large logical
excessively large
32-bit logical
entry consists
smaller pieces
two-level paging
paging algorithm
table memory
two-level page-table
page-table scheme
number consisting
offset consisting
10-bit page
outer page
address-translation method
translation works
vax architecture
architecture supports
32-bit machine
equal sections
section represents
high-order bits
bits represent
logical page
page outer
two-level 32-bit
32-bit paging
paging architecture
leave partitions
partitions unused
section page
section number
one-level page
vax process
vax pages
user-process page
64-bit logical
table consists
iml.er page
large table
32-bit processors
added flexibility
three-level paging
scheme suppose
standard-size pages
64-bit address
2nd outer
sti11234 bytes
four-level paging
second-level outer
64-bit ultrasparc
prohibitive number
accessesto translate
64-bit architectures
hierarchical page
considered inappropriate
hashed page
handling address
hash value
handle collisions
element consists
mapped page
algorithm works
first element
subsequent entries
table refers
single page
single page-table
multiple physical-page
physical-page frames
frames clustered
clustered page
memory references
inverted page
virtual hash
table representation
processes reference
reference pages
address entry
value directly
real page
page stored
real memory
table compare
standard page
operation inverted
address-space identifier
spaces mapping
memory storing
identifier ensures
frame examples
tables include
simplified version
i11verted page
process-id assumes
memory page
address figure
reference occurs
memory subsystem
address access
scheme decreases
memory needed
lookups occur
few-page-table entries
table adds
reference requires
memory reads-one
hash-table entry
performance improvement
difficulty implementing
multiple virtual
process sharing
standard method
page entry
mapped result
page faults
linear array
view memory
variable-sized segments
data elements
math library
n1.ain program
elements occupy
variable length
subroutine symbol
symbol table
program elements
first statement
seventh stack
stack frame
frame entry
single address
segn lent
lent number
constructs segments
segments reflecting
input program
segment table
segmentation hardware
memory libraries
assign.ed separate
segment numbers
two-dimensional address
one-dimensional sequence
twodimensional user-defined
user-defined addresses
one-dimensional physical
segment base
segment limit
segment resides
limit specifies
segment number
logical addressing
addressing attempt
base-limit register
register pairs
segments numbered
separate entry
beginning address
subroutine segment
segment1 symbol
limit base
bytes long
pentium architecture
memory-management structure
major ideas
linux address
pentium systems
cpu generates
segmentation unit
unit produces
linear address
paging unit
turn generates
paging units
units form
memory-management unit
pentium segmentation
logical-address space
first partition
partition consists
processes information
gdt consists
8-byte segment
segment descriptor
detailed information
base location
16-bit number
32-bit number
segment registers
microprogram registers
cache lets
pentium avoid
segment register
register points
limit information
address validity
memory fault
32-bit linear
unit turns
pentium paging
paging schence
address-translation scheme
scheme shown
pentium address
address offset
segmentation detail
bits reference
outernlost page
pentium terms
page directory
cr3 register
directory entry
entry points
page pointed
size flag
which-if setindicates
directory points
directory page
page figure
pentium page
invalid bit
disk location
limited support
user data
task-state segment
default ldt
ldt segment
segment descriptors
global descriptor
descriptor table
hardware context
segment selector
selector includes
2-bit field
threelevel paging
paging strategy
global directory
directory middle
middle directory
address varies
lglobal directory
directory cr3
cr3 __,.c__
__,.c__ ___
___ __l
__l register
directory figure
linux offset
offset page
three-level model
-the cr3
tss segments
tasks involved
switch memory-management
memory-management algorithms
systems range
simple single-user
system approach
paged segmentation
important determinant
hardware provided
contiguous allocation
simple base
register pair
multiple-partition schemes
mapping tables
address map
map performance
memory-management algorithm
address increases
simple systems
logical address-operations
fast paging
mapping table
performance degradation
acceptable level
level fragmentation
multiprogramming level
reduce memory
memory waste
fragmentation systems
fixed-sized allocation
allocation units
single-partition scheme
variable-sized allocation
multiple-partition scheme
fragmentation relocation
compaction compaction
compaction involves
consideration requires
compact storage
storage swapping
swapping swapping
intervals determined
cpu-scheduling policies
share code
users sharing
small packets
shared sharing
limited amount
shared programs
read -only
simple run-time
run-time checks
programming errors
memory organization
organization schemes
pure paging
execution allocation
heap segments
intel address-translation
complicated memory
memory translation
address-translation system
reentrant module
segmented pagil
table scheme
large address
paging system
table stored
reference takes
paged memory
add tlbs
page-table references
effective memory
tlbs takes
compare paging
memory required
translation structures
instruction fetch
data fetch
baselimit register
instruction base-limit
users discuss
generating binaries
object code
individual modules
linkage editor
combine multiple
multiple object
program bilcary
editor change
memory-binding tasks
memory-load operation
memory partitions
worst-fit algorithms
algorithms place
place processes
algorithm makes
conventional single-level
single-level page
address references
decimal numbers
program binaries
data segment
program variables
program starts
lower virtual
base length
sharing segments
linked segmentation
segmentation system
static linking
32-bit virtual
size write
unsigned data
dynamic storage
simulation results
fit knuth
50-percent rule
atlas system
storage manager
hardware aspects
mmus talluri
discusses page
spaces alternative
alternative approaches
tlb fang
evaluate support
large pages
pages tanenbaum
discusses intel80386
intel80386 paging
paging memory
ultrasparcare described
lim1x systems
memory abstracts
technique frees
efficient mechanism
decrease performance
page-replacement algorithms
working-set model
basic requirement
entire logical
special precautions
real programs
programs shows
unusual error
errors seldom
executed arrays,lists
assembler symbol
average program
u.s government
government computers
large virtual
task page
memory memory
swap user
run faster
user involves
smaller physical
memory makes
process refers
process begins
logical address-say
memorymanagement unit
logical pages
memory note
successive function
large blank
blank space
stack grows
include holes
sparse address
segments grow
page sharing
process considers
actual pages
libraries reside
memory enables
enables processes
memory recall
process processes
these-and other-benefits
paging shared
pages shared
shared library
library figure
executable program
memory suppose
select loading
executable code
load pages
memory systems
demand-paged virtual
demand-paging system
secondary memory
lazy swapper
large contiguous
contiguous address
term swapper
technically incorrect
swapper manipulates
entire processes
individual pages
paging program
memory swap
contiguous disk
pager guesses
pager brings
memory pages
bit scheme
page invalid
accesses pages
execution proceeds
valid-invalid frame
frame bit
memory dod
odd figure
memory operating
system reference
store trap
trap restart
restart instruction
instruction page
table reset
reset page
missing page
page fault
page marked
internal table
allocated frame
disk read
non-memory-resident page
causing multiple
unacceptable system
processes shows
reasonable performance
support demand
entry invalid
special value
memory holds
high-speed disk
swap device
swap-space allocation
crucial requirement
condition code
interrupted process
fault occurs
three-address instruction
repeated work
complete instruction
difficulty arises
ibm system
move character
page boundary
partially done
destination blocks
blocks overlap
source block
microcode computes
relevant pages
temporary registers
overwritten locations
trap occurs
action restores
restores memory
architectural problem
problem resulting
adding paging
existing architecture
difficulties involved
involved paging
non-demand-paging environment
fault represents
fatal errm
fault means
additional page
process restarted
paging demand
demand-paged memory
relevant page
desired word
nrr access
system save
fault check
disk issue
read request
device seek
disk correct
memory wait
maintain cpu
page-fault service
page-fault interrupt
interrupt read
page restart
careful coding
typical hard
total paging
including hardware
paging device
average page-fault
reasonable level
page-fault rate
slowing process
execution dramatically
additional aspect
space disk
larger blocks
file lookups
indirect allocation
paging throughput
file image
performing demand
demand pages
needed pages
subsequent paging
systems attempt
files demand
store howeve1
pages include
method appears
good compromise
rapid process
physical figure
modifies page
pages belonging
processes invoke
copy-on-write pages
shared page
process attempts
pages set
copied page
page belonging
copy-on-write technique
unmodified pages
processes note
child copy-on-write
copyon write
free page
free pages
managed operating
zero-fill-on-demand pages
previous contents
variation ofthe
ofthe fork
system call-vfork
altered pages
process calls
calls exec
pages takes
efficient method
implement unix
command-line shell
earlier discussion
first referenced
ten pages
paging saves
forty frames
ten frames
higher cpu
data set
sixty frames
holding program
program pages
pages buffers
considerable amount
algorithms deciding
significant challenge
systems allocate
fixed percentage
valid-invalid pc
replacement over-allocation
memory manifests
system determines
throughput users
paged system-paging
basic page
replacement page
replacement takes
freed frame
process faulted
include page
disk find
page-replacement algorithnc
victim frame
frame tables
tables restart
process notice
page transfers
modify bit
read-only pages
modified frame
enormous virtual
user addresses
longer constrained
twenty pages
replacement algorithm
major problems
implement demand
demand develop
replaced designing
important task
slight improvements
demand-paging methods
methods yield
large gains
replacement scheme
lowest page-fault
generate reference
reference strings
choice produces
entire address
fault page
first reference
address sequence
reference string
frames figure
versus number
page-replacement algorithm
faults decreases
reference strillg
strillg considered
faultsone fault
eleven faults
frames increases
faults drops
minimal level
memory increases
fifo page
simplest page-replacement
fifo replacement
oldest page
chosen notice
empty frames
replaces page
fifteen faults
faults altogether
fifo page-replacement
page replaced
initialization module
works correctly
active page
bad replacement
replacement choice
choice increases
slows process
string versus
frames notice
unexpected result
early research
investigators noticed
optimal page
longest period
page-fault curve
algorithm guarantees
pagefault rate
fixed number
sample reference
optimal page-replacement
optimal replacement
fifo algorithm
irt fact
future knowledge
similar situation
sjf cpu-schedulin.g
cpu-schedulin.g algorithm
optimal algorithm
comparison studies
algorithm reference
lru page
key distinction
opt algorithms
backward versus
versus forward
opt algorithm
lru replacement
replacement associates
lru chooses
lru algorithm
applying lru
algorithm produces
produces twelve
twelve faults
faults notice
replacement sees
algorithm replaces
lru policy
implement lru
lru page-replacement
substantial hardware
hardware assistance
frames defined
time-of-use field
logical clock
clock register
ti1ne-of-use field
last reference
considered stack
implementing lru
head pointer
tail pointer
pointer removing
pointer points
microcode implementations
stack algorithm
referenced pages
standard tlb
tlb registers
recent page
page references
clock fields
lru-approximation page
sufficient hardware
true lru
pagereplacement algorithms
reference bit
reference bits
page referenced
approximate lru
additional-reference-bits algorithm
additional ordering
ordering information
8-bit byte
interrupt transfers
system shifts
high-order bit
low-order bit
8-bit shift
shift registers
shift register
register value
history register
8-bit bytes
unsigned integers
lowest number
replaced notice
smallest value
fifo method
history included
second-chance algorithm
basic algorithm
second-chance replacement
pages reference
pages bits
bits bits
bit set
clock algorithm
pointer advances
victim page
position notice
pointer cycles
replacement second-chance
replacement degenerates
ordered pair
-best page
page belongs
page encountered
lowest nonempty
nonempty class
class notice
simpler clock
give preference
counting-based page
smallest count
large reference
reference count
initial phase
large count
average usage
usage count
lfu replacement
approxinlate opt
opt replacement
page-buffering algorithms
specific page-replacement
written out
free-frame pool
modified pages
modified page
scheme increases
frame contents
free-frame buffer
early versions
bit correctly
pagereplacement algorithm
penalty incurred
wrong victim
applications accessing
memory perform
perform worse
system provided
buffering applications
implementing algorithms
data warehouses
frequently perform
massive sequential
sequential disk
disk reads
older pages
sequential reads
special programs
disk partition
large sequential
sequential array
logical blocks
raw disk
termed raw
filesystem services
file locking
space allocation
directories note
special-purpose storage
storage services
raw partition
applications perform
regular file-system
file-system services
fixed amount
memory composed
pure demand
process started
started execution
in-memory pages
process terminated
system allocate
table space
support user
user paging
frames reserved
page swap
basic strategy
minimum number
frames involves
involves performance
frames allocated
process decreases
rate increases
executing ilcstruction
single ilcstruction
memory-reference instructions
mernory reference
one-level indirect
indirect addressing
indirect reference
paging requires
move instruction
pdp-11 includes
addressing modes
indirect references
mvc instruction
storage location
case occurs
execute instruction
worst-case scenario
scenario occurs
multiple levels
16-bit word
15-bit address
1-bit indirect
indirect indicator
simple load
indirect address
entire virtual
first indirection
indirection occurs
successive irtdirection
excessive indirection
limitation reduces
significant choice
frame allocation
allocation algorithms
equal share
leftover frames
differing amounts
small student
student process
interactive database
ncinimum number
frames required
tl1e instruction
proportional allocation
level decreases
departed process
remaining processes
processes notice
high-priority process
frames depends
relative sizes
global versus
local allocation
important factor
processes competing
broad categories
local global
global replacement
replacement frame
local replacement
replacement requires
process select
high-priority processes
select frames
replacement strategy
process depends
paging behavior
external circuntstances
generally results
greater system
memory faster
performance differences
system boards
system busses
high-speed network
access times
motherboard managing
affect performance
numa systems
treat memory
modify memory
minimum latency
system board
scheduler track
last cpu
process ran
memory-management system
allocate frames
process close
improved cache
cache hits
decreased memory
running threads
threads scheduled
case solaris
solaris solves
lgroup gathers
close cpus
lgroups based
groups solaris
nearby lgroups
memory latency
hit rates
process falls
number required
remaining pages
provision introduces
swap-out level
intermediate cpu
support pages
quickly page-fault
replacing pages
high paging
paging activity
thrashing thrashing
thrashing results
severe performance
actual behavior
early paging
paging systems
system monitors
monitors cpu
global page-replacement
replaces pages
taking frames
faulting processes
pagin.g device
swap pages
queue empties
utilization decreases
scheduler sees
decreasing cpu
longer queue
throughput plunges
increases tremendously
effective m.emory-access
multiprogramming increases
thrashing sets
drops sharply
increase cpu
process starts
starts thrashing
multiprogramming figure
average service
longer average
prevent thtashing
working-set strategy
approach defines
locality model
model states
program structure
basic memory
reference structure
structure note
unstated principle
caching discussions
useless suppose
current locality
memory-reference pattern
working set
set depends
entire locality
reference table
pages touched
important property
working-set size
total demand
extra frames
working-set sizes
sizes increases
strategy prevents
prevents thrashing
working-set window
moving window
reference appears
oldest reference
reference drops
fixed-interval timer
reference-bit values
current reference
in-memory bits
set note
reference occurred
history bits
frequent interrupts
correspondingly higher
page-fault frequency
control thrashilcg
direct approach
prevent thrashilcg
thrashilcg thrashing
high page-fault
lower bounds
actual page-fault
rate exceeds
upper limit
rate falls
lower limit
prevent thrashing
rate ilccreases
freed frames
page-fault rates
sequential read
standard system
access requires
disk access
significant performance
performance increases
working sets
page faultrates
set ofa
ofa process
code sections
sections move
tbe page-fault
general behavior
fault rate
rate working
rate occurs
rate rises
lower rate
span oftime
thenext peak
peak represents
basic mechanism
mechanism memory
initial access
file proceeds
ordinary demand
page-sized portion
page-sized chunk
subsequent reads
simplifying file
involve disk
file mapped
physical file
memory-mapped data
provide memory
systems choose
ordinary system
kernel address
solaris treats
allowing file
efficient memory
subsystem multiple
data writes
processes modify
earlier discussions
memory-mapped sections
sharing process
process points
physical memory-the
memory-the page
memory sharing
memory-mapping system
copy-on-write functionality
allowing processes
read-only mode
file figure
files process
memory-mapped file
exclusion described
posix-compliant shmget
systems calls
memorymapped file
file serves
illustrate support
general outline
memorymapped files
api involves
first creating
file mapping
mapped file
file represents
shared-menwry object
enable communication
shared-memory object
memory-mapping features
shared m.emory
process opens
message written
opened file
file handle
handle hfile
lpvoid lpmapaddress
file null
security open_always
file file_attribute_normal
attributes null
template hmapfile
handle null
security pagejreadwrite
mapped pages
map entire
memory object
object lpmapaddress
object handle
handle filejmap_all_access
mapped view
memory sprintf
memory message
producer writing
api -the
-the entire
code brevity
sharedobj ect
named object
passed values
entire mapping
handle hmapfile
access false
file object
memory printf
consumer reading
bringing pages
fm1ction returns
message shared
process establishes
existii1g named
message thatwas
processes remove
controller includes
includes registers
hold commands
data transfers
convenient access
device registers
registers reads
fast response
video controllers
n1.emory location
location displaying
displaying text
memory-mapped locations
parallel ports
connect modems
cpu transfers
long string
memory-mapped serial
serial port1
cpu writes
data byte
data register
control register
device takes
data transfer
user rnode
rnode requests
pages scattered
explained earlier
single byte
entire page
frame kernel
free-memory pool
ordinary user-mode
user-mode processes
primary reasons
kernel requests
requests memory
minimize waste
subject kernel
pages allocated
contiguous physical
devices interact
physical memory-without
memory interface-and
require memory
memory residing
contiguous pages
kernel processes
buddy system
slab allocation
system tbe
tbe buddy
system allocates
fixed-size segment
segment consisting
pages memory
satisfies requests
units sized
highest power
next-highest power
segment allocated
adjacent buddies
larger segments
kernel releases
original256-kb segment
obvious drawback
allocated segments
allocated unit
system allocation
single cache
structure -for
separate cache
representing process
process descriptors
file objects
cache represents
cache representing
representing semaphores
semaphores stores
stores instances
semaphore objects
descriptors stores
process descriptor
descriptor objects
figure shows
kernel objects
respective caches
slab-allocation algorithm
store kernel
cache depends
free object
object assigned
slab allocator
object representing
type struct
kernel creates
task_struct object
objects slabs
objects figure
free partial
slab consists
free objects
partial slab
empty slab
empty slabs
main benefits
fragmentation fragn
fragn entation
allocator returns
exact amount
object memory
memory requests
aging memory
allocating-and releasing-memory
time-consuming process
subsequent requests
general-purpose nature
user-mode memory
solaris linux
kernel adopted
major decisions
allocation policy
obvious property
situation results
initial locality
initial paging
small files
process prepaging
pages brought
saved page
unnecessary pages
prepaging loses
prepaging wins
existing machine
machine seldom
sizes page
invariably powers
active process
desirable memory
smaller pages
memory starting
final page
assuming independence
transfer times
times transfer
amount transferred
size howeve1
dwarf transfer
bytes latency
transfer doubling
sam.e amount
smaller page
match program
program locality
fault generates
large amount
overhead needed
saving registers
updating tables
sector size
table size
historical trend
first edition
common page
tlb reach
tlb recall
tlb refers
address translations
power hungry
hungry related
similar metric
reach refers
entries multiplied
resolving memory
memory-intensive applications
prove insufficient
page size-say
kb-we quadruple
ultrasparc supports
supports page
pages sizes
64-entry tlb
solaris ranges
solaris maps
pages solaris
size providing
providing support
sizes requires
system -not
entry managing
performance howeve1
reach offset
performance costs
recent trends
softwaremanaged tlbs
alpha architectures
architectures employ
software-managed tlbs
pentium manage
tables section
page management
virtual-to-physical address
physical frame
tables reduce
referenced page
memory demand
process page
external page
traditional per-process
per-process page
tables negate
memory n1.anager
case requires
careful handling
page-lookup processing
structure demand
paged nature
underlying demand
stored row
stored data
row takes
preceding code
code zeros
programming structures
increase locality
good locality
scatter references
bad locality
weighted factors
factors include
include search
search speed
sigicificant effect
paging separating
separating code
generating reentrant
code means
code pages
modified clean
clean pages
placing routines
page routines
bin-packing problem
operations research
variable-sized load
load segments
fixed-sized pages
interpage references
pointers tend
randomize access
object-oriented programs
poor locality
situation occurs
process issues
paged out
request advances
common solutions
extra copying
high overhead
lock bit
usual locked
locked pages
unlocked figure
lock bits
fault caused
bit involves
normal page
process faults
faults selecting
system reads
system sees
perfect replacement
effort spent
prevent replacement
brought-in page
faulting process
situation occur
locked frame
user doing
locking multiuser
multiuser systems
locking hints
individual process
solaris implement
clustering handles
handles page
faultil1.g page
faulting page
working-set minimum
working-set maximum
manager maintains
threshold value
manager allocates
working-set rnaximum
rnaximum incurs
local page-replacement
page-replacement policy
memory falls
automatic working-set
working-set trimming
trimming works
manager removes
removes pages
process reaches
allocated pages
free-page-frame list
sufficient free
multiprocessor x86
x86 systems
require invalidatil
look-aside buffer
thread incurs
kernel assigns
faulting thread
sufficient amount
parameter-zotsfree-that represents
begin paging
lotsfree parameter
pages falls
pageout starts
pageout process
scanning pages
process works
front hand
clock scans
back hand
clock examines
free list
modified solaris
solaris maintains
cache list
invalid contents
contents pages
pageout algorithm
scanning occurs
slowscan pages
default value
total physical
withfastscan set
system parameter
fastscan cll
slowscan minfree
minfree desfree
desfree amount
solaris page
page scanner
value depends
process checks
checks memory
desfree free
30-second average
kernel begins
swapping processes
swapped processes
recent releases
provided enhancements
enhancement involves
recognizing pages
libraries pages
scannerare skipped
page-scanning process
enhancement concerns
concerns distinguishing
distinguishing pages
physical menlory
increasing cpu
frees application
memory availability
share system
efficient type
paging pure
kernel consults
entire memory
and-in theory
requirements exceed
processes run
replace pages
anomaly optimal
knowledge lru
frame-allocation policy
needed allocation
local page
model assumes
avoid thrashing
require process
process swapping
memory mappil1g
mappil1g files
api implements
implements shared
files kernel
req1.1ire memory
physically contiguous
fragmentation slab
slab allocators
allocators assign
assign kernel
proper design
paging systern
systern requires
prep aging
tree illustrating
bytes request
followilcg releases
perform coalescing
bytes release
256-byte pages
smallest counter
basic idea
counters increased
increased iii
counters decreased
faults occur
optimal pagereplacement
pagereplacement strategy
time-measured utilizations
utilization paging
paging disk
improve cpu
utilization explain
faster cpu
bigger paging
main n1.enl0ry
faster hard
multiple controllers
multiple hard
hard disks
page-fetch algorithms
demand-paged computer
determine utilization
paging helping
disk utilization
average access
milliseconds addresses
table takes
reduces access
memory assume
simplified view
thread change
state figure
thread state
address reference
support required
frames remember
first unique
unique pages
replacement fifo
replacement optimal
allocates pages
system provide
discuss situations
algorithm generates
fewer page
opposite holds
occur describe
addressing scheme
indirect memory-load
per-process frame
allocation technique
kernellevel threads
process consist
thread explain
copy-on-write feature
two-dimensional array
small process
matrix resides
array-initialization loops
system detect
detect thrashing
candidate page
moving fast
moving slow
resident pages
pages assume
policy answer
free space
space generated
requested page
page exists
resident page
page set
free-france pool
pool managed
make space
system degenerate
object type
type assuming
scalability issue
empty frame
replaced page
nanoseconds assume
acceptable page-fault
variable-sized pages
pages define
segment-replacement algorithms
algorithms based
lru pagereplacement
pagereplacement schemes
schemes remember
consecutive locations
needed segment
segments cam
demand-paged environment
good explain
hashed symbol
sequential search
binary search
pure code
vector operations
user user
memory explain
memory identify
options system
memory describe
fault tlb
process generates
system establishes
physical location
benefits list
character instruction
destination regions
small value
high value
representing data
representing code
code explain
paged system
last examination
algorithms presented
random pagereference
pagereference string
numbers range
random page-reference
page-reference string
faults incurred
algorithm implement
catalan numbers
integer sequence
sequence c11
treeenumeration problems
first catalan
formula generating
generating c11
catalan sequence
line means
manchester university
university muse
muse computer
early demand-paging
first researchers
stack algorithms
fixed allocation
enl lanced
lanced clock
burroughs bssoo
bssoo computer
system wilson
allocation jolmstone
issues buddy
memory allocators
memory-fitting algorithms
memory-allocation strategies
windows implements
memory mcdougall
discussed operating
system support
sizes ortiz
system jacob
compared implementations
pentium architectures
companion article
ultrasparc part
memory modern
primary on-line
programs residing
devices files
devices transfer
transfer data
major component
device variation
key goal
simplest interface
maximum concurrency
distinct parts
related data
system file
systems live
major directory
directory structures
sharing files
discuss ways
file protection
access files
file-system design
design tradeoffs
including access
file-system protection
protection computers
file files
power failures
named collection
smallest allotment
logical secondary
free form
file-source programs
object programs
executable programs
numeric data
payroll records
graphic images
sound recordings
text file
characters organized
possibly pages
executable statements
object file
bytes organized
systems differentiate
lowercase characters
file example.c
floppy disk
destination system
symbolic file
humanreadable form
form identifier
unique tag
files location
device size
current size
maximum allowed
allowed size
attribute protection
protection access-control
access-control information
information determines
user identification
last modification
usage monitoring
turn locates
memory piecemeal
file operations
truncate files
basic file
similar operations
implemented creating
allocate space
directory writing
write pointer
write occurs
occurs reading
read pointer
current operation
operation location
saving space
reducing system
system complexity
complexity repositioning
current-file-position pointer
value repositioning
file seek
seek deleting
named file
file space
unchanged -except
length-but lets
space released
basic operations
operations comprise
minimal set
required file
operations include
primitive operations
operations mentioned
involve searching
constant searching
small table
system removes
open-file table
table create
file terminates
accept accessmode
request mode
actual file
file simultaneously
internal tables
per-process table
system-wide table
perprocess table
table tracks
open stored
current file
file pointer
turn points
system-wide open-file
process-independent information
access dates
file size
table pointing
systemwide table
open count
file open
count reaches
open file
file file
file offset
last readwrite
readwrite location
process operating
on-disk file
attributes file-open
file-open count
table entries
last file
table entry
file-open counter
counter tracks
last close
entry disk
operations require
operation access
access mode
provide facilities
file locks
system log
requires firstobtaini
i..lechannel fbr
fbr thefile
filelock lock
l.ong begin
long end
ooleqn shared
gi1iningand ending
ending positions
locked settingshared
true isfb
shared locks
false acquires
lock exclusively
exclusively tice
tice lock
filelock returned
program acquires
of.the file
locks provide
provide functionality
reader lock
lock concurrently
lock behaves
writer lock
exclusive file
file-locking mechanisms
process acquires
locked file
system .log
open system
text editor-the
editor-the operating
prevent access
acquiring access
locking scheme
ensures locking
locking integrity
advisory locking
systems adopt
adopt mandatory
mandatory locking
employ advisory
advisory locks
locks requires
ordinary process
programmers developing
file types
operating system-we
support file
system recognizes
reasonable ways
common mistake
mistake occurs
binary-object form
produces garbage
binary-object program
period character
additional characters
characters file
.bat extension
.exe files
.bat file
ascii format
system ms-dos
ms-dos recognizes
assemblers expect
expect source
.asm extension
microsoft word
word word
processor expects
executable exe
to-run machineor
language program
program object
object obj
linked source
languages batch
interpreter text
text txt
textual data
wordcprocessor doc
doc formats
library lib
dll libraries
libraries o.troutines
.programmers print
jpg ascii
archive arc
related files
files grouped
.one file,sometimes
file,sometimes compressed
storage multimedia
multimedia mpeg
avi audio
information figure
common file
types end
.doc extension
save typing
tops-20 operating
object program
function ensures
up-to-date object
last modified
correct compiler
creator attribute
file produced
user opens
file-executable program
batch file
magic numbers
system features
information unix
creating program
file-nameextension hints
aid users
file structure
structure file
internal structure
object files
required structure
system requires
specific structure
systems extend
system-supported file
file structures
special operations
vms operating
point brings
multiple file
resulting size
types supported
applications require
require information
information structured
severe problems
ascii characters
characters separated
carriage return
line feed
executable binary
encrypted file
unauthorized people
text lines
random bits
file-type mechanism
encryption scheme
systems impose
minimal number
un1x considers
operating systenl
executable file-so
expects files
resource fork
buttons displayed
foreign user
data fork
traditional file
file contents
ms-dos system
user-changeable data
data file
support structures
substantial effort
structures make
programming inconvenient
operating-system bloat
programmer confusion
internal file
well-defined block
size determined
physical record
record size
logical record
logical records
length paddng
physical blocks
simply streams
unpacks bytes
disk blockssay
physical block
packing technique
technique determine
functions operate
simple software
software problem
last block
generally wasted
waste incurred
systems suffer
fragmentation files
files store
computer memory
major design
current position
position end
sequential-access file
sequential access
simplest access
fashion reads
writes make
operation-read next-reads
automatically advances
operation-write next-appends
written material
integer n-perhaps
tape model
sequential-access devices
write records
direct-access method
disk model
random access
file block
numbered sequence
read block
write block
direct-access file
direct-access files
information databases
subject arrives
airline-reservation system
block identified
flight number
reservation file
store il1formation
larger set
hash function
small in-ncemory
in-ncemory index
block number
operation position
position file
relative block
first relative
absolute disk
disk address
first block
block numbers
allocation problem
accessing portions
systems start
system satisfy
record nina
nina file
file assuming
record length
bytes starting
first record
fixed size
sequential file
manner consistent
desired record
retail-price file
universal codes
record consists
10-digit upc
6-digit price
16-byte record
file sorted
index consisting
first upc
number adams
adams arthur
index file
relative file
relative files
files find
large file
file doing
large files
primary index
secondary index
index files
actual data
sequential-access method
small master
master index
disk blocks
index blocks
blocks point
file blocks
defined key
direct-access reads
reads figure
vms index
store files
computer stores
computer files
random-access storage
solid state
finer-grained control
system storage
raid sets
provide protection
sets partitioning
individual file
putting multiple
multiple file-system
file-system types
leaving part
directory partition
files disk
files partition
typical file-system
file-system organization
organization space
space partitions
ibm world
multiple devices
devices linked
raid set
virtual disk
disk volumes
device directory
records information
volume figure
multiple storage
systems computer
varying types
system list
general-purpose file
worth noting
special-purpose file
tmpfs-a temporary
temporary file
volatile main
contents erased
virtual file
debuggers access
kernel symbols
maintains contract
contract information
processes start
system boots
contract ctfs
object objfs
zfs figure
system lofs-a
lofs-a loop
prods-a virtual
presents information
system ufs
zfs-general-purpose file
segregate files
organization involves
directory overview
translates file
directory entries
insert entries
delete entries
named entry
logical structure
directory system
symbolic names
names match
pattern create
directory delete
directory list
list rename
changed traverse
good idea
magn.etic tape
backup copy
file released
common schemes
single-level directory
simplest directory
significant limitations
files increases
unique names
users call
file test
unique-name rule
programming class
assignment prog2
making file
names unique
11-character file
directory files
files figure
additional files
system keeping
daunting task
two-level directory
separate directory
similar structures
user w11en
user job
job starts
account number
user refers
system confines
local ufd
user directories
special system
teduciques discussed
structure solves
name-collision problem
local user
user files
inverted tree
direct descendants
user file
file directory
file desired
test file
file named
named test
naming files
additional syntax
file specification
file login.com
directory pbg
system files
files programs
system -loaders
utility routines
current ufd
enormous amount
files require
search procedure
procedure slightly
special user
user directory
directories searched
search path
unlimited list
ms-dos systems
tree-structured directories
two-level tree
natural generalization
arbitrary height
common directory
root directory
unique path
root ititi
tree-structured directory
internal format
entry defines
delete directories
current directory
current interest
directory holding
change directories
change directory
calls search
file note
special entry
initial current
login shell
accounting file
predefined location
accounting purposes
initial directory
spawned path
path names
directory names
tree-structured file
relative path
absolute path
subdirectories permits
separate directories
directory programs
source programs
directory bin
interesting policy
directory concerns
subdirectories exist
substantial amount
entire directory
backup exists
names user
tree-struch1red directory
access programs
long paths
system automates
desktop file
metadata code
system traverses
pertinent information
mechanism supports
double-dick execution
execution functionality
functionality described
described previously
creatorattribute data
clicked-on file
acyclic-graph directories
joint project
acyclic-graph directory
common subdirectory
shared directory
tree structure
structure prohibits
acyclic graph
cycles-allows directories
share subdirectories
directory scheme
file created
shared subdirectories
team member
shared files
file organization
project shared
real file
link information
file links
support types
indirect pointers
system ignores
traversing directory
directory trees
acyclic structure
implementing shared
sharing directories
original directory
equal duplicate
duplicate directory
copy indistinguishable
maintaining consistency
simple tree
multiple absolute
distinct file
aliasing problem
accumulate statistics
shared structures
problem involves
involves deletion
space allocated
leave dangling
dangling pointers
now-nonexistent file
file worse
remaining file
file pointers
actual disk
symbolic links
original file
file entry
links dangling
illegal file
system designer
symbolic link
llcal file
replaced microsoft
file-reference list
large size
references adding
entry increments
entry decrements
remaining references
nonsymbolic links
information block
prohibiting multiple
multiple references
acyclic-graph structure
avoid problems
shared directories
general graph
graph directory
create subdirectories
directory results
directory preserves
tree-structured nature
nature howeve1
add links
simple graph
graph structure
primary advantage
relative simplicity
avoid traversing
traversing shared
shared sections
performance reasons
shared subdirectory
avoid searching
designed algorithm
similar problem
problem exists
count means
garbage-collection scheme
reallocated garbage
collection involves
pass collects
similar marking
marking procedure
disk-based file
seldom attempted
attempted garbage
avoid cycles
detect cycles
simpler algorithm
bypass links
directory traversal
traversal cycles
multiple volumes
mount procedure
system type
mount point
empty directory
home directories
system verifies
valid file
expected format
system notes
scheme enables
file mounting
system depicted
triangles represent
represent subtrees
interest figure
unmounted volume
volume residing
accessed figure
existing system
situation depicted
impose semantics
clarify functionality
mounted file
existing files
allowing access
original files
mount points
classic macintosh
system encounters
root level
folder icon
screen labeled
gui hides
extended two-level
drive letters
letters volumes
drive letter
specific file
file takes
directory tree
located file
mount commands
configuration file
automatic mounting
system mounting
appendix a.7.5
previous sections
allowing users
effort required
computing goal
user-oriented operating
inherent difficulties
general issues
extend sharing
including remote
conflicting actions
actions occurring
system protect
system accommodates
accommodates multiple
file naming
grant access
implement sharing
directory attributes
change attributes
group attribute
attribute defines
share access
group members
permission attributes
owner attribute
requesting user
file likewise
requested operation
multiple local
local file
including volumes
multiple attached
attached disks
permission matching
remote computers
resources spread
obvious resource
file technology
file-sharing methods
implemented method
transferring files
major method
remote directories
local machine
remote files
separate operations
files ftp
authenticated access
anonymous file
exclusively dfs
dfs involves
tighter integration
machine providing
integration adds
adds complexity
model remote
remote machines
machine seeking
seeking access
client-server relationship
networked machines
server declares
serve multiple
multiple clients
multiple servers
client-server facility
directory level
level client
client identification
unauthorized client
secure solutions
solutions include
include secure
secure authentication
encrypted keys
ensuring compatibility
encryption algorithms
key exchanges
intercepted keys
unauthorized access
unsecure authentication
authentication methods
network file
authentication takes
client networking
networking information
determine access
real user
incorrect authentication
correct user
nfs protocols
many-to-many relationships
provide files
nfs clients
nfs servers
operation requests
dfs protocol
file-open request
standard access
access checks
mode requested
apply semantics
local file-system
file-system mount
distributed information
information systems
provide unified
unified access
remote computing
host-name-to-network-address translations
entire internet
networked hosts
scalable dns
provide user
distributed facility
facility unix
distributed-information methods
methods sun
microsystems introduced
yellow pages
industry adopted
centralizes storage
host names
printer information
including sending
sending user
user passwords
passwords unencrypted
clear text
identifying hosts
address sun
secure replacement
widely adopted
network information
requested file
m.u.st match
naming structures
older naming
naming technology
newer technology
naming facility
clients servers
authenticate users
secure distributed
naming mechanism
ldap sun
microsystems includes
includes ldap
system-wide retrieval
distributed ldap
ldap directory
resource information
system-administration efforts
information services
including failure
disk-management information
disk-controller failure
cable failure
host-adapter failure
failure user
system-administrator failure
entire directories
human intervention
damage remote
network systems
required interactions
poor hardware
networking implementation
implementation issues
built-in resiliency
including multiple
multiple paths
single failure
dfs commands
performing directory
directory lookups
closing files
scheduled shutdown
longer reachable
client system
lost server
delay operations
failure semantics
remote-file-system protocol
protocol termination
losing data-and
data-and patience
dfs protocols
file-system operations
rencote hosts
client maintain
maintain knowledge
current activities
exported file
opened files
nfs takes
simple approach
file read
previously open
nfs protocol
protocol carries
exported volumes
volumes mounted
stateless approach
approach makes
makes nfs
nfs resilient
write requests
nfs server
requisite mount
mount request
permission check
industry standard
standard nfs
nfs version
consistency semantics
semantics represent
supports file
system consistency
process-synchronization algorithms
complex algorithms
chapter tend
great latencies
slow transfer
transfer rates
remote disk
full set
functionalities tend
perform poorly
successful implementation
complex sharing
sharing semantics
andrew file
file accesses
operations makes
prominent examples
unix file
current location
user affects
sharing users
single image
unix semantics
physical image
exclusive resource
resource contention
session semantics
sessions starting
open instances
write accesses
scheduling accesses
immutable-shared-files semantics
unique approach
immutable ile
key properties
immutable file
file signifies
physical damage
improper access
duplicate copies
computer-operator intervention
copy disk
disk files
accidentally destroyed
destroyed file
hardware problems
power surges
head crashes
temperature extremes
vandalism files
file-system software
lost reliability
small single-user
desk drawer
file cabinet
protect files
direct result
files systems
permit access
complete protection
prohibiting access
free access
protection mechanisms
mechanisms provide
controlled access
made access
access requested
read read
write write
file execute
execute load
append write
file delete
delete delete
reuse list
list list
higher-level fm1ctions
lower-level system
calls protection
read requests
intended application
small computer
research group
large corporate
corporate computer
personnel operations
complete treatment
protection problem
make access
access dependent
general scheme
implement dependent
dependent access
access allowed
requests access
access list
requested access
protection violation
violation occurs
denied access
complex access
access methodologies
main problem
access lists
unrewarding task
complicated space
space management
condensed version
access-control list
systems recognize
owner group
similar access
work group
group universe
system constitute
common recent
recent approach
access-control lists
universe accesscontrol
accesscontrol scheme
specific files
fine-grained access
graduate students
named book
file jim
obtain feedback
textwith members
members jim
file book
temporary access
text group
access-control-list functionality
control list
human interaction
vms system
list access
limited protection
protection classification
define protection
controls read
controls write
controls execution
separate field
file owner
record protection
protection information
protection fields
owner sara
group text
combining approaches
interface users
optional acl
acl permissions
regular permissions
full contml
contml h-1odi
ia.l permissions
specia.l permissions
advanced settings
settings click
click .a.dva.nced
.a.dva.nced figure
list management
jim staff
separate set
acls windows
typically manage
manage access-control
cui figure
file-permission window
user guest
file lo.tex
assigning precedence
acls conflict
acl granting
granting joe
joe read
denied solaris
acls precedence
protection approaches
limiting access
directory protection
handled similarly
universe-each consisting
bits rwx
faa subdirectory
sample directory
unix environment
field describes
first character
optional extension
pbg staff
pbg student
program.c -rwxr-xr-x
program drwx
pbg faculty
scheme impractical
all-or-none basis
nrultiwrite access
single-user operating
older systems
multilevel directory
individual files
directory operations
protected operation
numerous path
general graphs
type defined
complex data
record types
logical file
physical storage
physical records
volume table
create directories
naming problems
directory solves
users files
directory lists
files acyclic-graph
enable users
complicate searching
complete flexibility
requires garbage
unused disk
space disks
left raw
raw file
naming scheme
scheme varies
disable access
maintenance file
sharing depends
semantics provided
multiple writers
sharing distributed
client hosts
mount volumes
network remote
systems present
security distributed
systems maintain
access information
share state
main information-storage
information-storage mechanism
needed access
list directory
single copy
file discuss
relative merits
job terminates
terminates discuss
scheme compared
file explicitly
authorized user
ordinary files
users suppose
protection scheme
scheme provided
providing ncandatory
ncandatory locks
maintain information
system maintain
separate table
separate entries
indexed files
answer change
supporting unix
unix consistency
system knew
access file
sequential manner
space reclaimed
supporting links
cross mount
file link
link refers
microcomputer file
systems database
multics system
systems nfs
general discussion
sun system
administration guide
docs sun
major features
features eastlake
proposed security
security extensions
dns hold
hold security
security keys
keys ldap
derivative subset
x.soo distributed
distributed directory
directory protocol
systems interesting
interesting research
file-system interfaces-in
lucent technology
including data
issues surrounding
surrounding file
secondary-storage medium
explore ways
allocate disk
freed space
discuss block
block allocation
free-block algorithms
trade-offs disks
disks provide
convenient medium
storing multiple
multiple files
sance place
read-write heads
discuss disk
sectors depending
size varies
usual size
bytes provide
provide efficient
allowing data
retrieved easily
system poses
design problems
task involves
operations allowed
creating algorithms
physical secondary-storage
secondary-storage devices
structure shown
layered design
lower levels
transfer information
disk system
input consists
high-level commands
retrieve block
output consists
hardware-specific instructions
hardware controller
specific bit
bit patterns
special locations
device location
generic commands
numeric disk
memory buffers
data blocks
block application
file-organization module
control devices
layered file
buffer ncemory
complete caches
optimum system
file allocation
logical block
block addresses
logical numbers
free-space manager
tracks unallocated
unallocated blocks
manages metadata
metadata information
information metadata
metadata includes
fileorganization module
file-control blocks
including ownership
layered structure
basic file-system
logical file-system
file-organization modules
system overhead
decreased performance
standard format
format agreed
cd-rom manufacturers
removable-media file
systems unix
berkeley fast
fast file
support disk
disk file-system
file-system formats
floppy-disk file-system
linux supports
file systerns
standard linux
linux file
common versions
client computers
network file-system
file-system research
research continues
implementation coogle
coogle created
specific storage
interesting project
fuse file-system
executing file
kernel-level code
request access
in-memory structures
vary depending
principles apply
system stored
free blocks
free-block count
free-block pointers
free-fcb count
fcb pointers
includes file
inode numbers
master file
file table
per-file fcb
identifier number
relational database
database structure
in-memory in.formation
in-memory volume
in-memory directory-structure
directory-structure cache
cache holds
directory information
accessed directories
file dates
acl file
blocks figure
typical file-control
file-control block
information buffers
buffers hold
file-system blocks
implementation creates
file-system creation
free fcbs
typical fcb
type field
field indicating
implement separate
separate system
treat directories
larger structural
structural issues
disk-block numbers
control system
call passes
per-process open-file
substantial overhead
speed directory
space kernel
storage figure
in-memory file-system
file-system structures
read file-system
file-system table
subsequent opens
entry varies
varies unix
windows refers
process closes
system-wide entry
file close
updated metadata
disk-based directory
systems complicate
system aspects
table holds
similar information
multiple purposes
caching aspects
average cache
cache hit
percent shows
worth implementing
operating structures
multiple partitions
span multiple
multiple disks
unix swap
system likewise
hold information
disk raid
raid systems
bit maps
maps indicating
miniature database
database holding
holding raid
raid configuration
set raw
boot information
separate partition
code loaded
file-system format
sequential series
memory execution
image starts
first byte
specific operating
boot space
successful mount
mount operation
consistency checked
in-memory mount
mount table
function depend
system microsoft
windows-based systems
systems mount
system places
device structure
driver letter
system finds
file-system pointer
directory mounting
in-memory copy
previous section
section m.akes
multiple types
file-system space
suboptimal method
implementing multiple
write directory
file routines
object-oriented techniques
dissimilar file-system
including network
nfs users
local disk
network data
basic systemcall
systemcall functionality
implementation consists
major layers
vfs layer
layer serves
important functions
file-system-generic operations
clean vfs
vfs interface
allowing transparent
transparent access
systems mounted
mounted locally
file-representation structure
numerical designator
network-wide unique
unique file
unix inodes
single file
network-wide uniqueness
vnode structure
active node
vfs distinguishes
local files
vfs activates
file-system-specific operations
local requests
protocol procedures
remote requests
requests file
file handles
relevant vnodes
layer implementing
network figure
system file-system
file-system type
briefly examine
vfs architecture
main object
object types
types defined
linux vfs
inode object
superblock object
dentry object
individual directory
vfs defines
f1.mction table
function table
table lists
actual functions
defined operations
abbreviated api
object include
file ssize_t
ssize_t read
ssize_t write
file int
int mmap
complete definition
ile_operat ions
vfs software
software layer
inode represents
directory file
directory-management algorithms
trade-offs involved
linear list
simplest method
-unused bit
free directory
last entry
freed location
real disadvantage
file requires
linear search
search directory
software cache
hit avoids
average search
substantial amounts
sorted directory
sophisticated tree
tree data
separate sort
sort step
list stores
hash data
value computed
directory search
names hash
major difficulties
linear-probing hash
65th file
directory hash
hash table-say
file narnes
hash-function values
chained-overflow hash
hash entry
individual value
resolve collisions
list lookups
direct-access nature
major methods
allocating disk
nova line
allocation requires
file occupy
contiguous blocks
disk disk
addresses define
linear ordering
accessing block
head movement
last sector
first sector
disk seeks
seeks required
allocated files
finally needed
operatil1.g system
block units
occupies blocks
starting block
area allocated
system remembers
block referenced
immediately access
access block
file start
start length
length count
finding space
system chosen
space determines
management systems
management system
contiguous-allocation problem
general problem
problem discussed
free holes
common strategies
holes simulations
algorithms suffer
free disk
largest contiguous
contiguous chunk
data depending
average file
preventing loss
significant amounts
original disk
contiguous free
contiguous space
large hard
weekly basis
system unmounted
production machines
system operations
best-fit allocation
allocation strategy
file larger
repeated runs
space needed
wasted space
previous space
space exists
system continues
final size
modified contiguous-allocation
contiguous-allocation scheme
amount proves
block count
extent size
setting results
internal fragm.entation
commercial veritas
optimize performance
high-performance replacement
unix ufs
linked allocation
allocation solves
last blocks
user sees
sees blocks
entry ile
first disk
end-of-list pointer
pointer value
empty file
size field
read blocks
free-space list
compact disk
space linked
sequential-access files
pointer requires
disk seek
direct-access capability
linked-allocation files
512-byte block
usual solution
collect blocks
allocate clusters
cluster units
units pointers
smaller percentage
logical-to-physical block
block mapping
improves disk
disk throughput
fewer disk-head
disk-head seeks
free-list management
partially full
full clusters
reliability recall
pointers scattered
disk hardware
wrong pointer
turn result
partial solution
linked lists
schemes require
important variation
disk-space allocation
entry indexed
chain continues
special end-of-file
end-of-file value
unused block
simple matter
previous end-of-file
fat structure
file consisting
start block
fat figure
file-allocation table
fat allocation
significant number
disk head
moves occur
indexed allocation
allocation linked
size-declaration problems
efficient direct
order solves
index block
disk-block addresses
block points
index-block entry
described il1
il1 section
free-space manage1
allocation supports
space indexed
pointer overhead
common case
file jeep
entire index
point raises
issue mechanisms
purpose include
linked scheme
small header
header giving
last word
small file
multilevel index
linked representation
first-level index
second-level index
tum point
desired data
data block
fourth level
desired maximum
maximum file
4,096-byte blocks
four-byte pointers
combined scheme
pointers point
direct blocks
separate index
indirect blocks
first points
single indirect
indirect block
double indirect
last pointer
triple indirect
file exceeds
four-byte file
32-bit file
pointer reaches
pointers pointers
unix inode
indexed-allocation schemes
schemes suffer
storage efficiency
data-block access
important criteria
proper method
allocation method
initial address
application requiring
support direct-access
methods files
desired type
file renamed
renamed indexed
considerable space
two-level index
index-block reads
require reading
needed data
allocation depends
index structure
block desired
systems combine
file grows
grows large
average performance
file-system allocation
allocation algorithm
performance measurements
maximum disk
typical workstation
disk bandwidth
sun made
dma transfer
sun systems
allocation reduced
latency times
disk-reading routines
large clusters
inode structure
left unchanged
substantially improved
cpu speed
disk speed
add thousands
extra instructions
disk-head movements
optimize head
head movements
deleted files
list records
required amount
bit vector
free-space bit
bit map
first free
consecutive free
bit-manipulation instructions
intel family
family starting
motorola family
first bit
powered pcs
macintosh systems
0-valued word
0-value words
features driving
driving software
software functionality
bit vectors
entire vector
smaller disks
512-byte blocks
blocks requires
disk size
constantly increases
special location
block block
frequent action
fat method
method incorporates
free-block accounting
allocation data
separate method
free-list approach
approach stores
linked free-space
standard linked-list
linked-list approach
approach takes
takes advantage
contiguous-allocation algorithm
free contiguous
entry requires
simple disk
extent method
allocating blocks
efficient lookup
space maps
maps sun
huge numbers
file-system hierarchies
resulting data
implemented properly
performance impact
impact conside1
freespace list
freed freeing
entire disk
managem.ent algorithm
zfs creates
manageable size
space map
map zfs
counting algorithm
write count
count structures
log-structured file
system techniques
block activity
zfs decides
balanced-tree structure
in-memory space
accurate representation
metaslab zfs
sil gle
gle entry
transaction-oriented operations
sortmg phase
block requests
zfs satisfies
balanced tree
directorymanagement options
efficient disk
disks tend
major bottleneck
slowest main
main computer
computer component
space depends
disk allocation
directory algorithms
empty disk
space lost
performance results
unix allocation
free-space algorithms
inode block
reduce seek
clustermg scheme
scheme discussed
file-transfer performance
unix varies
cluster size
small clusters
last cluster
require consideration
last write
write date
supply information
access date
section changed
block written
disks occur
accessed files
performance cost
pointer sizes
sizes limit
64-bit pointers
turn make
free-space-management methods
pointer size
allocation size
changing technology
hard drive
ms-dos file
fat entry
disk capacities
capacities increased
larger disks
track blocks
larger file
initial file-system
file-system decisions
efficiency reasons
ms-dos version
system sun
minimum mass
atomic-level storage
trillion kilograms
fixed length
structures included
process table
table sizes
artificial limits
general functionality
file-system algorithms
disk controllers
controllers include
local memory
on-board cache
entire tracks
disk cache
cache starting
tile system
unified buffer
buffer cache
reducing latency
disk controller
sector requests
separate section
page cache
file-system-oriented blocks
blocks cachii
accesses interface
systems-including solaris
xp-use caching
process pages
calls read
memory-mapping call
caches-the page
mapping proceeds
requires caching
waste memory
significant cpu
data movement
corrupt files
cache file
cache caching
manage file-system
caching disk
reasonable general-purpose
general-purpose algorithm
page-caching algorithms
algorithms reveals
algorithm solaris
unused memory
memory versions
allocatmg pages
system performing
caching pages
high rates
reclaimed pages
memory ran
ran low
low solaris
implemented priority
priority paging
cache solaris
fixed limit
file-system page
memory solaris
maximize memory
mmimize thrashing
system occur
asynchronously occur
subsystem receives
asynchronous writes
metadata writes
synchronous operating
required order
systems optimize
access type
pages replaced
lru order
read-ahead removes
waste buffer
subsequent pages
current page
processed retrieving
considerable ancount
track cache
high latency
small transfers
read-ahead remains
remains beneficial
disk drivers
interesting interactions
disk driver
driver sorts
output queue
write data
times optimized
disk rotation
synchronous writes
process writing
process sees
fast writes
large transfers
intuition files
on-disk file-system
free fcb
typical operation
disk directory
free counts
fcb count
fcb compounding
reach disk
varying methods
consistency checking
file-system metadata
metadata change
status bit
metadata complete
bit remains
consistency checker
systems program
free-space-management algorithms
algorithms dictate
allocation system
unix caches
caches directory
synchronous write
recovery algorithms
algorithms described
logging algorithms
consistency -.ilc
-.ilc .ll
resulting implementations
systems note
consistency-checking approach
approach discussed
preceding section
consistency check
directories consistency
human tells
proceed consistency
takes system
check terabytes
recovery techniques
metadata updates
veritas file
log entries
actual filesystem
filesystem structures
committed transaction
circular buffer
older values
separate disk
disk spindle
separate read
write heads
decreasing head
head contention
seek times
structures remain
problem occurs
system crashed
elimil ating
side benefit
disk metadata
updates proceed
on-disk data
performance advantage
costly synchronous
synchronous random
random meta
meta data
synchronous sequential
sequential writes
random writes
significant gain
metadata-oriented operations
file creation
network appliance
overwrite blocks
transaction writes
metadata structures
last update
pointer update
consistency checke1
failure scenarios
metadata corruption
zfs takes
ovative approach
disk consistency
overwrites blocks
correct zfs
data lost
lost forever
disk recovery
copying needed
backup program
last backup
typical backup
backup schedule
backup medium
files changed
day n-1
backup written
previous set
backup media
starting restores
full backup
incremental backups
complete restore
added advantage
backup cycle
deleted file
previous day
medium needed
days back
recent incremental
incremental backup
backups needed
successive incremental
backup involves
user ncay
ncay notice
saved forever
permanent backups
regular backups
cycle reuses
reuses media
media wear
backups network
system nfs
well-implemented client-server
client-server network
software system
accessing remote
unix svr4
svr4 running
sun workstations
interconnecting network
sun implementation
multiple versions
describe version
commonly deployed
overview nfs
nfs views
interconnected workstations
independent machines
independent file
explicit request
transparent manner
manner sharing
server sharing
ensure machine
machine independence
system affects
client machine
remote directory
ml-a client
operation involve
involve mounting
mounted directory
integral subtree
subtree descending
local directory
directory specification
machines named
figure depicts
view users
dirl directory
usr usr
usr figure
longer visible
visible subject
access-rights accreditation
directory diskless
diskless workstations
servers cascading
cascading mounts
nfs implementations
invoked mounting
client access
mount mechanism
transitivity property
honce environment
property permits
heterogeneous environment
network architectures
nfs specification
rpc primitives
primitives built
external data
implementation-independent interfaces
heterogeneous machines
specification distinguishes
actual remote-file-access
remote-file-access services
separate protocols
mount protocol
implement transparent
transparent remote
initial logical
logical connection
protocol functions
operation includes
server machine
machine storing
mount server
specific server
export lists
mount tables
clients recall
accredited machine
component unit
export list
unix terms
handle consists
file-system identifier
inode number
client machines
mounted directories
administrative purposes-for
purposes-for instance
server state
static mounting
mounting preconfiguration
actual mount
protocol includes
return export
procedures support
directory reading
entries manipulating
manipulating links
directories accessing
accessing file
attributes reading
writing files
prominent feature
stateless servers
file identifier
absolute offset
offset inside
resulting design
special measures
crash file
nfs request
sequence number
missing maintaining
server howeve1
server crash
include inconsistent
inconsistent data
stateless-server philosophy
including indirection
status blocks
write blocks
nfs data
data synchronously
consequent performance
lost performance
nonvolatile cache
battery-backed-up memory
controller ackiwwledges
disk write
host sees
fast synchronous
blocks remain
remain intact
disk periodically
single nfs
nfs write
write procedure
write calls
concurrency-control mechanisms
nfs architecture
rpc writes
udp packets
users writing
data intermixed
lock management
nfs nfs
open remote
client initiates
regular system
layer maps
vfs operation
layer identifies
nfs procedure
nfs service
service layer
remote server
file-system operation
actual service
path-name translation
nfs involves
dir1 path-name
component names
separate nfs
nfs lookup
lookup call
directory vnode
n10unt point
component lookup
separate rpc
expensive path-name-traversal
path-name-traversal scheme
target vnode
stateless server
directory-name-lookup cache
side holds
cache speeds
initial path
directory cache
attributes returned
cached vnode
vnode recall
mounted remote
cascading mount
direct client-server
client-server com1ection
desired directory
path-name traversal
original client
client sees
underlying directory
one-to-one correspondence
regular unix
protocol rpcs
nfs adheres
remote-service paradigm
caching techniques
direct correspondence
correspondence exists
remote operation
cached locally
future remote
consistency constraints
file-blocks cache
cached attributes
cached file
attribute cache
attributes arrive
server cached
delayed-write techniques
client clients
free delayed-write
delayed-write blocks
server confirms
conflicting modes
preserved tuning
performance makes
files created
file observe
strict emulation
session sen
sen antics
.ln spite
mechanism make
multi-vendor-distributed system
operation disk
huge impact
implementation command
file sizes
optimization wafl
write-anywhere file
elegant file
system optimized
writes wafl
servers produced
http protocols
large demand
random reads
larger demand
cifs protocols
protocols cache
cache data
read operations
greatest concern
file-server creators
creators wafl
nvram cache
wafl designers
stable-storage cache
front ease
guiding principles
snapshot functionality
read-only copies
describe files
file described
root inode
metadata lives
free-block map
free-inode root
free blotk
blotk map
standard files
metadata files
file systen
wafl creates
existing blocks
inode points
data changed
made-and takes
extra disk
space occupied
snapshot consists
important change
standard file
block nearest
current head
head location
performance optimizations
snapshot facility
copy-on-write copies
provide snapshots
efficiency wafl
wafl snapshots
newer versions
read-write snapshots
read-only snapshot
snapshot captures
clone refers
original snapshot
updated clones
blocks clones
original version
clone deleted
upgrade fails
system implementation
source system
blocks contained
system adds
snapshot repeating
process maintains
up-to-date copy
blocks change
wafl system
disaster recovery
efficient snapshots
control media
single spindle
modular structure
levels deal
devices upper
upper levels
logical properties
intermediate levels
levels map
file concepts
physical device
device properties
upper layers
type uniformly
allocation indexed
increase flexibility
fragmentation indexed
multiple blocks
increase throughput
index entries
entries needed
needed indexing
extents free-space
free-space allocation
include bit
lists optimizations
optimizations include
contiguous area
directory-management routines
damage operating-system
operating-system backup
backup tools
disk loss
system bug
user error
error network
client-server methodology
systems system
network protocols
server networking
multiple-client access
access create
create challenges
fundamental role
systems play
crucial techniques
log structures
ram disk
file systenc
modifed contiguous-allocation
contiguous set
key issue
allocated dynamically
fixed sizes
management scheme
blocks assume
filecontrol block
memory calculate
allocation strategies
contiguous-allocation case
block information
represent files
block requires
direct disk
indirect disk
reinote-file-access protocol
client maintains
caches translations
backup scheme
disk day
subsequent backups
backups copy
files modified
restore operations
operations made
difficult explain
bytes assume
logical-to-physical address
address mapping
blocks long
block accessed
logging metadata
updates ensures
ensures recovery
file-system crash
typical disk
disk devices
base registers
relocate files
files give
system reconstruct
list explain
small local
memory failure
special actions
structure consisting
initial contiguous
overflow area
allocated compare
standard contiguous
linked implementations
com.puter crashes
ms-dos fat
fat system
ibm allocation
bsd unl
discusses optimizations
methods made
coogle file
found workloads
distributed state
networked file
log-structured designs
ext2 file
zfs documentation
internal data
storage structures
physical structure
magenetic disks
disk-scheduling algorithms
disk formatting
boot blocks
damaged blocks
covering disk
disk reliability
stablestorage implementation
including raid
disk platter
flat circular
circular shape
common platter
platter diameters
diameters range
assembly rotation
rotation figure
moving-head disk
disk mechanism
magnetic material
-write head
head flies
arm position
position makes
concentric cylinders
storage capacity
common disk
measured iil
iil gigabytes
drive motor
motor spins
high speed
drives rotate
data flow
disk arm
desired cylinder
desired sector
typical disks
rotational latencies
thin cushion
make contact
disk surface
disk platters
thin protective
protective laye1
magnetic surface
head crash
removable magnetic
plastic case
prevent damage
inexpensive removable
soft plastic
flexible platter
floppy-disk drive
disk transfer
computingf published
published performance
performance numbers
real-world performance
numbers stated
stated transfer
magnetic media
system surface
hard-disk drive
normal hard
capacities measured
including buses
special electronic
electronic processors
computer end
computer places
host controller
controller operates
disk-drive hardware
command disk
built-in cache
fast electronic
electronic speeds
early secondary-storage
thousand times
storage tapes
read-write head
head moving
correct spot
drives tape
tape capacities
built-in compression
effective storage
sdlt tape
tape storage
fire wire
wire refers
interface designed
hard drives
digital video
video cameras
system fire
apple computer
originalfirewire standard
standard provided
provided bandwidth
standard firewire
data rate
original firewire-800
firewire-800 megabits
modern disk
large one-dimensional
one-dimensional arrays
smallest unit
one-dimensional array
disk sequentially
sequentially sector
first track
outermost cylinder
old-style disk
cylinder number
track number
sector number
defective sectors
mapping hides
substituting spare
spare sectors
smne drives
outer zones
track decreases
decreases tracks
outermost zone
innermost zone
drive increases
rotation speed
head moves
data moving
dvd-rom drives
bits decreases
outer tracks
rate constant
technology improves
outer zone
large disks
computers access
access disk
small systems
host-attached storage
storage accessed
typical desktop
bus architecture
similar protocol
sata high-end
high-end workstations
fiber charmel
physical medium
ribbon cable
scsi protocol
protocol supports
devices include
controller card
scsi disk
common scsi
scsi target
unit addressing
raid array
removable media
jukebox sendil
media-changer mechanism
high-speed serial
serial architecture
optical fiber
four-conductor copper
copper cable
24-bit address
large space
switched nature
great flexibility
raid arrays
initiate data
logical data
blocks directed
identified storage
storage units
network-attached storage
data network
clients access
remote-procedure-call interface
windows machines
local-area network
data traffic
networkattached storage
rpc interface
storage-access protocol
scsi device
scsi protocols
access storage
access enjoyed
local host-attached
lower performance
direct-attached storage
storage options
latest network-attached
storage protocol
storage-area network
operations consume
consume bandwidth
large client-server
client-server installations-the
installations-the communication
clients competes
private network
storage protocols
networking protocols
connecting servers
san lies
flexibility multiple
storage arrays
san switch
prohibits access
host sans
include multiple
multiple direct
direct host
host com1.ections
com1.ections sans
expensive ports
common san
san interconnect
emerging alternative
special-purpose bus
architecture named
named infiniband
software support
highspeed interconnection
interconnection networks
hardware efficiently
responsibility entails
network fast
fast access
large disk
bytes transferred
last transfer
request specifies
desired disk
pending requests
disk queue
system chooses
pending request
system make
simplest form
fastest service
head starts
fcfs disk
total head
wild swing
sstf scheduling
requests close
head position
sstf algorithm
algorithm selects
cylinders traversed
sstf chooses
request closest
request queue
closest request
initial head
method results
distance needed
substantial improvement
performance sstf
requests remember
request close
continual stream
wait indefinitely
sstf disk
pending-request queue
queue grows
grows longer
strategy reduces
scan scheduling
servicing requests
servicing continues
scan algorithm
arm behaves
first servicing
applying scan
position assuming
request arrives
request arriving
arm moves
reverses direction
back assuming
uniform distribution
head reaches
heaviest density
scan disk
c-scan scheduling
uniform wait
c-scan moves
return trip
circular list
final cylinder
c-scan disk
c-look disk
described themf
c-scan move
full width
direction immediatelyf
disk versions
disk-scheduling algorithm
disk-scheduling algorithmsf
natural appeal
increases performance
fcfs scan
c-scan perform
heavy load
starvation problem
optimal order
computation needed
optimal schedule
scheduling algoritlunf
algoritlunf howeverf
howeverf performance
performance depends
outstanding request
request thenf
algorithms behave
scheduling requests
disk service
file-allocation method
program reading
allocated file
limited head
indexed fik
include blocks
diskf resulting
greater head
directory structuref
first cylinder
entire width
middle cylinder
width caching
disk-arm movement
separate module
reasonable choice
default algorithm
seek distances
modern disks
rotational latency
average seek
blocks disk
disk manufacturers
controller hardware
hardware built
system sends
service order
disk writes
system robust
system allocated
disk page
application wrote
wrote data
modified inode
disk initialization
bad-block recovery
blank slate
magnetic recording
recording material
store data
low-level formatting
formatting fills
special data
data area
controller writes
value calculated
stored value
calculated numbers
disk sector
error-correcting code
ecc processing
manufacturing process
formatting enables
defect-free sectors
bytes formatting
larger sector
size means
fewer sectors
fewer headers
hold files
first step
operatiltg system
holds user
system stores
iltitial file-system
include maps
initial empty
increase efficiency
systems group
group blocks
larger chunks
fewer random-access
random-access characteristics
systems prefer
raw iio
exact disk
database record
stored raw
running-for instance
program finds
operating-system execution
tiny bootstrap
loader program
full bootstrap
rom instructs
non-fixed location
system ruru1ing
boot process
boot code
drivers bootil1g
bootil1g begins
running code
rom memory
code directs
table listing
system identifies
services mbr
mbr partition
code partition
partition table
table boot
partition figure
bad blocks
moving parts
small tolerances
contents restored
simple disks
ide controllers
handled manually
ms-dos format
format command
command performs
logical formatting
format finds
bad block
allocation routines
normal operation
sophisticated disks
scsi disks
high-end pcs
controller maintains
disk low-level
bad sector
typical bad-sector
bad-sector transaction
controller calculates
special command
scsi controller
system requests
replacement sector
controller note
spare cylinder
spare sector
sector slipping
slipping remaps
sectors front
lost soft
soft errors
block data
unrecoverable howeverf
howeverf results
lost data
th.at block
backup tape
intervention swapping
setting occurs
memory reaches
low point
implement swapping
fashion rathel
swap pagesf
terms swapping
paging interchangeablyf
interchangeablyf reflecting
low-level task
memory accessf
decreases system
main goal
operating systemsf
systemsf depending
instancef systems
process imagef
imagef including
data segments
segments paging
store pages
physical memoryf
space requiredf
system runs
abort processes
overestimation wastes
wastes disk
systems recommend
space solarisf
examplef suggests
setting swap
memory exceeds
pageable physical
past linux
linux community
multiple swap
swap spaces
separate disks
swap-space location
normal file
normal file-system
file-system routines
inefficient navigating
diskallocation data
structures takes
disk accesses
swapping times
forcing multiple
multiple seeks
process image
block location
location information
special tools
swap file
structures remains
separate swap-space
swap-space storage
algorithms optimized
raw-partition approach
approach creates
disk partitioning
partitioning adding
space requires
involves moving
file-system partitions
raw partitions
space linux
kernel started
copied entire
disk regions
memory unix
pagiltg hardware
designers changed
unix methods
improve efficiency
technological developments
text-segment pages
includes memory
uninitialized data
biggest change
allocates swap
first created
swap partition
file swap
swap map
modern computers
anonymous memory
processes linux
swap areas
swap area
regular file
raw-swap-space partition
area consists
swapped pages
.u1.2.p-an array
integer counters
page slot
swapped page
counter ij.l.dicates
system presents
presents opportunities
setup offers
redundant information
disk-organization techniques
reliability issues
raids composed
cheap disks
cost-effective alternative
expensive disks
higher reliability
higher data-transfer
economic reasons
specific single
structuring raid
raid raid
raid storage
raid flmctionality
intelligent host
control multiple
standalone unit
standard ata
ata scsi
common setup
raid functionality
raid-protected disks
raid software
software layers
flexibility disk
fail suppose
disk failure
high rate
extra information
lost information
disk fails
introducing redundancy
logical disk
disk consists
mirrored volume
volume fails
failed disk
volume-where failure
data depends
individual disks
mirrored disk
disk failures
valid power
natural disasters
manufacturing defects
correlated failures
disks age
failure grows
n1.irrored-disk systems
singledisk systems
systems power
power fails
write-back cache
error protection
parallel access
disks improves
improves performance
disk mirroring
single-disk system
striping data
write bit
normal size
access rate
disk participates
disk bit-level
bit-level striping
bit level
block-level striping
common parallelism
main goals
small accesses
page accesses
balancing reduce
large accesses
raid levels
levels mirroring
high reliability
expensive striping
high data-transfer
data-transfer rates
numerous schemes
provide redundancy
lower cost
disk striping
parity bits
cost-performance trade-offs
error-correcting bits
non-redundant striping
mirrored disks
memory-style error-correcting
error-correcting codes
bit-interleaved parity
block-interleaved parity
distributed parity
redundancy figure
cases depicted
extra disks
recovery raid
raid level
disk arrays
raid ievell
ievell raid
raid level1
level1 refers
mirroring figure
mirrored organization
raid level2
level2 raid
memory-style error-correctingcode
organization memory
parity bit
byte set
stored parity
computed parity
single-bit errors
menwry system
error-correcting schemes
schemes store
extra bits
single bit
eighth bit
error-correction bits
disks labeled
disks fails
remaining bits
damaged data
data note
overhead raid
unlike memory
single parity
error correction
missing bit
raid level3
disks required
one-disk overhead
storage overhead
parity disk
regular disks
mirror disk
n-way striping
level3 supports
overhead results
slower writes
non-parity raid
arrays include
dedicated parity
parity hardware
controller offloads
parity computation
make parity
parity raid
caching array
array doing
doing parity
non-caching non-parity
raid level4
parity block
block read
read accesses
multiple read
large reads
large writes
high transfer
small independent
independent writes
operatingsystem write
single write
write requires
blocks wafl
set seamlessly
added disks
parity value
correct raid
levels raid
spreading data
disks stores
nth block
nth blocks
store parity
potential overuse
common parity
raid system
system raid
stores extra
redundant data
failures raid
disks needed
equivalent stripe
failure figure
raid option
mirrored pairs
theoretical advantages
entire stripe
numerous variations
basic raid
raid schemes
schemes described
exact definitions
volume-management software
storage hardware
full raid
raid solution
solution parity
host bus-adapter
storage array
smaller volumes
volumes arrays
multiple connections
features raid
interconnect layer
disk virtualization
virtualization devices
device sits
manages access
separate storage
automatic duplication
separate sites
recovery replication
synchronous replication
asynchronous replication
written periodically
primary site
site fails
distance limitations
features differs
differs depending
san intercom1ect
raid implementations
hot spare
spare disk
case disk
mirrored pair
pair fail
replaced allocating
designers choose
continuous supply
rebuild performance
performance influences
failure rebuild
performance varies
rebuild data
disk rebuild
rebuild times
disk sets
sets raid
high-performance applications
critical raid
fast recovery
small databases
inserv storage
array im1ovation
expensive solutions
previous technologies
specific raid
chunklets ram
chunklet level
volumes inserv
inserv snapshots
mount copies
host makes
original size
change requires
copying data
configure inserv
host starts
unused disks
original logical
logical level
fixed storage
systems noticing
drives needed
high space
space overhead
large volumes
data level6
including arrays
wireless systems
raid structures
recover data
short units
parity unit
tape-drive robots
multiple tape
stripe data
incomplete writes
corrupt data
raid protects
media errors
software errors
hardware bugs
potential perils
solaris zfs
innovative approach
data zfs
zfs maintains
internal checksums
checksummed rathel
correct checksum
incorrect checksum
checksumming takes
takes places
zfs structures
raid disk
checksum calculation
extra block
read-modify-write cycles
twenty disks
disks divided
separate data
zfs checksums
five-disk raid
properly allocated
requirements change
array allowed
entire set
large raid
volume managers
issue described
above-mismatched file-system
file-system sizes
file-system growth
change sizes
zfs combines
volume management
unit providing
greater functionality
traditional separation
zfs file
entire pool
pool zfs
memory model
release storage
resize volumes
volumes zfs
system owner
traditional volumes
zfs model
pooled storage
zfs pool
required information
damaged state
correct value
write results
partial failure
failure occurred
total failure
write started
previous data
data values
disk remain
consistent state
output operation
first physical
first write
write completes
block declare
operation complete
completes successfully
detectable error
error exists
blocks differ
procedure ensures
failure destroys
arrays add
add nvram
considered part
storage writes
greatly improved
disk sealed
sealed inside
inexpensive disks
inexpensive cartridges
drive lowers
low cost
tertiary-storage devices
common examples
rewritable cds
tertiarystorage devices
removable devices
flash memory
usb interface
storage floppy
flexible disk
disk coated
protective plastic
common floppy
similar technology
recording stuface
greater risk
removable disk
records data
rigid platter
platter coated
recording technology
magneto-optic head
protective layer
arrangement makes
magneto-optic disk
magnetic field
room temperature
head flashes
laser beam
tiny spot
laser heats
weak magnetic
tiny bit
magnetic fields
drive reads
laser light
magnetic spot
rotated clockwise
head detects
special materials
bright spots
amorphous state
crystalline state
reflective layer
phase-change drive
low power
medium power
recording medium
high power
re-recordable cd-rw
worm disk
thin aluminum
aluminum film
film sandwiched
plastic platters
small hole
burning holes
alter data
ecc code
additions worm
worm disks
metal layer
protective glass
newer write-once
write-once technology
technology records
organic polymer
polymer dye
aluminum layer
dye absorbs
absorbs laser
form marks
recordable cd-r
dvd-r read-oniv
data prerecorded
nonremovable counterparts
writing process
removable medium
tape holds
disk cartridge
cartridge tape
similar transfer
rewind operation
takes tens
typical tape
tape cartridge
equivalent capacity
economical medium
fast random
access tapes
backup copies
large supercomputer
supercomputer centers
enornwus volumes
scientific research
commercial enterprises
large tape
tape installations
robotic tape
tape changers
move tapes
storage slots
tape library
mechanisms give
computer automated
automated access
tape cartridges
diskresident file
on-line magnetic
off-line tapes
tapes sitting
storage room
future technology
storage technologies
economics change
technologies evolve
solid-state disks
drive depending
memory technology
affects performance
performance nonvolatile
nonvolatile ssds
traditional hard
lower capacity
larger hard
shorter life-spans
hold metadata
requires high-performance
journaling file
system ssds
notebook computers
energy efficient
promising storage
storage technology
holographic photographs
special media
three-dimensional array
pixel represents
extremely high
continued development
holographic storage
commercially viable
active research
fabrication technologies
electronic chips
small datastorage
datastorage machines
proposal calls
tiny disk
disk heads
square centimeter
magnetic storage
storage material
material suspended
moved lengthwise
head accesses
linear track
shifted sideways
nonvolatile data-storage
data-storage technology
semiconductor dram
major jobs
machine abstraction
raw device
system queues
interleaved requests
application interface
fixed disks
blank cartridge
disk tapes
handled differently
raw storage
application exits
tape device
exclusivity makes
makes sense
interleaving random
random accesses
application makes
ascii form
files written
tape locate
specific logical
entire track
track locating
filled tape
empty space
written area
formatting process
empty sectors
final positions
variable block
defective tape
bad area
operation explains
area -the
-the positions
tape head
relative motion
operation space
locate backward
side effect
effect means
append-only devices
drive implements
drive refuses
eot mark
start writing
writing doing
append-only property
fixed disk
molmt table
table enables
removable cartridge
serial number
removable device
serial numbers
12-digit serial
removable drive
store bytes
binary numbers
name-space problem
problem unsolved
music cds
universal format
drive data
data cds
operating-system device
comn1on formats
formats dvd
dvd fonnats
hierarchical storage
human assistance
computer instructs
jukeboxes hold
hold tens
arms managing
system extends
primary memory
straightforward manner
long delay
files remain
file-archiving systems
file continues
longer occupy
occupy space
operation returns
disk-resident copy
data today
current work
hsm includes
data move
sites save
hsm tape
tape ilm
ilm centralizes
centralizes knowledge
tertiary-storage performance
average data
bytes divided
sustained bandwidth
data stream
effective bandwidth
rate provided
tlce bandwidth
bandwidth ranges
fastest tapes
similar range
performance measure
tapes disk
selected cylinder
tape wound
tape requires
tape reels
selected block
block reaches
access latency
significantly higher
stop spinning
robotic arm
disk cartridges
switching disks
jukebox incurs
slow tape
tape jukebox
disk jukebox
switching tapes
expensive tape
random item
pay attention
terrible bottleneck
bandwidth-to-storage-capacity ratio
robotic library
storage results
cheap cartridges
cartridges share
expensive drives
removable library
good pe1jormance
pe1jormance means
media failure
practical purposes
infinitely small
removable n1.ag
netic disks
harmful environmental
environmental conditions
mechanical forces
transparent plastic
glass layer
tape varies
inexpensive drives
drives wear
out tapes
magnetic-disk head
magnetic-tape drive
weak spot
close contact
scrubbing action
fixed-disk drive
optical-disk drive
data cartridge
cartridge unharmed
cost storage
cost suppose
magnetic platters
total price
removable storage
low price
removable cartridges
cartridges figures
show cost
cost trends
dram memory
magnetic hard
lowest prices
prices found
computer magazines
prices reflect
smallcomputer marketplace
minicomputer markets
2oos year
year figure
huge tape
dram fluctuates
fluctuates widely
price crashes
excess production
production caused
marketplace caused
sigrtificant price
price increases
price decline
tape-drive prices
inexpensive tape
dramatic fall
mid-range tape
tape technology
in.expensive drives
tracking prices
small-computer marketplace
small computers
fallen dramatically
storage improved
magnitude main
memory today
megabyte dropped
medium-sized tape
tape libraries
higher storage
disk prices
storage obsolete
revolutionary technology
technology breakthrough
enormous tape
practical storage
disk farms
farms disk
major secondary-storage
n1.agnetic tapes
tapes modern
size disks
network cmmection
disk-schedliling algorithms
disk-queue ordering
ordering performance
fragmented files
move blocks
fragmentation defragmenting
fragmented file
reduced performance
progress sophisticated
sophisticated file
unix fast
control fragmentation
disk reorganization
hardware-new disks
efficient swap
systems dedicate
storage required
large systems
raid algorithms
continued operation
automatic recovery
failure raid
multiple nonvolatile
stable data
magneto-optic disks
full services
including space
requestqueue scheduling
specific cartridge
raw interface
built-in support
jukeboxes jukebox
privileged application
application designed
random-access latency
disk switching
switching cartridges
low ratio
large fraction
optical media
sensitive layer
transparent coating
areal density
square inch
sequential-access medium
random-access medium
access depends
transfer size
term streaming
streaming transfer
rate denotes
effective transfer
total bytes
total seconds
including overhead
latency suppose
disk described
rate calculate
transfer sizes
performance figures
smallest transfer
acceptable utilization
random-access device
______ bytes
sequentialaccess device
s1naller transfers
minimum transfer
give acceptable
sequential-access device
hour mtbf
drive failure
disk farm
thousand years
mortality statistics
u.s resident
mtbf hours
expected lifetime
manufacturer guarantees
tape-resident file
system assume
eot marks
read position
position commands
drive costs
cartridge holds
square black-and-white
black-and-white picture
pixel stores
millisecond answer
device affect
term fast
fast wide
wide scsi-ii
scsi-ii denotes
scsi bus
device suppose
scsi-ii disk
drive spins
sustained transfer
adjacent-cylinder seek
accurate estimate
huge transfer
milliseconds estimate
random-access workload
individual sectors
multiple requests
seek distance
distance suppose
8-kilobyte pages
algorithm reduces
operations achieved
level1 organization
previous request
fifo order
total distance
elementary physics
physics states
constant acceleration
constant rate
seek assume
adjacent cylinder
full-stroke seek
moves explain
square root
total seek
smallest total
percentage speedup
fastest schedule
accelerating seek
seek described
hard-disk drives
disks manufactured
fixed rate
rate suppose
constant-rate seek
constantacceleration seek
additional cylinder
seek-time function
fastest scb.edule
average rotational
one-sided 5.25-inch
5.25-inch optical-disk
optical-disk cartridge
inch wide
feet long
long calculate
storage capacities
media suppose
optical tape
tape exists
physical size
storage density
tape hold
marketable price
tape cost
algorithms discussed
modify sstf
include latency
latency optimization
sector sparing
influence perfonnance
perfonnance suppose
bad sectors
random locations
cylinder estimate
workload consisting
kilobyte reads
relative advantages
performance depend
disk-scheduling disciplines
modify algorithms
ensure fairness
important goal
organization comprising
disks stored
continuous blocks
tapes describe
additional features
applications sharing
special properties
disk-resident explain
disk affect
hard-disk scheduling
simple estimates
terabyte storage
system made
storage suppose
disk holds
library costs
seconds compute
total cost
maximum total
total data
pure disk
library handles
mixed configuration
configuration comprising
comprising disks
disks organized
raid levell
levels disks
disks assume
disk organization
tradeoffs involved
rereading code
system versus
uniformly distributed
file-system fat
files suppose
case explain
hot spot
fil1.d data
indirection table
unix describe
improve disk
disk performance
accurate information
system improve
improve file
throughput achieved
levels organization
levell organization
single blocks
organization achieve
nonredundant striping
redundant arrays
independent disks
detailed survey
disk-system architectures
early comparative
comparative analysis
cylinders crossed
good choice
queue lengths
describes ways
disk ann
idle seltzer
scheduling optimizations
exploit disk
idle times
negligible performance
defect management
hot data
improve seek
accurate performance
performance model
drive worthington
low-level disk
disk properties
zone structure
disk power
power management
considerable influence
numerous interesting
interesting workload
workload characteristics
created files
short mckusick
sophisticated techniques
workloads mcvoy
basic ffs
ffs quinlan
worm storage
file-system approach
storage maher
thirty years
mathematical approach
hierarchy alt
tertiary-storage access
supercomputing environment
environment benjamin
massive storage
eosdis project
nasa management
network-attached disks
topic dating
emerging storage
electron trapping
trapping toigo
in-depth description
potential future
future storage
main jobs
main job
related topics
hardware interface
interface places
places constraints
internal facilities
system bridges
streams mechanism
assemble pipelines
driver code
code dynamically
performance aspects
devices connected
major concern
cd-rom jukebox
varied methods
methods form
technology exhibits
conflicting trends
increasing standardization
hardware interfaces
trend helps
improved device
device generations
existing computers
broad variety
previous devices
software techniques
hardware elements
device-driver modules
uniform deviceaccess
deviceaccess interface
calls provide
standard interface
computers operate
general categories
transmission devices
network cards
human-interface devices
military fighter
fighter jet
space shuttle
flight computer
foot pedals
computer sends
sends output
output commands
move rudders
incredible variety
device communicates
sending signals
connection point
serial port
common set
defined protocol
electrical voltages
voltages applied
defined timings
daisy chain
bus buses
signaling methods
connection methods
bus structure
processor-memory subsystem
fast devices
slow devices
usb ports
upper-right portion
bus plugged
common buses
main parts
computer include
serial-port controller
simple device
structure wires
bus controller
separate circuit
circuit board
private memory
protocol messages
built-in controllers
board attached
disk side
bad-sector mapping
processor give
give commands
short answer
control signals
processor communicates
writing bit
instruction triggers
triggers bus
bus lines
proper device
move bits
device register
standard data-transfer
data-transfer instructions
graphics controller
basic control
control operations
large memory558
memory558 chapter
interrupt controller
game controller
hard-disk controller
parallel port
diskette-drive controller
port locations
mapped region
screen contents
memory-mapped region
controller generates
screen image
image based
writing millions
graphics memory
issuing millions
common type
software fault
incorrect pointer
unintended region
memory-mapped device
accidental modification
protected memory
memory helps
send output
current command
data-in register
device error
port chooses
half-duplex communication
bit enables
enables parity
parity checking
bit sets
word length
bits select
speeds supported
data registers
fifo chips
output data
fifo chip
small burst
complete protocol
basic handshaking
handshaking notion
producer-consumer relationship
busy bit
status register
bit means
controller sets
busy working
host signals
command-ready bit
command register
host sets
host writes
writes output
data-out register
controller notices
controller reads
write command
controller clears
error bit
small buffer
host waits
cpu-instruction cycles
basic polling
polling operation
cpu processing
processing remains
remains undone
hardware mechanism
cpu device
driver initiates
cpu executing
executing checks
instructions cpu
resumes processing
interrupted task
basic interrupt
mechanism works
cpu senses
cpu detects
cpu performs
fixed address
handler determines
interrupt instruction
execution state
controller raises
request line
cpu catches
handler clears
device figure
mechanism enables
asynchronous event
sophisticated interrupthandling
interrupthandling features
critical processing
proper interrupt
first polling
multilevel interrupts
low-priority interrupts
request lines
unrecoverable memory
memory errors
interrupt line
critical instruction
instruction sequences
maskable interrupt
request service
mechanism accepts
specific interrupt-handling
interrupt-handling routine
small set
vectored interrupt
single interrupt
address elements
interrupt chaining
vector points
huge interrupt
interrupt table
handler figure
pentium processor
device-generated interrupts
high-priority interrupt
low-priority interrupt
system interacts
system probes
hardware buses
controllers raise
raise interrupts
interrupts signify
input data
nonexistent memory
trigger interrupts
common property
self-contained routine
efficient hardware
software mechanism
processor state
into-detected overflow
overflow bound
bound range
range exception
exception invalid
invalid opcode
opcode device
double fault
fault coprocessor
coprocessor segment
segment overrun
invalid task
task state
state segment
segment segment
present stack
stack fault
fault general
general protection
protection page
intel reserved
floating-point error
error alignment
alignment check
check machine
machine check
maskable interrupts
interrupts figure
processor event-vector
event-vector table
table calls
privileged routine
memory paging
interrupt suspends
page-fault handler
handler saves
wait queue
performs page-cache
page-cache management
resume execution
library calls
routines check
special instruction
desired kernel
kernel service
interrupt hardware
hardware saves
supervisor mode
low interrupt
interrupt priority
priority compared
queue overflows
loses data
data interrupts
processing required
copy data
user buffer
handlers implen
implen ents
high-priority handler
handler records
high-priority work
handler completes
kernel buffers
application space
threaded kernel
kernel architecture
implement multiple
multiple interrupt
interrupt priorities
background processing
application routines
high priorities
priorities give
handlers precedence
application code
kernel housekeeping
priority relationships
solaris thread
thread scheduler
preempt lowpriority
lowpriority interrupt
threaded implementation
implementation enables
enables multiprocessor
multiprocessor hardware
handlers concurrently
asynchronous events
supervisor-mode routines
urgent work
priorities device
hardware faults
trigger kernel
kernel routines
time-sensitive processing
efficient interrupt
good system
expensive general-purpose
general-purpose processor
watch status
status bits
feed data
controller register
time-a process
process termed
computers avoid
main cpu
special-purpose processor
dma command
command block
controller proceeds
placing addresses
perform transfers
simple dma
standard component
high-speed dma
dma hardware
hardware handshaking
controller places
dma-request wire
desired address
memory-address wires
iia -acknowledge
-acknowledge wire
controller receives
dma-acknowledge signat
dma-request signal
entire transfer
controller interrupts
controller seizes
secondary caches
cpu computation
data-transfer work
total system
perform mercwry
undergo translation
addresses dvma
memory-mapped devices
protected-mode kernels
prevents processes
issuing device
device commands
commands directly
discipline protects
protects data
access-control violations
system exports
exports functions
privileged process
access low-level
underlying hardware
access device
controllers directly
avoid kernel
kernel communication
protect memory
malicious applications
controller transfers
transfers bytes
increasing memory
transfer disk
driver tells
dma interrupts
interrupts cpu
signal transfer
transfer completion
.2-j rc-c
controller initiates
initiates dma
transfer cg
controller sends
controller figure
hardware summary
electronics-hardware design
operating systen
handshaking relationship
polling loop
devices poses
operating-system implementers
control-bit definitions
system give
structuring techniques
complex software-engineering
software-engineering problems
involves abstraction
software layering
detailed differences
general kinds
standardized set
standard interfaces
interfaces figure
device-driver layer
generic classes
hide hardware
hardware differences
applications making
subsystem independent
hardware simplifies
operating-system developer
hardware manufacturers
existing host
controller interface
write device
structure operating
operating-system vendor
develop support
support code
code unfortm1ately
device-hardware manufacturers
multiple device
device drivers-for
drivers-for instance
solaris devices
character-stream device
device transfers
block device
sequential device
fixed order
order determined
storage locations
synchronous device
device performs
performs data
asynchronous device
device exhibits
unpredictable response
sharable device
dedicated device
operation device
device speeds
speeds range
devices perform
transfer direction
direction access
method transfer
transfer schedule
synchronous asynchronous
asynchronous dedicated
dedicated sharable
sharable latency
latency seek
rate delay
operations read
read-write tape
tape keyboard
keyboard tape
keyboard cd-rom
cd-rom figure
application access
conventional types
resulting styles
broadly applicable
exact system
device categories
fairly standard
major access
access conventions
conventions include
include block
network sockets
sockets operating
additional devices
time-of-day clock
graphical display
arbitrary conunands
call enables
device managed
commands implemented
arbitrary data
control information
character devices
accessing disk
block-oriented devices
understand commands
essen.tial behaviors
block-storage devices
low-level differences
special applications
databasemanagement systems
simple linear
application performs
file systen1
unneeded buffering
buffering likewise
operating-system locking
locking services
raw-device access
access passes
passes control
system step
unix world
block-device drivers
offering read
memory-mapped interface
memory returns
satisfy access
offer virtual
mapping interface
kernel services
entry address
kernel access
interface enable
line-at-a-time access
editing services
user types
preceding character
input devices
produce data
access style
audio boards
linear stream
network devices
addressing characteristics
wall socket
electrical appliance
socket interface
local socket
remote address
socket created
receive packets
returns information
packet waiting
functions encapsulate
essential behaviors
distributed applications
underlying network
network hardware
protocol stack
interface card
long history
proving ground
network technology
half-duplex pipes
full-duplex fifos
full-duplex streams
sockets information
appendix a.9
hardware clocks
trigger operation
timesensitive applications
trigger operations
periodic interrupts
periodic flushing
dirty cache
cache buffers
network subsystem
cancel operations
network congestion
timer requests
timer hardware
hardware chan11els
virtual clocks
timer device
interrupts wanted
earliest-time-first order
earliest tince
kernel signals
interrupt rate
rate generated
execute hundreds
coarse resolution
timer ticks
system time-of-day
highfrequency counter
highresolution clock
generate interrupts
accurate measurements
interface relates
application issues
call completes
values returned
physical actions
actions performed
unpredictable amount
blocking application
nonblocking application
user-level processes
mouse input
displaying data
video application
application writer
overlap execution
multithreaded application
continue executing
solaris developers
user-level library
nonblocking call
nonblocking system
asynchronous system
asynchronous call
application continues
software interrupt
call-back routine
linear control
control flow
nonblocking read
available-the full
full number
bytes requested
asynchronous read
call requests
nonblocking behavior
call takes
network activity
kernel user
user kernel
introduces extra
multiple-read call
desired reads
completes kernels
kernels provide
services related
device reservation
devicedriver infrastructure
errant processes
malicious users
requests means
good order
applications issue
choice scheduling
share device
illustrate suppose
issue blocking
blocking read
read calls
disk application
ann travels
scheduling operating-system
operating-system developers
developers implement
scheduler rearranges
table system
application receives
poor service
give priority
priority service
delay-sensitive requests
kernel manages
subsystem improves
memory area
stores data
application buffering
speed mismatch
stream suppose
main mernory
bytes received
entire buffer
additional incoming
incoming data
modem fills
first buffer
relaxing timing
timing requirements
enormous differences
typical computer
provide adaptations
data-transfer sizes
computer networking
sending side
small network
network packets
receiving side
side places
reassembly buffer
source data
support copy
copy semantics
semantics suppose
systemcalt providing
data written
application system
calt independent
guarantee copy
bus hype
l.i band
sun enterprise
device-transfer rates
kernel buffer
application buffer
effect copying
application data
operation introduces
clean semantics
copy-on-write page
page protection
holds copies
cached copy
cached ilc
primary caches
existing copy
distinct functions
preserve copy
efficient scheduling
maill memory
hold disk
reread rapidly
kernel receives
efficient write
write schedules
delayilcg writes
holds output
ilcterleaved data
data streams
output mixed
system solves
application finishes
spooling system
correspondilcg spool
spool file
system copies
queued spool
spool files
system daemon
daemon process
in-kernel thread
control interface
unwanted jobs
jobs print
suspend printing
multiple concurrent
applications spooling
coordinate concurrent
concurrent output
concurrent device
explicit facilities
exclusive device
idle device
systems enforce
provide functions
device object
avoid deadlock
error handling
application errors
complete system
usual result
mechanical glitch
glitch devices
transient reasons
permanent reasons
defective operating
transient failures
failure results
network send
error results
res end
important component
component experiences
permanent failure
additional integer
named errno
error code-one
general nature
bad pointer
detailed error
current operating
hardware error
illegal request
bad command
command parameter
self-test failure
hardware subsystem
subsystem failed
scsi devices
devices maintain
internal pages
error-log information
host-but seldom
protection errors
prevent users
system perform
monitor mode
monitor kernel
kernel perform
program figure
port memory
user access
memory-protection system
system note
graphics games
video editing
playback software
memory-mapped graphics
controller memory
case provide
in-kernel data
table structure
track network
character-device communications
activities unix
file-system access
raw devices
entities supports
semantics differ
request size
sector boundary
uniform structure
object-oriented teclucique
open-file record
file-system record
inode pointer
write functions
select function
ple pointer
ioctl function
function file
descriptor .,_
close function
user-process memory
memory networking
v. pointer
network info
function pointer
f..un ction
structure figure
holds pointers
object-oriented methods
message-passing implementation
message contents
message-passing approach
procedural techniques
adds flexibility
subsystem summary
subsystem coordinates
extensive collection
subsystenc supervises
devices access
devices operation
operation control
allocation device
device allocation
device-status monitoring
recovery device-driver
device-driver configuration
subsystem access
uniform interface
system connects
application request
network wires
specific disk
application refers
file-system directories
file-access table
entry tells
space-allocation information
connection made
hardware port
memory-mapped controller
controller registers
simple operating
first part
primary hard
specific port
device table
colon separator
separation makes
extra functionality
invoke spooling
provided automatically
levels names
devices unix
unix represents
represents device
device names
unix path
device portion
device unix
associates prefixes
longest ncatchilcg
ncatchilcg prefix
file-system directory
minor device
m.ajor device
number identifies
device-table entry
memory-mapped address
controller modern
systems obtain
significant flexibility
multiple stages
lookup tables
pass requests
load device
typical life
figure suggests
operation requires
tremendous number
opened previously
system-call code
subsystem sends
driver depending
subroutine call
in-kernel message
driver allocates
allocates kernel
driver sends
sends commands
device hardware
transfer completes
correct interrupt
handler receives
interruptvector table
driver receives
kernel transfers
return codes
call device-controller
device-controller commands
commands user
process kernel
subsystem kernel
subsystem device
driver interrupt
handler device
controller return
call interrupt
request moving
queue unblocks
scheduler assigns
call unix
interesting mechanism
full-duplex connection
stream user
streams structure
driver end
write queue
queue message
modules provide
streams processing
serial-port device
handle input
input editing
adjacent modules
adjacent queue
flow control
queue accepts
adjacent module
queue supporting
supporting flow
control buffers
buffers messages
accept messages
sufficient buffer
process involves
involves exchanges
control messages
call writes
writes raw
raw data
stream head
head copies
messages continues
reads data
ordinary data
unstructured byte
byte stream
process communicates
flow controt
message likewise
driver end-like
data drivers
support flow
dropping incoming
network card
input buffer
ample buffer
store incoming
incremental approach
writing device
protocols modules
networking module
ethernet network
wireless network
treating character-device
message boundaries
unix variants
variants support
support streams
preferred method
writing protocols
socket mechanism
heavy demands
device-driver code
schedule processes
resulting context
switches stress
hardware caches
interrupt-handling mechanisms
data copies
durilcg copies
space coping
major concerns
computer architect
expensive task
state change
restore state
state programmed
cycles spent
full overhead
switch network
high context-switch
context-switch rate
remote login
character typed
remote machine
keyboard interrupt
local kernel
network layers
network packet
network device
driver transfers
network controller
hardware receives
network daemon
daemon identifies
login session
state switches
receiver echoes
approach doubles
developers reimplemented
in-kernel threads
threads sun
sun estimates
improvement sending
sending system
system receiving
receiving system
lntercomputer communications
network logins
large server
interrupt burden
remote terminals
large computer
special-purpose cpu
cpu found
high-end systems
data flowing
cpu remains
dma controllers
controllers found
smaller computers
sophisticated programs
switches reduce
application reduce
smart controllers
increase concurrency
dma-knowledgeable controllers
simple data
cpu move
move processing
processing primitives
bus operation
operation balance
balance cpu
mouse movements
button clicks
numeric values
mouse device
disk device
write request
coordinated set
data-recovery algorithms
optimize disk
application software
progression depicted
application level
application bugs
developing code
reload device
application-level implementation
internal kernel
device code
device functionality
functionality progression
progression kernel
kernel functionality
efficient in-kernel
in-kernel messaging
application-level algorithm
development effort
complex software
in-kernel implementation
avoid data
data corruption
highest performance
specialized implementation
implementation include
fixing bugs
increased development
decreased flexibility
hardware raid
raid controller
individual block
block reads
special information
elements involved
moving data
kernel module
basic categories
including block
block devices
programmed interval
interval timers
asynchronous calls
num.erous services
character-string names
device addresses
bus controllers
separate device
ms-dos streams
data passing
layers imply
protection boundary
applications assume
timer channels
device control
control registers
host processor
separate pieces
first piece
piece executes
remaining piece
single serial
front-end processor
termii1.al concentrator
performance overhead
manipulating shared
object-oriented message
components discuss
programs access
access men10ry
processor iterates
busy-waiting loop
interrupt describe
hybrid strategy
device service
pure polling
pure interrupts
multitasking operating
device preallocation
graphics card
direct bus
bus connection
give reasons
reliable transfer
streams abstraction
controllers support
support direct
design complicate
speed increases
multiple interrupts
serviced discuss
assigning priorities
implement nonblocking
good overview
unix leffler
methods employed
sample minix
minix operating
includes detailed
memory-mapping functionality
processor reference
reference manuals
sources hennessy
describe multiprocessor
cache-consistency issues
issues tanenbaum
describes hardware
low level
ieee computer
software raga
good discussion
streams part
mechanisms control
access permitted
resources protection
security ensures
system users
security system
system prevents
prevents unauthorized
protection refers
protection security
security assurance
protection domains
protection systems
grown protection
multiprogramming operating
untrustworthy users
common logical
common physical
modern protection
protection concepts
complex system
intentional violation
access restriction
general importance
program component
ways consistent
stated policies
reliable system
malfunctioning subsystem
policies governing
governing resource
protection system
policies policies
guard resources
resources created
application subsystem
application designers
protection software
software note
policies mechanisms
mechanisms determine
policies decide
general mechanisms
mechanisms enables
guiding principle
principle simplifies
simplifies design
system consistent
time-tested guiding
security guard
public areas
minimal damage
privilege implements
minimum damage
n1inimum damage
gain maximum
maximum privileges
access controls
enable privileges
audit trails
privileged function
function access
audit trail
systems administrator
law-enforcement officer
security activities
system managing
managing users
privilege entails
entails creating
separate account
mount tapes
files needed
role-based access
functionality computers
computers implemented
computing facility
running specific
specific remote
remote hosts
specific times
control lists
secure computing
complex protection
security holes
wrong aspects
areas vulnerable
meaningful operations
operations objects
execute memory
read tape
rewound data
program files
need-to-know principle
faulty process
invokes procedure
chapter14 allowed
well-defined subset
listing file
private files
optimization purposes
privilege discussed
security violations
domain structure
process operates
domain defines
object domains
print object
execute object
dynamic protection
static protection
reason stems
changed content
domain content
accessed depends
user domain
domain switching
switching occurs
process domain
accessed corresponds
variables defined
procedure domain
discuss domain
greater detail
standard dual-mode
monitor-user mode
nonprivileged instructions
modes protect
monitor domain
elaborate scheme
operating systems-unix
user switching
domain corresponds
identification temporarily
owner identification
domain bit
setuid bit
user executes
file owned
temporary userid
userid change
change ends
change domains
user ids
domain definition
privileged facility
general user
user population
networking programs
networking program
access privilege
powerful user
user manages
setuid mechanism
place privileged
privileged programs
special directory
program run
setuid programs
crackers create
obscure file
special techniques
privileged facilities
sends requests
great care
writing privileged
total lack
frequently successful
setuid feature
discuss security
mul tics
ring structure
ring corresponds
single domain
domain rings
rings exist
monitor-user n1ode
mode corresponds
segmented address
segm.ent description
description includes
ring number
access bits
control reading
current-ring-number counter
multics ring
cmmot access
segment domain
multics occurs
process crosses
controlled mmmer
controlled domain
ring field
access bracket
gates identifies
current ring
system occurs
fewer privileges
designated entry
limited access
call procedures
lower rings
requirement means
multics protection
protection interferes
process students
similar protection
number crunching
utmost importance
protection policy
simple protection
protection depending
separate mechanism
general model
matrix represent
represent domains
columns represent
represent objects
matrix consists
column defines
defines objects
access right
entry access
matrix shown
objects-three files
laser printer
read files
access-matrix scheme
mechanism consists
read execute
read write
write figure
semantic properties
outlined hold
access-matrix entries
implement policy
decisions involve
last policy
user creates
initialization entries
implementing strict
strict control
dynamic association
control domain
including domains
operations processes
d2 allowing
allowing controlled
controlled change
entries requires
additional operations
read switch
print switch
switch switch
switch write
execute read
execute execute
copy rights
copy propagation
separate rights
limited copy
valid right
owner write
write execute
owner owner
execute owner
owner read
read owner
owner rights
domain objects
process executil1.g
modify domai11
switch print
switch control
control read
execute write
write switch
switch figure
modified access
rights provide
general unsolvable
access-matrix model
protection requirements
mechanism exists
datastructure techniques
representing sparse
sparse matrices
protection facility
global table
simplest implementation
table consisting
ordered triples
triples domain
implementation suffers
special groupings
empty entries
resulting list
object consists
ordered pairs
pairs domain
nonempty set
default set
exception condition
capability lists
tbose objects
execute operation
parameter simple
capability means
capability list
protected object
capability-based protection
protection relies
access capabilities
secure pointer
resource protection
protected pointer
applications level
inherent protection
distinguish capabilities
abstract machine
run capabilities
program hardware
firmware support
distinguish integers
floating-point numbers
uninitialized values
normal data
segmented memory
lock-key mechanism
unique bit
domain users
expect choosing
matrix involves
domains access
lists correspond
access-rights information
long access
consuming capability
localizing information
process attempting
attempting access
valid revocation
access privileges
additional references
cal system
strategy works
file-table entry
user carmot
checked or1
allowed operations
similar function
microsystems operating
facility revolves
work privileges
assigned roles
roles based
privileges decreases
security risk
programs user1
user1 executes
matrix described
revoke access
objects shared
versus delayed
revocation occur
selective versus
versus general
select group
partial versus
versus total
object temporary
temporary versus
versus permanent
revoked access
access-list scheme
list revocation
temporary capabilities
difficult revocation
revocation problem
implement revocation
capabilities include
capability back-pointers
costly indirection
capabilities point
capability points
unique entry
desired entry
illegal table
entry table
selective revocation
revocation keys
bit pattern
set-key operation
master key
keys match
raised revocation
revocation replaces
previous capabilities
key matches
matching key
providing maximum
key-based schemes
defining keys
interesting proving
proving grounds
protection theories
hydra hydra
considerable flexibility
fixed set
basic forms
user-defined rights
access protection
system-defined rights
facilities constitute
protection technology
technology operations
defined procedurally
user-defined procedures
userdefined type
auxiliary rights
typed object
restriction enables
enables discrin
discrin lination
process-by-process basis
basis hydra
formal parameter
rights held
trustworthy procedure
program segments
process amplification
implementation procedures
procedures access
representation variables
process holds
auxiliary right
so-called kernel
kernel rights
indirect access
control passes
code body
storage segment
segment representing
process cmmot
originat unamplified
unamplified state
protected segment
dynamic adjustment
guarantee consistency
programmer-defined abstraction
abstraction amplification
abstract type
hydra operating
user passes
right howeve1
user-protection requirement
procedure performs
task correctly
errors hydra
hydra solves
restricting amplifications
direct solution
suspicious subsystems
sort routine
users invoke
service program
som.e private
calling user
program hydra
hydra subsystem
protection kernel
require protection
subsystem interacts
kernel-defined primitives
define access
subsystem designer
define policies
protection afforded
capability system
reference rnanual
rnanual hydra
large library
system-defined procedures
programs programmers
incorporate calls
system procedures
program translator
cambridge cap
cap system
system cap
closer examination
examination shows
provide secure
secure protection
user-defined objects
objects cap
ordinary kind
provide access
rights provided
standard read
individual storage
storage segments
object data
data capabilities
cap machine
cap microcode
rights amplification
protected procedure
software capability
specific kind
amplification corresponds
unseal primitives
type verification
software capabilities
procedure universal
universal trust
protected procedures
protection policies
basic protection
procedure access
protection environment
insecure protected
protection breakdown
capabilities allowed
considerable economies
implementing protection
policies commensurate
abstract resources
subsystem designers
existing computer
security agent
protected resource
comprehensive access
access validation
protection satisfying
implement protection
support mechanisms
protection environments
greater operational
operational efficiency
higher-level user
objects protection
functional nature
newest protection
invoked extends
system-defined functions
standard file-access
file-access methods
include functions
application designe1
applications subsystem
compiler-based enforcement
languages enter
desired control
declarative statement
typing facility
data typing
significant advantages
facilities provided
declarative notation
linguistic concept
programming-language implementation
enforce protection
generate code
storage reference
reference made
hardware occurs
restriction prevents
arbitrary restrictions
capabilities provided
language implementation
interpret software
scheme puts
puts policy
policy specification
protection specifications
principal distinction
operational state
separate references
security provided
protection rests
code generated
enforcement based
enforcement provided
compiler security
security enforcement
greater degree
protectionchecking code
compiler-supported scheme
security rests
compiled code
softwaresupported protection
lesser degree
designated file
tagged-capability system
fixed microprogram
greater security
hardware-supported protection
protection violations
software malfunction
malfunction flexibility
user-defined policy
adequate facilities
provide enforcement
sufficient flexibility
kernel efficiency
greatest efficiency
language-based enforcement
static access
access enforcement
intelligent compiler
enforcement mechanism
fixed overhead
kernel calls
high-level description
provide software
protection enforcement
automatic hardware-supported
hardware-supported checking
interpret protection
generate calls
making protection
computation inherent
program components
capability-creating program
primitive operation
unseal privilege
protection mechanism
unseal operations
operations takes
procedural approach
make protection
dynamic access-control
access-control mechanism
distributing capabilities
constructs provide
customer processes
allocated resource
practical tool
infancy protection
greater concern
distributed architectures
stringent requirements
data security
suitable language
language notations
express protection
machine-or jvm-has
built-in protection
mechanisms java
data fields
jvm loads
create instances
features ofj
ofj ava
untrusted classes
distrusting classes
paramount concern
concern classes
classes running
equally trusted
enforcing protection
jvm process
system lacks
protection decisions
protection domain
assigned depends
digital signatures
configurable policy
policy file
file determines
permissions granted
classes loaded
trusted server
home directory
untrusted server
access permissions
resource accesses
open network
system library
network connection
philosophy adopted
library class
network corucection
calling sequence
takes responsibility
implementation approach
ongoing invocations
method executes
access request
dopri vileged
vileged block
indirectly dopri
static method
accesscontroller class
invoke stack
stack inspection
inspection examines
examines stack
stack frames
added frame
first found
inspection exhausts
allowed depends
untrusted applet
applet protection
domain performs
url loader
loader protection
proxy server
server proxy
proxy .lucent
retrieving urls
networking library
library encounters
call finds
vileged annotation
socket permission
proxy figure
important differences
directly access
reference references
well-defined interfaces
interfaces compliance
sophisticated collection
run-time stack
checks enforce
java classes
classes type
type safety
safety ensures
treat integers
write past
arbitrary ways
methods defined
java protection
package type
enforced computer
misuse objects
rights processes
manipulate objects
design property
objects revocation
protection model
providing read
execution protection
general public
file multics
access hydra
capability systems
extend protection
user-defined software
software objects
objects solaris
access controt
finer-grained arbitration
single java
java jvm
protection class
sophisticated stack
computer games
faculty members
computer center
center staff
times suggest
policy efficiently
arbitrary object
access-matrix facility
role-based access-control
access-control facility
practice compare
cross-ring calls
ring-protection scheme
capability-based system
greater flexibility
typical operating
values stored
higher-numbered ring
ring invokes
access-control matrix
approach equivalent
protection failures
privilege aid
shared stack
parameter passing
system suggest
efficient implementation
module designers
multics ring-protection
stack-inspection scheme
system suppose
protection structure
efficient capability
capability manipulation
sensitive data
provided excellent
excellent surveys
protection harrison
formal version
system mathematically
capability evolved
rice university
university computer
term capability
hydra system
ring-protection system
system revocation
confinement problem
operations discussed
general dynamic-resource-management
dynamic-resource-management schemes
schemes jones
static access-control
access-control scheme
supports abstract
minimal operating-system
exokernel project
internal problem
adequate protection
external environment
system operates
unauthorized user
user computer
resources include
examining ways
purposely misused
key security
security enabler
enabler -cryptography
detect attacks
security threats
security attacks
worth considerable
considerable effort
commercial systems
financial data
inviting targets
thieves systems
data pertaining
corporate operations
unscrupulous competitors
discussed mechanisms
including programs
mechanisms work
users conform
total security
achieved nonetheless
make security
rare occurrence
norm security
accidental misuse
malicious misuse
part protection
list includes
malicious security
terms intruder
breach security
security violation
break security
security breach
violation involves
1mauthorized reading
intruder capturing
capturing secret
secret data
credit-card information
identity information
intruder breach
unauthorized modification
innocent party
important commercial
application breach
unauthorized destruction
wreak havoc
gain status
bragging rights
gain financially
financially web-site
web-site defacement
breach theft
intrusion program
server denial
preventing legitimate
original internet
internet worm
worm turned
dos attack
bug failed
rapid spread
discuss dos
dos attacks
standard methods
communication pretends
attackers breach
privileges-obtain privileges
common attack
captured exchange
fraudulent repeat
valid data
data transmission
replay comprises
entire attackfor
transfer money
escalate privileges
normal attacker
attacker masquerading
masquerading attacker
man-in-the-middle attacker
attacker figure
standard security
legitimate user
attacker sits
man-in-the-middle attack
active communication
communication session
attack methods
absolute protection
malicious abuse
denial-ofservice attack
surreptitious entry
machine rooms
social-engineering attack
legitimate-looking e-mail
page misleads
confidential information
human authorization
finding phone
phone books
finding notes
personnel issues
problems pertaining
purposeful security
runaway process
accidental denial-of-service
denial-of-service attack
reveal passwords
stack overflow
unauthorized process
endless network
computer data
systems travels
leased lines
shared lines
wireless connections
dial-up lines
lines intercepting
interruption communications
remote denial-of-service
diminishing users
high security
strict low-level
intruders countermeasures
incidents include
section tools
tools needed
detecting intrusions
threats processes
accomplishing work
normal process
common goal
nonprogram security
security events
goal causing
program threat
easy access
original exploit
common methods
breaches note
considerable variation
naming conventions
descriptive terms
horse systems
allowing programs
text-editor program
include code
certairl keywords
special area
long search
search paths
path lists
system commanct
instance horse
control-alt-delete conlbination
modern windows
trojan horse
shareware programs
download ads
capture information
central site
general category
surreptitious communication
communication occurs
innocuous-seeming program
spyware daemon
recipient addresses
spam message
windows machine
user discovers
macro problem
install network
network daemons
human error-a
common security
security weakness
normal user
poor operating-system
fine-grained control
understand inconvenient
inadequate security
trap door
movie war
war games
code inight
inight check
specific user
normal security
security procedures
procedures programmers
including rounding
rounding errors
occasional half-cent
half-cent credited
account credititrg
large bank
bank executes
clever trap
standard object
information trap
trap doors
doors pose
difficult problem
logic bomb
security incident
normal operations
security hole
predefined set
write code
check failed
buffer overflow
buffer-overflow attack
dial-up connection
target system
attack exploits
simple case
poor programming
programmer neglected
code bounds
bounds checking
input field
attacker sends
attacked program
attacker determines
command-line argument
network daemon-wl.til
stack overwrite
current return
exploit code
simple set
attacker wishes
execute-for instance
attack program
root shell
privileged command
command execution
web-page form
form expects
extra characters
buffer-reading subroutine
subroutine returns
buffer-overflow exploit
character array
array size
size buffer_size
parameter provided
command line-argv
null terminator
begin copying
program crashes
program suffers
potential problem
copied data
data overflow
buffer array
buffer-overflow condition
condition note
careful programmer
performed bounds
line strcpy
good bounds
security vulnerabilities
automatic variables
function exits
typical stack
frame pointer
return bottom
pointer grows
top figure
stack pointer
saved frame
relative access
standard memory
bufferoverflow attack
ter goal
attacking program
segment creates
shell process
attacked runs
system-wide permissions
created shell
complete access
attacked process
language instructions
primary modification
unnecessary features
code size
assembled code
code fragment
binary sequence
frame appears
hypothetical stack
no-op instructions
constructed binary
position buffer
modified shell
shell code
potential buffer-overflow
buffer-overflow problems
code shown
malicious act
opening network
network ports
attack reveals
considerable knowledge
programming skill
exploitable code
great programmers
launch security
rudimentary computer
computer skills
target systems
allowed communication
target machine
security added
disallows execution
stack section
sparc chip
chip include
overflowed routine
x86 chips
chips include
including linux
implementation involves
bit marks
buffer-overflow attacks
greatly diminish
code embedded
legitimate program
program viruses
destroying files
causing system
program malfunctions
penetration attacks
applications viruses
multiuser operating
protected viruses
comrnon vector
users download
viral programs
programs internet
exchange infected
infected disks
common form
virus transmission
microsoft office
office files
word documents
basic programs
office suite
suite powerpoint
execute automatically
deleting user
contact list
basic macro
windows computer
sub autoopen
dim ofs
ofs set
set ofs
end sub
viruses work
virus reaches
virus dropper
core activity
literally thousands
categories note
viruses belong
category file
file virus
virus infects
execution jumps
noticed file
file viruses
parasitic viruses
full files
host program
functional boot
boot virus
boot sector
boatable media
memory viruses
virus works
works macro
macro viruses
macro virus
spreadsheet file
file source
code virus
boot-sector computer
virus polymorphic
polymorphic virus
avoid detection
antivirus software
series make
virus code
code encrypted
encrypted virus
virus includes
includes decryption
decryption code
executes stealth
tricky virus
virus attempts
modifying parts
read system
original form
infected code
code tunneling
bypass detection
anti virus
virus scanner
interrupt-handler chain
similar viruses
viruses install
infect nmltiple
nmltiple parts
including boot
boot sectors
armored virus
antivirus researchers
virus droppers
virus infestation
unviewable file
vast variety
widespread virus
separate bugs
virus started
infecting hundreds
windows servers
trusted sites
running microsoft
microsoft internet
internet information
information server
vulnerable microsoft
microsoft explorer
explorer web
browser visiting
sites received
browser virus
back-door programs
things entered
credit-card numbers
unlimited remote
route spam
infected desktop
desktop computer
disruptive security
active debates
computing community
systems run
damage caused
security intrusions
microsoft products
debate concerns
exists today
today program
attack programs
threats involve
network comcections
comcections system
threats create
network attack
program attack
system is-the
enabled system
including worms
port scamcing
denial-of-service attacks
replay attacks
multiple systems
sharing secrets
prove identity
secure sharing
sharing methods
methods exist
methods include
interprocess comnmnications
comnmnications creating
creating secure
secure communication
ravage system
worm spawns
spawns copies
entire network
event occurred
worth millions
robert tappan
tappan morris
first-year cornell
cornell graduate
graduate student
worm program
internet targeting
targeting sun
vax computers
computers running
running variants
great distances
consumed system
infected machines
robert morris
morris designed
self-replicating program
rapid reproduction
unix networking
networking environment
environment provided
morris chose
in.itial infection
internet host
host left
program exploited
exploited flaws
security routines
unix utilities
simplify resource
local-area networks
connected sites
sites morris
program ll.c
grappling hook
hook consisted
code compiled
hook connected
main worm
hooked system
program proceeded
infected system
connect easily
morris exploited
networking utility
utility rsh
easy remote
remote task
task execution
special files
remote account
paired list
worm searched
site names
rsh attack
attack finger
finger attack
attack sendmail
sendmail attack
attack worm
system infected
morris internet
remote execution
remote shells
executing anew
infection methods
methods built
methods involved
operating-system bugs
unix finger
sendmail programs
finger utility
utility functions
electronic telephone
telephone directory
command finger
finger user-name
user-name hostname
hostname returns
login names
home address
telephone number
research plan
clever quotation
quotation finger
finger runs
background process
bsd site
worm executed
program queried
536-byte string
string crafted
buffer allocated
main routine
finger daemon
procedure executed
remote shell
bug exploited
malicious entry
entry sendmail
sendmail sends
electronic mail
mail debugging
debugging code
utility permits
permits testers
ncail system
debugging option
morris included
user address
grappling-hook program
simple cases
passwords constructed
account-user-name combinations
internal dictionary
favorite password
password choices
final stage
unix on-line
on-line dictionary
efficient three-stage
three-stage password-cracking
password-cracking algorithm
algorithm enabled
rsh data
broken accounts
remote systems
program searched
active copies
copy exited
seventh instance
worm exited
duplicate sightings
remained undetected
undetected allowing
seventh duplicate
confound efforts
spread baiting
fake worms
wholesale infestation
vax systems
unix network
network environment
advance ease
electronic communication
copy source
human expertise
expertise allowed
cooperative efforts
develop solutions
solutions quickly
invading program
software patches
exploited security
security flaws
morris unleash
harmless prank
criminal offense
offense based
elaborate steps
repel efforts
program contained
code aimed
virus programs
interesting observations
sound basis
inferring motive
legal outcome
federal court
court convicted
convicted morris
community service
legal costs
security experts
experts continue
evaluate methods
eliminate worms
recent event
internet grows
harmless worms
sobig worm
fastest-spreading worm
worm released
peak mfecting
mfecting hundreds
e-mail messages
e-mail inboxes
slowed networks
huge number
pornography newsgroup
account created
stolen credit
credit card
virus targeted
targeted microsoft
smtp engine
addresses found
subject lines
random address
infected source
source sobig.f
sobig.f included
target e-mail
e-mail reader
default windows
windows directory
windows registry
code included
twenty servers
untold damage
port scanning
scanning port
attack port
tcp lip
lip connection
port scanner
answering service
nwre systems
command shell
trojan horses
perform subsets
services running
generates reports
final step
found bugs
knowledgeable cracker
script kiddie
port scans
independent systems
nefarious purposes
including denial-of-service
spam relay
relay zombies
zombies make
make crackers
inconsequential systems
valuable information
gaming information
stealing resources
disrupting legitimate
attacks involve
involve systems
prevents legitimate
facility denial-of-service
generally network
network based
categories attacks
first category
facility resources
web-site click
java applet
windows infinitely
category involves
successful denial-of-service
major web
web sites
attacks result
fundamental functionality
tcp connection
started tcp
tcp sessions
network resources
legitimate tcp
tcp connections
last hours
full failure
target facility
network level
multiple sites
common target
zombies ddos
ddos attacks
blackmail attempts
attackers offer
system slowdown
successful advertising
advertising campaign
interesting aspects
authentication algorithm
algorithm locks
incorrect attempts
making incorrect
examples suggest
systems managers
science classes
notorious sources
accidental system
system dos
first programming
students learn
common bug
bug involves
spawning subprocesses
subprocesses infinitely
computer attacks
broadest tool
computer security
isolated computer
ali interprocess
computer receives
receives bits
sends bits
potential senders
network messages
messages network
packets arrive
source address
intended receiver
destination address
security matters
rogue computer
falsified source
numerous computers
named source
destination addresses
message cryptography
process messages
messages cryptography
cryptography enables
computer possessing
key-the key
unlike network
public information
trustworthy means
constraining senders
messages note
small complexities
communication security
computing encryption
encryption algorithm
algorithm enables
message encryption
ancient practice
ancient times
important modern
modern encryption
encryption principles
algorithms figure
users communicating
insecure channel
section note
key exchange
certificate authority
algorithm consists
generating ciphertexts
computable functions
generating messages
essential property
insecure medium
computer holding
decrypt ciphertexts
main types
symmetric encryption
civilian applications
national institute
des works
64-bit value
56-bit key
permutation operations
encryption transformations
so-called s-boxes
states government
government messages
64-bit chunks
extended anwunt
ciphertext block
considered insecure
nist created
des algorithm
effective key
key length
bits triple
triple des
replace des
des aes
symmetric block
block cipher
key lengths
128-bit blocks
matrix formed
block encryption
today bear
bear mentioning
fast compact
basic computational
computational operations
common stream
stream cipher
pseudo-random-bit generator
produce random
infinite set
input plaintext
plaintext stream
stream rc4
encrypting steams
wireless lan
lan protocol
ieee standard
reasonable amount
fact rc4
asymmetric encryption
decryption keys
rsa cipher
block-cipher public-key
public-key algorithm
asymmetrical algorithm
asymmetrical algorithms
elliptical curves
gaining ground
cryptographic strength
asymmetric cryptography
andq are512bitseach
icc satisfies
satisfies leekd
leekd mod
decryption algorithm
ckd mod
small values
kekrt mod
private key
key results
encryption begins
public key
key publication
electronic copy
message created
matching public
small difference
symmetric cryptography
mathematical functions
usual symmetric
symmetric algorithms
asymmetric algorithms
asymmetric algorithm
generalpurpose encryption
key distribution
encryption offers
message constraining
functions overlap
encrypted message
discuss authentication
message note
generating authenticators
verifying authenticators
critical property
generate authenticators
main varieties
authentication algorithms
explore hash
hash functions
fixed-sized block
functions work
n-bit blocks
n-bit hash
collision resistant
common message-digest
message-digest functions
functions include
128-bit hash
160-bit hash
hash message
message digests
detecting changed
changed messages
message modification
algorithm takes
message digest
first main
main type
cryptographic checksum
secret key
key knowledge
mac defines
first argument
collision resistance
suitable verification
verification algorithm
digital-signature algorithm
one-way function
rsa digital-signature
rsa encryption
digital signature
separate authentication
reasons authentication
fewer computations
notable exception
huge difference
improves space
software patch
modified authentication
supplies proof
entity performed
nonrepudiation involves
electronic forms
paper contracts
contracts nonrepudiation
nonrepudiation assures
person filling
electronic form
good part
inventing ciphers
involves keys
symmetric key
huge challenge
paper document
key-management challenge
challenge suppose
user wanted
users privately
keys frequently
asymmetric key
key algorithms
public keys
simple storage
keys requires
attack shown
message sends
bad public
bad key
digital certificates
trusted party
party receives
encryption __
key kbad
kbad attacker
attacker decryption
decryption key
kbad .,......_read
certificate authorities
standard x.509
x.509 digital
digital certificate
certificate format
secure web
web communication
cryptography network
layer acting
protocol generates
protocol peer
network-protocol stack
transport-layer protocol
network-layer protocol
tcp packets
tcp peer
data-link layer
destination computer
data networking
protocol layers
iso model
model ssl
transport layer
layer networklayer
networklayer security
packet formats
packet contents
key ipsec
ipsec endpoints
numerous protocols
implement security
cryptographic protection
definitive answer
protocols benefit
packets encapsulate
encapsulate tcp
encapsulated tcp
packets detect
contaii1.ed tcp
tcp header
header information
lower layers
give insufficient
insufficient protection
higher-layer protocols
application server
client computer
application-level protocol-for
standard smtp
smtp protocol
multiple times
insecure network
e-mail message
ssl ssl
cryptographic protocol
corrumjj1icate securely-that
internet today
standard protocol
web communicate
standard tls
tls protocol
tls ssl
complex protocol
single variation
abstract form
maintain focus
cryptographic primitives
complex dance
session keys
ssl protocol
denoted cert
certification authority
attributes attrs
unique distinguished
public encryption
validity interval
interval interval
interval durirtg
information made
public verification
verification algorithms
certification authorities
28-byte random
random value
certificate cert5
client verifies
client generates
sends cpms
server recovers
recovers pms
collision-resistant function
function server
pms dependence
fresh value-that
session key
previous communication
encrypting messages
server client
mac generation
server sends
client recovers
protocol enables
generated pms
decrypt cpms
web transactions
attrs field
ssl supports
ipsec vpns
ssl vpns
vpns ipsec
point-to-point encryption
company offices
offices ssl
individual employee
employee working
corporate office
authentication involves
involves messages
major security
turn depends
users identify
user identifier
attribute retina
user-supplied password
password matches
password stored
system assumes
account passwords
protect objects
protection schemes
password nmst
reading files
appending files
updating files
full rights
systems tend
classic trade-off
security makes
password vulnerabilities
vulnerabilities passwords
obvious information
brute force
valid password
password characters
four-character password
correct hit
password enumeration
longer passwords
lowercase letters
punctuation characters
large password
password space
electronic monitoring
logging iil
computer resides
network monitor
network including
including user
passwords encrypting
password solves
passwords stolen
off-system analysis
trojan-horse program
program installed
severe problem
systems force
force users
long passwords
easy passwords
final type
password compromise
illegal transfer
human nature
computer installations
forbids users
share accounts
accounting reasons
improving security
breach occurs
break occurred
users break
account-sharing rules
circumvent accounting
unauthorized users
system-generated passwords
user-selected passwords
favorite car
proposed password
check user
age passwords
forcing users
password history
simple password
password schemes
now-invalid password
violation steps
breached security
encrypted passwords
password secret
system store
user presents
password list
list secret
difficult-the designers
designers hope
impossible-to invert
function value
encoded passwords
encoded password
password file
tested rigorously
fast encryption
encryption routines
fast computers
slow computers
well-known encryption
cracked previously
unix store
encrypted password
password entries
presented password
stored password
password run
run setuid
recorded random
plaintext passwords
unix password
password methods
systems treat
dictionary encryption
encryption method
systems disallow
dictionary words
first letter
remembered phrase
lower characters
punctuation mark
mark thrown
good measure
password mmn.isk
one-time passwords
password sniffing
shoulder surfing
session begins
password pair
correct answer
integer function
user applies
results match
algorithmic passwords
entity intercepting
user share
shared seed
alphanumeric sequence
authentication challenge
computer becallse
improper authentication
authentication clue
password exposure
one-time password
password systems
commercial implementations
hardware calculators
key-chain dangle
usb device
random seed
shared secret
password generator
case two-factor
two-factor authentication
authentication offers
authentication protection
single-factor authentication
single-use passwords
software calculator
code book
book based
biometric measures
measures palm
physical access-for
data center
readers match
stored parameters
hand-reader pads
temperature map
finger length
finger width
line patterns
normal computer
computer authentication
authentication fingerprint
fingerprint readers
devices read
finger ridge
ridge patterns
reading pad
factors software
stored sequences
profiles stored
accurate two-factor
authentication scheme
fingerprint scan
replay attack
strong authentication
authentication method
normal passwords
passwords recall
authenticated session
myriad threats
network security
security solutions
solutions run
improved user
user education
bug-free software
security professionals
professionals subscribe
theory applies
door lock
improve resistance
security policy
policies vary
outsideaccessible applications
code review
connection points
road map
vulnerability assessment
broad ground
social engineering
risk assessment
scans rlsl
management team
potential loss
vulnerability assessments
assessment vulnerability
vulnerability scans
test systems
unhappy behavior
individual system
easy-to-guess passwords
passwords unauthorized
programs unauthorized
unauthorized programs
system directories
long-running processes
improper directory
directory protections
directories improper
improper protections
dangerous entries
program search
horse discussed
programs detected
checksum values
values unexpected
hidden network
problems found
security scan
system networked
standalone systems
access points
connected terminals
face attacks
large set
access points-a
severe security
lesser extent
telephone lines
government considers
far-reaching connection
top-secret system
considered top-secret
system loses
topsecret rating
communication call
call occur
government facilities
extreme security
security precautions
secure computer
physical lock
lock combination
multifactor authentication
systems administrators
computer-security professionals
internet network
connects millions
indispensable resource
good members
bad members
interconnected computers
worm vulnerability
scans search
application listening
vulnerabilities testing
lacks needed
needed patches
port scanners
improve security
crackers find
find vulnerabilities
detect port
anomaly detection
general challenge
people advocate
test security
information secret
secret makes
company assuming
false sense
intrusion detection
successful intrusions
intrusions intrusion
detection encompasses
wide array
detection occurs
occurs detection
inputs examined
intrusive activity
include user-shell
user-shell commands
process system
packet headers
correlating information
response capabilities
capabilities simple
simple forms
response include
include alerting
potential intrusion
intrusive activity-for
process engaged
sophisticated fonn
false resource
resource exposed
resource appears
gain information
design space
ids systems
systems raise
idp systems
intrusion defining
suitable specification
intrusion turns
automatic idss
idps today
today settle
ambitious approaches
system input
specific behavior
behavior patterns
signature-based detection
scanning network
unix systenl
virus-detection software
scans binaries
lmown viruses
anomalous behavior
computer systen
anomalous system
system activity
monitoring system
system-call behavior
behavior deviates
normal patterns
monitoring shell
shell commands
anomalous commands
anomalous login
detection attempts
dangerous behaviors
behaviors occurs
approaches yield
yield idss
unknown methods
so-called signature-based
recognizable pattern
great frequency
detected manually
behavior accurately
normal benchmark
intrusive behaviorf
normal behavior
false alarms
orf worse
missed intrusions
installation consisting
unix workstations
security-relevant events
small installation
million audit
audit records
actual attack
ten audit
audit recordsf
records reflecting
record reflecting
intrusive behavior
accurate ids
intrusion focusil
false-alarm rate
good true-alarm
true-alarm rate
good falsealarm
falsealarm rate
real intrusion
security administrator
administrator ilwestigates
christmas tree
tree effect
effect -is
ignore alarms
general principle
low false-alarm
rate achieving
anomaly-detection systems
contil ues
improve anomalydetection
anomalydetection techniques
techniques intrusion
detection software
implement signatures
accurate anomaly-detection
anomaly-detection rate
virus protection
systems protection
important security
security concern
concern antivirus
antivirus programs
specific pattern
program antivirus
software continue
viruses modify
basic pattern-match
pattern-match approach
programs antivirus
single pattern
programs implement
detection algorithms
compressed viruses
process anomalies
process opening
popular teducique
tripwire file
anomaly-detection tool
checking tool
purdue university
university tripwire
tripwire operates
intrusions result
inserting copies
user-shell search
remove system
log files
tracks tripwire
monitor file
changed files
configurationfile tw.config
file includes
selection mask
inode attributes
file itselt
storing hashes
files requires
tripwire takes
tw.config file
directory consisting
monitored attributes
hash values
tripwire inputs
stored database
directory named
compl.j-ted database
database events
events reported
administrator include
monitored file
signature differs
changed file
monitored directory
added file
wide class
tripwire program
database file
tamper-proof medium
write-protected disk
secure server
tightly controlled
authorized updates
monitored directories
security-relevant files-for
log files-are
files-are supposed
unauthorized change
escape tripwire
detection capabilities
obvious inconsistencies
shrinking log
software analyzes
run unmonitored
complete shield
scanning files
search boot
outbound e-mail
computer viruses
unopened software
pirated copies
public sources
disk exchange
exchange offer
safest route
preventing infection
legitimate software
software applications
virus infection
disgruntled employees
software company
master copies
software programs
economic harm
exchange microsoft
alternative file
file format
native word
word format
format rtf
attach macros
e-mail attachments
unknown users
e-mail vulnerabilities
love bug
bug virus
love notes
receiver opened
basic script
virus propagated
first addresses
e-mail contact
clogging e-mail
e-mail systems
defensive strategy
opening attachments
effective defense
defense method
e-mail attachment
incoming attachments
prevent infection
viral attack
secure software
message-digest computation
resulting filename
messagedigest list
system recomputes
original list
differences serve
high-overhead antivirus
antivirus scan
program passes
signatures match
logging auditing
decrease system
including security
security logging
system-call executions
program behavior
suspicious events
logged authentication
authentication failures
authorization failures
break-in attempts
potential tool
find performance
reveal security
unix computer
computer break-ins
cliff stoll
exam5ning accounting
accounting logs
trusted computer
untrustworthy network
separate trusted
unh usted
usted systems
network firewall
firewall limits
limits network
limit coru1.ections
coru1.ections based
finger protocol
multiple domains
common implementation
untrusted domain
semisecure network
dmz computers
company computers
controlled commurucations
company computer
database server
corporate network
dmz systems
computers internet
internet internet
internet access
computers figure
domain separation
secure connections
prevent attacks
http connection
attack likewise
denialof service
service attacks
affect firewalls
unauthorized host
host pretends
authorized host
authorization criterion
firewall rule
send packets
network firewalls
newer kinds
limiting communication
security domains
limits communication
personal firewall
prex-y understands
applications speak
mail transfer
application proxy
proxy accepts
smtp server
original destination
destination smtp
illegal commands
exploit bugs
specific protocol
specific purpose
analyzing xml
xml traffic
malformed xml
xml sit
system-call execution
privilege feature
feature implements
fifty system
u.s department
defense trusted
system evaluation
security classifications
model security
lowest-level classification
minimal protection
protection division
security classes
discretionary protection
audit capabilities
capabilities division
c1-class system
system incorporates
private information
cooperating users
controls access
control sharing
named individuals
defined groups
tcb requires
protected mechanism
tcb protects
authentication data
c2-class system
individual-level access
single individual
system adrninistrator
users based
individual identity
information produced
prior user
storage object
speciat secure
secure versions
level division-b
division-b mandatory-protection
mandatory-protection systems
classc2 system
sensitivity label
bl-class tcb
tcb maintains
security label
decisions pertaining
mandatory access
confidential level
sensitive secret
secret level
sensitivity level
human-readable output
normal user-namepassword
user-namepassword authentication
carry sensitivity
sensitivity labels
security clearance
secret-level user
controls processes
distinct address
b2-class system
storage objects
maximum security
security levels
enforce constraints
constraints imposed
physical environments
supports covert
covert channels
covert channel
b3-class system
denote users
monitor events
mechanism notifies
disruptive manner
highest-level classification
class-al system
formal design
design specifications
verification techniques
high degree
implemented correctly
trusted facility
trusted personnel
enforce aspects
environment develops
security agency
national computer
security center
electronic eavesdropping
tempest-certified system
electromagnetic fields
shielding ensures
housed camwt
camwt detect
terminal microsoft
system designed
examine features
perform security
security functions
security model
manner access
system objects
desired users
unique security
security ids
special privileges
privileges include
access token
object authentication
user account
modular design
custom authentication
authentication packages
greater access
manage permissions
user runs
program acting
simple subjects
server subjects
typical application
simple subject
security access
process implemented
protected server
security context
security technique
technique windows
bl1ilt-in auditing
monitored examples
include failure
failure auditing
logoff events
detect random
random password
password break-ins
success auditing
detect login
login activity
strange hours
failure write-access
write-access auditing
virus outbreak
detect access
sensitive files
security descriptor
group security
posix subsystem
discretionary access-control
identifies users
system access-control
auditing messages
file foo.bar
owner avi
-all access
access group
cs-read-write access
access user
audit writes
access-control entries
access mask
action files
access types
wri teattributes
objects windows
classifies objects
container objects
noncontainer objects
container object
object inherits
inherits permissions
parent object
user copies
destination directory
directory inherit
performance monitor
spot approaching
approaching problems
good job
providing features
myriad security
services windows
boot tiine
real multiuser
multiuser environment
security plan
security tools
tools protection
problem security
valuable objects
accidental loss
malicious access
data absolute
proper authority
masses stack
buffer-overflow techniques
successful attackers
access viruses
infecting thousands
computers denial-of-service
attacks prevent
prevent legitimate
systems encryption
encryption limits
authentication limits
senders encryption
provide confidentiality
encryption requires
asymnletric encryption
key authentication
changed user
password protection
avoid replay
attacks two-factor
authentication requires
hardware calculator
activation pin
pin multifactor
authentication forgery
forgery methods
detecting security
include intrusiondetection
intrusiondetection systems
system events
system-call monitoring
judicial sentence
sentence handed
worm discussed
damage done
computer programs
man-in-themiddle attacks
attacks discuss
discuss solutions
unix program
program cops
cops scans
potential hazards
security concerns
concern relates
experimental addition
program requests
denies access
provide authentication
intrusion-detection system
alarms generated
system correspond
real intrusions
user-provided password
general interest
issues concernin
secure systems
security kernel
multiprocessor microcomputer
distributed secure
secure system
discuss password
password security
security morshedian
presents methods
fight password
password pirates
pirates password
password authentication
insecure communications
password cracking
cmnputer break-ins
trusting computer
unix security
watchdog extension
security-scanning package
ftp program
cops spafford
detailed technical
technical discussion
spafford article
article appears
special section
protocol suite
protecting networks
insider attacks
secure topology
route discovery
discovery kent
present solutions
secure routing
routing savage
service attack
trace-back solutions
problem perlman
diagnose faults
malicious routers
routers information
up-to-date security
information diffie
public-key encryption
algorithm presented
systems discussions
orange book
security rating
rating reading
good starting
starting point
understanding security
workstation resource
resource kit
security inodel
rsa algorithm
aes activities
ietf request
processors communicate
communication lines
wide-area networks
system vary
small handheld
real-time devices
large mainframe
mainframe computer
service activity
centralized data
data repository
independent storage
system include
include giving
giving users
resources maintained
improving data
handling failures
high-speed buses
i11 chapter
high-level overview
coupled processors
processors interconnected
communication network
respective resources
small microprocessors
large general-purpose
general-purpose cornputer
cornputer systems
communication site
major reasons
building distributed
printer located
remote sites
processing information
distributed database
printing files
remote specialized
specialized hardware
high-speed array
array processor
loaded sites
automated load
moves jobs
remammg sites
large autonomous
autonomous installations
sncall machines
crucial system
tenninal character
continue operation
function occurs
occurs correctly
site recovers
system smoothly
actions present
single-computer message
system discussed
higher-level flmctionality
flmctionality found
file transfer
distant sites
exchanging mail
users minimize
longdistance work
industry-wide trend
computers companies
bigger bang
locating resources
expanding facilities
easier maintenance
network-oriented operating
systems network
access remote
remote resources
important function
telnet facility
lets suppose
college wishes
valid account
user issues
command telnet
command results
cs.yale.edu computer
networking software
software creates
bidirectional link
characters entered
machine asks
correct information
process acts
major function
computer maintains
file located
transfer protocol
program suppose
program server
executing ftp
java resides
file location
vario-us copies
login permission
cs.yale.edu ptp
yale computer
copy files
files remotely
remote copying
anonymous ftp
ftp method
special subdirectory
protection set
ftp command
user supplies
arbitrary password
anonymous login
access inappropriate
inappropriate files
user anonymous
anonymous users
usual file-protection
file-protection scheme
camlot access
tree implementation
ftp mechanism
telnet implementation
remote site
site watches
ptp port
port login
login authentication
execute commands
commands remotely
telnet daemon
ptp daemon
daemon responds
file-related commands
machine put-transfer
dir-list files
change transfer
transfer modes
ascii files
determine connection
connection status
important point
change paradigms
paradigms ptp
ptp requires
command set
normal operating-system
operating-system commands
commands telnet
telnet requires
smaller shift
unix machine
unix commands
session facilities
commands distributed
local resources
resources data
process migration
data migration
migration suppose
basic methods
modest change
automated ftp
ftp system
microsystems network
microsoft smb
smb protocol
microsoft netbeui
netbeui protocol
network smb
appendix c.6.1
small part
significant portions
migration includes
mere transfer
data translations
sites involved
character-code representations
represent integers
computation migration
desired results
remote cmmnand
remote command
ways suppose
predefilced procedure
procedure executes
alternatively process
needed result
files residing
logical extension
workload computation
total process
process turnaround
reduced hardware
hardware preference
specialized processor
matrix inversion
microprocessor software
software preference
require software
move processes
achieving load
homogeneous systems
user input
programs remotely
distributedcomputing environment
web client
database operation
java applets
easily accessible
easy-to-use facility-one
huge growth
main difference
geographically distributed
distributed local-area
small areas
single building
adjacent buildings
autonomous processors
large area
differences imply
major variations
communications networks
networks local-area
networks emerged
self-contained applications
single large
full complement
single enterprise
natural step
network lans
communication links
links tend
higher speed
lower error
error rate
networks high-quality
longer distances
high-quality cable
prohibitively expensive
conunon links
fiberoptic cabling
common configurations
star networks
networks communication
communication speeds
local radio
radio network
higher-quality cable
optical-fiber-based fddi
fddi networking
fddi network
typical lan
laser printers
magnetic-tape drives
specialized processors
ethernet scheme
construct lans
central controller
multiaccess bus
ethernet protocol
significant growth
wireless spectrum
designing local-area
networks wireless
wireless router
transmitting signals
wireless adapter
adapter networking
networking card
ethernet systems
wifi networks
slower speeds
workstation workstation
workstation printer
printer laptop
laptop file
ieee standards
ilc practice
practice data
data rates
higher data
actual practice
typical data
spectrum wireless
physical advantage
wired ethernet
ethernet networks
connect communicatilcg
communicatilcg hosts
internet cafes
networks wide-area
academic research
research project
efficient communication
allowing hardware
wide community
first wan
arpanet begun
four-site experimental
experimental network
worldwide network
comprising millions
large geographical
typical links
dedicated data
microwave links
satellite channels
sites communicate
communication subsystem
host communication
communication processor
processor figure
communication processors
internet wan
wan enables
enables hosts
separated sites
host computers
regional networks
nsfnet il1
northeast united
telephone-system service
leased line
sites requiring
faster internet
routers control
message takes
increase commmlication
commmlication efficiency
reduce security
security risks
communication charges
standard telephone
primary means
digital data
computer side
analog signals
telephone system
destination site
site converts
analog signal
digital form
destination receives
unix news
news network
predetermined times
nearby systems
public messages
specific destinations
private messages
transmission rates
rates range
point-to-point protocol
protocol ppp
ppp functions
modem coru1ections
installation cost
communication cost
nodes correspond
connected network
links grows
huge installation
connected networks
direct links
links exist
requirement results
higher communication
link fails
connection exists
unconnected subsystems
single node
network types
types include
tree-structured networks
ring networks
failure characteristics
communication costs
costs installation
treestructured network
single link
ring network
higher degree
tree-structured network
star network
link results
network partition
single site
single-site failure
low communication
site howeve1
network star
physical aspects
basic issues
processes locate
communicate routing
routing strategies
packet strategies
sequence connection
connection strategies
processes send
conflicting demands
first component
identifier beca
networked systems
systems share
pair host
alphanumeric identifier
hosts named
named homer
lisa bart
computers prefer
prefer numbers
name-to-address binding
program compilation
network requires
internet rnarr-,,or
dns specifies
naming structure
name-to-address resolution
resolution hosts
multipart names
address progress
progress frorn
general part
periods separating
bob.cs.brown.edu refers
host bob
top-level domain
domains include
commercial sites
reverse order
made communicate
nance server
server resides
inform system
server crashed
addresses resolved
primary servers
domain-name service
internet needed
updated file
find hosts
name-server site
host information
dns lookups
updated information
autonomous subdomains
message indicating
class representing
method getbyname
inetaddress class
string representation
designated host
message destined
destination host
process named
java dnslookup
i.e java
dnslookup www.wiley.com
class dnslookup
unknownhostexception uhe
system err
err println
dns lookup
physical path
multiple physical
physical paths
routing options
alternative paths
communication paths
exchange routing
routing information
common routing
routing schemes
fixed routing
failure disables
shortest path
virtual routing
sessions involving
involving messages
remote-login period
dynamic routing
separate messages
paths site
site sends
schem.es fixed
link failures
routing fixed
routing ensure
manage routing
complicated environments
environments unix
simple networks
complicated network
network environments
local network
company-wide networks
individual host
static route
routing messages
routing software
special-purpose device
network cmmections
route messages
router decides
network connected
destination internet
internet address
router checks
static routing
manual update
routing tables
tables automatically
automatically gateways
dedicated hardware
strategies messages
implement communication
fixed-length messages
communication incplemented
connectionless message
packet reached
destination indicating
packet arrived
return packet
reliable exchange
multiple packets
information pairs
circuit switching
physical link
tl1is link
communication line
calls party
parties hang
message switching
temporary link
physical links
short periods
errorcorrection codes
destination correctly
post-office mailing
mailing system
link packet
packet switching
logical message
arrive note
destination breaking
audio signal
telephone communication
great confusion
done carefully
obvious tradeoffs
schemes circuit
switching requires
substantial set-up
waste network
network bandwidth
switching require
reassembled packet
data networks
contention depending
transmit information
link simultaneously
bus network
transmitted information
special provisions
degraded performance
repeated collisions
including collision
collision detection
token passing
start transmitting
sites begin
stop transmitting
ethernet system
common local
network system
network adding
congested network
poor network
network throughput
networking performance
unique message
message type
token arrives
site completes
message transmission
unique site
election algorithm
token-passing scheme
apollo systems
token-passing network
constant adding
performance decrease
loaded networks
inherent complexity
asynchronous operations
operations communicating
error-prone environment
determining host
locating hosts
establishing connections
related implementation
multiple layers
system communicates
equivalent layer
peer layers
iso environment
systems environment
environment figure
computers communicating
iso network
network model
logical communications
lowest-level layers
layers implemented
international standards
standards organization
physical layer
electrical details
physical transmission
bit stream
communicating systems
electrical representation
electrical signals
networking device
device data-link
fixed-length parts
layer network
network layer
providing connecti01cs
routing packets
including handling
outgoing packets
incoming packets
maintaining routing
proper response
load levels
levels routers
routers work
layer transport
low-level access
including partitioning
partitioning messages
maintaining packet
packet order
controlling flow
addresses session
session layer
implementing sessions
process-to-process communication
actual communications
remote logins
mail transfers
presentation layer
including character
character conversions
duplex-full duplex
duplex modes
character echoing
application layer
layer deals
file transfe1
remote-login protocols
distributed databases
databases figure
physical flow
stack communicates
message starts
end-user application
application process
process distributed
information transfer-syntax
transfer-syntax negotiation
negotiation data-representation
data-representation transformations
transformations dialog
synchronization control
application entities
network-independent message-interchange
message-interchange service
end message
connection management
error control
network routing
call set-up
clearing application
layer presentation
layer session
layer data-link
data-link control
data transparency
link layer
electrical networkcinterface
networkcinterface connections
physical connection
network termination
termination equipment
iso protocol
data-link -layer
-layer header
header network-layer
network-layer header
header transport-layer
transport-layer header
session-layer header
layer message
_____j data-link
-layer trailer
trailer figure
network message
il1.clude message-header
message-header data
message reaches
data-network layer
data-lil1.k layer
system receives
model formalizes
earlier work
adopted protocol
internet sites
iso networking
illcluding http
connectionless user
user datagram
datagram protocol
connection-oriented transmission
transmission control
control protocol
internet protocol
physical laye1
allowing tcp
physical network
model running
modern communication
communication protocol
authentication ensures
encryption protects
weak authentication
clear-text communication
iso presentation
presentation session
telnet smtp
defined figure
protocol stacks
common protocols
multistep handshake
handshake protocol
authentication devices
adding complexity
protocol modern
modern cpus
perform encryption
offload encryption
separate cryptography
cryptography processors
compromised longdistance
longdistance communication
made secure
virtual private
lan communication
communication remains
strong native
native authentication
lan security
failure detection
link failure
site failure
message loss
detect link
procedure suppose
direct physical
fixed intervals
sites send
j-am-up m.essage
j-am-up message
are-you-up message
replies positively
positive reply
reply tells
direct link
time-out occurs
alternative path
reconfiguration suppose
system believes
longer attempt
failed site
central coordinator
logical ring
constructed note
undesirable situation
sites serve
failed link
smoothly suppose
failed wlcen
handshaking procedure
procedure described
receive information
local tables
routing-table information
mcdelivered messages
fault tolerance
failures making
facility fault
fault tolerant
tolerant starts
protocol level
term fault
broad sense
sense communication
communication faults
machine failures
machine stops
erroneous operation
storage-device crashes
degraded form
components fails
multiple redundant
redundant communication
cmnmunication failure
storage failure
redundant hardware
hardware components
continued access
entire facility
stop operation
inost simple
failure involves
stateless applications
running applications
modify shared
data-centric computing
computing facilities
make fault
failure-monitoring software
special infrastructure
veritas cluster
sun cluster
cluster include
shared disks
running application
automatically restarted
computer fails
application loses
failed system
last wrote
data missing
specific applications
implementing lock
multiple nodes
disks concurrently
concurrently clustered
clustered databases
anode fails
users notice
noncommitted transactions
failed node
client applications
retry noncommitted
database node
node making
key challenge
transparent distributed
user mobility
system facilitates
facilitates user
project athena
mit provide
large scale
smaller scale
-the capability
increased service
service load
load systems
bounded resources
increased load
saturation occurs
cpu runs
high utilization
utilization rate
full scalability
relative property
scalable system
system reacts
performance degrades
resources reach
saturated state
perfect design
ever-growing load
load adding
additional indirect
adding machines
increase service
service loads
expensive design
design modifications
special importance
scalable design
high service
accommodate growth
user community
enable simple
simple integration
added resources
resources scalability
loaded component
faulty component
spare resources
ensuring reliability
handling peak
peak loads
loads gracefully
inherent advantage
inappropriate design
potential fault-tolerance
scalability considerations
considerations call
design demonstrating
demonstrating distribution
great extent
magic guidelines
guidelines ensure
current designs
pose problems
large-scale systems
service demand
service mechanism
load demand
size adding
principle concerns
concerns centralization
central control
control schemes
central resources
systems examples
centralized entities
central authentication
authentication servers
central naming
naming servers
central file
servers centralization
functional asyrrunetry
machines constituting
ideal alternative
symmetric configuration
component machines
equal role
incorporating diskless
diskless machines
machines violates
functional symmetry
workstations depend
central disk
important goals
aspire deciding
process structure
service servers
active clients
single-process server
request necessitates
necessitates disk
blocked assigning
frequent context
related problem
server processes
share information
single requests
clients scheduling
explicit locking
lightweight-process scheme
name-resolution issue
issue raised
processing needed
network number
host number
split varies
internet adrninistrators
adrninistrators assign
assign host-ids
network part
source network
destination network
complete message
packets needed
destination process
packet moves
packet move
ethernet device
unique byte
byte number
lan communicate
send data
software generates
special network
maximum address
address matches
arp request
request responds
mac address
host caches
ip-mac address
address pair
cache entries
eventually forgotten
added performance
arp entries
arp cache
communicate networking
software takes
application laye1
hardware layer
ethernet address
packet damage
upper-level headers
ethernet packets
destination ethernet
packet passing
byte pattern
data pattern
broadcast ethernet
address length
bytes message
message data
data message
detection figure
ethernet packet
network checks
ethernet number
data-link-layer header
packet remain
partially connected
communication-network design
include routing
com1ection strategies
migration protocol
network layering
layering models
adding information
naming system
device address
separate networks
pass packets
detect hardware
hardware failures
devices compared
bad idea
broadcast packets
senses collisions
networking specifies
model provide
provide datagram
datagram service
delivery guarantees
provide reliability
reliability discuss
reliable message
message delivery
network transparent
heterogeneous network
systems describe
architectures running
network topologies
concurrent communications
load balance
routing responsibilities
routing strategy
strategy affect
affect application
application behavior
original http
http protocol
separate tcp
tcp session
destroying tcp
lip connections
problems resulted
implementation method
good alternative
improve http
http performance
viable strategy
static host
host tables
servers generate
satisfy translation
translation requests
address-resolution protocol
host read
protocol explain
www.wiley.com www.cs.yale.edu
www.cs.yale.edu www.apple.com
robust distributed
ethernet segment
decreased network
network performance
hierarchical manner
hierarchical organization
systems tanenbaum
networks williams
covers computer
computer-architecture viewpoint
network programming
operating-system structures
load-balancing dns
dns servers
servers process
previous chapter
discussed network
network construction
low-level protocols
protocols needed
distributed implementation
classical time-sharing
storage resources
common concepts
influential dfs-the
dfs-the andrew
location transparency
distributed files
stateless distributed
improving availability
preceding chapter
coupled computers
computers interconnected
dispersed files
term dfs
commercial transarc
transarc dfs
dfs product
nfs refers
terms service
software entity
entity running
service software
software running
single machine
lower-level interface
actual cross-machine
cross-machine interaction
file services
client interface
file service
primitive file
primary hardware
hardware concponent
server controls
local secondary-storage
concrete configuration
servers run
dedicated machines
conventional operating
distinctive features
centralized file
dfs facilitates
important performance
satisfy service
conventional systems
additional overhead
overhead attributed
distributed structure
overhead includes
cpu overhead
protocol software
ideal dfs
conventional file
dfs manages
dispersed storage
distinguishing feature
space managed
smaller storage
storage spaces
constituent storage
spaces correspond
smallest set
files belonging
physical objects
users deal
data objects
objects represented
file nances
system manipulates
disk tracks
lower-level numerical
numerical identifier
multilevel mapping
transparent dfs
naming mapping
treating files
abstractions leads
mapping returns
multiple copies
related notions
definitions relate
user-level textual
textual names
system-level numerical
numerical identifiers
location-independent naming
dynamic mapping
location independence
stronger property
current dfss
dfss provide
location-transparent mapping
user-level names
systems files
specific set
blocks files
file migration
migration implies
operating-system-initiated action
experimental file
support location
file mobility
mobility afs
afs supports
administrative purposes
afs component
component units
high-level user
low-level names
differentiate location
static location
significant attributes
contents ratber
location location-independent
location-independent files
data containers
data users
locationtransparent manner
logical names
devices location
independence promotes
system-wide storage
single virtual
virtual resource
system location
independence separates
naming hierarchy
storagedevices hierarchy
intercomputer structure
contradicts decentralization
decentralization guidelines
special protocols
boot sequence
diskless workstation
dfs code
special boot
boot protocol
dfs makes
operating-system files
diskless clients
machines require
greater convenience
operating-system upgrade
upgrade occurs
added complexity
boot protocols
performance loss
loss resulting
local disks
user data-and
client systems
main reason
providing clients
pure diskless
diskless systems
generations appearing
limit network
naming schemes
main approaches
unique system-wide
unix-like path
location transparent
location independent
isolated component
entire conventional
component 1-mits
1-mits remain
file-system component
networking package
package supported
vendors nfs
attach remote
local directories
coherent directory
nfs versions
versions allowed
mmmted remote
file-structure names
names components
support transparent
transparent sharing
resulting structure
total integration
component file
single global
structure spans
unix device
device files
machine-specific binary
binary directories
goal difficult
evaluate naming
difficult-to-maintain structure
nfs structure
rem.ote directory
resulting hierarchy
highly m1structured
arbitrary set
separate accreditation
accreditation mechanism
mechanism controls
implementation techniques
techniques implementation
transparent naming
naming requires
file naine
mapping manageable
aggregate sets
component-unit basis
single-file basis
aggregation serves
unix-like systems
hierarchical directory
name-to-location mapping
aggregate files
crucial mapping
mapping information
local caching
independence means
consistent update
information impossible
textual file
lower-level file
file identifiers
file belongs
inevitable price
maps component
update mechanism
mechanism implementing
low-levet location-independent
location-independent identifiers
identifiers makes
hierarchy invariant
component-unit migration
component-unit location
location mapping
low-level identifiers
structured names
bit strings
part identifies
unit variants
individual parts
obtain uniqueness
taking care
apollo domain
location-transparent system
scheme aggregating
aggregating files
lower-level locationindependent
locationindependent file
techniques exemplified
server storing
nanling scheme
machine performs
implementing remote
direct analogy
analogy exists
disk-access methods
remote-service method
remote-service mechanism
reduce disk
basic remote-service
basic caching
caching scheme
data needed
system accesses
accessed disk
repeated accesses
additional network
least-recently-used algorithm
size bounded
server files
master copy
copy residing
relevant consistency
cached copies
copies consistent
dfs caching
server nfs
single access
afs caches
caches files
large chunks
systems discussed
chapter support
support caching
individual blocks
client demand
demand increasing
caching unit
unit increases
miss penalty
miss requires
consistency problems
caching involves
network transfer
transfer unit
rpc protocol
protocol service
service unit
larger units
reception block
total cache
blockcaching schemes
common block
large caches
smaller caches
fewer blocks
lower hit
cache location
stored-on disk
disk caches
clear advantage
main-memory caches
reliable modifications
volatile memory
memory moreove1
caches permit
permit workstations
diskless data
performance speedup
server caches
user caches
user machine
single caching
caching nl.echanism
remote-access implementations
server-side memory
memory caching
provide disk
disk caching
recent solaris
solaris implementations
implementations ofnfs
clientside disk-caching
disk-caching option
nfs client
client reads
reads blocks
memory copy
needed block
cachefs disk
memory cache
cache-update policy
blocks back
critical effect
simplest policy
policy requires
poor write
write performance
performance caching
exploiting caching
delay updates
copy modifications
delayed-write schemes
schemes introduce
introduce reliability
reliability problems
unwritten data
machine crashes
crashes variations
delayed-write policy
policy differ
write-through policy
flush blocks
recent scan
server network
network workstation
workstation figure
cache sprite
30-second interval
interval nfs
server durilcg
cache flush
nfs treats
treats meta
directory data
file-attribute data
file-structure loss
directory-structure corruption
cache area
cachefs improves
decreases performance
high cache
gain performance
write-back caching
reduce network
write-on-close policy
closing process
performance advantages
delayed writes
delayed write
frequent flushing
machine determines
client-initiated approach
validity check
local data
validity checking
resulting consistency
access coupled
access served
intervals depending
server server-initiated
server-initiated approach
server records
server detects
potential inconsistency
inconsistency occurs
modes cache
server play
active role
intended mode
disabling caching
caching results
remote-service mode
service trades
decreased simplicity
substantial number
remote accesses
accesses efficiently
efficiently capitalizing
file-access patterns
patterns makes
obvious total
total network
network overhead
big chunks
transmitting series
specific requests
disk-access routines
contiguous segments
random disk
cache-consistency problem
major drawback
access patterns
patterns exhibit
exhibit infrequent
infrequent writes
mechanisms employed
consistency problem
problem incur
server load
large main
main memories
memories remote
small-memory-capacity machines
lower-level intermachine
intermachine interface
upper-level user
interface mirrors
server-side information
client accesses
accesses remote
server tracks
service provided
scenario involving
server fetches
fetches information
connection identifier
in-core table
subsequent accesses
session ends
stateful service
garbage-collection mechanism
main-memory space
longer active
key point
service approach
main-memory information
clients afs
stateful file
avoids state
request self-contained
request identifies
operation stands
remote message
message reads
remote messages
final close
local operation
operation nfs
stateless file
saving disk
blocks stateless
servers cmmot
stateful server
server loses
volatile state
crash ensuring
graceful recovery
server involves
recovery protocol
protocol based
recovery requires
crash occurred
client failures
reclaim space
crashed client
client processes
stateless computer
computer server
server avoids
reincarnated server
self-contained request
server failures
slow server
recovering server
robust stateless
longer request
request messages
slower processing
in-core i,_lformation
service imposes
additional constraints
target file
low-level naming
translating remote
local names
clients retransmit
retransmit requests
times consecutively
self-contained read
absolute byte
byte count
position withilc
incremental offset
unix read
destructive operations
server employs
server-initiated method
cache validation
provide stateless
implicit offsets
inherently stateful
stateful servers
mailctain tables
current offset
explicit offset
access replication
availability multimachine
multimachine replication
benefit performance
nearby replica
request results
shorter service
replication scheme
file reside
failure-independent machines
nfsv4 ourcov,era.geofnfs
considered version
mostrecentnps standard
differs fundanrentaljy
vious versimi.s
versimi.s jhe
significant ch9nge
stqteful,meaping tha
the.state ofthe
ofthe client
client session
j1lote file
ned untij
untij itis
itis closed
closed th.t1s
thenfs protocol
.proyide .np
operations furthen
parate protocols
lounting remote
remote fil
lockii1g remote
phlgle prqtocol
network fitewalls
nj.ount protocol
notorimis security
nps implem,entations
ability of.dients
tne performapc
a.s plients
file a9cesses
che rgther
rgther thanh
tsjo req
estfile jocks
ll .if
loci ,tmtil
ar,e als
traditiora11y1 unix
.provide advisory
advisory jile
jile locking
windows operatirg
operatirg systen1
v4t1qw.p.rovides mandatory
lockinga11d caching
caching mec
server delegates
delegates responsibilities
lockand contents
.the client
client thatrequested
thatrequested tnel
delegated client
.current version
.the file
deleg21ted client
lock access
a1i.d filt
egated client
client reli11quishesth
lock andde
udj network
network ptqtocol
itto betteraclj
lstto varying
traffic loads
cts reduces
foado11the s.eryet
s.eryet and.i
obvious requirement
requirement implies
replication management
location-opaque activity
activity provisions
users mapping
replicated file
lower-level names
transparency requirement
providing replication
replication control
levels replication
control includes
includes determination
users locus
file denote
logical entity
consistency sen1antics
virtual accesses
logical files
primary incportance
fundamental tradeoff
preserving consistency
sacrificing consistency
guaranteed progress
progress locus
employs replication
sacrifices consistency
accesses ibis
primary-copy approach
pair primary-replica-identifier
local replica
replica exists
identical identifiers
identifiers ibis
ibis supports
supports demand
demand replication
automatic replication-control
replication-control policy
whole-file caching
nonlocal replica
nonprimary replica
replica updates
primary copy
serialized invalidation
nonprimary replicas
stale replica
satisfy remote
remote write
requesting machine
machine andrew
distributed computing
environment designed
information-sharing mechanism
transarc corporation
ibm ibm
afs afs
industry coalition
osf organization
transarc lab
lab announced
open-source product
termed openafs
ibm public
public license
commercial product
product openafs
unix vendors
dce system
make dce
accepted dfs
describe afs
afs seeks
simpler dfss
feature-rich nonexperimental
nonexperimental dfs
location-independent file
client-side caching
cache consistency
server-side caching
automatic switchover
source server
formidable attributes
andrew system
implementations worldwide
overview afs
afs distinguishes
machines servers
wans clients
partitioned space
dedicated servers
location-transparent file
file hierarchy
root file
space descends
descends workstations
workstations run
virtue protocol
space servers
autonomous operation
temporary files
workstation owner
privacy reasons
store locally
locally viewed
finer granularity
clusters interconnected
optimal performance
cross-cluster file
file references
file-system architecture
basic heuristic
offload work
experience indicating
server cpu
key mechanism
cache files
feature reduces
file-open latency
client mobility
mobility clients
initial performance
vice interface
client programs
vice machines
machines authentication
secure-transmission functions
connectionbased communication
communication package
package based
mutual authentication
vice server
client communicate
encrypted messages
messages encryption
software information
protection database
database replicated
server protection
protection afs
protecting directories
regular unlxbits
list ncay
users allowed
directory afs
types read
delete heterogeneity
heterogeneity defining
clear interface
diverse workstation
workstation hardware
links pointing
machine-specific executable
space afs
small component
single client
volumes reside
unix m01mt
m01mt mechanism
granularity difference
mounted volumes
key administrative
administrative unit
vice file
low-level identifier
afs directory
entry maps
path-name component
equal-length components
volume number
vnode number
single volume
vnode numbers
structures compact
compact fids
file movements
cached directory
directory contents
contents location
volume basis
volumes makes
location database
disk partitions
original server
temporary forwarding
forwarding information
handle updates
recent modifications
volume-movement operation
read-only replication
entire volume
system-executable files
seldom-updated files
volume-location database
database specifies
read-write copy
replication sites
fundamental architectural
architectural principle
entire files
client workstation
workstation interacts
vice servers
remote interaction
far-reaching ramifications
workstation intercepts
file-system calls
client-level process
stores modified
modified copies
files back
closed venus
contact vice
individual bytes
bypass venus
sites caching
future opens
file venus
venus assumes
cached entries
cache-validation requests
requests received
client caches
server updates
server notifies
server removes
open purposes
clients caching
file lose
server readin.g
writing bytes
copy venus
venus regains
regains control
venus contacts
contacts vice
callback revoked
modified files
afs implements
implements session
primitive read
operation completes
cached validation
validation traffic
replace callbacks
callbacks lost
network failures
venus considers
cached files
directories suspect
cache-validation request
mechanism forces
maintain callback
callback information
maintain validity
validity information
information maintained
break callbacks
notifying clients
callback state
state maintained
result venus
caches contents
syncbolic links
pathname translation
fetched directories
intermediate directories
future open
open calls
caching policy
well-defined operations
purposes venus
venus reflects
implementation client
usual set
detect references
vice files
relevant operations
client-level venus
venus process
workstation venus
venus carries
translation component
mapping cache
server locations
avoid server
server interrogation
volume location
directory connection
connection establishment
security purposes
disk venus
low-level storage
afs servers
client cache
access unix
unix files
expensive path-name-to-inode
path-name-to-inode translation
translation routine
internal inode
inode interface
client-level processes
additional system
added dfs
ufs venus
venus manages
separate caches
simple least-recently-used
venus notifies
status cache
rapid servicing
data cache
buffering mechanism
single client-level
file req1.1ests
lightweight-process package
non-preemptible scheduling
requests concurrently
rpc package
low-level datagram
datagram abstraction
whole-file transfer
rpc connection
priori binding
processes services
services client
structures needed
single server
disastrous effect
made transparent
facilitates client
client logs
tree requests
complementary methods
service paradigms
feature-rich dfs
dfs characterized
significant consistency
semantics caching
nfs provide
obtain inconsistent
stale data
consistency guaranteed
client ships
entire path
server requesting
client prefer
locationtransparent dfs
location-independent dfs
dfs discuss
dfss discussed
multiclient database
database application
mapping objects
reliable network
recovery control
replicated files
unix environncent
file placement
distributed computer
servers appears
afs system
interesting dfss
unix united
locus unix
locus system
sprite system
mobile storage
considerable research
distributed storage
wide-area settings
centralized synchronization
discuss methods
schemes discussed
present schemes
handling deadlock
events occurred
single common
common memory
determine order
resource-allocation scheme
common clock
occurred first
happened-before relation
partial ordering
distributed algorithm
consistent total
events executed
totally ordered
happenedbefore relation
message constitutes
bare events
irreflexive partial
affect event
space-time diagram
horizontal direction
direction represents
represents space
vertical direction
vertical lines
lines denote
denote processes
labeled dots
dots denote
denote events
wavy line
line denotes
path exists
events related
concurrent events
happened first
processes happened
events agree
son1.e order
synchronized clocks
physical clocks
system event
global ordering
ordering requirement
logical lci
simple counter
counter incremented
increasing value
event bin
bin process
global orderil
situation violates
timestamp-ordering scheme
process identity
identity numbers
break ties
mapping exists
centralized approach
exclusion sends
request message
release message
coordinator checks
coordinator receives
algorithm ensures
critical-section entry
coordinator process
distributed approach
decision making
event-ordering scheme
message request
queueing incmning
incmning requests
reply messages
deferred requests
request timestamp
incoming request
request made
algorithm exhibits
desirable behavior
obtained freedom
ensured freedom
ordering ensures
number represents
required messages
processes act
algorithm functions
sections process
logical clocks
clocks described
replies immediately
receiving replies
process joins
processes participating
mutual-exclusion algorithm
interested reader
entire scheme
scheme collapses
longer send
send request
failed process
process recovers
group processes
stable sets
token-passing approach
processes ilc
process possession
token entitles
single token
organized ilc
process receiving
messages required
high contention
infinite number
low contention
difficulty occurs
single transaction
link connecting
erroneous computations
computations ensuring
system preserves
preserves atomicity
local transaction
transaction coordinator
transactions initiated
transaction breaking
execution coordinating
local site
site maintains
recovery purposes
two-phase commit
commit protocol
final outcome
commit protocols
transaction initiated
executed inform
protocol phase
record prepare
transaction manager
sites determines
portion oft
record ready
received responses
pre-specified interval
participating sites
aborted depending
record commit
record abort
coordinator sends
site receives
message ready
commit tor
site crashes
site responds
coordinator site
final verdict
coordinator writes
record complete
failure handling
major disadvantage
coordinator failure
coordinator recovers
participating site
occurred suppose
site executes
executes redo
executes undo
fate oft
corrnni tted
control records
records implies
s1c failed
s1c means
coordinator fails
failed coordinator
active site
abort tin
preceding cases
cases holds
active sites
additional control
decision is-until
oft remains
hold system
hold locks
unavailable data
data increases
blocking problem
destinations intact
sites connected
previous schemes
links fail
global transaction
transactions executing
concurrency schemes
change needed
lock manager
first deals
data replication
general case
nonreplicated scheme
locking schemes
local lock
items stored
transaction wishes
lock data
lock mode
incompatible mode
lock request
lock n1.anager
n1.anager sends
initiator indicating
simple implementation
message transfers
handling lock
ncessage transfer
handling unlock
deadlock-handling algorithms
single-coordinator approach
single chosen
chosen site-say
manager determines
item resides
handling lmlock
lmlock requests
requests simple
simple deadlock
scheme include
concurrency controller
recovery scheme
lockmanager function
manager administers
distribution reduces
complicates deadlock
majority protocol
nonreplicated data
data scheme
presented earlier
manager controls
replicated inn
manager detern1.ines
scheme deals
replicated data
decentralized manner
requests deadlock
full replication
replication suppose
mode transaction
biased protocol
favorable treatment
exclusive locks
manager manages
site shared
differently shared
common cases
protocol shares
handle concurrency
unreplicated data
data implementation
principal idea
timestamping scheme
unique timestamp
serialization order
centralized scheme
distributed scheme
generating unique
unique timestamps
previous protocols
nonreplicated environment
primary methods
local clock
site generates
local unique
global unique
site identifier
sign.ificant position
global timestamps
timestamps generated
site compare
unique na1nes
local timestamps
faster rate
fast site
fair generation
local timestamp
site local
timestamp site
identifier figure
x,y visits
generate timestamps
basic timestamp
timestamp scheme
scheme introduced
straightforward mamler
centralized case
cascading rollbacks
item value
eliminate cascading
con bine
described suffers
undesirable property
causing aborts
read queue
queue consisting
deadlock-detection algorithms
distributed algorithms
resource-ordering deadlock-prevention
deadlock-prevention technique
unique numbers
unique nl1mber
global resource-ordering
deadlock-prevention scheme
scheme based
timestampordering approach
prevents deadlocks
low priorities
complementary deadlock-prevention
deadlock-prevention schemes
wait-die scheme
nonpreemptive teclmique
smaller timestamp
wound-wait scheme
preemptive technique
wait-die approach
larger timestamp
avoid starvation
starvation provided
smallest timestamp
significant differences
schemes operate
older process
younger process
resource contrast
scheme process
fewer rollbacks
rollbacks occur
unnecessary rollbacks
deadlock-prevention algorithm
preempt resources
ecessary preemptions
graph describing
resourceallocation state
graph represents
local wait-for
graph correspond
graph note
wait-for graphs
usual manner
local processes
global wait-for
local graphs
communication delay
real graph
graph describes
ormliscient observer
constructed graph
approximation generated
reported results
correct algorithms
deadlock-detection coordinator
cycledetection algorithm
coordinator searches
global graph
victim process
graph-construction options
options listed
local graph
coordinator updates
single message
message periodically
periodically returning
coordinator note
false cycle
reasons unrelated
rolled back1
centralized deadlock-detection
false deadlocks
requests coordinator
coordinator figure
unique identifiers
requested resource
initiating message
local information
graph reflects
instantaneous state
initiating messages
controllers share
detecting deadlock
site constructs
waitfor graph
total graph
dynamic behavior
partial graphs
involves construction
scheme differs
additional node
node pex
pex exists
arc pex
graphs results
involve node
cycle involving
involving pex
distributed deadlock
deadlock -detection
-detection algorithm
algorithm suppose
involving node
item located
deadlock-detection message
site sic
deadlock-detection computation
computation halts
message describing
include node
invoked note
deadlock-detection messages
unnecessary message
reduce message
message traffic
site s1c
s1c continues
graphs maintained
sites discover
local cycles
graph site
algorithms employ
performs functions
functions needed
lost token
algorithms assume
largest priority
recovered process
current coordinator
present examples
algorithm applies
systems organized
bully algorithm
algorithm process
election message
number process
coordinator howeve1
message informing
highest number
lower numbers
higher numbers
process forces
active coordinator
lower number
election request
election requests
ring algorithm
main data
algorithm ends
active list
message elect
first elect
elect message
j-thatis,ifthe message
pisnumber -then
largest number
recovering process
inquiry message
turn sends
common value
communication medium
garbled messages
resultilcg lie
unpredictable process
process behavior
processes fail
execution pattern
incorrect messages
failed processes
divisions byzantine
byzantine army
enemy camp
byzantine generals
reach agreement
generals agree
result lie
lie defeat
situation corresponds
unreliable communication
loyal generals
faulty processes
processes lie
unreliable communications
unreliable suppose
function boo
detect failures
acknowledgment message
procedure continues
compute boo
boo note
viable alternatives
respective states
minimal sequence
transfers exists
compute foo
last message
decision procedure
original sequence
faulty suppose
private value
nonfaulty process
conditions exist
nonfaulty processes
correct algorithm
worst-case delay
proportionate tom
message-passing delays
general solution
information exchange
first round
arbitrary value
values reported
majority value
default value-say
exact order
events occur
system timestamps
consistent event
ring-structured networks
validation schemes
unique global
site identification
local clocks
message arrives
primary method
graph methods
graph include
backup coordinator
assume responsibility
centralized environment
hierarchical deadlock-detection
non-leaf controller
relevant information
lowest common
common ancestor
comp1.1ter network
deadlock-detection scheme
deadlockprevention scheme
bidirectional rings
achieving distributed
failure model
faulty processors
processors processors
processors follow
prescribed protocol
unexpected points
processors fail
processors discuss
scheme perform
granting resources
ensures transaction
clock timestamp
scheme presented
cam1.0t order
events based
distinguish concurrent
first general
general algorithm
squareroot algorithm
token-passing algorithm
rilcg-structured systems
systems presented
presented ilc
ilc section
fault-tolerant solution
simple taxonomy
distributed mutual-exclusion
mutual-exclusion algorithms
disjoint processes
distributed solution
dilling-philosophers problem
presume commit
presume abort
defilling default
default assumptions
papers dealing
transaction concept
comprehensive discussions
distributed concurrency
control rosenkrantz
timestamp distributed
distributed deadlock-prevention
distributed deadlock-detection
offer surveys
systems deadlocks
global snapshots
generals problem
ring-structured system
operating-system issues
general-purpose computing
computing systems
period results
results produced
real value
traditional operating-system
stringent timing
timing deadlines
multimedia system
data multimedia
continuous-media data
data continuous-media
handling continuous-media
data require
operatingsystem structure
produce results
real-time computer
soft real-time
defining characteristics
hard real-time
computing results
autonomous robot
delivers mail
office complex
vision-control system
requirement contrast
timing requirement
strict demands
interactive desktop
quick response
interactive user
batch-processing system-m.ay
requirements whatsoever
whatsoever real-time
systems executing
traditional computer
specialized devices
ordinary home
home appliances
consumer digital
digital devices
communication devices
blackberry handheld
larger entities
embedded system
computing device
larger system
home dishwasher
dishwasher-the water
water temperature
timer indicating
computer embedded
system controlling
controlling antilock
antilock brakes
sensor detecting
system controller
controller taking
controller tells
braking mechanism
braking pressure
embedded computer
home furnace
real-time requirements
safety-critical systems
safety-critical system
missed deadline
deadline -results
catastrophe examples
include weapons
weapons systems
antilock brake
brake systems
flight-management systems
worse-might occur
significant majority
including fax
fax machines
missing deadline
deadline requirements
requirements results
unhappy user
critical realtime
realtime tasks
critical real-time
real-time task
receive priority
linux-provide soft
address issues
operating systencs
single purpose
small size
mass-produced specific
specific timing
unlike pcs
mp3 player
navigation system
play dvds
system reflects
single-purpose nature
microwave oven-it
space constraints
processing power
standard desktop
contemporary desktop
small footprints
devices devices
costconscious environments
inexpensively mass-produced
embedded controller
alternative technique
buses provide
mechanism intercom1ectin.g
individual components
system controllers
including cache
memorymouse keyboard
printer figure
bus-oriented organization
attached peripheral
peripheral ports
integrated circuit
soc strategy
final characteristic
characteristic identified
primary task
chapter focuses
issue real-time
systems meet
tim.ing requirements
give real-time
real-time processes
highest schedulil1.g
schedulil1.g priorities
addressing timing
features provided
operatil1.g systems
graphical displays
drives protection
security mechanisms
mechanisms multiple
users supporting
sophisticated -and
-and large-kernel
forty million
million lines
typical real-time
simple design
features listed
systems serve
features found
found il1
digital wristwatch
vision identification
features supported
desktop operating
fast processors
sufficient space
peripheral disk
nonvolatile memory
supporting features
economically impractical
additional considerations
considerations arise
memory features
power consumption
translating addresses
managing address
cpu generate
addresses directly
real-addressing mode-does
employ virtual
real-addressil1.g mode
processes real-addressing
real-addressing mode
translation real-addressing
real-time constraints
performance benefit
register shown
systems configure
obvious benefit
last approach
full virtual
memory functionality
translation takes
attached disk
nvram flash
systems providing
full support
memory keeping
means absolute
provide fewer
kernel minimized
minimized latency
notable feature
networking support
support networking
provide networking
networking capabilities
gathers real-time
real-time data
networking features
system requiring
obvious networking
networking requirencent
basic requirements
requirements listed
preemption recall
algorithms assign
priority based
important tasks
supports preemption
scheduling features
systems assigns
highest levelspriority
levelspriority values
processes solaris
similar prioritization
prioritization schemes
schemes note
priority-based scheduler
functionality hard
deadline requirem
additional scheduling
kernels disallow
disallow preemption
task running
mode designing
traditional user-oriented
user-oriented applications
commercial desktop
xp-are nonpreemptive
real-time systems-in
real-time systems-preemptive
systems-preemptive kernels
kernel preemptible
insert preemption
preemption points
long-duration system
preemption point
point checks
switch takes
call preemption
safe locations
minimizing latency
event-driven nature
occur events
timer expires-or
remote-controlled vehicle
vehicle detects
event occurs
event latency
latency requirements
latency requirement
brake system
occurs event
system responds
latency system
controlling radar
latency period
latencies affect
interrupt latency
latency dispatch
latency interrupt
latency refers
interrupt occursf
specific interrupt
running interrupt
interrupt type
type owitocontiex
tasks receive
factor contributing
updated real-time
deterministic behavior
behavior required
latency providing
cpu mandates
systems minimize
effective technique
keeping dispatch
conflict phase
kernel release
preemption disabled
preemption enabled
affect dispatch
latency arises
kernel event
event response
--------response interval
process made
latency real-time
priority -process
-process m-has
critical process
noncritical processes
processes hard
stricter requirements
individual schedulers
considered periodic
constant intervals
periodic process
fixed processing
processing timet
periodic task
assign priorities
rate requirements
admission-control algorithm
rate-monotonic scheduling
algorithm schedules
periodic tasks
static priority
priority policy
scheduling assumes
processil1.g times
period -ti
-the cpu
total cpu
first deadline
milliseconds remaining
scheduler resumes
rate-monotonic algorithm
algorithm assume
assign process
shorter period
burst process
worst-case cpu
processes approaches
percent combined
processes scheduled
schedule deadlines
missing deadlines
earliest-deadline-first scheduling
dynamically assigns
assigns priorities
edf policy
system priorities
illustrate edf
edf scheduling
processes shown
meet deadline
scheduling recall
earliest deadline
continue running
first deadlines
deadlines process
begins rum1ing
earlier deadline
process require
constant amount
process a1mom1ce
handling deadlines
proportional share
share scheduling
share schedulers
schedulers operate
total processor
examplef assume
total oft
admission control
control policy
allocated shares
client requesting
sufficient shares
admission controller
real-time computingposix
api related
threads pthreads
pthreads defines
sched __fifo
__fifo sched_rr
sched_rr sched__fifo
sched__fifo schedules
first-served policy
blocks sched_rr
priority pthreads
system specific
api specifies
int policy
current scheduling
pthread_attr setsched_policy
non-zero values
set policy
describe vxworks
popular real-time
support vxworks
wind river
river systems
industrial devices
networking equipment
routers vxworks
opportunity-that began
began exploring
planet mars
wind microkernel
microkernel recall
bare minimum
additional utilities
approach offers
including minimizing
desirable feature
small footprint
microkernel supports
basic features
tasks embedded
real-time application
application figure
operating .systent
.systent isbe
singlyinreai-time enviroft
,whereby real-time
real-time tasl
tasl sareassignt
kernel makelinux
even,more suitilb
.embedded systems
systems thes
fullr pree
pree ptive
ptive kernel
.efficient sched-lli11g
ofthe number
enthardlare arc
strategy jew
integrah1lg linux
linux iftto
iftto reanill1e
reanill1e .envirof
involves combini
linux operat
ernet tht
.is theappro
lil_1cux ppt
standard lirn.tx
lirn.tx kernel
kernel run
real7tirlle ketnel
itc tl1rlotac1c11atencyto.thereal-timesystem.rj
ies difft
rent schedulingpolicies
tnd earliest
deadline-first scheduling
separate scheduling
scheduling models
nonpreemptive round-robin
manages interrupts
bounded interprocess
wind micro
pipes-a mechanism
special fik
inheritance protocol
prevent priority
priority mversion
microkernet vxworks
component libraries
required features
size-or footprint-of
system vxworks
first level
per-page basis
policy enables
tasks running
individual processors
cache-coherency policy
tasks maintain
consistent view
optional virtual
memory component
component vxvmi
processor support
optional component
data areas
area marked
kernel modes
applications run
results arrive
results arriving
systems soft
deadline periods
strict timing
inexpensive devices
meet timing
timing issues
algorithms include
earliestdeadline first
first scheduling
scheduling assignb
assignb tasks
scheduling assigns
assigns priority
nuclear power
power plant
fuel economy
economy system
landing system
jet airliner
scheduling illustrate
share scheduler
scheduling inferior
monotonic scheduling
systems handle
wordprocessing documents
files continuous-media
differences affect
chapter objectives
compress multimedia
system requirements
including cpu
term multimedia
mp3 audio
live web
web casts
multimedia files
common standards
representing multimedia
media delivery
delivery multimedia
multimedia file
specific rate
special timing
rate video
rapid succession
video appears
human eyes
eye retains
choppy-looking presentation
video file
rate consistent
laptop computer
audio file
handheld mp3
data comprise
system multimedia
smaller device
handheld computer
cellular telephone
telephone data
live continuous
continuous media
streaming techniques
progressive download
real-time streaming
media file
small media
media files
clips differs
long videos
internet radio
rewind operations
dvd controller
dvd disc
5-minute streaming
streaming video
movie clip
media stream
live streaming
ondemand streaming
radio program
program broadcast
live real-time
real-time stream
favorite radio
radio station
internet live
video conferencing
live delivery
delivery means
live stream
earlier portions
radio broadcast
broadcast on-demand
on-demand streaming
deliver media
media streams
full-length movies
archived lectures
news broadcast
on-demand stream
dvd player
convenient time-there
arriving late
late depending
stream examples
well-known streaming
streaming media
media products
products include
include realplayer
apple quicktime
windows media
media player
client media
media players
traditional applications
100-minute mpeg-1
mpeg-1 video
high-defuution television
storing hundreds
high data
color video
frame requires
required multimedia
timing delays
continuous-media file
deliver continuous-media
requirements-of continuous
media providing
qos guarantees
guarantees affects
management specific
processing multimedia
multimedia tasks
ensure meeting
media network
support bandwidth
bandwidth requirements
minimizing delay
compressing multimedia
compression makes
significant demands
smaller form
quickly compression
network cormection
discussing file
file compression
compressed file
compression ratio
file affects
decompression compression
compression algorithms
lossy compression
original data
lossless compression
compression ensures
generat lossy
lossy techniques
techniques provide
higher cone
cone pression
pression ratios
lossy compression-namely
video lossy
low frequencies
human ear
video operate
successive frames
frames lossless
lossless algorithms
compressing text
compressed files
compression schemes
moving picture
picture experts
experts group
mpeg mpeg
mpeg refers
file formats
compression standards
audio portion
layers layers
video portions
file layer
timing information
mpeg player
major mpeg
mpeg standards
audio stream
conventional vcr
vcr videos
videos mp3
popular medium
storing music
audio layer
practice compression
compression ratios
compressing dvd
digital television
including high-definition
high-definition television
video compression
typical bit
bit rates
encoded files
higher rates
local playback
transmit audio
three-dimensional animation
animation layers
layers animation
animation makes
end users
potential home
home buyer
virtual tour
appealing feature
scalable level
allowing delivery
slow network
bps modems
high-speed local
area networks
wireless devices
including handheld
standards discussed
perform lossy
high compression
mpeg performs
performs compression
characteristics described
require levels
spreadsheets tin1.ing
foremost concern
video data
data demands
rate constraints
constraints tasks
request data
constant intervals-or
playback maintaining
rate requires
succeeds frame
video playback
displaying frame
qos levels
best-effort attempt
level treats
traffic streams
best-effort service
quality-of-service requirements
traditional operating
operating systems-the
systems-the systems
worst-case workload
demand exceeds
exceeds resource
resource capacity
next-generation multimedia
provide continuous-media
continuous-media applications
guarantees made
hard qos
enable multimedia
service-level guarantees
parameters defining
defining qos
delay refers
desired result
delay jitter
jitter refers
on-demand real-time
pauses-or lost
frames-during playback
playback clients
worth-before beginning
beginning playback
playback reliability
reliability refers
lost packets
processing delays
these-and other-scenarios
streaming service
negotiating quality
content provider
provide qos
everyday lives
movie theater
everyday life
admission-control policy
multimedia environment
simple admission-control
nonshareable resources
implementing admission
reservation request
resource il1
il1 advance
admission-control scheme
scheme assigns
resource arrives
resource manager
qos demands
manager reserves
requesting client
desired qos
qos requirements
ensure qos
cineblitz multimedia
multimedia storage
storage server
covers real-time
critical processes
noncritical process
typical requirement
unusable multimedia
critical task
guaranteed period
scheduling issue
non-real-time tasks
systems assign
scheduling strategies
strategies discussed
deadline qos
discussed disk
handle conventional
scheduling goals
traditional disk
disk schedulers
schedulers employ
continuous-media files
preserve qos
diskscheduling algorithms
conflict continuous-media
high disk-bandwidth
disk-bandwidth rates
data-rate requirements
low transfer
latency rates
high bandwidth
continuous-media systems
deadlines edf
order requests
current cylinder
closest deadline
serviced first
higher seek
seek tim.es
strict edf
head passes
disk scheduler
deadline requirement
scan-edf scheduling
fundamental problem
unacceptable seek
affect disk
throughput recall
issue faced
adopting scan
scan schedulil
arm reaches
reverse direction
strategy optimizes
optimizes seek
times scan-edf
hybrid algorithm
combines edf
scheduling scan-edf
scan-edf starts
edf ordering
services requests
deadline usil
scan order
batch requests
scan ordering
batching requests
similar deadlines
reordering requests
deadlines fall
requested cylinder
batching scheme
first batch
last batch
service request
moving downward
cylinder nun1.bers
first service
heads begin
moving upward
requests hand
final batch
foremost qos
qos issue
systems concerns
concerns preserving
preserving rate
client wishes
video compressed
required rate
quality-ofservice requirements
internet-issues relating
network delivers
network issues
unique demands
general -and
provide network
proprietary protocols-notably
meet qos
encounter congestion
traffic issues-issues
end hosts
server delivering
client playing
internet standard
including audio
transporting media
media formats
files compressed
mpeg rtf
remove jitter
jitter introduced
unique requirements
delivering content
server delivers
separate unicast
method lies
unicast delivery
unicast session
public internet
multicasting appears
reasonable compromise
clients indicating
practical standpoint
intermediate routers
originating server
support multicasting
delays incurred
intermediate router
multicast stream
unicast channels
multicasting routers
reasonable physical
physical proximity
chief executive
executive officer
streaming protocol
randomly access
standard web
hypertext transport
transport protocol
deliver documents
play media
media streamed
uniform resource
resource locatm
real audio
streaming windows
conventional web
standard http
http requests
delivering streaming
media content
client wished
resume playback
protocol designed
streaming servers
significant advantage
advantage rtsp
random positions
playback delivery
streami.j.1.g media
streaming server
rtsp protocol
rtsp defines
rtsp streaming
commands i.j.1.clude
server allocates
allocates resources
session established
setup command
server suspends
suspends delivery
server breaks
state machine
rtsp server
rtsp commands
media offers
networking issues
interested readers
high-performance media
cineblitz refers
constraints cine
cine blitz
blitz guarantees
real-time clients
data retrieval
cineblitz disk-schedulu1.g
admission-control algorithms
algorithms setup
setup play
play tear
pause figure
finite-state machine
machine representing
representing rtsp
cineblitz disk
scheduler services
service cycle
heads move
reversing direction
pure scan
cil eblitz
monitor requests
non-real-time clients
clients receive
receive service
rate guarantees
guarantees required
term client
client refers
real-time client
cineblitz monitors
disk latency
cineblitz admission
controller admits
retrieve data
rate cineblitz
cineblitz queues
queues requests
cyclic order
total buffer
idea behil
bound requests
first estimated
estimated service
service times
admitted requests
double buffer
buffer total
double buffering
cinebiitz bits
admission policy
blocks thatcanberetrievedforrequest
thatcanberetrievedforrequest r1c
r1c duringeachcycleis
r1c bits
last portion
block involves
track contailling
rotational delay
desired track
c-scan disk-scheduling
sorted order
worst-case seek
delay times
maximum latency
latency incurred
tseek component
component refers
maximum disk-seek
disk-seek latency
component reflects
blocks multiplied
worst-case rotational
yic bits
request r1c
r11 bits
free buffer
files include
include video
audio filesf
desktop computersf
digital assistantsf
deadline requiren
requiren ents
timing requirementsf
playback multimedia
multimedia server
qualityof service
service requirementsf
provide quality
servicef multimedia
system accepts
quality-of-service level
request providing
providing quality-of-service
guarantees requires
system performs
performs cpu
cpu schedulingf
schedulingf disk
disk schedulingf
continuous-media task
scheduling criterion
criterion network
handle delay
jitter caused
traditional internet
internet protocols
transmitting data
contrast unicastingf
unicastingf multicastingf
target bit
bit rate
desired bit
color assuming
application consists
compressed sizes
streaming applications
tolerate delay
tolerate jitter
jitter live
streaming on-demand
cylinders requests
deadlines occurring
scan-edf disk
requests batched
repeat exercise
operating principle
blitz system
performing admission
systems topics
topics related
resource management
processing capability
system discussions
programming model
developing multimedia
rate-monotonic scheduler
serving video
schedule-management issues
great detaiilinux
full-featured unix
operating-system source
recent operating
gaining popularity
stand-alonemachine market
workgroup-server market
on-line coverage
freebsd system
linux combines
combines features
bsd model
freebsd source
unix windows
windows applications
chapter presents
in-depth examination
practice linux
gained popularity
programmer interfaces
linux presents-interfaces
unix tradition
internal methods
interfaces linux
evolving operating
chapter describes
describes developments
linux schedules
schedules processes
devices linux
unix compatibility
design goal
linux project
development began
finnish student
christened linux
self-contained kernel
first true
pc-compatible cpus
initial kernel
unix functionality
linux development
development revolved
central operating-system
privileged executive
full operating
operating systeitl
original piece
software developed
linux con1.munity
development projects
basic linux
standard environment
user programming
standard means
linux distributions
standard components
administrative tools
initial installation
subsequent upgrading
manage installation
modern distribution
includes tools
first linux
kernel released
80386-compatible intel
intel processors
device-driver support
early incarnation
incarnation supported
minix file
system -the
minix platform
implement proper
proper unix
unix processes
protected address
milestone version
release culminated
rapid development
limlx kernel
single biggest
included support
standard tcp
lip networking
bsd-compatible socket
networking programming
programming device-driver
slip protocols
serial lines
enhanced file
original minix
scsi controllers
high-performance disk
developers extended
support paging
swap files
arbitrary files
extra hardware
cd-rom devices
sound cards
international keyboards
floating-point emulation
math coprocessor
unix-style inclllding
implemented simple
simple support
unloadable kernel
development started
kernel stream
numerous bug-fix
bug-fix patches
standard numbering
numbering convention
kernels kernels
odd minor-version
minor-version number
evennumbered minor-version
minor-version numbers
stable updates
stable kernels
remedial versions
development kernels
untested functionality
pci hardware
architecture developers
developers added
pc-specific feature-support
virtual8086 mode-to
dos operating
networking stack
ipx protocol
including accounting
firewalling functionality
final pc-only
pc-only linux
source distribution
implemented support
full integration
stable kernel
release concentrated
wider hardware
complete implementations
existing functionality
main kernel
development stream
functionality added
major version-number
version-number increment
multiple architectures
64-bit native
native alpha
alpha port
multiprocessor architectures
architectures linux
distributions based
motorola 68000-series
68000-series processors
sparc systems
derived version
linux running
powermac systems
memory-management code
unified cache
kernel offered
memory performance
file-system caching
writable memory-mapped
memory-mapped regions
improved tcp
including apple
apple talk
anlateur radio
radio networking
isdn support
mount remote
remote netware
microsoft lanmanager
network volumes
major improvements
handling dependencies
automatic loading
dynamic configuration
standardized configuration
configuration interface
file-system quotas
posix-compatible real-time
real-time process-scheduling
process-scheduling classes
classes improvements
improvements continued
ultrasparc systems
added networking
flexible firewalling
traffic management
large window
selective acks
acks acorn
kernel-mode nfs
nfs daemon
daemon added
performance advances
kernel include
memorymanagement system
kernel forms
components make
complete linux
code written
supporting software
unix-like operating
tools developed
bsd operating
main system
addressing omissions
high quality
networkingadministration tools
recent bsd
bsd derivatives
borrowed code
return examples
intel floating-point-emulation
floating-point-emulation math
sound-hardware device
loose network
developers collaborating
small groups
specific components
internet file-transfer-protocol
archive sites
sites act
standard repositories
standard specifies
names configuration
system binaries
run-time data
latest revisions
ftp sites
linux user
carry out
precompiled sets
easy installation
extra system-installation
management utilities
ready-to-install packages
common unix
unix tools
news servers
editing tools
first distributions
distributions managed
important contributions
modem dish
dish ibutions
advanced package
package management
management today
package-tracking database
removed painlessly
sls distribution
first collection
linux packages
complete distribution
single entity
sls lacked
packagemanagement tools
distribution represented
great improvement
poor package
installed distributions
noncommercial limlx
limlx distributions
popular distributions
commercial linux
linux support
support company
free-software linux
supported versions
linux include
include distributions
large linux
german-language distributions
including versions
prohibit compatibility
rpm package
package file
commercial applications
applications distributed
accept rpm
rpm files
linux licensing
gnu general
software fmmdation
fmmdation linux
public-domain software
software implies
waived copyright
copyright rights
linux code
authors linux
main implications
licensing terms
legitimate exercise
derived product
product proprietary
proprietary software
software released
gpl camwt
binary-only product
release software
components covered
make source
binary distributions
resh iction
prohibit ntaking-or
selling-binary-only software
software distributions
receives binaries
reasonable distribution
distribution charge
linux resembles
nonmicrokernel unix
unix implementation
tools linux
system adheres
networking model
internal details
early development
individual enthusiasts
well-funded development
research facilities
start linux
linux attempted
limited resources
multiprocessor machine
minimalist limix
limix kernels
kernels grew
functionality speed
prices paid
unix implementations
posix standards
standards comprise
common operating-system
operating-system functionality
process threads
real-time operations
operations linux
relevant posix
posix documents
achieved official
official posix
posix certification
linux presents
linux programming
interface adheres
svr4 unix
bsd behavior
implement bsd
bsd semantics
behaviors differ
differ significantly
standards exist
full certification
expense involved
wide base
major goal
formally certified
basic posix
posix threading
threading extensions-pthreads
main bodies
important abstractions
processes system
libraries define
standard set
functions implement
full privileges
code system
perform individual
specialized management
management tasks
unix terminology
incoming network
accepting logon
logon requests
updating log
full linux
important distinction
code executes
computer linux
linux refers
user-mode code
operating-system-support code
messagepassing architecture
kernel internals
linux retains
historical model
monolithic binary
hardware interrupt
delivered linux
modules figure
core scheduling
memory code
networking code
kernel components
components share
m.elting pot
needed piece
independent loadable
loadable components
run processes
protected access
hardware resources
kernel implements
features required
extra features
unix application
application expects
applications make
make calls
turn call
operatingsystem services
simplest level
kernel-system service
requests making
call involves
transferring control
tmprivileged user
privileged kernel
transfer vary
system-call arguments
special form
complex versions
file-handling functions
advanced control
basic kernel
kernel system
provide routines
sorting algorithms
string-manipulation routines
system includes
user-mode programs-both
programs-both system
user utilities
utilities include
configure network
load kernel
server programs
programs handle
handle user
login requests
printer queues
standard utilities
utilities serve
key system-administration
system-administration functions
unix user
user environment
simple everyday
everyday tasks
listing directories
complex utilities
text-processing functions
performing pattern
pattern searches
input text
utilities form
standard tool
tool set
basic limix
arbitrary sections
modules run
hardware capabilities
networking protocol
protocol kernel
reasons linux
write kernel
modified kernel
entire kernel
cumbersome cycle
driver-the driver
already-rmming kernel
proprietary components
components added
module interface
gpl kernel
standard minimal
minimal kernet
extra device
drivers built
cd-rom driver
module support
reserve hardware
module management
management loading
module requires
binary contents
module makes
correct locations
linux deals
reference updating
module loading
separate sections
module code
linux maintains
internal syncbol
syncbol table
symbols defined
exported symbols
symbols constitutes
well-defined interface
exporting symbols
kernel function
special effort
module writer
standard external
external linking
external symbols
symbols referenced
final module
module binary
binary produced
system utility
unresolved references
correct addresses
running kernel
module passed
moduleloader utility
utility asks
continuous area
kernel returns
loader utility
machine code
correct loading
loading address
final module-management
module-management component
module requestor
kernel defines
communication interface
module-management program
connection established
management process
network service
original service
manager process
loaded module
actively needed
driver registration
isolated region
dynamic tables
startup routine
cleanup routine
separate mechanisms
device registration
registration tables
drivers include
include character
interface devices
devices file
implements linux
virtual-file-system calling
calling routines
storing files
system network
entire networking
networking protocot
packet-filtering rules
firewall binary
binary format
format specifies
conflict resolution
commercial unix
single-supplier solution
software vendor
hardware configurations
large numbers
video display
display adapters
modular device
active set
dynamically variable
variable linux
central conflict-resolution
conflict-resolution mechanism
arbitrate access
prevent modules
prevent aui
oprobes-device-driver probes
configuration-from interfering
existing device
multiple drivers
parallel printer
printer driver
network driver
printer port
maintains lists
allocated hardware
limited number
dma channels
kernel database
database first
alternative hardware
basic context
user-requested activity
unix linux
linux operates
key places
introduce linux
threading model
basic principle
separate functions
rumung program
great simplicity
original program
process encompasses
single execution
specific sections
process properties
properties fall
identity consists
lmique identifier
additional identifiers
identifiers associate
process group
processes forked
session credentials
access system
personality process
process personalities
personality identifier
calls personalities
emulation libraries
limited control
session identifiers
security checks
checks howeve1
primary pid
uniquely identifies
process environment
null-terminated vectors
argument vector
enviromnent vector
command-line arguments
environment vector
value pairs
named environment
environment variables
arbitrary textual
textual values
user-mode address
first datum
environment vectors
parent possesses
calling exec
kernel passes
enviromnent variables
current environment
command-line vectors
alone-their interpretation
user-mode libraries
process provide
flexible ways
pass information
user-mode system
important environment
conventional meanings
related parts
terminal com1.ected
perform operations
text programs
multilingual support
display system
system messages
environment-variable mechanism
mechanism custom-tailors
per-process basis
process context
environment properties
constantly process
context includes
scheduling context
scheduling context-the
context-the information
saved copies
registers floating-point
floating-point registers
floating-point arithmetic
includes information
outstanding signals
signals waiting
key part
separate area
memory reserved
kernel-mode code
stack accounting
total resources
resources consumed
entire lifetime
table file-system
file-system context
context applies
current root
default directories
file searches
signal-handler table
table unix
external events
table defines
specific signal
signal arrives
memory context
context describes
full contents
private address
process linux
entire context
main process
independent subcontexts
arguments passed
subcontext data
data struch1res
struch1res initialized
allocating cpu
kernel tasks
tasks kernel
tasks encompass
scheduling linux
separate process-scheduling
process-scheduling algorithms
time-sharing algorithm
absolute priorities
time-sharing tasks
tasks received
major overhaul
earlier versions
processor affin.ity
maintaining fairness
unique nature
runqueue data
arrays includes
vice-versa tasks
o-o figure
slices linux
realtime scheduling
classes required
priority irt
irt addition
class processes
time-sharing scheduling
waiting longest
fcfs processes
processes continue
round-robill process
scheduling queue
round-robin processes
unlike routine
priorities linux
scheduler offers
strict guarantees
reahim.e process
kernel synchronization
kernel schedules
kernel-mode execution
kernel-defined handler
problem posed
sanl.e internal
kernel task
risking data
fact relates
critical sections-portions
access shared
synchronization involves
nonpreernptive kernet
kernet meaning
higherpriority process
task disables
field preempt_count
counter indicating
longer periods
protection technique
linux applies
basic tool
interrupt-control hardware
kernel guarantees
hardware architectures
interrupt enable
disable instructions
interrupts remain
device waiting
synchronization architecture
entire duration
interrupts disabled
user-mode programs
interrupt protection
protection levels
levels linux
separating interrupt
top half
bottom half
normal interrupt
recursive interrupts
interrupts enabled
miniature scheduler
bottom halves
bottom-half scheduler
routine exits
separation means
complex processing
half execute
running completes
similar bottom
disabling selected
selected bottom
foreground kernel
relevant bottom
tl1e end
bottom-half tasks
top-half interrupt
section figure
code running
scheduling interrupt
first stable
stable linux
support hardware
smp imposed
kernel spinlock
termed bkl
big kernel
kernel lock
kernel concurrently
bkl provided
coarse level
locking granularity
kernel made
smp implementation
multiple locks
kernel provided
additional smp
smp enhancements
load-balancing algorithms
algorithms memory
physical memory-pages
small blocks
memory mapped
hardware characteristics
linux separates
zone_dma zone_normal
zone_normal zone_highmem
architecture specific
standard architecture
memory comprise
comprise zonldma
zonldma zone_normal
zone_normal identifies
32-bit intel
intel architecture
remaining memory
intel80x86 architecture
memory arrives
kernel satisfies
priinary physical-memory
physical-memory manager
lil lux
lux kernel
page allocator
allocating ranges
adjacent units
allocatable memory
adjacent partner
allocated partner
partner regions
larger region-a
region-a buddy
buddy heap
larger region
larger free
free region
small memory
memory request
small free
memory regions
allowable size
smallest size
buddy-heap allocation
desired size
memory allocations
basic allocator
reserve memory
memory-management subsystems
underlying page
variable-length allocator
entire pages
smaller blocks
additional allocator
arbitrary-sized requests
service allocates
allocates entire
service allocating
memory involves
free piece
memory shortages
strategy adopted
free kernel
main subsystems
main cache
main mechanism
native linux
linux diskbased
diskbased file
nfs networked
cache stores
stores entire
networked data
systems interact
cache requires
mapping pages
creates pages
manages loading
separate views
separate regions
first view
describing instructions
space consists
nonoverlapping regions
region representing
page-aligned subset
single vm_area_struct
vm_area_struct structure
execute permissions
balanced binary
binary tree
fast lookllp
physical view
pagetable entries
entries identify
exact current
virtual mernory
software-interrupt handlers
address-space description
key page-management
page-management functions
unavailable page
central memorymanagement
memorymanagement routines
regions linux
region backed
simplest type
region represents
demand-zero memory
memory filled
file acts
pager detects
region result
object mapped
empty virtual
concplete copy
kernel copies
vm_area_struct descriptors
page covered
child share
copying operation
operation reaches
process copies
brand-new page
mechanism ensures
relocate pages
systems performed
modern versions
paging-the movement
disk linux
whole-process swapping
paging mechanism
mechanism exclusively
pages data
data back
pageuut policy
standard clock
multiplepass clock
accessed pages
higher age
age value
age valuing
select pages
supports paging
dedicated swap
swap devices
normal files
slower due
overhead incurred
system blocks
next-fit algorithm
out pages
continuous runs
allocator records
page-not-present bit
pagetable entry
index identifying
memory linux
linux reserves
architecture-dependent region
kernel pages
kernel virtual
static area
simple translation
addresses occurs
reserved section
function allocates
single region
contiguous kernel
function maps
call commands
current execution
initial context
system service
permission rights
kernel invokes
loader routine
program file
single routine
loader functions
initial reason
loader table
changed older
older linux
kernels understood
out format
binary files-a
simple format
older unix
systems newer
newer linux
modern elf
elf format
current unix
implementations elf
including flexibility
elf binary
extra debugging
loader routines
allowing registration
multiple loader
binary formats
single rmming
rmming system
elf-format binaries
out binaries
binary loader
fault result
initial memory
elf-format binary
file consists
page-aligned sections
elf loader
loader works
typical layout
regions set
reserved region
space sits
privileged region
normal user-mode
memory-mapping functions
create regions
data regions
user-mode virtual
lower-numbered addresses
includes copies
program il1
bottom end
program text
write-protected region
writable initialized
initialized data
private demand-zero
demand-zero region
fixed-sized regions
variable-sized region
hold data
data allocated
current extent
data region
brk region
single system
call -sbrko
loader initializes
program-counter register
point recorded
elf header
run functions
library functions
linked executables
program generated
disk-space usage
single loading
happen linux
special linker
linker library
linked program
linked function
static function
link library
library determines
dynamic libraries
libraries required
information contained
symbols contained
position-independent code
retains unix
standard file-system
file-system model
object stored
data device
interprocesscommunication channels
kernel handles
file system-ext2fs
object-oriented principles
object represents
ldividual directory
operations includes
struct file_operations
file-system objects
network socket
first obtaining
object pointing
process asked
write permissions
perform adaptive
fetching file
performance file
inode objects
standard information
recently modified
modified directory
unix programming
interface defines
files concerned
connected set
self-contained file
single superblock
device mounted
main responsibility
vfs identifies
number pair
separate dentry
dentry objects
treats directory
path requires
file include
file stdio
translation obtaining
dentry cache
linux ext2fs
ext2fs file
standard on-disk
historical reasons
minix-compatible file
ease exchanging
exchanging data
minix development
development system
14-character file-name
file-name limits
maximum file-system
file-system size
extended file
missing features
features led
linuxs ext2fs
bsd fast
storing data-block
data-block pointers
interpreted differently
entry refers
ffs lie
disk-allocation policies
filled blocks
smaller units
default block
requests clustering
clustering reduces
per-request overhead
disk-controller hardware
allocation policies
policies designed
adjacent blocks
ext2fs allocation
multiple block
block groups
groups ffs
similar concept
cylinder groups
group corresponds
single cylinder
modern disk-drive
disk-drive technology
technology packs
packs sectors
cylinder sizes
fixed-sized cylinder
block group
inode allocations
parent directory
directory resides
nondirectory files
files directory
disk load
reducing fragmentation
first blocks
ext2fs searches
entire free
free byte
free bit
free bytes
bytes aims
extended backward
allocated block
backward extension
extension prevents
prevents ext2fs
previous nonzero
nonzero byte
byte found
byte search
ext2fs extends
allocation forward
blocks allocating
continuous free
blocks block
ieee block
block selected
allocator ___
___ bitmap
bitmap search
search bit
bit boundary
boundary byte
byte boundary
boundary figure
ext2fs block-allocation
block-allocation policies
extra blocks
preallocation helps
reduce fragmentation
in.terleaved writes
separate files
cpu cost
allocating multiple
blocks simultaneously
preallocated blocks
free-space bitmap
closed figure
row represents
unset bits
allocation bitmap
long run
isolated blocks
large free
free areas
block close
fragmented area
allocation preceding
allocation flush
default allocation
popular feature
call modifying
journal entries
entries relating
actual file-system
separate read-write
system recovers
remain consistent
checking journaling
non-journaling systems
in-memory journal
file-system metadata-oriented
deletion journaling
unux process
process file
vfs enables
linux svr4
unix introduced
efficient interface
debugging support
system corresponded
system reveals
asch decimal
decimal representation
extra directories
entries correspond
loaded drivers
plain text
powerful tools
unprivileged program
directory structu.re
directory inodes
inodes identified
system nmst
nmst define
persistent inode
file inode
directory inode
textual form
read buffer
information type
type splits
bits define
pid field
separate global
global files
files exist
exist iil
report information
inode mappings
ode numbers
file-system entries
ode number
contents drivers
deregister entries
kernel variables
variables files
common handlers
kernel parameters
desired values
ascii decimal
efficient access
system sysctl
extra facility
dynamic entry
entry tree
files users
access channel
user opening
device referenced
normal file-protection
file-protection device
driver driver
application character
character device
device file
file character
protocol dlsciptlne
driver figure
device-driver block
block structure
set access
device linux
linux splits
device-driver system
memory block
fine-tuned laying
fundamental difference
random access-block
access-block devices
accessed serially
pointil1.g device
devices users
networking subsystem
devices block
devices provide
main interface
block-device system
block represents
kernel performs
request manager
buffer contents
block-device driver
separate list
request lists
increasing starting-sector
starting-sector number
removed fronc
driver continues
active request
request ncanager
ncanager attempts
merge requests
operations changed
elevator algorithm
operations concentrated
specific region
starvation issue
deadline sched
uler maintains
sorted queue
operations ordered
queues-a read
deadline expires
expired request
policy ensures
character-device driver
offer random
fixed blocks
character-device drivers
drivers registered
lim.jx kernel
device deal
main exception
special subset
implement terminal
terminal devices
tty struct
struct structures
line discipline
common line
tty discipline
output streams
tty line
processes connected
line disciplines
networking connection
serial line
terminal system
networking system
network-device drivers
data appearing
network-device driver
driver linux
rich environment
involve transferring
standard lim.ix
lim.ix mechanism
processes owned
carry information
process sigrl.als
generates signals
data arrive
network channel
child terminates
timer expires
receive notification
kernel takes
scheduling states
wai t_queue
t_queue structures
relevant events
single event
memory successfully
semaphore mechanism
multiple semaphores
linux wait
queue mechanism
mechanism synchronizes
synchronizes processes
linux offers
unix mechanism
communication channel
virtual-filesystem software
wait queues
writer unix
networking facilities
send streams
remote processes
processes networking
process communications
communications method
suspend execution
occurs shared
interprocess-communication mechanism
missing synchronization
persistent object
independent address
linux paging
paging algorithms
shared-memory pages
object acts
memory-mapped memory
virtual-address-space region
shared-memory mappings
direct page
persistent shared-memory
sharedmemory objects
objects remember
key area
standard internet
unix-to-unix communications
protocols native
non-unix operating
server-class systems
interface protocol
protocol drivers
networking requests
bsd socket
socket layer
programs designed
berkeley sockets
section a.9.1
represent network
single interface
protocols implemented
standard bsd
bsd systems
protocols supported
sown framework
networking data
protocol set
protocols manage
error reporting
reliable retransmission
protocol layer
rewrite packets
reassemble packets
discard incoming
finished processing
local connection
layer decides
single skbuff
socket buffer
single continuous
buffer inside
add data
trim data
modern microprocessors
skbuff architecture
manipulating packet
unnecessary data
important set
linux networking
suite comprises
protocol implements
implements routing
routing protocol
icmp protocols
udp protocol
arbitrary individual
individual datagrams
tcp protocol
reliable connections
guaranteed in-order
in-order delivery
automatic retransmission
icmp protocol
status messages
identifier indicating
networking-device drivers
drivers encode
protocol type
networking-protocol identifiers
kernel-loadable modules
modules incoming
perform routing
driver forwards
internal protocol
protocol driver
network-device-driver queue
routing decision
persistent forwarding
information base
recent routing
routing decisions
fib holds
holds routing-configuration
routing-configuration information
routes based
specific destination
wildcard representing
representing multiple
multiple destinations
hash tables
tables indexed
tables representing
specific routes
searched first
successful lookups
route-caching table
caches routes
route cache
cache expires
fixed period
software passes
passes packets
management-selective filtering
arbitrary criteria
firewall manager
separate chain
chain chains
separate purposes
forwarded packets
data generated
ordered list
rule specifies
firewall-decision functions
matching purposes
functions performed
large packets
outgoing packet
smaller fragments
receiving host
driver maintains
ipfrag object
fragment awaiting
assembled incoming
incoming fragments
final fragment
driver packets
packets identified
tcp protocols
protocols share
associating packets
destination sockets
connected pair
socket lists
tables keyed
address-port values
socket lookup
unreliable connections
ordered lists
unacknowledged outgoing
out-of-order packets
missing data
arrived linux
typical unix
authentication making
entry rights
rights access
control providing
preventing access
authentication authentication
readable password
random salt
salt value
one-way transformation
transformation function
function means
original password
password cam1ot
value stored
result matches
problems passwords
salt values
good chance
lmauthorized access
accounts compromised
result extensions
password mechanism
secure methods
authentication mechanisms
mechanisms exist
distribute authentication
related systems
security mechanism
address authentication
authentication problems
system component
linux pam
authentication modules
system-wide configuration
authentication mechanism
pam modules
account restrictions
sessionsetup functions
password-changing functions
users change
unique numeric
numeric identifiers
single set
group identifier
extra identifier
identify rights
rights belonging
standard access-control
shared-memory sections
group access
single uid
single gid
uid matches
object linux
linux performs
performs access
assigning objects
world access
full read
execute access
privileged uid
special uid
automatic access
normal access
granted permission
privileged operations
reserved network
normal users
key internal
internal resources
root uid
uid linux
unix setuid
section a.3.2
user running
lpr program
print queue
print queues
setuid distinguishes
effective uid
real uid
posix specification
user-id mechanism
uid repeatedly
security reasons
safe mode
privileges granted
setuid status
selected operations
implementations achieve
effective uids
previous effective
program saved
saved uids
enhancement provided
effective ids
serve files
flexible passing
another-a mechanism
duplicate file
pass access
print server
print job
print client
server file
server access
files linux
free operating
system based
unix standards
unix applications
increasing number
supported applications
applications linux
core linux
linux operating-system
free unix
unix software
entire unix-compatible
unix-compatible operating
proprietary code
traditional monolithic
monolithic kernel
created processes
selective parts
programming interprocess
mechanisms-message queues
memory-and bsd
interface multiple
multiple networking
processes pages
lfu algorithm
system appears
abstraction layer
manage multiple
device-oriented file
systems access
defined inside
scheduler implements
programming tasks
linux setuid
feature differ
socket type
intercomputer file-transfer
file-transfer program
network explain
copy-on-write attribute
attribute enabled
extra costs
cloned thread
linux developers
memory-management architectures
architecture-specific kernel
programming technique
technique describe
implement threads
linux clone
alternative mechanism
cd-rom vendors
process request
primary goals
loading kernel
libraries perform
drawbacks explain
design decision
include files
types affect
classify linux
threads support
optimizations based
rotation position
sequential data
rotational optimization
operation supported
system-call sequence
sequence fork
key sites
sites reference
linux cross-reference
cross-reference pages
maintain current
current listil1.gs
fully crossreferenced
crossreferenced linux-hq
information relating
includes lil1.ks
home pages
major mailing
mailing lists
linux documentation
documentation project
source format
tips relating
kernel hackers
internet-based guide
expandil1.g site
kernel newbies
newbies website
lists devoted
mailing-list manager
e-mail address
address maj
maj ordomo
ordomo vger
vger rutgers
single line
list server
internet complete
home sites
companies concerned
maintains archives
investigating internet
internet resources
preemptive multitasking
key goals
layered architecture
principles underlying
underlying windows
ibm cooperated
single-processor intel
fresh start
application-programming interfaces
dave cutler
team planned
nts native
native environment
32-bit windows
windows api
first versions
advanced server
incorporated internet
internet web-server
webbrowser software
user-interface routines
graphics code
decreased system
microprocessor architectures
marketplace factors
factors windows
active directory
x.soo-based directory
directory service
laptop support
plug-and-play devices
server versions
.net server
visual design
hardware advances
numerous features
repair problems
device experience
including zero-configuration
zero-configuration wireless
instant messaging
digital photography
dramatic performance
large multiprocessors
earlier windows
systems windows
multiple operating-system
operating-system personalities
subsystem architecture
operating-system personality
application compatibility
distributed services
terminal server
simultaneous terminal
server sessions
windows desktop
desktop systems
desktop versions
server multiplex
virtual terminal
terminal sessions
logged-on user
fast user
system windows
64-bit version
64-bit integers
major extension
large addresses
premium desktop
desktop system
power users
home windows
advanced features
features needed
server family
webserver farms
large datacenter
datacenter machines
ia32 systems
ia64 systems
systems microsoffs
microsoffs design
included security
international support
security windows
goals required
design standards
enabled windows
c-2 security
security classification
moderate level
defective software
malicious attacks
extensive code
sophisticated automatic
automatic analysis
potential defects
represent security
security vuh1erabilities
reliability windows
stable operating
extensive stress
stress testing
automatic detection
stringent microsoft
extensive manual
automatic code
correct windows
extended driver
driver verification
subtle bugs
catching programming
user-level code
third-party applications
rigorous certification
certification process
process furthermme
added facilities
including downloading
downloading fixes
perceived reliability
interface easier
simpler menus
measured improvements
common tasks
consumer applications
application checks
latent application
previous system
compatibility layer
layer makes
bug-for-bug compatible
previuus versions
windows windows
windows xpf
releasesf maintains
maintains support
16-bit applications
conversionf layer
api calls
calls similarlyf
thunking layer
native 64-bit
64-bit calls
additionf posix
posix support
unix-compatible software
software compiles
performance windows
cache-line management
satisfy performance
performance requirements
optimized protocols
kernel-based graphics
synchronization algorithms
performance considerations
considerations related
cache lines
multiprocessors windows
code-path length
critical functionsf
per-processor data
memory coloring
non-uniform n1emory
n1emory access
scalable locking
queued spinlocks
protocols helped
helped reduce
reduce system
bus cycles
lock-free lists
atomic read-modify-write
read-modify-write operations
interlocked increment
advanced locking
locking techniques
constitute windows
highperformance message
kernel dispatcherf
dispatcherf threads
higherpriority threads
symmetrical multiprocessing
multiprocessor computer
extensibility refers
computing technology
facilitate change
developers implemented
implemented windows
executive runs
protected mode
server subsystems
subsystems operate
microsoft windowsf
additional environmental
loadable drivers
running windows
supports distributed
open software
hardware architecture
processor-dependent code
kernel depend
hal interfaces
bolstering windows
hal manipulates
manipulates hardware
market reasons
reasons windows
intel ia32
compatible platforms
dec alpha
alpha platforms
ensure portability
portability windows
ia64 processors
processors microsoft
microsoft recognizes
multiplatform development
practical matter
maintaining portability
support windows
nls api
specialized routines
format dates
national customs
customs string
string comparisons
varying character
character sets
sets unicode
native character
character code
code windows
supports ansi
ansi characters
unicode characters
system text
text strings
resource files
languages multiple
multiple locales
multilingual individuals
main layers
user-mode subsystems
subsystems fall
provide security
chief advantages
section describes
auth.entication package
security account
account manq.ger
manq.ger database
database figure
block diagram
hardware-abstraction layer
hides hardware
make windows
hal exports
machine interface
kernel dispatcher
single version
required-it runs
multiprocessing device
drivers map
map devices
administrative details
mapping memory
motherboard-specific facilities
main responsibilities
exception handling
low-level processor
processor synchronization
object oriented
system-defined data
attributes store
methods perform
kernel activities
timer managencent
software interrupts
deferred procedure
exception dispatching
scheduling state
actual priority
cpu-usage information
highest-priority ready
ready thread
standby state
preempted thread
allotted execution
event signaling
thread enters
variable class
dispatcher skips
dispatcher executes
idle thread
quantum runs
clock interrupt
interrupt queues
priority lowering
variable-priority thread
large priority
priority increase
active gui
gui window
window receives
scheduling occurs
wait state
higher-priority real-tince
real-tince thread
access windows
key operating-system
operating-system data
common facilities
reference counting
security control
control dispatching
objects include
event occurrence
action notification
notification events
synchronization events
user-mode mutual
deadlock-free mutual
defsemaphore object
signal timeouts
periodic activity
open operation
code polls
dispatcher implements
asynchronous procedure
executing thread
procedure apcs
terminate processes
deliver notification
completed apcs
specific threads
context deferred
postpone interrupt
device-interrupt processes
remaining processing
dispatcher schedules
schedules software
device interrupts
deferring deviceinterrupt
deviceinterrupt processing
process timer
timer expirations
quantum execution
dpcs prevents
prevents threads
current processor
dpc routines
dispatcher maintains
threads isrs
dpcs queue
queue work
work itencs
threads dpc
block execution
unlike apcs
routines make
trap handling
interrupts generated
software windows
architectureindependent exceptions
memory-access violation
violation integer
integer overflow
overflow floating-point
floating-point overflow
integer divide
floating-point divide
instruction data
data misalignment
misalignment privileged
page-read error
error access
access violation
violation paging
paging file
file quota
quota exceeded
exceeded debugger
debugger breakpoint
breakpoint debugger
debugger single
trap handlers
handlers deal
simple exceptions
exceptions elaborate
elaborate exception
exception dispatcher
neve d.,.
exception record
exception handler
exception occurs
fatal system
infamous blue
blue screen
signifies system
failure exception
environmental subsystem
debugger port
exception port
handler sends
dispatcher attempts
posix environment
environment translates
exception messages
interrupt dispatcher
handles interrupts
kernel trap-handler
trap-handler routine
interrupt object
object makes
interrupt-service routines
hardware directly
processor architectures
dispatcher maps
priority order
request levels
represent hardware
interrupt level
multiprocessor compute1
separate interrupt-dispatch
interrupt-dispatch table
out interrupts
isr returning
processing windows
deliver apcs
synchronizing threads
thread dispatches
handle timers
bus error
error power
power fail
fail interprocessor
interprocessor notification
irq hardware
interrupts dispatch
passive figure
object manager
process manager
call facility
cache manager
security reference
reference monitor
power managers
kernel-mode entities
generic set
programs windows
entities objects
executive component
object table
process user-mode
code accesses
opaque value
apis object
object handles
existing handle
process examples
objects threads
dispatcher waiting
memory apis
objects file
open state
devices sections
map files
objects local-communication
local-communication endpoints
port objects
object instances
translating names
internal directories
managing object
object creation
deletion objects
reference counts
protected-mode code
code howeve1
kernel-mode components
system registry
plug-and-play device
device discovery
process ncay
ncay create
share objects
duplicating handles
temporary nance
nance exists
object names
file path
space directories
device objects
objects representing
representing volumes
systems objects
virtual functions
implementations provided
query jlame
object operations
parse procedure
object begins
space path-name
path-name components
whack characters
current parse
parse directory
internal nodes
leaf object
components remaining
remaining path
parse procedures
objects belonging
wilcdows gui
configuration manager
-device objects
representing file
type allocates
object fields
object-manager namespace
original absolute
handle unix
permit multiple
multiple nicknamesor
nicknamesor aliases-for
standard ms-dos
ms-dos drive
drive names
sessions share
session basenamedobj
basenamedobj ects
objects created
process attencpts
remote computer
manager calls
parse method
network redirector
type specifies
implement operations
mapping names
applying security
pointer count
distinct references
references made
object protected-mode
handle count
handle table
entries referring
close routine
cleanup operation
last handle
operation tells
longer accessed
sharing restrictions
range locks
open routine
handle close
close removes
final reference
delete procedure
close operation
temporary object
object completes
object permanent
current boot
extra reference
permanent objects
permanent object
deleted permanent
drive-letter mappings
link objects
managed objects
user-mode api
existing object
duplicated handle
open handles
standardized interface
identifier unique
resource handles
whert child
out-of-process execution
execution contexts
natural place
check security
manager checks
enforces quotas
maximum amount
memory occupied
referenced objects
accumulated charges
charges exceed
login process
process authenticates
primary group
default access-control
thread making
thread token
process token
execute code
clients windows
rights granted
system compares
open occurs
occurs operating-system
components executing
mode bypass
access check
avoid security
leaving checks
checks disabled
user-modeaccessible handle
untrusted process
object determines
default list
access-token object
controls auditing
object accesses
accesses operations
security log
administrator monitors
discover attempts
access protected
protected objects
manager assumes
hardware supports
virtual-to-physical mapping
paging mechanisnc
transparent cache
cache coherence
page-based management
la32-compatible processors
ia64 pages
system pages
la32 processors
key areas
kernel-mode region
hardware references
physical page-frame
page-frame numbers
manager maps
addresses hyperspace
hyperspace maps
working-set information
kernel-mode address
space session
session space
session-specific drivers
terminal-server session
kernel-mode threads
space rum1ing
data caching
large applications
sql databases
larger user-mode
allocate user
step reserves
step commits
paging files
process consumes
committed memory
process decommits
decommits memory
process object
subsystems manage
selected pages
file processes
raw physical
physical mernory
map regions
space ia32
ia32 processors
address extension
address windowing
windowing extension
allocate physical
awe facility
sql database
database windows
process maps
memory portion
process redefines
entire object
shared-memory section
system-paging file
section appears
processes attempting
protection settings
no-access page
page raises
faulty program
program iterates
memory allocator
special kernel
kernel allocator
device verifier
detect buffer
buffer overruns
copy-on-write mechanism
independent copies
manager places
shared copy
copy-on-write property
manager makes
private copy
multilevel page
address extensions
extensions enabled
pde points
pte points
total size
manager pages
individual tables
manager self-maps
additional memory
single page-directory
page-directory entry
hardware requires
table occupy
sii gle
gle page
page determine
ia32-compatible processors
pae enabled
10-bit value
address pointer
byte address
32-bit virtual-memory
virtual-memory address
address selects
table layout
pte specifies
specific byte
mmu creates
32-bit pte
ia32 hardware
hardware reserves
caching attributes
valid ia32
processors running
page-frame number
number field
secondlevel page
page directories
extra level
pdes translation
top-level directory
directory index
second-level page
virtual pages
ia32 architecture
hardware mmu
ta64 invokes
software-trap routine
supply translations
translations missing
manager flexibility
three-level tree
rnapping user-mode
ptes occupy
top-level pdes
second-level pdes
user portion
current version
full advantage
ia64 processor
references required
handle tlb
tlb misses
space supported
valid page
zeroed page
zero-on-demand faults
standby page
disk standby
standby pages
exploit locality
bad page
transition page
valid bit
manager defines
bits invalid
invalid pages
states represented
pte page-file
page-file pages
marked zero-ondemand
zero-ondemand files
files mapped
section objects
objects encode
object pages
page file
actual structure
page-file pte
page-file offset
page state
invalid virtual
pte structure
significant bit
state invalid
temporary states
page-file page-table
modified list
standby list
idle cpu
zeroed list
list transition
transition pages
valid windows
describe pages
mmu reads
prototype pte
prototype pies
pies needed
page-frame address
state bits
page generates
normal manner
longer shared
physical m.emory
page page
valid pte
page type
valid pies
page-frame database
marked dirty
manager finds
zero-on-demand pages
first choice
faulted page
fron1 disk
file systein
list pages
working-set manager
manager trims
trims pages
process windows
per-process first-in
default minimum
pages windows
page faulting
minimum working-set
manager replaces
trimming cycles
pte trimmed
trimmed pages
modified bit
immediately needed
needed research
research shows
memory referencing
adjacent pages
sequential instructions
manager faults
faults writes
reserved memory
splay tree
faulting address
manager searches
missing pte
page-table page
process hierarchies
created thread
threads processes
large units
job objects
processor affinities
large data-center
data-center machines
api environncent
api application
application calls
calls createprocess
api subsystem
created createprocess
api win32
returns handles
user-mode image
image loader
posix environmental
api environment
environment calls
cross-process nature
subsystem process
threads apcs
terminate threads
debuggers user-mode
signal-like notifications
send alerts
debugger support
manager includes
resume threads
suspended mode
process-manager apis
register context
memory threads
existing threads
process originating
work request
supports impersonation
security token
thread-specific token
token belonging
clientserver computing
computing model
client-server nlodel
environn ental
ental subsystems
subsystems security
security management
printer spooling
web services
memory footprint
multiple services
user-mode thread-pool
thread-pool facilities
share threads
request services
subsystems lpc
rpc mechanisms
machine lpc
message-passing mechanism
process publishes
visible connection-port
connection-port object
corn1.ection-port object
charn1.el consists
private communication
client-to-server messages
server-to-client messages
messages communication
channels support
accept requests
lpc channel
message-passing tecl111.iques
first technique
small messages
hundred bytes
larger messages
sharedmemory section
channel messages
information referring
large messages
sender places
places data
receiver views
teclu ique
api window
window manager
executive lpc
lpc facilities
client asks
window-manager messaging
server sets
dedicated server
handle requests
event-pair object
provide notification
client thread
api server
object passes
object performs
performs synchronization
synchronization window-manager
object eliminates
eliminates message
message copying
pass messages
thread eliminates
scheduling preference
server threads
network drivers
filter drivers
manages buffers
handles caching
including setting
initiating threads
completion ports
threads device
manager converts
standard form
first driver
driver processes
continue processing
system context
original thread
driver returns
status indicating
arbitrary context
final processing
originating thread
stack model
driver stack
operation mount
mount management
partition management
functionality implemented
execute beneath
stack file-system
file-system filter
drivers execute
implement functionalities
management single
single instancing
remote boot
dynamic forncat
forncat conversion
implement virus
virus detection
detection device
windows driver
driver model
model lays
layer filter
handling power
plug-and-play requests
correct cancellation
cancellation logic
full wdm
wdm device
excessive amount
model makes
similar devices
audio drivers
ethernet controllers
device shares
common driver
port driver
driver implements
standard operations
device-specific routines
device-specific functionality
centralized caching
caching facility
manager caching
raw blocks
system recall
space comprise
system area
system cache
cache block
vacbs reside
single array
array maintained
separate vacb
vacb index
index array
s-entry vacb
array points
manager receives
user-level read
manager sends
device-driver stack
file resides
requested data
noncached read
manager calculates
array corresponds
byte offset
vacb array
copy succeeds
fault figure
copy fails
non cached
cached read
paging operation
page allocated
completed figure
synchronous operations
mechanism parallels
normal irp-based
operation fails
normal irp
irp path
kernel-level read
pinning interface
page locks
physical-memory page
system asks
manager flushes
small history
history attempts
access forward
prefetches data
application finds
win32 apt
apt openfile
file_flag_sequentialscan flag
normal amount
default behavior
cachewriter thread
write-through caching
cache-flush function
fast-writing process
free cache
cache pages
cache-writer thread
cache writer
writer prevents
blocks processes
flush pages
network transfers
network redirectors
move data
dma interface
data directly
directly moving
directly avoids
intermediate buffer
monitor centralizing
centralizing management
system entities
manager enables
uniform mechanism
run-time access
audit checks
security tokens
debug processes
access objects
users restricted
restricted tokens
untrusted code
logging security
security audit
audit events
rating requires
trace attempts
making access
security-event log
pnp standard
pnp manager
installed devices
potential resources
memory ranges-has
remove device
installing device
study system
pcmcia cards
laptop docks
hot-pluggable devices
configurable resources
manager handles
dynamic reconfiguration
bus driver
installed driver
add-device request
manager figures
optimal resource
resource assignments
start-device request
resource assignment
query-stop request
temporarily disabled
pending operations
stop request
pccard device
surprise-remove request
device fails
user removes
remove request
request tells
supports sophisticated
sophisticated power
home systems
reduce power
promoting ease
quicker access
individual devices
low-power mode
sleep mode
data retention
phone line
modem rings
soft power
power button
button windows
execution continues
reducing power
processor loop
state requiring
lower power
clock speed
significant power
registry windows
internal database
registry database
separate hives
system information
default user
user preferences
software installation
registry manager
system hive
user installs
installs software
system-hive configuration
last-known-good configuration
configuration damage
software states
driver executables
working state
hardware powers
bios begins
bios identifies
ntldr program
system device
device ntldr
ntldr loads
hal library
boot device
boot drivers
ntldr begins
begins kernel
kernel execution
kernel initializes
internal worker
first user-mode
user-mode process
process created
unix smss
including establishing
loading device
csrss processes
processes csrss
subsystem winlogon
winlogon brings
lsass security
security subsystem
remaining services
services needed
system optimizes
pre-loading files
disk based
previous boots
out system
operations required
processes required
grouping services
approaches contribute
dramatic reduction
hibernation capabilities
quickly resume
processes layered
native windows
executive services
enable windows
api subsysten1
main operating
operating environment
subsystem starts
subsystem calls
manager returns
win32 indicating
native win32
environment checks
takes control
application startup
provide operatingsystem
mixing api
api routines
application cam1.ot
cam1.ot make
separate user-mode
display capabilities
environment categorizes
categorizes applications
character based
character-based application
interactive output
window win32
api transforms
graphical representation
command window
output routine
win32 routine
environment performs
characterbased windows
screen text
transformation works
ms-dos applications
command-line applications
ms-dos environment
emulate intel
instructions vdm
ms-dos rom
software-interrupt services
virtual device
32-bit executables
ms-dos application
shell starts
vdm process
ia32-compatible processor
full-screen mode
character applications
full screen
applications access
access hardware
busy loops
dispatcher detects
offending application
operate incorrectly
windows environment
win16 execution
stub routines
api subroutines-converting
16-bit addresses
32-bit addresses
addresses applications
16-bit window
underlying win32
api implementation
windows wow32
multi task
win16 application
features imply
receivil1.g input
win16 applications
enable multiple
multiple win16
win16 environments
command start
common installation
wow32 environment
environment conti11.ues
native ia64
ia64 il1.struction
il1.struction set
execute ia32
ia32 programs
environment requires
32-bit win32
require translation
64-bit windows
windows supports
wow64 environment
direct execution
ia32 instructions
wow64 achieves
win32 environment
main subsystem
runs win32
api applications
controlling environment
extremely robust
api contribute
win16 environment
win32 process
manager dispatches
terminate applications
prevent crashes
wrong handle
subsystem verifies
handle points
manager prevent
prevent objects
individual applications
behavior expected
applications expect
latent bugs
implementation running
shims enabled
limited interoperability
posix subsysten1
applications written
unix model
server psxss
psxss exe
library psxdll
psxdll dll
posix console
console session
session manager
redirection mechanism
environment enforces
unix-like permissions
posix system
professional desktop
security subsystems
logon service
winlogon winlogon
secure attention
attention sequence
required n1echanism
logon screen
change passwords
smart card
personal identification
identification number
security policies
local security
security authority
authority subsystem
generates access
access tokens
represent users
perform authentication
logon subsystem
network server
authentication package
local database
quota limits
user attempts
checks privileges
default authentication
kerberos lsass
strong passwords
authenticating users
performing encryption
16-bit fat
fat file
size limitation
32-bit fat
modern file
ntfs file
data recovery
multiple data
unicode names
sparse files
volume shadow
shadow copies
compression windows
read floppies
fat32 continues
additional file-system
common formats
dvd media
fundamental entity
management utility
disks ntfs
disk sectors
default cluster
larger volumes
size reduces
files ntfs
disk offset
simple byte
structured object
object consisting
independent byte
attribute types
ms-dos shortname
specifies access
control user
data attributes
traditional data
unnamed data
data attribute
additional data
explicit names
macintosh files
named data
iprop interfaces
component object
object model
store properties
including thumbnails
attribute syntax
syntax ntfs
ntfs returns
unnamed attribute
file-query operations
array stored
small attributes
mft record
large attributes
unnamed bulk
bulk data
fit inside
-one record
overflow records
additional pointers
ntfs volume
file reference
64-bit quantity
48-bit file
file number
16-bit sequence
record number
array slot
mft entry
number enables
enables ntfs
internal consistency
consistency checks
stale reference
ntfs namespace
top level
disk extents
update timestamp
resident attributes
mft copies
efficiently generated
update times
mft entries
ntfs metadata
first file
files described
file-system hierarchy
startup code
simple rom
rom bootstrap
boot file
bad areas
error recovery
simple file
store redundant
redundant metadata
sck program
state restoring
damaged files
freeing data
data clusters
slow process
data ntfs
ntfs takes
file-system robustness
filesystem data-structure
data-structure updates
performed inside
inside transactions
undo information
commit record
transaction succeeded
first redoing
committed transactions
system_ startup
file-system recovery
user-file contents
transaction scheme
cover user
metadata file
fixed maximum
holds context
context information
logging area
restart area
area holds
logging functionality
performing recovery
log-file service
service queues
queues pending
pending transactions
ntfs halts
in-progress operations
ntfs calls
queued transactions
enforce permissions
enabled traversal
traversal checks
modem parsing
prefix matching
component-by-component opening
tolerance ftdisk
fault-tolerant disk
multiple disk
logical volume
volume set
logical drive
drives volume
physical partitions
bitmap metadata
added space
space ntfs
ntfs continues
lcn mechanism
ftdisk driver
driver supplies
logical-volume offset
stripe set
round-robin fashion
stripe size
physical partition
allocation wraps
wraps ar01md
set forms
physical layout
levels suppose
data stripes
data stripe
eighth disk
parity stripe
byte-wise exclusive
reconstruct data
data makes
disk array
lose data
failure notice
requires recalculation
concurrent writes
require updates
parity stripes
data disks
avoid creating
round-robin style
equal-sized partitions
partitions located
robust scheme
application writes
mirror set
ftdisk writes
data contents
partition fails
mirror mirror
mirror sets
mirror half
sedor sparing
cluster remapping
hardware technique
hardware capability
capability provided
good sectors
extra sectors
sectors unmapped
sector fails
ftdisk instructs
technique performed
ntfs substitutes
unallocated block
affected pointers
mft ntfs
usual outcome
fault-tolerant volumes
system reconstructs
reconstructed data
encryption ntfs
perform data
data compression
individual tlles
ntfs divides
contiguous clusters
compression unit
data-compression algoritln11
result fits
compressed version
stored compression
contiguous compression
compression units
ntfs prefetches
save space
space clusters
virtual-duster numbers
numbers stored
ntfs finds
unix ntfs
ntfs supports
supports encryption
key-recovery service
lost keys
points mount
organizing disk
global names
true volume
long transition
drive-letter scheme
journal ntfs
journal describing
system user-mode
user-mode services
receive notifications
content-indexing service
change journal
identify files
filereplication service
copies windows
shadow copy
volume making
blocks modified
volume requires
stable state
safely restarted
server version
documents stored
earlier points
recover files
previous version
client-server networking
networking components
provide data
data transport
i11terprocess communication
send print
print jobs
remote printers
describe networking
internal networking
networking interfaces
separate network
transport protocols
interface enables
session-layer component
transport mechanism
similar reasoning
reasoning led
tdi supports
connectionless transport
protocols windows
implements transport
change windows
network functionality
server-message block
message types
types session
session control
redirector corldection
file messages
server printer
printer messages
remote print
receive status
message messages
hardware-abstraction interface
bios hardware-abstraction
interface devised
pcs running
running ms-dos
ms-dos netbios
standard network-programming
network-programming interface
interface netbios
logical connections
reliable data
smb requests
netbios extended
extended user
efficient networking
default protocol
peer networking
workgroups windows
support routing
facto standard
standard networking
networking infrastructure
infrastructure windows
lip package
package includes
simple network-management
network-management protocol
dynamic host-configuration
host-configuration protocol
windows internet
netbios support
point-to-point tunneling
tunneling protocol
protocol provided
remote-access server
server modules
modules running
remote-access servers
encrypt data
novell netware
netware protocols
etware protocols
ipx datagram
spx transport
nwlink protocol
protocol connects
netware networks
client service
netware client
netware server
web-distributed authoring
versioning protocol
http-based protocol
collaborative authoring
network windows
webdav redirector
system building
system enables
enables webdav
personal files
public place
appletalk protocol
low-cost connection
files windows
windows services
macintosh package
distributed-processing mechanisms
support distributed
applications mechanisms
distributed processing
include netbios
windows sockets
microsoft interface
interface definition
definition language
netbios applications
connection-oriented messaging
messaging mechanism
mechanism named
high-level interface
netbios connections
na1ned pipes
pipe names
typical remote
server_name identifies
share_name identifies
network users
connectionless messaging
intended recipient
broadcast applications
finding components
computer browser
browser service
sockets api
api winsock
session-layer interface
unix sockets
added windows
addressing schemes
winsock application
winsock-compliant protocol
client-server mechanism
client calls
local procedure-a
procedure-a stub
routine-which packs
client-side stub
stub routine
server unpacks
return results
client stub
stub unblocks
computing-environment standard
rpc messages
highly portable
rpc standard
computer words
standard data
data formats
messages windows
send rpc
lan manager
manager networks
discussed earlie1
transmit arguments
simple description
results windows
procedure names
language generates
generates header
remote procedures
return-value messages
generates source
application executes
rpc stub
code handles
objects provide
inserting spreadsheets
microsoft documents
distributed extension
network utilizing
utilizing rpc
transparent method
client-side object
detait access
file occurs
standard unc
unc format
manager builds
request packet
manager recognizes
mup sends
registered redirectors
redirector sends
network request
remote-system network
drivers receive
server driver
driver hands
file-system driver
requesting redirector
calling application
similar process
process occurs
api network
network api
unc services
multi-provider router
tdi api
network transport
higher-level protocol
protocol mentioned
system unc
unc names
server windows
network administrator
files multiple
folder redirection
business users
longer attached
off-line access
redirected files
networked environments
natural groups
computer laboratory
global access
relationship whatsoever
domain-name system
maps internet
closely related
user database
kerberos protocol
kerberos realm
backup domain
domain controllers
versions required
one-way trusts
domains windows
hierarchical approach
approach based
transitive trusts
approach reduces
trusts required
domain trust
domain controller
users retain
restrict access
domain trees
single organization
contiguous dns
dns naming
managing multiple
children-domains research
noncontiguous names
domain tree
trust relationships
relationships trust
cross-link versions
trust domain
trusts band
call trust
authentication traffic
traffic suppose
leaf nodes
standard transitive
transitive trust
authentication requests
cross-linking trust
directory stores
topology information
doncain-based user
group accounts
domain-based store
group policies
establish uniform
uniform standards
desktop preferences
corporate information-technology
information-technology groups
computing intellimirror
corporate server
resolving www.bell-labs.com
broadcast-name resolution
lmhosts file
wins servers
servers maintain
dynamic database
name-to-if address
address bindings
client software
wins service
server failure
name-resolution workload
machines wins
dhcp updates
updates address
address configurations
wins database
administrator intervention
dhcp client
client starts
discover message
dhcp server
message replies
offer message
client chooses
selected dhcp
server responds
client attempts
fundamental interface
main aspects
handle a_semaphore
char comand_line
ostrstream ostring
ostring a_semaphore
a_semaphore ends
_process exe
code enabling
programs obtain
manipulating kernel
process gains
gains access
kernel object
object named
named xxx
createxxx function
function fails
special constant
constant named
named invalid.j1andllvalue
object drops
sharing objects
processes windows
parent calls
parent supplies
securities__attributes structure
blnheri thandle
thandle field
field set
field creates
inheritable handle
binheri thandle
thandle argument
argument figure
semaphore handle
handle inherited
process assuming
achieve interprocess
first command-line
desired named
createxxx functions
lpszname parameter
a_semaphore createsemaphore
handle b_semaphore
b_semaphore opensemaphore
calling openxxx
executing instance
routine loads
additional threads
give process
handle process_a
semaphore figure
run-time functions
maintain state
static variables
multithread application
unsynchronized access
wrapper function
function beginthreadex
instance handles
file loaded
instance handle
null pointer
violation priorities
scheduling model
priority values
chosen win32
priority level4
normal_priority _class
high_priority _class
priority levell3
real time_priority
time_priority _class
priority level24
normalpriority _class
idllpridrity _class
setpriori tyclass
start command
cbserver exe
cbserver program
realtime_ pridrity
pridrity _class
increase scheduling
priority privilege
realtimlpriority_class administrators
_class windows
performance option
system section
control panel
priority determined
function takes
thread_priority _below_normal
thread_priority _normal
thread_priority _above_normal
thread_priority _highest
priority recall
realtime class
class thread_priority
thread_priority _idle
_idle sets
variable-priority threads
threads thread_pridritltimlcritical
thread_pridritltimlcritical sets
kernel adjusts
setprocesspriori tyboost
setthreadpriori tyboost
suspend thread
functions set
synchronized region
thread establishes
calling ini
ini tializecri
tializecri ticalsection
call entercri
entercri ticalsection
leavecri ticalsection
routines guarantee
critical-section mechanism
kernel-synchronization objects
allocate kernel
encounters contention
user-defined scheduling
multiple fibers
legacy unix
fiber-execution model
convertthreadtofi ber
primary difference
call swi
swi tchtofiber
calling deletefiber
pool repeated
repeated creation
work requests
bind callbacks
waitable handles
registerwai tforsingleobj
,and apis
increase performance
performance threads
pool attempts
outstanding threads
delaying work
timer-callback apis
fewer threads
waitable handle
lnterprocess communication
communication win32
applications handle
handle interprocess
sharing kernel
passing messages
gui applications
calling postmessage
,or sendmessagecallback
message differ
post routines
send routines
separate address
calling sendmessage
type wm_copydata
copydatastruct data
unlike threads
16-bit windows
api thread
receives messages
space void
void buf
space virtualalloc
memory virtualfree
allocated address
space virtualfree
shared input
stuck application
block input
call getmessage
handle events
queue fills
system marks
thread-local storage
calls virtualalloc
allocated region
ox10000 examples
committed pages
calling virtuallock
calls setprocessworkingsetsize
memory-mapping files
space memory
processes map
multistage process
file-mapping object
size handle
handle hmap
space mapped
file unmapviewoffile
reserved address
api process
api functions
default heap
space-allocation data
concurrent updates
threads win32
heap-management functions
private heap
heap unlike
unlike virtuallock
functions perform
lock pages
storage mechanism
mechanism functions
static data
runtime function
function strtok
static variable
execute strt
separate current
position variables
mechanism allocates
global storage
per-thread basis
static methods
dynamic method
thread-local static
application declares
dword cur_pos
variable dword
dword var_index
value int
int var
var t1sgetvalue
index t1sfree
dynamic thread-local
storage microsoft
design.ed windows
system -one
hardware windows
supports multiple
operating environments
64-bit processors
numa computers
basic services
programs compiled
model stronger
previous microsoft
includes internationalization
internationalization features
cu1.d upgrade
upgrade hardware
booting process
windows32 api
page facility
facility provided
calls facility
main architectural
architectural layers
programs executing
executing inside
protection guarantees
guarantees provided
applications executing
application executing
32-bit application
fiber abstraction
abstraction provided
threads abstraction
programs developed
manager improve
communicating data
message-passing teclllliques
ntfs handle
recovery takes
decision made
ntfs directory
structure differ
manages caching
process obtain
handle solomon
system internals
components tate
good reference
server resource
six-volume set
deploying windows
microsoft developer
developer network
network library
products iseminger
directory richter
writing programs
api silberschatz
one-of-a-kind systems
presentation highlights
include references
technical content
operating-system features
features migrate
huge systems
microcomputers shows
migration started
multiplexed information
system multics
massachusetts institute
complex mainframe
original partners
pdp-11 minicomputer
recent operatirlg
operatirlg systems
mac osx
osx operating
linux includes
historical overview
computing starts
twentieth century
perform specific
fixed tasks
tasks modifying
tasks required
manual labor
alan turing
john von
program store
data store
fundamental computer
computer concept
world war
first working
working stored-program
manchester mark
first commercial
commercial computer
ferranti mark
early computing
computing efforts
enormous machines
machines run
front panel
panel switches
punched cards
program ran
display lights
console output
dedicated computer
developed card
card readers
lil1.e printers
commonplace assemblers
task libraries
providing software
software reusability
careful programming
special subroutine-called
driver-was written
control bits
simple task
paper-tape reader
complex sequences
device-specific operations
languages appeared
fortran program
fortran compiler
proper tape
card reader
compiler produced
produced assembly-language
assembly-language output
procedure required
supporting library
binary object
object form
job consisted
separate steps
compiler tape
tape running
compiler unloading
tape loading
assembler tape
assembler unloading
job step
paper tapes
punch cards
job set-up
real problem
cpu sat
sat idle
idle remember
cost millions
operational costs
owners wanted
shared computer
professional computer
computer operator
longer operated
mounting tapes
programmer provided
short description
incorrect program
dump dumping
registers allowed
difficult debugging
debugging problem
operator received
fortran job
cobol job
compiler tapes
fortran programs
saving operator
monitor figure
resident monitor
job stopped
people developed
first rudimentary
rudimentary operating
small program
moni loj
program terminated
programmer included
contained directives
monitor indicating
separate control
control card
job-first card
end-final card
machine resources
programmer parameters
program cards
special character
dollar-sign character
first colun
code ibm
control language
slash marks
columns figure
sample card-deck
card-deck setup
simple batch
identifiable parts
insh uctions
control-card interpreter
load system
an.d application
providing continuity
saving memory
systems work
automatic job
job sequencing
monitor loads
program completes
card deck
human operation
sequencing elim.inates
human set-up
electronic devices
slow cpu
cpu works
licrosecond range
instructions executed
fast card
technology resulted
cpu speeds
speeds increased
slow card
magnetic-tape units
systems reading
card punches
equivalent record
lilce printers
obvious advantage
off-line operation
mam computer
tape units
units card
reader line
line printer
reader tape
drives iine
iine printer
similar equipment
real gain
multiple reader-to-tape
tape-to-printer systems
process input
read cards
readers working
cpu busy
however-a longer
longer delay
job run
additional jobs
similar jobs
off-line preparation
jobs continued
systems disk
tape systems
cpu read
entire tape
nature devices
devices disk
systems eliminated
position needed
card images
system satisfies
card-reader input
job requests
system buffer
simultaneous peripheral
peripheral operation
operation on-line
on-line spooling
huge buffer
storing output
disk line
processing data
cpu sends
remote printer
entire input
input job
remote card
remote processing
cpu intervention
data spooling
spooling overlaps
simple systen
output lines
disk spooling
direct beneficial
beneficial effect
devices working
rates spooling
spooling leads
atlas operating
standard parts
systems device
extra codes
codes atlas
batch operating
spooling spooling
schedule jobs
tape readers
tape punches
fuce printers
remarkable feature
management core
core memory
drum demand
drum automatically
british computer
48-bit words
words addresses
98-kb-word drum
512-word pages
registers implemented
fault occurred
memory frame
drum transfer
start immediately
algorithm attempted
future memory-accessing
memory-accessing behavior
behavior based
past behavior
recent reference
largest t2
algorithm assumes
xds-940 operating
pages contained
code processes
xds-940 system
modified xds-930
user-monitor ltlode
system-call instruction
user-mode instruction
resources files
256-word blocks
free drum
drum blocks
blocks index
provided system
destroy subprocesses
synchronization process
creation defined
technische hogeschool
dutch computer
clean design
processes employing
employing semaphores
synchronization unlike
active agents
print user
priority cpu-scheduling
scheme gave
processes memory
software paging
algol compiler
generated calls
system routines
requested information
512-kb-word drum
512-word page
page-replacement strategy
deadlock control
provide deadlock
venus system
layer-structured design
synchronize processes
faster system
paged-segmented memory
design concepts
system rathel
operating-system nucleus
complete operating
lower levels-comprising
kernel-were provided
kernel supported
round-robin cpu
primary communication
synchronization itl.echanism
fixed-sized rnessages
common buffer
ncessage buffer
common pool
received messages
out buffer
out sender
out message
out resul
out result
allowed processes
primitives required
process service
developers provided
additional communication
communication primitives
input character
compatible time-sharing
experimental time-sharing
interactive users
interactive commands
memory made
36-bit words
users user
fast drum
drum cpu
multilevelfeedback queue
queue algorithm
shortest quantum
run first
initial level
practical mode
multics operating
natural extension
ctss ctss
early tin
e-sharing systems
larger computers
ctss set
time-sharing utility
utility computing
computing service
electrical power
telephone wires
vast file
data multics
computer department
pagedsegmentation memory
18-bit segment
word offset
1-kb-word pages
second-chance page-replacement
file segments
multilevel tree
subdirectory structures
scheduling protection
protection rings
system continued
continued running
longest line
operating-system development
ibm computers
early ibm
prime examples
independent sites
computers spanning
complete range
small business
business machines
large scientific
scientific machines
reduce maintenance
maintenance problems
move programs
system included
variable-length records
unblocked files
added parameters
average user
base-register addressing
addressing mode
arrangement prevented
separate versions
fixed regions
variable regions
tables operating-system
operating-system overhead
remote part
system remained
fairly constant
segmented-paged virtual
memory mvs
mit decided
switched vendors
vendors ibm
time-shared utility
sites purchased
tiine-sharing systems
temporary systems
time-sharing option
cambridge scientific
scientific center
center developed
developed cms
temporary system
ibm systems
multics achieved
commercial success
wrong part
advanced systems
purposes minicomputers
minicomputers died
special-purpose servers
computers continue
servers tend
cpus today
data centers
computers sit
desktop rivalry
microsoft continues
continues today
application functionality
long-term competitors
leading desktop
forms continues
technical users
nontechnical users
connected computer
accent operating
system developedatcarnegiemellon
developedatcarnegiemellon university
communication system
mach scheduler
early version
mach shared-memory
critical goals
memory models
evolutionary path
systems mach
mach code
developed inside
4.2bsd kernet
components replaced
mach components
bsd components
communication subsystems
dec vax
vax computer
computer family
including multiprocessor
multiprocessor versions
vax versions
encore multimax
sequent balance
balance multiprocessor
including task
thread support
first official
official releases
provided compatibility
mach made
bsd kernels
kernels mach
bsd code
kernet leaving
smaller microkernel
basic mach
mach features
unix-specific code
user-mode servers
servers excluding
excluding unix-specific
simultaneous execution
operating-system interfaces
user-mode implementations
machine concept
kernel interface
including single
processor sun
intet ibm
dec machines
multiprocessor dec
encore systems
industry attention
steve jobs
computer fame
initial release
system competed
operati.j.l.g system
members osf
osf members
i.j.l.cluded key
key technological
technological companies
dec l.jn
incorporates multiprocessing
multiprocessing support
ranging rom
processors mach
support multiprocessing
parallel computation
communication method
method ensures
integrating messages
daemons managing
great 1exibility
memory-objectmanaging tasks
complex functions
buik mach
mach reduces
operating-system emulation
user levet
virtual-machine systems
concepts included
entire chapter
fourth edition
lwww os-book
interesting properties
mcp operating
burroughs computer
system.programming language
supported segmentation
scope operating
multi-cpu system
designed history
newer hardware
multics suppose
kernel foundation
unix development
summer usenix
usenix conference
a.-r adl-tabatabai
unlocking concurrency
acm transactions
internet equality
processing encrypted
encrypted data
recent events
ieee concurrency
tutorial survey
adaptive block
block rearrangement
international conference
data engineering
winter usenix
lock alternatives
shared-money multiprocessors
ieee trans
trans parallel
parallel distrib
distrib sysl
performance implications
management alternatives
shared-memory multiprocessors
ieee transactions
effective kernel
user-level management
acm symposium
operati11g systems
systems principles
serverless network
ande1 son
interposed request
request routing
scalable network
network storage
fourth symposium
systems design
technical introduction
macintosh family
family addison-wesley
optical storage
ieee spectrum
hard real
deadline monotonic
monotonic approach
ieee workshop
base-rate fa.llacy
acm conference
consistent global
global states
prentice hah
cal confermce
m.g baker
m.d k11pfer
distribl1ted file
p2p systems
multithreaded freebsd
fast mach
mach network
network ipc
ipc implementation
mach symposium
von eicken
user-level network
tlze acm
acm sy1nposium
l.a belady
virtual-storage computer
space-time characteristics
paging machine
lip protocol
computer comnzunication.s
comnzunication.s reuiew
distributed programming
prentice hall
retrieval systems
time-stamp-based algorithms
large databases
practical considerations
non-blocking concurrent
concurrent objects
tlze winter
lightweight remote
pard yak
spln operating
tile acm
operating stjstems
stjstems principles
sigplan notices
technical report
implementing remote
scheduling support
j.d burchfiel
sharing system
bolosky eta
distributed schedule
schedule management
ttger vtdeo
vtdeo .fileserver
acm symposiwn
object-caching kernel
arbitrary resources
annual technical
technical conference
linux kemel
limtx kernel
win32 system
.first-fit strategy
software -practice
structured multiprograrm11ing
system principles
seventh edition
brownbridge eta
the newcastle
newcastle connection
world unite
software practice
mutual exclusion
sigact news
posjx threads
high pe7formance
pe7formance cluster
nfs illustrated
trill eta
dynamic instrumation
ock-a simple
effective algoritlun
modem computing
mit press
distributed snapshots
distributed control
computer networlcs
chase eta
single-address-space operating
operating system
p.m chen
reliable secondary
acm computing
computing surveys
m.a malcolm
portable real-time
internet security
wily hacker
exploring issues
systems structuring
extensible systems
systems review
computer mass
system deadlocks
win32 multithreaded
afips fall
joint computer
computer conference
experimental time
time sharing
aflps fall
kind berg
systems concepts
addison wesley
concurrent control
parallel computer
morgan kaufmann
kaufmann publishers
microsoft press
cooperative storage
rsa digital
additional comments
set model
signature keys
public-key cryptosystems
programming semantics
mu.ltiprogrammed computations
pages h3-155
privacy issues
wearable wireless
information theory
teclmical report
teclmological university
programming control
hierarchical ordering
acta informatica
criteria department
idle task
mmu tricks
transparent process
design alternatives
sprite implementation
storage alternatives
mobile computers
adaptive disk
spin-down policies
usenix symposium
independent computing
high-bandwidth cross
cross domain
domain transfer
transfer facility
network working
working group
control problem
conditional capabilities
portable multithreading
signal stack
stack trick
user-space thread
predicate locks
reevaluating online
online superpage
superpage promotion
promotion witl1
witl1 hardware
international symposium
high-pejformance computer
security issues
making unix
unix secure
trace scheduling
global microcode
microcode compaction
file slructures
forrest eta
ntx processes
lite ieee
ieee sy1uposiwn
lan technology
universal history
history ofcol
john wiley
illustrated histon
carlton books
denser disks
ieee multimedia
coming revolution
optical file
random-access file
write-on optical
purpose operating
flexible application-level
application-level networking
exokernel systems
practical unix
s.-t leung
network-attached secure
secure disks
carnegie-mellon university
andj zelenka
server scaling
cryptographic sealing
infonnation secrecy
bow beer
java concurrency
secure environment
untrusted helper
helper applications
6th usenix
usenix security
security syrnposiwn
the structure
usenix winter
operati11g system
ieee internet
internet computini
security architecture
java development
development kit
usenix synzposium
internet technologies
goodman eta
efficient synchronization
large-scale cache-coherent
cache-coherent multiprocessors
architectural support
tlzejava language
unix operating-system
at&t bell
technical journal
data base
base operating
the transaction
lnlerprocess communications
recovery manager
database manager
modeling power
computer telecomnnmimtion
telecomnnmimtion systems
average completion
on-line algorithms
discrete algorithms
virtual versus
physical process-migration
process-migration strategies
mob.ile computing
computing networks
exploiting process
process lifetime
lifetime distributions
dynamic load
balancing dns
limtx journal
quarter century
file imwvation
ibm journal
java network
operating systems
system programming
tlzird edition
zebra striped
striped network
file system
avoiding deadlock
multitasking systems
m.s hecht
experience adding
nix conference
quantitative approach
share scheduler
bell labomtories
technical joumal
concurrent data
lock-free data
annual intemational
intemational symposium
computer architeclure
nfs file
server appliance
infonnation storage
storage tedmology-a
parallel programming
system structuring
structuring concepf
ofl-lie acm
deadlock properties
computing surve
yarning java
howard eta
university atlas
computer journal
hsiao eta
academic press
secure path
path vector
vector routing
routing scheme
securing bgp
acm sigcomm
sigcomm conference
data communication
secure on-demand
on-demand routing
hoc networks
proceedings oft
annual international
mobile computing
columbus chicken
chicken statute
bonehead legislation
greene press
osborne mcgraw-hill
technical reference
reference ibm
ibm corporation
iliffe andj
reference manual
manual intel
intel corporation
manual programmer
reference intel
microprocessor programmer
processor user
programming manual
directory services
software-mm1aged address
performance computer
contemporary microprocessors
ieee micro
micro magazine
computer magazine
rotational position
hewlett-packard laboratories
time-driven scheduling
systems symposium
first international
language extension
expressing constraints
fine-grained mobility
emerald system
computer systerns
kaashoek eta
application performance
system architectures
digital press
secure border
border gateway
gateway protocol
ieee joumal
selected areas
an alternative
event queues
capability managers
right expressions
internal organization
i-l kim
system integrity
integrity checker
arm movement
future requests
disconnected operation
coda file
queueing systems
computer applications
wiley interscience
fast storage
storage allocator
computer programming
fundamental algorithms
allocation based
multithreaded sparc
sparc processor
non-blocking write
write protocol
protocol nbw
real-time synchronisation
synchronisation problem
semaphore primitives
petri nets
starch press
retaining suid
suid programs
secure unix
summer usenjx
usenjx conference
global-scale persistent
persistent storage
top-down approach
approach featuring
concurrent progra1mning
progra1mning problem
independent processes
concurrent reading
distributed multiprocess
multiprocess systems
lnsecure communications
exclusion problem
mutual excll
sion algorithm
progrmnming languages
protection stmctures
tlze afips
annual princeton
princeton conference
systems science
7th acm
crash recovery
distributed data
xerox research
formal models
formal approach
method guaranteeing
guaranteeing retrieval
rate-monotonic admission
ieee ti-ansnctions
end-user perspective
virtual disks
seventh international
tlze design
4.3bsd unix
andy ding
yionotonic scheduling
exact characterization
average case
case behaviour
10th ieee
real-time sijstenzs
sijstenzs stjmposiwn
distributed multimedia
mechanism separation
defining deadlock
penguin books
microsystems press
jaw technology
man-machine interaction
fall joirll
joirll computer
java virtuallvlachine
virtuallvlachine specificalioll
optimal thread
pool size
stcm review
primitive systems
systems phd
phd thesis
the design
venus operating
liu andj
real-time environment
system breakers
kernel development
kemel development
multiflow trace
scheduling compiler
giant black
black book
american eagle
eagle publications
email viruses
higher disk
head utilization
free bandwidth
busy disk
root algorithm
decentralized systems
viass storage
ieee symposium
first-class user-level
user-level threads
13th acm
systems principle
evaluation techniques
storage hierarchies
kernel arcl1itecture
the bsd
bsd packet
packet filter
user-level packet
packet capture
ltsenix winter
multi-core processors
usenjx magazine
solaris jntemals
parallel programs
software volume
limited memory
l11e frcebsd
frcebsd unix
acm transaclions
dual-threaded ltanium
ltanium processor
extent-like performance
functional structure
scalable synchronization
data bases
processor capacity
capacity reserves
tim.edia computing
microsoft ms-dos
ms-dos user
ms-dos programmer
reference microsoft
kit microsoft
network development
development library
library microsoft
an analysis
unix supercomputing
computing survcljs
domain names-concepts
efficient c01
processes model
distributed transactions
fundamental design
environment phd
case history
distributed personal
personal computing
risc microprocessor
microprocessor user
manual motorola
handheld cornputing
transparent operating
cap computer
sixth symposium
sprite network
peter norton
norton programmer
modem perspective
database systerns
optical device
virtual optical
disks solve
storage crunch
embedded oss
oss gain
inside track
ousterhout the
the role
cmu computer
25th anniversary
trace-driven analysis
bsd file
sprite network-operating
network-operating system
p2p networking
information-sharing alternative
virtual storage
machine concepts
cigarette smokers
conditional statements
tlze management
m.a pechura
estimating file
layer protocols
byzantine robustness
robustness phd
information processing
processing letters
buddy systems
cache locality
programrning languages
platform independent
performance dependent
system review
protection structures
locus distributed
system arclzilecturc
vmin-an optimal
optimal variable
variable space
space page-replacement
page-replacement algoritlun
holographic memories
scientific american
replication facility
berkeley unix
purdorn,jr ands
statistical propertieso.f
cached worm
network prograrmning
eee computer
computer society
fall joint
conm1unication-oriented network
exclusion algorithms
capturing causality
tntemotional workshop
redell eta
atomic actions
decentralized data
computer volume
model matters
microsoft research
recent widespread
widespread computer
an optimal
optimal algoritlun
media devices
optical information
advanced windows
active storage
large-scale data
data mining
24th lnternntional
lnternntional conference
large data
gnutella nenqork
internet volume
on digital
key cryptosystems
stems programming
modern scheduler
tlze usenix
usenix bsdcon
bsdcon conference
automatic .reconfiguration
opeml ing
ing systenzs
systenzs principles
acm symposiunt
symposiunt oil
oil opera
opera ling
ling systems
p.m lewis
level concurrency
disk shuffling
ruemmler a11d
unix disk
proceedin8s oft
wiuler usenjx
usenjx confereuce
an introduction
drive modeling
opemti11g srjstcujs
srjstcujs principles
security basics
microsofl windows
tile ieee
sun network
sun nelwork
nelwork filesystem
disks replace
practical network
network support
automated disk
drive characterization
passing primitives
distributed programs
applied cryptography
priority queues
management science
detecting causal
causal relationships
relationships i11
i11 distributed
distributed computations
password cracking
tlic winter
an implementation
usenfx winter
system logging
logging versus
performance comparison
usen1x winter
reliable remote
call mechanism
fntd technology
technology journal
database systen1
systen1 concepts
efficient unified
caching subsystem
technical conference-freenjx
conference-freenjx tracie
selected papers
optical engineering
engineering press
systerns approach
cache-miss ratio
ratio analysis
design considerations
distributed mobile
inside windows
acm sigops
sigops operating
metropolitan area
softvvare communication
calls versus
versus messages
strategic directions
passing communication
communication versus
versus procedure
call communication
multimedia operating
nintlz symposium
advanced programming
illustrated volume
nix network
network programming-volume
network programrning
programrning inter
inter process
communications volume
share resource
time-shared systems
real-tim.e systems
machine monitor
programming guide
guide sun
tall uri
m.d hill
fine-grained dynamic
dynamic instrumentation
commodity operating
usenjx symposium
structured computer
van steen2002
essential reference
mapped files
future unix
trusting trust
programming languages
mobile code
data crunch
database management
ieee coloquium
unix internals
locality-preserving load-balancing
load-balancing mechanisms
synchronous simulations
fourteenth workshop
distributed simulation
efficient software
software based
based fault
fault isolation
efficient software
extensible security
security architectures
acm transacl
transacl ions
cing approach
schedlller activations
netbsd operating
critical review
jntcnwtional workshop
memory mmwgcment
computer performance
performance tradeoffs
tradeoffs obtained
controlled-share queue
queue schedulers
scheduling algoritlm1s
on-line extraction
drive parameters
acm sigmetrics
performance monitors
multiprogramming systems
experimental computer
lightweight directory
directory access
access protocol
the duality
multiprocessor operating
operating principles
trading capacity
hoc routing
routing protocols
acm worlcshop
wireless security
morgan kaufmam1
kaufmam1 publishers
publisher figure
international business
machines corporation
corporation reprinted
corporation figure
addison-wesley publishing
massachusetts figure
pentiwn processor
corporation figures
data communications
open systems
san francisco
california derived
authors figure
database systern
systern concepts
york section
617-622 reprinted
protocol lobaset
lobaset ethernet
loobaset ethernet
aborted transactions
absolute code
access access
additional sense
sense code
additional sense-code
sense-code qualifier
address resolution
resolution protocol
address-space identifiers
administrative complexity
advanced encryption
encryption standard
advanced technology
technology attachment
anonymous access
calls api
program interface
interface apple
apple computers
macintosh computer
proxy firewalls
arbitrated loop
armored viruses
identifiers assignment
asymmetric clustering
asynchronous devices
asynchronous thread
ata buses
write-ahead logging
automatic work-set
work-set trimming
windows xplt
automount feature
back door
base file
file record
batch files
batch interface
parity organization
bit maplt
black-box transformations
blade servers
boot control
volume control
block ciphers
system diskt
bootstrap programs
bootstrap loaders
boot viruses
half interrupt
buddy-system allocation
nonvolatile ram
update policy
cache coherency
cache management
cancellation points
carrier sense
multiple access
constant angular
angular velocity
central processing
processing unit
cpu certificate
character-stream devices
common internet
internet file
cipher-block chaining
circular scan
dtrace command-line
algorithm clones
c-look scheduling
closed-source operating
cluster server
constant linear
linear velocity
code books
model combined
scheme index
command interprete1
communication systems
communications sessions
compute clusters
computer environments
programs computer
system viewed
real-tim.e embedded
conditional-wait construct
resolution module
connectionless messages
conservative timestamp-ordering
control programs
core dump
cpu schedule1
scheduler cpu
feedback-queue scheduling
queueing-network analysis
earliest-deadline-first schedufu1g
short-term schedule1
crash dumps
cross-link trust
access ctss
ctss operating
cycle stealing
data capability
data-encryption standard
data striping
safe-state algorithm
algorithm usage
no-preemption condition
system resource-allocation
resource-allocation graphs
dedicated devices
delay-write policy
restartil1g instructions
demilitarized zone
directories device
device-management system
system digital
digital rights
rights management
directory objects
direct virtual
dirty bits
modify bits
structure allocation
low-level formatted
dispatched process
distributed coordination
reaching algorithncs
basic scheme
distributed naming
naming services
distributed lock
libraries dlm
access dma
direct-memory-access controller
controller dmca
double caching
dynamic random-access
random-access memory
registration module
dual-booted systems
dumpster diving
duplex set
dynamic storage-allocation
storage-allocation problem
enabling control
code edf
effective memory-access
memory-access lime
eide buses
algorithm embedded
encrypted viruses
integrated drive
drive electronics
equal allocation
read-only mem01y
event objects
expansion bus
system extended
false negatives
false positives
fault-tolerant systems
fiber channel
algorithm feature
accessing information
l123-427 protecting
file-management system
file session
systems extended
virh1al systems
log-based transaction-oriented
system hierarchy
hierarchy standard
standard document
fine-grained multithreading
firewall chains
firewall management
first-fit strategy
forward-mapped page
frame-allocation algorithm
frame pointers
free-behind technique
bit vectm
front-end processors
graph directories
portable threads
graceful degradation
green threads
group identifiers
group rights
layer handheld
hands-on computer
interactive computer
hard errors
hard links
hardware objects
heavyweight processes
high-availability clusters
host adapter
spare disks
hot-standby mode
human security
idle threads
intrusion-detection systems
systems ike
ike protocol
information life-cycle
life-cycle management
naming techniques
indexed disk
index root
information-maintenance system
instruction-execution unit
interrupt-controller hardware
interrupt-driven data
data transfe1
interrupt-driven operating
interrupt-handler routine
interrupt-request line
intrusion-prevention systems
procedures supervised
protocol ipc
communication ipsec
iso reference
reference model
jit compiler
job queues
transaction-oriented file
task synchronization
kerr effect
key ring
keystroke logger
networks latency
logical cluster
cluster numbers
lightweight directory-access
directory-access protocol
protocol ldt
local descriptor
linear addresses
linear lists
linked disk
adding system
first kernel
swap-space rnanagernent
limlx system
load balancers
priority replacement
lock-key scheme
logical units
formatted disks
calls lru-approximation
message-authentication code
medium access
magic number
mailbox sets
metropolitan-area networks
many-to-many multithreading
multithreading model
many-to-one multithreading
reliability improvement
future tedmology
master book
book record
master secret
medium-term schedule1
memory over-allocation
memory memory-address
memory-address register
memory-resident pages
error-correcting organization
memory transactions
micro-electronic mechanical
mechanical systems
message-passing model
windows migration
miniport driver
unit mobility
monitor calls
calls monoculture
mpeg files
system issues
multipartite viruses
multiple-coordinator approach
multiple-partition method
multiple universal-naming-convention
universal-naming-convention provider
ntulticore processors
parallel systems
coupled systems
sharing multithreading
fully-distributed approach
device interface
interface specification
near-line storage
netbiosextended user
netbios network
information service
network login
nonmaskable interrupt
nonresident attributes
access nvram
object linking
off-line compaction
embedding olpc
one-time pad
one-to-one multithreading
one-way trust
on-line compaction
resource allocatm
ordering orphan
orphan detection
out-of-band key
key delivery
page-directory entries
page .fault
pageout policy
page slots
page-table base
page-table length
length register
page-table self-map
paired passwords
pluggable authentication
systems para-virtualization
partition boot
blocks pci
pci bus
process-contention scopet
assistants pdes
penetration test
periodic processes
personal firewalls
page-fault-frequency phase-change
phase-change disks
physical formatting
physical security
pipe mechanism
pnp managers
sec plug-and-play
policy algorithm
polymorphic viruses
pop-up browser
browser windows
redundancy scheme
premaster secret
private keys
mode probes
communication components
multithreading operations
threads performed
task control
process-control system
process objects
processor sets
concurrent transactions
hardware solution
production kernels
programs program
programmable interval
interval timer
logic bombs
overflow attacks
access mah
computer systen1s
language-based systems
protection mask
protection subsystems
random-access devices
reaching algorithms
read-ahead technique
read-modify-write cycle
read-write devices
read-write disks
limlx schedulers
real-time transport
real-time value
master boot
reed-solomon codes
resolving links
graph algorithm
resource allocato1
resource reservations
retrofitted protection
reverse engineering
text format
roaming profiles
robotic jukebox
rolled-back transactions
memory root
root partitions
cmmected networks
algorithm rtf
rich text
running thread
safe computing
storage-area networks
networks sata
sata buses
scheduler activation
scheduling disk
scheduling rules
script kiddies
small computer-systems
computer-systems interface
scsi buses
scsi initiator
scsi targets
single sign-on
authentication classifications
secu.rity descriptor
security-through-obscurity approach
sequential devices
serial ata
server subject
session hijacking
session object
sharable devices
shell script
single-level directories
single-threaded processes
algorithm slab
small-area networks
scsi smb
server-message-block smp
multiprocessing snapshots
system-on-chip strategy
strategy soft
soft error
source-code viruses
special-purpose computer
spoofed client
monitor ssds
disks ssl
shortest-seek-time scheduling
algorithm stable
stack-overflow attacks
standby thread
blocking state
stateless dfs
stateless protocols
stealth viruses
structure definitions
stored program
program computers
stream ciphers
stream modules
superblock objects
mode suspended
switch architecture
symbolic-link objects
symmetric mode
synchronous devices
synchronous message
sec system
generation system
system-call firewalls
systems layer
system mode
mode system-on-chip
system restore
m.aster file
blocks tcb
computer base
sec transmission
protocol tcp
transport driver
driver interface
terminal concentrators
terminated state
multithreading cancellation
java tlueads
threats throughput
timer objects
buffer tlb
transactions defined
transition thread
translation coordinator
tunneling viruses
twofish algorithm
two-level directories
udp sockets
interface uma
uniform naming
naming convention
universal serial
serial buses
npcall handler
user-defined signal
user identifiers
user tasks
user rights
utility storage
address control
block vads
address descriptors
variable timer
virtual dos
dos machine
machine vector
vector programs
memory fork
system victim
victim frames
distributed-processing lttechanisms
object access
executive hardware-abstraction
process managet
wirte-on-close policy
world rights
read-many-times disks
disks worm
worst-fit strategy
xml firewalls
zero-day attacks
zero-fill-on-demand technique
zipped files
zombie systems
restarting instructions
france allocation
tlu ashing
page-fault-frequency strategy
worki1cg-set model
private networks
virus droppe1
manager vmware
networks vulnerability
web clipping
web distributed
networks win32
children
lemar
sivan
aaron
nicolette
avi
silberschatz
wife
carla
gwen
owen
maddie
peter
baer
galvin
pat
sons
tom
jay
greg
gagne
abraham
sidney
weinberg
professor
chair
computer
science
yale
university
prior
joining
vice
president
information
sciences
research
center
bell
laboratories
held
chaired
professorship
department
texas
austin
acm
fellow
ieee
received
taylor
booth
education
award
karl
karlstrom
outstanding
educator
sigmod
contribution
recognition
level
innovation
technical
excellence
awarded
projects-the
qtm
project
datablitz
netlnventory
writings
appeared
numerous
publications
professional
conferences
journals
coauthor
textbook
database
system
concepts
written
op-ed
articles
york
times
boston
globe
hartford
courant
chief
technologist
corporate
technologies
www.cptech.com
facility
reseller
integrator
systems
manager
brown
sun
columnist
login
magazine
byte
magazines
columns
world
sysadmin
consultant
trainer
talks
taught
tutorials
security
administration
worldwide
westminster
college
salt
lake
city
teaching
addition
operating
teaches
networks
distributed
software
engineering
workshops
educators
industry
professionals
essential
part
similarly
computer-science
field
undergoing
rapid
change
computers
prevalent
virtually
application
games
sophisticated
planning
tools
governments
multinational
firms
fundamental
remain
fairly
clear
base
book
wrote
text
introductory
junior
senior
undergraduate
first-year
graduate
hope
practitioners
find
description
underlie
prerequisites
assume
reader
familiar
basic
data
struchues
organization
high-level
language
java
hardware
topics
required
understanding
included
chapter
code
examples
predominantly
understand
algorithms
knowledge
languages
presented
intuitive
descriptions
important
theoretical
results
covered
formal
proofs
omitted
bibliographical
notes
end
pointers
papers
first
proved
references
material
reading
place
figures
suggest
expect
result
question
true
based
existing
conunercial
aim
present
general
setting
tied
large
number
pertain
popular
im1.ovative
including
microsystems
solaris
linux
microsoft
windows
vista
apple
mac
implying
feature
exists
specific
release
state
explicitly
vii
viii
reflects
years
courses
consideration
feedback
provided
reviewers
comments
submitted
readers
earlier
editions
content
corresponds
suggestions
computing
curricula
published
joint
task
force
society
association
machinery
supporting
web
site
provide
sample
syllabi
approaches
advanced
rule
encourage
progress
sequentially
chapters
strategy
study
select
ordering
subsections
on-line
support
wileyplus
students
exercises
programming
problems
instructors
assign
grade
access
operating-system
simulators
work
hands-on
lab
activities
ends
organized
major
parts
overview
explain
designed
constructed
discuss
common
features
user
computer-system
operator
presentation
motivational
explanatory
nature
avoided
discussion
things
done
internally
suitable
individual
lower-level
classes
learn
details
internal
process
management
coordination
describe
concept
concurrency
heart
modern
unit
consists
collection
concurrently
executing
processes
execute
rest
cover
n1.ethods
scheduling
interprocess
communication
synchronization
deadlock
handling
threads
examination
issues
related
multicore
memory
deal
main
execution
improve
utilization
cpu
speed
response
users
effectiveness
algorithm
depends
situation
storage
file
mass
i
handled
mechanism
programs
classic
structures
firm
practical
-their
properties
advantages
disadvantages
includes
matters
secondary
tertiary
devices
attach
vary
widely
wide
range
functionality
applications
control
aspects
depth
design
interfaces
functions
ways
slowest
components
represent
performance
bottleneck
examine
protection
mechanisms
protected
ensure
gained
proper
authorization
operate
files
resources
controlling
defined
means
controls
imposed
enforcement
protects
integrity
stored
physical
1.mauthorized
malicious
destruction
alteration
accidental
introduction
inconsistency
processors
share
clock-a
providing
maintains
computation
availability
reliability
file-service
servers
dispersed
sites
dealing
variety
failures
encountered
centralized
special-purpose
purposes
real-time
multimedia
requirements
differ
general-purpose
focus
remainder
require
computed
correct
produced
deadline
period
quality-of-service
guarantees
ensuring
delivered
clients
frame
case
studies
appendices
www.wiley.comj
global
integrate
described
describing
real
include
freebsd
mach
chose
unix-at
time-was
small
toy
selected
simplicity
sophistication
readily
departments
opporhmity
implementation
drastically
unix
briefly
describes
influential
real-world
illustrate
attention
paid
family
versions
bsd
significant
amount
coverage
reflecting
recent
version
kernel
-version
2.6-at
intended
run
environments
primary
environment
win32
api
interface
comprehensive
set
managing
peripheral
illustrating
tested
rum1.ing
posix
stands
portable
inte1jace
represents
standards
implemented
primarily
unix-based
focuses
posix-compliant
implement
core
standard
posix.1
defines
extensions
posixl.b
extension
library
posix1.c
pthreads
programn1.ing
debian
gee
compilers
rich
built-in
thread
creation
virtual
machine
jvm
networking
chosen
opinion
two
models
comfortable
easily
instances-such
creation-we
allowing
contrast
libraries
address
situations
apis
demonstrate
shared
socket
tcp
highlighted
eighth
edition
guided
previous
observations
rapidly
changing
fields
rewritten
bringing
older
date
removing
longer
interest
relevance
made
substantive
revisions
organizational
importantly
added
open-source
practice
solutions
demonstrations
operation
outline
expanded
cpus
clustered
significantly
updated
machines
grub
boot
loader
debugging
pipes
form
multithreaded
adds
architectures
mutual
exclusion
locks
priority
inversion
transactional
memory-management
strategies
numa
xii
virtual-memory
updates
managernent
current
capacities
implementing
full
zfs
expands
volumes
directories
secondary-storage
structure
iscsi
pools
pcix
pci
express
hypertransport
wireless
limix
latest
increases
early
tops-20
ms-dos
original
emphasize
projects
modified
involved
adding
call
message
queues
creating
solving
producer-consumer
problem
incorporates
steven
robbins
san
antonio
model
behavior
performs
tasks
disk-head
schedulil1.g
starvation
translation
systern
download
observe
scenarios
simulator
parameters
behaves
assigned
algorithmic
developed
scott
pike
a&m
xiii
supplencents
www.wiley.coml
slides
accompany
source
up-to-date
errata
appendix
additional
found
testbank
encouraged
solve
check
answers
obtain
restricted
supplements
solution
guide
contact
local
orne
wiley
sales
representative
note
faculty
mailman
visit
url
follow
instructions
subscribe
http
mailman.cs.yale.edul
mailmanllistinfo
os-book
mailing-list
benefits
archive
postings
subscription
options
digest
send
messages
list
e-mail
cs.yale.edu
depending
reply
personally
forward
mailing
moderated
receive
inappropriate
mail
class
attempted
clean
error
but-as
systems-a
obscure
bugs
hearing
textual
errors
omissions
identify
improvements
contribute
glad
hear
correspondence
os-book-authors
derived
coauthored
james
peterson
helped
hamid
arabnia
rida
bazzi
randy
bentson
david
black
xiv
joseph
boykin
jeff
brumfield
gael
buckley
roy
campbell
capon
john
carpenter
gil
carrick
thomas
casavant
bart
childs
ajoy
kum.ar
datta
joe
deck
sudarshan
dhall
doeppner
caleb
drake
racsit
eskicioglu
hans
flack
robert
fowler
graham
richard
guy
max
hailperin
rebecca
i-iartncan
wayne
hathaway
christopher
haynes
don
heller
bruce
hillyer
mark
holliday
dean
hougen
michael
huangs
ahmed
kamet
marty
kewstet
kieburtz
carol
kroll
westet
leblanc
leggett
jerrold
leichter
ted
leung
gary
lippman
carolyn
miller
molloy
euripides
montagne
yoichi
muraoka
jim
banu
ozden
posnak
boris
putanec
charles
qualline
quarterman
mike
reiter
gustavo
rodriguez-rivera
schauble
skimcer
yannis
smaragdakis
jesse
laurent
stankovic
adam
stauffer
stepanek
sterling
hal
stern
louis
stevens
pete
umbaugh
steve
vinoski
tommy
wagner
larry
wear
jolm
werth
westall
weston
yang
xiang
paper
levy
unpublished
manuscript
stephen
tweedie
dave
probert
cliff
martin
updating
accompanying
supplied
arvind
krishnamurthy
shapiro
bryan
cantrill
mauro
answered
solarisrelated
questions
incorporate
reece
newman
initially
explored
appropriateness
josh
dees
rob
reynolds
contributed
.net
trona
saint
colchester
vermont
marilyn
turnamian
generate
wogahn
produce
e.g
latex
macros
fonts
works
properly
associate
publisher
dan
sayre
expert
guidance
prepared
assisted
weisman
managed
smoothly
production
editor
ken
santor
instrumental
lauren
sapira
cindy
jolmson
helpful
ready
beverly
peavler
copy-edited
freelance
proofreader
katrina
avery
indexer
word
haven
burlington
architecture
ucture
operations
services
calls
types
summary
generation
ipc
clientserver
xvi
multithreading
threading
criteria
multiple-processor
evaluation
backgrmmd
critical-section
semaphores
deadlocks
characterization
methods
prevention
avoidance
monitors
atomic
transactions
detection
recovery
four
background
swapping
contiguous
allocation
paging
page
table
segmentation
intel
pentium
xvii
demand
copy-on-write
replacement
frames
thrashing
memory-mapped
allocating
considerations
directory
disk
file-system
mounting
sharing
free-space
efficiency
nfs
wafl
mass-storage
attachment
man.agement
swap-space
subsystem
transforming
requests
raid
stable-storage
tertiary-storage
struchue
streams
xviii
goals
principles
domain
matrix
program
threats
network
cryptography
tool
authentication
defenses
firewalling
protect
revocation
rights
capability-based
language-based
surnmary
computer-security
classifications
motivation
networkbased
topology
protocols
robustness
naming
transparency
remote
stateful
versus
stateless
service
replication
afs
event
atomicity
election
reaching
agreement
special
purpose
characteristics
kernels
vxworks
5.x
compression
cineblitz
history
modules
environmental
subsystems
input
output
programmer
sum.mary
migration
atlas
xds-940
ctss
multics
ibm
macintosh
xix
a.4
b.l
b.2
b.3
b.4
b.s
conununication
b.6
c.1
c.2
c.3
c.4
enviromnental
c.s
bibliography
credits
index
alo
b.7
c.6
c.7
acts
intermediary
convenient
efficient
manner
manages
prevent
interfering
greatly
makeup
lines
impmtant
begins
basis
choices
complex
created
piece
pieces
delineated
portion
carefully
inputs
outputs
amazing
aspect
varied
accomplishing
mainframe
optimize
personal
business
handheld
combination
explore
begin
discussing
startup
makes
write
functional
well-delineated
grand
tour
role
divided
roughly
compiler
assembler
figure
abstract
view
hardwa.te-the
ievices-provides
browsers-define
coordinates
consisting
similar
government
function
simply
fully
systemfs
viewpoints
1.1.1
varies
sit
front
mouse
monopolize
goal
maximize
play
performing
optimized
single-user
experience
multiple
cases
sits
terminal
connected
accessing
sance
terminals
exchange
llclc
resource
utilizationto
assure
efficiently
tbat
takes
fair
otber
workstations
dedicated
disposal
servers-file
compute
print
compromise
usability
recently
varieties
fashion
standalone
units
directly
wire
modems
power
limitations
perform
battery
life
embedded
home
automobiles
numeric
keypads
turn
indicator
lights
show
status
intervention
1.1.2
point
intimately
context
space
file-storage
facing
possibly
conflicting
decide
allocate
minicomputer
slightly
emphasizes
improper
concerned
1.1.3
defining
looked
views
define
completely
adequate
definition
exist
offer
reasonable
usable
make
definitions
notation
values
collections
bits
numbers
letters
images
movies
sounds
documents
smallest
chunk
nt
instruction
move
bit
term
native
generally
bytes
64-bit
8-byte
words
kilobyte
1,024
megabyte
1,0242
gigabyte
1,0243
manufacturers
round
million
billion
easier
bare
easy
brought
universally
accepted
simple
viewpoint
vendor
ships
order
lack
full-screen
gigabytes
graphical
windowing
running
computer-usually
matter
constitutes
increasingly
united
states
deparhnent
justice
filed
suit
essence
claiming
prevented
vendors
competing
browser
integral
guilty
monopoly
limit
competition
section
ofoperating
neverbeenarnore
interestirighnwtostud
yoperating
neverb.een.e
sier.theopen-sourc
movernent
overtaken
.operating
caj.tsing
marly
ofthenctobemadeavailable
binary
ecuta
jle
fonnat
.this
iistindud
linu
is,and
cos.x
availa
ilityqf
source.code.q,llowsus.tostudyoperq,til
.gsy
tems
frorrt
theinsid,eout
questionsthat
previo
1sly
onlyb
answerecl
atdocumentaticmor
thebehayior.ofan
rating
c.annow
examining
additi
rise
virtualization
.ainsfreafll
andfrequelltly
free
cmnp
1ter
ftmctionmakesitpos
i1jlet
runnmnyoperqtingsystems.ontop.of
onecoresystem
forexample,vmware
lttp
vmware
.com
afree
player
hundreds.of
.virtualappliilnces
cann.m.using
method,students
tryolit
hundreds
ofoperatingsystems.withintheir
operatingsystems
.atno
cost
.sy
temsthat
lortge
ofllmerci
lly
viableltave
opell
lrced
asvvell
enablirtg
.usto
pperated
time.of
v.r
.emory
etnd.storcrge
.resoj.trces
.an
exten
iye.b
.it
complete
9pen-sourct
operafirtg
rom
omp
lre
m._sourc
i..m
..f
....h
...r
....d
ar..e
a.i.l
.le
....o
...g
operat
systell
.to.runon.na
ve.hardware
ithrrtthec
.fines
modem
tipj-iter
moderj1
ystem
decsystemc20
loa
ource.tages
modify
alld
comp
t.evvtops-20
rnel
art
interested
stltdent
search
theint
rnet
origillal
cribe
systemand
the.origipa
manuals
adve
fogen-source
te1tis
lal
.make
fromstu
enttooper
lting
systemdeveloper.with
knov.rledge
som
effo1t
a11d
internet
connection,a
student
alleven
create
operating-systemdistribution
justa
fev.r
itwas
diffic
_llt
if1lpossible
acce
lijnited
bylt
wmuchtimeand
skim
skip
1.2.1
device
controllers
bus
controller
charge
type
drives
audio
video
displays
cycles
orderly
synchronize
start
rum
ing-for
instance
powered
rebooted-it
initial
keyboard
printer
monitor
_rlo
i-nneh
typically
read-only
electrically
erasable
programmable
initializes
registers
contents
bootstrap
load
accomplish
locate
operatingsystem
starts
init
waits
occur
occurrence
signaled
trigger
interrupt
sending
signal
interrupted
stops
doing
immediately
transfers
fixed
location
starting
routine
located
executes
completion
resumes
line
shown
interrupts
transfer
straightforward
method
invoke
generic
interrupt-specific
handler
quickly
predefined
routines
indirectly
intermediate
needed
low
hundred
locations
hold
addresses
array
indexed
unique
request
processing
idle
tmcefeniog

t
single
interrupting
dispatch
save
designs
store
return
stack
processor
state-for
modifying
register
values-it
restore
returning
serviced
saved
loaded
counter
occurred
1.2.2
rewriteable
ram
commonly
semiconductor
technology
forms
camwt
changed
static
immutability
game
cartridges
eeprom
frequently
smartphones
factory-il
stalled
interaction
achieved
sequence
moves
explicit
loads
stores
automatically
typical
instruction-execution
cycle
executed
fetches
il1struction
decoded
operands
fetched
back
notice
sees
stream
generated
indexing
indirection
literal
ignore
ideally
reside
ncemory
permanently
arrangement
reasons
volatile
loses
turned
lost
requirement
quantities
destination
central
importance
larger
sense
describedconsisting
magnetic
disks-is
cache
cd-rom
tapes
storing
datum
holding
retrieved
differences
lie
size
volatility
hierarchy
higher
levels
expensive
fast
decreases
trade-off
faster
another-other
same-then
reason
slower
fact
tape
memories
relegated
museums
cheaper
top
differing
nonvolatile
mentioned
removed
absence
generator
backup
safekeeping
electronic
symmetric
multiprocessing
benefit
simultaneously
cpus-without
causing
deterioration
reach
separate
sitting
overloaded
resulting
inefficiencies
multiprocessor
resources-such
memory-to
dynamically
lower
variance
systems-including
-now
smp
difference
asymmetric
differentiate
master
slaves
sunos
increase
integrated
addressable
uniform
non-uniform
uma
penalty
minimize
management_
discussed
9.5.4
trend
in.clude
chip
chips
cores
on-chip
between-chip
single-core
suited
server
dual-core
caches
architectural
contention
tendency
puts
pressure
designers-and
programmers-to
finally
development
boards
chassis
traditional
blade-processor
board
boots
independently
runs
blade-server
n1.ultiprocessor
blurs
consist
independent
1.3.3
multiple-cpu
gather
computational
composed
systems-or
nodes-joined
concrete
commercial
packages
wrestle
closely
linked
jc.h.a
o.x
interconnect
infiniband
clustering
continue
cluster
fail
high
obtained
redundancy
layer
nodes
node
lan
monitored
fails
monitoring
ownership
restart
failed
interruption
beowulf
clusters
high-performance
built
comm.odi
hard
ware-such
computers-that
area
interestingly
duster
package
con1puting
communicate
thus,.there
constructing
open
freely
low-cost
building
discarded
ht.mdreds
cornputing
computationally
scientific
clusterin.g
structured
symmetrically
rmming
hot-standby
host
active
hosts
mode
supply
greater
single-processor
capable
advantage
technique
dividing
parallel
solved
combined
final
wide-area
wan
simultaneous
accomplished
releases
oracle
tracks
locking
products
dozens
separated
miles
saj
12.3.3
pool
attached
increasing
depicts
talk
envirorunent
commonalities
ability
multiprogram
generat
ith_er
thg
ortbt
1jusy_c1t
il.ul
byorganizing
jobs
codeand
datafso
hasoi1
0to
execl1te
fhe
idea
op-ei
atlng
accommodate
residing
awaiting
setofjobs
inmemg_ry_canbe
asubt
thejql
jpoo1
picks
eventually
job
wait
layout
multiprogramming
_tnpl
non-multiprogrammed
multiprogrammed
operatilcg
switches
switched
finishes
waiting
long
lawyer
client
trial
typed
lawyers
tend
politicians
social
value
keeping
busy
utilized
effectively
is_
alex_tension
time-s
caring
syste
s,the
cpl
execu
eslnl1ltiplejobs
switcll.ing
ainong
1sers
canh
teract
eachprograffi
ere
l.t1sil.mning.
-ti1ne
shar
requi.i-es
direct
te
sho
1ld
time-shared
action
command
short
impression
entire
11ses
eachuserhas
atleast
t_e
parateprogra111inmemory
tirne
interactive
display
people
speeds
bounded
typing
characters
incredibly
slow
switch
room
choose
making
decision
selects
requires
f_s
verajjq
jsaxere
lcly
sd1,2dviii
jobscoi
cl.lrl
ei1hy
affect
limited
phases
time-sharing
swapped
out
achieving
tec
hdiql1
_fuc
cillqws._
aprocessthat
isnot
inl1le1yl_cld
advai1tage
scheme
enables
actual
abstracts
separating
logical
viewed
frees
programmers
concern
memory-storage
resides
disks
protecting
stuck
forever
si1
e11tio11ecl
arlier
cletnopexatli1ksystems_m
respond
quietly
happen
events
trap
interruptca
seci
ler
byan
division
byzero
invalid
acc
ss_
performed
interrupt-driven
segments
determine
responsible
adversely
affected
bug
infinite
loop
prev.ent
subtle
erroneous
sorts
suspect
incorrect
x.t
cute
incorrectly
,_c
..c
1.5.1
dual-mode
distinguish
userdefined
approach
modes
viththeplode1
jit
ve2lrea
distinguishbetween
onbehalf
aicd
executeci
behalfofthejjser
systel.n1s
behalf
transition
fulfill
enhancement
occurs
gains
passing
dual
errant
users-and
cc011lplishthis
designating
ofthe
machineine
tructions
trlijjt
cal1_sej
l11
ins
trucrci
il1e
spl
iyileg
instrl
ctionsto
o11ly
inkern
ll11qq_
attempt
privileged
treats
illegal
traps
controt
timer
_5ysiemcalls
proyide
auser
st
perforp
re_
erved
forjhe
syst
gr1
1.lser
.12l
qgra1llsbeha,lf
invoked
underlying
vector
mips
r2000
syscall
asystep1
calljs
ecutect
treated
rlt
l.l
iltrol
passes
systemcaflserv1ce
the-kernel
examines
parameter
requesting
quest_may
passed
vedfies
legat
ti1erequest
returns
hardware-supported
shortcomings
rum1ing
awry
wipe
writing
potentially
disastrous
contemporary
systemssuch
-take
detects
violate
way-such
space-then
terminate
abnormally
user-requested
abnormal
termination
dumped
dump
1.5.2
wer
r1,_ust
ope
atil
gsystemij
taintains
ontrol
overthe
cam1.ot
userp
ogram
to_
stuc
kin
e1ninfinite
syste1n
seryices
retltrn
perating
tl1.1s
we_can
usea
_a_tirn
r_can
beset
mp_ut
af_t
ril
ified
peri
variable
millisecond
fixed-rate
clock
sets
ticks
decremented
reaches
10-bit
1-millisecond
intervals
milliseconds
steps
turning
ensures
tij11e_
_il1t
totll.e
pel
epl,_
thicfl__
l-1
1ytreat
faiaf
taygi-y_etll.ep_rograrn
rnc
clearly,il
structions
il1.itialize
allowed
7-minute
initialized
positive
returned
negative
terminates
exceeding
word-processing
subprocesses
concurrent
resources---including
me111ory
and-i
esources
tl1er
or
allocated
obtains
initialization
screen
desired
reclaim
reusable
_111pl
t21size
itselfis
nota
y_assive
likt
tl1e
i1terltsof
fil
storecl_m1
iskl
a.thereasc
_pr
jce
s_1s
entity
si-dgl
1hr
eaded
proc
_pr_ogra111
cou11
eecifying
nexf1il
uc_tiogt
_ex
cljte
-execi.rtioil
sequential
completes
considered
sequences
counters
pointing
jheseprocesses
canp
ltially
_lly.ij
lli
p_l
sir1gle
,for_
ample
connection
deleting
suspending
resuming
process-management
techniques
ranging
thousands
billions
repository
accessible
reads
instruction-fetch
writes
data-fetch
von
neumann
noted
generallythe
mu.st
transferred
lemory
cpu-generated
mapped
absolute
accesses
generating
declared
memorymanagement
schemes
reflect
selecting
account
factors-especially
track
deciding
thereof
deallocating
il1
maps
media
1.8.1
pile
visible
optical
medium
controlled
drive
capacity
data-transfer
rate
randmn
creator
object
alphabetic
alphanumeric
free-form
formatted
rigidly
extremely
implements
desirable
read
append
accessed
organize
primitives
manipulating
mapping
backing
stable
file-management
teclmiques
1.8.2
holds
principal
programs-including
assemblers
editors
formatters-are
hinge
manipulate
backups
seldom-used
long-term
archival
dvd
platters
write-once
read-many-times
read-write
formats
crucial
leave
progran1s
systerns
unmounting
rnedia
freeing
exclusive
migrating
1.8.3
caching
principle
copied
system-the
cache-on
temporary
putting
copy
assumption
high-speed
register-allocation
register-replacement
totally
expected
hardware-only
careful
selection
policy
increased
compares
software-controlled
16mb
64gb
100gb
custom
off-chip
cmos
dram
ports
cmossram
0.25-0.5
0.5-25
80-250
5,000.000
bandwidth
20,000
100,000
10,000
1000-5000
20-150
backed
moved
highest
maintain
bulk
magneticdisk
removable
loss
hard-disk
failure
autoinatically
jukeboxes
movement
implicit
f_o
lstilnce,datatransfe
11
cl_
r-_s
_is_
1suall
ahardvvare
op-era
ii.g
sy-s
tern
data-from
aisk
controlledby
the-op
ra-t
ri.g
11ier2rrchical
suppose
integer
incremented
increment
proceeds
issuing
block
copying
appears
places
differs
tim.e
poses
difficulties
multitasking
-forth-among
var1ous
extreme
care
processe
o-accessa
___
--.c
complicated
maintaining
bc1
.1l_
_ill_
1lt
2ey
f_a
ij.t
simultaneouslyinseyeral
variouscpus
tly
,ve-must1nake
surethat
ofa
1.8.4
a11
hide
peculiarities
ofspecific
jro1n
l1s
hidden
component
buffering
spooling
device-driver
drivers
driver
1.2.3
handlers
construction
regulated
operated
memory-addressing
gain
relinquishing
device-control
users-to
resourcesdefined
rni1st
confrols
enforce
detecting
latent
contamination
healthy
malfunctioning
unprotected
defend
isuse
unauthorized
incompetent
protection-oriented
authorized
usage
terl
_ca1lhave
adequateprotection
prone
ado_w
inappr
priat
acs
identifying
stolen
deleted
working
external
attacks
spread
huge
viruses
worms
denial-ofservice
legitimate
identity
theft
due
alarming
incidents
fast-growing
names
parlance
numerical
ids
logs
stage
determines
readable
translated
circumstances
owner
issue
group
belonging
system-wide
ic1entifiers
groups
decisions
normal
s-l.iffici.e11t
hov
tever
extra
permissions
activity
fhatis
resh
icted,for
examp1e.operatmg
privilege
escalation
setuid
attribute
turns
privileges
physically
heterogeneous
networked
generalize
contained
specifically
mix
modes-for
ftp
utility
popularity
simplest
terms
path
depend
distances
transport
protocol
atm
widespread
likewise
proprietary
device-a
adapter
examplewith
manage
handle
characterized
floor
links
buildings
cities
countries
company
com1ect
offices
continuing
advent
brings
link
bluetooth
commt.micate
distance
feet
carry
equally
copper
wires
fiber
strands
transmissions
satellites
microwave
dishes
radios
cellular
phones
short-range
infrared
rudimentary
notion
connectivity
autonomously
aware
autonomous
comm
lmicate
illusion
focused
objective
domains
1.11.1
existence
car
engines
manufacturing
robots
dvds
ovens
systencs
primitive
preferring
spend
automobile
robotic
arms
considerably
systems-such
unix-with
application-specific
circuits
continues
expand
elements
houses
computerized
computer-either
system-can
heating
lighting
alarm
coffee
makers
enable
house
heat
arrives
someday
refrigerator
grocery
notices
milk
rigid
flow
sensors
bring
analyze
adjust
sensor
experiments
medical
imaging
industrial
realtime
automobile-engine
fuel-injection
home-appliance
weapon
well-defined
constraints
robot
arm
instructed
halt
smashed
correctly
mandatory
batch
great
detail
1.11.2
conventional
progranls
spreadsheets
incorporation
data-such
video-must
streamed
restrictions
today
mp3
conferencing
clips
movie
previews
news
stories
downloaded
live
webcasts
broadcasting
speeches
sporting
webcams
viewer
manhattan
customers
cafe
paris
desktop
directed
smaller
pdas
telephones
stock
trader
quotes
wirelessly
pda
demands
affects
1.11.3
digital
assistants
palm
pocket-pes
developers
face
challenges
inches
height
width
weighs
one-half
pound
amounts
screens
workstation
behave
confines
fraction
replaced
recharged
consume
tax
last
confronting
designers
limits
keyboards
handwriting
screen-based
measure
square
browsing
pages
condensed
displaying
subset
displayed
fall
category
downloading
balanced
convenience
portability
com1ections
cameras
players
conclude
1.12.1
matures
blurring
office
ago
consisted
pcs
awkward
laptop
mainframes
companies
fewer
stretching
boundaries
establish
accessibility
ccxepu1as
essentially
web-based
con1pany
connect
portal
myriad
network-connection
inexpensive
giving
connections
serve
printers
homes
breaches
firewalls
dollars
decade
half
century
scarce
nonexistent
processed
predetermined
sources
waited
uncommon
owned
slice
1.12.2
client-server
faste1
powerful
shifted
supplanted
correspondingly
user-interface
act
satisfy
specialized
depicted
broadly
categorized
sends
responds
update
delete
delivers
browsers
1.12.3
peer-to-peer
p2p
distinguished
peers
ncay
participate
join
joined
to-and
-other
determining
joins
lookup
desiring
contacts
provider
peer
acting
discover
discovery
late
1990s
file-sharing
napster
gnutella
exchanging
broadcasts
future
remains
uncertain
copyrighted
music
laws
governing
distribution
peerto
undoubtedly
searching
1.12.4
leading
wider
dreamt
pdas1
cell
emphasis
previously
wired
improved
categories
distribute
an1.ong
acted
evolved
complexity
web-enabled
vast
source-code
format
compiled
famous
well-known
opposite
dosedapproach
oppositethe
binaries-is
lot
work1
items
recovered
learning
code1
summaries
compile
changes1
excellent
indudes
involve
text1
deeper
commtmity
unpaid
helping
debug
secure
closed-source
eyes
viewing
advocates
argue
owing
earn
revenue
selling
hesitant
red
suse1
showing
contracts
sale
1.13.1
days
1950s
hackers
enthusiasts
mit
tech
railroad
club
left
drawers
homebrew
exchanged
meetings
company-specific
equipment
corporation
dec
contributions
collected
ncembers
sought
paying
releasing
achieve
ideas
competitors
books
effective
u.s
millennium
copyright
dmca
reverse-engineer
drm
circumvent
redistribution
stallman
started
gnu
unixcompatible
manifesto
argues
open-sourced
formed
encouraging
fsf
copylefts
improvement
gercera
codifies
copylefting
license
released
ftmdamentally
gpl
binaries
1.13.2
unix-compatible
utilities
finland
linus
torvalds
unix-like
invited
meant
submit
week
so-called
grow
enhanced
thousand
spawned
builds
distributions
redhat
suse
fedora
slackware
ubuntu
installed
enterprise
lim1x
geared
pclinuxos
jvc
cd-an
booted
variant
supergamer
graphics
gamer
compatible
booting
finished
reboot
resets
tuned
desktops
founder
pays
printing
helps
player
uncompress
untar
tar
2.6.18.1.tar.bz2
1.13.3
derivative
at&t
california
berkeley
ucb
opensource
slowed
lawsuit
4.4bsd-lite
lim.ix
netbsd
openbsd
dragonflybsd
image
darwin
posted
xnu
revision
leopard
www.opensource.apple.coml
darwinsource
balls
apsll
xnu-1228
tar.gz
appl
originally
close-sourced
test
fix
mature
full-featured
historic
build
ilinux
licensing
licenses
mutually
cross-pollination
ported
sourcing
quality
individuals
cornputer
human
program.s
millions
mem.ory
designing
uniprocessor
utilize
employ
nmning
modification
tin1.er
prevents
loops
facilities
blocks
representing
securing
measures
defending
geographically
n10del
computations
members
lans
wans
geographical
consumer
robotics
fixed-time
delivery
playing
synchronized
influence
leadi.j.1.g
advantageous
configuration
dormitory
campus
nation
give
vvbat
eliminate
timesharing
machine-a
distinction
degree
answer
enforcing
tradeoffs
inherent
construct
arguments
entries
device-status
coherence
cached
manifests
disadvantage
cooperate
highly
difficulty
overcome
avoid
coordinate
dma
transferring
interfere
interference
caused
functionalities
listed
supported
shows
settings
intentionally
sincilar
brookshear
bovet
cesati
solomon
russinovich
considerable
abmrt
internals
mcdougall
singh
parameswaran
gong
ripeanu
agre
balakrishnan
loo
lee
good
buyya
advances
survey
relating
tanenbaum
van
renesse
textbooks
stallings
2000b
nutt
hamacher
cmnputer
laudon
hennessy
patterson
buses
blaauw
brooks
stokes
illustrated
microprocessors
associative
analyzed
smith
extensive
subject
discussions
magnetic-disk
freedman
harker
kenville
fujitani
oleary
kitts
gait
olsen
kenley
floppy
offered
pechura
schoeffler
sarisky
chi
hoagland
kurose
ross
overviews
fortier
presents
detailed
kozierok
mullender
discusses
developments
developing
myers
beigl
dipietro
mancini
raymond
hacking
foundation
philosophy
howtof
orge
vantage
points
interconnections
showin.g
debugged
methodologies
structuring
customized
n1.ake
interrelate
helpfuj
dcfr
commands
entering
editing
directives
entered
window
menus
selections
enter
variations
indicating
recording
blanking
manipulation
deny
choice
communications
rnenwry
packets
constantly
parity
arithmetic
overflow
too-great
consistent
variation
react
enhance
abilities
lultiple
usersormultiple
rmuung
sametime
d1herent
-types
cpu-scheduling
factors
usb
accounting
to_keeptrack
whichusers
lovy
rnl1c
hand
kindsofcomputer
record
accoun
tii1g
thai
billed
accumulating
statistics
valuable
researchers
reconfigure
owners
multiuser
hould
iiwolves
systerr1
-controlled
outsiders
requiring
authenticate
password
extends
adapters
attempts
break-ins
precautions
instituted
chain
strong
weakest
command-line
gui
2.2.1
interpreter
treat
initiated
interpreters
shells
bourne
shell
bourne-again
korn
third-party
user-written
preference
user-specified
jump
comnlands
alternative
-used
-implements
cmnmand
file.txt
txt
add
r
console
extended
ogi
nell
1sj
un0718days
wai
actv
svc_t
average
jcpu
pcpu
command-interpreter
2.2.2
interfacing
userfriendly
cui
mouse-based
windowand
nl.enu
metaphor
position
pointer
clicking
button
directory-known
folder-or
pull
menu
taking
1970s
xerox
parc
alto
1980s
undergone
adoption
aqua
windows-version
1.0-was
cosmetic
appearance
enhancements
explorer
traditionally
dominated
gul
cde
x-windows
aix
kde
gnome
prefer
pleased
nice
historically
screenshot
substantially
friendly
systenc
concentrate
low-level
assembly-language
prompting
icon-based
opened
conditions
abort
option
termin.al
replace
reached
encounter
close
see1
heavy
systemcall
applicatiol1
accordir1g
ji
ajispecifies
posix-based
that-unless
-the
system-call
createprocess
unsurprisingly
ntcreateprocess
programnl.er
invoking
concerns
supports
difficult
correlation
acquire
prompt
accept
apt
readfile
unction
api-a
bool
lpvoid
dword
lpdword
lpoverlapped
buffer
ovl
file-the
buffer-a
bytestoread-the
bytesread
ovl-indicates
overlapped
run-time
serves
intercepts
invokes
nunlbers
caller
rathel
obey
relationship
opeo
illustrates
handles
onthe
coj
rlpl1te.rjjlll
exact
ammmt
length
pass
param.eters
pushed
popped
stacl
operatirl
yste111
syste1ns
grouped
oughly
intc
manipujation
maintenance
coinmuiii
a1ioii
lndpr
tediol
ri.s
2.4.l
hi.i
l.gli
2.l
discllss
summarizes
2.4.1
ruru1il1g
examined
aid
finding
correcting
bugs-to
mterpreter
cominand
assumed
pop-up
wmdow
alert
cards
actions
batch-system
discovers
severe
higher-level
combi11e
jobexecuting
gral11_11l
ll1tto
joad
andexecut
anoteer
pro-gra1
th1s
feafl
i11terpreter
click
interesting
attributes
reposition
logically
detach
createprocesso
fork
exi
tprocess
exit
waitforsingleobject
createfile
writefile
closehandle
setconsolemode
ioctl
readconsole
writeconsole
getcurrentprocessid
getpid
settimero
sleep
createpipe
pipe
createfilemapping
shmget
mapviewoffile
mmapo
setfilesecurity
chmod
initlializesecuritydescriptor
umask
setsecuritydescriptorgroup
chown
multi
programmed
reset
maximum
allowable
finish
lock
preventing
locked
printf
statement
system-in
stdio.h
int
dealilcg
facets
examples-one
involving
single-tasking
-to
clarify
sincple
overwritten
reload
fre
_s_i
der_i_
eley
otthe
s-choiceis
accepts
startanew
__process,_th_es1w1l
for-k
tem
exec
issued
fron1
nonzero
thefork
systemcalls
2.4.2
rewinding
skipping
organizing
codes
callable
2.4.3
execute-main
granted
sufficient
thought
llnmanaged
hazard
potential
requested
similarity
merge
file-device
identified
placement
ncake
similar1
dissimilar
2.4.4
provision
trace
lists
step
caught
debugger
profile
prof
c_92
cee
ki2l
ility_s
egl1lar
tii
_ee
c6l-i
te1
-ls
recorded
sufficiently
frequent
statistical
picture
spent
3.1.3
2.4.5
ll1l
ji1_
od_e_l
ss_colrll
nica
tion
ssag_e
shared-memory
nth
g_e
pa,s
ij1gl
lel
t_l
rrtll12injfa_fii
gpr
lailg
ill-es
ges
tcfo_rillaji
mailbox
communicator
comcected
identifier
narne
systemcanrefertotheprocess
hostidand
processid
identifiers
generalpurpose
recipient
permission
comnmnication
receiving
daemons
awakened
rna
daenwn
shared-me_1llorytllodel,proc
sses
tlared
memorycreate
2rt1d
toi
egions
n1emory
recall
operatinisystein
hiesf
prevei1foiie
process-from
agree
remove
restriction
areas
determined
sirnultaneously
scheme-threads-in
default
conflicts
intercomputer
2.4.6
can-or
not-be
lowest
enviromnenf1orprograrn-aevelopmeiita1inexecuhon
rename
ncanipulate
logging
retrieve
transformations
programming-language
debuggers
visual
perl
loading
assembled
loaders
relocatable
linkage
overlay
comcections
rnessages
browse
electronic-mail
log
remotely
ogr
lj1ls
iitcllldeif
jrg_wsf2r
worg
f6-rinatteis,spreadsheets
plott1i1g
ana
s-tafistica
-analysis
ancl
gan1es
tne
viewoclne
opei
ating-sysrerri-seen
inost
rumcing
featuring
mouse-and-windows
alternatively
confusing
dual-booting
exposed
successful
2.6.1
specifications
harder
desire
obvious
reliable
safe
flexible
vague
interpreted
mvs
multiaccess
creative
2.6.2
policies
separation
mechanisiil
echa
1lis
leter111il1e
hcnu
q_c
-sonl
tl-til1g
lic
les
termir
zul1dt
wilcbe
mechani.sril
-forensill1ng
_s_
122l
cl_tig
fp.qli_cy_an_ci
t1_echanism
imp
rtant
flexibility
over
rri
tlle
worst
insensitive
redefinition
progran1.s
cpu-intensive
microkernel
operati1lg
sy_sh
mechai
1sinai
cfp
hcyto
byimplementing
basicset
j_pri111.iti_y
1jiwding
bfocks
-1necharnsms
user-created
scheduler
loadable
tables
load-new-table
th_
is_il_
ttc
-as
ti_
l_t
yjc_
icj
lec
.c
and_p
_1i_c_y__a_
_epc
ciec
1._
j_e_ilforce__
an_cl_
fe_el
2.6.3
assembly
cor
mcp
burroughs
algol
sections
saving
restoring
systemsimplementation
accrued
compact
recompilation
port-to
hardware-if
natively
x86
emulators
non-nativelyslower
use-on
duplicate
sparc
ibmpowerpc
reduced
howeve1
analysis
apply
optimizations
deep
pipelining
n1.ultiple
dependencies
mind
critical
equivalents
engineered
partition
monolithic
interconnected
melded
2.7.1
systen1.s
grew
scope
systen1
wellseparated
rnstai1.ce
appii.cat1on
aie
outiri.es
freedom
leaves
vulnerable
malicio
lls
crashes
era
systein
dc5s
ware
ft1il.cfionali.ty
consistsoftwo
separahlepai
thei
eril.el
ai1d
prograrns
thekei
nel
bios
series
layered
rgvides__i
_fil
dulijl,g
fm1ctions
i.n
sum
thatl.sai1
enormous
an1ol.lnt
2.7.2
withproper
tarc
brokeninto
app1
opriate
thar
hose
signals
character
.qoiilncil
lj_ix
systeill
retain
implementers
workin.gs
modular
topdown
hiding
fit
stays
unchanged
advertised
qne
broken
ii1to
1l.umberoflayers
lever8j.ti1eoottom.iiiyer
.1sthetiarawai
nig
ytesl
layern
1sfhe
layering
layer-say
-consists
layers
simplifies
.system
verification
functioning
simplified
lowerlevel
hides
involves
appropriately
backing-store
rescheduled
m.ay
u1.formation
backu1.g-store
implementations
trapped
laye1
tum
overhead
net
nonlayered
backlash
beu1.g
providu1.g
modularized
avoidu1.g
2.7.3
microkernels
mid-1980s
carnegie
mellon
operatu1.g
roke
ee1
2lc
i.b
._gl
_0ructl
--t
nonessential
cornponentsfrom
thekemel
1mp
e_l
-ll
itil
fe_l
rl.ls_
greili
the.reslin
is-a
smarrei
consensus
minimal
micro
wishes
interact
microkemel
ease
extending
port
user-rather
kernel-processes
untouched
tru64
user-level
qnx
nl.icrokernel
suffer
compared
partially
redressed
moving
integrating
2.7.4
methodology
object-oriented
armmd
executable
miscellaneous
resembles
module
hybrid
procedure
rpcs
kit
refers
comn
10n
conclusion
si11.gle
run.ning
private
identical
guest
2.8.1
commercially
-----1
vm1
vm2
vm3
virtual-machine
nonvirtual
worth
exploring
vm370
nmltiple
numing
ncajor
virtualmachine
wanted
substantial
disks-termed
minidislcs
-that
respects
minidisk
ran
cms-a
2.8.2
fundarnentally
virus
inside
damage
guests
isolated
volume
modeled
perfect
vehicle
operating-systems
dangerous
wrong
destroy
tlle
stopped
comnconly
systemdevelopment
unavailable
scheduled
night
weekends
seldom
disrupted
developer
virtualized
porting
testing
varying
enviromnents
sinlilarly
quality-assurance
engineers
buying
powering
data-center
physical-to-virtual
conversions
optimization
lightly
heavily
deployment
evolve
install
pre-install
virh1al
tuning
administrators
installation
redeploying
usual
uninstalling
reinstalling
standardized
platform
succeed
unifying
2.8.3
simulation
system-emulation
outdated
e1nulator
translates
emulation
challenge
instruction-set
magnitude
ten
emulator
2.8.4
para-virtualization
vanat10n
theme
trick
believing
paravirtualization
preferred
paravirtualized
container
containers
stacks
accounts
systemwide
zone
2.8.5
usefut
remember
calt
simulate
effect
noting
spooled
slowing
unpredictable
simulated
slowly
impossible
amd
operation-host
thinks
2.8.6
coming
compatibility
methods-simple
wdules
machines-are
2.8.6.1
ing
scenario
owns
disaster
qpu
jemgfy
2.8.6.2
introduced
specification
machine-or
objects
produces
architecture-neutral
bytecode
.class
bytecodes
diagrammed
verifier
checks
valid
underflow
garbage
reclaiming
interprets
just-in-time
subsequent
invocations
framework
target
worry
aboutthe
specifics
successfully
runtime
clr
itprovides
targeted
pronounced
c-sharp
vb.net
architecture-independent
ms-il
assemblies
metadata
.exe
.dll
.is
converts
compilation
converted
ofthe.clr
bypassing
just-in-tim.e
fixing
seeks
2.9.1
operators
capture
referred
dumps
probed
risky
rebooting
unrecoverable
kernel-owned
reboots
crash
2.9.2
bottlenecks
producing
listings
logged
traces
suggested
kernighan
law
cleverly
smart
sorted
resource-using
traffic
authors
single-purpose
guess
analyzing
tune
enabling
tracing
kernel-enabled
emit
dtrace
dynamic
2.9.3
probes
i11
queried
astonishing
ending
interactions
toolset
understands
instrument
affecting
minimum
impact-ideally
impact
proportional
meets
low-impact
environncent
shrouded
mystery
happenstance
archaic
breakpoint
negatively
reen,g
periodically
samples
trends
pgrep
xclock
xeventsqueued
script
matched
_xeventsqueued
_xlltransbytesreadable
_xlltranssocketbytesreadable
getf
udatamodel
releasef
broadcast
slows
occurring
systems-systems
applications-and
harm
enabled
pre-debugging
broad
happening
delve
deeply
subroutine
providers
hash
hashed
probe
dtrace_probe
kinds
differently
user-process
generates
assured
modifications
root
ace
consumers
fires
emits
fire
ecbs
ecb
predicate
filter
gathering
firing
kernel-level
reactions
invaluable
monitoril1.g
tennil1.ates
consuming
rewriting
put
destroyed
probing
buffers
exceeded
terminated
offending
ofd
nms
sched
on-cpu
uid
self
timestamp
-cpu
execname
nanoseconds
sched.d
sched.d
grwme-settings-d
gnome-vfs-daemon
dsdm
wnck-applet
gnome-panel
clock-applet
mapping-daemon
xscreensaver
meta
xorg
gnome-terminal
mixer
applet2
agreements
capabilities
derivatives
kernel-tracing
beginning
fostered
institutions
paradyn
configurations
configured
sysgen
dvd-rom
iso
asks
floatingpoint
partitions
referencing
fault
legal
sizes
administrator
declarations
initializations
constants
conditional
output-object
tailored
lead
precompiled
recompiled
overly
driven
lil1.k
generality
newly
acquired
termil1.al
frequency
infrequency
locates
two-step
receives
event-for
rebooted
unknown
infected
diagnostics
initialize
sooner
consoles-store
rugged
resolve
eprom
readonly
writable
firmware
thart
ammmts
ock
fits
disk-bound
12.5.1
bootsh
traverse
batch-mode
u.ser
accord
ilcg
satisfied
classified
def
ilced
iilce
modularity
improves
buggers
fucd
progressively
smarter
regard
develop
designer
dependent
unclear
tight
coupling
choosing
usil1.g
strengths
weaknesses
experimental
synthesis
incorporated
assembles
antithesis
buildu1.g
pros
cons
system-performance
obtaining
copies
destilcation
checking
ptrace
truss
ktrace
i11corporate
kernet
expanding
user-mode
jumping
intel386
eax
ox80
juxnps
interacting
lusr
nr_close
closin.g
descriptor
lusrlsrcllinux-2.x
heading
entry
sys_calltable
sys_close
unistd
keyword
.long
denotes
occupy
familiarize
comprises
srcllinux
suffix
configure
xconfig
dep
bzimage
boatable
lilo
ofbootable
boot-up
conf
label
mykernel
lbootlbzimage
unmodified
ftmction
experiment
compiling
srcllinux-2
xlkernel
xlkernelimakef
ile
makefile
helloworld
sheds
light
header
linuxllinkage
linuxlkernel
linuxllinkage.h
linuxlkernel.h
asmlinkage
sysjhelloworld
printk
kern_emerg
creates
sys_helloworld
sys_hellowor
rellli
ant
prototype
nr_helloworld
nr_syscalls
constant
defuced
definedinthe
completing
ordinarily
manual
earlie1
statements
fortunately
instantiating
wrapper
_syscallo
macro
specifies
instantiate
string
printed
illto
implications
opposed
dijkstra
advocated
desigll
brinch-hansen
proponent
nucleus
instrumentation
tamches
hart
covers
mckusick
mach-are
vahalia
lwww
comlmacosx
vmi370
microkernel-based
young
kaashoeket
exokernel
separates
untrusted
exercise
gosling
lindholm
yellin
workings
ven11ers
golm
highlight
deletion
current-day
evolution
firmer
compartmentalization
resulted
multiplexed
switching
productive
introduce
arises
activities,_f
_qcij
hj3ystem
xeq_l_
_lqq.s_
_2l_
_i_
11_e
ds_ys
tas
browse1
_the
etif
_lised
interchangeably
operat1ng-system
theory
terminology
misleading
superseded
3.1.1
informally
represented
variables
heap
thatis
passive
double-clicking
icon
prog
exe
diagram
equivalent
spawns
3.1.2
proces
excr
utes
defil1.ed
reception
arbitrary
finely
delineate
realize
instant
1cb
cess
isrepreserlt
pjnthe
operatir1,g
process_
coptrol
blo_ck
pcb
-alsocalled
taskcontrozbloclc
iil.format1o11assodated
runnil
halted
mclude
accumulators
condition-code
mterrupt
continued
afterward
segment
dependmg
mformation
briet
3.1.4
implied
word-processor
spell
checker
operatin.g
explores
nnming
meet
objectives
3.2.1
queue
representation
struch1re
task_struct
parent
pid_t
pid
unsigned
time_slice
struct
list__head
files_struct
mm_struct
isrepresented
doubly
-current
proccess
illustration
new_state
currentis
ready-queue
pcbs
mag
t_82_11
il
quits
queueing
rectangular
box
circles
arrows
dispatched
subprocess
forcibly
queueing-diagram
deallocated
3.2.2
schedulers
migrates
lifetime
carried
short-term
allocates
lies
executions
percent
wasted
freqvently
minutes
equal
departure
leaving
interval
afford
tin
bound
spends
cpu-bound
infrequently
empty
unused
unbalanced
absent
stability
limitation
self-adjusting
declines
acceptable
quit
medium-term
key
reduce
multiprogramrning
reintroduced
overcommitted
freed
swap
partiaii
sw11pped-out
3.2.3
generically
resu.me
saves
context-switch
pure
ultrasparc
resorts
preserved
preserve
n1.echanisms
3.3.1
create-process
forming
tree
processes-including
pageout
fsflush
ini
t-inetd
dtlogin
inetd
telnet
session
xsession
sdt_shel
sdlshel
shell-the
c-shell
csh-is
commandline
child
cat
csh
netscape
emacs
listing
-el
recursively
constrained
restricting
overloading
file-say
img.jpg-on
img.jpg
possibilities
ve
tmique
destroying
await
sysltypes.h
unistd.h
fprintf
stderr
execlp
lbinlls
,null
null
inherits
overlays
implicitly
,where
windows.h
void
startupinfo
process_information
zeromemory
&si
sizeof
si.cb
&pi
system32
mspaint.exe
inherit
false
disable
inheritance
flags
pi.hprocess
pi.hthread
examplef
functionf
howeverf
inheriting
furthermoref
parametersf
expects
mspaint
opt
pursuing
consult
instances
proceeding
process.lnformation
tforsingleobj
ect
process-pi
hprocess-and
exits
3.3.2
process-including
buffers-are
terminateprocess
arbitrarily
kill
identities
m.ust
inspect
exiting
vms
phenomenon
cascading
collect
cooperating
shares
cooperation
speedup
break
subtasks
channels
region
established
messagepassing
conh
asted
system.s
time-consuming
irttervention
sharedmemory
regions
assistance
ren1.ainder
3.4.1
communicating
excbange
paradigm
producer
consumed
html
filled
emptied
item
assumes
buffer_size
typedef
circular
nextproduced
3.5.1
3.14
3.4.2
message-passing
lrt
showed
chat
participants
recei
fixed-sized
system-level
nextconsumed
conversely
variable-sized
1nore
simpler
coitlmon
kind
tradeoff
indirect
synchronous
asynchronous
automatic
3.4.2.1
sender
-send
-receive
pair
exhibits
symmetry
addressing
receiver
employs
asymmetry
necessitate
hard-coding
stated
mailboxes
abstractly
w1.ique
identification
robin
eith
confusion
disappears
subsequently
notified
tailbox
receivers
3.4.2.2
blocking
nonblockingalso
blocked
nonblocking
retrieves
combinations
rendezvous
trivial
3.4.2.3
basically
finite
quelie
unbounded
zero-capacity
segment_id
ipcprivate
s_lrusr
s_lwusr
identifies
used-that
shmat
flag
shared_memory
char
sprintf
attaches
detaches
shmdt
shmctl
segrnent
ipcrmid
4,096-byte
outputting
removes
3.5.2
message-based
mach-including
intertask
informationis
tailboxes-the
notify
mailbox-are
notification
occurrences
msg_send
msg_recei
msg_rpc
,which
rpc
systems-hence
porlallocate
syslshm.h
syslstat.h
segmenlid
canst
ipc_private
s_irusr
s_iwusr
sprint
ipc_rmid
defaults
queued
first-in
first-out
fifo
guarantee
senders
fixed-length
variable-length
system-such
segments-n
indefinitely
temporarily
pending
line-printer
finishing
one-time
porlstatus
named
singleprocessor
evidenced
inclusion
poor
double
double-copy
virtual-memory-management
message-management
boost
intrasystem
website
3.5.3
decrease
n1.essage-passing
lpc
communicates
channet
inherited
cmmection
opens
conimunication
callbacks
listen
replies
rnessage-passing
establishes
channel
decides
avoids
callback
lpcs
ir1
sockets
3.6.1
endpoint
sockets-one
concatenated
incoming
listening
com1ection
i-htp
listens
initiates
146.86.5.20
161.25.19.8
traveling
46.86.5.20
com1.ections
wished
datagram.socket
mul
ticastsocket
subclass
multicast
recipients
connection-oriented
serversocket
com1.ection
printwri
ter
objectthatitwill
println
calling
closes
connecting
import
java.net
java.io
public
dateserver
args
sock
sock.accept
printwriter
pout
client.getoutputstream
pout.println
java.util.date
.tostring
resume
catch
ioexception
ioe
system.err.println
127.0.0.1
madef
serverf
127.0.0.t
referring
addressf
namef
www.westminstercollege.eduf
sockets-although
efficient-is
unstructured
responsibility
impose
subsectionsf
dateclient
,6013
inputstream
sock.getinputstream
bufferedreader
bin
inputstreamreader
bin.readline
system.out.println
idexception
3.6.2
procedure-call
addressed
daemon
requester
packet
rencote
port-say
oil
semantics
locally
side
stub
marshals
marshalling
packaging
transmitted
transmits
teclu1.ique
dealt
32-bit
integers
big-endian
little-endian
machine-independent
converting
machine-dependent
xdr
m1.marshalled
fait
duplicated
semantic
attaching
timestamps
repeated
detected
risk
reqliest
acknowledge
ack
resend
binding
kejyt
.c3
rness
tqe
matchrnakecto
pgrtpuml
f
matchmakerf
rpcx
distriblited
file-related
dfs
3.6.3
conduit
allowin.g
unidirectional
bidirectional
two-way
duplex
travel
directions
parent-child
commlmicating
3.6.3.1
ordinary
producerconsumer
one-way
direction
descriptors
read-end
-pip-e
-ou
comnmnicate
progranc
detect
end-of-file
writer
closed
string.h
read_end
write_end
write_msg
read_msg
strlen
continuation
termed
counterparts
relationships
wri
tefile
createpi
stdlib.h
readhandle
writehandle
anonymous
unlike
initializing
security--attributes
redirecting
redirect
prohibit
designated
getstdhandle
3.6.3.2
ceases
securi1yattributes
securityattributes
&readhandle
&writehandle
&sa
startjnfo
getstartupinfo
si.hstdoutput
std_outputjhandle
si.hstdinput
dwflags
startf
_usestdhandles
sethandleinformation
tehandle
handle_flagjnherit
child.exe
null,null
&written
hprocess
buffer_stze
std_inpuli-iandle
&read
,buffer
-child
writers
additionally
fifos
mkfifo
manipulated
contirme
til
half-duplex
transmission
permitted
intermachine
richer
full-duplex
byte-oriented
ftfo
message-oriented
createnamedpipe
connectnamedpipe
scroll
press
bar
moref
corrm1and
dos
cmmterpart
establishing
dir
readyf
queuecc
pcbf
contend
influenced
resourceallocation
mechanisnc
commlmicate
principally
mernory
rests
chamcel
commlmication
permit
unrelated
commmucation
reference
undesirable
consequences
arise
respect
complications
-ael
man
longterm
pids
stdio
pid1
,pid
,pid1
fibonacci
formally
expressed
fib
fibl
jibn
jibn-l
jibn-2
comm_and
,value
dataf
non-negative
repeat
preceding
exercisef
instancef
random
jokes
multi-line
joke
echo
echoes
client-that
isf
perfonning
deals
inputstrearn
reflected
malsequence
generatesequence_
sequence_size
max_sequence
fib_sequence
shared_data
thmugh
suspended
reverses
file-copying
filecopy
input.txt
copy.txt
ipcs
shmid_ds
shm_segsz-size
shm__nattch-number
ipc_perm
shm_perm-permission
-identifier
-memory
mode-permission
key_t
-user-specified
permissionof
bitwise
evaluates
userspecified
shm_ds
shmbuffer
ipc_stat
&shmbuffer
condition
errno
segmentid
temperatures
completed
temperature
stabilized
recalculate
formulas
temp
mytemp
centraltemp
temps
iteration
outer
msgget
msgsnd
msgrcv
msgctl
msqid
externally
facilitate
invocation
ipc_creat
instructs
omitting
msq
globally
consulted
ranges
instructor
aggregate
recommend
recommended
msgp
assuming
stat
&msgp
-sizeof
ipc_nowait
messages-or
bytes-so
attempting
transmit
reused
queue-and
received-will
unread
msgid_ds
dummyparam
&dummyparam
substituting
ipc.h
types.h
msg.h
artifact
bears
mentioning
,any
1..4
71-74
removal
-via
uniquely
parameter-its
hints
versa
wise
-for
commented
verify
argc
extraneous
relevant
easiest
ipcrm
brinchhansen
schlichting
schneider
prirnitives
bershad
gray
barrera
birrell
nelson
shrivastava
panzieri
tay
ananda
stmmstrup
harold
introduces
heavrvveighl
4.1.1
single-threaded
responding
keystrokes
spelling
grammar
sound
single-tlu
artd
process-creation
intensive
incur
web-server
vital
------.--r---10
4.1.2
responsiveness
lengthy
arranged
belong
economy
costly
economical
empirically
gauging
solarisf
thirty
scalability
multicpu
parallelism
4.1.3
1.3.2
interleaved
balance
splitting
dependency
paths
inherently
wiridows
-support
ultimately
4.2.1
many-to-one
one-to-one
unable
multiprocessors
solaris-uses
modet
4.2.2
drawback
burden
restrict
4.2.3
many-to-many
multiplexes
......._
-kernel
two-level
schedule
suffers
irlx
hp-ux
implementii
illustrative
summation
n.m
upper
bounds
enters
4.3.1
1003.lc
behavim
shareware
demonstrates
calculates
nonnegative
runner
pthread
pthread_t
tid
declares
pthread_attr_t
attr
declaration
pthread_attr
&attr
pthread_create
passirtg
execution-in
argv
pthread.h
param
a.out
atoi
,atoi
pthread_attr_init
&tid,&attr,runner,argv
pthread_join
tid,null
,sum
inti
pthread_exi
threadf
pthread_j
oin
returnedf
4.3.2
threads-in
sum-are
createthread
and-just
pthreads-a
il1.clude
eligible
rm1
creatil1.gthread
exited
4.3.3
tlu
eads
comprise
control-even
override
alternative-and
usedteclmique
runnable
winapi
sumrnation
threadid
threadhandle
&param
&threadid
threadhandle,infinite
surn
getsum
setsum
this.sum
sumvalue
this.upper
this.sumvalue
sumvalue.setsum
args.length
integer.parseint
sumobject
thrd
thrd.start
sumobject.getsum
interruptedexception
constructor
referenced
immutable-that
tforsingledbj
throw
4.4.1
duplicates
setup
many-to-manymodel
themany
to-one
greenthreads
implementedusing
many-to
inany
.example
forking
duplicating
unnecessary
4.4.2
cancellation
-c
terminating
remaining
canceled
presses
threads-each
stop
deferred
opportunity
midst
troublesome
canceling
asynchronously
checked
safely
4.4.3
synchronously
pattern
expire
user-defilced
overridden
delivering
deliver
applies
signals-such
-should
pthread_kill
emulated
apcs
apc
4.4.4
superior
nonetheless
servicing
unlimited
exhaust
tince
beh_ind
awakens
pool-if
available-and
awaits
heuristically
thread-pool
patterns
pool-thereby
memory-when
defin_ed
poolfunction
member
queueuserworkitemo
paranceters
lpthread_starlroutine
function-a
pvoid
param-the
ulong
flags-flags
queueuserworkitem
&poolfunction
lightweight
------
kamalthcead
lwp
periodic
util
4.4.5
thread-specific
transaction-processing
transaction
libraries-including
pthreads-provide
4.4.6
activations
adjusted
structure-typically
lwp-is
user-thread
schedules
lwps
file-read
inform
upcalls
upcall
triggers
informing
relinquishes
informilcg
preempt
marking
1-mblocked
4.5.1
employed
dlls
rcc
ethread-executive
kthread-kernel
tee-thread
ethread
belongs
kthread
inforn1.ation
teb
thern
user-space
identifie1
threadspecific
4.5.2
clone
task-rather
thread-when
meaning
sighand
clone_fs
clone_vm
clone_sighand
clone_files
signal-handling
howevet
nptl
start-up
growth
flows
use1
relate
ncultithreaded
prime
&tid,&attr,runner,null
rnodel
implicatiorts
userlevel
socket-based
fib0
fih
jibn-1
placing
smmnation
rewrite
akin
solaris-treat
modeling
distinct
topics-naming
muliplication
dns
www
westminstercollege
assignment
ling
resolving
inetaddress
hostaddress
inetaddress.getbyname
www.westminstercollege.edu
ipaddress
hostaddress.gethostaddress
getbyname
throws
unknownhostexception
resolve-such
eduto
localhost
responses
telnec
escape
destrninstercollege
146.86.1.17
foreign
convinced
resolved
nsclient
multiplication
matrices
rows
coh.11m1s
row
column
c.j
c,j
bn,j
3-by-2
2-by-3
m.atrix
element
c3,1
a3,1
b1.1
a3,2
b2,1
calculate
worker
main-or
parent-thread
product
statically
1,4
2,5
3,6
8,7,6
5,4,3
populated
calculating
rnalloc
workerthread
col
this.row
this.col
this.a
this.b
this.c
matrices-along
jto
tformultipledbj
ects
waitformultipleobjectso
num_threads
workers
num.ber
timeout
duration
thandles
waitformultipleobjects
enclose
cheap
thotll
cheriton
pilot
redell
accetta
tevanian
1987a
anderson
evaluating
combining
engelschall
optimal
williams
system_
marsh
govindan
draves
zabatta
compare
pinilla
gill
love
lewis
berg
butenhof
oaks
wong
holub
goetz
beveridge
wiener
cohen
woodring
threads-not
processes-that
productively
wait.tor
burst
5.i
alternating
bursts
5.1.1
success
observed
property
alternate
durations
measured
extensively
compute1
curve
exponential
hyperexponential
histogram
cpu-burst
5.1.2
necessarily
implen
ented
sirnply
unordered
conceptually
lined
chance
records
5.1.3
preemptive
nonpreemptive
cooperative
3.x
relied
platforms
incurs
preempted
inconsistent
topic
preemption
middle
chaos
ensues
com.plete
kernel-execution
supportil1g
i.j.1
guarded
reenable
5.1.4
dispatcher
latency
favor
comparing
comparison
judged
throughput
hour
turnaround
criterion
submission
periods
an1.ount
minirnize
investigators
predictable
accurate
elaborate
5.3.1
first-come
first-served
fcfs
tail
head
arrive
ani
served
gantt
chart
participating
ncilliseconds
reduction
convoy
big
shorter
regular
5.3.2
shortest-job-first
sjf
associates
tie
shortest-next-cpu-burst
total
m.ost
provably
knowing
submits
motivated
estimate
accurately
time-limit-exceeded
resubmission
approximate
predict
approximation
pick
shortest
predicted
lengths
formula
t11
past
relative
weight
prediction
transient
irrelevant
weighted
lmderstand
atn
atn-1
atn-j
to
successive
predecessor
arrived
time
shortest-remaining-time-first
arrival
5-3
5.3.3
equal-priority
inverse
priorities
4,095
rity
nceasurable
quantity
ratio
funds
sponsoring
politicat
rnajor
indefinite
lowpriority
steady
higher-priority
low-priority
a.m
sunday
lose
unfinished
rumor
shut
blockage
aging
techniqtje
gradually
hours
priority-127
age
priority-0
5.3.4
round-robin
quantum
fronc
dispatches
voluntarily
proceed
expires
millisconds
exceeds
p11t
chunks
cdc
quanta
contextswitch
approximately
microseconds
r.r
-lr
.p1
c1l
time-quantum
drops
degenerates
thumb
5.3.5
multilevel
foreground
response-time
-------i--n_te_r
ac_t_iv_e_e
.d_it
in_g--p
r-.o-c_
e---ss
e-s
------l
---------b_a_tc_h_p_r_o_ce_s_s_e_s
______
-------s_tu_d_e_n_t_p_ro_c_e_s_s_es_
_____
_jl
fixed-priority
lower-priority
possibility
time-slice
foreground-background
5.3.6
inflexible
numbered
arriving
filcish
sink
upgrade
higherpriority
demote
lowerpriority
match
distinguishing
unaware
5.4.1
process-contention
system-contention
scs
usilcg
priority-the
slicing
5.4.2
postx
pthread_scope_process
pthread_scope_system
maintained
bind
getting-and
setting-the
pthread_attr_setscope
pthread_attr_getscope
contaiils
non-zero
pthread_scoplprocess
pthreadoh
stdiooh
inquire
&scope
valueo
&tid
,&attr,runner,null
identical-homogeneous-in
homogeneous
5.5.1
processor-the
reducing
self-scheduling
5.5.2
affinity
populate
invalidated
repopulated
invalidating
repopulating
rumung
affinity-that
rumting
processor-but
guaranteeing
so-we
soft
migrate
-such
-also
limiting
main-memory
delay
memory-placement
cleanly
solid
dotted
aimed
optimizing
5.5.3
balancing
workload
workloads
evenly
extracts
rmmable
push
-if
finds
imbalance-evenly
distributes
pushing
less-busy
pulls
load-balancing
5.6.3
ule
techniql1es
loadbalancing
counteracts
pulling
invalidates
non-idle
imbalance
threshold
5.5.4
complicate
discovered
miss
stall
remedy
stalls
dual-threaded
perspective
thread1
thread0
multithread
__u.,u
chccu
coarse-grained
long-latency
pipeline
flushed
filling
fine-grained
finer
granularity-typically
boundary
logic
chooses
adopt
roundrobin
itanium
hvo
hardwaremanaged
urgency
thread-switching
5.5.5
single-cpu
summarize
achine
eacb
fine-tuned
impacted
allot
mercy
100-millisecond
catastrophic
time-of-day
clocks
timers
lmdo
scheduling-algorithm
efforts
tlueads
5.6.1
priority-based
sys
fss
alters
assigns
slices
applications-such
managers-a
brevity
handful
class-dependent
expired
lowered
sleeping
boosted
guaranteed
reserved
fair-share
entitlement
class-specific
n.ms
map
160-169
5.6.2
highest-priority
preferential
32-level
traverses
realtime_priority
_class
higf-lpriority
abovknormalpriority
normalpriority
normal...priority
idle...priority
realtime...priority
time_critical
above_normal
above_normal...priority_class
nunceric
realtime...priority_class-24
higrlpriority
class-13
above_normalpriority_class-10
_class-8
_normalpriority
_class-6
idle_priority
_class-4
normalpriority_class
quantun1
variable-priority
lowering
consumption
compute-bound
variablepriority
boosts
moderate
permitting
spare
distinguishes
factor-typically
scale
grows
overhauled
time-known
-regardless
fairness
numerically
tim.e-slice
exhausted
nmqueue
runqueue
arrays
posix.1b
o-o
0--0--0
o--o-o
minus
interactivity
subtracted
deterncined
adjustments
closer
favors
recalculated
thxoughput
maximizing
constraint
linearly
evaluate
5.7.1
deterministic
analytic
p11
separately
rninimum
5.7.2
day
approximated
estimated
mathematical
probability
arrival-time
rates
queueing-network
excluding
equation
seconds
moment
mathematics
mathematically
tractable
-but
unrealistic-ways
assumptions
approximations
accuracy
questionable
5.7.3
simulations
modifies
gathered
random-number
arrivals
departures
poisson
measurements
distribution-driven
inaccurate
coding
5.7.4
conlpletely
expense
incurred
reaction
noninteractive
1-second
gave
meaningless
altered
managers
high-end
systemsparticularly
unix-allow
fine-tune
dispadmin
downfall
performance-tuning
shortestjob
predicting
relinquished
preem.pted
excessive
processes-for
imitating
implencent
tentls
context-switching
long-running
discriminate
assigning
starve
realtimeyriority
normalyriority_class
highyriority
above..normal
draw
charts
implies
ti1r1e
enforces
numbe1
recalculates
raise
pairs
conflict
imply
answering
supposed
k11ow
durirtg
future-knowledge
corbato
schrage
kleinrock
philbin
mcnairy
bhatia
kongetira
fisher
hall
lowney
henry
woodside
kay
uder
bach
neville-neil
roberson
siddha
consistency
pointed
deficiency
register1
register2
accumulator
restored
interleaving
reversed
outcome
guard
race
threads-which
data-are
cdticall
enclosed
boxes
carmot
postponed
kernel-mode
yields
responsive
minimized
software-based
machine-language
complexities
bomcded
presenting
denote
equals
boolean
explanation
asserting
assignments
eventual
prove
bounded-waiting
met
-say
-must
statencent
persist
tool-a
softwarebased
premise
unexpected
feasible
disabling
testandset
&lock
mutual-exclusion
delays
unin.terruptible
characteristic
atomically
declaring
operates
satisfies
&key
mutualexclusion
scans
cyclic
designates
hardware-based
overcmrte
semaphore
dutch
proberen
verhogen
no-op
s
indivisibly
6.5.2
6.5.1
counting
unrestricted
lmown
mutex
mljltiple
decrementing
count
incrementing
letting
synch
inserting
thatit
continuously
continual
looping
ncany
wastes
spins
spinlocks
spin
engaging
restarted
wakeup
fron
suspends
classical
decrement
rernove
inhibiting
inhibited
reenabled
regain
disabled
diminish
techniques-such
spinlocks-to
admit
eliminated
opera
coded
sbould
occupied
rarely
casesf
inefficient
6.5.3
cam1ot
deadlocked
acquisition
lifo
last-in
6.5.4
process-or
preempting
mars
pathfinder
inconvenience
systems-see
cascade
pathfinde1
nasa
landed
sojourner
rove1
conduct
shortly
began
reinitialized
mission
high-priority
bcdist
forced
medium-priority
bc_sched
suffering
team
mbj
authoritative_account.html
priority-process
m-has
relinquish
insufficient
2tic
x,u
revert
exan1.ple
priority-inheritance
h-not
m-would
concurrency-control
nextp
proposed
6.6.1
bounded-buffer
committing
comct
interpret
nextc
6.6.2
readers-writers
adverse
effects
ensue
readerswriters
variants
starvation-free
wrt
readcount
generalized
acquiring
reader-writer
wishing
readerwriter
compensates
6.6.3
dining-philosophers
philosophers
lives
thinking
eating
surrounded
chairs
dining
philosopher
bowl
rice
laid
chopsticks
colleagues
hungry
closest
right
neighbors
chopstick
neighbor
htmgry
eats
scientists
dislike
deadlock-free
mam1er
grab
rejected
grabs
delayed
remedies
eat
odd
satisfactory
death
timing
happened
reasonable-off
review
behaved
honest
uncooperative
interchanges
violating
reproducible
replaces
omits
violated
sencaphores
constructs
construct-the
6.7.1
adt
encapsulates
programmer-defined
bodies
procedures
syntax
rrwnitor
fa1
tailor-made
schematic
signaling
adopting
signal-and-continue
resumed
adopted
pascal
imncediately
mesa
languages-such
erlang-provide
__
6.7.2
imposes
enum
declare
sel
diningphilosophers
pickup
nlay
suspension
putdown
.signal
initialization_code
dining-philosopher
diningphilosophers.pickup
diningphilosophers.putdown
6.7.3
nwnitor
ltlonitor
n1onitor
sernaphore
suspend
next_count
body
ensured
x_sem
x_count
applicable
hoare
6.7.4
process-resumption
resourceallocator
x.wait
longest
expression
evaluated
pdos
plans
time-allocation
r.acquire
gaining
ntight
assist
resourceaccess
monitor-scheduling
correctness
gateway
time-dependent
defeated
inspection
access-control
synchronizing
monitor-like
mechanisn1
owning
safemethod
simpleclass
6.8.1
adaptive
mutexes
sernaphores
turnstiles
mlltexes
spinlock
rwming
adaptive-mutex
spin-waiting
exceedingly
sleeps
waking
wasting
serialize
n1.utex
turnstile
associating
priorityinheritance
kernel-locking
adhere
thread-locking
refined
implem.entation
6.8.2
masks
tluead
nonsignaled
,72led
transitions
frmn
acquires
-or
nlore
threads-from
6.8.3
-even
disables
summarized
acquirespin
calls-preempldisable
preempt_
preemptible
irl
thread-info
preemplcount
preempt_count
assuncing
preempldisable
spinlocks-along
preemption-are
6.8.4
code-that
sem
uninterruptible
entirety
debited
credited
credit
debit
retrieval
upsurge
database-systems
manipulators
hoc
6.9.2
6.9.4
6.9.1
preservation
commit
signifies
emergence
fordeveloping
thread-safe
committed
aborted
rolled
memoi
developer-isrespon.sible
ofthreads
anapplicationgrows
stm
nam
suggests
ments
exclusivelyin
nospecial
inserted
lowlevellockingis
htm
hierarchies
coherency
instmmentation
cachecoherencyprotocolsbe
existed
prompted
amolmt
ofresearch
academics
ended
determ.ine
resilience
survive
merrwry
survives
m.edia
inform.ation
orders
becm1se
electromechanical
motion
grain
theoretically
absolutes
replicate
log-based
preceded
commits
reconstructing
price
undo
restores
redo
idempotent
aborts
consulting
redone
lmdone
classification
undone
corrnni
6.9.3
checkpoints
determinations
drawbacks
redoing
idempotency
write-ahead
checkpoint
presence
systenl
streamline
observation
refine
backward
applied
ll
nc
tic
serially
arbih
ary
restrictive
overlap
serializability
6.9.4.1
chronological
bottom
appearing
colunm
serial
cj,sefi
nflic
cing
consecutive
nonserial
serializable
nonconflicting
swaps
transformed
izable
6.9.4.2
governs
shared-mode
denoted
exclusive-mode
m.ode
unlock
moreove1
growing
phase
shrinking
two-phase
conflict-serializable
6.9.4.3
timestamp-based
advance
w-timestamp
largest
r-timestamp
obsolete
capability
deadlocl
obstacle
overlaps
delaying
aborting
sohjtion
dekker
eisenberg
mcguire
pstate
want_in
in_cs
immaterial
n-1
requirenlents
hclc
decrease_count
leads
resource-manager
mil1.imized
coru1.ections
lil1.ux
exhibit
hint
kessels
-once
finished-will
denied
holder
max_resources
available_resources
resourcesf
increase_count
semaphoref
fun.ction
cigarette-smokers
smoker
agent
rolls
cigarette
smokes
roll
smoke
cigarettef
ingredients
tobaccof
paperf
matches
materials
ij.l.gredient
repeats
smokers
slim
ordered
-back
b-ut
rolled-back
propose
6.27
altogether
recover
portions
strict
banking
deposit
withdraw
deposited
withdrawn
bank
husband
sleeping-barber
barbershop
barber
roorn
customer
shop
asleep
wakes
semaphore-based
slots
insertion
consumer-running
threads-will
fixed-size
buffer_i
buffer.h
buffer_item
insert_i
remove_i
skeleton
outlining
insert_item
insert
remove_item
outlined
f-lmction
awakening
nuncber
,argv
rand
rand..max
pararn
report
,item
&item
pthread_mutex_t
pthread_mutex_init
&mutex,null
pthread_mutex_lock
&mutex
pthread_mutex_unlock
pthread_mutex_ini
callil1.g
ftmctions
semaphores-named
unnamed
illush
ates
semaphore.h
sem_t
sem_init
&sem
sem_ini
sem_wait
sem_post
aaa5
sem_wai
,respectively
createmutex
disallowing
alse
leas
emu
releasemutex
createsemaphore
indefinitely-as
infinite-until
releasesemaphore
1965a
two-process
problem-was
mathematician
1965b
knuth
refinement
debruijn
succeeded
bakery
lamport
burns
hardware-solution
raynal
patil
parnas
flaws
kosaraju
lipton
process-coordination
paradigms
boundedbuffer
courtois
critical-region
signalil1.g
lampson
ben-ari
lockil1.g
mellor-crummey
herlihy
kopetz
reisinger
culler
goodman
barnes
moss
mtroduced
formulated
eswaran
timestampbased
reed
explail1.ed
bernstem
adl-tabatabai
compete
drawn
kansas
legislature
20th
trains
crossing
deadlock-prevention
withirt
long-lived
avoiding
partitioned
cares
prints
ninth
basement
exceed
explained
kernelmanaged
pay
candidates
characterize
7.2.1
nonsharable
pthread....mutex_ini
unlocked
pthread....mutex_lock
pthread....mutex_unlock
pthread....mutex_t
first....mutex
second_nmtex
&first....mutex
&second....mutex
threads-thread_one
thread_two--are
thread_one
thread_
do_work_one
do_work_two
&first_mutex
&second_mutex
pthread_mutex
_unlock
pthread_exit
thread_two
first_mutex
second_mutex
second__mutex
__mutex
aacquites
second_
attemptsto
cmrently
pn-1
p,v
circular-wait
hold-and-wait
7.2.2
resource-allocation
graph
precisely
vertices
edges
vis
rml
edge
pictorially
circle
rectangle
dot
designate
dots
fulfilled
instantaneously
pl
rlf
p2
r3f
rl
p2f
r2
r3
breaking
speaking
pretend
mention
argued
spectrum
deadlock-avoidance
constraining
deadlockavoidance
recognizing
undetected
manually
viable
year
frozen
7.4.1
sharable
denying
intrinsically
7.4.2
precede
printe1
7.4.3
recovers
.4.4
fourth
enumeration
precedes
hmction
natural
iilstances
proof
contradiction
modulo
indexes
r11
transitivity
warnings
lock-order
witness
wih1ess
warning
imposing
lock1
lock2
getlock
trans
transposing
checkingaccount
savingsaccount
restraining
restraints
priori
circularwait
7.5.1
unsafe
spaces
twelve
safety
mistake
granting
7.5.2
resource-allocation-graph
claim
dashed
reconverted
claimed
relax
formation
cycle-detection
7.5.3
banker
cash
nun1.ber
encode
simplify
andy
vectors
1,7,3,2
0,3,2,1
7.5.3.1
7.5.3.2
resource-request
modifyil1.g
available
7.5.3.3
snapshot
abc
plt
request1
1,0,2
available-that
3,3,2
grant
3,3,0
0,2,0
detection-and-recovery
costs
losses
recovering
7.6.1
deadlockdetection
wait-for
collapsing
iil
searches
7.6.2
time-varying
ann
relation
investigates
fori
tme
optimistic
attitude
deadlock-detection
7.6.3
detection-algorithm
reality
jointly
identifiable
intervals-for
cripples
drop
alternatives
7.7.1
reclaims
partial
recomputed
algorithnc
rnust
determination
economic
precise
7.7.2
successively
1-m
victim
termil
ation
rollback
contil
missing
picked
rollbacks
factor
maximunl
detennine
victims
single-lane
bridge
connects
villages
north
tunbridge
south
farmers
neighboring
town
northbound
southbound
farmer
stubborn
months
bought
introducing
rnore
dimensionality
multiple-resource-type
applying
sil1.gle-resource-type
individually
requestmg
4,2,2
2,2,1
1,0,1
0,0,1
2,0,0
1,0,0
1,2,1
higherorder
sixth
containment
7.4.4
overheads
abcd
0,4,2,0
5,000
month
rerun
half-done
installing
eliminating
rules
entitled
contributors
holt
person
formalize
allocation-graph
hyman
levine
havender
devised
resource-ordering
habermaml
coffman
rodeheffer
schroeder
baldwin
bare-machine
hozu
covering
pertinent
symbolic
linking
8.1.1
direct-access
decode
tick
intolerable
soa
lj.o
1go
differential
legally
inclusive
fatal
accidentally
deliberately
monitor-addressing
8.1.2
steps-some
optional-before
bein.g
lin.kage
classically
krww
extend
recompile
.com-format
8.1.3
11se
devoted
bindings
multistep
unit-that
memory-is
compile-time
load-time
address-binding
execution-time
addressbinding
in_
relocation
mmu
generalization
base-register
relocated
80x86
addresses-all
memory-mapping
ranger
tor
valuer
8.1.4
memory-space
dynancic
menwry
8.1.5
libraryroutine
memory-resident
incurring
fixes
relinked
incompatible
minor
8.4.4
meantime
reschedule
dictated
reloads
50mb
100-mb
resident
3gb
this-say
informed
postpone
a.6
pcs-which
lacked
methods-ran
swapped-out
menlory
explains
8.3.1
contaitls
relocation-register
8.3.2
divide
supportfor
mft
fixed-partition
mvt
holes
fill
untit
hole
scattered
split
adjacent
merged
recombined
first-fit
leftover
best-fit
decreasing
8.3.3
fragmentation
fragmented
piece-the
reveals
one-third
unusable
multiple-partition
18,464
18,462
shuffle
nlemory
compaction
external-fragmentation
noncontiguous
complementary
permits
solves
fitting
backin.g
suffered
fragments
fmmd
foooo
f1111
1---------1
8.4.1
harnes
san1.e
offset
wordst
high-order
low-order
displacement
minuscule
noticed
32-byte
4-byte
coincide
2,048
72,766
1,086
page-table
grown
on-the-fly
injo
reconciled
address-translation
memory-which
free-frame
new-process
buffe1
translate
8.4.2
told
paging-address
nlust
pdp-11
sncall
ptbr
resort
fastlookup
bc.1her
tlb
tag
keys
numbering
unmapped
lru
tlbs
asid
address-space
asids
erased
hit
percentage
80-percent
mapped-memory
40-percent
slowdown
memory-access
98-percent
8.4.3
paged
memory-protection
violation
execute-only
-invalid
disallow
14-bit
valid-invalid
10,468
2,287
---------
flee
2-kb
wasteful
8,000
three-page
editor-each
-being
reentrant
non-self-modifying
wilt
kb-a
savings
-compilers
corrununication
8.5.1
hierarchical
excessively
4mb
contiguously
vax
partitioning
one-level
8mb
iml.er
conveniently
three-level
standard-size
daunting
2nd
sti11234
four-level
second-level
paging-a
prohibitive
accessesto
8.5.2
collisions
searched
matching
favorable
mappings
physical-page
8.5.3
inverted
slot
validity
powerpc
i11verted
triple
process-id
page-number
pagenumber
found-say
i-then
lookups
alleviate
one-or
few-page-table
reads-one
hash-table
offering
faults
unavoidable
differentiation
8.6.1
linear
math
n1.ain
sqrt
symbol
begim1.ing
seventh
invisible
segn
lent
tuple
segment-number
assign.ed
8.6.2
two-dimensional
one-dimensional
twodimensional
user-defined
effected
startilcg
base-limit
segment1
14001---1
1-----1
--1
f--------1
tooo
8.7.1
logical-address
ldt
gdt
selector
16-bit
microprogram
lets
8.7.2
4-kb
schence
outernlost
cr3
innermost
0-11
which-if
setindicates
4-mb
registe
8.7.3
segmentationlinux
rely
minimally
task-state
tss
2-bit
limlx
recognizes
plausible
threelevel
highlights
lglobal
__,.c__
__l
-just
determinant
legality
address-operations
degraded
degradation
packing
waste
single-partition
shifting
-only
translatil
manufacturer
sharil
segmented
pagil
preferable
convert
fetch
baselimit
combine
bilcary
bindmg
memory-binding
memory-load
worst-fit
512mb
single-level
1-kb
offsets
decimal
significance
0,430
1,10
2,500
3,400
4,112
decincal
50-percent
kilburn
howarth
dennis
organick
daley
article
chang
mergen
jacob
mudge
mmus
talluri
studied
wahbe
1993a
chase
thorn
dougan
tedmiques
fang
intel80386
architectures-such
pentiunl
ultrasparcare
1998a
tecrucique
carelessly
page-replacement
working-set
meeting
unfortunate
unusual
arrays,lists
3,000
symbols
budget
confer
simplifying
perceived
address-say
0-and
upward
downward
blank
sparse
beneficial
dynam.ically
considers
speeding
these-and
other-benefits
problent
demand-paged
demanded
demand-paging
lazy
swapper
technically
manipulates
pager
9.2.1
guesses
n1.emory
usuat
marked
dod
jtb
translating
non-memory-resident
faulting
unacceptable
9.6.1
fetching
operand
worst-case
three-address
decoding
repetition
mvc
ncove
overlapping
straddles
microcode
computes
occm
transparent
non-demand-paging
errm
9.2.2
zero-that
ttp
nrr
deterncine
seek
optional
page-fault
faced
page-switch
device-service
device-queueing
memoryaccess
8,000,000
7,999,800
1,000
399,990
dramatically
demandpaging
bypass
minimizes
thatthe
worked
nl.apping
process1
process2
nwdified
arked
copyon
zem-fhl-on-den
1and
zero-fill-on-demand
zeroed-out
erasing
call-vfork
vfork
ork
caution
strictly
forty
suddenly
sixty
strain
pc
-------
over-allocation
system-paging
9.4.1
faulted
doubles
reduces
programnlers
twenty
replacing
tceme
h
slight
yield
strings
artificially
facts
0100,0432,0101,0612,0102,0103,0104,0101,0611,0102,0103
0104,0101,0610,0102,0103,0104,0101,0609,0102,0105
..0
strillg
faultsone
eleven
9.4.2
oldest
fifteen
bad
belady
anomaly
9.4.3
min
moj
pagefault
irt
cpu-schedulin.g
optimat
9.4.4
strangely
reverse
sis
time-of-use
ti1ne-of-use
aintained
conceivable
tolerate
9.4.5
lru-approximation
pagereplacement
cleared
9.4.5.1
additional-reference-bits
8-bit
shifts
discarding
shift
9.4.5.2
second-chance
chances
poi11ter
clears
9.4.5.3
-best
hut
modified-not
clean-probably
-probably
nonempty
scan
9.4.6
counting-based
lfu
actively
counts
exponentially
decaying
mfu
argument
approxinlate
9.4.7
page-buffering
expansion
mistakenly
sirnple
conjunction
augmentation
9.4.8
worse
warehouses
massive
preserving
newer
raw
bypasses
filesystem
prefetching
in-memory
94th
9.5.1
ilcstruction
memory-reference
straddle
m.oved
15-bit
1-bit
touched
16levels
irtdirection
9.5.2
recognize
ncinimum
departed
detriment
9.5.3
classify
.no
-cu
circuntstances
hinder
equal-or
busses
collectively
exception
motherboard
rnade
hits
decreased
lgroup
gathers
lgroups
nearby
maximized
falls
swap-in
swap-out
spending
pagin.g
empties
plunges
tremendously
m.emory-access
plotted
ilccreases
sharply
thrash
thtashing
9.6.2
locality
localities
unstated
patterned
useless
paramete1
vrindovv
jjl
jlli111
encompass
,2,5,6,7
extrem.e
wss
dis
reallocated
optimizes
fixed-interval
assum.e
reference-bit
15,000
uncertainty
9.6.3
prepaging
9.9.1
clumsy
thrashilcg
,read
faultrates
directrelationship
pver
processis
11.ot
tbe
peaks
valleys
peak
rises
span
oftime
thenext
9.7.1
page-sized
imm.ediate
ren
loved
memory-map
mmap
memory-maps
memory-the
j---r
-rl..-r
-r
.....c.c
..----r
.l
coordinated
memorymapped
9.7.2
shared-menwry
m.emory
consum.er
mapviewdffile
hfile
hmapfile
lpmapaddress
temp.txt
genericjread
generic_write
open_always
file_attribute_normal
template
pagejreadwrite
sharedobject
filejmap_all_access
unmapviewoffile
sharedobj
subsection
openfilemapping
file_map_all_access
fm1ction
ii1stance
existii1g
ii1
thatwas
9.7.3
devices1
port1
polling
watch
poll
rnode
however1
free-memory
result1
conservatively
memory-without
interface-and
buddy
slab
9.8.1
power-of-2
allocator
sized
rounded
16-kb
buddies-which
-each
buddies
64-kb
buddiesbland
br
next-highest
32-kb
21-kb
teclmique
coalescing
coalesce
coalesced
128-kb
original256-kb
rounding
33-kb
9.8.2
nwre
slabs
instantiations
respective
slab-allocation
objects-which
free-are
12-kb
continguous
3-kb
7-kb
fragn
entation
allocating-and
releasing-memory
tin1.e
systerns-notably
solaris-prepage
restarting
prepaged
wins
9.9.2
invariably
powers
4,096
4,194,304
8,192
independence
12.1.1
dwarf
attributable
doubling
sam.e
tall
isolate
102,400
sector
historical
9.9.3
translations
cheaply
metric
multiplied
memory-intensive
approacl1
size-say
kb-we
quadruple
8-kb
64-entry
256mb
majority
databases-to
-not
hardware-to
softwaremanaged
alpha
software-managed
9.9.4
virtual-to-physical
per-process
negate
n1.anager
page-lookup
9.9.5
awareness
contrived
informative
128-by-128
128j
127j
zeros
16,384
scatter
sigicificant
packed
bin-packing
pack
interpage
randomize
diminishing
9.9.6
interlock
emory
unacceptably
apparently
effort
brought-in
overuse
hurt
trusting
disregard
9.10.1
faultil1.g
rnaximum
tactic
trimming
free-page-frame
clearing
invalidatil
look-aside
9.10.2
imperative
parameter-zotsfree-that
lotsfree
hands
scanning
appending
reclaimed
scam
scanrate
slowscan
fastscan
progresses
fasts
withfastscan
determil
handspread
cll
minfree
desfree
scanner
investigating
scam-ate
intention
30-second
processes-even
scannerare
skipped
page-scanning
regularfiles
11.6.2
worrying
consults
and-in
least-the
frame-allocation
suggesting
schedulil
mappil1g
req1.1ire
allocators
reqmnng
prep
1,024-kb
followilcg
12-bit
256-byte
hexadecimal
dash
9ef
minimization
distributing
iii
time-measured
utilizations
bigger
n1.enl0ry
page-fetch
microsecond
i.e
ilccurred
nonresident
kernellevel
array-initialization
candidate
free-france
degenerate
segment-replacement
cam
fault-that
nonsuspended
regularly
discard
pagereference
page-reference
catalan
c11
treeenumeration
ell
manchester
muse
mattson
demonstrated
prieve
fabry
enl
lanced
carr
denning
wulf
bssoo
wilson
algoritluns
jolmstone
memory-fragmentation
knowlton
1965l
norman
purdom
stigler
bonwick
adams
memory-fitting
stephenson
bays
brent
memory-allocation
ganapathy
schimmel
navarro
ortiz
1998b
companion
randomly
organizes
touch
persistent
allotment
file-source
payroll
graphic
recordings
subroutines
in.to
nnderstandable
linker
10.1.1
example.c
uppercase
lowercase
edit
humanreadable
non-human-readable
megabytes
piecemeal
10.1.2
truncate
renaming
repositioning
current-file-position
repositioned
kn.own
erase
truncating
forcing
recreate
-except
length-but
open-file
accessmode
information-create
append-only
perprocess
process-independent
dates
readwrite
on-disk
file-open
reuse
firstobtaini
i..lechannel
fbr
thefile
loc
filechannel
acquir
filelock
l.ong
ooleqn
gi1iningand
positions
settingshared
isfb
exclusively
tice
operati
illusttates
thefilefile
of.the
advisory
file-locking
n1.andatory
.log
process-for
editor-the
10.1.3
system-indeed
system-we
binary-object
parts-a
resume.doc
server.java
readerthread
.bat
ascii
.asm
isnl
tji
,u
to-run
machineor
obj
pas
asm
bat
doc
rdprocessor
wp,tex
rtf
wordcprocessor
lib
dll
o.troutines
.programmers
pdf
jpg
arc
zip
.tar
.one
file,sometimes
compressed
archiving
mpeg
mov
.doc
edited
enforced
crude
file-executable
postscript
magic
solely
file-nameextension
depended
10.1.4
expectations
conform
understood
system-supported
cumbersome
carriage
feed
encrypted
misuse
file-type
abandon
encryption
un1x
interpretation
structure-that
file-so
labels
buttons
re-label
data-the
user-changeable
inconvenient
bloat
10.1.5
locating
paddng
begi1ming
packs
unpacks
blockssay
block-as
conversion
1,949
rewind
sequential-access
10.2.1
operation-read
next-reads
operation-write
next-appends
n-perhaps
random-access
10.2.2
fixedlength
databases
query
airline-reservation
flight
seats
reservation
il1formation
in-ncemory
begirm.ing
nina
simulating
10.2.3
retail-price
universal
upcs
prices
10-digit
upc
6-digit
16-byte
120,000
2,000
digits
arthur
asher
th,jol
irdex
isam
memory-based
subdivided
finer-grained
quarters
quarter
unformatted
1-7
type-for
10.3.1
sliced
dozen
fig1-1re
tmpfs-a
objfs-a
dfs-a
contract
ufs
devfs
dev
ctfs
mntfs
tmpfs
objfs
lofs
lofs-a
prods-a
zfs-general-purpose
segregate
10.3.2
copyin.g
magn.etic
10.3.3
unique-name
prog2
assign2
complicating
11-character
10.3.4
ufds
w11en
mfd
ufd
ascertain
teduciques
name-collision
isolates
isolation
pennitted
lmiquely
descendants
leaf
directory-entry
userb
letter
colon
fest
login.com
sst.jdeck
sst
jdeck
subdirectory
pbg
-loaders
on-are
presently
10.3.5
tree-structured
subdirectories
ititi
redefine
desires
defi11es
ernpty
tree-struch1red
automates
double-dick
creatorattribute
clicked-on
10.3.6
acyclic-graph
prohibits
acyclic
cycles-allows
exemplified
ignores
traversing
trees
indistinguishable
aliasing
system-to
accumulate
storage-this
deletes
dangling
now-nonexistent
orig
llcal
flavors
file-reference
trouble
-we
increments
decrements
nonsymbolic
inode
a.7.2
prohibiting
10.3.7
preserves
poorly
continually
self-referencing
garbage-collection
collects
traversal
disk-based
lir1k
graphs
mounted
mount
motmting
verifies
verifying
n1.ounted
triangles
subtrees
unmounted
bill
repeatedly
encounters
mounts
folder
labeled
drive-letter
11.2.2
a.7.5
collaborate
user-oriented
spite
occurf
10.5.1
accommodates
preeminent
mediate
definable
denies
10.5.2
reversion
authenticated
tighter
integration
10.5.2.1
mom1.t
seeking
imitated
spoofing
exchanges
intercepted
unsecure
basing
trust
credentials
10.5.2.2
unified
host-name-to-network-address
scalable
16.5.1
distributed-information
yellow
renamed
centralizes
passwords
unencrypted
nis
m.u.st
ldap
conceivably
system-administration
10.5.2.3
corruption
disk-management
disk-controller
cable
host-adapter
system-administrator
repair
interruptions
resiliency
closing
shutdown
reachable
plemented
remote-file-system
losing
data-and
patience
seamlessly
rnounted
exported
carries
resilient
forged
requisite
10.5.3
observable
process-synchronization
latencies
andrew
sketch
prominent
10.5.3.1
advancing
interleaves
origin
10.5.3.2
sessions
10.5.3.3
immutable-shared-files
immutable
disciplined
computer-operator
damaged
surges
dirt
extremes
vandalism
desk
drawer
cabinet
10.6.1
limitin.g
finance
personnel
treatment
10.6.2
acju
tedious
unrewarding
condense
universe
constitute
accesscontrol
sara
hired
dawn
jill
group-say
textwith
accordance
visitor
nith
access-control-list
tightly
superuser
14.5.2
-rwx
acl
appends
f1l
pbg-la.ptof
gue
contml
h-1odi
,.
a.d
r.ead
spec
ia.l
a.llo
specia.l
orfor
.a.dva.nced
-rw-r--r
staff
file1
setfacl
getfacl
acls
file-permission
ntfs
lo.tex
precedence
specificity
10.6.3
fields-owner
universe-each
rwx
faa
protecti.on
s11bdirectory
-rw-rw-r
sep
30l
intro.ps
drwx
jul
drwxrwxr-x
jul8
drwxrwx
aug
feb
program.c
-rwxr-xr-x
-x--x
drwxrwxrwx
impractical
all-or-none
minidisk-one
nrultiwrite
systencs-such
x-provide
seamless
ncanage
information-storage
access-read
merits
4,990
howwould
ncandatory
discretion
knew
exploit
cross
grosshans
golden
microcomputer
rfc3505
docs
app
mockapetris
eastlake
x.509
x.soo
yeong
ongoing
interfaces-in
plan
lucent
surrounding
free-block
trade-offs
heads
rotate
sectors
translator
lowlevel
hardware-specific
infrastructure
cylilcder
file-organization
anager
optimum
unallocated
fileorganization
file-control
flle-corttml
duplication
cd-roms
agreed
removable-media
diskbased
fee
ffs
fat
fat32
floppy-disk
ext2
ext3
coogle
fuse
11.2.1
b,jsck
free-fcb
fcb
per-file
relational
in.formation
dismount
directory-structure
fcbs
file-one
includii
entities
structural
disk-block
---..,...
-t-ilej
inodes
overlooked
cooked
mirrored
miniature
corrected
windows-based
superblock
11.2.3
m.akes
navigate
suboptimal
modularize
schematically
vfs
file-system-generic
coexist
file-representation
designator
network-wide
uniqueness
vnode
activates
file-system-specific
vnodes
dentry
f1.mction
abbreviated
-open
ssize_t
-read
-write
-memory-map
ile_operat
ions
directory-allocation
directory-management
11.3.1
all-blank
-unused
reread
b-h
sort
11.3.2
collisions-situations
dependence
linear-probing
65th
enlarge
table-say
narnes
reorganize
hash-function
chained-overflow
stepping
colliding
rdos
nova
11.4.1
accessil1.g
cylil1.der
cylinder
operatil1.g
occupies
remembers
contiguous-allocation
fragncented
compacting
weekly
defragmentation
detennination
sides
overestimate
preallocation
proves
extent
fragm.entation
extents
veritas
11.4.2
_20_
23_0-4
2402sc.51
poileter
nil
end-of-list
signify
begirueing
rnetil
linked-allocation
512-byte
multiples
logical-to-physical
free-list
disk-access
welt
picking
disk-space
0-valued
file-allocation
11.4.3
size-declaration
bringil1.g
blo
1jz
1lz
index-block
manage1
jeep
non-nil
raises
first-level
four-byte
1,048,576
4gb
terabytes
indexed-allocation
11.4.4
data-block
12-mips
sparcstation1
disk-reading
read-ahead
free-behind
disparity
unreasonable
movements
blocks-those
11.5.1
bit-manipulation
motorola
bit-vector
non-0
scanned
calculation
0-value
driving
occasionally
1.3-gb
1-tb
escalate
1-pb
32-gb
bitmap
11.5.2
11.5.3
grouping
linked-list
11.5.4
tracking
b-tree
11.5.5
scales
conside1
freespace
1gb
managem.ent
chucks
manageable
metaslabs
metaslab
log-structured
allocatil
freemg
countil
balanced-tree
replays
condenses
sil
gle
transaction-oriented
sortmg
block-allocation
directorymanagement
11.6.1
preallocated
preallocating
spreading
reconsider
clustermg
aids
file-seek
file-transfer
weigh
free-space-management
10-mb
32-mb
32mb
100mb
inconvenienced
128-bit
atomic-level
trillion
kilograms
recompiling
artificial
deallocate
on-board
tile
file-system-oriented
cachii
xp-use
opening
caches-the
inconsistencies
corrupt
voiding
page-caching
choosil1.g
2.5.1
distmction
allocatmg
processesrather
cache-when
optionally
mmimize
buffered
synchxonously
retrieving
ancount
elincinate
rotation
intuition
compounding
11.7.1
confirm
systenl
flux
chkdsk
windows-compares
dictate
reconstructed
recreated
11.7.2
fin.d
origil1.ally
-.ilc
.ll
consistency-checking
irreparable
tells
fundamentally
replayed
incomplete
overwriting
spindle
crashed
elimil
ating
loggil
metadata-oriented
11.7.3
appliance
overwrite
checke1
ovative
overwrites
check-summing
assures
12.7.6
11.7.4
incremental
corrupted
permanent
destroys
reuses
times-if
commonplace
well-implemented
onc
svr4
udp
interconnecting
intertwined
deployed
11.8.1
machine-say
ml-a
subtree
descending
transparently
dirl
usr
prefix
dir1
access-rights
accreditation
diskless
roots
dir2
honce
encourages
implementation-independent
interfaced
remote-file-access
11.8.2
forwarded
exports
etc
export
accredited
conforms
administrative
purposes-for
notifying
preconfiguration
unmount
11.8.3
omission
intentional
parallels
open-files
robust
statelessness
implication
stateless-server
synchrony
flushes
intact
consequent
battery-backed-up
ackiwwledges
intermixed
1,500
advised
reinjected
retraced
11.8.4
path-name
parsing
perform.ing
n10unt
crossed
path-name-traversal
itluch
whicb
directory-name-lookup
11.8.5
adheres
remote-service
sake
file-attribute
inode-infonnation
file-blocks
revalidate
delayed-write
confirms
retained
sen
antics
.ln
multi-vendor-distributed
write-anywhere
elegant
cifs
greatest
file-server
creators
nvram
guiding
block-based
free-inode
blotk
systen
made-and
snapshots
nearest
versioning
,.hj
clones
shapshots
captures
promoted
throwing
upgrades
naturally
repeating
uniformly
enlarged
countilcg
retranslated
multiple-client
cachirtg
modifed
variability
granularity
filecontrol
reinote-file-access
m.edium
penalties
recompaction
compacted
relocate
recompacting
reconstruct
preallocate
com.puter
norton
wilton
iacobucci
1985b
1985a
deitel
unl
mcvoy
kleiman
ghemawat
baker
ousterhout
hartman
thekkath
hitz
documentation
community
magenetic
disk-scheduling
formatting
stablestorage
hsm
platter
flat
shape
diameters
moving-head
surfaces
magnetically
flies
surface
concentric
cylinders
motor
rotational
thin
cushion
air
microns
danger
coated
protective
accident
repaired
plastic
computingf
1.44mb
portsf
disk-drive
12.1.2
spool
wound
rewound
spot
positioned
comparable
20gb
200gb
includil1.g
millimeters
inch
lt0-2
sdlt
originalfirewire
megabits
standardfirewire
2-has
emerged
1394b
firewire
firewire-800
outermost
-at
theory-convert
old-style
defective
smne
density
farther
zones
stay
tens
12.3.1
host-attached
ide
ata
cabling
sata
scsi
charmel
ribbon
conductors
card
to.rgr
jukebox
sendil
media-changer
four-conductor
fabric
24-bit
dominate
sjld
initiate
12.3.2
network-attached
nas
remote-procedure-call
network-usually
local-area
networkattached
thil
storage-access
enjoyed
direct-attached
networks-rather
cables-can
interconnects
distant
storage-area
acute
installations-the
competes
sans
emerging
highspeed
interconnection
responsibilities
entails
12.4.1
fastest
183,37,122
14,124,65,67
wild
swing
12.4.2
sstf
traversed
cylinders-little
pending-request
12.4.3
elevator
reversing
183,37
servicil
heaviest
12.4.4
c-scan
trip
wraps
c-look
12.4.5
themf
practicef
commonlyf
immediatelyf
12.4.6
algorithmsf
appeal
diskf
requestsf
retrievat
justify
algoritlunf
thenf
samef
fik
contrastf
usedf
structuref
filef
casef
disk-arm
disclose
alleviating
gladly
urgent
flush
spoon-feed
bad-block
slate
fills
trailer
ecc
calculated
mismatch
12.5.3
error-correcting
reports
recoverable
low-level-formatted
factory
defect-free
low-level-format
256,512
headers
trailers
operatiltg
icgicz
iltitial
assuring
iio
12.5.2
running-for
-it
jumps
tiny
non-fixed
ruru1ing
bootil1g
directs
mbr
contilmes
tolerances
conle
resided
bad-sector
redirection
invalidate
remapped
slipping
remaps
spared
slipped
th.at
restoration
8.2f
critically
pagesf
interchangeablyf
merging
accessf
sectionf
12.6.1
systemsf
imagef
gigabytesf
amow1.t
memoryf
backingf
safer
underestimate
requiredf
overestimation
filesf
pageable
factf
debate
linux-allow
12.6.2
carved
navigating
diskallocation
short-lived
raw-partition
repartitioning
12.6.3
pagiltg
technological
text-segment
thrown
uninitialized
biggest
1---------swap
area--------1
l
---_l
raw-swap-space
.u1.2.p-an
ij.l.dicates
economically
opportunities
improving
offers
redundant
disk-organization
raids
cost-effective
stood
ij.l.dependent
12.7.1
flmctionality
intelligent
raid-protected
-and
rebuild
mirroring
volume-where
57,000
disasters
earthquakes
floods
defects
correlated
n1.irrored-disk
singledisk
write-back
correction
12.7.2
doubled
functionat
single-disk
striping
participates
bit-level
divides
striped
mod
block-level
12.7.3
l1.ave
cost-performance
non-redundant
memory-style
bit-interleaved
block-interleaved
12.1l
ievell
level1
level2
error-correctingcode
single-bit
error-correction
level3
one-disk
mirror
n-way
3-and
paritybased
levels-is
non-parity
offloads
spindles
outperform
non-caching
level4
diagramed
slowe1
syti
datacompared
5-and
stripe
resulti.j.l.g
inaccessible
mirrors
volume-management
bus-adapter
hba
intercom1ect
replicated
hot
reestablished
12.7.4
continuous
influences
rebuilding
rebuilds
important-for
inserv
im1ovation
3par
256-mb
chunklets
chunklet
needing
shrink
noticing
purchase
level6
12.7.5
comrnonly
tape-drive
landscape
perils
innovative
checksums
checksummed
checksum
checksumming
read-modify-write
noticeable
five-disk
above-mismatched
lanagers
shrinkage
combines
malloc
resize
quotas
reservations
pooled
outcomes
injormation
detectable
succeeds
trusted
route
buy
sealed
lowers
12.9.1
rewritable
cds
tertiarystorage
flash
12.9.1.1
stuface
scratches
magneto-optic
thick
glass
resistant
coil
weak
magnetize
flashes
laser
beam
heats
susceptible
bounced
polarization
rotated
clockwise
counterclockwise
dependin
orientation
magnetism
dark
bright
spots
exarnple
optical-disk
freeze
crystalline
amorphous
brighter
ltlaterial
bounces
reflective
phase-change
melting
refreezing
melt
re-recordable
cd-rw
dvd-rw
worm
manufacture
aluminum
film
sandwiched
burn
burning
alter
additions
durable
metal
encapsulated
organic
polymer
dye
absorbs
marks
recordable
cd-r
dvd-r
read-oniv
prerecorded
pressed
burned
nonremovable
12.9.1.2
cartridge
fast-forward
supercomputer
centers
enornwus
enterprises
installations
changers
automated
diskresident
off-line
shelves
12.9.1.3
economics
solid-state
ssd
ssds
energy
life-spans
journal
journaling
notebook
promising
bologt
phk
holographic
photographs
hologram
three-dimensional
pixels
pixel
white
fabrication
datastorage
proposal
centimeter
lengthwise
sideways
data-storage
12.9.2
abstraction
abstractions
12.9.2.1
exclusivity
backs
partly
detern
ined
fly
detennined
read_position
erases
end-of-tape
eot
refuses
12.9.2.2
molmt
prefixed
memorize
12-digit
encodings
ebcdic
name-space
unsolved
comn1on
fonnats
12.9.2.3
archived
file-archiving
staged
disk-resident
sporadically
ilm
12.9.3
12.9.3.1
transfer-that
cartridge-switching
sustained
tlce
bandwidths
30mb
buried
reel
winding
reels
spinning
seconds-about
robotic-ann
ejected
calibrate
prepare
tape-switch
enormously
overgeneralize
eject
terrible
bandwidth-to-storage-capacity
12.9.3.2
pe1jormance
infinitely
n1.ag
netic
harmful
dust
humidity
mechanical
forces
shock
bending
gentle
magnetic-tape
scrubbing
fixed-disk
removable-disk
weakness
unharmed
12.9.3.3
amom1.t
housing
lox
averaged
advertisements
smallcomputer
marketplace
readership
markets
purchased
128mb
2gb
---c-19
,8.,.-2
98-cc4
c8
88---,19
c9
-1c
91
99-4
c19l96---,19c
-2.,-,o
oo
0l.04
2oos
fluctuates
excess
glut
shortages
sigrtificant
decline
steadier
fell
steadily
ceased
dramatic
mid-range
dat
approaching
72gb
320gb
9c-c84-1
l98
-88c---cc19
90c
c19
--c-c19l94-c-c19l96,---.,-c19cc98-2,-jooc-c0--c2,-j.00,-,-2
.,j
in.expensive
small-computer
fallen
plummeted
dropped
medium-sized
largely
rendered
revival
revolutionary
breakthrough
farms
n1.agnetic
disk-schedliling
disk-queue
harmed
defragmenting
badly
reorganization
hardware-new
preformatted
dedicate
requestqueue
convention
sensitive
coating
expose
lastly
decades
notably
areal
gigabits
suitability
streaming
underway
level-2
kilobytes
sentence
sequentialaccess
s1naller
mtbf
drive-hours
750,000
farm
minute
mortality
dying
ages
deduce
20-year-olds
20-year-old
1-million-hour
warranty
tape-resident
imagine
invented
40,000
black-and-white
resolution
invention
scsi-ii
7,200
rpm
7,000
cylinde1
head-switch
adjacent-cylinder
8-kilobyte
serving
86,1470,913,1774,948,1509,1022,1750,130
elementary
physics
subjected
acceleration
at2
accelerates
decelerates
lillisecond
full-stroke
accelerating
manufactured
constant-rate
constantacceleration
seek-time
scb.edule
rotates
one-sided
5.25-inch
gigabit
1,800
marketable
simulates
remapping
sparing
perfonnance
disciplines
assertion
unfair
comprising
estimates
terabyte
10gb
5mb
mixed
levell
rereading
fil1.d
nonredundant
chen
disk-system
katz
wilkes
teorey
pinkerton
comparative
king
seltzer
jacobson
lumb
worthington
negligible
defect
ruemmler
akyurek
salenl
schindler
gregory
douglis
1994l
1995l
greenawalt
golding
randomness
smalt
quinlan
richards
maher
alt
accommodation
supercomputing
benjamin
eosdis
gibson
1997b
1997at
riedel
1998t
psaltis
mok
dating
sincerbox
asthana
finkelstein
electron
trapping
toigo
in-depth
incidental
paint
basics
embodiment
bridges
gap
assemble
pipelines
standardization
11s
generations
encapsulate
oddities
deviceaccess
human-interface
s11ch
steering
military
fighter
jet
shuttle
aircraft
joystick
foot
pedals
motors
rudders
flaps
thrusters
incredible
electronics
conveyed
electrical
voltages
timings
plugs
daisy
processor-memory
upper-right
c01mected
plugged
pcie
serial-port
circuit
com1ection-scsi
memory558
000-00f
020-021
040-043
200-20f
2f8-2ff
320-32f
378-37f
3d0-3df
3f0-3f7
diskette-drive
3f8-3ff
unintended
data-in
data-out
nlode
13.2.1
intricate
handshaking
comm.and
command-ready
coordinating
cpu-instruction
logical-and
extract
branch
arrange
13.2.2
senses
asserted
catches
interrupthandling
defer
raised
maskable
interrupt-handling
vectored
chaining
il1.terrupt
inefficiency
dispatching
theinterruptvector
nonmaskable
device-generated
maskii1.g
interacts
installs
cornpleted
induce
self-contained
19-31
32-255
into-detected
opcode
coprocessor
overrun
floating-point
alignment
i3.4
event-vector
page-cache
convey
supervisor
interrupts-executilcg
overflows
urgent-it
ents
threaded
housekeeping
summa
supervisor-mode
time-sensitive
13.2.3
time-a
burdening
pio
offloading
dma-request
dma-acknowledge
seize
memory-address
iia
-acknowledge
signat
seizes
momentarily
mercwry
undergo
dvma
protected-mode
discipline
violations
kernelsoftware
interferes
--
2..c
li.ip
.2-j
rc-c
.,.,---j
,._
cg
,or
tt_ront
13.2.4
electronics-hardware
control-bit
host-and
disruption
software-engineering
encapsulation
functions-an
custom-tailored
scsi-2
peripherals
unfortm1ately
device-hardware
ship
drivers-for
dimensions
character-stream
instruct
irregular
styles
conventions
conunands
implernented
invent
13.3.1
block-oriented
essen.tial
behaviors
block-storage
insulated
databasemanagement
unneeded
contradictory
raw-device
block-device
programmers-access
line-at-a-time
backspace
style
mice
spontaneously
13.3.2
-seek
wall
electricity
analogy
plug
eliminates
facilitating
proving
ground
a.9
13.3.3
elapsed
timesensitive
flushing
dirty
cancel
congestion
chan11els
earliest-time-first
earliest
coarse
precision
drift
highfrequency
highresolution
13.3.4
relates
asynchronous-they
decompressing
h1.stead
communicated
triggering
call-back
available-the
fotmd
multiple-read
services-scheduling
handlil1.g-are
devicedriver
protectil1.g
13.4.1
begilming
travels
rearrangil1.g
rearranges
experienced
delay-sensitive
teclul.iques
13.4.2
cope
instantaneous
decouples
consun1.er
relaxing
decoupling
adaptations
disparities
reassembly
systemcalt
hype
ransport
32,pair
xpress
lnfi
l.i
band
qdr
efigure
device-transfer
logarithmic
clever
13.4.3
ilc
sometinces
illstance
maill
accumulated
delayilcg
13.4.4
ilcterleaved
prillter
intercepting
correspondilcg
in-kernel
unwanted
usefully
multiplex
thenlselves
13.4.5
glitch
compensate
retry
res
experiences
signifying
code-one
values-indicating
reported
self-test
.l
error-log
host-but
13.4.6
purposely
disrupt
disruptions
camlot
playback
13.4.7
character-device
aligned
teclucique
ple
.,_
v.
info
write.functions
f..un
ction
procedural
13.4.8
subsystenc
supervises
file-access
space-allocation
separator
prefixes
ncatchilcg
m.ajor
device-table
stages
tremendous
interruptvector
device-controller
-------tim_e
unblocks
orputmsg
putmsg
getmsg
end-like
modules-has
triggered
fult
dropping
ethernet
treating
unblock
stress
exposes
durilcg
coping
gracefully
architect
internjpt-driven
transported
unpacked
subdaemon
reimplemented
lntercomputer
logins
offload
cham1.els
flowing
dma-knowledgeable
overload
idleness
clicks
error-handling
data-recovery
-in
progression
f1exible
application-level
messaging
reimplement
challenging
perform.ed
offloaded
num.erous
character-string
stacked
bidirectionally
pseudocode
front-end
termii1.al
concentrator
men10ry
initiation
iterates
busy-waiting
catching
combin_ation
polled
targets
system-bus
busy-wait
leffler
milenkovic
interprocesscommunication
brain
minix
woodhull
custer
hardware-level
cache-consistency
sargent
shoemaker
march
raga
confidence
assurance
broader
pervasive
conceived
adjunct
untrustworthy
mischievous
time-tested
dictates
passkey
guards
misused
compromised
n1inimum
audit
trails
trail
prograrnmer
law-enforcement
officer
role-based
rbac
irtcomplete
differentiates
meaningful
reso1jrces
reqllires
conunonly
need-to-know
faulty
chapter14
risks
14.3.1
object-name
rights-set
disjoint
stems
realized
-generally
monitor-user
nonprivileged
systems-unix
14.3.2
tbough
userid
population
crackers
oversight
attacked
attackers
breached
14.3.3
tics
hierarchically
ring
rings
dj
n1ode
segm.ent
current-ring-number
cmmot
crosses
mmmer
bracket
gates
segncent
bl,b2
weighed
grades
classwork
crunching
utmost
omit
i,j
objects-three
access-matrix
decided
cohum1
d2
asterisk
appended
colurrm
propagation
lc,j
executil1.g
domai11
disclosure
unsolvable
datastructure
14.5.1
triples
groupings
r1c
rjc
14.5.3
ltst
tbose
relies
foreseen
fom1dation
tags
tagged
booleans
14.5.4
lock-key
14.5.5
correspond
localized
localizing
revoked
swiftly
cal
file-table
or1
com.paring
revolves
processes,limiting
roles
superusers
user1
revoke
selective
access-list
reacquisition
reacquire
back-pointers
inspected
set-key
exercised
key-based
grounds
theories
14.8.1
hydra
system-defined
procedurally
krtown
auxiliary
discrin
lination
instance-by-instance
process-by-process
fnrwk
j1o
certified
trustworthy
regarded
trustworthiness
amplification
amplified
originat
unamplified
adjustment
reinstated
user-protection
circumvented
amplifications
suspicious
compile1
malfunction
authority
som.e
kernel-defined
subsystenl
enforceable
afforded
acquainting
rnanual
14.8.2
cambridge
cap
superficially
seal
unseal
unverified
consequence
insecure
breakdown
economies
formulating
commensurate
validate
validation
satisfying
operational
originated
newest
designe1
tampering
14.9.1
compiler-based
declarative
linguistic
usin.g
certify
protectionchecking
compiler-supported
softwaresupported
lesser
tagged-capability
immune
enforcem.ent
disturbance
verified
tailor
capability-creating
rendering
nonprocedural
led
infancy
stringent
notations
recognized
14.9.2
jvm-has
ofj
ava
distrusting
paramount
intuitively
lacks
signatures
15.4.1.3
configurable
corucection
assert
dopri
vileged
accesscontroller
annotated
checkpermissions
annotation
silently
disallowed
accesscontrolexception
exhausts
applet
proxy
.lucent
urls
encountering
uri
addr
.lucent.com
doprivileged
proxy.lucent.com
checkpermission
annotations
manipulations
compliance
camlot
f01mdation
subclasses
arbitration
played
p.m
ancestors
descendant
x,y
xis
z,y
cross-ring
ring-protection
higher-numbered
enjoy
stack-inspection
popek
saltzer
surveys
harrison
iliffe
jodeit
codewords
horn
needham
walker
jefferson
ekanadham
bernstein
levin
confinement
lipner
morris
mcgraw
andrews
dynamic-resource-management
jones
liskov
ganger
kaashoek
ineffective
enabler
-cryptography
fundamentals
hashing
countermeasures
financial
inviting
thieves
pertaining
unscrupulous
fraud
impair
rare
norm
accidents
intruder
cracker
breach
vulnerability
confidentiality
1mauthorized
capturing
secret
credit-card
money
liability
innocent
party
wreak
havoc
bragging
financially
web-site
defacement
intrusion
denial
attack
15.3.3
participant
pretends
masquerading
privileges-obtain
replay
captured
fraudulent
attackfor
attacker
man-in-the-middle
abuse
perpetrator
deter
intruders
cmmtermeasures
secured
armed
surreptitious
rooms
tricked
social-engineering
legitimate-looking
misleads
confidential
bribe
trash
phone
purposeful
runaway
denial-of-service
reveal
launching
endless
leased
dial-up
inaintained
circumvention
adage
chal.l
guarding
intrusions
exploration
nonprogram
threat
descriptive
15.2.1
horse
text-editor
certairl
keywords
misuses
exacerbate
trojanhorse
friend
commanct
emulates
control-alt-delete
conlbination
trojan
spyware
accompanies
freeware
ads
visited
innocuous-seeming
spam
crime
mistakes
error-a
inadequate
weakening
15.2.2
door
war
inight
arrested
embezzling
banks
occasional
half-cent
credititrg
nefarious
doors
pose
15.2.3
bomb
incident
circltmstances
launched
15.2.4
buffer-overflow
exploits
neglected
expecting
buffer-for
daemon-wl.til
execute-for
spawn
web-page
buffer-reading
line-argv
terminator
strcpy
buffer,argv
strncpy
.unfortunately
vulnerabilities
bufferoverflow
attacking
execvp
sh
fragment
hypothetical
no-operation
attackedthe
15.2-ran
exploitation
skill
exploitable
launch
skills
exploita
pernicious
disallows
overflowed
sp2
nonexecutable
15.2.5
self-replicating
infect
malfunctions
penetration
progran
borne
comrnon
viral
suite
powerpoint
excel
unconstrained
sub
autoopen
dim
ofs
createobject
scripting.filesystemobject
command.com
,vbhide
inserts
dropper
literally
infects
parasitic
watches
low-levellanguage
spreadsheet
boot-sector
polymorphic
antivirus
signature
cilii
decryption
decrypts
stealth
tricky
tunneling
anti
interrupt-handler
multipartite
armored
unravel
disinfection
droppers
infestation
unviewable
exploited
infecting
iis
visiting
back-door
disruptive
debates
jth-yhcn
monoculture
supposedly
inisused
is-the
allows-the
strive
scamcing
netvvorks
secrets
comnmnications
15.3.1
ravage
potent
reproduce
workday
november
tappan
cornell
unleashed
corm.ected
targeting
reproduction
propagate
in.itial
infection
ll.c
grappling
hook
uploaded
hooked
proceeded
rsh
host-login
paired
finger
sendmail
anew
telephone
user-name
hostname
quotation
queries
536-byte
crafted
routed
invading
routes
testers
ncail
arsenal
-instead
testing-issued
cornmands
mailed
grappling-hook
systematically
account-user-name
comparisons
dictionary
favorite
three-stage
password-cracking
wontt
sightings
remained
confound
baiting
fake
wholesale
expertise
evening
halting
circulated
patches
unleash
harmless
prank
criminal
offense
unintentional
repel
damaging
author
trojan-horse
inferring
motive
speculation
federal
court
convicted
handed
probation
experts
august
sobig
w32.sobig.f
persons
fastest-spreading
mfecting
seventeen
clogged
inboxes
sobig.f
pornography
newsgroup
disguised
photo
smtp
engine
details,
approved
payload
winppr32.exe
registry
malevolent
untold
15.3.2
lip
operath
encoded
horses
subsets
nma
exploiting
knowledgeable
kiddie
15.6.3
relay
zombies
prosecute
inconsequential
gaming
stealing
disrupting
penetrated
pop
ddos
comncon
blackmail
surge
advertising
campaign
firewall
induced
deploying
notorious
spawning
stand
gamut
broadest
reliably
ali
infer
rogue
falsified
routers
infeasible
.,-ro.rnron
constrain
selectively
possessing
key-the
derive
subtleties
15.4.1
ancient
securely
parties
certificate
15.4.1.4
ciphertexts
computable
eachlc
ciphertext
possesses
----1
rnessage
i5.7
decrypt
plaintexts
15.4.1.1
encrypt
secrecy
civilian
national
institute
stantechxwlogy
nist
des
56-bit
substitution
permutation
s-boxes
cipher
encrypting
anwunt
exclusive-ored
xored
exhaustively
encryptions
plaintext
uslilg
keys-for
lc2
aes
rounds
bear
crus
pseudo-random-bit
fed
keystream
rc4
steams
wep
breakable
con1.puter
15.4.1.2
rsa
inventors
rivest
shamir
adleman
block-cipher
public-key
asymmetrical
elliptical
curves
cryptographic
strength
disseminated
ice
messlge
isl
encryption_...
k5.91
gl
andq
are512bitseach
theencryptionalgorithmis
icc
leekd
ckd
p-1
yielding
kekrt
publication
publish
handing
jealously
seemingly
inaking
truth
authenticators
sand
possess
authenticator
n-bit
collision
m-that
message-digest
160-bit
digests
recompute
encrypts
cam10t
resistance
digital-signature
lcv
lc5
lcs
essage
notable
h.sa
patch
sign
supplies
nonrepudiation
signing
battle
cryptographers
inventing
ciphers
cryptanalysts
cut-or-band
document
conversation
key-management
privately
happily
authentication-what
certificates
digitally
signed
kbad
-.u
...
.,......_read
certifies
certifier
i.j.l.cluded
authorities
vouch
parsed
15.4.3
15.4.2
network-protocol
transport-layer
network-layer
data-link
ssl
networklayer
ipsec
endpoints
definitive
protections
contaii1.ed
higher-layer
protocol-for
transports
corrumjj1icate
securely-that
completeness
tls
dance
-cey
two-all
forgotten
cert
certification
attrs
theca-that
kca
presumed
shipped
28-byte
cert5
tests
46-byte
cpms
pms
possession
cmnpute
48-byte
collision-resistant
fresh
value-that
ypt
rypt
lcd
identityfor
name-of
vpns
competitor
point-to-point
traffic-say
employee
authenticating
canle
authentic
retina
15.5.1
comm.on
asked
user-supplied
nmst
bypassed
15.5.2
guessed
sniffed
illegally
cats
spouses
brute
enumeration-or
punctuation
-until
four-character
guessing
shoulder
watching
off-system
keystroke
exposure
hard-to-remember
forbids
questioned
break-in
account-sharing
friends
-possibly
system-generated
user-selected
cracking
accepting
foolproof
toggle
extren
now-invalid
15.5.3
necessity
difficult-the
impossible-to
invert
rigorously
flaw
it-encrypting
cracked
remembered
phrase
mother
katherine
mmn.isk
crack
15.5.4
sniffing
surfing
challenged
seed
becallse
clue
securid
calculators
shaped
key-chain
dangle
keypad
pin
jn
two-factor
single-factor
single-use
calculator
calculations
15.5.5
biometrics
biometric
hand-readers
access-for
hand-reader
pads
fingerprint
ridge
pad
profiles
transit
hijacked
bug-free
defense
15.6.1
outsideaccessible
permissible
road
reviewed
15.6.2
assessment
assessments
rlsl
endeavors
assets
odds
.,
--in
unhappy
easy-to-guess
unexpectedly
points-a
far-reaching
top-secret
topsecret
connectors
computer-an
multifactor
mission-critical
indispensable
ncisconfigured
scanners
advocate
stating
obscurity
strives
encompasses
axes
intrusive
user-shell
correlating
alerting
activity-for
killing
engaged
fonn
divert
degrees
idp
idss
idps
settle
ambitious
signature-based
virus-detection
anomalous
presumption
deviates
coin
non
codified
recognizable
contemplated
evade
benchmark
benchmarked
benchinarked
behaviorf
alarms
orf
missed
marginally
security-relevant
worthy
investigation
optimistically
recordsf
recor
mtrus10n
interpreting
1-p
raising
probabilities
focusil
aii
false-alarm
true-alarm
ail
falsealarm
ilwestigates
alarms-called
christmas
-is
teach
admilcistrator
anomaly-detection
adequately
benchmarking
ues
anomalydetection
evolving
15.6.4
catalogs
pattern-match
families
decompress
anomalies
teducique
tripwire
purdue
configurationfile
tw.config
enumerates
deletions
mask
itselt
hashes
sign.ature
recomputes
tw.conf
compl.j-ted
tamper-proof
write-protected
unforhm.ately
files-for
files-are
detectcertain
analyzes
sandbox
unmonitored
shield
inbound
outbound
purchasing
unopened
pirated
safest
disgruntled
employees
attachments
pretended
propagated
clogging
defensive
safeguard
reformatting
filename
messagedigest
high-overhead
virus-scanned
15.6.5
auditing
misbehavior
stoll
exam5ning
spotted
unh
usted
router
semitrusted
semisecure
dmz
commurucations
r---------i
attack-proof
denialof
prex-y
speak
forwards
xml
malformed
fifty
lowest-level
discretionary
accountability
c1-class
sensitivity
tcb
c2-class
individual-level
adrninistrator
speciat
division-b
mandatory-protection
classc2
bl-class
human-readable
user-namepassword
clearance
authorizations
hierarchicat
secret-level
b2-class
covert
b3-class
notifies
highest-level
architecturally
class-al
functionally
develops
agency
tempest
eavesdropping
tempest-certified
shielded
electromagnetic
escaping
shielding
housed
wilcdows
shutting
interactively
token
retinal
eye
subjects
bl1ilt-in
logoff
strange
write-access
outbreak
foo.bar
-all
cs-read-write
cliff-no
accessallowed
accessdenied
readdata
writedata,appenddata
execute,readextendedattribute
writeextendedattribute
readattributes
teattributes
classifies
noncontainer
printilig
tiine
formulate
environment-people
businesses
threats-within
agaitlst
masses
self-perpetuating
asymnletric
activation
forgery
intrusiondetection
judicial
man-in-themiddle
cops
alerts
hazards
physicat
watchdog
grants
watchdogs
lce
intrusion-detection
user-provided
hsiao
1979l
landwehr
deru
1ing
pfleeger
russell
gangemi
lobel
concernin
rushby
silverman
schell
randell
thompson
morshedian
fight
pirates
seely
lehmann
reid
grampp
wood
kochan
farrow
1986b
1986a
filipski
hanko
hecht
kramer
garfinkel
security-scanning
ftp.uu.net
spafford
june
bellovin
cheswick
insider
kent
zapata
asokan
perrig
routing
savage
trace-back
perlman
proposes
diagnose
ludwig
diffie
hellman
lempel
simmons
demting
gifford
ahituv
schneier
akl
davies
orange
qualify
inodel
ietf
rfc
axelsson
kim
system-call-based
forrest
loosely
coupled
minicomputers
16.1.1
16.1.2
subcomputations
comnlon
16.1.3
remammg
tenninal
16.1.4
single-computer
longdistance
collaborating
industry-wide
dovmslzing
bang
buck
network-oriented
16.2.1
multiplicity
16.2.1.1
p1.npose
16.2.1.2
enviromnent
cs.uvm.edu
vario-us
ptp
ftp
jtp
nanle
file-protection
corulect
get-transfer
put-transfer
dir-list
-change
tehlets
16.2.2
16.2.2.1
modest
smb
netbeui
c.6.1
mere
character-code
representations
16.2.2.2
itiated
cmmnand
predefilced
operatil
ilwocation
duril
16.2.2.3
microprocessor
migrated
distributedcomputing
applets
easy-to-use
facility-one
16.3.1
substitute
complement
cou.rjerparts
high-quality
cables
attain
prohibitively
conunon
twisted-pair
fiberoptic
star
megabit
appletalk
radio
higher-quality
egabits
optical-fiber-based
fddi
token-based
laptops
gateways
wifi
transmitting
802.11g
802.11n
communicatilcg
cafes
16.3.2
1960s
academic
arpanet
begun
four-site
unreliable
satellite
defilcing
netwot
regional
nsfnet
northeast
interlinked
16.5.2
telephone-system
multiple-t1
commmlication
charges
analog
destinations
1,200
ppp
coru1ections
topologies
ntially
some-but
all-pairs
rerouted
unconnected
treestructured
single-site
disconnected
lise
beca
homer
marge
lisa
humans
name-to-address
updati.n.g
rnarr-,,or
untenable
domain-name
multipart
frorn
bob.cs.brown.edu
bob
depattment
top-level
organizations
resolves
host-id
brown.edu
nance
cs.brown.edu
128.148.31.100
refreshed
safeguards
lmreachable
back-up
registered
sri-nic
name-server
subdomains
host-name
gethostaddress
destined
16.5.4
dnslookup
www.wiley.com
uhe
err
.-i
remote-login
sited
schem.es
adapt
ncessages
company-wide
cmmections
16.5.3
incplemented
connectionless
communicators
uuc
con1municate
tl1is
hang
correspondents
information-such
errorcorrection
post-office
reassembled
set-up
shipping
16.5.5
cmmect
scrambled
retransmit
provisions
-uvith
congested
circulates
retransmits
token-passing
apollo
lengthen
error-prone
international
handlingfiames
connecti01cs
outgoing
process-to-process
duplex-full
echoing
transfe1
schemas
protocols-showing
end-user
transfer-syntax
negotiation
data-representation
dialog
network-independent
message-interchange
end-to
framing
networkcinterface
-layer
f-------1
session-layer
_____j
message-header
data-network
data-lil1.k
stripped
fu1.ally
formalizes
combilles
illcluding
datagram
datagrams
clear-text
tcp-udp
handshake
16.7.1
j-am-up
m.essage
are-you-up
positively
time-out
sih1ations
16.7.2
reconfiguration
believes
coordinator
coordinators
16.7.3
wlcen
routing-table
mcdelivered
16.7.4
tolerance
tolerant
fail-stop
storage-device
decays
tolerated
grinds
cmnmunication
compromising
computation-centric
data-centric
failure-monitoring
18.4.1
anode
noncommitted
arranging
mobility
facilitates
bringiicg
cmu
athena
saturated
saturation
reacts
nonscalable
degrades
moderately
ever-growing
clog
withstand
paralyzed
saturate
fault-tolerance
demonstrating
large-scale
guidelines
centralization
fault-tolerant
asyrrunetry
constituting
ideal
autonomy
practically
comply
incorporating
violates
aspire
single-process
necessitates
lightweight-process
name-resolution
tcf
proportion
adrninistrators
host-ids
re-sent
arp
ip-mac
hardwired
announced
upper-level
compose
802.3layer
1-mtil
0-1500
0-46
pt.e
n1bh
s.tartfc1ft
ccll
data-link-layer
communication-network
massage
reconfigured
rectified
torn
address-resolution
www.cs.yale.edu
www.apple.com
www.ietf.org
2000a
computer-architecture
comer
coulouris
steen
i-iarchol-balter
downey
vee
i-isu
i-iarish
owens
han
ghosh
milojicic
sirer
dfss
dfs-the
transarc
cross-machine
concponent
distinctive
dispersion
cpu-processing
attributed
dimension
constituent
cmnpm1.c
nances
replicas
17.2.1
notions

location-independent
stronger
location-transparent
operating-system-initiated
divorce
exhibited
ratber
locationtransparent
promotes
mobilized
storagedevices
um1.ecessarily
contradicts
decentralization
applications-are
17.2.2
ibis
local-name
1-mits
popularized
coherent
mmmted
file-structure
versatile
spans
machine-specific
difficult-to-maintain
rem.ote
m1structured
17.2.3
naine
component-unit
single-file
aggregation
name-to-location
replicating
teclllcique
inevitable
low-levet
invariant
aggregating
locationindependent
nanling
analogous
rationale
17.3.1
least-recently-used
17.3.4
sincilarly
notwithstanding
diskread-ahead
disassembled
blockcaching
1mb
17.3.2
stored-on
outweigh
nl.echanism
remote-access
hybrids
augmented
server-side
sprite
emphasized
ofnfs
clientside
disk-caching
serve1
cachefs
17.3.3
cache-update
write-through
unwritten
write-on-close
apparent
client-initiated
crux
server-initiated
17.3.5
trades
capitalizing
attractive
contacted
infrequent
small-memory-capacity
masse
in-core
ru1.til
evident
graceful
silcce
reincarnated
unnoticeable
retransmitting
i,_lformation
consecutively
withilc
destructive
camcot
mailctain
multimachine
replica
failure-independent
nfsv4
ourcov,era.geofnfs
.far
0p1y
orv3
mostrecentnps
fundanrentaljy
vious
versimi.s
jhe
ch9nge
stqteful,meaping
tha
tthesetv
the.state
j1lote
0pt
ned
untij
itis
th.t1s
thenfs
c1o
ersions
thich
.proyide
.np
furthen
ore
preytous
cersions
parate
lounting
systews
lockii1g
phlgle
prqtocol
patticular
1nrnmt
elimin
1.ted
fitewalls
nj.ount
notorimis
nps
implem,entations
.additionally
enhan
edthe
of.dients
prov
performapc
disttil
a.s
plients
reso
a9cesses
che
rgther
thanh
lvingto
gpjhroughthe
ver
diel
tsjo
req
estfile
jocks
rvers
.if
senr
grqrct
loci
,tmtil
lea.st
clier
ar,e
als
stiltg
traditiora11y1
.provide
jile
operatirg
mandat
rylockil1g
allov
towm
wellwithnon-unixsyste1fts
v4t1qw.p.rovides
vvell
lockinga11d
mec
anisms
legahon
whe
eby
delegates
lockand
.the
thatrequested
tnel
ckcrhat
delegated
.current
deleg21ted
a1i.d
filt
confentsuntifthe
del
egated
reli11quishesth
andde
egation
whereas.preyiousversionb
npsarebasedon
udj
ptqtocol
.tcp,whioh
itto
betteraclj
lstto
thel
etwork
peleg2lting
cliel
cts
foado11the
s.eryet
and.i
proves.cache.coherency
location-opaque
locus
sen1antics
incportance
sacrificed
sacrificing
sacrifices
primary-copy
primary-replica-identifier
local-replica-identifier
replication-control
whole-file
nonlocal
nonprimary
serialized
invalidation
stale
information-sharing
coalition
dce
osf
openafs
cross-platform
arguably
feature-rich
nonexperimental
client-side
kerberos
switchover
formidable
17.6.1
descends
virtue
privacy
com1.ected
decomposition
cross-cluster
heuristic
accessil
secure-transmission
connectionbased
unlxbits
administer
heterogeneity
diverse
facilitated
17.6.2
unusually
quota
glued
m01mt
fid
equal-length
uniquifier
fids
querying
forwarding
volume-movement
system-executable
seldom-updated
volume-location
contammg
17.6.3
lethod
ramifications
client-level
venus
cache-validation
readin.g
regains
occasions
exceptions
unilaterally
revoking
sync
syncbolic
pathname
re-fetching
17.6.4
interrogation
comcection
establishment
placeholders
path-name-to-inode
namei
file-status-returning
req1.1ests
non-preemptible
paralyzing
preferences
vlhich
multiclient
davcev
burkhard
brereton
purdin
wah
svobodova
callaghan
sandberg
howard
satyanarayanan
brownbridge
mobile
kistler
sobti
cluster-based
dabek
kubiatowicz
aft-er
happened-before
18.1.1
causality
happenedbefore
a
b
irreflexive
causally
space-time
horizontal
vertical
wavy
q3
son1.e
18.1.2
perfectly
defil
converse
lci
orderil
lc1
particulm
tlcenit
timestamp-ordering
ties
tirnestamps
18.4.2
18.2.1
fair-such
firstserved
scheduling-no
reques
electing
elected
18.2.2
event-ordering
incmning
deferring
defers
participation
gro11p
circulating
collapses
rejoin
pause
intend
18.2.3
providilcg
circulate
entitles
substituted
subtransactions
18.3.1
execution-that
-then
2pc
oft
pre-specified
verdict
fate
unconditionally
tat
promise
unanimity
18.3.2
18.3.2.1
query-status
tted
s1c
18.3.2.2
made-or
is-until
doubt
downtime
18.3.2.3
18.4.1.1
nonreplicated
qat
initiator
ncessage
deadlock-handling
18.4.1.2
single-coordinator
site-say
lmlock
lockmanager
administers
complicates
18.4.1.3
inn
detern1.ines
decentralized
18.4.1.4
biased
18.4.1.5
unreplicated
timestamping
serialization
generalizing
18.4.2.1
concatenation
sign.ificant
na1nes
timestarnp
visits
18.4.2.2
mamler
con
bine
18.5.1
nl1mber
channeled
timestampordering
wait-die
dies
wound-wait
counterpart
younger
wounded
reissue
die
18.5.2
ecessary
preemptions
union
18.5.2.1
tmion
ormliscient
observer
cycledetection
victiitl
graph-construction
picked1
back1
initiating
vertex
18.5.2.2
waitfor
pex
-detection
sj
discovering
iiwoked
sic
halts
5.z
elect
18.6.1
bully
elects
restarts
18.6.2
lisi
ifi
j-thatis,ifthe
pisnumber
j-that
inquiry
garbled
resultilcg
stopping
deviating
divisions
byzantine
army
commanded
surround
enemy
camp
generals
defeat
messengers
18.7.1
traitors
loyal
18.7.2
functionfoo
boo
acknowledgment
foo
pj
contradicting
devise
nonfaulty
vi
proportionate
refuse
ai,l
a,2
ai,3
ai,f
value-say
nil-is
ring-structured
concatenate
non-leaf
ancestor
comp1.1ter
deadlockprevention
prescribed
cam1.0t
1978b
fidge
singhal
babaoglu
marzullo
schwarz
mattern
ricart
agrawala
squareroot
maekawa
rilcg-structured
lann
carvalho
roucairol
agrawal
abbadi
taxonomy
kanodia
1978a
sclmeider
dilling-philosophers
sturgis
presume
defilling
mohan
lindsay
implementillg
traiger
spector
bernsteill
rosenkrantz
obermarck
menasce
muntz
knapp
takilcg
chandy
pease
garcia-molina
larue
specialpurpose
passed-even
correct-may
deadlines
continuous-media
passedeven
vision-control
walked
quick
batch-processing
system-m.ay
whatsoever
appliances
dishwashers
blackberry
airplanes
dishwasher
dishwasher-the
water
cleaning
antilock
brakes
wheel
sliding
traction
braking
furnace
safety-critical
operation-usually
-results
catastrophe
weapons
brake
flight-management
health-related
pacemakers
injury-or
worse-might
fax
wristwatches
systems-as
linux-provide
inexpensively
mass-produced
airliner
navigation
wristwatch
oven-it
footprint
footprints
thermostats
costconscious
intercom1ectin.g
memorymouse
bus-oriented
management-unit
soc
tim.ing
degrade
minimizing
il1.terrupts
large-kernel
vision
addresses-especially
miss-may
teclmique-kn.own
real-addressing
mode-does
real-addressil1.g
lynxos
requirencent
19.4.1
deemed
levelspriority
31-are
prioritization
requirem
19.4.2
xp-are
systems-in
systems-preemptive
long-duration
kernel-that
19.4.3
event-driven
expires-or
hardware-as
remote-controlled
obstruction
elapses
veering
radar
occursf
isr
obviouslyf
owitocontiex
ish
contributing
amomrt
mandates
beil
--------response
_....
-process
-will
noncritical
stricter
timet
period1
period2
period3
announce
admission-control
admits
rejects
19.5.1
rate-monotonic
inversely
respectively-that
processil1.g
-ti
20j50
19.8
j80
misses
19.5.2
earliest-deadline-first
edf
a1mom1ce
optimal-theoretically
19.5.3
timef
processesf
sharesf
admission
19.5.4
computingposix
__fifo
sched_rr
sched__fifo
sched_fifo
class-scheddther-but
undefined
pthread_attr_getsched_policy
pthread_attr_setsched_policy
sched_other
setsched_policy
pthread_attr_getschedpolicy
&policy
pthread_attr_setschedpolicy
scheddther
wind
river
rovers-spirit
opportunity-that
planet
organizationofvxworks
centered
kernel-a
thelinux
.systent
isbe
incre
singlyinreai-time
enviroft
ments.yve
hav
alreadycovered
softr
fil-ti,nteschedv,ling.fe
tur
secti
,whereby
tasl
sareassignt
d.thehj.ghe
tpriorityi
cst
additionaueatures
2,6
makelinux
even,more
suitilb
fot
.embedded
thes
i.nclud
fullr
pree
ptive
.efficient
sched-lli11g
orith
vhic
p.ll1sij
tinte
ac.tive
.stero
the2.6release
enthardlare
itecttlresbydi
tlcljng
jew
integrah1lg
iftto
reanill1e
.envirof
combini
s,.systt
it1
vith
mallreal-.ti
fle
ernet
tht
reby
systell1
botl
gene
s.e
tnd
real-tipte
theappro
tctken1
jy.t
lil_1cux
ppt
rat
systerrl
.rtlinux
lirn.tx
sll1ctll
l-timeoperating
htt1eikerllelj
alliftterrupts.-,-directing
ndarclkerrtel.or
anintef
rupt.randler
real7tirlle
ketnel
tlin
shtndar
i.linuxkernel
disablb
intefrl_lpts
tus.ens11rirtg
itc
tl1rlotac1c11atencyto.thereal-timesystem.rj
lirtux.ctls0
ies
difft
rent
schedulingpolicies
includingrate-mo1lot
schec1ul
j1g
sechonj9.5.1
deadline-first
section19
pipes-a
mversion
microkernet
optionat
customize
excluded
size-or
footprint-of
per-page
non-cacheable
cache-coherency
vxvmi
earliestdeadline
assignb
upcoming
deadlines-the
thermostat
household
nuclear
plant
fuel
landing
19.7-19.10
inferior
monotonic
liu
wordprocessing
compress
casts
20.1.1
succession
smoother
smooth
retains
choppy-looking
listened
-are
progressive
-by
videos
disc
5-minute
clip
ondemand
concert
lecture
station
utah
poil1.ts
thing
00p.m
10p.m
on-demand
full-length
lectures
time-there
realplayer
quicktime
20.1.2
100-minute
mpeg-1
1.125gb
high-defuution
television
hdtv
color
colors
11,520
mbps
listener
pauses
20.1.3
requirements-also
qos
requirements-of
jitter
compressing
beilcg
cormection
800-kb
decompressed
decompression
lossy
lossless
cone
pression
ratios
compression-namely
frequencies
ear
mpeg-2
mpeg-4
bitrate
vcr
high-definition
characterizes
lmsuitable
animation
buyer
appealing
56-i
bps
tin1.ing
foremost
intervals-or

hundredths
best-effort
systems-the
far-typically
next-generation
service-level
pauses-or
frames-during
data-say
worth-before
other-scenarios
negotiate
agreeing
negotiating
admitting
everyday
theater
practiced
nonshareable
requirements-for
negotiated
reserves
20.7.2
withii1
non-real-time
algorithn
diskscheduling
disk-bandwidth
data-rate
prioritize
20.5.1
.5.2
shortest-seek-time-first
deadline-the
tim.es
20.5.2
scan-edf
swil
wildly
fro
whereil
proximity
usil
batching
reordering
batches
threshold-say
followil
-
kj
time0
nun1.bers
quality-ofservice
network-perhaps
internet-issues
particular
protocols-notably
cisco
routers-that
prioritized
issues-issues
originator
real-thne
rrrf
rtp
transporting
rathe1
20.6.1
unicasting
multicasting
unicast
,
nh
suffice
standpoint
originating
country
executive
20.6.2
replaying
pausing
hypertext
http-the
realplaye1
cajj.u
locatm
metafile
rtsp
streami.j.1.g
i.j.1.clude
breaks
cine
blitz
disk-schedulu1.g
tear
finite-state
20.7.1
inc-scan
beginr1ing
cil
eblitz
time-length
tpically
behil
admitted
lett
rater
f---1
cinebiitz
thatcanberetrievedforrequest
duringeachcycleis
yjc
contailling
tscek
trot
servicil1g
tseek
1-b-l
disk-seek
retrievals
dislu
ansfer
yic
raisk
diok
computersf
assistantsf
requiren
requirementsf
qualityof
servicef
schedulingf
unicastingf
multicastingf
colorf
480f
imagesf
videof
mbf
batched
,j,c
..ji
r10
fuhrt
steinmetz
leslie
mercer
druschel
reddy
wyllie
regehr
lauzac
bolosky
schedule-management
detaiilinux
read-and
stand-alonemachine
market
workgroup-server
similarities
exam.ining
presents-interfaces
owe
tradition
feels
finnish
christened
pc-compatible
collaboration
revolved
kernel-the
n1.anages
systeitl
scratch
con1.munity
multitude
borrowed
teams
matured
arisen
upgrading
21.1.1
dated
80386-compatible
incarnation
cross-developed
milestone
culminated
bsd-compatible
slip
unix-style
inclllding
unloadable
bug-fix
minor-version
and2.1
evennumbered
remedial
untested
pc-specific
feature-support
virtual8086
mode-to
ipx
pc-only
concentrated
jmce
version-number
68000-series
powermac
ax.25
anlateur
isdn
netware
lanmanager
posix-compatible
process-scheduling
january
acks
acorn
21.1.2
li1.efficiencies
networkingadministration
floating-point-emulation
sound-hardware
loose
file-transfer-protocol
facto
repositories
21.1.3
painful
system-installation
ready-to-install
text-processing
unpacking
dish
ibutions
package-tracking
upgraded
painlessly
sls
packagemanagement
noncommercial
free-software
cz,ldera
germany
german-language
circulation
21.1.4
fmmdation
public-domain
waived
liimx
redistributed
binary-only
alongside
iction
ntaking-or
selling-binary-only
nonmicrokernel
well-funded
squeeze
minimalist
diversity
compliant
official
surprises
a.3
certifying
extensions-pthreads
21.2.1
othersknown
-may
logon
operating-system-support
m.elting
pot
unload
-they
arbitrated
kernel-system
tmprivileged
collecting
file-handling
sorting
string-manipulation
programs-both
com1.t
wanting
relinking
reloading
undertake
driver-the
already-rmming
unloaded
dismounted
reserve
21.3.1
syncbol
exporting
unresolved
moduleloader
verbatim
module-management
requestor
unloads
21.3.2
registration
cleanup
registering
virtual-file-system
nfs1
protocot
ipx1
packet-filtering
sysctl
21.7.4
21.3.3
sold
single-supplier
conflict-resolution
arbitrate
aims
clashing
aui
oprobes-device-driver
auto-detect
configuration-from
hardware-for
parallel-line
pup
incidentally
a.3.2
21.4.1
distinctly
run-the
21.4.1.1
lmique
forked
personality
personalities
unchangeable
21.4.1.2
null-terminated
conventionally
alone-their
meanings
cursor
scrolling
multilingual
lang
environment-variable
custom-tailors
21.4.1.3
context-the
signal-handler
21.4.2
subcontexts
file-descriptor
subcontext
struch1res
21.5.1
overhaul
affin.ity
arrays-active
vice-versa
ether
o-o-o
posix.lb
round-robill
time-share
soft-rather
hard-real
reahim.e
21.5.2
implicitly-for
posed
sanl.e
risking
sections-portions
nonpreernptive
preemplenable
preempt_disable
interrupt-control
disassemble
recursive
halves
bottom-half
top-half
21.5.3
bkl
memory-pages
lto
21.6.1
zone_dma
zone_normal
zone_highmem
isa
zonldma
4-gb
intel80x86
priinary
physical-memory
lil
lux
lntel80x86
allocatable
partner
region-a
partners
buddy-heap
ultim.ately
allocations
ncade
21.6.2
kmalloc
8kb
16kb
4kb
arbitrary-sized
splits
clainled
reallocate
21.8.1
limn
nonoverlapping
page-aligned
vm_area_struct
lookllp
laintains
pagetable
software-interrupt
page-management
21.6.2.1
demand-zero
viewport
21.6.2.2
concplete
brand-new
absolutely
21.6.2.3
inemory
paging-the
whole-process
pageuut
multiplepass
youthfulness
valuing
next-fit
page-not-present
21.6.2.4
architecture-dependent
modifiable
vmalloc
vremap
21.6.3
loadil1.g
files-a
elf
extensibility
confused
21.6.3.1
21.6.3.2
elf-format
lower-numbered
contail1
brk
-sbrko
program-counter
executables
commence
ltl.emory
position-independent
pic
system-ext2fs
ldividual
file_operations
irnplementation
havil
linuxmaintains
21.7.2
ext2fs
minix-compatible
severely
14-character
file-name
extfs
redesign
linuxs
a.7.7
disk-allocation
per-request
densities
geometry
nondirectory
preallocates
in.terleaved
unset
compensated
21.7.3
journat
concpleted
non-journaling
unux
persistently
corresponded
asch
plain
unprivileged
parses
structu.re
global-rather
process-specificinformation
ode
pro
deregister
tree-appearing
directoryis
file-devices
1etwork
llne-l
dlsciptlne
.
laying
access-block
pointil1.g
wl1en
unidirectional-elevator
starting-sector
rernoved
ncanager
uler
queues-a
expiration
21.8.2
lim.jx
preprocessing
tty
feeds
glues
detaching
encoding
network-device
21.9.1
sigrl.als
ruml.ing
t_queue
wake
synchronizes
21.9.2
virtual-filesystem
interprocess-communication
virtual-address-space
unix-to-unix
non-unix
server-class
a.9.1
sown
reporting
retransmission
reassemble
skbuff
trim
outstripped
icmp
in-order
networking-device
networking-protocol
kernel-loadable
injects
network-device-driver
routing-configuration
wildcard
route-caching
wildcards
management-selective
filtering
chains
firewall-decision
disassembly
ipfrag
ipq
keyed
address-port
unacknowledged
out-of-order
21.11.1
publicly
transformation
deduced
lmauthorized
pam
sessionsetup
password-changing
21.11.2
gid
uids
conferred
modes-read
execute-are
lpr
user-id
waiving
fsuid
fsgid
killed
another-a
comm.ercially
vacuum
mechanisms-message
memory-and
obeys
device-oriented
cloned
architecture-specific
disk-layout
cross-reference
listil1.gs
browsable
crossreferenced
linux-hq
2.x
lil1.ks
archives
how-to
guides
tips
internet-based
expandil1.g
newbies
newcomers
maj
ordomo
vger
rutgers
32-i
successor
cooperated
application-programming
october
cutler
charter
planned
nts
webbrowser
february
x.soo-based
plug-and-play
zero-configuration
photography
wil,dows
logged-on
appropriate-so
premium
mernbers
webserver
datacenter
ia32
ia64
microsoffs
22.2.1
adherence
c-2
investigate
vuh1erabilities
22.2.2
maturity
63,000
reviewing
rigorous
furthermme
health
22.2.3
quirks
masked
bug-for-bug
previuus
xpf
releasesf
thunkingf
conversionf
similarlyf
thunking
additionf
interix
compiles
22.2.4
cache-line
kernel-based
code-path
functionsf
per-processor
coloring
lock-free
interlocked
highperformance
dispatcherf
symmetrical
22.2.5
emulate
windowsf
22.2.6
processor-dependent
bolstering
isolating
ia32-compatible
multiplatform
22.2.7
locales
nls
customs
acc01mt
unicode
ansi
localize
auth.entication
manq.ger
22.3.1
hardware-abstraction
required-it
configuring
motherboard-specific
22.3.2
oriented
22.3.2.1
ncemmy
llling
managencent
22.3.2.2
cpu-usage
standby
allotted
skips
quantum-end
dpc
real-tince
22.3.2.3
defsemaphore
gate
timeouts
polls
22.7.1
22.3.2.4
dpcs
device-interrupt
queuing
lsrs
deviceinterrupt
expirations
isrs
itencs
22.3.2.5
architectureindependent
misalignment
page-read
neve
d.,.
infamous
blue
trap-handler
interrupt-service
irqls
interrupt-dispatch
processm
irql
3-26
interprocessor
irq
22.3.3
22.3.3.1
opaque
local-communication
perrnanent
query.jlame
,parse
jlame
parse
whack
slashes
-most
-device
mitiates
object-manager
namespace
translatilcg
nicknamesor
aliases-for
aliases
basenamedobj
attencpts
redirector
supervise
confers
whert
out-of-process
contexts
charging
refusing
authenticates
impersonate
user-modeaccessible
access-token
audited
22.3.3.2
page-based
la32-compatible
la32
page-frame
hyperspace
session-specific
terminal-server
3-gb
sql
consumes
decommits
pae
awe
redefines
read-write-execute
no-access
overruns
pdes
pde
pte
self-maps
self-map
page-directory
sii
ptes
1,023
concatenating
globat
secondlevel
ta64
software-trap
rnapping
8-tb
zeroed
zero-on-demand
prefetched
page-file
zero-ondemand
processs
pies
trimmed
trims
adjusts
determin.ed
iterating
splay
22.3.3.3
kn.owledge
refinements
affinities
ntdll.dll
cross-process
signal-like
notifications
process-manager
injected
impersonation
22.3.3.4
nlodel
environn
ental
plug-andplay
publishes
connection-port
corn1.ection-port
charn1.el
client-to-server
server-to-client
tecl111.iques
teclu
ique
window-manager
event-pair
subsysten
22.3.3.5
completions
irp
beneath
instancing
forncat
wdm
lays
richness
device-specific
22.3.3.6
vacb
vacbs
256-kb
2-mb
s-entry
noncached
irp-based
pinning
unpin
prefetches
openfile
file_flag_sequentialscan
prefetch
telling
accumulates
cachewriter
cache-flush
fast-writing
cache-writer
flooding
retransmitted
redirectors
backlog
22.3.3.7
centralizing
user-accessible
srm
tokens
security-event
22.3.3.8
plug--and-play
pnp
resources-primarily
ranges-has
proliferation
pcmcia
docks
hot-pluggable
add-device
start-device
query-stop
query-remove
pccard
surprise-remove
promoting
quicker
low-power
retention
pushes
hibernate
underutilized
22.3.3.9
hives
hive
system-hive
last-known-good
22.3.3.10
ntldr
smss
winlogon
csrss
lsass
pre-loading
lay
hibernation
vironm.en
subsysten1
mixing
categorizes
character-based
transforms
characterbased
clipboard
22.4.1
vdm
hog
throttles
22.4.2
win16
wow32
graphical-device-interface
gdi
subroutines-converting
thunlcing
tlueaded
receivil1.g
wi11.dows
corrupting
win16application
wmdows
conti11.ues
il1.stalled
22.4.3
il1.struction
calls-just
wow64
achieves
22.4.4
robushl.ess
validates
shims
-though
interoperability
22.4.5
psxss
psxdll
22.4.6
n1echanism
intercept
shadow
fat16
floppies
22.5.1
1.6-gb
16,000
17mb
wo11ld
multiplying
lcn
shortname
iprop
thumbnails
file-query
attributes-or
-one
48-bit
22.5.1.1
reorganizing
22.5.1.2
22.5.2
sck
data-structure
undoing
user-file
undamaged
---l
log-file
in-progress
22.5.3
component-by-component
22.5.4
ftdisk
22.5.4.1
ilcns
128001-7833611
logical-volume
22.5.4.2
interleave
lcns
0-15
16-31
32-47
48-63
64-79
80-95
ar01md
22.5.4.3
stripes
byte-wise
recalculation
equal-sized
22.5.4.4
22.5.4.5
sedor
spares
substitutes
reconstructs
22.5.5
tlles
data-compression
algoritln11
decompresses
gaps
virtual-duster
zero-fills
key-recovery
22.5.6
supplant
22.5.7
content-indexing
re-indexed
filereplication
22.5.8
i11terprocess
22.6.1
3com
ndis
tdi
reasoning
connection-based
22.6.2
22.6.2.1
server-message
corldection
22.6.2.2
netbios
becmne
network-programming
22.6.2.3
workgroups
22.6.2.4
network-management
snm
host-configuration
dhcp
22.6.2.5
multi-protocol
22.6.2.6
novell
ovell
etware
spx
nwlink
22.6.2.7
web-distributed
authoring
webdav
http-based
collaborative
22.6.2.8
ocoi
22.6.3
distributed-processing
mailslots
22.6.3.1
22.6.3.2
na1ned
unc
server_name
share_name
22.6.3.3
mailslot
22.6.3.4
winsock
winsock-compliant
22.6.3.5
ake
procedure-a
routine-which
argunlents
computing-environment
22.6.3.6
marshal
unmarshal
stubs
return-value
unmarshaller
22.6.3.7
jbjecj
utilizing
22.6.4
locat
detait
mup
remote-system
multi-provider
22.6.4.1
22.6.4.2
autonlatically
airplane
redirected
esc
online
tinle
22.6.5
laboratory
school
realm
trusts
transitive
22.6.5.1
forests
bell-labs.com
research.bell-labs.com
pez.bell-labs.com
children-domains
pez
bell-labs.conz
andlucent.com
forest
22.6.5.2
cross-link
cut
cross-linking
authentications
22.6.6
,.,.,cu
doncain-based
domain-based
information-technology
uniformity
intellimirror
22.6.7
www.bell-labs.com
135.104.1.14
broadcast-name
lmhosts
name-to-if
lease
renew
renewed
security_attributes
sa.nlength
sa.lpsecuritydescriptor
sa.binherithandle
a_semaphore
comand_line
ostrstream
ostring
command_line
_process
xxx
createxxx
invalid.j1andllvalue
22.7.2
securities__attributes
blnheri
thandle
inheritable
binheri
1nay
distinct-and
differentobjects
lpszname
mysem1
b_semaphore
opensemaphore
semaphore_all_access
openxxx
duplicatehandle
22.7.3
process_a
openprocess
process_all_access
process_id_of....a
getcurrentprocess
&b_semaphore
duplicate_same_access
unsynchronized
beginthreadex
22.7.3.1
getmodulehandle
de-reference
normal_priority
high_priority
levell3
time_priority
level24
idllpridrity
setpriori
tyclass
cbserver
realtime_
pridrity
realtimlpriority_class
22.7.3.2
panel
22.7.3.3
setthreadpriori
thread_priority
_lowest
_below_normal
_normal
_above_normal
_highest
designations
_idle
thread_pridritltimlcritical
setprocesspriori
tyboost
22.7.3.4
resumethread
tializecri
ticalsection
entercri
leavecri
kernel-synchronization
22.7.3.5
fibers
tin1e
legacy
fiber-execution
convertthreadtofi
ber
createfiber
swi
tchtofiber
deletefiber
22.7.3.6
instantiation
queueuserworkitern
waitable
registerwai
,and
createtirnerqueue
createtirnerqueuetirner
reusing
timer-callback
devote
22.7.4
lnterprocess
postmessage
postthreadmessage
sendmessage
sendthreadmessage
sendmessagecallback
.posting
post
wm_copydata
copydatastruct
buf
virtualalloc
ox1000000
mem_reserve
mem_top_down
age_readwrite
ox800000
mem_commit
page_readwrite
decommit
virtualfree
mem_decommit
mem_release
getmessage
22.7.5
heaps
thread-local
22.7.5.1
ox10000
virtuallock
setprocessworkingsetsize
22.7.5.2
multistage
oxffffffff
file-mapping
somefile
generic_read
file_share_read
file_share_write
hmap
sec_commit
shm_l
unmap
22.7.5.3
1-mb
heap-management
heapcreate
heapalloc
heaprealloc
heapsize
heapfree
heapdestroy
heaplock
heapunlock
22.7.5.4
strtok
strt
per-thread
declspec
cur_pos
var_index
t1salloc
t1ssetvalue
var
t1sgetvalue
t1sfree
design.ed
extensible
winl6
internationalization
cu1.d
budgets
windows32
conducive
teclllliques
tate
six-volume
quarterly
wealth
iseminger
richter
one-of-a-kind
flavor
i11.to
microcomputers
handhelds
massachusetts
operatirlg
osx
looms
frah
graphically
frauenfelder
twentieth
1940s
labor
alan
turing
blurred
stored-program
offspring
ferranti
rojas
hashagen
ceruzzi
consoles
punched
23.2.1
lil1.e
linkers
reusability
subroutine-called
driver-was
paper-tape
writil1.g
fortran
cobol
unloading
punch
sat
cooling
investments
23.2.2
twofold
dumping
observing
moni
loj
ftn
ftn-execute
asm-execute
run-execute
tvw
job-first
end-final
defirte
charged
dollar-sign
colun
jcl
slash
card-deck
carrying
insh
uctions
control-card
an.d
continuity
sequencing
elim.inates
licrosecond
exacerbated
23.2.3
punches
pri
n.ted
lilce
mam
iine
plotters
reader-to-tape
tape-to-printer
however-a
hand-carried
preparation
card-reader
cmttpleted
acronym
spooler
england
fuce
remarkable
drum
british
98-kb-word
512-word
memory-accessing
iff
t2
lichtenberger
pirtle
xds-930
user-monitor
ltlode
256-word
chained
mckeag
technische
hogeschool
eindhoven
netherlands
27-bit
employing
agents
512-kb-word
layer-structured
paged-segmented
danish
regnecentralen
levels-comprising
kernel-were
itl.echanism
send-message
wait-message
send-answer
resul
wait-answer
wait-event
previous-buffer
next-buffer
get-event
36-bit
5-kb
multilevelfeedback
vyssotsky
e-sharing
honeywell
pagedsegmentation
18-bit
1-kb-word
comprised
300,000
spanning
mealy
unblocked
incomprehensible
hampered
segmented-paged
konigsford
anticipation
tiine-sharing
tso
cms
meyer
seawright
parmelee
died
desks
rivalry
outdo
amigaos
nontechnical
freiberger
swaine
ancestry
accent
developedatcarnegiemellon
rashid
robertson
1989l
1987b
4.3bsd
evolutionary
4.2bsd
encore
multimax
sequent
unix-specific
evicted
intet
propelled
forefront
brainchild
fame
competed
operati.j.l.g
l.jn
1exibility
memory-objectmanaging
buik
levet
system.programming
multi-cpu
surprisingly
littered
faded
marketed
consistently
discrepancy
conclusions
fade
baron
golub
proceedings
summer
usenix
conference
93-112
a.-r
kozyrakis
saha
unlocking
24-33
1-20
equality
voh.une
39-42
lapid
777-780
glance
volmne
ald
tutorial
15-24
salem
rearrangement
182-189
winter
281-287
shared-money
distrib
sysl
6-16
lazowska
1631-1644
symposium
operati11g
95-109
dahlin
neefe
roselli
wang
serverless
109-126
ande1
son
vahdat
interposed
implementalion
addison-wesley
thana
superdense
25-31
audsley
richardson
wellings
workshop
base-rate
fa.llacy
detection
procwiings
commuuications
55-96
prentice
hah
tullman
stoller
hsieh
lepreau
annual
confermce
al.1991
m.g
m.d
k11pfer
shirriff
uusterhout
distribl1ted
tjnzposiwn
198-212
lvi
karge1
stoica
43-48
locking
kernel
261-270
1-12
basu
buch
vogels
eicken
u-net
tlze
sy1nposium
191-192
l.a
virtual-storage
78-101
lady
shedler
349-353
comnzunication.s
reuiew
32-48
nasa
applimtions
10-17
time-stamp-based
285-300
hadzilacos
non-blocking
264-273
37-55
pard
yak
fiuczynski
becke1
eggers
chambers
spln
stjstems
267-284
mutlithreading
sigplan
21-27
birrell1989
dec-src
implementing
198,1
39-59
scheduling
35-43
bobrow
al.l972
j.d
burchfiel
murphy
tomlinson
tenex
pdp-10
co111munications
eta
fitzgerald
douceur
ttger
vtdeo
.fileserver
symposiwn
212-223
object-caching
87-98
vmem
nix
kemel
oreilly
limtx
ent
.first-fit
388-403
management
-practice
771-780
com7
1ltnications
238-241
structured
multiprograrm11ing
574-578
bri.nch-hansen
marshall
the
newcastle
unixes
unite
1147-1162
mutual
sigact
42-47
posjx
pe7formance
trill
cantril
leventhal
dynamic
instrumation
wsc
ock-a
algoritlun
87-95
carvalbo
roucairol1983
carvallio
on
146-147
63-75
n-philosophers
networlcs
71-76
programming
28-50
feeley
single-address-space
system
271-307
raid
145-185
314-333
m.a
malcolm
len
sager
thoth
105-115
rubin
repelling
wily
hacker
cheung
loong
4-16
60-74
elphick
shoshani
67-78
141-160
internetworlcing
intemetworlcing
afips
185-196
merwin-daggett
aflps
335-344
carmen
cormen
leiserson
stein
dollimore
addison
wesley
heymans
readers
writers
667-668
gupta
morgan
kaufmann
publishers
karger
cfs
202-215
121-128
dermis
87-96
55-62
137-138
deitel1990
323-333
se-6
64--84
derming
27-35
cryptosystems
conzmunications
388-392
227-249
589-602
mu.ltiprogrammed
computations
h3-155
pietro
wearable
communicalions
74-79
hellman1976
644-654
diffle
397-427
teclmical
teclmological
341-346
acta
informatica
115-138
mackerras
yodaiken
tricks
doughs
757-785
caceres
taube1
25-37
krishnan
spin-down
121-137
fbufs
high-bandwidth
189-202
comm.ents
dijksh
se-5
458-464
engelschall2000
lorie
624-633
zhang
carter
mckee
reevaluating
superpage
promotion
witl1
high-pejformance
65-70
april
65-71
28-33
113-128
478-490
folk
zoellick
slructures
hofmey1
longstaff
ntx
lite
sy1uposiwn
120-128
handbook
mccraw-h.ill
ofcol
lpuling
histon
carlton
denser
jnfosyslcms
valley-the
mcgraw-hill
1991
47-59
revolution
546-554
write-on
schimmel1998
canapathy
gange1
engle1
briceno
hunt
pinckney
fast
49-83
elections
volum.e
c-31
schwartz
lntemel
chemawat
gobiof
s.-t
1nposiwn
1997a
nagle
amiri
cobiof
rochberg
zelenka
filesystem
carnegie-mellon
al.1997b
feinberg
gobio
ozceri
andj
scaling
measurement
272-284
sealing
infonnation
comnw.nications
274-286
peirls
bloch
bow
beer
holmes
lea
goldberg
brewe1
helper
6th
syrnposiwn
colden
222-230
staelin
sullivan
sloth
201-212
cohn
felser
wawersich
kleinoder
computini
nwnber
muelle1
prafullchandra
schemers
synzposium
vernon
woest
cache-coherent
operaling
sterrjs
64-75
joy
steele
tlzejava
covindan
68-80
crampp
1649-1672
notes
bayer
393-181
the
virtues
limitations
144-154
lnlerprocess
p.r
blasgen
223-2-12
telecomnnmimtion
62-66
habermann
373-377,385
hallet
shmoys
wein
soda
acm-s
discrete
vranesic
zaky
process-migration
mob.ile
networks
365-378
harchol-balter
exploiting
253-285
harish
brede
pattison
santana
taft
imwvation
677-689
ruzzo
ullman
systems
communicatio11s
461-471
tlzird
zebra
ansactions
274-310
joumal
74-84
m.s
johri
aditham
wei
133-146
he1messy
quantitative
scheduler
labomtories
745-770
twentiefh
intemational
architeclure
lau
netapp
tedmology-a
60-68
perrott
61-71
concepf
comllwnications
ofl-lie
549-557
comments
conmiunicalions
36-38
surve
179-196
yarning
apress
kazat
menees
nichols
sidebotham
55-81
payne
sunmer
226-229
kerr
maclnick
y.-c
pe1-rig
spv
bgp
sigcomm
johnson
ariadne
columbus
chicken
statute
bonehead
legislation
greene
osborne
200-209
intel1985a
iapx
intel1985b
intel1986
intel1990
i486
lntel1993
software-mm1aged
60-75
33-43
hewlett-packard
jensen
locke
tokuda
time-driven
112-122
johnstone
26-36
expressing
nmnber
358-367
hutchinson
emerald
109-133
engler
mazieres
grimm
jannotti
mackenzie
52-65
lauder
44-55
kenah
goldenberg
bate
lynn
seo
border
secure-bgp
comrnunications
582-592
kerrville
kenv
lle
nltmber
21-26
an
500-503
se-4
467-477
expressions
syslems
78-96
sumner
222-225
i-l
requests
volw11e
214-229
coda
3-25
interscience
303-328
623-624
321-322
koch
352-370
aingaran
olukotun
niagara
32-way
21-29
reisinge1
nbw
synchronisation
131-137
limitations
petri
nets
122-126
starch
retaining
suid
usenjx
107-118
bindel
czerwinski
eaton
geels
gummadi
rhea
weatherspoon
weimer
wells
zhao
oceanstore
global-scale
networking-a
top-down
intemet
progra1mning
453-455
synchronization
processes
15-34
concurrent
806-811
multiprocess
95-114
1978bj
558-565
lnsecure
cornmunicalion
770-772
comnumimlions
313-348
excll
sion
1-11
connmmicalions
shostak
progrmnming
382-401
stmctures
27-38
princeton
437-443
conzmunicntiohs
613-615
redell1979
7th
sosp
43-44
landweht
247-278
systems-toward
ifjp
155-160
larson
kajla
670-677
melhem
mosse
ti-ansnctions
49-53
petal
84-92
karels
break-ins
584-585
lehoczky
sha
ding
yionotonic
behaviour
10th
sijstenzs
stjmposiwn
lempel1979
cryptology
286-303
mcauley
roscoe
barham
evers
fairbairns
hyden
1280-1297
15-28
corwin
pollack
policy
132-140
backers
penguin
progrmmning
jaw
lvl
experimentation
man-machine
joirll
589-598
virtuallvlachine
specificalioll
mullen
lin
31
nltmbet
lipne1
comment
stcm
192-196
phd
thesis
liskov1972
conunur1.ications
144-149
layland
schedulingalgorithmsformultiprogramming
environment
conmnmicalions
46-61
lobel1986
foiling
breakers
comnnmicalions
56-61
freudenberger
arzes
lichtenstein
odonnell
ruttenberg
multiflow
compiler
1-2
51-142
giant
american
eagle
email
extracting
ansnctions
145-159
mahet
goldick
kerby
zumach
viass
27-31
markatos
first-class
threads
13th
110-121
gecsei
slutz
78-117
mcdougall2007
solar
arcl1itecture
mccanne
ltsenix
259-270
multi-core
here
32-39
jntemals
programs
1-9
mckeon
129-138
imple
111cl1talion
l11e
frcebsd
unlx
transaclions
slcms
181-197
bostic
montecito
ltanium
10-20
extent-like
33-44
witt
clark
21-65
bases
195-202
merce1
tim.edia
90-99
199-218
an
421-434
paindaveine
wheele1
zhou
survcljs
241-299
names-concepts
c01
1it
teclmology
15-21
volm11e
594-597
co1mer
rosenthal
184-201
risc
mullendej
beigl2003
27-29
lyer
cox
superpages
1-10
welch
134-154
nutl2004
87-208
nurnber
crunch
volmtte
93-96
oss
25th
anniversary
commemorative
costa
kunze
kupfe1
trace-driven
cherenson
network-operating
23-36
susarla
whinston
tillman
hatfield
99-130
181-183
patil1971
228-234
estimating
754-763
myths
421-431
edler
anshus
douglas
archit
programrning
60-71
gill2003
22-33
arclzilecturc
vmin-an
295-297
70-76
software-practice
923-940
purdorn,jr
ands
propertieso.f
683-697
1289-1299
rago
prograrmning
rig
eee
conm1unication-oriented
cathedral
bazaar
raynal1986
raynal1991
47-50
singhal1996
49-56
issltes
69-74
iria
tntemotional
197-210
dalal
horsley
lauer
lynch
mcjones
murray
purcell
communimtions
a.cm
81-92
3-23
eventcounts
115-123
rcgeh.1
reflections
103-105
com1nunications
9-17
270-274
faloutsos
mining
24th
lnternntional
62-73
immnitchi
foster
nenqork
on
120-126
conmtunicntion
concurrenct
bsdcon
schroedet
.reconfiguration
autonet
opeml
systenzs
183-97
rosenblum
symposiunt
1-15
stearns
178-198
shuffling
proceedin8s
wiuler
confereuce
405-120
volttme
nttmber
17-29
rush
mposiwn
opemti11g
srjstcujs
12-21
randell1983
55-67
microsofl
1278-1308
walsh
lyon
nelwork
filesystem
119-130
110-117
9-21
wetherall
karlin
traceback
295-306
schell1983
47-53
141-147
schneide1
synchwnization
125-148
sclmeier
466-474
causal
holy
grail
149-174
password
wits
conummicalious
700-704
cl1en
revisited
tlic
313-323
seltze1
usenfx
307-326
mcmains
padmanabhan
usen1x
249-264
692-697
pallipadi
mallick
fntd
korth
reflections
143-154
silvers
ubc
conference-freenjx
tracie
sim.mons
304-330
singhal1989
37-48
202-216
473-530
cache-miss
161-203
garg
zheng
lai
shao
ziskind
segank
crisis
aftermath
678-687
sigops
18-35
metropolitan
softvvare
strategic
751-763
staunstrup
staunsh
223-234
68-84
nintlz
30-32
programming-volume
inter
abdei-wahab
jeffay
baruah
gehrke
plaxton
real-tim.e
sugerman
venkitachalam
lim
virtualizing
hosted
network-based
353-398
hill
khalidi
mille
commodity
tmplementation
419-470
steen2002
woodhull1997
riders
68-79
177-184
cooper
yolmg
sanzi
teva.nian
maim
ailed
frangipani
224-237
761-763
programming
213-239
58-74
galtieri
323-342
tudor
coloquium
frontiers
hsu
locality-preserving
fourteenth
131-138
venners
23-32
lucca
efficient
203-216
1993b
lucco
lsolation
wallach
balfanz
felten
autorald
transacl
108-136
networ
schedlller
freen
neely
boles
jntcnwtional
mmwgcment
1-116
wolf
codesign
38-43
hayden
controllability
controlled-share
se-12
1041-1048
patt
algoritlm1s
measurernent
241-251
extraction
sigmetrics
146-156
wul
175-181
harbison
howes
kille
cormnents
eppinge1
duality
63-76
gum
trading
243-258
securing
worlcshop
hermesy
kaufmam1
reprinted
adapted
vol
no.3
publishing
pentiwn
halsall
hanna
francisco
451-454,14.1.1
471-742,14.1.3
476-479
482-485
512-513
517-518
523-524
613-617
617-622
lobaset
876-877
loobaset
841-843
598-602
605-606
602-605
606-607
440-443
sense-code
qualifier
318-319
319-320
824-825
793-794
process01
202-203
buddy-system
471-479
471-473
476-477
473-476
477-479
398-399
718-723
721-722
722-723
720-721
136-137
565-571
567-568
570-571
569-570
568-569
658-660
66-67
56-57
fc-al
12-18
16-18
13-16
12-13
642-643
854-855
911-912
733-736
257-267
261-262
262-267
264-265
262-264
265-267
257-260
260-261
622-623
zero-day
breaching
643-645
work-set
xplt
4-6
automount
autoprobes
607-608
519-520
539-540
bayes
theorem
653-654
nl.odify
335-336
maplt
black-box
blade
432-433
566-568
526-527
diskt
89-90
122-123
39-40
879-880
linuxlt
572-574
627-630
748-749
bus-mastering
483-484
713-714
711-712
484-485
870-872
609-610
166-167
-ies
607-610
607-609
carrier
csma
cav
angular
velocity
836-837
792-794
cipher-block
292-294
296-297
cli
447-448
csc
35-36
696-697
clv
interprete1
52-53
65-66
327-328
472-473
610-613
782-784
884-885
678-679
34-37
34-35
30-31
25-26
11-13
24-25
7-9
23-24
29-30
32-34
33-34
32-33
9-11
25-29
26-27
633-638
736-740
736-739
739-740
conditional-wait
811-812
conservative
486-487
consolidation
cay
689-690
199-200
582-583
556-557
direct-memory-access
367-369
15-16
315-317
184-185
schedule1
bout
183-184
187-199
187-188
213-217
188-189
feedback-queue
198-199
196-197
192-193
194-196
189-192
213-215
786-787
200-206
185-186
768-774
schedufu1g
772-774
769-771
110-115
227-229
229-230
234-239
235-238
238-239
234-235
231-234
638-639
639-646
646-647
647-649
914-915
486-490
tluead-specific
data-encryption
677-678
dcom
740-747
294-300
safe-state
295-296
301-304
742-747
303-304
301-303
290-291
285-286
285-287
740-742
290-294
291-292
no-preemption
304-306
304-305
305-306
283-285
287-289
84-88
84-85
85-88
delay-write
delegation
361-367
362-364
404-405
400-401
365-367
prepagil
399-400
402-403
restartil1g
364-365
401-402
demilitarized
697-699
lilmx
805-808
68-69
849-851
device-management
107-108
574-575
645-646
242-244
248-249
431-432
563-564
controlle1
434-444
443-444
470-471
436-437
tree-sh
uctured
438-440
437-438
505-507
482-483
506-507
516-517
479-481
mini
509-510
483-486
534-535
510-516
511-512
513-514
515-516
883-884
787-789
740-7
747-750
727-730
730-732
algorithncs
750-752
705-706
707-710
710-715
contd
714-715
716-718
715-716
449-450
dlm
677-679
888-889
673-675
675-677
891-892
downsizing
580-581
810-811
dual-booted
dumpster
diving
320-321
storage-allocation
787-788
lime
eide
78-79
651-652
641-642
850-851
mem01y
525-526
765-766
165-166
826-827
493-494
694-695
533-534
734-736
negatives
positives
475-476
881-884
903-904
896-897
373-375
421-422
430-433
422-423
429-430
425-427
l123-427
451-456
455-456
434-435
427-428
446-451
450-451
446-447
448-450
448-449
461-463
imple1nentation
464-470
467-468
468-470
828-834
487-488
444-446
490-496
496-498
676-677
869-870
661-662
folders
812-814
forward-mapped
628-629
382-385
384-385
383-384
485-486
479-482
vectm
479-480
480-481
481-482
745-747
38-39
guis
52-54
green
728-729
120-121
556-565
563-sm
560-563
332-334
heavyweight
337-340
high-availability
hijacking
873-874
326-327
homogeneity
915-917
ike
life-cycle
69-70
764-768
765-768
764-765
709-710
information-maintenance
9-10
315-316
intellimirrm
345-348
defined,565
116-123
128-140
131-134
128-130
837-838
124-126
119-120
123-124
117-119
127-128
8-9
818-819
interrupt-controller
20-23
766-767
interrupt-request
656-658
intrusion-prevention
ipss
340-342
395-396
909-911
50-51
571-578
supervised
577-578
555-556
576-577
571-572
575-576
834-837
835-836
580-582
582-585
578-580
692-693
425--426
164-165
102-103
866-867
832-833
784-786
228-229
762-764
817-819
852-856
396-399
809-812
809-810
keystreams
logger
610-615
71-73
directory-access
least-frequently
592-593
376-378
38-40
801-843
95-97
830-832
829-830
801-806
804-805
802-804
805-806
820-828
820-823
823-826
838-840
348-349
812-815
814-815
815-820
815-817
819-820
211-213
840-843
rnanagernent
256-257
173-174
807-808
livecd
livedvd
balancers
203-204
loade1
826-828
679-681
868-869
61-62
425-426
241-242
loopback
782-783
378-380
message-authentication
73-74
919-920
918-919
535-536
324-325
325-327
316-318
346-348
nwnagement
328-341
329-332
336-337
342-345
3ll2-345
344-345
322-324
737-738
mans
metropolitan-area
158-159
157-158
505-508
522-532
531-532
524-529
522-524
520-522
534-543
tedmology
536-537
536-538
539-543
matchmakers
920-921
ncain
898-899
862-863
390-396
391-393
827-828
393-395
mems
micro-electronic
148-152
metafiles
73-75
minidisks
miniport
74-76
244-252
resumption
250-252
245-247
634-636
most-frequently
492-493
783-784
875-876
204-205
156-157
596-598
779-780
780-781
781-782
789-792
multiple-coordinator
universal-naming-convention
14-15
206-208
208-211
ntulticore
205-206
18-20
n10dels
157-159
168-170
170-171
167-168
fully-distributed
857-858
120-122
685-686
national-language-support
near-line
netbiosextended
690-694
684-690
688-689
699-701
694-697
small-area
683-684
679-680
886-892
889-891
494-495
nonrepudialion
10-11
878-880
602-603
857-860
embedding
ole
olpc
37-40
dosed-source
5-6
904-911
905-906
906-909
3-6
i1nplementation
21-23
time1
allocatm
49-52
70-75
70-71
4-5
52-55
374-376
orphan
elimination
out-of-band
overprovisioning
380-381
.fault
page-fault-frequency
pff
390-391
369-381
370-373
ptlr
825-826
pluggable
parallelization
325-326
649-653
652-653
650-651
439-440
scopet
541-543
539-541
persistence
phishing
357-358
110-111
134-140
137-139
134-137
505-506
872-873
sec
pptp
portals
positioning
premaster
254-255
813-814
751-752
115-116
105-110
101-102
104-105
103-104
process-control
60-64
833-834
812-813
225-227
242-24l1
253-255
255-256
profiling
85-86
625-633
bombs
625-626
630-633
mah
systen1s
593-598
594-595
595-596
591-592
51-52
retrofitted
886-887
160-161
200-201
105-108
105-107
913-914
790-792
759-760
763-764
760-762
762-763
774-776
489-490
880-881
reed-solomon
332-333
674-675
537-538
allocato1
749-750
654-656
roaming
linuxt
diskst
687-688
cmmected
298-299
697-698
788-798
108-109
199-201
853-854
895-897
kiddies
computer-systems
378-379
sign-on
662-664
654-661
660-661
621-625
634-637
638-649
649-654
664-665
secu.rity
security-through-obscurity
seeds
cluste1
server-message-block
shortest-seek-time
656-657
821-822
274-280
system-on-chip
521-522
406-407
sparseness
spoofed
910-911
stack-overflow
stalling
904-905
882-883
symbolic-link
55-58
55-56
88-89
m.aster
364,862
concentrators
110-116
386-387
ategy
387-389
153-156
171-173
894-897
159-165
159-160
162-163
257-258
258-259
863-864
tcpiip
20-21
658-659
twofish
733-734
usbs
450--451
unreliability
npcall
50-55
vads
208-209
vforko
76-84
77-78
76-77
81-82
357-360
conserving
84,7-849
lttechanisms
892-899
897-898
893-894
877-878
851-874
405---406
857-874
managet
860-866
680-681
wirte-on-close
read-many
741-742
write-end
zipped
zombie
france
ashing
worki1cg-set
405-406
droppe1
80-82
881-882
clipping
681-683
847-848
847-900
849-850
874-878
wi.n32
878-885
878-879
