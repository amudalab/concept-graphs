data structures and algorithms dr naveen garg department of computer science and engineering indian institute of technology  delhi lecture 3 queues and linked lists in the last lecture we looked at stacks as a data type we saw how to implement stacks using an array today we are going to look at queues and linked list and in the later part of the class  we are going to do sequences in particular the first part of the class i am going to do queues  linked list and double ended queues what is the queue and how does it differ from the stack the stack followed the last-in first-out principle  the element that was inserted last in to stack was the one that was removed first queue on the other hand follows the first-in-first-out principle whoever joins the queue earlier is the first to be removed from the queues that is first to be processed you are all familiar with the queues in a queue for instance there is a notion of a first element and the notion of the rear element when an element is inserted in to the queue  it comes at the rear if i remove an element from queue it is the element which is sitting at the front end would be removed we always insert an element at the end and when we remove an element it is always the element at the front is removed the queue is also an abstract data type and we can define a few methods on the queue the methods given in the slide are the standard operations the method new would create a queue and enqueue is the method to add an element to the queue and dequeue is to remove an element from the queue when you dequeue a queue or when you remove an element from the queue  you get another queue the front is the method which gives the first element of the queue how it does differ from dequeue it does not remove the front element  it only tell us which is the front element of the queue we also have some other support methods  to implement the queue one could be size and the other is isempty size would tell us how many elements are there in the queue and isempty would tell us whether the queue is empty or not it would return true if the queue is empty else it would return false just as we defined axioms for the stacks  you can define similar axioms for queues if i create a new queue and i insert an element or enqueue an element v and then when i say what is the element at the front of the queue it should be v and suppose i create a new queue and enqueue an element and then i dequeue an element  then i should get the empty queue which is the same as whatever obtained if i just called new similarly if i had a queue and i enqueued an element w  which means i added an element to the queue then i added another element v to the queue  thus w is ahead of v in the queue if i call front  first i will get all the elements of the queue  followed by w and then followed by v the element in the front of  q  w  is the element at the front of the queue why i have written front of  q  w  and not front of queue if i have just written front of queue  then it would not have been defined if a queue is empty then there is no notion of front of the queue that is why i have written front  enqueue  q  w    same thing as before in which i had a queue q  if i insert w in to the queue then i insert a v and then i removed an element the element which was at the front of queue would be removed  if the queue was empty then it would have been w the following operation is the same as in which i had a q  i added w to the queue then i removed an element from the queue  then i added v again the queue that i have obtained as the result of the below mentioned 2 procedures should be the same dequeue  enqueue  enqueue  q,w  ,v   = enqueue  dequeue  enqueue  q,w   ,v  let us check out whether the result is true let us assume that the queue was initially empty what does this statement dequeue  enqueue  enqueue  q  w   v   gives first i added w then added v and then i removed an element if i removed an element from the queue i would get w  that is w is removed then i get v as the remaining queue let us look at this enqueue  dequeue  enqueue  q  w    v   queue is empty  i added w to the queue then i removed an element and once again i have left with an empty queue then i enqueue v  thus the queue has v in it if queue is empty then in both the cases the queue will have only v in it at the end of the procedure if queue is not empty then i enqueued w  then i enqueued v again hence i have a queue in which first i have all the elements of q  followed by w  followed by v when i dequeued  i will be left with the original q without the front element  followed by w and then followed by v let us see if we get the same thing in enqueue  dequeue  enqueue  q  w    v   i started with q and i added w to it now i have queue which has q and w then i dequeued which means i removed the front element of queue the queue contains all the elements except the front element  then i have w in that queue and i added v at the end thus i get the same result how do we implement a queue we are going to use an array in a circular fashion to implement the queue what does it mean suppose someone tells that the queue is never going to be larger than n elements i am going to allocate an array of size n i am going to have 2 variables f and r  f for front and r for rear f is the index of the front element that is f will be referring to the front element of the queue r is an index which is the element following the rear element the blue part is the one which is occupied by the queue  refer slide time  08  11  how did the queue reach the blue colored part i would have started with the front that is the first element i inserted must have come to the 0th location then the next element i inserted must have come to the 1st location and the 3rd element must have come to the 2nd location and so on then i also delete the elements when i delete  an element goes away in effect the elements in the queue drift right and hence the front and the rear element has moved to right this implies that we have deleted f-1 elements it is not completely accurate i had said something like in a circular fashion what does the circular fashion mean and why am i saying such a thing let us say that we kept inserting the elements in queue i insert another element then i insert another element and at one stage i can not insert anymore elements because i have already reached the end of this array but i have a space available in the front then i will wrap around and start inserting the elements your queue in some point will look like the one which is given in the slide below the front was at the left of the rear but now front is at the right of the rear because we have queue which is now starting from the right side and going to the left side when i insert an element it will still come to the th r location and then to the next location and so on when we started the front was referring to 0th location that is f should have been at minus one  because the front refers to the first element of the queue if there is nothing in the queue then f should be minus one and rear refers to 0  because rear refers to an empty location what does if at some point i reach a situation when f = r is that empty or full what will happen when it becomes empty suppose if i kept removing the elements starting from the th f location  i did not add any other element and then i removed all the elements before th r location where f would be located f would be increment to r  so f becomes r when f is r  queue is empty suppose i kept adding the elements to the queue when i add  r will move one step  another step and so on when i add an element close to th f location  then r would be referring to f again f equals r we will add the th n element there is an ambiguity and we have to resolve it in some manner f = r means  both empty and full since we will have a problem  if you do not know whether the queue is empty or full we will try and ensure that we never had n elements to the queue when the queue has only n-1 one elements  we will declare it before that is what we are going to do let us look at the code for enqueue this is just pseudo code if the size of the queue or the number of elements in the queue is n-1  then we are going to stop and say that the queue is full and we will return the queue full exception otherwise if it is not the case then add the rear location  put the element that you are trying to insert and increment r the modn is required  because we need to do the wrap around since it is circular indices goes from 0 through n-1 only  r is already n-1 and i increment r at this r  r + 1  modn point then i do not want it to become n  but i want it to become 0 and hence modn is 0 and i will have it in r in the pseudo-code  size is the method and it should have been enclosed in brackets what does the method size do it returns  n-f + r  value why it should not return r-f r-f is negative in the setting which is given in the slide  but in the setting which is given in the slide  r-f tells me exactly the number of elements in the queue r-f is the correct thing except it might be negative how many elements are there in the queue which is given in the above slide it should be n r + f or n-f + r  which is anyone of these the quantity  n-f + r  would be the number of elements that you would get and this quantity is always positive  because r-f can at worst be minus n thus n + r-f would always be a positive quantity you can return this  n-f + r  as the size  as this will tell you the right number of elements check this out if you are confused isempty   is a method and we said queue is empty if f = r there was an ambiguity and we never had more than n-1 elements into the queue if f = r  that means the queue is empty and it is not full thus f = r returns empty also it returns true for this  algorithm isempty    method for front if the queue is empty then it raises an exception  otherwise just return a front element we are not removing the front element as we are doing it in the dequeue method in the case of dequeue method  we will increment the front index and remove the front element by setting q  f  null you can also implement the queue using a linked list we saw an array to implement our queue the disadvantage of using an array is fixed size if you know the maximum size that the queue can take then it is ok  but if you have no idea about the maximum size  then you could either use the method which we did in the last class were in when the size increases beyond what we have allotted  then we double the size of the queue you could either do that or you could use an implementation which uses a linked list what is essentially a linked list it has nodes and it has pointers which are basically referring to the next nodes in the list the first node is referred to as head of the list and the last node is referred to as the tail of list each of the nodes has some element or some data in it if i am going to use a linked list to implement the queue  then the question is which should be the front of the queue  whether the head node should be the front of queue or the tail node should be the front of the queue the head of the list should be the front of the queue  the tail of the list can not be the front of the queue why the tail of the list can not be the front of the queue why can not i have my queue in which the 1st element is this  the 2nd second element is this and the third element is this the problem is with removing  note that i can not remove the torcezo element the linked list does not permit me to do this can i remove the torcezo element from linked list not directly  because to remove that element i have to change the 2nd pointer but there is no way of accessing that pointer and hence i can not remove that element i can remove the rome element  there is no problem in it  but i can not remove the torcezo element in a queue the removal is being done at the front that is we remove the element at the front of the queue since i can not remove the element which is sitting at the last place and i can not call this as the front of the queue i would like to have rome as the front of my queue let us see how we are going to implement our methods suppose i have to dequeue which means that the front of the queue is the one which is at your left head part is the front of the queue and the tail part is going to be the rear of the queue if i have to remove the element at the front of the queue that is to dequeue  i should point the head to the 2nd node thus the front element will get removed and i just increment or just making the head point to 2nd node in this manner i can delete the head element very easily and also i can insert a new element to the head easily i just create a new node  connect the new node and make the head point to the new node thus inserting at the head is very easy the head is the front of the queue  i can just move the head to one step right and in that manner  remove the front element of the queue if i have to add an element  enqueue has to be done at the rear of the queue in the above slide  first diagram is my queue and the last element is the rear of the queue i need to add a new element at the rear end of the queue the pointer should now get modified to point to the newly added element and the tail should be update to the next node because that will become tail and the pointer after the rear element should be null i can always add an element at the tail but it is difficult to remove an element in constant time  because to remove the tail node  i need to access the previous node the only way you can to do in this kind of list is to start from the beginning and move all the way to the right till you get to the tail node then you will be able to access the previous node what is problem in removing in the tail node the problem is that after i remove the tail node  what is the new tail of the list it is the last before node  i have to make the tail point to that last before node how do i get to that last before node i need to go through the entire list  to get to this node i am not saying that it is not possible  but it is a very expensive operation it is not worth while to remove at the tail and so we will remove at the head and add at the tail  which means the front of our queue will be at the head and the rear of the queue would be the tail so far we have seen the queue data type now i am going to introduce another data type called double-ended queue what is the double-ended queue it is a queue in which we support  insert and delete operations at both the ends we have insert first which is to insert at the front of the queue  insert last is to insert at the end of the queue  remove first is to remove at the front of the queue and remove last is to remove an element at the end of the queue also we have the first and the last operations such a thing is called double-ended queue  at both the ends we can do both the operations of insert and delete a singly linked list is not a good idea to implement such a double-ended queue why because as i have said repeatedly  we can not remove the element at the tail or it is very expensive what is the good solution to this problem we are going to use doubly linked list to implement double-ended queues what is the doubly linked list a doubly linked list has nodes with two pointers  one is next pointer and the other is the previous pointer we are also going to have two sentinel nodes each node has two pointers  one pointing to the next and one pointing to the previous using such a list we can implement all the operations of double-ended queue in constant time the problem earlier was how to delete the node which is at the end the head and the trailer nodes are the 2 sentinel nodes i have a pointer to 2 sentinel nodes and to get to the last element  i just follow the pointer once and get to that element to delete that node  move to the previous port and set its next pointer to trailer and send the previous pointer of trailer to that node  we need header and trailer nodes in a doubly linked list these nodes are called sentinel nodes or dummy nodes because they do not contain any data inside them and they are just there to mark the start and the end this is useful how do you delete at the end i have to delete san francisco out of this list all i have to do is make the sentinel node point to the previous node and make that previous node to point to the sentinel node then the last node is deleted and in the slide the last one becomes my new list that was the only thing i could not do in a singly linked list and i have shown it here hence all the other operations can be done in constant time thus using a doubly linked list  we can implement all the operations of double-ended queue in constant time we can insert at the front  insert at the end  delete at the front or delete at the end all in constant time what is meant by constant time it is the time which is independent of number of elements in the list and your running time will not be depended upon the time double-ended queue is a fairly generic data type  it can used to implement other data types also suppose you had an implementation of double-ended queue and you can use that to make a stack or a queue let us see the implementation of a double-ended queue i can use the methods of this implementation to implement a stack for instance in the method top    the top element of the stack would correspond to the last element of our double-ended queue.thus the method top   would return the last element of the double-ended queue the method push   would correspond to inserting at the end of my double ended queue and the method pop   would correspond to deleting at the end of my double ended queue i could also make the last   to correspond to the front element of my double ended queue in that case the last   would have been my front and insert last  0  would have been insert front   and remove last   would have been my remove front    you can use it either way you like it size   just corresponds to the size of my double ended queue and isempty   corresponds to isempty of my double-ended queue because these are only dependent upon the number of elements in the queue similarly i can use a double-ended queue to implement the queue front   gives the first element of the double-ended queue  enqueue   corresponds to last that is it inserts at the rear when i say dequeue  it removes the first element of the double-ended queue if i have a dequeue implementation  i can use the methods to implement a stack or a queue or one of these data types we have used a double-ended queue to implement a stack or queue and this is an example of an adapter pattern thus adapter patterns implements a class using methods of another class in general  adapter classes specialize general classes and we can have certain applications one application is that we can just implement by changing some methods for example we can implement a stack by using a double-ended queue another application would be an implementation of a stack we define an interface called stack and implemented it using an array that implementation is called an array stack what are the contents of array stack they are any arbitrary objects and i can adapt arraystack implementation to an implementation called integerarraystack which only uses integer objects in it all i have to do is suitably cast the type of the objects that i am pushing in to the stack or removing out of the stack there is another data structures called circularly linked list and it is very simple in that the last element is pointing to the first element of the list.there are no 2 pointers head and tail that is there is only one pointer which is pointing to the start of the circular list and you can use the data structure which is given in the above slide to implement both queue and the stack how will you use this data structure to implement a queue in a queue we will make the first node as the front of the queue and the last node as the rear of the queue how will i add an element at the rear to add an element before the first node  make the pointer point to the first node and make the head point to  it is not straight forward because if you mean the big pointer then how you will make this to point to the new node you have just created we want to create a new node at the end make the element which you are inserting to go into the new node and create a new node and copy the element rome into the new node make the head point to that new node and copying is not costly because here you are copying only the reference think about the circular list and it is a very straight forward in this manner you can insert an element in the queue  if you are using this circular list to implement the queue removing an element corresponds to removing the first one how do you remove the first one if i have to just remove the first element in the list  then how do i make the pointer from the last node to point to the 2nd node there is a problem in doing this what do you do again let us remove the 2nd node and copy the contents of that node to the 1st node we have to remove the rome how do i remove the rome i copy seattle to rome thus rome has seattle in it and i remove the 2nd node copying just means changing the reference hence we discusses about queues and double-ended queues we are going to the second part where we will quickly look at some sequences we are going to talk about vectors  positions  list and general sequences we will be using the data structures like arrays and linked lists to implement these data types what is the vector data type vector data type is a sequence of n elements that supports the following methods which are given in the slide below these are indicative methods and not all the methods essentially in a vector it is a sequence where there is a notion of rank with every element of the sequence think of sequence of elements right 7,11,13,19 we know that 7 was the 1st element  1l was the 2nd element  13 was the 3rd element and 5 was the 4th element with each element there is a notion of rank  and then i can have methods like elematrank r rank here corresponds to let us say rank  r  integers first element was the element at rank 1 and 2nd element was the element at rank 2 and so on suppose if i ask to give the element at rank r or replace the element at rank r by the element e  insert an element e at rank r or delete the element at rank r i could have such methods when i remove the element at rank r  for instance let us say the rank of the students in a particular class there is a departmental rank 1  the departmental rank 2 and departmental rank 3 and so on suppose the departmental rank 4 changes and goes to some other department the department rank 4 is the rank of the one who had the rank 5 before the same notion follows and everyone would move up by 1 rank let us see how to implement the data type using arrays i am going to have an array  in which i will have the element with rank 1  rank 2 and rank 3 and so on if i have to insert an element at rank r  i have to put an element in the th r location  which means i have to shift all these elements to one step right that is what i am doing and i put an element in that location in a for loop  first we are moving n-1 one step to the right by this statement s  i + 1  s  i   first we are doing this for n-1  then n-2 where n-2 is moved one step to the right till r is moved to the one step right finally element e is put at position r and the size is increased by 1 where n sores the size of the vector s  r  e n n + 1 similarly when i am removing an element at rank r  i am essentially shifting the entire elements one step to the left all elements starting from r to n-2 and then s  i  gets s  i + 1   at the location r  i will get the element which was sitting at location r + 1 how expensive are these operations in the worst case order n in the worst case because we might have to shift up to n elements to the right or to the left this implementation is expensive from this point of view  if i have to do these two operations insert at a certain rank or remove at a certain rank i have 2 in the worst case spent order n time the other operations are faster how much time does the elematrank  r  takes  because i just go to the th r location in that array and retrieve the elements sitting there replaceatrank  r  e  again order one  because i just go to the th r location and replace that element with element e the chart given below shows the time complexity of various methods all methods except inserted at rank and remove at rank take constant time but these two methods could take order n time in the worst case can you think of some other way of implementing this list we can implement through doubly linked list can you use a doubly linked list to implement a vector i am showing you here the operation of inserting at a certain rank there are 3 diagrams in the above slide in the 1st diagram  the 1st node is the header and the next one is the element at rank 1 following one is the element at rank 2 and the next one is the element at rank 3 suppose i want to insert an element at rank 2  i have to make a new node and put it between 1 and 3 how much time does it take create the node and to insert it  i make a pointer point to the next node and make the previous pointer point to the previous node this is how i insert newyork and the 3rd diagram is the one which i get after insertion there are 2 issues first if i know where i have to insert  then i take constant time but to find out where i have to insert takes order n times because if i have to insert at rank 17 then i have to step through that linked list till 17th position and then i would know to insert at that location.once i know to insert at this location then it is easy i will insert the element in 3 or 4 pointer changes the following would be a java code for inserting at a rank i am assuming the existence of the procedure nodeatrank  rank   this is the method that i am going to be defining shortly what does this method do given a rank  it tells me which is the node at that rank for instance  to insert the node at rank 2  first i will call the procedure with rank 2 it will give me the 2nd node of the 1st diagram because that is the node at rank 2 i have to get to the previous node of that node if i get to this node  next  at rank 2  then i get to the previous node  next.getprev    and this is the node previous to rank 2 which is at rank 1 the new node that i have to insert has to be between next and prev i create the new node and i set its previous field to refer to the previous node and i set its next field to refer to the next node dlnode next = nodeatrank  rank  ; dlnode prev = next.getprev   ; dlnode node = new dlnode  element  prev  next  ; dlnode prev = next.getprev   ; this was the node at rank 1 and dlnode next = nodeatrank  rank  ; was the node earlier at rank 2 in this manner i create the new node at the appropriate place and then i also need to check the previous and next field of the prev and next node that is what i am doing here next.setprev  node  ; prev.setnext  node  ; size + + ; do not get intimated by this code  it is just doing what is shown in the picture i am assuming the existence of this procedure dlnode next = nodeatrank  rank  in which  the given rank will tell me which is the node at that rank in the original list i will show you the process of deletion if i have to remove the element at rank 3  i will first find out the node which is at this rank so i get to the node which is selected in the 2nd diagram and then i have to go to the next node  go to the previous node and update their next and previous pointers thus the pointer will point to the next node and previous node and in this manner i will get rid of that node and at the end i will get the 3rd diagram as the final node similarly i can write down the java code for doing this once again i am assuming the procedure nodeatrank  which tells me about the node which is sitting at that rank how do i implement this procedure nodeatrank there is nothing else i can do except that i march to the list and keep incrementing my counter till i reach that rank i have done essentially that except a small improvement  that if the rank is less than the number of the size of the list by 2  then i start from the header and if it is more than size by 2 i start from the tail just to small improvement nothing more you do such a thing  because if your list has hundred elements and you are looking for the element at rank 98  then there is no point to start from the header it is better to start from the tail that is as far as the vector abstract data type is concerned except that when i say remove the element at a particular rank or insert the element at a particular rank as you have seen both the implementations we have a problem whether we use an array or a list to do that implementation  we seem to require order n time in the worst case  just to be able to find out where the element correspond to that rank is in an array  we know the element corresponding to that rank is and we have to move the elements when we insert or delete linked lists are better in supporting node based operations i have a linked list and i tell you delete this node  if it is a doubly linked list you can delete that node in constant time if i say this is a node and insert a new node after this node i could insert a new node after that node in constant time or if i say delete the inserted node before this node  again i can insert a node in constant time we have the data structure which is very efficient  which can do constant time operations provided that we give access to the node some how i access the particular node at which we want to insert or delete that is what mentioned below removeatnode  node v  and insertafternode  node v  object e  you can remove at a node or you can insert after a node and you can insert before a node all in constant time however when i give you access to a particular node then in some sense  i am also telling you how i have implemented my list whether it is a doubly linked list or a singly linked list and what are the pointers and stuff like that suppose i want to hide all those information  so that you can still use node based operation without knowing the actual implementation of how the thing was done so one can have different implementations we are going to do this using a notion of positions position is an abstract data type which intuitively captures the place where a certain element is stored in your data structure  there is only one method which is associated with the position and is the method element given an object of this data type position  i can only call this method element on that object and that will tell me about the element which is sitting at that particular position if this is not making much sense  then think of position as reference to a particular node think of it as a pointer  because using that pointer you can access the element which is situated in the node and nothing else you can not use that pointer to update the next or the previous fields  or you do not even know how the node is implemented you do not need to know whether the implementer has used a doubly linked list or singly linked list or a circular list it is an abstract data type which hides all the details and you can only use the method element    on the abstract data type position with the notion of position  there will be a relative order of positions jus as in the case of a linked list there is the 1st element in your linked list  2nd element and the position is referring to the 1st element or the 1st node or the 2nd node or the 3rd node of the list similarly 1st position  the 2nd position  the 3rd position and so on given a position that  there is the notion of the position before which refers to the node before that position and a position after that position we can now define a list abstract datatype which uses the positions what would this abstract datatype have it would have generic methods like size   and isempty   and it could have query method  given a particular position i can have a method which asks is this the first position of my list if it is this will say yes and otherwise say no and whether it is the last position of the list i can have excessive methods like first    last    before  p  and after  p   first will give me the first position  last would give me the last position  before  p  will give me the position before this position p and after will give me after this position p i can have update methods like swapelements  p  q   what does this do given a positions p and q  it swaps the contents of these positions whatever may be the elements sitting at these 2 positions it swaps the contents i can replace the element at position p with e  replaceelement  p  e   and similarly i can insert the element e  insertfirst  e   at the very first position i can insert the element e  insertlast  e   at the last position and so on using a doubly linked list you can actually implement all of these methods in constant time the list abstract datatype is just as the same as your linked list data structure except that we are getting an abstract datatype implementation of it we are trying to capture all of those methods that you can do on a linked list as an abstract datatype this datatype can be implemented using a double linked list and it can be implemented using a singly linked list except that it is more efficient if you implement it using a doubly linked list in the doubly linked list all of these methods can be done at a constant time using a singly linked list some of these methods might take linear time in the worst case finally we have the notion of a sequence abstract data type we talked of the vector abstract data type where there is a notion of rank associated with each element then there is a list data type where there is a notion of positions and the sequence abstract data type has both of these it combines the vector and the list abstract data type and it inherits both of these interfaces and that is multiple inheritance besides the methods that are listed for vector and list abstract data type  it has two additional methods which helps you to go from one to other given a particular rank r  the method atrank  r  will return me the position corresponding to this rank given a position p the method rankof  p  will tell me the rank corresponding to this position you could have an implementation of the kind which was given in the slide for a sequence in the above slide  given an array in which each element of the array refers to the position and the point 2 is same in both the cases with the given particular location  i can identify the rank which it corresponds to by looking at the element how is the method rankof  p  implemented p corresponds to a position  a position here is the thing which is given in the middle of the diagram given a particular position and how do i know the rank corresponding to that position i just look in to the 3rd element that gives me the rank corresponding to that position given a particular rank how do i determine the position corresponding to that rank suppose you gave me rank 1  when i follow 1st reference  1 is the position corresponding to this rank at that position there is an element stored which is newyork at the position besides the element  there is something else stored which is kind of provides cross reference at each of these positions i have an element stored and a rank of that element in my sequence suppose i had to insert an element at rank 2  i am going to create new position and the element would sit in that position and 2 would refer to that position and all of these will have to move to one step right not only have to move to the right  we have to change the ranks and update the position again inserting at the particular rank will take order n time of the worst case and similarly deleting an element if i had given particular position and if i wanted to delete the element at that position how do we delete an element at a certain position in the case of a doubly linked list you need to think about this so leave it as an exercise this is a comparison of sequence operations  you can implement a sequence using an array in the picture i have shown you previously and you can also implement a sequence using a doubly linked list this would be the worst case of running time you can see in the case of an array implementation  if you want to insert an element at a certain rank or you want to remove an element at a certain rank it will take order n time if you want to insert after or insert before a certain position  this will also take order n time and if you need to remove an element at a certain position  this will also take order n time not so in the case of a doubly linked list because then you can just zap out the element from there you can just update the pointers before and after and do these in constant time but then what becomes more expensive is  because in a doubly linked list you can not figure out the rank of an element i have to go to the entire list to figure out the rank any rank based operation will take order n time  whether you want to find the rank of n element or you want to find out the element at a particular rank  find out the position corresponding to certain rank  all of these would take order n time we learnt about queues  double ended queues and also how to use linked list and doubly linked list to implement the these data types then we also looked at the vector abstract data type  the list abstract data type which is essentially a concretization of the linked list data structure and we also looked at sequence data types which is basically inheriting all the methods of your list data type and your vector data type 