linked list from wikipedia  the free encyclopedia this article includes a list of references  but its sources remain unclear because it has insufficient inline citations please help to improve this article by introducing more precise citations  march 2012  in computer science  a linked list is a data structure consisting of a group of nodes which together represent a sequence under the simplest form  each node is composed of data and a reference  in other words  a link  to the next node in the sequence ; more complex variants add additional links this structure allows for efficient insertion or removal of elements from any position in the sequence a linked list whose nodes contain two fields  an integer value and a link to the next node the last node is linked to a terminator used to signify the end of the list linked lists are among the simplest and most common data structures they can be used to implement several other common abstract data types  including lists  the abstract data type   stacks  queues  associative arrays  and s-expressions  though it is not uncommon to implement the other data structures directly without using a list as the basis of implementation the principal benefit of a linked list over a conventional array is that the list elements can easily be inserted or removed without reallocation or reorganization of the entire structure because the data items need not be stored contiguously in memory or on disk  while an array has to be declared in the source code  before compiling and running the program linked lists allow insertion and removal of nodes at any point in the list  and can do so with a constant number of operations if the link previous to the link being added or removed is maintained during list traversal on the other hand  simple linked lists by themselves do not allow random access to the data  or any form of efficient indexing thus  many basic operations such as obtaining the last node of the list  assuming that the last node is not maintained as separate node reference in the list structure   or finding a node that contains a given datum  or locating the place where a new node should be inserted may require sequential scanning of most or all of the list elements the advantages and disadvantages of using linked lists are given below contents  hide  * 1 advantages * 2 disadvantages * 3 history * 4 basic concepts and nomenclature o 4.1 singly linked list o 4.2 doubly linked list o 4.3 multiply linked list o 4.4 circular linked list o 4.5 sentinel nodes o 4.6 empty lists o 4.7 hash linking o 4.8 list handles o 4.9 combining alternatives * 5 tradeoffs o 5.1 linked lists vs dynamic arrays o 5.2 singly linked linear lists vs other lists o 5.3 doubly linked vs singly linked o 5.4 circularly linked vs linearly linked o 5.5 using sentinel nodes * 6 linked list operations o 6.1 linearly linked lists * 6.1.1 singly linked lists o 6.2 circularly linked list * 6.2.1 algorithms * 7 linked lists using arrays of node * 8 language support * 9 internal and external storage o 9.1 example of internal and external storage o 9.2 speeding up search o 9.3 random access lists * 10 related data structures * 11 notes * 12 footnotes * 13 references * 14 external links advantages  edit  * linked lists are a dynamic data structure  allocating the needed memory while the program is running * insertion and deletion node operations are easily implemented in a linked list * linear data structures such as stacks and queues are easily executed with a linked list * they can reduce access time and may expand in real time without memory overhead disadvantages  edit  * they have a tendency to use more memory due to pointers requiring extra storage space * nodes in a linked list must be read in order from the beginning as linked lists are inherently sequential access * nodes are stored incontiguously  greatly increasing the time required to access individual elements within the list * difficulties arise in linked lists when it comes to reverse traversing for instance  singly linked lists are cumbersome to navigate backwards  1  and while doubly linked lists are somewhat easier to read  memory is wasted in allocating space for a back pointer history  edit  linked lists were developed in 1955 1956 by allen newell  cliff shaw and herbert a simon at rand corporation as the primary data structure for their information processing language ipl was used by the authors to develop several early artificial intelligence programs  including the logic theory machine  the general problem solver  and a computer chess program reports on their work appeared in ire transactions on information theory in 1956  and several conference proceedings from 1957 to 1959  including proceedings of the western joint computer conference in 1957 and 1958  and information processing  proceedings of the first unesco international conference on information processing  in 1959 the now-classic diagram consisting of blocks representing list nodes with arrows pointing to successive list nodes appears in " programming the logic theory machine " by newell and shaw in proc wjcc  february 1957 newell and simon were recognized with the acm turing award in 1975 for having " made basic contributions to artificial intelligence  the psychology of human cognition  and list processing "  the problem of machine translation for natural language processing led victor yngve at massachusetts institute of technology  mit  to use linked lists as data structures in his comit programming language for computer research in the field of linguistics a report on this language entitled " a programming language for mechanical translation " appeared in mechanical translation in 1958 lisp  standing for list processor  was created by john mccarthy in 1958 while he was at mit and in 1960 he published its design in a paper in the communications of the acm  entitled " recursive functions of symbolic expressions and their computation by machine  part i "  one of lisp 's major data structures is the linked list by the early 1960s  the utility of both linked lists and languages which use these structures as their primary data representation was well established bert green of the mit lincoln laboratory published a review article entitled " computer languages for symbol manipulation " in ire transactions on human factors in electronics in march 1961 which summarized the advantages of the linked list approach a later review article  " a comparison of list-processing computer languages " by bobrow and raphael  appeared in communications of the acm in april 1964 several operating systems developed by technical systems consultants  originally of west lafayette indiana  and later of chapel hill  north carolina  used singly linked lists as file structures a directory entry pointed to the first sector of a file  and succeeding portions of the file were located by traversing pointers systems using this technique included flex  for the motorola 6800 cpu   mini-flex  same cpu   and flex9  for the motorola 6809 cpu   a variant developed by tsc for and marketed by smoke signal broadcasting in california  used doubly linked lists in the same manner the tss/360 operating system  developed by ibm for the system 360/370 machines  used a double linked list for their file system catalog the directory structure was similar to unix  where a directory could contain files and other directories and extend to any depth basic concepts and nomenclature  edit  each record of a linked list is often called an 'element ' or 'node' the field of each node that contains the address of the next node is usually called the 'next link ' or 'next pointer' the remaining fields are known as the 'data '  'information '  'value '  'cargo '  or 'payload ' fields the 'head ' of a list is its first node the 'tail ' of a list may refer either to the rest of the list after the head  or to the last node in the list in lisp and some derived languages  the next node may be called the 'cdr '  pronounced could-er  of the list  while the payload of the head node may be called the 'car' singly linked list  edit  singly linked lists contain nodes which have a data field as well as a 'next ' field  which points to the next node in line of nodes operations that can be performed on singly linked lists include insertion  deletion and traversal a singly linked list whose nodes contain two fields  an integer value and a link to the next node doubly linked list  edit  main article  doubly linked list in a 'doubly linked list '  each node contains  besides the next-node link  a second link field pointing to the 'previous ' node in the sequence the two links may be called 'forward  's '  and 'backwards '  or 'next ' and 'prev '  'previous '   a doubly linked list whose nodes contain three fields  an integer value  the link forward to the next node  and the link backward to the previous node a technique known as xor-linking allows a doubly linked list to be implemented using a single link field in each node however  this technique requires the ability to do bit operations on addresses  and therefore may not be available in some high-level languages multiply linked list  edit  in a 'multiply linked list '  each node contains two or more link fields  each field being used to connect the same set of data records in a different order  e.g  by name  by department  by date of birth  etc   while doubly linked lists can be seen as special cases of multiply linked list  the fact that the two orders are opposite to each other leads to simpler and more efficient algorithms  so they are usually treated as a separate case circular linked list  edit  in the last node of a list  the link field often contains a null reference  a special value used to indicate the lack of further nodes a less common convention is to make it point to the first node of the list ; in that case the list is said to be 'circular ' or 'circularly linked ' ; otherwise it is said to be 'open ' or 'linear' a circular linked list in the case of a circular doubly linked list  the only change that occurs is that the end  or " tail "  of the said list is linked back to the front  or " head "  of the list and vice versa sentinel nodes  edit  main article  sentinel node in some implementations  an extra 'sentinel ' or 'dummy ' node may be added before the first data record or after the last one this convention simplifies and accelerates some list-handling algorithms  by ensuring that all links can be safely dereferenced and that every list  even one that contains no data elements  always has a " first " and " last " node empty lists  edit  an empty list is a list that contains no data records this is usually the same as saying that it has zero nodes if sentinel nodes are being used  the list is usually said to be empty when it has only sentinel nodes hash linking  edit  the link fields need not be physically part of the nodes if the data records are stored in an array and referenced by their indices  the link field may be stored in a separate array with the same indices as the data records list handles  edit  since a reference to the first node gives access to the whole list  that reference is often called the 'address '  'pointer '  or 'handle ' of the list algorithms that manipulate linked lists usually get such handles to the input lists and return the handles to the resulting lists in fact  in the context of such algorithms  the word " list " often means " list handle "  in some situations  however  it may be convenient to refer to a list by a handle that consists of two links  pointing to its first and last nodes combining alternatives  edit  the alternatives listed above may be arbitrarily combined in almost every way  so one may have circular doubly linked lists without sentinels  circular singly linked lists with sentinels  etc tradeoffs  edit  as with most choices in computer programming and design  no method is well suited to all circumstances a linked list data structure might work well in one case  but cause problems in another this is a list of some of the common tradeoffs involving linked list structures linked lists vs dynamic arrays  edit  comparison of list data structures linked list array dynamic array balanced tree random access list indexing  n   1   1   log n   log n  insert/delete at beginning  1  n/a  n   log n   1  insert/delete at end  n  when last element is unknown ;  1  when last element is known n/a  1  amortized  log n   log n  updating insert/delete in middle search time +  1   2   3   4  n/a  n   log n   log n  updating wasted space  average   n  0  n   5   n   n  a dynamic array is a data structure that allocates all elements contiguously in memory  and keeps a count of the current number of elements if the space reserved for the dynamic array is exceeded  it is reallocated and  possibly  copied  an expensive operation linked lists have several advantages over dynamic arrays insertion or deletion of an element at a specific point of a list  assuming that we have indexed a pointer to the node  before the one to be removed  or before the insertion point  already  is a constant-time operation  otherwise without this reference it is o  n    whereas insertion in a dynamic array at random locations will require moving half of the elements on average  and all the elements in the worst case while one can " delete " an element from an array in constant time by somehow marking its slot as " vacant "  this causes fragmentation that impedes the performance of iteration moreover  arbitrarily many elements may be inserted into a linked list  limited only by the total memory available ; while a dynamic array will eventually fill up its underlying array data structure and will have to reallocate an expensive operation  one that may not even be possible if memory is fragmented  although the cost of reallocation can be averaged over insertions  and the cost of an insertion due to reallocation would still be amortized o  1   this helps with appending elements at the array 's end  but inserting into  or removing from  middle positions still carries prohibitive costs due to data moving to maintain contiguity an array from which many elements are removed may also have to be resized in order to avoid wasting too much space on the other hand  dynamic arrays  as well as fixed-size array data structures  allow constant-time random access  while linked lists allow only sequential access to elements singly linked lists  in fact  can be easily traversed in only one direction this makes linked lists unsuitable for applications where it 's useful to look up an element by its index quickly  such as heapsort sequential access on arrays and dynamic arrays is also faster than on linked lists on many machines  because they have optimal locality of referenceand thus make good use of data caching another disadvantage of linked lists is the extra storage needed for references  which often makes them impractical for lists of small data items such as characters or boolean values  because the storage overhead for the links may exceed by a factor of two or more the size of the data in contrast  a dynamic array requires only the space for the data itself  and a very small amount of control data    note 1  it can also be slow  and with a na ve allocator  wasteful  to allocate memory separately for each new element  a problem generally solved using memory pools some hybrid solutions try to combine the advantages of the two representations unrolled linked lists store several elements in each list node  increasing cache performance while decreasing memory overhead for references cdr coding does both these as well  by replacing references with the actual data referenced  which extends off the end of the referencing record a good example that highlights the pros and cons of using dynamic arrays vs linked lists is by implementing a program that resolves the josephus problem the josephus problem is an election method that works by having a group of people stand in a circle starting at a predetermined person  you count around the circle n times once you reach the nth person  take them out of the circle and have the members close the circle then count around the circle the same n times and repeat the process  until only one person is left that person wins the election this shows the strengths and weaknesses of a linked list vs a dynamic array  because if you view the people as connected nodes in a circular linked list then it shows how easily the linked list is able to delete nodes  as it only has to rearrange the links to the different nodes   however  the linked list will be poor at finding the next person to remove and will need to search through the list until it finds that person a dynamic array  on the other hand  will be poor at deleting nodes  or elements  as it can not remove one node without individually shifting all the elements up the list by one however  it is exceptionally easy to find the nth person in the circle by directly referencing them by their position in the array the list ranking problem concerns the efficient conversion of a linked list representation into an array although trivial for a conventional computer  solving this problem by aparallel algorithm is complicated and has been the subject of much research a balanced tree has similar memory access patterns and space overhead to a linked list while permitting much more efficient indexing  taking o  log n  time instead of o  n  for a random access however  insertion and deletion operations are more expensive due to the overhead of tree manipulations to maintain balance schemes exist for trees to automatically maintain themselves in a balanced state  avl trees or red-black trees singly linked linear lists vs other lists  edit  while doubly-linked and circular lists have advantages over singly-linked linear lists  linear lists offer some advantages that make them preferable in some situations a singly linked linear list is a recursive data structure  because it contains a pointer to a smaller object of the same type for that reason  many operations on singly linked linear lists  such as merging two lists  or enumerating the elements in reverse order  often have very simple recursive algorithms  much simpler than any solution using iterative commands while those recursive solutions can be adapted for doubly linked and circularly linked lists  the procedures generally need extra arguments and more complicated base cases linear singly linked lists also allow tail-sharing  the use of a common final portion of sub-list as the terminal portion of two different lists in particular  if a new node is added at the beginning of a list  the former list remains available as the tail of the new one a simple example of a persistent data structure again  this is not true with the other variants  a node may never belong to two different circular or doubly linked lists in particular  end-sentinel nodes can be shared among singly linked non-circular lists the same end-sentinel node may be used for every such list in lisp  for example  every proper list ends with a link to a special node  denoted by nil or    whose car and cdr links point to itself thus a lisp procedure can safely take the car or cdr of anylist the advantages of the fancy variants are often limited to the complexity of the algorithms  not in their efficiency a circular list  in particular  can usually be emulated by a linear list together with two variables that point to the first and last nodes  at no extra cost doubly linked vs singly linked  edit  double-linked lists require more space per node  unless one uses xor-linking   and their elementary operations are more expensive ; but they are often easier to manipulate because they allow fast and easy sequential access to the list in both directions in a doubly linked list  one can insert or delete a node in a constant number of operations given only that node 's address to do the same in a singly linked list  one must have the address of the pointer to that node  which is either the handle for the whole list  in case of the first node  or the link field in the previous node some algorithms require access in both directions on the other hand  doubly linked lists do not allow tail-sharing and can not be used as persistent data structures circularly linked vs linearly linked  edit  a circularly linked list may be a natural option to represent arrays that are naturally circular  e.g the corners of a polygon  a pool of buffers that are used and released in fifo  " first in  first out "  order  or a set of processes that should be time-shared in round-robin order in these applications  a pointer to any node serves as a handle to the whole list with a circular list  a pointer to the last node gives easy access also to the first node  by following one link thus  in applications that require access to both ends of the list  e.g  in the implementation of a queue   a circular structure allows one to handle the structure by a single pointer  instead of two a circular list can be split into two circular lists  in constant time  by giving the addresses of the last node of each piece the operation consists in swapping the contents of the link fields of those two nodes applying the same operation to any two nodes in two distinct lists joins the two list into one this property greatly simplifies some algorithms and data structures  such as the quad-edge and face-edge the simplest representation for an empty circular list  when such a thing makes sense  is a null pointer  indicating that the list has no nodes without this choice  many algorithms have to test for this special case  and handle it separately by contrast  the use of null to denote an empty linear list is more natural and often creates fewer special cases using sentinel nodes  edit  sentinel node may simplify certain list operations  by ensuring that the next or previous nodes exist for every element  and that even empty lists have at least one node one may also use a sentinel node at the end of the list  with an appropriate data field  to eliminate some end-of-list tests for example  when scanning the list looking for a node with a given value x  setting the sentinel 's data field to x makes it unnecessary to test for end-of-list inside the loop another example is the merging two sorted lists  if their sentinels have data fields set to +  the choice of the next output node does not need special handling for empty lists however  sentinel nodes use up extra space  especially in applications that use many short lists   and they may complicate other operations  such as the creation of a new empty list   however  if the circular list is used merely to simulate a linear list  one may avoid some of this complexity by adding a single sentinel node to every list  between the last and the first data nodes with this convention  an empty list consists of the sentinel node alone  pointing to itself via the next-node link the list handle should then be a pointer to the last data node  before the sentinel  if the list is not empty ; or to the sentinel itself  if the list is empty the same trick can be used to simplify the handling of a doubly linked linear list  by turning it into a circular doubly linked list with a single sentinel node however  in this case  the handle should be a single pointer to the dummy node itself  6  linked list operations  edit  when manipulating linked lists in-place  care must be taken to not use values that you have invalidated in previous assignments this makes algorithms for inserting or deleting linked list nodes somewhat subtle this section gives pseudocode for adding or removing nodes from singly  doubly  and circularly linked lists in-place throughout we will use nullto refer to an end-of-list marker or sentinel  which may be implemented in a number of ways linearly linked lists  edit  singly linked lists  edit  our node data structure will have two fields we also keep a variable firstnode which always points to the first node in the list  or is null for an empty list record node  data ; the data being stored in the node node next a reference to the next node  null for last node  record list  node firstnode points to first node of list ; null for empty list  traversal of a singly linked list is simple  beginning at the first node and following each next link until we come to the end  node  = list.firstnode while node not null  do something with node.data  node  = node.next the following code inserts a node after an existing node in a singly linked list the diagram shows how it works inserting a node before an existing one can not be done directly ; instead  one must keep track of the previous node and insert a node after it function insertafter  node node  node newnode  insert newnode after node newnode.next  = node.next node.next  = newnode inserting at the beginning of the list requires a separate function this requires updating firstnode function insertbeginning  list list  node newnode  insert node before current first node newnode.next  = list.firstnode list.firstnode  = newnode similarly  we have functions for removing the node after a given node  and for removing a node from the beginning of the list the diagram demonstrates the former to find and remove a particular node  one must again keep track of the previous element function removeafter  node node  remove node past this one obsoletenode  = node.next node.next  = node.next.next destroy obsoletenode function removebeginning  list list  remove first node obsoletenode  = list.firstnode list.firstnode  = list.firstnode.next point past deleted node destroy obsoletenode notice that removebeginning   sets list.firstnode to null when removing the last node in the list since we ca n't iterate backwards  efficient insertbefore or removebefore operations are not possible appending one linked list to another can be inefficient unless a reference to the tail is kept as part of the list structure  because we must traverse the entire first list in order to find the tail  and then append the second list to this thus  if two linearly linked lists are each of length  list appending has asymptotic time complexity of  in the lisp family of languages  list appending is provided by the append procedure many of the special cases of linked list operations can be eliminated by including a dummy element at the front of the list this ensures that there are no special cases for the beginning of the list and renders both insertbeginning   and removebeginning   unnecessary in this case  the first useful data in the list will be found atlist.firstnode.next circularly linked list  edit  in a circularly linked list  all nodes are linked in a continuous circle  without using null for lists with a front and a back  such as a queue   one stores a reference to the last node in the list the next node after the last node is the first node elements can be added to the back of the list and removed from the front in constant time circularly linked lists can be either singly or doubly linked both types of circularly linked lists benefit from the ability to traverse the full list beginning at any given node this often allows us to avoid storing firstnode and lastnode  although if the list may be empty we need a special representation for the empty list  such as a lastnode variable which points to some node in the list or is null if it 's empty ; we use such alastnode here this representation significantly simplifies adding and removing nodes with a non-empty list  but empty lists are then a special case algorithms  edit  assuming that somenode is some node in a non-empty circular singly linked list  this code iterates through that list starting with somenode  function iterate  somenode  if somenode null node  = somenode do do something with node.value node  = node.next while node somenode notice that the test " while node somenode " must be at the end of the loop if the test was moved to the beginning of the loop  the procedure would fail whenever the list had only one node this function inserts a node " newnode " into a circular linked list after a given node " node "  if " node " is null  it assumes that the list is empty function insertafter  node node  node newnode  if node = null newnode.next  = newnode else newnode.next  = node.next node.next  = newnode suppose that " l " is a variable pointing to the last node of a circular linked list  or null if the list is empty   to append " newnode " to the end of the list  one may do insertafter  l  newnode  l  = newnode to insert " newnode " at the beginning of the list  one may do insertafter  l  newnode  if l = null l  = newnode linked lists using arrays of node  edit  languages that do not support any type of reference can still create links by replacing pointers with array indices the approach is to keep an array of records  where each record has integer fields indicating the index of the next  and possibly previous  node in the array not all nodes in the array need be used if records are also not supported,parallel arrays can often be used instead as an example  consider the following linked list record that uses arrays instead of pointers  record entry  integer next ; index of next entry in array integer prev ; previous entry  if double-linked  string name ; real balance ;  a linked list can be build by creating an array of these structures  and an integer variable to store the index of the first element integer listhead entry records  1000  links between elements are formed by placing the array index of the next  or previous  cell into the next or prev field within a given element for example  index next prev name balance 0 1 4 jones  john 123.45 1 -1 0 smith  joseph 234.56 2  listhead  4 -1 adams  adam 0.00 3 ignore  ignatius 999.99 4 0 2 another  anita 876.54 5 6 7 in the above example  listhead would be set to 2  the location of the first entry in the list notice that entry 3 and 5 through 7 are not part of the list these cells are available for any additions to the list by creating a listfree integer variable  a free list could be created to keep track of what cells are available if all entries are in use  the size of the array would have to be increased or some elements would have to be deleted before new entries could be stored in the list the following code would traverse the list and display names and account balance  i  = listhead while i 0 loop through the list print i  records  i  .name  records  i  .balance print entry i  = records  i  .next when faced with a choice  the advantages of this approach include  * the linked list is relocatable  meaning it can be moved about in memory at will  and it can also be quickly and directly serialized for storage on disk or transfer over a network * especially for a small list  array indexes can occupy significantly less space than a full pointer on many architectures * locality of reference can be improved by keeping the nodes together in memory and by periodically rearranging them  although this can also be done in a general store * na ve dynamic memory allocators can produce an excessive amount of overhead storage for each node allocated ; almost no allocation overhead is incurred per node in this approach * seizing an entry from a pre-allocated array is faster than using dynamic memory allocation for each node  since dynamic memory allocation typically requires a search for a free memory block of the desired size this approach has one main disadvantage  however  it creates and manages a private memory space for its nodes this leads to the following issues  * it increases complexity of the implementation * growing a large array when it is full may be difficult or impossible  whereas finding space for a new linked list node in a large  general memory pool may be easier * adding elements to a dynamic array will occasionally  when it is full  unexpectedly take linear  o  n   instead of constant time  although it 's still an amortized constant   * using a general memory pool leaves more memory for other data if the list is smaller than expected or if many nodes are freed for these reasons  this approach is mainly used for languages that do not support dynamic memory allocation these disadvantages are also mitigated if the maximum size of the list is known at the time the array is created language support  edit  many programming languages such as lisp and scheme have singly linked lists built in in many functional languages  these lists are constructed from nodes  each called a consor cons cell the cons has two fields  the car  a reference to the data for that node  and the cdr  a reference to the next node although cons cells can be used to build other data structures  this is their primary purpose in languages that support abstract data types or templates  linked list adts or templates are available for building linked lists in other languages  linked lists are typically built using references together with records internal and external storage  edit  when constructing a linked list  one is faced with the choice of whether to store the data of the list directly in the linked list nodes  called internal storage  or merely to store a reference to the data  called external storage internal storage has the advantage of making access to the data more efficient  requiring less storage overall  having better locality of reference  and simplifying memory management for the list  its data is allocated and deallocated at the same time as the list nodes   external storage  on the other hand  has the advantage of being more generic  in that the same data structure and machine code can be used for a linked list no matter what the size of the data is it also makes it easy to place the same data in multiple linked lists although with internal storage the same data can be placed in multiple lists by including multiple next references in the node data structure  it would then be necessary to create separate routines to add or delete cells based on each field it is possible to create additional linked lists of elements that use internal storage by using external storage  and having the cells of the additional linked lists store references to the nodes of the linked list containing the data in general  if a set of data structures needs to be included in linked lists  external storage is the best approach if a set of data structures need to be included in only one linked list  then internal storage is slightly better  unless a generic linked list package using external storage is available likewise  if different sets of data that can be stored in the same data structure are to be included in a single linked list  then internal storage would be fine another approach that can be used with some languages involves having different data structures  but all have the initial fields  including the next  and prev if double linked list  references in the same location after defining separate structures for each type of data  a generic structure can be defined that contains the minimum amount of data shared by all the other structures and contained at the top  beginning  of the structures then generic routines can be created that use the minimal structure to perform linked list type operations  but separate routines can then handle the specific data this approach is often used in message parsing routines  where several types of messages are received  but all start with the same set of fields  usually including a field for message type the generic routines are used to add new messages to a queue when they are received  and remove them from the queue in order to process the message the message type field is then used to call the correct routine to process the specific type of message example of internal and external storage  edit  suppose you wanted to create a linked list of families and their members using internal storage  the structure might look like the following  record member  member of a family member next ; string firstname ; integer age ;  record family  the family itself family next ; string lastname ; string address ; member members head of list of members of this family  to print a complete list of families and their members using internal storage  we could write  afamily  = families start at head of families list while afamily null loop through list of families print information about family amember  = afamily.members get head of list of this family 's members while amember null loop through list of members print information about member amember  = amember.next afamily  = afamily.next using external storage  we would create the following structures  record node  generic link structure node next ; pointer data generic pointer for data at node  record member  structure for family member string firstname ; integer age  record family  structure for family string lastname ; string address ; node members head of list of members of this family  to print a complete list of families and their members using external storage  we could write  famnode  = families start at head of families list while famnode null loop through list of families afamily  =  family  famnode.data extract family from node print information about family memnode  = afamily.members get list of family members while memnode null loop through list of members amember  =  member  memnode.data extract member from node print information about member memnode  = memnode.next famnode  = famnode.next notice that when using external storage  an extra step is needed to extract the record from the node and cast it into the proper data type this is because both the list of families and the list of members within the family are stored in two linked lists using the same data structure  node   and this language does not have parametric types as long as the number of families that a member can belong to is known at compile time  internal storage works fine if  however  a member needed to be included in an arbitrary number of families  with the specific number known only at run time  external storage would be necessary speeding up search  edit  finding a specific element in a linked list  even if it is sorted  normally requires o  n  time  linear search   this is one of the primary disadvantages of linked lists over other data structures in addition to the variants discussed above  below are two simple ways to improve search time in an unordered list  one simple heuristic for decreasing average search time is the move-to-front heuristic  which simply moves an element to the beginning of the list once it is found this scheme  handy for creating simple caches  ensures that the most recently used items are also the quickest to find again another common approach is to " index " a linked list using a more efficient external data structure for example  one can build a red-black tree or hash table whose elements are references to the linked list nodes multiple such indexes can be built on a single list the disadvantage is that these indexes may need to be updated each time a node is added or removed  or at least  before that index is used again   random access lists  edit  a random access list is a list with support for fast random access to read or modify any element in the list  7  one possible implementation is a skew binary random access listusing the skew binary number system  which involves a list of trees with special properties ; this allows worst-case constant time head/cons operations  and worst-case logarithmic time random access to an element by index  7  random access lists can be implemented as persistent data structures  7  random access lists can be viewed as immutable linked lists in that they likewise support the same o  1  head and tail operations  7  a simple extension to random access lists is the min-list  which provides an additional operation that yields the minimum element in the entire list in constant time  without  clarification needed  mutation complexities    7  related data structures  edit  both stacks and queues are often implemented using linked lists  and simply restrict the type of operations which are supported the skip list is a linked list augmented with layers of pointers for quickly jumping over large numbers of elements  and then descending to the next layer this process continues down to the bottom layer  which is the actual list a binary tree can be seen as a type of linked list where the elements are themselves linked lists of the same nature the result is that each node may include a reference to the first node of one or two other linked lists  which  together with their contents  form the subtrees below that node an unrolled linked list is a linked list in which each node contains an array of data values this leads to improved cache performance  since more list elements are contiguous in memory  and reduced memory overhead  because less metadata needs to be stored for each element of the list a hash table may use linked lists to store the chains of items that hash to the same position in the hash table a heap shares some of the ordering properties of a linked list  but is almost always implemented using an array instead of references from node to node  the next and previous data indexes are calculated using the current data 's index a self-organizing list rearranges its nodes based on some heuristic which reduces search times for data retrieval by keeping commonly accessed nodes at the head of the list notes  edit  1 jump up ^ the amount of control data required for a dynamic array is usually of the form  where is a per-array constant  is a per-dimension constant  and is the number of dimensions and are typically on the order of 10 bytes footnotes  edit  1 jump up ^ skiena  steven s  2009   the algorithm design manual  2nd ed   springer p 76 isbn 9781848000704 we can do nothing without this list predecessor  and so must spend linear time searching for it on a singly-linked list 2 jump up ^ gerald kruse cs 240 lecture notes  linked lists plus  complexity trade-offs juniata college spring 2008 3 jump up ^ day 1 keynote  bjarne stroustrup  c + + 11 style at goingnative 2012 on channel9.msdn.com from minute 45 or foil 44 4 jump up ^ number crunching  why you should never  ever  ever use linked-list in your code again at kjellkod.wordpress.com 5 jump up ^ brodnik  andrej ; carlsson  svante ; sedgewick  robert ; munro  ji ; demaine  ed  1999   resizable arrays in optimal time and space  technical report cs-99-09   pdf   department of computer science  university of waterloo 6 jump up ^ ford  william ; topp  william  2002   data structures with c + + using stl  second ed   prentice-hall pp 466 467 isbn 0-13-085850-1 7 ^ jump up to  a b c d e okasaki  chris  1995   purely functional random-access lists  ps   in functional programming languages and computer architecture  acm press   pp 86 95 retrieved may 7,2015 references  edit  * juan  angel  2006   " ch20 data structures ; id06  programming with java  slide part of the book 'big java '  by cays horstmann  "  pdf   p 3 * black  paul e  2004-08-16   pieterse  vreda ; black  paul e  eds " linked list "  dictionary of algorithms and data structures national institute of standards and technology retrieved 2004-12-14 * antonakos  james l ; mansfield  kenneth c  jr  1999   practical data structures using c/c + +  prentice-hall pp 165 190 isbn 0-13-280843-9 * collins  william j  2005   2002   data structures and the java collections framework new york  mcgraw hill pp 239 303 isbn 0-07-282379-8 * cormen  thomas h ; leiserson  charles e ; rivest  ronald l ; stein  clifford  2003   introduction to algorithms mit press pp 205 213,501 505 isbn 0-262-03293-7 * cormen  thomas h ; leiserson  charles e ; rivest  ronald l ; stein  clifford  2001   " 10.2  linked lists "  introduction to algorithms  2nd ed   mit press pp 204 209.isbn 0-262-03293-7 * green  bert f  jr  1961   " computer languages for symbol manipulation "  ire transactions on human factors in electronics  2   3 8 doi  10.1109/thfe2.1961.4503292 * mccarthy  john  1960   " recursive functions of symbolic expressions and their computation by machine  part i "  communications of the acm 3  4   184.doi  10.1145/367177.367199 * knuth  donald  1997   " 2.2.3-2.2.5 "  fundamental algorithms  3rd ed   addison-wesley pp 254 298 isbn 0-201-89683-4 * newell  allen ; shaw  f c  1957   " programming the logic theory machine "  proceedings of the western joint computer conference  230 240 * parlante  nick  2001   " linked list basics "  pdf   stanford university retrieved 2009-09-21 * sedgewick  robert  1998   algorithms in c addison wesley pp 90 109 isbn 0-201-31452-5 * shaffer  clifford a  1998   a practical introduction to data structures and algorithm analysis new jersey  prentice hall pp 77 102 isbn 0-13-660911-2 * wilkes  maurice vincent  1964   " an experiment with a self-compiling compiler for a simple list-processing language "  annual review in automatic programming  pergamon press  4  1   1 doi  10.1016/0066-4138  64  90013-8 * wilkes  maurice vincent  1964   " lists and why they are useful "  proceeds of the acm national conference  philadelphia 1964  acm   p 64   f1 1 * shanmugasundaram  kulesh  2005-04-04   " linux kernel linked list explained "  retrieved 2009-09-21 external links  edit  wikimedia commons has media related to linked lists * description from the dictionary of algorithms and data structures * introduction to linked lists  stanford university computer science library * linked list problems  stanford university computer science library * open data structures  chapter 3  linked lists * patent for the idea of having nodes which are in several linked lists simultaneously  note that this technique was widely used for many decades before the patent was granted   hide  * v * t * e data structures types * collection * container abstract * associative array * double-ended priority queue * double-ended queue * list * map * multimap * priority queue * queue * set * multiset * disjoint sets * stack arrays * bit array * circular buffer * dynamic array * hash table * hashed array tree * sparse array linked * association list * linked list * skip list * unrolled linked list * xor linked list trees * b-tree * binary search tree * aa * avl * red-black * self-balancing * splay * heap * binary * binomial * fibonacci * r-tree * r * * r + * hilbert * trie * hash tree graphs * binary decision diagram * directed acyclic graph * directed acyclic word graph * list of data structures authority control * gnd  4783888-7 categories  * linked lists * data structures 