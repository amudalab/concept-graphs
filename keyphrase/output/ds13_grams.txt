two four trees
trees in today
operation of insert
search and delete
kind of performance
case in avl
kind of search
binary search trees
trees so recall
happening the tree
point so nodes
four actually refers
number of children
children and node
right such trees
children but satisfy
multi way search
two which means
right any number
two each node
node of tree
tree also stored
stored a collection
collection of items
items the form
form key coma
key coma element
search each node
node was storing
storing one key
lets say reference
key was lets
lets say student
student record student
record student entry
student entry number
number the student
key comma element
binary search tree
minus one search
pairs or items
generalizing a binary
helps us helps
helps us determine
child second child
child third child
child fourth child
minus one difference
difference keys sitting
children this node
node the number
number of keys
instance this node
node the key
key is determined
determined what set
set of keys
left sub tree
right sub tree
first sub tree
last sub tree
ten would lie
middle sub tree
minus one keys
keys or items
two consecutive keys
follow one child
searching is similar
binary search procedure
left most sub
right most sub
node for instance
two eight lies
searching for twenty
sequence of steps
found the twenty
found that twelve
keys is lies
lies between right
key which keys
left most child
right most child
driver in traversal
recall inorder traversal
traversal says left
print the data
right so first
print the key
child then print
correspond to inorder
first go left
finishes inorder traversal
finish the inorder
print this key
printed this key
doing inorder traversal
tree this sub
eleven first thirteen
first thirteen fourteen
eighteen nineteen twenty
nineteen twenty twenty
finishes the inorder
keys in sorted
easy to prove
out these key
order of printing
two four tree
properties each node
tree okay multi
tree each node
node has atmost
forget this square
level two right
two addition properties
addition properties search
properties search tree
four tree node
node okay don
base two right
tree be maximum
complete binary tree
tree and complete
height is log
log n base
height is maximum
maximum the tree
height is minimum
nodes are closer
closer to root
find the height
tree is log
nodes always lies
two its lies
lies between log
two and log
base four log
half of log
basically the height
four tree lies
lies between half
two for search
lets say suppose
eleven with twelve
comparing with ten
four tree height
essentially now compare
node and node
require one right
require three comparison
right to determine
node times log
number of node
node you require
tree you required
searching i start
keys to determine
four different branches
make three comparison
shown the node
shown each node
insert as twenty
insert we insert
found that element
lets see twenty
insert so twenty
twenty one lies
lies between thirteen
thirteen and twenty
out i compare
eighty its larger
larger then eighteen
sit this node
hit the leaf
node is empty
empty the right
heat the null
put the node
space no problem
insert the twenty
twenty three lie
lie between twenty
two and thirty
link out twenty
right and twenty
insert that node
problem with forty
forty with thirty
space i put
insert a node
insert a key
kind of thing
right so twenty
follow this twenty
split the node
node which node
split this node
twenty six twenty
twenty eight twenty
two okay lets
remove this node
understand why twenty
promoted up twenty
promoted one key
parent and inserted
inserted that key
insert the key
parent the parent
child we follow
node two nodes
two nodes created
four five children
node and promoted
two left children
children the first
first two children
node the right
keys which means
means three children
split the parent
thirteen gets promoted
root the height
understand the procedure
put the key
done very simple
split that node
lower two lower
two lower keys
two higher keys
node the largest
promoted up promoted
promoted up means
problem otherwise repeat
repeat the split
node so split
split my cascading
process of insertion
doing the split
constant time independent
node split takes
split takes constant
total time order
suppose i wanted
wanted to delete
search for twenty
twenty one find
case of binary
tree we recall
recall deletion require
two child cases
node two children
found the successor
successor or predecessor
form the predecessor
move the predecessor
delete the predecessor
similar here lets
lets see suppose
right go left
twenty one right
problem deleting twenty
violating the property
tree we require
require each node
shown the process
twenty five right
twenty five bite
predecessor of twenty
find the predecessor
find the largest
key its twenty
four so predecessor
remove the twenty
note that predecessor
search tree lets
tree lets check
check this point
tree the predecessor
node right suppose
finding the predecessor
predicessor of ten
right keep taking
taking the right
child is null
children are null
remove that leaf
four and twenty
read of twenty
imagine problem raising
delete a key
leaf becomes empty
right so lets
deleting a key
key and node
node becomes empty
borrow a key
right i reach
twenty so twenty
twenty is removed
node not permitted
borrow from sibling
right because search
right for instance
problem wait lets
sibling we merge
sibling we combine
sibling okay suppose
twenty three right
guy everyone understand
solve our problem
node which separate
merge okay lets
moving the key
parent node corresponds
corresponds to deletion
deleting the key
node this procedure
cascading right cascading
height can reduce
height has shrink
insertion may height
understand this procedure
insertion may split
point is doing
great so lets
lets conclude today
theta of log
deletion was concern
looked at vaning
tree to search
log n step
step each step
merging with sibling
constant time operation
operation right borrowing
borrowing could corresponds
search insertion deletion
complicated data structure
structure called red
red black tree
fast data structure
structure for implementing
four trees today
helpful in understanding
red black trees
black trees functions
insert search
data structure
performance guarantee
avl trees
search trees
binary search
binary tree
first point
search properties
internal node
search tree
form key
key coma
coma element
student record
record student
student entry
entry number
kind key
search pairs
keys helps
search process
first child
fourth child
difference keys
keys sitting
node determined
sub trees
key twenty
sub tree
left sub
right sub
first sub
last sub
middle sub
first key
consecutive keys
key value
consecutive pairs
tree searching
search procedure
success visit
last key
order driver
traversal tree
inorder traversal
recall inorder
print twenty
first twenty
middle child
right child
finishes inorder
doing inorder
first thirteen
thirteen fourteen
twenty twenty
entire thing
sorted order
key right
valid node
lets understand
important property
leaf nodes
leaf node
square boxes
level suppose
numbering level
addition properties
properties search
tree node
worst case
last level
complete binary
right log
tree height
level sixteen
tree lies
takes search
key lets
eleven lets
compare eleven
change color
order height
maximum number
right node
node times
times log
order log
first element
search terminates
insert element
right pointer
null pointer
comparing twenty
twenty lets
empty space
insertion lets
out twenty
inserted order
move twenty
last node
compare twenty
insert forty
forty forty
inserting twenty
promote twenty
search property
largest key
parent doesn
nodes created
left node
parent node
sufficient split
made children
smaller node
left children
node twenty
remember right
root thirteen
tree increases
space great
lower keys
higher keys
lower part
split process
clear search
node split
split takes
takes constant
delete twenty
recall deletion
deletion require
child cases
problem twenty
find twenty
problem deleting
deleting twenty
instance suppose
problem note
tree lets
lets check
null right
left child
swapped twenty
right twenty
simple case
imagine problem
problem raising
sibling lets
removed problem
empty node
guys means
avl tree
problem wait
wait lets
small catch
adjusting sibling
merge combine
node corresponds
parent deleting
child left
sibling key
deletion height
means height
lets conclude
conclude today
discussion height
search insertion
insertion deletion
complicated data
fast data
implementing dictionaries
trees today
red black
black trees
trees functions
two
four
trees
today
class
talking
representing
additionally
operation
insert
search
delete
data
structure
kind
performance
guarantee
case
avl
classes
begin
binary
recall
happening
tree
node
children
right
first
point
nodes
refers
number
satisfy
properties
multi
internal
child
means
stored
collection
items
form
key
coma
element
storing
lets
reference
student
record
entry
similar
pairs
pair
minus
generalizing
keys
left
helps
determine
similarly
process
fourth
difference
sitting
showing
clear
back
show
instance
read
determined
set
sub
twenty
ten
last
lie
middle
concept
understand
follow
previous
code
consecutive
elements
value
searching
procedure
suppose
compare
find
lies
success
visit
found
sequence
steps
twelve
extrimate
check
larger
simple
order
driver
traversal
question
inorder
print
correspond
part
finishes
finish
parent
printed
doing
give
eleven
thirteen
fourteen
seventeen
eighteen
nineteen
entire
thing
sorted
easy
prove
out
printing
true
put
valid
organized
manner
great
atmost
important
property
leaf
level
forget
square
boxes
numbering
addition
height
don
log
base
worst
maximum
noise
leafs
basically
complete
argued
forge
setting
minimum
closer
root
sixteen
sixty
analysis
quantities
essentially
half
takes
change
color
comparing
doesn
correct
require
comparison
branch
times
careful
required
start
branches
make
insertion
largest
shown
location
space
pointers
terminates
exist
eighty
sit
hit
empty
pointer
null
place
continue
hindi
heat
wound
ring
page
filled
wait
week
problem
thirty
link
inserted
move
forty
inserting
happen
split
smaller
remove
guy
originally
promote
promoted
smallest
created
sufficient
made
guys
create
disappear
remember
eventually
increases
done
decided
lower
higher
mans
successful
repeat
cascading
questions
splits
constant
independent
total
deletion
wanted
cases
distinguish
worried
successor
predecessor
deleting
violating
deleted
mark
bite
swap
note
finding
predicessor
line
taking
stop
situation
permitted
swapped
imagine
raising
borrow
sibling
reach
removed
fifteen
rotation
wondering
merge
combine
small
catch
jumble
adjusting
solve
separate
separating
siblings
moves
non
diverse
moving
corresponds
lead
reduce
shrink
copy
conclude
discussion
theta
concern
looked
vaning
step
borrowing
merging
complicated
reason
red
black
fast
implementing
dictionaries
learnt
helpful
understanding
functions
