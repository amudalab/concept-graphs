linked lists in chapter 2  arrays  we saw that arrays had certain disadvantages as data storage structures in an unordered array  searching is slow  whereas in an ordered array  insertion is slow in both kinds of arrays  deletion is slow also  the size of an array can t be changed after it s created in this chapter we ll look at a data storage structure that solves some of these problems the linked list linked lists are probably the second most commonly used generalpurpose storage structures after arrays the linked list is a versatile mechanism suitable for use in many kinds of general purpose databases it can also replace an array as the basis for other storage structures such as stacks and queues in fact  you can use a linked list in many cases in which you use an array  unless you need frequent random access to individual items using an index linked lists aren t the solution to all data storage problems  but they are surprisingly versatile and conceptually simpler than some other popular structures such as trees we ll investigate their strengths and weaknesses as we go along in this chapter we ll look at simple linked lists  doubleended lists  sorted lists  doubly linked lists  and lists with iterators  an approach to random access to list elements   we ll also examine the idea of abstract data types  adts   and see how stacks and queues can be viewed as adts and how they can be implemented as linked lists instead of arrays links in a linked list  each data item is embedded in a link a link is an object of a class called something like link because there are many similar links in a list  it makes sense to use a separate class for them  distinct from the linked list itself each link object contains a reference  usually called next  to the next link in the list a field in the list itself contains a reference to the first link this relationship is shown in figure 5.1 180 chapter 5 linked lists linked list first data link next data link next data link next data link next null figure 5.1 links in a list here s part of the definition of a class link it contains some data and a reference to the next link class link  public int idata data public double ddata data public link next reference to next link  this kind of class definition is sometimes called self referential because it contains a field called next in this case of the same type as itself we show only two data items in the link an int and a double in a typical application there would be many more a personnel record  for example  might have name  address  social security number  title  salary  and many other fields often an object of a class that contains this data is used instead of the items class link  public inventoryitem ii object holding data public link next reference to next link  references and basic types you can easily get confused about references in the context of linked lists  so let s review how they work being able to put a field of type link inside the class definition of this same type may seem odd wouldn t the compiler be confused how can it figure out how big to make a link object if a link contains a link and the compiler doesn t already know how big a link object is the answer is that in java a link object doesn t really contain another link object  although it may look like it does the next field of type link is only a reference to another link  not an object a reference is a number that refers to an object it s the object s address in the computer s memory  but you don t need to know its value you just treat it as a magic number that tells you where the object is in a given computer/operating system  all references  no matter what they refer to  are the same size thus  it s no problem for the compiler to figure out how big this field should be and thereby construct an entire link object note that in java  primitive types such as int and double are stored quite differently than objects fields containing primitive types do not contain references  but actual numerical values like 7 or 3.14159 a variable definition like double salary = 65000.00 creates a space in memory and puts the number 65000.00 into this space however  a reference to an object like link alink = somelink puts a reference to an object of type link  called somelink  into alink the somelink object itself is located elsewhere it isn t moved  or even created  by this statement it must have been created before to create an object  you must always use new link somelink = new link   even the somelink field doesn t hold an object it s still just a reference the object is somewhere else in memory  as shown in figure 5.2 other languages  such as c + +  handle objects quite differently than java in c + + a field like link next actually contains an object of type link you can t write a self referential class definition in c + +  although you can put a pointer to a link in class link a pointer is similar to a reference   c + + programmers should keep in mind how java handles objects this usage may be counter intuitive links 181 figure 5.2 objects and references in memory relationship  not position let s examine one of the major ways in which linked lists differ from arrays in an array each item occupies a particular position this position can be directly accessed using an index number it s like a row of houses you can find a particular house using its address in a list the only way to find a particular element is to follow along the chain of elements it s more like human relations maybe you ask harry where bob is harry doesn t know  but he thinks jane might know  so you go and ask jane jane saw bob leave the office with sally  so you call sally s cell phone she dropped bob off at 182 chapter 5 linked lists alink somelink object of type link memory alink and somelink refer to an object of type link peter s office  so but you get the idea you can t access a data item directly you must use relationships between the items to locate it you start with the first item  go to the second  then the third  until you find what you re looking for the linklist workshop applet the linklist workshop applet provides three list operations you can insert a new data item  search for a data item with a specified key  and delete a data item with a specified key these operations are the same ones we explored in the array workshop applet in chapter 2 they re suitable for a general purpose database application figure 5.3 shows how the linklist workshop applet looks when it s started initially  there are 13 links on the list the linklist workshop applet 183 figure 5.3 the linklist workshop applet the insert button if you think 13 is an unlucky number  you can insert a new link press the ins button  and you ll be prompted to enter a key value between 0 and 999 subsequent presses will generate a link with this data in it  as shown in figure 5.4 in this version of a linked list  new links are always inserted at the beginning of the list this is the simplest approach  although you can also insert links anywhere in the list  as we ll see later a final press on ins will redraw the list so the newly inserted link lines up with the other links this redrawing doesn t represent anything happening in the program itself  it just makes the display neater figure 5.4 a new link being inserted the find button the find button allows you to find a link with a specified key value when prompted  type in the value of an existing link  preferably one somewhere in the middle of the list as you continue to press the button  you ll see the red arrow move along the list  looking for the link a message informs you when the arrow finds the link if you type a non existent key value  the arrow will search all the way to the end of the list before reporting that the item can t be found the delete button you can also delete a key with a specified value type in the value of an existing link and repeatedly press del again  the arrow will move along the list  looking for the link when the arrow finds the link  it simply removes that link and connects the arrow from the previous link straight across to the following link this is how links are removed the reference to the preceding link is changed to point to the following link a final keypress redraws the picture  but again redrawing just provides evenly spaced links for aesthetic reasons the length of the arrows doesn t correspond to anything in the program note the linklist workshop applet can create both unsorted and sorted lists unsorted is the default we ll show how to use the applet for sorted lists when we discuss them later in this chapter 184 chapter 5 linked lists a simple linked list our first example program  linklist.java  demonstrates a simple linked list the only operations allowed in this version of a list are inserting an item at the beginning of the list deleting the item at the beginning of the list iterating through the list to display its contents these operations are fairly easy to carry out  so we ll start with them  as we ll see later  these operations are also all you need to use a linked list as the basis for a stack  before we get to the complete linklist.java program  we ll look at some important parts of the link and linklist classes the link class you ve already seen the data part of the link class here s the complete class definition class link  public int idata data item public double ddata data item public link next next link in list public link  int id  double dd  constructor  idata = id initialize data ddata = dd  next is automatically  set to null  public void displaylink   display ourself  system.out.print   + idata +  + ddata +     end class link in addition to the data  there s a constructor and a method  displaylink    that displays the link s data in the format  22  33.9   object purists would probably object to naming this method displaylink    arguing that it should be simply display    using the shorter name would be in the spirit of polymorphism  but it makes the listing somewhat harder to understand when you see a statement like a simple linked list 185 current.display   and you ve forgotten whether current is a link object  a linklist object  or something else the constructor initializes the data there s no need to initialize the next field because it s automatically set to null when it s created  however  you could set it to null explicitly  for clarity  the null value means it doesn t refer to anything  which is the situation until the link is connected to other links we ve made the storage type of the link fields  idata and so on  public if they were private  we would need to provide public methods to access them  which would require extra code  thus making the listing longer and harder to read ideally  for security we would probably want to restrict link object access to methods of the linklist class however  without an inheritance relationship between these classes  that s not very convenient we could use the default access specifier  no keyword  to give the data package access  access restricted to classes in the same directory   but that has no effect in these demo programs  which occupy only one directory anyway the public specifier at least makes it clear that this data isn t private in a more serious program you would probably want to make all the data fields in the link class private the linklist class the linklist class contains only one data item a reference to the first link on the list this reference is called first it s the only permanent information the list maintains about the location of any of the links it finds the other links by following the chain of references from first  using each link s next field class linklist  private link first ref to first link on list public void linklist   constructor  first = null no items on list yet  public boolean isempty   true if list is empty  return  first = = null   186 chapter 5 linked lists  other methods go here  the constructor for linklist sets first to null this isn t really necessary because  as we noted  references are set to null automatically when they re created however  the explicit constructor makes it clear that this is how first begins when first has the value null  we know there are no items on the list if there were any items  first would contain a reference to the first one the isempty   method uses this fact to determine whether the list is empty the insertfirst   method the insertfirst   method of linklist inserts a new link at the beginning of the list this is the easiest place to insert a link because first already points to the first link to insert the new link  we need only set the next field in the newly created link to point to the old first link and then change first so it points to the newly created link this situation is shown in figure 5.5 a simple linked list 187 a  before insertion b  after insertion first next next next next first next next next next null null 42 7 98 14 42 link next 33 7 98 14 42 7 98 14 figure 5.5 inserting a new link in insertfirst   we begin by creating the new link using the data passed as arguments then we change the link references as we just noted insert at start of list public void insertfirst  int id  double dd   make new link link newlink = new link  id  dd  newlink.next = first newlink old first first = newlink first newlink  the arrows in the comments in the last two statements mean that a link  or the first field  connects to the next  downstream  link  in doubly linked lists we ll see upstream connections as well  symbolized by arrows  compare these two statements with figure 5.5 make sure you understand how the statements cause the links to be changed  as shown in the figure this kind of reference manipulation is the heart of linked list algorithms the deletefirst   method the deletefirst   method is the reverse of insertfirst    it disconnects the first link by rerouting first to point to the second link this second link is found by looking at the next field in the first link public link deletefirst   delete first item   assumes list not empty  link temp = first save reference to link first = first.next delete it first old next return temp return deleted link  the second statement is all you need to remove the first link from the list we choose to also return the link  for the convenience of the user of the linked list  so we save it in temp before deleting it and return the value of temp figure 5.6 shows how first is rerouted to delete the object in c + + and similar languages  you would need to worry about deleting the link itself after it was disconnected from the list it s in memory somewhere  but now nothing refers to it what will become of it in java  the garbage collection process will destroy it at some point in the future it s not your responsibility notice that the deletefirst   method assumes the list is not empty before calling it  your program should verify this fact with the isempty   method 188 chapter 5 linked lists figure 5.6 deleting a link the displaylist   method to display the list  you start at first and follow the chain of references from link to link a variable current points to  or technically refers to  each link in turn it starts off pointing to first  which holds a reference to the first link the statement current = current.next changes current to point to the next link because that s what s in the next field in each link here s the entire displaylist   method public void displaylist    system.out.print  list  first last   link current = first start at beginning of list while  current ! = null  until end of list   current.displaylink   print data current = current.next move to next link  system.out.println    the end of the list is indicated by the next field in the last link pointing to null rather than another link how did this field get to be null it started that way when the link was created and was never given any other value because it was always at a simple linked list 189 a  before deletion b  after deletion first first null null 27 94 6 33 94 6 33 the end of the list the while loop uses this condition to terminate itself when it reaches the end of the list figure 5.7 shows how current steps along the list 190 chapter 5 linked lists first next next next next null a  before current = current.next current first next next next next null b  after current = current.next current figure 5.7 stepping along the list at each link  the displaylist   method calls the displaylink   method to display the data in the link the linklist.java program listing 5.1 shows the complete linklist.java program you ve already seen all the components except the main   routine listing 5.1 the linklist.java program linklist.java demonstrates linked list to run this program c java linklistapp class link  public int idata data item  key  public double ddata data item public link next next link in list public link  int id  double dd  constructor  idata = id initialize data ddata = dd  next is automatically  set to null  public void displaylink   display ourself  system.out.print   + idata +  + ddata +     end class link class linklist  private link first ref to first link on list public linklist   constructor  first = null no items on list yet  public boolean isempty   true if list is empty  return  first = = null   insert at start of list public void insertfirst  int id  double dd   make new link link newlink = new link  id  dd  newlink.next = first newlink old first first = newlink first newlink  public link deletefirst   delete first item   assumes list not empty  link temp = first save reference to link first = first.next delete it first old next return temp return deleted link  a simple linked list 191 listing 5.1 continued public void displaylist    system.out.print  list  first last   link current = first start at beginning of list while  current ! = null  until end of list   current.displaylink   print data current = current.next move to next link  system.out.println     end class linklist class linklistapp  public static void main  string   args   linklist thelist = new linklist   make new list thelist.insertfirst  22  2.99  insert four items thelist.insertfirst  44  4.99  thelist.insertfirst  66  6.99  thelist.insertfirst  88  8.99  thelist.displaylist   display list while  ! thelist.isempty    until it s empty   link alink = thelist.deletefirst   delete link system.out.print  deleted  display it alink.displaylink   system.out.println    thelist.displaylist   display list  end main    end class linklistapp 192 chapter 5 linked lists listing 5.1 continued in main   we create a new list  insert four new links into it with insertfirst    and display it then  in the while loop  we remove the items one by one with deletefirst   until the list is empty the empty list is then displayed here s the output from linklist.java list  first last   88  8.99   66  6.99   44  4.99   22  2.99  deleted  88  8.99  deleted  66  6.99  deleted  44  4.99  deleted  22  2.99  list  first last  finding and deleting specified links our next example program adds methods to search a linked list for a data item with a specified key value and to delete an item with a specified key value these  along with insertion at the start of the list  are the same operations carried out by the linklist workshop applet the complete linklist2.java program is shown in listing 5.2 listing 5.2 the linklist2.java program linklist2.java demonstrates linked list to run this program c java linklist2app class link  public int idata data item  key  public double ddata data item public link next next link in list public link  int id  double dd  constructor  idata = id ddata = dd  public void displaylink   display ourself  system.out.print   + idata +  + ddata +     end class link finding and deleting specified links 193 class linklist  private link first ref to first link on list public linklist   constructor  first = null no links on list yet  public void insertfirst  int id  double dd   make new link link newlink = new link  id  dd  newlink.next = first it points to old first link first = newlink now first points to this  public link find  int key  find link with given key   assumes non empty list  link current = first start at first while  current.idata ! = key  while no match   if  current.next = = null  if end of list  return null didn t find it else not end of list  current = current.next go to next link  return current found it  public link delete  int key  delete link with given key   assumes non empty list  link current = first search for link link previous = first while  current.idata ! = key   if  current.next = = null  return null didn t find it else  previous = current go to next link 194 chapter 5 linked lists listing 5.2 continued current = current.next   found it if  current = = first  if first link  first = first.next change first else otherwise  previous.next = current.next bypass it return current  public void displaylist   display the list  system.out.print  list  first last   link current = first start at beginning of list while  current ! = null  until end of list   current.displaylink   print data current = current.next move to next link  system.out.println     end class linklist class linklist2app  public static void main  string   args   linklist thelist = new linklist   make list thelist.insertfirst  22  2.99  insert 4 items thelist.insertfirst  44  4.99  thelist.insertfirst  66  6.99  thelist.insertfirst  88  8.99  thelist.displaylist   display list link f = thelist.find  44  find item if  f ! = null  system.out.println  found link with key + f.idata  else finding and deleting specified links 195 listing 5.2 continued system.out.println  can t find link  link d = thelist.delete  66  delete item if  d ! = null  system.out.println  deleted link with key + d.idata  else system.out.println  can t delete link  thelist.displaylist   display list  end main    end class linklist2app the main   routine makes a list  inserts four items  and displays the resulting list it then searches for the item with key 44  deletes the item with key 66  and displays the list again here s the output list  first last   88  8.99   66  6.99   44  4.99   22  2.99  found link with key 44 deleted link with key 66 list  first last   88  8.99   44  4.99   22  2.99  the find   method the find   method works much like the displaylist   method in the linklist.java program the reference current initially points to first and then steps its way along the links by setting itself repeatedly to current.next at each link  find   checks whether that link s key is the one it s looking for if the key is found  it returns with a reference to that link if find   reaches the end of the list without finding the desired link  it returns null the delete   method the delete   method is similar to find   in the way it searches for the link to be deleted however  it needs to maintain a reference not only to the current link  current   but to the link preceding the current link  previous   it does so because  if it deletes the current link  it must connect the preceding link to the following link  as shown in figure 5.8 the only way to tell where the preceding link is located is to maintain a reference to it 196 chapter 5 linked lists listing 5.2 continued figure 5.8 deleting a specified link at each cycle through the while loop  just before current is set to current.next  previous is set to current this keeps it pointing at the link preceding current to delete the current link once it s found  the next field of the previous link is set to the next link a special case arises if the current link is the first link because the first link is pointed to by the linklist s first field and not by another link in this case the link is deleted by changing first to point to first.next  as we saw in the linklist.java program with the deletefirst   method here s the code that covers these two possibilities found it if  current = = first  if first link  first = first.next change first else otherwise  previous.next = current.next bypass link other methods we ve seen methods to insert and delete items at the start of a list  and to find a specified item and delete a specified item you can imagine other useful list methods for example  an insertafter   method could find a link with a specified key value and insert a new link following it we ll see such a method when we talk about list iterators at the end of this chapter finding and deleting specified links 197 a  before deletion b  after deletion first next next next previous current next null first null previous current 17 44 98 73 17 44 73 next next next 17 44 98 17 73 double ended lists a double ended list is similar to an ordinary linked list  but it has one additional feature a reference to the last link as well as to the first figure 5.9 shows such a list 198 chapter 5 linked lists first last next next next next null figure 5.9 a double ended list the reference to the last link permits you to insert a new link directly at the end of the list as well as at the beginning of course  you can insert a new link at the end of an ordinary single ended list by iterating through the entire list until you reach the end  but this approach is inefficient access to the end of the list as well as the beginning makes the double ended list suitable for certain situations that a single ended list can t handle efficiently one such situation is implementing a queue we ll see how this technique works in the next section listing 5.3 contains the firstlastlist.java program  which demonstrates a doubleended list  incidentally  don t confuse the double ended list with the doubly linked list  which we ll explore later in this chapter  listing 5.3 the firstlastlist.java program firstlastlist.java demonstrates list with first and last references to run this program c java firstlastapp class link  public long ddata data item public link next next link in list public link  long d  constructor  ddata = d  public void displaylink   display this link  system.out.print  ddata +    end class link class firstlastlist  private link first ref to first link private link last ref to last link public firstlastlist   constructor  first = null no links on list yet last = null  public boolean isempty   true if no links  return first = = null  public void insertfirst  long dd  insert at front of list  link newlink = new link  dd  make new link if  isempty    if empty list  last = newlink newlink last newlink.next = first newlink old first first = newlink first newlink  public void insertlast  long dd  insert at end of list  link newlink = new link  dd  make new link if  isempty    if empty list  first = newlink first newlink else last.next = newlink old last newlink last = newlink newlink last  public long deletefirst   delete first link   assumes non empty list  long temp = first.ddata if  first.next = = null  if only one item double ended lists 199 listing 5.3 continued last = null null last first = first.next first old next return temp  public void displaylist    system.out.print  list  first last   link current = first start at beginning while  current ! = null  until end of list   current.displaylink   print data current = current.next move to next link  system.out.println     end class firstlastlist class firstlastapp  public static void main  string   args   make a new list firstlastlist thelist = new firstlastlist   thelist.insertfirst  22  insert at front thelist.insertfirst  44  thelist.insertfirst  66  thelist.insertlast  11  insert at rear thelist.insertlast  33  thelist.insertlast  55  thelist.displaylist   display the list thelist.deletefirst   delete first two items thelist.deletefirst   thelist.displaylist   display again  end main    end class firstlastapp 200 chapter 5 linked lists listing 5.3 continued for simplicity  in this program we ve reduced the number of data items in each link from two to one this makes it easier to display the link contents  remember that in a serious program there would be many more data items  or a reference to another object containing many data items  this program inserts three items at the front of the list  inserts three more at the end  and displays the resulting list it then deletes the first two items and displays the list again here s the output list  first last  66 44 22 11 33 55 list  first last  22 11 33 55 notice how repeated insertions at the front of the list reverse the order of the items  while repeated insertions at the end preserve the order the double ended list class is called the firstlastlist as discussed  it has two data items  first and last  which point to the first item and the last item in the list if there is only one item in the list  both first and last point to it  and if there are no items  they are both null the class has a new method  insertlast    that inserts a new item at the end of the list this process involves modifying last.next to point to the new link and then changing last to point to the new link  as shown in figure 5.10 double ended lists 201 first last first next next next next null a  before insertion first last next next next next null b  after insertion figure 5.10 insertion at the end of a list the insertion and deletion routines are similar to those in a single ended list however  both insertion routines must watch out for the special case when the list is empty prior to the insertion that is  if isempty   is true  then insertfirst   must set last to the new link  and insertlast   must set first to the new link if inserting at the beginning with insertfirst    first is set to point to the new link  although when inserting at the end with insertlast    last is set to point to the new link deleting from the start of the list is also a special case if it s the last item on the list last must be set to point to null in this case unfortunately  making a list double ended doesn t help you to delete the last link because there is still no reference to the next to last link  whose next field would need to be changed to null if the last link were deleted to conveniently delete the last link  you would need a doubly linked list  which we ll look at soon  of course  you could also traverse the entire list to find the last link  but that s not very efficient  linked list efficiency insertion and deletion at the beginning of a linked list are very fast they involve changing only one or two references  which takes o  1  time finding  deleting  or inserting next to a specific item requires searching through  on the average  half the items in the list this requires o  n  comparisons an array is also o  n  for these operations  but the linked list is nevertheless faster because nothing needs to be moved when an item is inserted or deleted the increased efficiency can be significant  especially if a copy takes much longer than a comparison of course  another important advantage of linked lists over arrays is that a linked list uses exactly as much memory as it needs and can expand to fill all of available memory the size of an array is fixed when it s created this usually leads to inefficiency because the array is too large  or to running out of room because the array is too small vectors  which are expandable arrays  may solve this problem to some extent  but they usually expand in fixed sized increments  such as doubling the size of the array whenever it s about to overflow   this solution is still not as efficient a use of memory as a linked list abstract data types in this section we ll shift gears and discuss a topic that s more general than linked lists abstract data types  adts   what is an adt roughly speaking  it s a way of looking at a data structure focusing on what it does and ignoring how it does its job 202 chapter 5 linked lists stacks and queues are examples of adts we ve already seen that both stacks and queues can be implemented using arrays before we return to a discussion of adts  let s see how stacks and queues can be implemented using linked lists this discussion will demonstrate the abstract nature of stacks and queues how they can be considered separately from their implementation a stack implemented by a linked list when we created a stack in chapter 4  stacks and queues  we used an ordinary java array to hold the stack s data the stack s push   and pop   operations were actually carried out by array operations such as arr  + + top  = data and data = arr  top  which insert data into  and take it out of  an array we can also use a linked list to hold a stack s data in this case the push   and pop   operations would be carried out by operations like thelist.insertfirst  data  and data = thelist.deletefirst   the user of the stack class calls push   and pop   to insert and delete items without knowing  or needing to know  whether the stack is implemented as an array or as a linked list listing 5.4 shows how a stack class called linkstack can be implemented using the linklist class instead of an array  object purists would argue that the name linkstack should be simply stack because users of this class shouldn t need to know that it s implemented as a list  listing 5.4 the linkstack.java program linkstack.java demonstrates a stack implemented as a list to run this program c java linkstackapp class link  public long ddata data item public link next next link in list abstract data types 203 public link  long dd  constructor  ddata = dd  public void displaylink   display ourself  system.out.print  ddata +    end class link class linklist  private link first ref to first item on list public linklist   constructor  first = null  no items on list yet public boolean isempty   true if list is empty  return  first = = null   public void insertfirst  long dd  insert at start of list  make new link link newlink = new link  dd  newlink.next = first newlink old first first = newlink first newlink  public long deletefirst   delete first item   assumes list not empty  link temp = first save reference to link first = first.next delete it first old next return temp.ddata return deleted link  public void displaylist    link current = first start at beginning of list while  current ! = null  until end of list   current.displaylink   print data current = current.next move to next link  system.out.println   204 chapter 5 linked lists listing 5.4 continued   end class linklist class linkstack  private linklist thelist public linkstack   constructor  thelist = new linklist    public void push  long j  put item on top of stack  thelist.insertfirst  j   public long pop   take item from top of stack  return thelist.deletefirst    public boolean isempty   true if stack is empty  return  thelist.isempty     public void displaystack    system.out.print  stack  top bottom   thelist.displaylist     end class linkstack class linkstackapp  public static void main  string   args   linkstack thestack = new linkstack   make stack abstract data types 205 listing 5.4 continued thestack.push  20  push items thestack.push  40  thestack.displaystack   display stack thestack.push  60  push items thestack.push  80  thestack.displaystack   display stack thestack.pop   pop items thestack.pop   thestack.displaystack   display stack  end main    end class linkstackapp the main   routine creates a stack object  pushes two items on it  displays the stack  pushes two more items  and displays the stack again finally  it pops two items and displays the stack a third time here s the output stack  top bottom  40 20 stack  top bottom  80 60 40 20 stack  top bottom  40 20 notice the overall organization of this program the main   routine in the linkstackapp class relates only to the linkstack class the linkstack class relates only to the linklist class there s no communication between main   and the linklist class more specifically  when a statement in main   calls the push   operation in the linkstack class  this method in turn calls insertfirst   in the linklist class to actually insert data similarly  pop   calls deletefirst   to delete an item  and displaystack   calls displaylist   to display the stack to the class user  writing code in main    there is no difference between using the list based linkstack class and using the array based stack class from the stack.java program  listing 4.1  in chapter 4 a queue implemented by a linked list here s a similar example of an adt implemented with a linked list listing 5.5 shows a queue implemented as a double ended linked list 206 chapter 5 linked lists listing 5.4 continued listing 5.5 the linkqueue.java program linkqueue.java demonstrates queue implemented as double ended list to run this program c java linkqueueapp class link  public long ddata data item public link next next link in list public link  long d  constructor  ddata = d  public void displaylink   display this link  system.out.print  ddata +    end class link class firstlastlist  private link first ref to first item private link last ref to last item public firstlastlist   constructor  first = null no items on list yet last = null  public boolean isempty   true if no links  return first = = null  public void insertlast  long dd  insert at end of list  link newlink = new link  dd  make new link if  isempty    if empty list  first = newlink first newlink else last.next = newlink old last newlink last = newlink newlink last  abstract data types 207 public long deletefirst   delete first link   assumes non empty list  long temp = first.ddata if  first.next = = null  if only one item last = null null last first = first.next first old next return temp  public void displaylist    link current = first start at beginning while  current ! = null  until end of list   current.displaylink   print data current = current.next move to next link  system.out.println     end class firstlastlist class linkqueue  private firstlastlist thelist public linkqueue   constructor  thelist = new firstlastlist    make a 2 ended list public boolean isempty   true if queue is empty  return thelist.isempty    public void insert  long j  insert  rear of queue  thelist.insertlast  j   public long remove   remove  front of queue  return thelist.deletefirst    public void displayqueue    system.out.print  queue  front rear   208 chapter 5 linked lists listing 5.5 continued thelist.displaylist     end class linkqueue class linkqueueapp  public static void main  string   args   linkqueue thequeue = new linkqueue   thequeue.insert  20  insert items thequeue.insert  40  thequeue.displayqueue   display queue thequeue.insert  60  insert items thequeue.insert  80  thequeue.displayqueue   display queue thequeue.remove   remove items thequeue.remove   thequeue.displayqueue   display queue  end main   the program creates a queue  inserts two items  inserts two more items  and removes two items following each of these operations the queue is displayed here s the output queue  front rear  20 40 queue  front rear  20 40 60 80 queue  front rear  60 80 here the methods insert   and remove   in the linkqueue class are implemented by the insertlast   and deletefirst   methods of the firstlastlist class we ve substituted a linked list for the array used to implement the queue in the queue.java program  listing 4.4  of chapter 4 the linkstack.java and linkqueue.java programs emphasize that stacks and queues are conceptual entities  separate from their implementations a stack can be implemented equally well by an array or by a linked list what s important about a stack is abstract data types 209 listing 5.5 continued the push   and pop   operations and how they re used it s not the underlying mechanism used to implement these operations when would you use a linked list as opposed to an array as the implementation of a stack or queue one consideration is how accurately you can predict the amount of data the stack or queue will need to hold if this isn t clear  the linked list gives you more flexibility than an array both are fast  so speed is probably not a major consideration data types and abstraction where does the term abstract data type come from let s look at the data type part of it first and then return to abstract data types the phrase data type covers a lot of ground it was first applied to built in types such as int and double this is probably what you first think of when you hear the term when you talk about a primitive type  you re actually referring to two things a data item with certain characteristics and permissible operations on that data for example  type int variables in java can have whole number values between 2,147,483,648 and + 2,147,483,647  and the operators and so on can be applied to them the data type s permissible operations are an inseparable part of its identity understanding the type means understanding what operations can be performed on it with the advent of object oriented programming  you could now create your own data types using classes some of these data types represent numerical quantities that are used in ways similar to primitive types you can  for example  define a class for time  with fields for hours  minutes  seconds   a class for fractions  with numerator and denominator fields   and a class for extra long numbers  characters in a string represent the digits   all these classes can be added and subtracted like int and double  except that in java you must use methods with functional notation like add   and sub   rather than operators like + and  the phrase data type seems to fit naturally with such quantity oriented classes however  it is also applied to classes that don t have this quantitative aspect in fact  any class represents a data type  in the sense that a class is made up of data  fields  and permissible operations on that data  methods   by extension  when a data storage structure like a stack or queue is represented by a class  it too can be referred to as a data type a stack is different in many ways from an int  but they are both defined as a certain arrangement of data and a set of operations on that data 210 chapter 5 linked lists abstraction the word abstract means considered apart from detailed specifications or implementation an abstraction is the essence or important characteristics of something the office of president  for example  is an abstraction  considered apart from the individual who happens to occupy that office the powers and responsibilities of the office remain the same  while individual office holders come and go in object oriented programming  then  an abstract data type is a class considered without regard to its implementation it s a description of the data in the class  fields   a list of operations  methods  that can be carried out on that data  and instructions on how to use these operations specifically excluded are the details of how the methods carry out their tasks as a class user  you re told what methods to call  how to call them  and the results you can expect  but not how they work the meaning of abstract data type is further extended when it s applied to data structures such as stacks and queues as with any class  it means the data and the operations that can be performed on it  but in this context even the fundamentals of how the data is stored become invisible to the user users not only don t know how the methods work  they also don t know what structure is used to store the data for the stack  the user knows that push   and pop    and perhaps a few other methods  exist and how they work the user doesn t  at least not usually  need to know how push   and pop   work  or whether data is stored in an array  a linked list  or some other data structure like a tree the interface an adt specification is often called an interface it s what the class user sees usually its public methods in a stack class  push   and pop   and similar methods form the interface adt lists now that we know what an abstract data type is  we can mention another one the list a list  sometimes called a linear list  is a group of items arranged in a linear order that is  they re lined up in a certain way  like beads on a string or houses on a street lists support certain fundamental operations you can insert an item  delete an item  and usually read an item from a specified location  the third item  say   don t confuse the adt list with the linked list we ve been discussing in this chapter a list is defined by its interface the specific methods used to interact with it this interface can be implemented by various structures  including arrays and linked lists the list is an abstraction of such data structures abstract data types 211 adts as a design tool the adt concept is a useful aid in the software design process if you need to store data  start by considering the operations that need to be performed on that data do you need access to the last item inserted the first one an item with a specified key an item in a certain position answering such questions leads to the definition of an adt only after the adt is completely defined should you worry about the details of how to represent the data and how to code the methods that access the data by decoupling the specification of the adt from the implementation details  you can simplify the design process you also make it easier to change the implementation at some future time if a user relates only to the adt interface  you should be able to change the implementation without breaking the user s code of course  once the adt has been designed  the underlying data structure must be carefully chosen to make the specified operations as efficient as possible if you need random access to element n  for example  the linked list representation isn t so good because random access isn t an efficient operation for a linked list you d be better off with an array note remember that the adt concept is only a conceptual tool data storage structures are not divided cleanly into some that are adts and some that are used to implement adts a linked list  for example  doesn t need to be wrapped in a list interface to be useful it can act as an adt on its own  or it can be used to implement another data type such as a queue a linked list can be implemented using an array  and an array type structure can be implemented using a linked list what s an adt and what s a more basic structure must be determined in a given context sorted lists in the linked lists we ve seen thus far  there was no requirement that data be stored in order however  for certain applications it s useful to maintain the data in sorted order within the list a list with this characteristic is called a sorted list in a sorted list  the items are arranged in sorted order by key value deletion is often limited to the smallest  or the largest  item in the list  which is at the start of the list  although sometimes find   and delete   methods  which search through the list for specified links  are used as well in general you can use a sorted list in most situations in which you use a sorted array the advantages of a sorted list over a sorted array are speed of insertion  because elements don t need to be moved  and the fact that a list can expand to fill 212 chapter 5 linked lists available memory  while an array is limited to a fixed size however  a sorted list is somewhat more difficult to implement than a sorted array later we ll look at one application for sorted lists sorting data a sorted list can also be used to implement a priority queue  although a heap  see chapter 12  heaps  is a more common implementation the linklist workshop applet introduced at the beginning of this chapter demonstrates sorted as well as unsorted lists to see how sorted lists work  use the new button to create a new list with about 20 links  and when prompted  click on the sorted button the result is a list with data in sorted order  as shown in figure 5.11 sorted lists 213 figure 5.11 the linklist workshop applet with a sorted list use the ins button to insert a new item type in a value that will fall somewhere in the middle of the list watch as the algorithm traverses the links  looking for the appropriate insertion place when it finds the correct location  it inserts the new link  as shown in figure 5.12 with the next press of ins  the list will be redrawn to regularize its appearance you can also find a specified link using the find button and delete a specified link using the del button java code to insert an item in a sorted list to insert an item in a sorted list  the algorithm must first search through the list until it finds the appropriate place to put the item this is just before the first item that s larger  as shown in figure 5.12 figure 5.12 a newly inserted link when the algorithm finds where to put it  the item can be inserted in the usual way by changing next in the new link to point to the next link and changing next in the previous link to point to the new link however  we need to consider some special cases the link might need to be inserted at the beginning of the list  or it might need to go at the end let s look at the code public void insert  long key  insert in order  link newlink = new link  key  make new link link previous = null start at first link current = first until end of list  while  current ! = null && key current.ddata   or key current  previous = current current = current.next go to next item  if  previous = = null  at beginning of list first = newlink first newlink else not at beginning previous.next = newlink old prev newlink newlink.next = current newlink old current  end insert   we need to maintain a previous reference as we move along  so we can modify the previous link s next field to point to the new link after creating the new link  we 214 chapter 5 linked lists prepare to search for the insertion point by setting current to first in the usual way we also set previous to null this step is important because later we ll use this null value to determine whether we re still at the beginning of the list the while loop is similar to those we ve used before to search for the insertion point  but there s an added condition the loop terminates when the key of the link currently being examined  current.ddata  is no longer smaller than the key of the link being inserted  key  this is the most usual case  where a key is inserted somewhere in the middle of the list however  the while loop also terminates if current is null this happens at the end of the list  the next field of the last element is null   or if the list is empty to begin with  first is null   when the while loop terminates  then  we may be at the beginning  the middle  or the end of the list  or the list may be empty if we re at the beginning  or the list is empty  previous will be null so we set first to the new link otherwise  we re in the middle of the list  or at the end  and we set previous.next to the new link in any case we set the new link s next field to current if we re at the end of the list  current is null  so the new link s next field is appropriately set to this value the sortedlist.java program the sortedlist.java example shown in listing 5.6 presents a sortedlist class with insert    remove    and displaylist   methods only the insert   routine is different from its counterpart in non sorted lists listing 5.6 the sortedlist.java program sortedlist.java demonstrates sorted list to run this program c java sortedlistapp class link  public long ddata data item public link next next link in list public link  long dd  constructor  ddata = dd  public void displaylink   display this link  system.out.print  ddata +   sorted lists 215  end class link class sortedlist  private link first ref to first item on list public sortedlist   constructor  first = null  public boolean isempty   true if no links  return  first = = null   public void insert  long key  insert  in order  link newlink = new link  key  make new link link previous = null start at first link current = first until end of list  while  current ! = null && key current.ddata   or key current  previous = current current = current.next go to next item  if  previous = = null  at beginning of list first = newlink first newlink else not at beginning previous.next = newlink old prev newlink newlink.next = current newlink old current  end insert   public link remove   return & delete first link   assumes non empty list  link temp = first save first first = first.next delete first return temp return value  public void displaylist    system.out.print  list  first last   link current = first start at beginning of list 216 chapter 5 linked lists listing 5.6 continued while  current ! = null  until end of list   current.displaylink   print data current = current.next move to next link  system.out.println     end class sortedlist class sortedlistapp  public static void main  string   args   create new list sortedlist thesortedlist = new sortedlist   thesortedlist.insert  20  insert 2 items thesortedlist.insert  40  thesortedlist.displaylist   display list thesortedlist.insert  10  insert 3 more items thesortedlist.insert  30  thesortedlist.insert  50  thesortedlist.displaylist   display list thesortedlist.remove   remove an item thesortedlist.displaylist   display list  end main    end class sortedlistapp in main   we insert two items with key values 20 and 40 then we insert three more items  with values 10  30  and 50 these values are inserted at the beginning of the list  in the middle  and at the end  showing that the insert   routine correctly handles these special cases finally  we remove one item  to show removal is always from the front of the list after each change  the list is displayed here s the output from sortedlist.java list  first last  20 40 list  first last  10 20 30 40 50 list  first last  20 30 40 50 sorted lists 217 listing 5.6 continued efficiency of sorted linked lists insertion and deletion of arbitrary items in the sorted linked list require o  n  comparisons  n/2 on the average  because the appropriate location must be found by stepping through the list however  the minimum value can be found  or deleted  in o  1  time because it s at the beginning of the list if an application frequently accesses the minimum item  and fast insertion isn t critical  then a sorted linked list is an effective choice a priority queue might be implemented by a sorted linked list  for example list insertion sort a sorted list can be used as a fairly efficient sorting mechanism suppose you have an array of unsorted data items if you take the items from the array and insert them one by one into the sorted list  they ll be placed in sorted order automatically if you then remove them from the list and put them back in the array  the array will be sorted this type of sort turns out to be substantially more efficient than the more usual insertion sort within an array  described in chapter 3  simple sorting  because fewer copies are necessary it s still an o  n2  process because inserting each item into the sorted list involves comparing a new item with an average of half the items already in the list  and there are n items to insert  resulting in about n2/4 comparisons however  each item is copied only twice once from the array to the list and once from the list to the array n * 2 copies compares favorably with the insertion sort within an array  where there are about n2 copies listing 5.7 shows the listinsertionsort.java program  which starts with an array of unsorted items of type link  inserts them into a sorted list  using a constructor   and then removes them and places them back into the array listing 5.7 the listinsertionsort.java program listinsertionsort.java demonstrates sorted list used for sorting to run this program c java listinsertionsortapp class link  public long ddata data item public link next next link in list public link  long dd  constructor  ddata = dd  218 chapter 5 linked lists  end class link class sortedlist  private link first ref to first item on list public sortedlist   constructor  no args   first = null  initialize list public sortedlist  link   linkarr  constructor  array  as argument  first = null initialize list for  int j = 0 j linkarr.length j + +  copy array insert  linkarr  j   to list  public void insert  link k  insert  in order   link previous = null start at first link current = first until end of list  while  current ! = null && k.ddata current.ddata   or key current  previous = current current = current.next go to next item  if  previous = = null  at beginning of list first = k first k else not at beginning previous.next = k old prev k k.next = current k old current  end insert   public link remove   return & delete first link   assumes non empty list  link temp = first save first first = first.next delete first return temp return value   end class sortedlist sorted lists 219 listing 5.7 continued class listinsertionsortapp  public static void main  string   args   int size = 10 create array of links link   linkarray = new link  size  for  int j = 0 j size j + +  fill array with links  random number int n =  int   java.lang.math.random   * 99  link newlink = new link  n  make link linkarray  j  = newlink put in array  display array contents system.out.print  unsorted array  for  int j = 0 j size j + +  system.out.print  linkarray  j  .ddata +  system.out.println   create new list initialized with array sortedlist thesortedlist = new sortedlist  linkarray  for  int j = 0 j size j + +  links from list to array linkarray  j  = thesortedlist.remove   display array contents system.out.print  sorted array  for  int j = 0 j size j + +  system.out.print  linkarray  j  .ddata +  system.out.println    end main    end class listinsertionsortapp this program displays the values in the array before the sorting operation and again afterward here s some sample output unsorted array 59 69 41 56 84 15 86 81 37 35 sorted array 15 35 37 41 56 59 69 81 84 86 220 chapter 5 linked lists listing 5.7 continued the output will be different each time because the initial values are generated randomly a new constructor for sortedlist takes an array of link objects as an argument and inserts the entire contents of this array into the newly created list by doing so  it helps make things easier for the client  the main   routine   we ve also made a change to the insert   routine in this program it now accepts a link object as an argument  rather than a long we do this so we can store link objects in the array and insert them directly into the list in the sortedlist.java program  listing 5.6   it was more convenient to have the insert   routine create each link object  using the long value passed as an argument the downside of the list insertion sort  compared with an array based insertion sort  is that it takes somewhat more than twice as much memory the array and linked list must be in memory at the same time however  if you have a sorted linked list class handy  the list insertion sort is a convenient way to sort arrays that aren t too large doubly linked lists let s examine another variation on the linked list the doubly linked list  not to be confused with the double ended list   what s the advantage of a doubly linked list a potential problem with ordinary linked lists is that it s difficult to traverse backward along the list a statement like current = current.next steps conveniently to the next link  but there s no corresponding way to go to the previous link depending on the application  this limitation could pose problems for example  imagine a text editor in which a linked list is used to store the text each text line on the screen is stored as a string object embedded in a link when the editor s user moves the cursor downward on the screen  the program steps to the next link to manipulate or display the new line but what happens if the user moves the cursor upward in an ordinary linked list  you would need to return current  or its equivalent  to the start of the list and then step all the way down again to the new current link this isn t very efficient you want to make a single step upward the doubly linked list provides this capability it allows you to traverse backward as well as forward through the list the secret is that each link has two references to other links instead of one the first is to the next link  as in ordinary lists the second is to the previous link this type of list is shown in figure 5.13 doubly linked lists 221 figure 5.13 a doubly linked list the beginning of the specification for the link class in a doubly linked list looks like this class link  public long ddata data item public link next next link in list public link previous previous link in list   the downside of doubly linked lists is that every time you insert or delete a link you must deal with four links instead of two two attachments to the previous link and two attachments to the following one also  of course  each link is a little bigger because of the extra reference a doubly linked list doesn t necessarily need to be a double ended list  keeping a reference to the last element on the list  but creating it this way is useful  so we ll include it in our example we ll show the complete listing for the doublylinked.java program soon  but first let s examine some of the methods in its doublylinkedlist class traversal two display methods demonstrate traversal of a doubly linked list the displayforward   method is the same as the displaylist   method we ve seen in ordinary linked lists the displaybackward   method is similar but starts at the last element in the list and proceeds toward the start of the list  going to each element s previous field this code fragment shows how this process works link current = last start at end while  current ! = null  until start of list  current = current.previous move to previous link 222 chapter 5 linked lists first last next prev next prev next prev next prev null null incidentally  some people take the view that  because you can go either way equally easily on a doubly linked list  there is no preferred direction and therefore terms like previous and next are inappropriate if you prefer  you can substitute directionneutral terms such as left and right insertion we ve included several insertion routines in the doublylinkedlist class the insertfirst   method inserts at the beginning of the list  insertlast   inserts at the end  and insertafter   inserts following an element with a specified key unless the list is empty  the insertfirst   routine changes the previous field in the old first link to point to the new link and changes the next field in the new link to point to the old first link finally  it sets first to point to the new link this process is shown in figure 5.14 doubly linked lists 223 first last next old first link prev next prev next prev next prev next prev null null new link figure 5.14 insertion at the beginning if the list is empty  the last field must be changed instead of the first.previous field here s the code if  isempty    if empty list  last = newlink newlink last else first.previous = newlink newlink old first newlink.next = first newlink old first first = newlink first newlink the insertlast   method is the same process applied to the end of the list it s a mirror image of insertfirst    the insertafter   method inserts a new link following the link with a specified key value it s a bit more complicated because four connections must be made first  the link with the specified key value must be found this procedure is handled the same way as the find   routine in the linklist2.java program  listing 5.2   then  assuming we re not at the end of the list  two connections must be made between the new link and the next link  and two more between current and the new link this process is shown in figure 5.15 224 chapter 5 linked lists first last next current prev next prev next prev next prev next prev null null figure 5.15 insertion at an arbitrary location if the new link will be inserted at the end of the list  its next field must point to null  and last must point to the new link here s the insertafter   code that deals with the links if  current = = last  if last link   newlink.next = null newlink null last = newlink newlink last  else not last link   newlink.next = current.next newlink old next newlink old next current.next.previous = newlink  newlink.previous = current old current newlink current.next = newlink old current newlink perhaps you re unfamiliar with the use of two dot operators in the same expression it s a natural extension of a single dot operator the expression current.next.previous means the previous field of the link referred to by the next field in the link current deletion there are three deletion routines deletefirst    deletelast    and deletekey    the first two are fairly straightforward in deletekey    the key being deleted is current assuming the link to be deleted is neither the first nor the last one in the list  the next field of current.previous  the link before the one being deleted  is set to point to current.next  the link following the one being deleted   and the previous field of current.next is set to point to current.previous this disconnects the current link from the list figure 5.16 shows how this disconnection looks  and the following two statements carry it out current.previous.next = current.next current.next.previous = current.previous doubly linked lists 225 first current.prev last next prev prev prev next next null null current current.next figure 5.16 deleting an arbitrary link special cases arise if the link to be deleted is either the first or last in the list because first or last must be set to point to the next or the previous link here s the code from deletekey   for dealing with link connections if  current = = first  first item first = current.next first old next else not first old previous old next current.previous.next = current.next if  current = = last  last item last = current.previous old previous last else not last old previous old next current.next.previous = current.previous the doublylinked.java program listing 5.8 shows the complete doublylinked.java program  which includes all the routines just discussed listing 5.8 the doublylinked.java program doublylinked.java demonstrates doubly linked list to run this program c java doublylinkedapp class link  public long ddata data item public link next next link in list public link previous previous link in list public link  long d  constructor  ddata = d  public void displaylink   display this link  system.out.print  ddata +    end class link class doublylinkedlist  private link first ref to first item private link last ref to last item public doublylinkedlist   constructor  first = null no items on list yet last = null  226 chapter 5 linked lists public boolean isempty   true if no links  return first = = null  public void insertfirst  long dd  insert at front of list  link newlink = new link  dd  make new link if  isempty    if empty list  last = newlink newlink last else first.previous = newlink newlink old first newlink.next = first newlink old first first = newlink first newlink  public void insertlast  long dd  insert at end of list  link newlink = new link  dd  make new link if  isempty    if empty list  first = newlink first newlink else  last.next = newlink old last newlink newlink.previous = last old last newlink  last = newlink newlink last  public link deletefirst   delete first link   assumes non empty list  link temp = first if  first.next = = null  if only one item last = null null last else first.next.previous = null null old next first = first.next first old next return temp  public link deletelast   delete last link doubly linked lists 227 listing 5.8 continued   assumes non empty list  link temp = last if  first.next = = null  if only one item first = null first null else last.previous.next = null old previous null last = last.previous old previous last return temp  insert dd just after key public boolean insertafter  long key  long dd    assumes non empty list  link current = first start at beginning while  current.ddata ! = key  until match is found   current = current.next move to next link if  current = = null  return false didn t find it  link newlink = new link  dd  make new link if  current = = last  if last link   newlink.next = null newlink null last = newlink newlink last  else not last link   newlink.next = current.next newlink old next newlink old next current.next.previous = newlink  newlink.previous = current old current newlink current.next = newlink old current newlink return true found it  did insertion  public link deletekey  long key  delete item w/ given key   assumes non empty list  link current = first start at beginning 228 chapter 5 linked lists listing 5.8 continued while  current.ddata ! = key  until match is found   current = current.next move to next link if  current = = null  return null didn t find it  if  current = = first  found it first item first = current.next first old next else not first old previous old next current.previous.next = current.next if  current = = last  last item last = current.previous old previous last else not last old previous old next current.next.previous = current.previous return current return value  public void displayforward    system.out.print  list  first last   link current = first start at beginning while  current ! = null  until end of list   current.displaylink   display data current = current.next move to next link  system.out.println    public void displaybackward    system.out.print  list  last first   link current = last start at end while  current ! = null  until start of list   current.displaylink   display data current = current.previous move to previous link  doubly linked lists 229 listing 5.8 continued system.out.println     end class doublylinkedlist class doublylinkedapp  public static void main  string   args   make a new list doublylinkedlist thelist = new doublylinkedlist   thelist.insertfirst  22  insert at front thelist.insertfirst  44  thelist.insertfirst  66  thelist.insertlast  11  insert at rear thelist.insertlast  33  thelist.insertlast  55  thelist.displayforward   display list forward thelist.displaybackward   display list backward thelist.deletefirst   delete first item thelist.deletelast   delete last item thelist.deletekey  11  delete item with key 11 thelist.displayforward   display list forward thelist.insertafter  22  77  insert 77 after 22 thelist.insertafter  33  88  insert 88 after 33 thelist.displayforward   display list forward  end main    end class doublylinkedapp in main   we insert some items at the beginning of the list and at the end  display the items going both forward and backward  delete the first and last items and the item with key 11  display the list again  forward only   insert two items using the insertafter   method  and display the list again here s the output 230 chapter 5 linked lists listing 5.8 continued list  first last  66 44 22 11 33 55 list  last first  55 33 11 22 44 66 list  first last  44 22 33 list  first last  44 22 77 33 88 the deletion methods and the insertafter   method assume that the list isn t empty although for simplicity we don t show it in main    isempty   should be used to verify that there s something in the list before attempting such insertions and deletions doubly linked list as basis for deques a doubly linked list can be used as the basis for a deque  mentioned in the preceding chapter in a deque you can insert and delete at either end  and the doubly linked list provides this capability iterators we ve seen how the user of a list can find a link with a given key using a find   method the method starts at the beginning of the list and examines each link until it finds one matching the search key other operations we ve looked at  such as deleting a specified link or inserting before or after a specified link  also involve searching through the list to find the specified link however  these methods don t give the user any control over the traversal to the specified item suppose you wanted to traverse a list  performing some operation on certain links for example  imagine a personnel file stored as a linked list you might want to increase the wages of all employees who were being paid minimum wage  without affecting employees already above the minimum or suppose that in a list of mailorder customers  you decided to delete all customers who had not ordered anything in six months in an array  such operations are easy because you can use an array index to keep track of your position you can operate on one item  then increment the index to point to the next item  and see if that item is a suitable candidate for the operation however  in a linked list  the links don t have fixed index numbers how can we provide a list s user with something analogous to an array index you could repeatedly use find   to look for appropriate items in a list  but that approach requires many comparisons to find each link it s far more efficient to step from link to link  checking whether each one meets certain criteria and performing the appropriate operation if it does iterators 231 a reference in the list itself as users of a list class  what we need is access to a reference that can point to any arbitrary link this way  we can examine or modify the link we should be able to increment the reference so we can traverse along the list  looking at each link in turn  and we should be able to access the link pointed to by the reference assuming we create such a reference  where will it be installed one possibility is to use a field in the list itself  called current or something similar you could access a link using current and increment current to move to the next link one problem with this approach is that you might need more than one such reference  just as you often use several array indices at the same time how many would be appropriate there s no way to know how many the user might need thus  it seems easier to allow the user to create as many such references as necessary to make this possible in an object oriented language  it s natural to embed each reference in a class object this object can t be the same as the list class because there s only one list object  so it is normally implemented as a separate class an iterator class objects containing references to items in data structures  used to traverse these structures  are commonly called iterators  or sometimes  as in certain java classes  enumerators   here s a preliminary idea of how they look class listiterator    private link current   the current field contains a reference to the link the iterator currently points to  the term points as used here doesn t refer to pointers in c + + we re using it in its generic sense to mean refers to  to use such an iterator  the user might create a list and then create an iterator object associated with the list actually  as it turns out  letting the list create the iterator is easier  so it can pass the iterator certain information  such as a reference to its first field thus  we add a getiterator   method to the list class this method returns a suitable iterator object to the user here s some abbreviated code in main   that shows how the class user would invoke an iterator public static void main     linklist thelist = new linklist   make list listiterator iter1 = thelist.getiterator   make iter 232 chapter 5 linked lists link alink = iter1.getcurrent   access link at iterator iter1.nextlink   move iter to next link  after we ve made the iterator object  we can use it to access the link it points to or increment it so it points to the next link  as shown in the second two statements we call the iterator object iter1 to emphasize that you could make more iterators  iter2 and so on  the same way the iterator always points to some link in the list it s associated with the list  but it s not the same as the list or the same as a link figure 5.17 shows two iterators pointing to links in a list iterators 233 first next next next next null current list iterator 1 linked list current list iterator 2 figure 5.17 list iterators additional iterator features we ve seen several programs in which the use of a previous field made performing certain operations simpler  such as deleting a link from an arbitrary location such a field is also useful in an iterator also  it may be that the iterator will need to change the value of the list s first field for instance  if an item is inserted or deleted at the beginning of the list if the iterator is an object of a separate class  how can it access a private field  such as first  in the list one solution is for the list to pass a reference from itself to the iterator when it creates the iterator this reference is stored in a field in the iterator the list must then provide public methods that allow the iterator to change first these linklist methods are getfirst   and setfirst     the weakness of this approach is that these methods allow anyone to change first  which introduces an element of risk  here s a revised  although still incomplete  iterator class that incorporates these additional fields  along with reset   and nextlink   methods class listiterator    private link current reference to current link private link previous reference to previous link private linklist ourlist reference to parent list public void reset   set to start of list  current = ourlist.getfirst   current first previous = null previous null  public void nextlink   go to next link  previous = current set previous to this current = current.next set this to next    we might note  for you old time c + + programmers  that in c + + the connection between the iterator and the list is typically provided by making the iterator class a friend of the list class however  java has no friend classes  which are controversial in any case because they are a chink in the armor of data hiding iterator methods additional methods can make the iterator a flexible and powerful class all operations previously performed by the class that involve iterating through the list  such as insertafter    are more naturally performed by the iterator in our example the iterator includes the following methods reset   sets the iterator to the start of the list nextlink   moves the iterator to the next link getcurrent   returns the link at the iterator atend   returns true if the iterator is at the end of the list 234 chapter 5 linked lists insertafter   inserts a new link after the iterator insertbefore   inserts a new link before the iterator deletecurrent   deletes the link at the iterator the user can position the iterator using reset   and nextlink    check whether it s at the end of the list with atend    and perform the other operations shown deciding which tasks should be carried out by an iterator and which by the list itself is not always easy an insertbefore   method works best in the iterator  but an insertfirst   routine that always inserts at the beginning of the list might be more appropriate in the list class we ve kept a displaylist   routine in the list  but this operation could also be handled with getcurrent   and nextlink   calls to the iterator the interiterator.java program the interiterator.java program includes an interactive interface that permits the user to control the iterator directly after you ve started the program  you can perform the following actions by typing the appropriate letter s show the list contents r reset the iterator to the start of the list n go to the next link g get the contents of the current link b insert before the current link a insert a new link after the current link d delete the current link listing 5.9 shows the complete interiterator.java program listing 5.9 the interiterator.java program interiterator.java demonstrates iterators on a linked listlistiterator to run this program c java interiterapp import java.io * for i/o class link  public long ddata data item iterators 235 public link next next link in list public link  long dd  constructor  ddata = dd  public void displaylink   display ourself  system.out.print  ddata +    end class link class linklist  private link first ref to first item on list public linklist   constructor  first = null  no items on list yet public link getfirst   get value of first  return first  public void setfirst  link f  set first to new link  first = f  public boolean isempty   true if list is empty  return first = = null  public listiterator getiterator   return iterator  return new listiterator  this  initialized with  this list public void displaylist    link current = first start at beginning of list while  current ! = null  until end of list   current.displaylink   print data current = current.next move to next link  system.out.println    236 chapter 5 linked lists listing 5.9 continued  end class linklist class listiterator  private link current current link private link previous previous link private linklist ourlist our linked list public listiterator  linklist list  constructor  ourlist = list reset    public void reset   start at first  current = ourlist.getfirst   previous = null  public boolean atend   true if last link  return  current.next = = null   public void nextlink   go to next link  previous = current current = current.next  public link getcurrent   get current link  return current  public void insertafter  long dd  insert after  current link link newlink = new link  dd  if  ourlist.isempty    empty list  ourlist.setfirst  newlink  current = newlink iterators 237 listing 5.9 continued  else not empty  newlink.next = current.next current.next = newlink nextlink   point to new link   public void insertbefore  long dd  insert before  current link link newlink = new link  dd  if  previous = = null  beginning of list   or empty list  newlink.next = ourlist.getfirst   ourlist.setfirst  newlink  reset    else not beginning  newlink.next = previous.next previous.next = newlink current = newlink   public long deletecurrent   delete item at current  long value = current.ddata if  previous = = null  beginning of list  ourlist.setfirst  current.next  reset    else not beginning  previous.next = current.next if  atend    reset   else 238 chapter 5 linked lists listing 5.9 continued current = current.next  return value   end class listiterator class interiterapp  public static void main  string   args  throws ioexception  linklist thelist = new linklist   new list listiterator iter1 = thelist.getiterator   new iter long value iter1.insertafter  20  insert items iter1.insertafter  40  iter1.insertafter  80  iter1.insertbefore  60  while  true   system.out.print  enter first letter of show  reset   system.out.print  next  get  before  after  delete  system.out.flush   int choice = getchar   get user s option switch  choice   case s show list if  ! thelist.isempty    thelist.displaylist   else system.out.println  list is empty  break case r reset  to first  iter1.reset   break case n advance to next item if  ! thelist.isempty   && ! iter1.atend    iter1.nextlink   else iterators 239 listing 5.9 continued system.out.println  can t go to next link  break case g get current item if  ! thelist.isempty     value = iter1.getcurrent   .ddata system.out.println  returned + value   else system.out.println  list is empty  break case b insert before current system.out.print  enter value to insert  system.out.flush   value = getint   iter1.insertbefore  value  break case a insert after current system.out.print  enter value to insert  system.out.flush   value = getint   iter1.insertafter  value  break case d delete current item if  ! thelist.isempty     value = iter1.deletecurrent   system.out.println  deleted + value   else system.out.println  can t delete  break default system.out.println  invalid entry   end switch  end while  end main   public static string getstring   throws ioexception  inputstreamreader isr = new inputstreamreader  system.in  240 chapter 5 linked lists listing 5.9 continued bufferedreader br = new bufferedreader  isr  string s = br.readline   return s  public static char getchar   throws ioexception  string s = getstring   return s.charat  0   public static int getint   throws ioexception  string s = getstring   return integer.parseint  s    end class interiterapp the main   routine inserts four items into the list  using an iterator and its insertafter   method then it waits for the user to interact with it in the following sample interaction  the user displays the list  resets the iterator to the beginning  goes forward two links  gets the current link s key value  which is 60   inserts 100 before this  inserts 7 after the 100  and displays the list again enter first letter of show  reset  next  get  before  after  delete s 20 40 60 80 enter first letter of show  reset  next  get  before  after  delete r enter first letter of show  reset  next  get  before  after  delete n enter first letter of show  reset  next  get  before  after  delete n enter first letter of show  reset  next  get  before  after  delete g returned 60 enter first letter of show  reset  next  get  before  after  delete b enter value to insert 100 iterators 241 listing 5.9 continued enter first letter of show  reset  next  get  before  after  delete a enter value to insert 7 enter first letter of show  reset  next  get  before  after  delete s 20 40 100 7 60 80 experimenting with the interiterator.java program will give you a feeling for how the iterator moves along the links and how it can insert and delete links anywhere in the list where does the iterator point one of the design issues in an iterator class is deciding where the iterator should point following various operations when you delete an item with deletecurrent    should the iterator end up pointing to the next item  to the previous item  or back at the beginning of the list keeping the iterator in the vicinity of the deleted item is convenient because the chances are the class user will be carrying out other operations there however  you can t move it to the previous item because there s no way to reset the list s previous field to the previous item  you would need a doubly linked list for that task  our solution is to move the iterator to the link following the deleted link if we ve just deleted the item at the end of the list  the iterator is set to the beginning of the list following calls to insertbefore   and insertafter    we return with current pointing to the newly inserted item the atend   method there s another question about the atend   method it could return true when the iterator points to the last valid link in the list  or it could return true when the iterator points past the last link  and is thus not pointing to a valid link   with the first approach  a loop condition used to iterate through the list becomes awkward because you need to perform an operation on the last link before checking whether it is the last link  and terminating the loop if it is   however  the second approach doesn t allow you to find out you re at the end of the list until it s too late to do anything with the last link  you couldn t look for the last link and then delete it  for example  this is because when atend   became true  the iterator would no longer point to the last link  or indeed any valid link   and you can t back up the iterator in a singly linked list we take the first approach this way  the iterator always points to a valid link  although you must be careful when writing a loop that iterates through the list  as we ll see next 242 chapter 5 linked lists iterative operations as we noted  an iterator allows you to traverse the list  performing operations on certain data items here s a code fragment that displays the list contents  using an iterator instead of the list s displaylist   method iter1.reset   start at first long value = iter1.getcurrent   .ddata display link system.out.println  value +  while  ! iter1.atend    until end   iter1.nextlink   go to next link  long value = iter1.getcurrent   .ddata display it system.out.println  value +   although we don t do so here  you should check with isempty   to be sure the list is not empty before calling getcurrent    the following code shows how you could delete all items with keys that are multiples of 3 we show only the revised main   routine everything else is the same as in interiterator.java  listing 5.9   class interiterapp  public static void main  string   args  throws ioexception  linklist thelist = new linklist   new list listiterator iter1 = thelist.getiterator   new iter iter1.insertafter  21  insert links iter1.insertafter  40  iter1.insertafter  30  iter1.insertafter  7  iter1.insertafter  45  thelist.displaylist   display list iter1.reset   start at first link link alink = iter1.getcurrent   get it if  alink.ddata % 3 = = 0  if divisible by 3  iter1.deletecurrent   delete it while  ! iter1.atend    until end of list   iterators 243 iter1.nextlink   go to next link alink = iter1.getcurrent   get link if  alink.ddata % 3 = = 0  if divisible by 3  iter1.deletecurrent   delete it  thelist.displaylist   display list  end main    end class interiterapp we insert five links and display the list then we iterate through the list  deleting those links with keys divisible by 3  and display the list again here s the output 21 40 30 7 45 40 7 again  although we don t show it here  it s important to check whether the list is empty before calling deletecurrent    