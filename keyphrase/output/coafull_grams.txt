brindha computer architecture
computer architecture prof
architecture prof anshul
prof anshul kumar
anshul kumar department
department of computer
science and engineering
engineering iit delhi
iit delhi lecture
control for multi
multi cycle design
processor where execution
instruction is divided
divided into multiple
multiple clock cycles
path is designed
designed and today
sequence of lectures
designing of processor
processor we started
instruction was done
single clock cycle
cycle we notice
notice the problem
problem with performance
putting these sequences
sequences of actions
build the flow
flow of control
control for carrying
out these instructions
identify what control
signals are required
required to control
control this data
steps for doing
group the control
define some meaningful
operations called micro
set of micro
establishing a relationship
relationship between control
states um transit
complete the design
design of control
data path last
memory register file
file and alu
out from memory
stored in instruction
register when data
data is read
stored in data
operand from register
file are brought
out into registers
results of alu
register called res
short for result
change their states
multiplexer as usual
control for alu
alu register file
file and memory
components like registers
instructions are divided
activity is done
read one word
word from memory
memory into instruction
register that form
form the instruction
address of memory
operations are done
concurrently within first
read the operand
two are brought
addresses of register
sixteen to twenty
first one corresponds
meant by putting
clock cycle number
operation being performed
transferring this result
eleven to fifteen
fifteen which corresponds
made a careful
done in sequence
first cycle involves
involves um access
access to memory
memory to fetch
fetch the instruction
instruction and updation
updation of program
involves um bringing
bringing the registers
access two registers
participate in address
carry the value
fields of instruction
instruction register file
file is accessed
accessed and registers
registers are values
values are brought
cycle we calculate
calculate the address
adding offset coming
coming from bit
fifteen of instruction
instruction with sign
register called result
contents of res
written into memory
write is performed
require four cycles
load word instruction
instruction first cycle
involves um reading
reading one register
register from register
read from memory
stored in register
fourth cycle memory
cycle memory access
access is performed
performed the data
address is carried
carried in res
read is brought
value into register
file the address
cycles which complete
complete load word
beq first cycle
lot of work
address in case
alu is free
alu for comparison
free we calculate
calculate this address
don t transfer
res the condition
checking the condition
alu will compare
out from register
address is transferred
req this requires
compose this address
instruction by taking
two bit shift
shift is concatenated
accessing the instruction
memory access required
required no alu
alu operation required
occupying two cycles
bits are picked
cycle and put
takes one cycle
cycle to fetch
occupying additional cycle
single cycle approach
roughly taking equivalent
approach the data
directly we picked
bits and formed
formed the address
required is max
decided one clock
requiring two cycles
basically first clock
first clock period
instruction into cycles
cycles the division
division of activity
form overall flow
instructions or groups
put their actions
pieces of text
matter of detail
omitted some details
register file performing
arithmetic or logical
logical operations storing
storing in register
file um storing
storing in memory
reading from memory
taking different cycles
notice some commonality
things start differing
boxes will correspond
sort of state
state transition diagram
describe the control
action is required
out same activity
contemplating a bifurcation
onwards after first
instruction or instruction
fetched the instruction
instruction and brought
cycle on onwards
opcode second cycle
decoding of opcode
opcode or understanding
understanding which instruction
activity the circuit
identify particular instruction
typically be allowed
allowed a full
cycle fully occupied
bifurcation or split
split must occur
step is completed
required to make
make it common
read two values
values from register
values two values
reading two values
consume some energy
energy in doing
agree to fetch
thing you notice
holding any value
jump um requires
instruction a jump
common decoding cycle
operand fetch cycle
instruction whose frequency
frequency of occurrence
two common cycles
end first cycle
cycle our operands
address is ready
ready in res
cycles are required
two for store
small finite state
finite state machine
instruction is follow
long as power
require four clock
four clock cycles
range of number
number of clock
action we perform
small improvement possibility
word and store
store are concerned
bifurcate into load
load and store
number of control
total of ten
made very clear
component which require
require a control
write is rew
signals control signals
cycle the cha
state is changed
decide the values
requires some controls
controls so control
instruction or data
sources this multiplexer
written into register
two r memory
memory to register
multiplexer is controlled
controlled by signal
earlier two registers
hand two multiplexers
signal is labeled
noiselor pc source
source the memory
usual control signals
single cycle data
cycle data path
signals as compared
build the table
group the related
related control signals
call as micro
grouping the signals
things group wise
simplify the matter
group of signals
build a table
list micro operations
two signals pwu
pwu and pwc
state will generate
generate a signal
calling as pwc
four i make
make pc pwu
output of alu
alu directly output
alu through res
back and check
don t bring
register into picture
single cycle design
control a multiplexer
coming from controller
controlled a multiplexer
making a choice
four plus offset
things are handled
cycle the choice
address is calculated
derived from pwu
transfer an address
activate this signal
signal the source
two three etcetera
signal takes multiple
takes multiple value
case the source
doesn t matter
controller will produce
clear any question
formed for jump
control the data
make this happen
make the unconditional
unconditional write signal
don t care
values here don
don t matter
matter the result
sort of overriding
overriding um signal
pwc is don
select the correct
operation um notice
multiplexer is selecting
selecting the sources
input of multiplexer
multiplexer one input
signals are taking
transfer is taking
changing the value
give some names
make things convenient
convenient in subsequent
names for convenience
operations which revolve
memory the relevant
write and read
read control signals
data this signal
source of address
two signals decide
register this controls
operation is fetching
fetching the instruction
read is written
data from memory
writing into memory
kind of redundancy
make such observation
observation and simplify
simplify the controller
finally the default
read both signals
register load signals
load signals low
matter some convenient
memory read memory
read memory write
set of values
group is register
register file group
talking of writing
writing a signal
signal rw register
register file write
file write rdst
written is coming
coming from memory
register so reading
two r don
give a write
doesn t require
require similarly reading
writing into register
make the write
address is coming
values being written
make any change
two signals rdst
rdst and m2r
m2r are complementary
reduce the signals
rs2a rt2b res2rd
rt2b res2rd mem2rt
finally the alu
signals are opc
two bit value
part of circuitry
multiplexer control signals
signals a source
signal which controls
writing into result
earlier is appearing
ensure that addition
addition is done
offset for load
store and offset
offset for branch
two for load
load store offset
source are concerned
writing into res
opc and coding
simply perform addition
addition without doing
load store instruction
wha our logic
controller would ensure
ensure that alu
perform the addition
matter what alu
ensure that rew
relationship between micro
assert various control
signals what values
increment arithmetic memory
arithmetic memory address
redraw the diagram
micro operation symbol
described in previous
previous few slides
rs2a and rt2b
rt2b and paddr
table will define
state what micro
table next table
states and signal
listing signal values
listing the micro
groups i identified
identified pc group
group memory group
group and alu
shows the pair
requires to control
group the operation
operation is fetch
fetching these operands
operands and calculating
calculating um branch
first um sep
first distinct state
perform the arithmetic
value gets written
state for load
store here memory
address gets calculated
completes the store
performs memory read
memory read operation
transfer of data
completes the branch
branch operation branch
operation branch micro
branch micro operation
micro operation shows
requires a comparison
change the state
completes the jump
symbol um replace
bit vector defines
defines the relevant
relevant control signals
states in binary
bits to encode
encode this state
state i form
form a truth
input the code
control state transitions
transitions take place
four for load
conditions wont occur
instruction we start
kinds of truth
state these form
form one input
bits which encode
plas to implement
holding the control
state four bit
four bit register
bit register hold
state will form
form the controller
draw that picture
instruction get divided
divided into sequences
sequences of micro
control operations control
operations control signals
operation and control
identified control state
processor design microprogrammed
design microprogrammed control
lecture i started
design of controller
multi multi cycle
multi cycle datapath
complete that design
style of design
design called microprogrammed
concentrate on microprogrammed
finish this control
control part design
two different alternatives
implementation of controller
parts one part
produces the control
signals other part
talk about microprogrammed
microprogrammed control design
multi cycle approach
controlling various components
flow chart indicating
indicating how control
control control state
cycle to cycle
identified um groups
groups of control
operation were identified
pattern of control
control signals required
make them effective
names were assigned
tables one table
table um describes
describes the control
indicating what micro
supposed to perform
replace each micro
truth table description
encode these control
forms the truth
part showing black
input and part
part showing green
numbers upto twenty
twenty so twenty
earlier for single
four input coming
signals um group
altogether twenty signal
grouped as usual
usual r class
row and column
capturing this flowchart
flowchart or state
control state codes
states are replaced
codes and opcodes
opcodes also put
describe the truth
table is defining
defining four bits
described by implement
lot of sparsity
two d table
dimensional um table
combinations are listed
state and instruction
two raise power
raise power ten
power ten entries
bits of input
don t cares
combinations are captured
replace the state
state numbers state
numbers state labels
form the truth
first two column
two column represent
represent the input
ten bit input
four bit output
bits of control
bits of opcode
opcode to produce
produce um nex
nex next state
pla s implementing
two specific tables
register which holds
holds the state
clock this value
value will change
current control state
pla is generating
generating the control
opcode and deciding
single combination circuit
circuit with total
inputs and twenty
twenty four outputs
two smaller pla
pla s put
alternative to pla
general purpose component
fully expanded truthtable
rows and defines
defines m outputs
essentially by putting
putting this pattern
pattern of outputs
talking about read
read only memory
memory the kind
kind of memory
modifying the contents
contents you give
give an address
address as input
apply as address
read out contents
output um combinational
circuit that definition
part um corresponds
terms of size
raise to power
power n words
number of bits
input m output
logic and false
implement and gates
size what governs
governs the size
size is governed
number of column
number of vertical
run each vertical
line here corresponds
corresponds to suppose
fully expanded form
lots of don
accommodates um rows
width in proportional
makes a pla
compact as compared
table have lot
lot of sparkcity
lot of don
form of pla
illustrate this point
input the output
terms are grouped
irrespective the value
value second input
fully expanded truth
expanded truth table
inputs that means
means two raised
two raised power
ten or thousand
four um words
memory each word
bits and total
number of words
ten eleven twelve
thirteen fourteen terms
correspond to product
term in case
sixty four term
mention microprogrammed control
program flow chart
computer which executes
executes a simple
programs that program
generates control signals
deal with manipulating
steps each step
step involves generating
generating some control
reading out words
talking of memory
mentioned some disadvantage
memory based design
notice so imagine
imagine a memory
applied as control
tho those signals
generated by circuit
word um generates
arrangement to make
address is presented
word is read
generate this address
calling as micro
sequencer so micro
sequencer is ensuring
ensuring that right
address is put
stepping through memory
register it steps
micro programmed memory
memory to ensure
signals are generated
correctly each micro
micro programmed counter
simple incrementer adder
branching another point
follow in simple
call it dispatch
micro program terminology
multi way branch
call that dispatch
call that reset
possibilities are sequence
dispatch one dispatch
two and reset
four four possibilities
complex um design
two bit field
address is concerned
two bits coming
call as sequence
select either current
opcode and generating
generating the correct
tables um depending
four possible addresses
addresses here depending
depending upon opcode
small roms small
roms small plas
number of ways
program will control
control this multiplexer
low level program
level program lower
single language program
simple primitive operations
done each line
represents one micro
micro program memory
incidentally micro program
rest are reset
micro program written
assembler can translate
structure your micro
horizontal micro programming
path can support
provision of doing
doing many micro
degree of concurrency
concurrency um vertical
fetching an instruction
two different instructions
conserve the space
altogether the space
space we require
word having twenty
twenty two bits
past many processor
complex and micro
micro program run
run two thousands
thousands of words
concurrency of micro
pattern of bits
number of patterns
number of pattern
pattern in general
raised the power
power of number
low memory requirement
programming the idea
don t lose
micro programmed approach
programmed approach versus
versus um non
non micro program
state machine based
machine based approach
pros and cons
easy to write
definition of control
chart like form
work with design
architecture and design
design of micro
terms of performance
separate memory chip
make a change
add few instruction
memory and rest
rest could remain
times the families
families of processor
processor were designed
micro program implementation
attempts like emulation
architecture in mind
emulate um emulation
simulation in microprogramming
simulate the effect
set of instructions
internal registers temporary
registers temporary registers
working at microprogrammed
level could make
makes it slower
longer um popular
lot of performance
tools where tdf
tdf final state
final state machine
state machine design
done by hand
advantage of micro
tools can design
design very efficient
machine or hardwired
hardwired controllers starting
kind of description
levels various stages
process of design
initial representation level
draw a finite
state machine diagram
program micro program
program at sequencing
sequencing control level
function um coming
pla or memory
micro program counter
counter plus dispatch
write is logic
write as truth
finally at implementation
pla or read
technically all combinations
completed the design
require two pla
care of generating
path and taking
thirdly we looked
looked at micro
approach to control
main um things
drive this memory
microsequencer which determines
pipelined processor design
datapath and control
lecture we discussed
type of design
design called pipelined
frequency of clock
clock the idea
attempt to initiate
initiate one instruction
number of instructions
stages of execution
ideally each stage
ways of handling
handling those situations
hazards we looked
types of hazards
hazards structural hazards
structural hazards data
hazards data hazards
hazards and control
eliminate structural hazards
hazards but data
reduce their effect
last time complete
ignore the hazards
condition in ideal
condition how pipeline
controlled and instructions
instruction per clock
complete the datapath
shifters um bit
introduce the controller
simple pipeline design
pipeline design behaves
behaves in context
possibly in subsequent
augment our design
design to handle
handle these hazards
single cycle datapath
basis for designing
designing um pipelined
omitted um instruction
reduce the size
easier for discussions
components like multiplexers
multiplexers and sign
extenders and shifters
number of components
diagram is smaller
analyze and discuss
basically to introduce
stage is considered
considered um instruction
instruction fetch stage
stage which involves
introduced a register
decoded control signals
generated and operands
fetched from register
register third stage
calculation for branch
final the fourth
stage is memory
read or write
write of data
stage is writing
skip some stages
skip some stage
forward going paths
thirty two bits
bits of instruction
instruction plus thirty
sixty four bit
register the register
twenty eight bit
cutting three paths
ninety six bits
means the information
cycle of delay
backward going paths
back to register
passing through register
initiate next instruction
instruction unless first
turning this back
loop can turn
values every cycle
instruction gets pumped
removed for convenience
convenience of discussion
put this back
peculiar thing happening
four value generate
generate for instruction
analyze but lets
two different sources
adding data coming
coming from register
instruction the offset
offset a multiplexer
register file output
output of memory
memory or output
alu so notice
instruction where memory
experiencing a delay
doing anything idling
homogenous and uniform
right back operation
back is happening
amount of delay
carry the data
data and address
experience same delay
change we require
feeding the address
address all move
instruction and address
lot of options
consequences of multiplexing
consuming five bits
don t multiplex
two five bit
length will increase
imagine the consequence
consequence of positioning
positioning the sign
sign extension unit
input of sign
extension is sixteen
thirty two lines
lines to pass
consuming sixteen bits
position best position
address is made
hand in hand
data and reach
reach the register
introduce um control
generate control signals
components which require
register files multiplexers
thi this multiplexer
passing two things
sixty four bits
bring this multiplexer
discussing this point
lets also understand
understand other implications
implications of making
repositioning of components
components of multiplexer
register after register
stage the paths
form the part
path which starts
file and ends
delay that delay
calculate the maximum
maximum path delay
critical path delays
data memory delay
two choices achieves
delay okay suppose
delay of data
larger than delay
typically then keeping
keeping this multiplexer
delay and make
make things worse
slack some room
side to accommodate
point of view
cost in terms
terms of register
register length register
length register size
style of control
follow the single
single cycle type
type of control
design or multi-cycle
design in single
cycle the key
purely a combinational
generates the sig
generates the signals
decide the control
signals gets determined
sense the influence
influence of opcode
making the control
reduce the number
signals to generate
first two states
branching off depending
suppose we don
don t branch
states four states
determine what control
recall your theory
theory of finite
finite state machines
mealy machine type
type of approach
moore machine type
suit the pipeline
controller be combinational
remember the states
purely combinational circuit
cycles and control
maintain several control
decide control signals
fortunately what turns
derive the controller
lets um reconstruct
reconstruct the controller
lets um superimpose
control signal goint
controls the write
write operation register
operation register file
signal for alu
control for data
data memory read
memory read control
gate which generates
generates um signal
care of branch
result of comparison
controls this multiplexer
mixing of datapath
two different instruction
coming from instruction
generated is found
drive the controller
ignoring the identity
solved the problem
problem of synchronizing
address and data
data while writing
writing to register
done for control
generate the control
cur current stage
stage you delay
applicable two stages
extend these registers
registers to accommodate
accommodate the control
extended these walls
walls to separate
separate um control
basically the signals
directly the signal
basically you put
units of delay
register they pass
applicable here signals
reach the multiplexer
simply by inserting
inserting register extend
portions of registers
signals are passing
carrying the control
bits here eleven
bit here twelve
twelve bit register
required for instruction
circuit is identical
focus your tension
unit do multiplexing
signal which enables
correct this signal
irrelevant for write
output of multiplexing
out from controller
registers and bringing
back and applying
applying into register
addresses and control
complete design datapath
out jump instruction
remaining eight instructions
position this multiplexer
delaying the data
giving write signal
change this register
move this multiplexer
register other consequence
passed and made
register file operation
generated this address
address you store
store um suppose
suppose next instruction
two three addresses
cycle we store
cycle we move
first in first
first out kind
out kind arrangement
done this design
recall that last
datapath for data
hazard and control
introduce appropriate delays
suffer the delays
delays are reduced
two consecutive instructions
means the value
two gap depending
opportunities for data
putting a result
required by add
delay the register
register read stage
matches with register
write or write
write back stage
sharing a cycle
cycle between read
read and write
write of register
register file half
half the cycle
cycle for writing
cycle for reading
two ideal cycles
made any arrangement
arrangement to check
check this situation
situation and introduce
read old results
valid and computation
problem which exist
instructions following close
pass on part
compare an instruction
stage and instruction
stage okay lets
write into register
instruction to proceed
read um address
directly because instruction
instruction is stored
carried this information
address for instruction
enable those paths
halt these instruction
control um transfer
transfer of information
register it means
don t clock
doesn t pass
disable the clock
doesn t change
value means inactive
giving the basic
happening when control
control hazards occur
taking some decision
tendency the pipeline
pipeline to start
flush these instructions
delayed is starting
easy you don
coming out indicating
ready to flush
flush the instruction
branch instruction freeze
instruction freeze don
point you decide
happen and start
opcode what kind
kind of branch
branch it means
loops are iterated
iterated several times
arrangement also means
encountered this instruction
prediction that last
case um lets
actions we require
require in light
out the design
hazard the first
instructions with dependence
introduce suitable number
two is required
required sometimes delay
pipeline where things
things are moving
smoothly you insert
instructions more complex
data forwarding path
enable the paths
introduction of bubbles
forwarding will eliminate
eliminate the delay
cycles of delay
instructions are flowing
held up including
fetching next instruction
moving of forward
control hazards require
detect identify branch
identify branch instructions
flush wrong instruction
blindly inline instructions
fairly straight forward
complex dynamic prediction
care by introducing
introducing more hardware
hazards are coming
program is interacting
software the answer
software um assembler
assembler or compiler
whichever is generating
generating the code
analysis and rearrange
hazard is minimized
hazard is coming
coming when dependent
instructions are close
instruction without changing
changing the meaning
make the program
depend upon instruction
instructions are independent
separate out instruction
don t find
insert no ops
sequence is organized
worry about data
hazards are data
hazards are removed
removed by construction
handle the branch
branch instruction similar
instruction similar spirit
done both ways
instruction and imagine
imagine the branch
find something common
instruction and place
decide two cycles
slots two delay
two delay slots
program can done
programmer if program
program is written
simplifies the task
task of hardware
case of data
data hazard data
hazard data hazards
branch the hardware
branches are effective
completed the datapath
cycle datapath design
design with inter
inter stage registers
number of register
thing was controller
controller also turn
cycle datapath controller
controller but control
involves many thing
thing get fed
back the data
control and address
carefully so handling
handling of hazards
hazards requires detection
requires detection stalling
detection stalling flushing
support from software
software which simplify
simplify the task
minimize their effect
handling data hazards
design may face
hazards we started
care of structural
hazards that means
means enough resources
resources are introduced
problem of data
handle data hazards
introduce no ops
ops or bubbles
functionality remains correcst
techniques of data
forwarding and improve
improve the situation
question of stalling
stalling th pipeline
pipeline in detail
types of instruction
number of stall
stall cycles required
introduce the stall
additional control circuitry
circuitry is required
define the conditions
detected in order
exercise this control
sort of bypass
bypass the register
require the additional
introduce additional paths
spite of introducing
introducing data forwarding
cases how stalling
stalling is done
datapath and introduce
introduce inter stage
cycle um control
make the control
control signal pass
find a pair
pair of instructions
dependent so suppose
calling if instruction
load instruction storing
immediately an add
cycle goes waste
instruction and register
first instruction happen
sense when reading
reading and writing
writing of register
cycle you write
cycle you read
case the value
lets say middle
cycle um instruction
read correct values
instruction would remain
values and proceed
implement um delaying
delaying of instructions
instruction the pipeline
pipeline you notice
proceed further forward
discuss that pipeline
two different views
instruction by instruction
horizontal axis indicating
instruction you put
show which stage
show all stages
shot snap shots
throw more light
two the previous
reached this point
two has reached
ins these stages
cycles of instruction
instructions will remain
means no operation
shown alu shaded
shaded which means
occupying a cycle
stopping that moves
two are stuck
move to alu
pipeline two bubbles
lets tell fluid
fluid was flowing
indicating no activity
two no operations
correct time instant
instruction wise background
two inactive stage
two two nops
two nops introduced
operations get introduced
introduced from alu
alu stage onwards
fetched from memory
forward so nop
out a condition
condition is true
cycle one nop
nop gets introduced
nops gets introduced
re-rooted some wires
sake of clarity
introduce no operations
prevent any instruction
instruction from moving
clock this register
instruction was fetched
explicitly shown control
shown control signals
care of stalling
define control signals
order to introduce
introduce a null
signals all null
null control signal
registers see remember
applicable for subsequent
defined our control
means inactive situation
put a multiplexer
controls are passing
multiplexer other input
select this multiplexer
signals get passed
values get passed
introducing a bubble
calling as bubble
operation nop instruction
combination of control
control will achieve
achieve the desired
detect that condition
detect the dependency
hazard so first
stating this condition
condition in words
instruction the alu
hazard between instruction
stage and alu
instruction rf stage
stage to held
held back instruction
back instruction alu
instruction alu stage
stage will proceed
condition that means
instruction to move
forward and write
con conditional persists
suppose we notice
notice the hazard
two cycles introduced
depending will pass
check this condition
introducing some notation
inter stage register
stage okay instruction
active that means
condition is satisfied
comparing the register
comparing rs address
means an instruction
register which matches
specification of instruction
destination is matching
intends to write
source and destination
put the condition
reads the register
instructions like jump
read the registers
back a jump
refined little bit
reads the registers
omitting those details
condition another point
two alternative destination
alternative destination addresses
addresses are multiplexed
influence in terms
terms of number
bates and clock
multiplex is showing
signal pc write
signal and bubble
considered as part
data forwarding paths
introducing two cycles
two consecutive instruction
two dependent instructions
instructions are separated
case this match
match would occur
instruction has reached
reached dm stage
find any conflict
data forwarding techniques
recall that idea
result is generated
generated we pass
repeat those slides
result of first
input of alu
means two paths
two paths leading
instruction like add
case the data
state to alu
instruction um requires
requires two registers
register the value
required in fourth
out of alu
alu is required
don t pass
directly from alu
dma and fourth
store so output
register to alu
register and send
datapath okay augmented
paths and shown
identify these paths
inputs of alu
two gets selected
selected and coming
bringing a copy
introduced an multiplexer
require three control
work out conditions
give proper value
two bit signal
paths are organized
conditions to energize
energize these paths
two the paths
stages the control
control we require
forward a equal
don t hold
hold by default
holds the value
similar but first
instruction ex stage
stage um intends
intending to write
taking special care
made this check
check in earlier
condition without forwarding
digit one instruction
instruction is writing
right or wrong
wrong another instruction
write it intends
non zero address
address is matching
back so instruction
instruction here intends
intends to read
stage the instruction
moved further intends
write into non
non zero register
matches the destination
matches the source
register where instruction
forward the data
supposed to read
register the instruction
introduced this additional
additional um check
matching that means
means the instruction
condition for defining
controlling the multiplexer
relevant register field
place rs rest
condition that instruction
destination there matches
require rt register
checked by control
energize or enable
enable the right
right forwarding paths
paths having done
spite of forwarding
result is ready
ready after fourth
introduce um stall
condition when data
forwarding is happening
described the condition
specifically a load
check is happening
check when instruction
stage that load
read is load
signal is active
exercise our controls
controls for holding
holding the instruction
cycle and introducing
introducing a nop
instruction we don
two different ways
notice that instructions
times um times
times time slabs
nops are inserted
inserted the control
signal were defined
conditions were defined
defined we check
check the hazard
hazard and activate
activate those control
improve the performance
performance we talked
types of data
situations where stalls
stalls are required
conditions for introducing
basically the conditions
develop for stall
condition we developed
set of control
select these multiplexers
special cases introduce
introduce the stalls
handling control hazards
discussing pipelined design
design for mips
processor um last
out the logic
detect when hazards
hazards are occurring
out the dependency
introduce appropriate control
signals for today
modify to handle
handle the control
performance in view
couple of techniques
possibility of eliminating
execution of branches
prediction of branch
instruction level parallel
level parallel architecture
architecture and tha
view of branch
hazards and data
effect of data
execution of instructions
introduce um null
instruction or nop
instructions or bubbles
sequence of instructions
stage wise view
showing various stages
notice that nops
two nop instruction
back to alu
possibly after multiplexer
back to memory
derive control signals
signals which guide
guide these multiplexers
enable this paths
imagine a branch
sequentially or branch
continues getting instructions
instructions in sequence
sequence is broken
fetch the target
entered the pipeline
generate a control
datapath and controller
designed the branch
condition regarding tested
tested in alu
tested by alu
generated for feeding
end of fourth
fetch cycle shifts
trapping this output
making this pass
register um consequences
determines the clock
undergo a change
gate this multiplexer
gate and multiplexer
borne in mind
flush the instructions
loading the target
out the instructions
make the contents
introducing um nop
hazards so similar
action somewhat similar
handle the branches
instruction in general
completed somewhere target
machine is completed
inline that means
branch is taking
activities are happening
happening would determine
mind these delays
happening we started
basically the computation
address and condition
reduce the delay
mind another factor
architectures where condition
evaluation and branching
branching are split
set some flags
flags the branch
test the flag
carry out branching
branching so condition
fact the real
real evaluation takes
evaluation takes place
immediately preceding instruction
instruction the condition
speed up branch
move these events
events as early
increase the gap
making and actual
thing is branch
saving a lot
correctly you lose
improved the situation
doing dynamic predication
remember the target
decision but calculation
illustration of branch
testing some condition
condition is false
instruction or predicated
attach a condition
two you attached
attached the condition
true the instruction
instruction gets done
specifies which condition
tested so condition
condition being tested
result of previous
flag is set
branch to current
two that means
means you skip
set nz means
removing this branch
branch instruction explicit
instruction explicit branch
explicit branch instruction
instruction and putting
putting that condition
testing is part
preparation for doing
doing the addition
addition and depending
store the result
speed up execution
execution of branch
speed up target
target is calculation
calculation and condition
calculating the target
generate target address
decode the instruction
target address calculation
calculate target address
address in anticipation
fetching the registers
complex if virtual
memory was involved
calculation also involves
involves um page
doing that translation
translation from virtual
address to real
simply um address
simply involve making
making um doing
doing an addition
starting in anticipation
sequence of cycles
showing a part
design okay last
introduced a comparator
cycle because alu
alu was free
utilize the alu
moving that adder
moving and introducing
introducing a comparator
terms of clock
coming in series
multiplexer these dont
main um effect
delay of register
remember that testing
testing for equality
simpler as compared
compared to testing
greater than right
bit by bit
afford um equality
equality or inequality
greater than comparison
done within alu
alu the fast
beq bna kind
doing this right
putting a simpler
comparison here comparator
design with slight
losing one cycle
basically when branch
branch actually occurs
gap between condition
condition code evaluation
instructions to evaluate
setting the condition
data hazard situation
instruction is dependent
instruction is setting
code other instruction
instruction is testing
waiting is cut
instruction can calculate
calculate its target
branch that means
assume that branch
true or false
cycles so lets
instruction that means
done whether condition
role of compiler
find um suitable
suitable independent instruction
decision about branching
make branch effective
effective one cycle
technique of branch
branches that means
don t worry
operation that means
means um don
basic idea question
ways of doing
find the branch
true and branch
criteria is fixed
depend upon situation
predict um inline
predict the target
kind of branches
care of situations
decide the dynamic
dynamic branch prediction
occurs several times
inside a loop
condition was true
minded um approach
last several occurrences
occurrences and based
make the design
giving the programmer
bypassing the delay
branch with nullification
predicting okay depending
simple branch prediction
strict forward logic
instructions which loops
suppose your strategy
enter the loop
bra some loop
find that last
condition becomes false
make a mistake
entering the loop
exiting the loop
static branch policy
predict that loop
make one mistake
mistake per loop
dynamic prediction strategy
strategy does worse
worse than static
static prediction strategy
make branch dynamic
branch dynamic branch
modify our dynamic
remembering what happened
showing a scheme
remembering one bit
effectively two bits
bits of information
summary of last
last several outcomes
don t change
change your decision
predicting that branch
point um branch
arcs are indicating
transiting the state
outcome and based
predict that branch
taking the branch
continue to predict
continue in state
avoid making double
making double mistakes
keeping the history
done in anticipation
type of instruction
address is obtained
obtained by adding
adding a constant
things are changing
keeping in mind
scheme will work
associative or contrantive
contrantive decibel memory
current um instruction
field carries instruction
carries instruction address
field carry prediction
carry prediction statistics
match that address
occurs you pick
store target address
store target instruction
instruction branch instruction
branch instruction carries
doing in anticipation
probability of changing
changing of target
ninety five percent
predicted with hundred
hundred percent accuracy
basis of outcome
history of branches
encode um outcome
zeros which represent
last few branches
accuracy the outcome
improve your prediction
hardware to carry
out these things
hardware to undo
undo the effect
effect of wrong
due to data
hazards or branch
putting the instruction
analyze the instruction
instruction and push
push those striking
striking the pipeline
causing any stalls
right um wha
doing data forwarding
check the dependency
dependency between instruction
built in hardware
instruction is producing
pushed in pipeline
done by compiler
complete um picture
change the order
order of instruction
out of order
nicely support speculative
support speculative execution
execution and dynamic
prediction the kind
kind of stuff
forms the basis
super scalar architecture
decode and execute
execute several instructions
necessarily a dynamic
window of instructions
stream of instructions
idea of dynamic
extended to multiple
instruction level parallelism
talking of parallel
parallelism in terms
terms of multiple
multiple processors doing
processors doing multiple
doing multiple instructions
processor is capable
capable of fetching
fetching and decoding
decoding and executing
executing several instructions
instructions and finds
out which instruction
hardware which executes
executes these instruction
instruction in parallel
results are obtained
coming to ilp
ilp or instruction
compiler to identify
identify what instructions
don t leave
leave this query
carrying multiple operations
long instruction word
word um whe
coded multiple instructions
multiple instructions put
picture very large
large instruction word
meaning of vliw
architecture with dynamic
compiler driven vliw
driven vliw approach
multiple functional units
units so multiple
handle multiple instructions
access the register
file so register
support multiple read
multiple read write
read write ports
parallel between vliw
vliw and super
scalar the difference
case of vliw
long instructions carrying
instructions carrying multiple
hand um super
scalar um architecture
decode and issue
fetched simultaneously pick
showing that multiple
terms of stream
vliw each instruction
two alternative architecture
alternative architecture versus
architecture versus timing
top picture shows
four stage pipeline
stage pipeline lets
stages are instruction
instruction fetch decode
fetch decode execute
execute and write
overlapping this manner
instructions in flight
super scalar suppose
degree of parallelism
fetching three instructions
decoding three instructions
executing three instructions
instructions doing write
doing write back
instructions um biw
instruction being fetched
fetched single instruction
instruction being decoded
out multiple operation
place three architecture
super scalar processors
ibm s power
high performance desktop
performance desktop computing
desktop computing machines
scalar processors vliw
specialized in varied
applications so question
scalar is popular
popular for general
general purpose computing
binary code compatibility
eighty six processor
pentium a super
super scalar version
thing the code
code compatibility exists
made to work
machine and run
series as long
long as instruction
user is concerned
machine doing executing
speed through vliw
regenerate the code
detect um parallelism
parallelism at instruction
instruction level pack
pack the instruction
run the code
source level compatibility
object level compatibility
vliw um processor
require very specialize
impossible to code
code normal scalar
normal scalar machine
machine by hand
code super scalar
require anything extra
designed for super
super scalar processor
account some features
features and produce
produce better code
machine is super
busy the compiler
compiler can produce
specially for super
density in vliw
find many instructions
cost super scalars
achieve a higher
degree of performance
performance in vlwi
vlwi technique provided
words about exception
discussed exceptional handling
handling in case
case of multi
case of pipeline
design in fact
fact in pipeline
pipeline design exception
design exception handling
instructions in processing
instruction is showing
overflow another instruction
showing um page
fault or illegal
types of exceptions
show an exception
results in overflow
overflow okay overflow
done the arithmetic
supposed to occur
things very difficult
interrupt or imprecise
case of precise
precise interrupt means
interrupts or exception
instructions are occurring
insist on precise
interrupts to happen
saving of status
naturally very complex
handle the exception
back in resume
resume the instruction
instructions were executed
out and restart
lot of possibilities
point um realizing
finally to summarize
stalls which occurred
due to branch
pipeline we looked
techniques to improve
improve branch performance
branch performance including
performance including branch
including branch elimination
branch elimination branch
elimination branch speed
static or dynamic
dyna dynamic scheduling
superscalar and vliw
basically instruction level
level parallel architectures
performance beyond cpi
ideally it lies
lies to make
cpi one barrier
super scalar manner
science and engineering,iit
engineering,iit delhi lecture
set architecture-1 today
discussion on instruction
instruction set arhitecture
lecture instructions form
form the interface
interface between hardware
hardware and software
software instructions provide
provide the primitive
operations in terms
basic behaviour definitions
definitions which hardware
understand what action
action they perform
things so first
instructions for carrying
carrying out arithmetic
out arithmetic operations
arithmetic operations simple
data the data
data is required
memory and registers
decisions are made
made in program
control is defined
defined using instructions
handle constant operands
situations where constant
participate in computations
carry the distinction
assembly and machine
relationship between machine
language um machine
basic building blocks
harware can interpret
designing an instruction
goal certain goal
provide a set
set of operations
operations where computation
maximize performance maximize
performance maximize efficiency
cost of implementing
implementing these instructions
goals as power
purpose of reaching
takes a toy
machine and describe
developed by people
people at stanford
stanford in early
risk reduced instruction
reduced instruction set
instruction set computers
lines and mips
video games silicon
games silicon graphics
silicon graphics computers
sony play station
begin with arithmetic
simplest arithmetic operations
add and subtract
add two numbers
numbers to produce
produce the result
equivalently in mips
mips assembly language
register name dollar
two another register
association between registers
established by compiler
arbitarily some decision
registers of mips
two are appearing
two are operands
register and putting
putting the result
simple and infact
architecture and simplicity
simplicity favors regularity
follow certain uniformity
uniformity various operations
follow similar format
instructions for doing
instruction which adds
adds two numbers
operands in mips
mips are thirty
thirty two bit
two bit numbers
registers are thirty
two bit registers
registers um question
instruction can add
add two number
limit the size
size because working
working on arbitary
commonly your numbers
numbers can fit
fit within thirty
addition of thirty
add larger numbers
involve several operations
statement which subtracts
additions being done
two the result
high level language
level language program
done by putting
done in straight
straight forward manner
hold the program
program but memory
hold bulk data
larger data structures
records structures arrays
complexing you build
number of registers
registers is limited
limited in mips
thirty two registers
talking of arrays
instructions to move
data between memory
data from specific
locations of memory
memory so memory
large one dimensional
dimensional array consisting
consisting of bytes
memory is considered
byte whereas operands
two bit operations
half the word
word of thirty
addressability is provided
resolution that means
address each individual
addressed so addresses
terms of byte
bits of address
raised to power
thirty two bytes
raised power thirty
thirty two minus
talking of words
two bit words
words each consisting
power thirty words
relationship of bytes
bytes with word
two different conventions
ignore this spelling
error little endian
endian or big
endian little endian
word you start
start numbering bytes
two are reverse
showing most significant
bit of word
big endian convention
lsb least significant
significant bit end
follow different conventions
intel processors follow
follow little endian
endian convention spark
convention spark processor
processor follows big
work in lab
lab with simulator
adapts the convention
running on pentiums
find one convention
fifty in computer
find different convention
words are aligned
situations where words
aligned to address
physically these bytes
bytes are grouped
grouped as shown
word which consists
consists of byte
logically can pick
word from byte
consisting of byte
word is spread
back to instructions
instructions which excess
moved between registers
registers and memory
store so suppose
element okay lets
memory one word
stands for load
load w stands
stands for word
loading a word
instructions for load
lets not worry
writing a number
imagining that register
holds the starting
elements of type
integer which means
byte of thirty
numbers one number
number is thirty
two another number
contained in register
added and define
define the address
address is loaded
perform an addition
loaded from memory
result is put
put in register
writes this value
instruction sw stand
stand for store
word the address
change this constant
described a simple
index of array
memory perform arithmetic
perform arithmetic put
put the result
back in memory
simply a matter
matter of moving
interchange two elements
taking an array
variable to interchange
programming for interchanging
interchanging two variables
temporary and cycle
basically its clear
require two loads
first two instructions
contents of register
multiply instruction takes
takes one value
offset we require
require four times
address of array
four to begin
address is prepared
prepared in register
offset zero offset
done entire address
entire address calculation
two and offset
load a word
word you pick
fifteen this loads
loads second load
store in opposite
sixteen is stored
fifteen is stored
two get interchanged
explicitly used temporary
put in reverse
order um ignore
talking of instructions
written in symbolic
machine machine instruction
instruction or machine
instructions in binary
form are thirty
uniformity the data
instructions also thirty
operation is add
registers involved registers
total of thirty
etcetera are numbered
etcetera numbered sixteen
numbered sixteen seventeen
directly by number
register two register
register five register
two bit word
word is divided
fields each field
fields the first
short this specifies
specifies which operation
done which operation
operation the instruction
code op code
code for add
limit the total
real machine requires
group of instructions
infact subtract instruction
pattern here contrary
instruction add subtract
fields five bits
field because registers
bit numbers numbering
instruction this filed
filed is unused
short for shift
register fields correspond
stands for register
code for seventeen
two bit number
number which defines
defines this instruction
instruction so add
machine is concerned
writing a long
write in compact
form in hexa
hexa decimal form
instructions load store
store in machine
follow same form
make a deviation
idea of regularity
realize that good
good design demands
demands a compromise
format r stands
constants so lets
number of fields
basically four fields
sixteen bit field
instruction like load
thirty two dollar
field so corresponds
writing in binary
put decimal equivalents
code of eighteen
two is put
coming in load
sixteen bit number
instructions and instructions
instructions for moving
instruction which define
two simple instructions
bne and beq
beq bne stands
stands for branch
equal and beq
branch if equal
equal to illustrate
illustrate this lets
simple if statement
perform this addition
make this comparison
appearing as equality
language or symbolic
symbolic assembly language
equal then branch
two a statement
arbitary in names
doesn t hold
label is linked
symbol j stands
stands for jump
operand for comparison
simply say unconditional
branching to label
puts the result
result this adds
addition we don
jump here jump
jump to lab
two this label
label is label
instruction after subtract
instruction the control
jumps to lab
two so lab
control is organised
comparison for equality
greater than type
type of comparison
instruction called slt
slt which stands
stands for set
set a register
register to value
depending upon comparison
alter the flow
beq or bna
bna to achieve
achieve an effect
lets say blt
spirit as beq
compare two register
register for equality
equality and branch
condition holds suppose
suppose the comparison
combine a comparison
instruction or beq
beq or bne
make compare make
compare make comparison
make comparison result
register is equal
introduced this jump
jump instruction lets
introduced for decision
making and flow
control so bne
code two register
defines the label
pick the data
define an address
address but address
assembly form symbolic
form symbolic form
written a label
number which appears
essentially an offset
define the destination
destination where jump
code and remaining
twenty six bits
jump address slt
address slt instruction
code three register
register fields shift
fields shift amount
shift amount field
field and function
function together define
define slt instruction
move to handling
handling of constants
lot of cases
deal with constants
follow different approach
program is loaded
memory this constant
put the constants
constants as part
putting same instructions
stands for add
brought from register
register or memory
described the meaning
meaning is obvious
instructions also follow
follow i format
code two registers
constants are sixteen
hardwared to register
register whose contents
suppose you write
write an add
instruction with register
leave it unchanged
perform add operation
simply moving data
separate move instruction
instruction um add
moving by virtue
written as dollar
contained in sixteen
work with thirty
two bit constants
deal with sixteen
sixteen bit constant
bit constant rate
designed for larger
eighteen twenty twenty
single instruction handling
instruction handling thirty
two bit constant
instructions one instruction
left half left
half left sixteen
sixteen another instruction
half right sixteen
right sixteen bits
extraction called lui
lui which stands
lui upper means
means it loads
loads upper part
part of register
register left half
half of register
constant so lui
constant sixteen bit
constant this instruction
instruction will bring
bring this constant
constant into upper
half or left
constant which corresponds
happening is shown
instruction is executed
half the right
instruction is taking
taking this constant
right half left
two are odd
odd which means
load a constant
work with single
binary or machine
subtract immediate add
follow r format
add immediate subtract
subtract immediate follow
two branch instructions
discussed the format
unconditional branch instruction
instruction called jump
jump the format
out here load
load word store
word store word
word also form
format lui load
lui load upper
form of bne
bne is branch
beq is branch
smaller in size
size adding smaller
adding smaller numbers
numbers the circuitory
hardware for adding
adding two thirty
numbers is faster
faster than hardware
adding two sixty
four bit numbers
swap instruction swap
instruction swap operation
basically the key
two load instructions
two store instructions
reading two words
words from memory
sixteen and writing
swapped what remains
preparing the addresses
addresses of memory
array is constant
array where compiler
compiler would put
four and index
integers are concerned
concerned they occupy
occupy one word
addressing is byte
add four times
first multiply instruction
preparing four times
two so register
four are added
two has complete
additional four offset
takes two thirty
words and performs
performs or operation
takes one register
bits but actual
two bit operation
operation so remaining
remaining sixteen positions
positions are filled
filled with zeros
number first number
number is contained
number is obtained
obtained by prefixing
prefixing sixteen zeros
put two parts
form a thirty
market the natural
performance which performs
instructions are organized
computer is designed
designed the question
alternatives which alternative
issue of performance
relationship between performance
performance and architectural
performance the question
perspective okay user
view of design
basis for comparison
compare one versus
definition is required
talk of users
understand the relationship
purchasers perpesctive suppose
buy a computer
lot of variety
manufacturers different vendors
set of choices
range of machines
compare performance wise
performance and cost
performance price ratio
pose this question
hand from designers
major styles load
styles load store
load store style
style or memory
memory memory style
memory style stack
style stack style
style okay accumulator
type of machine
philosophies of designing
designing and instruction
build the hardware
choices on cost
cost and performance
instruction design stage
question of performance
fix the price
out different ways
study of performance
quantitative and precised
measuring the performance
measurement may involve
number which summarizes
experiment and based
make good choices
two issues involved
issues involved performance
make a judgement
market a system
project certain things
account your requirements
evaluation or definition
understanding of performance
method of measurement
method of summarizing
method of comparing
comparing is isimportant
view of understanding
understanding various design
piece of hardware
design choice performs
doing word processing
things may happen
influencing the performance
performance are related
related to hardware
factors are related
related to architectural
influence of instruction
performance okay including
including certain instruction
influence on performance
performance or instruction
develop certain understanding
bring some basic
points into attention
set of aircrafts
shows a set
kind of perfomance
first three columns
ignore the last
last two columns
moment the first
first second column
aircraft okay expressed
expressed in miles
range in terms
terms of miles
capacity in terms
number of passengers
matter of telling
speed all right
target was speed
speed then concorde
interested in long
connect two airports
fifty all right
non stop flight
talking of passenger
four fifty passengers
choice is boeing
four seven right
make two trips
fix your targets
area of interest
whats your application
hours to connect
connect two points
two points lets
four thousand miles
number of hours
throughput okay number
carried into miles
kind of composite
two the figures
combination of capacity
criteria okay multiple
machines of performance
context of computers
question how long
job to run
run so moment
run it takes
takes certain amount
execute the program
interactive environment lets
lets say database
query or atm
type of environment
give a command
make a request
seconds or minutes
minutes or hours
type of measure
out the rate
carried out number
number of tasks
tasks per unit
average execution rate
shoes of computer
computer system manager
run every hour
wait or user
collection of computers
throughput some waiting
times are introduced
replace all computers
throughput more important
important than execution
depends upon perhas
perhas the person
concern of response
number a larger
larger number represents
represents better performance
reciprocal of execution
performance of lets
lets say machine
long it takes
simple and straight
straight forward definition
talk of relative
two performance numbers
performance numbers performance
terms of execution
machine a runs
runs the program
program in twenty
seconds and machine
machine b runs
twenty five seconds
twenty times faster
four or twenty
twenty five percent
point eight times
concorde versus boeing
ratio of speeds
ratio which means
means two point
point two times
two times faster
twenty percent times
percent times faster
faster than boeing
point five hours
throughput okay suppose
suppose we define
chart as persons
persons or passengers
passengers carried multiplied
multiplied by miles
pmph figure passenger
figure passenger capacity
passenger capacity multiplied
multiplied by speed
boeing so concorde
concorde is point
percent time faster
faster than concorde
sense all right
comparison was faster
faster in speed
sense or travel
travel time sense
understand the question
order to improve
upgrading a machine
lets say pentium
four two point
point eight giga
hertz is replaced
replaced by pentium
point zero giga
response time change
improve okay increasing
increasing the number
number of jobs
running a sequence
sequence of jobs
jobs all right
right so imagine
imagine that people
start taking multiple
taking multiple jobs
improve the throughput
reduce the response
overhead of switching
overhead of doing
doing time sharing
incurring some overhead
incurring so response
deteriorate okay suppose
couple of machines
machines five machines
machines are lying
add a couple
throughput certainly throughput
throughput will improve
improve more jobs
response time doesn
wait in front
talking of total
takes to execute
execute your job
machines or ten
machines or fifty
network of atm
increase the number
number of processors
number of network
network of atmmachines
end for supporting
supporting this atm
right more machines
fire a transcaction
transcaction on atm
atm but processor
processor is busy
processors take care
fast so continuing
kind of practical
question now suppose
processors two machines
vendors the pentium
takes eight seconds
takes ten seconds
reasons to buy
budget limiting budget
fairly complicated depending
output to happen
multi tasking environment
ultimately is sum
hand the cpu
cpu actually spends
doing your program
exclude the disk
exclude the waiting
spent actually executing
executing your instructions
doing some service
loads your program
program it takes
care of communication
incurrs is attributable
speaking the total
total cpu execution
spent on user
executed to serve
serve your program
factors which influence
essentially user cpu
long a cpu
give an architecture
run that program
clarify these points
program is twenty
twenty two seconds
two seconds user
seconds user component
component is ninety
hundred twelve seconds
total one sixty
sixty two seconds
spent in executing
executing a user
express in terms
processor is running
two giga hertz
hertz that means
half ano seconds
ano seconds cycle
events takes place
place at discrete
clock changes state
two hundred mega
hundred mega hertz
hertz the cycle
execute to cycle
cpu clock cycles
cycles into clock
suppose your cycle
cycles for doing
cpu will spend
spend one milli
clock cycles divivded
divivded by clock
frequency or clock
thing because clock
rate and cycle
rewritten as cpu
clock cycles depend
product of instruction
count and cpi
stands for cycles
cycles per instruction
number of cycles
takes to run
run a program
cpu time equal
equal to instruction
instruction count multiplied
multiplied by cpi
multiplied by clock
period alternatively cpu
divided by clock
rate or clock
frequency so units
units of thee
talking of seconds
cpu time seconds
instructions per program
cpi is cycles
instruction and clock
rate is seconds
seconds per clock
balanced okay instructions
cancel with instruction
instruction um cycles
cycles get cancel
cancel with cycles
seconds per program
left hand side
hand side seconds
side seconds required
required to execute
execute a program
program or seconds
processor with clock
rate of fifty
fifty mega hertz
talking of cycles
cycles everything happening
happening in cycles
talking of average
substituting the value
value the instruction
count is thousand
rate is fifty
hertz so fifty
fifty into ten
ten raised power
seventy into ten
raised power minus
minus six seconds
seconds or seventy
seventy macro seconds
clock frequency increases
asked this kind
kind of question
two fifty mega
hertz other factors
factors others remaining
ratio of inverse
rates or direct
ratio of clock
two five times
point of fractional
mentioned that cpi
implement the hardware
notice that hardware
hardware takes longer
instructions and shorter
find an average
average so cpi
essentially a waited
average of cpis
cpis of individual
individual instructions suppose
instructions or instruction
frequently this instruction
instruction is occuring
categories of instructions
instructions arithmetic instructions
present fifty percent
program that means
half the instruction
program are add
subtract multiply divide
category twenty percent
percent of instructions
load ten percent
store twenty percent
twenty percent branches
hundred the cpi
alu instruction cpi
stands for arithmetic
arithmetic logic unit
logic unit instruction
arithmetical or logical
cycle load takes
takes five cycles
cycles store takes
takes three cycles
cycles branch takes
takes two cycles
fraction while computing
two into point
average an instruction
spends two point
point two cycles
cpu would spend
spend doing alu
doing alu instructions
spend doing load
doing load instrution
divided by total
two so point
twenty three percent
forty five percent
point two point
processor will spend
write a program
attention on minimizing
minimizing the loads
kind of instructions
instructions take longer
instructions take shorter
group all alu
situations where multiplications
multiplications and divisions
longer than addition
addition and subtraction
operations and floating
floating point operations
point operations floating
operations floating point
longer than integer
integer operations memory
operations memory accesses
accesses take longer
longer than accessing
instructions for adding
adding one picks
picks up operands
operands from memory
memory one picks
operands from registers
taking from register
change your cycle
redesign a faster
cycles because number
required for doing
doing an instruction
make the cycle
divide into cycles
cycles would determine
make your cycles
work per cycle
product of clock
multiplied by number
attempt to pull
quantity and hoping
change can influence
program is cycles
cycles per program
multiplied by seconds
seconds per cycle
multiplied by cycles
reduce this seconds
increase the clock
make a move
complicated statement lets
program which runs
runs in ten
seconds on computer
four hundred mega
design and build
run this program
program is concerned
increase will effect
effect the rest
cpu design causing
design causing machine
require one point
program what clock
designer to target
answer is giving
sir the number
seconds by executing
executing n instructions
set is instruction
figure would change
two and divided
times four hundred
four hundred multiplied
multiplied by ten
answer all right
difference between system
system cpu execution
system means operating
means operating system
thing just word
computer architecture today
walks of life
shapes and sizes
computer of today
today it packs
power more storage
computer of nineteen
occupied a big
hall much bigger
form of computer
weather prediction nuclear
prediction nuclear simulation
simulation for astronomical
calculation and bio
tiny and small
home appliances cameras
appliances cameras mobile
cameras mobile phones
remote to control
control this projector
variety of computers
computers entire diversity
diversity in space
principle which binds
forms of computers
motivation for studying
define the term
term computer architecture
propose to learn
find this basic
principle is common
small and large
learn how computers
people have developed
developed wrong notion
designed or built
design and construction
aspects of computers
important in todays
responsible for giving
kind of performance
structure into cahes
cahes and virtual
pipelined how instructions
put in parallel
build a computer
opportunity for designing
design an improved
processors getting designed
software stream understanding
understanding of architecture
influences the performance
relationship between hardware
manager or administrator
buy a set
set of computers
system is important
knowledge of basic
relations with basic
area of embedded
computers where computer
computer is part
application where computer
architecture um simplest
giving an idea
idea what computer
architectural buildings building
buildings building architecture
basically a plan
parts of building
components of building
make a plan
hand a civil
design which means
stand it shouldn
shouldn t fall
care of stresses
stresses and strains
design or circuit
realise this functionality
realise this plan
put basic components
components together transistors
transistors registers capacitors
move little bit
computers are designed
designed and built
immediately it brings
disciplines of engineering
engineering and science
talk of architecture
architecture you find
layers and layers
layers of abstraction
abstraction what abstraction
leave out details
relevant and focus
focus on matters
matters and issues
abstraction by information
information is reduced
relationship between architecture
architecture and circuit
similarly the architecture
software are seperated
layers of abstractions
abstractions the abstractions
computer at level
level of basic
components from circuit
millions and millions
millions of basic
defining your computer
computer in terms
complex and mind
numbers and returns
returns the result
level language programmer
solution but computer
directly this solution
language which computer
computer can understand
produce an eqivalent
computation is broken
number of steps
preparing the data
data before addition
putting the data
circuitary inside processor
processor can perform
link this function
function to main
program called assembler
sequence of numbers
straight forward process
machine language program
program or machine
essentially a number
number number notation
hexa decimal number
two hexa decimal
hexa decimal digits
number or bytes
sequence of bytes
bytes which represent
turn it represents
represents this program
written by programmer
zeros but hexa
hexa decimal notation
corresponds with binary
binary notation inside
inside a computer
data or program
data or instructions
instructions the numbers
don t distinguish
understands the hardware
abstraction one major
central processing unit
input output devices
mouse keyboard display
keyboard display disk
display disk drive
controller the processor
processor is connected
connected to memory
program counter register
counter register file
register file alu
alu and bus
bus interface program
interface program counter
counter keeps track
track of current
instruction being executed
executed register file
register file stores
file stores operand
operations arithmetical logical
arithmetical logical relational
logical relational comparison
relational comparison operation
operation and bus
connects these modules
gates or gates
exclusive or gates
gates not gate
consisting of basic
basic devices transistor
devices transistor register
eventually you reach
reach a level
transistors of basic
shown these pictures
floppy disk drive
disk drive hard
drive hard disk
hard disk drive
disk drive cdrom
drive cdrom drive
fins of heat
system the memory
input output cards
bottom some part
part is visible
slots where zoomed
plug in input
pci slots pci
cards are connected
connected various controllers
controllers are connected
memory individual memory
individual memory chips
put together form
form a memory
form the complete
complete memory system
seagate hard disk
drive okay shown
recording is done
level language programs
major building block
building block registers
block registers adders
components and transistors
hardware software boundary
instructions which define
define the basic
major harware components
understand those instructions
software in terms
levels of hierarchy
hierarchy within software
instruction set level
micro architecture level
level so instruction
instruction set architecture
set architecture refers
lowest level visible
visible to programmer
programmer so programmer
flops or adders
unit of computation
instruction whereas micro
concerns a hardware
define any instruction
information is made
made to flow
defines the instruction
place instruction set
software and hardware
hardware at top
compiler is required
required to translate
translate these high
high level programs
programs to machine
required to manage
manage the resources
resources and make
compile compile load
load and execute
design the broad
broad cpu design
fabricating the circuit
place the transistor
place a wire
network but physical
physical dimension physical
dimension physical manifestation
manifestation is assigned
earlier assembly language
assembly language view
language view defines
instruction to instruction
state defined state
state is defined
defined in terms
terms of contents
registers and flip
processor so memory
memory whereas memory
data and program
program what registers
performing an addition
typically the operand
instructions are represented
set of instruction
instruction is represented
represented in terms
zeros or hexa
digits for convenience
layer of abstraction
hardware components high
components high level
level as register
register files alu
level as transistors
transistors and resistances
make this instruction
instruction set posssible
put these components
components these blocks
lots of tricks
tricks and techniques
employed to make
make everything happen
talking of hand
hand held devices
held devices devices
small computers lap
computers lap tops
lap tops mobile
tops mobile phones
consumption is important
last very long
carry out computation
computation while consuming
issue sometime power
extreme power saving
ultimately the cost
find different ways
ways of executing
executing same instruction
lots and lots
lots of transistors
lies in making
making right choice
choice while designing
designing a processor
works is captured
code or program
program in machine
supposed to operate
means to bring
computations are done
structure called stack
functions about hierarchy
system is cpu
counter and alu
alu registers condition
registers condition codes
perform all arithematic
arithematic and logical
operands are contained
contained in registers
alu will carry
out the desired
sequence of instruction
instruction will differ
encoded what operations
operations they invoke
operation is done
subsequently for decision
helps in providing
branches and loops
high level languages
processor or simple
talk little bit
make an abstraction
works in terms
terms of simple
abstraction some details
making an abstraction
kind of simplification
registers or memory
store supposedly integers
integers and reals
mathematics are unbounded
talk of real
programs and real
bounded okay integer
integer in mathematics
integers and finite
understand these differences
numbers is concerned
properties which real
number would satisfy
working in mathematical
talking of real
add three numbers
talking of numbers
numbers as abstracted
understand to understand
understand a processor
understand its assembly
real life program
programming is done
language is required
mind to understand
understand how programs
model of memory
array of bytes
bytes or words
memory is bound
number of word
word or limit
number of bytes
fast to read
read different words
words of memory
memory one acess
acess to memory
makes that happen
structure in real
talking of performance
performance in program
architecture how long
execute that program
terms of milli
milli seconds seconds
seconds and minutes
minutes if program
program is taking
long i mentioned
mentioned about embedded
embedded computers domain
provide you opportunities
opportunities for making
making new designs
typically require designing
require designing hardware
harder than designing
designing just software
software or designing
designing just hardware
issues so embedded
components okay embedded
processor is part
system it appears
component which performs
performs some intelligent
control a proces
information or perform
perform some communication
opens up lot
lot of application
embedded computer domain
worry about real
real time operation
computer in embedded
work with information
appears in real
lot of design
customize a processor
add or subtract
part the key
variety of processors
applications from tiny
desk top computers
top computers lap
computers lap top
lap top computers
top computers mobile
computers mobile phones
mobile phones washing
phones washing machines
set and executing
difference in instructions
difference in terms
performance or speed
lot of difference
terms of power
power consumption cost
terms of instructions
general purpose general
purpose general purpose
general purpose means
kind of application
desk top computer
power point presentation
listening to music
music whereas special
special purpose computer
process the calls
function is unchanged
unlike in desk
desk top processor
change the program
phone the program
program is fixed
two different cpus
intel same manufacturer
type of processor
typically in embedded
application the actual
small rectangular tcq
tcq see inside
inside this circular
case the actual
size this big
thing like forty
accommodate forty pins
made so big
device same circuitory
packages roughly lets
approximately this size
two contrasting devices
general purpose processor
high performance consumes
performance consumes lot
lot of power
special purpose applications
lower power consumption
consumption um doesn
doesn t care
care about performance
left would work
work at giga
hertz of frequency
essentially a quartz
erase the program
store the program
put the program
inside its memory
make some upgrade
ultra violet light
light the memory
program will remain
don t chage
summarize with list
list of major
forms an outline
meant by performance
specific instruction set
set a simple
simple but powerful
computation in terms
terms of doing
architecture at instruction
operations are carried
out in terms
terms of binary
circuitory to carry
out those numbers
operations then based
based around based
build a processor
processor to execute
execute the instruction
put register file
put program counter
put a controller
controller to make
make the data
flow of data
technique of pipelining
high performance system
today have pipelining
component is memory
talk of input
output devices input
devices input output
input output controllers
connect to memory
memory and processors
out various announcements
overview similar list
list of topics
incidently doctor kolin
doctor kolin paul
preparing presentation material
maintain a lab
instructions about lab
first lab exercise
make a submission
submission so guidelines
submission of assignment
initial few exercises
simulator called spin
account but don
computer services centre
computer organisation design
design the hardware
hardware software interface
book other books
refered to computer
computer system design
design and architecture
architecture by huring
huring and jordan
jordan and computer
architecture and organisation
terms computer design
computer design computer
design computer organisation
computer organisation computer
organisation computer architecture
list a book
rigerously the term
terms of describing
functionality whereas design
hardware building aspects
minors majors lab
majors lab exercises
exercises um weightage
weightage of lab
percent and quizs
interface peripheral computer
peripheral computer interface
mobile phone mobile
phone mobile phone
computer okay infact
infact many mobiles
palm palm top
top yes palm
general purpose computer
variety of function
generally a gap
delivered same day
history of computers
lecture i talked
history is important
political history economic
history economic history
history or history
history of science
science or history
place in past
past have made
made um significant
tommorow so first
half a century
period gets divided
impact on history
interesting old pictures
pictures of computers
briefly this mentioned
mentioned what technology
decide what kind
kind of computers
future this period
differences of opinion
people only recognize
generation as recognised
develop computer systems
systems or electronic
system in general
major technological development
technological development takes
development takes place
significant very drastic
drastic sudden change
size of computers
top in terms
terms of cost
cost the affordability
affordable by large
organisations now large
number of people
people can afford
computers and infact
count all computers
devices all appliances
appliances mobile phones
equipment the number
number of computers
today the power
consumption has changed
large of magnitude
efficiency in terms
computers can work
reliabily for extended
beginning in forties
forties to fifties
device was vacuum
vacuum tube vacuum
tube vacuum tube
bulb like device
basic electronic device
voltage at current
bulky and reliable
reliable and powerguzzlers
powerguzzlers the computer
computer is built
roomful of system
devices were punched
cards and paper
tapes the memories
rotating drum magnetic
drum magnetic rotating
magnetic rotating drum
program was machine
first generation computers
notice a period
indicating are overlapping
suddenly on day
growth development improvement
change is marked
abrupt but rapid
change here accord
accord with arrival
arrival of transistor
transitor from texas
instruments these transistors
perform roughly similar
roughly similar function
function what vacuum
smaller faster cheaper
efficient in terms
terms of energy
energy also reliability
development in terms
terms of software
machine language people
language people started
period some languages
languages high level
languages the early
put several transistors
single silicon chip
integrate many transistors
device the picture
picture here shows
shows the layout
early chip depending
level of integration
characterised as ssi
msi or lsi
lsi ssi stands
stands for small
small scale integration
scale integration medium
integration medium scale
medium scale integration
integration and large
large scale integration
integration or small
devices few transistors
tens of transistors
transistors large scale
scale would scale
scale few thousands
thousands of transistors
naturally equipment computer
compact the speed
increased the efficiency
efficiency increased additional
increased additional peripherals
interactive with cards
batch processing environment
submit your program
program for running
days later depending
load and efficiency
press a button
prepare a deck
deck of cards
progam is punched
punched and data
punched or prepare
prepare a roll
roll of paper
tape by punching
small syntactic mistakes
result is nil
make that correction
terminals and keyboards
interactive and online
mode and operating
system also evolved
change next major
major change occur
make entire processor
chip the number
number of transistors
chip was large
lsi to vlsi
vlsi vlsi stands
large scale integrated
scale integrated circuits
vlsi also terms
defined like ulsi
ulsi ultra large
ultra large scale
seventies late seventies
talking of vlsi
number of times
million um infact
tending to hundreds
hundreds of millions
vlsi basically meant
tens and hundreds
hundreds of thousands
level of change
owning their computers
computers personal computing
personal computing home
computing home computing
home computing embedded
computing embedded computing
computing that means
posible when processor
processor really shrunk
terms of capablities
capablities of computers
emphasis on graphics
graphics graphical user
graphical user interface
mouse um hand
devices also started
basically same microprocessor
literature you find
mention fifth generation
terms of capability
capability of computers
computers um computers
processing to increase
increase the performance
performance and input
natural in human
life so infact
undertaken in japan
unlike previous definition
definition of previous
defined by change
style of computing
computing and level
level of performance
performance has increased
cost has decreased
combine the effect
cost per unit
technologies are compared
compared here vacuum
vacuum tube transistor
tube transistor integrated
transistor integrated circuit
circuit and vlsi
four different generation
years nineteen fifty
fifty one sixty
sixty five seventy
performance per cost
unit cost raises
amount of progress
place in terms
rupee or dollar
capacity has changed
dram or dynamic
ram the basic
basic semiconductor memory
changed in terms
terms of capacity
talking of capacity
capacity per chip
capacity as theyears
theyears have passed
sixteen k capacity
four million bits
year to year
years the capacity
frequency of processor
scale of complete
complete computer system
include performance contribution
performance contribution made
made by cpu
ten years period
rise in performance
decade um sunfour
sunfour two sixty
mix machines ibm
machines ibm machine
machine hp bakel
bakel for twenty
twenty one thousand
thousand two sixty
terms of generation
events the significant
events which occur
impact so lets
couple of slides
major events beginning
beginning with introduction
first programmable computer
computer by konrad
four um computer
computer called harvard
architecture essentially means
program and memory
memory which accomodates
program and data
two different memory
units for program
idea even today
caches for program
okat this basic
eniac one computer
developers were eckert
large as compared
compared to previous
periods of forties
researching on development
development of computers
significant in terms
size its capabilities
difficult to pin
inventor of computer
john fon newman
involved in developing
precisely the concept
principle of computer
counter the processor
processor takes instruction
instruction and executes
stated by john
plug in wires
slot to change
change the functionality
sort of computer
easy to program
program then nineteen
transistor was invented
event which changed
first commercial computer
computer is considered
considered as univac
univac and people
involved with eniac
responsible for development
buy then ibms
ibms first computer
computer is ibm
enters the history
remained very significant
industry the language
first high level
language which easy
four fortran seventy
original um event
event is nineteen
version was made
stanford research institute
institute and bank
bank of america
computer was developed
micr was made
magnetic ink corrector
ink corrector reading
ics integrated circuits
integrated circuits date
back to nineteen
first computer game
computer game nineteen
game nineteen sixty
sixty two spacewar
spacewar um invention
invention of computer
sixty four first
four first computer
first computer network
computer network arpanet
arpanet in nineteen
developed by defence
defence funding arpa
funding arpa stands
stands for advanced
advanced research project
research project agency
agency which funds
funds research projects
projects in usa
usa um large
scale integration begins
intel first memory
first memory chip
first dynamic ram
dynamic ram chip
chip and first
microprocessor is intel
flexible storage unit
storage unit flexible
unit flexible disk
nature um ethernet
ethernet computer networking
consumer so first
first home computer
computer or consumer
computers in seventy
seventy four seventy
span many years
years from apple
apple trs eighty
eighty and commodore
commodore um spreadsheet
spreadsheet was visicalc
developed in nineteen
first word processor
word processor wordstar
processor wordstar nineteen
wordstar nineteen seventy
level a series
computing the earlier
earlier consumer computer
computing also moved
moved to individuals
reaped maximum benefit
event were microsoft
microsoft and intel
first operating system
system first version
version of microsoft
microsoft operating system
operating system msdos
apple lisa computer
computer with extensive
extensive gui graphic
gui graphic user
graphic user interface
convenient another popular
computer of apple
apple apple macintosh
macintosh um windows
appeared in nineteen
history of events
lot of significant
events took place
looked as compared
computer from ibm
ibm s ssec
compute tables indicating
tables indicating moon
indicating moon positions
flight to moon
moon in nineteen
talk of millions
millions of operations
input and output
cards and pumched
tape the technology
tubes and relays
relays are devices
voltage the current
required floor space
space of twenty
twenty feet twenty
twenty five feet
feet by forty
forty feet univac
thousand of operation
terms of magnetic
magnetic tape printer
tape printer memory
printer memory size
thousand words thousand
words thousand numbers
storage was delay
vacuum tubes magnetic
tubes magnetic tapes
thousand us dollars
orders of magnitude
magnitude as compared
compared to todays
cost of printer
two very popular
popular systems ibm
ibm three sixty
left and cdc
architecturally cdc sixty
introduced the idea
idea of pipelening
pipelening and idea
modern day processors
architectural details illiac
system a parallel
parallel system developed
developed by university
university of illionos
illionos urbana champaign
first major attempt
attempt to develop
develop a large
large parallel system
seventies the level
integration became high
high computers computers
computers computers shrunk
shrunk from room
writer like device
acts as terminal
picture xerox alto
xerox alto machine
first work stations
stations so work
basically powerful desk
powerful desk top
full fledged capability
capability of large
computer but good
good user interface
user interface graphic
interface graphic user
interface so xerox
work in developing
developing window based
window based interface
early super computers
super computers cray
company called clay
clay which fall
category of super
high performance computer
highest performance computer
number of cabinets
reduce the length
length of wire
length of cables
cables which connect
connect back panels
reason for keeping
keeping this cable
required extensive cooling
cooling to make
make it work
computers of aragon
kind of technology
lot of things
things which research
research is taking
place the devices
devices are shrinking
reaching the atomic
nano technology area
technology area nano
area nano technology
nano technology means
means all dimensions
meters um grid
grid computing refers
refers to computing
number of hundred
thousands of billions
billions of computers
computers all netrworked
solve a single
extended quantum computing
quantum computing based
based on quantum
promise of solving
tough computing problems
shorter time dna
structure and computing
extent and depending
totally different kind
computers in future
design a part
discussing instruction set
set level architecture
simple instruction set
set for mips
architecture has thirty
perform arithmetic add
arithmetic add subtract
summary of instructions
add subtract add
instructions one operand
equality and inequality
beq and bne
instruction or jump
instruction for moving
parts and first
loads upper half
back the remaining
divided into fields
format or register
upto three registers
registers i format
format is required
performing an operation
field of sixteen
instruction where twenty
point and talk
case of simple
type of structures
typically beq bne
beq bne instruction
possibily in conjuction
conjuction with slt
loops we don
introduce new instruction
loop you access
access an array
accessed with index
type of statements
variation from instruction
differences so lets
programming is summing
straight forward thing
form where instructions
structure have put
put in terms
terms of conditions
elements we begin
begin by intialising
intialising a variable
hold the sum
element of array
array and submit
update the index
index and perform
perform loop termination
loop termination check
test in today
instructions these steps
steps are implemented
straight forward move
forward move instruction
remember the correlation
register for holding
holding the value
register to hold
hold the value
written a single
statement s equal
repair the address
address to make
make an excess
talking of integers
occupy four bytes
array the offset
put a comment
address of first
two were added
added together give
two are added
added the result
doing the job
two we branch
start the loop
talked of blt
blt instruction blt
compares two registers
two real instructions
slt slt compares
value is stored
make a branch
branch all right
branch will occur
implemented using slt
slt and beq
beq or slt
slt and bne
kinds of comparison
simply use blt
assembler which expands
introduced another register
stands for assembler
expecting that blt
hold some temporary
value some intermediate
terms of numbers
modify the contents
convention is good
directly and leave
directives which define
define the data
area so dot
define some data
assembler directive dot
directive dot space
four hundred bytes
data area leave
area leave space
array of size
assume we assume
symbolic language programmer
assembly language programmer
assembler to figure
assembler will assign
assign some address
default data area
arbitary size thirty
lecture that loading
loading a large
requires two steps
steps first step
first step loads
loads the upper
half next step
loads the lower
right a upper
upper is loaded
loaded by lui
instruction into upper
simply um superposes
superposes the lower
initialization i wanted
two hundred hundred
instruction get loaded
hundred and put
code to input
input the data
perform the sum
code for computation
done the summation
output the result
skipping the details
details of input
written some code
code which works
pointers or addresses
code or improve
pointing to starting
indexing the array
dereferencing the pointer
addition to incrementing
incrementing the index
incrementing the pointer
pointer and rest
two extra statements
initialization of pointer
updation of pointer
pointer the summation
summation gets replaced
introducing more statements
translate this summation
gain is occuring
worried about making
making the loop
done several times
instructions has reduced
jump two steps
load address dollar
statement gets expressed
expressed in terms
terms of real
simply a loading
loading the word
word and performing
performing the addition
addition because address
multiply the index
two initial address
initial address preparation
address preparation steps
straight away load
load the data
opportunity for improving
improving the code
notice whats happening
working with pointer
simply to control
control the termination
maintaining a index
access a array
reached the final
attempt to improve
improve the code
removed i equal
added a statement
statement which computes
computes the final
introduced a statement
preparing the final
two is equivalent
careful to add
place of hundred
loop is programmed
two nested loops
simple sorting algorithm
array okay finds
out the smallest
smallest one smallest
smallest one place
put for structures
comparison then jumps
makes a pass
array the main
seperately main step
scanning and compares
interchange is done
first outer loop
loop first iteration
first with encoded
encoded the first
array then anchor
scan the array
comparison and interchange
indices are changing
working with pointers
pointer to begin
four please correct
basically comparing elements
comparing elements pointed
comparison is done
repeat this process
simply the pointer
initialization is load
prepares next statement
ninety six right
two is initialized
equal to comparison
comparing limits pointed
limit or element
skip this integer
require three assignments
load the values
store the values
four the order
basically that statement
understand how comparison
branch and jump
unlike boolean comparison
true and false
pieces of code
means after performing
performing f equal
end you put
put a break
make repeated comparisons
right you compare
action then compare
statement had lots
lots of cases
tedious and messy
doing a multiway
jump on register
table and jump
value k falls
skip second comparison
comparison is made
shown it whats
prepare an index
obtain four times
performing a multiplication
doubling the number
value so add
four is assumed
jump table starting
table starting address
prepared the index
array same thing
thing is done
done starting address
address is added
added and final
contents of memory
memory location address
table we pick
table is shown
table and register
finally is made
made to point
find straight forward
straight forward code
forward code doing
subtraction another subtraction
btehe more statements
finally you jumped
jumped to exit
case but problems
talking of values
values were relevant
non continuos values
waste the space
range is compact
compact that means
values of range
bodies or cases
blanks to make
suppose um suppose
suppose these addresses
addresses are thousand
lets say thousand
thousand twenty thousand
twenty thousand fourty
fourty and thousand
starting address thousand
thousand plus twenty
addresses are arbitary
compute the address
address by taking
taking a base
range of instructions
built using beq
computing the address
address j instruction
format j format
twenty six bit
format provides fields
registers we require
fields are unused
first lets begin
begin with load
imagine a instruction
type load word
register or base
addressed is obtained
positive or negative
number the value
range two minus
two fifteen minus
twos complement form
familiar with twos
twos complement notation
address in beq
worried about word
terms of bytes
words or double
varieties may exist
processors where instructions
located at aligned
boundaries the instruction
fact is made
offset the address
offset again positive
negative with respect
jumping four instructions
give a positive
write a table
label of destination
current instruction assembler
negative the offset
terms of word
addresses for instructions
shown here beq
two c compare
register specifying address
strictly speaking notice
notice that depending
depending on outcome
outcome of comparison
instruction in jump
number as destination
full fledged thirty
two bit address
terms of hardware
address is computed
instruction dot dot
dot dot twenty
twenty six lsbs
two to twenty
unchanged and bits
defined by twenty
effectively in terms
twenty eight byte
twenty eight bits
range of jump
segment of size
memory is divivded
divivded into segments
segments with thirty
memory two raised
four gb imagine
four gb space
space is divided
divided into segments
segments of size
size two fifty
jump is occuring
segment then jump
jump will occur
segment and jump
word will occur
two bit register
doing is transfering
transfering the contents
fledged thirty bit
thirty bit address
carrying out jump
today i began
began with examples
compare and branch
statements to carry
carry out simple
out simple loops
simple loops nested
loops nested loops
opportunities for improving
loop the body
whats the importance
language in practice
point in bothering
small nitty gritty
nitty gritty improvements
understanding is required
required for compiler
transformations these improvements
mind by code
code is generated
beginning actually comppiler
generate the final
final improved code
program we wrote
write using index
index but compiler
implement a switch
address the memory
point computer architecture
set architecture-3 today
important programming language
programming language abstraction
abstraction namely function
function or procedure
bottom up fashion
construct large program
impossible the set
learnt is summarized
includes arithmetic instructions
instructions and logical
first two rows
operands are registers
comparison and branch
branch unconditional jump
unconditional jump load
jump load store
load store load
store load upper
jump with register
means to jump
mechanism to carry
out multiway branch
defined are shown
shown here move
moving a data
essentially a copy
copy of value
value is made
made load address
load address load
loads a constant
variations of branch
branch these instructions
instructions are implemented
discuss in tutorials
today will talk
abstraction to implement
implement a procedure
require what activities
function the instruction
form of functions
order to develop
develop a program
abstraction essentially procedural
essentially procedural abstraction
procedural abstraction means
piece of code
defined well identified
operation either single
operation or single
ease and convenience
computation is performed
require several things
worry about flow
control that means
means from main
call that means
tranfer the control
ends the control
made a call
made because call
call may occur
points and ruturn
everytime you invoke
invoke a procedure
set of data
set of parameters
parameters of procedures
procedures called sub
sub data flows
parameter which carry
local storage decorations
inside a procedural
call a function
function multiple times
allocation of storage
procure may make
make an access
case where main
matter gets complicated
recursion and indirect
recursion that means
direct or indirect
issues of control
control flow data
flow data flow
data flow organising
flow organising local
local and global
recursion so lets
organize the flow
simple minded sorting
minded sorting program
simply had double
main operation inside
inside the loop
interchange we suppose
calling as xchg
basically this exchange
level um rest
comparison and exchange
basically a set
don t place
put a call
jump and link
link jal stands
xchg as label
effect of jal
tranfer the call
transfer the control
thing it saves
saves the current
address of instruction
special in terms
terms of functionality
stands for return
return address register
return after completing
completing the prodedure
address and link
back so rest
call as main
returning any values
value is void
parameter being passed
values and doing
added a return
terms of mips
instruction which takes
destination or target
stored return address
provide control flow
flow and linkage
linkage of caller
question of passing
care of data
arguments the parameters
done the simplest
designated for passing
procedure are loaded
part of set
set of register
convey the parameters
changed the register
number of parameters
parameters the convention
upto four parameters
four registers designated
lots of common
similarly the values
values being returned
procedure or function
number of values
resort to memory
specific memory locations
function is restricted
restricted to load
partly through registers
returned to memory
defining local storage
local storage suppose
function or procedures
data area code
area code area
data and code
functions or procedures
compiler would follow
convention and produce
produce the code
case of nested
calls that means
means a function
function can call
call another function
bring the control
control gets tranferred
dollar ra brings
happen when first
first call occurs
occurs the ddress
jal gets stored
reach this point
array gets replaced
replaced by address
call will occur
correctly this return
return will occur
return the program
preserves its return
address all right
calls can occur
care of saving
enter the procedure
huh you save
save the contents
call the last
return the last
memory location load
array is free
make any calls
make a call
nesting of calls
sorting case sorting
case sorting problem
find a minimum
minimum and put
number of elements
pointer to place
place where minimum
area in array
onwards and bring
bring the minimum
back to location
single loop call
call to min
min um min
performs that exchange
exchange condition conditional
condition conditional exchange
conditional exchange compare
compare and exchange
jal to min
makes a call
call to exchange
updates r compares
basically forms body
save and load
saving ra value
call ra save
constant or large
assembler will translate
possibly two instructions
prepare the address
move a step
call which means
means a procedure
changed this loop
min into recursive
improving the program
jump to exchange
value of parameter
exchange or exchange
exceeds final value
finding this false
chain of return
return will happen
follow this program
translation in minutes
restoring this right
making this comparison
comparison and looping
making a call
fixed memory location
stored is value
inside so subsequent
return takes place
everytime now return
original entry point
lose any value
natural structure natural
structure natural data
natural data structure
last in first
first out structure
returns take place
first out manner
enter into function
call is occuring
occuring the return
address gets pushed
returning i popped
popped the latest
calls are occuring
pushing the return
enter a function
push the return
address into stack
stack and return
pushing and popping
stack is created
register called stack
implement a stack
make stack grow
grow towards reducing
addresses or increasing
imagining that lets
lets say address
top and maximum
stack and start
start building stack
stack towards lower
point to top
decrement stack pointer
pointer to create
space for putting
putting in data
store the value
stack so add
subtract immediate instruction
instruction you add
four from stack
pointer and pop
pick up value
stack as pointed
stack pointer put
register and update
update the stack
stack pointer increase
save and restore
restore the values
values of return
environment all right
ensuring that information
information about return
previous example situation
situation was simple
back i don
basically um everytime
everytime a call
call is made
made the fresh
values are passed
value i don
code after recursive
passed you passed
passed on values
afford to lose
lose whole values
passed through registers
registers if situation
situation is simple
calls whole parameters
save the parameters
pass the parameters
parameters through stack
answered which memory
locations so additional
call you load
load the parameter
inside the function
allocating the local
enter the function
space which corresponds
create local arrays
talking of procedure
writing a program
program you assume
call occurs control
program will continue
imagine a situation
situation that main
person one programmer
function is written
write in sequence
vision all right
ease the task
save the registers
writing the calling
done partial computation
computation some results
back and continue
caller should save
save or callee
callee should save
question this conflict
programs two people
people will write
destroy the value
fingers will point
saved temporary registers
caller can assume
safe to leave
ensure that values
preserved across calls
results for left
assume that values
feels the necessity
save the values
save the callers
value which work
make a make
restore those values
caller is concerned
caller will stick
assumption that values
simply temporary registers
registers where values
responsibility of leaving
leaving these untempored
hand if caller
requires these values
saved across calls
caller is expected
expected to save
safely then make
recover that recover
recover these values
saved by caller
values or touching
touching the values
values and saving
saving in case
talking of lots
lots of register
ensured by hardware
value is constant
thing you missed
out here dollar
eighty is register
expanding pseudo instructions
pseudo instructions requires
requires a temporary
preparation of address
address or storing
storing the comparison
result then assembler
normal is expected
run into problem
function many procedures
access various components
dollar zero dollar
dollar two dollar
dollar four etcetera
usage so hardware
ensured that register
value and jal
jal instruction assumes
assumes that value
matter of convention
convention the hardware
convention and hardware
doesn t understand
understand this stack
register for pointing
pointing to stack
execute jal instruction
instruction the return
instruction it starts
specifically for return
talked abou putting
mentioned was stack
stack is organised
follow different convention
create an activation
record on top
return you clear
nested calls occur
build these activation
typically the stack
pointer will point
mentioned other register
frame pointer points
previous activation record
record okay convention
earlier the arguments
record the return
saved is saved
saved here local
data is allocated
local local data
local data area
access is made
referenced in terms
doing any dynamic
dynamic storage allocation
suppose the program
program is sophisticated
allocation gets done
act as reference
reference point accessing
accessing the data
access is load
word some constant
pointer the offsets
stack is filled
offset is required
lets summarize lets
create procedural abstraction
arranging procedure call
call and return
parameters are passed
passed we talked
talked of complications
complications which arise
recursion the solution
lot of conventions
illustration and show
complex recursive procedure
activation record creation
explain frame pointer
writing the program
piece of data
accessed with constant
offset with respect
top of stack
size may grow
grow or shrink
changing so stack
part is constant
constant all right
methods but atleast
atleast the part
unchanged whose location
location or seat
seat is unchanged
access by constant
push and pop
couldn t calculate
terms the pushes
push different things
push return address
made to grow
clear off activation
space which isallocated
source of error
pushes and pops
memory is allocated
stack pointer stack
pointer stack stack
stack stack pointer
start at lets
areas two data
two data areas
areas which grow
grow in opposite
stack it grows
grows and shrinks
heap which grows
shrinks so heap
allocations for malloc
allocations when calls
calls and return
make a fixed
area for heap
area for stack
area less heap
area less stack
don t clash
out of memory
answered this question
space you allocate
allocate a fixed
space and leave
class i discussed
discussed how sub
routines or procedures
assembly language programs
link the flow
talked about convention
convention of register
usage which helps
helps in usage
usage of temporary
temporary areas temporary
areas temporary words
structure like stack
match the order
define an activation
layout of memory
memory in stack
kep the temporary
data um today
ideas and show
show and illustrate
create activation records
records in order
order to define
define recursive procedures
call these records
records get created
return some functions
examples and rest
calling this picture
funtions or procedures
calls could occur
arrange for flow
manner or non
non recursive manner
illustrate the point
implementation first describe
begin with description
description of main
care of inputting
inputting an array
array of integers
integers then call
call the sort
array of dimension
dimension as input
care of entering
entering the value
array or size
input the values
integers and integers
integers are input
input and stored
call to sort
output the sorted
output all right
straight forward function
function you input
perform a sort
sort and output
output i don
function the merge
merge function merge
function merge sort
merge sort function
sub matrices sub
matrices sub arrays
purpose um special
split the array
array that array
sorted when size
two parts sort
out two integers
halves roughly equal
roughly equal halves
halves of size
size of data
two sorted arrays
function all right
forward in terms
structure one small
permit a variable
variable size array
spliting the array
smaller and smaller
maximum possible size
wastage of space
sake of simplicity
manner so infact
sort it creates
creates two local
two local arrays
arrays of size
order is maintained
output and small
small p small
small q give
give the dimensions
local variables initialised
element and pick
creating array sorted
array sorted array
array in ascending
transfer one element
reach a point
pass on elements
pass on remaining
implement these recursive
based on defining
defining activation records
activation records creating
call and disposing
return so lets
define the structure
record so first
create activation record
parameters addresses starting
addresses starting addresses
right the order
things are appearing
space on top
parameters return address
return the stack
registers for passing
put those put
creating activation record
addresses are put
smaller activation record
basically my entire
split between registers
bit beyond convention
convention is defined
registers are concerned
parameters through registers
thing has put
put into registers
two array addresses
address b address
space for return
order the entire
upper half upper
half upper part
initialising these locations
move the stack
defined activation records
code of merge
encode this part
part um keeping
begin by accessing
accessing the value
location from top
word within offset
four and register
basically your stack
stack is stack
pointing to top
contents of stack
loading p keeping
keeping in register
pseudo instruction bge
instruction bge branch
branch if greater
greater than equal
prepare the indices
indices for arrays
four and add
done this kind
two steps multiplication
multiplication and addition
bring one word
four then add
add the starting
read from array
back in register
back in array
picture of activation
record in front
picking from activation
out the offset
required with respect
respect to stack
pointer and access
access that value
record for merge
merge was created
inside the procedure
described the entire
calling this function
record of sort
record of merge
achieve that starting
moment and execution
call should result
result in creation
stack and filling
passed the array
address of starting
statement takes care
care of filling
two is starting
starting twenty word
means eighty bytes
array second parameter
twenty plus twenty
forty one forty
forty two forty
forty three forty
leave a gap
gap of forty
forty four words
seventy six bytes
thethird statement requires
statement requires correction
put this address
put the contents
storing the value
read that location
two all right
previous activation records
first we bring
pointer stack pointer
twenty forty words
stack which means
means one sixty
read from offset
sixty from top
minus eight offset
offset from top
brought a value
offset and stored
offset that means
bring the value
sixty four offset
four offset bring
minus four offset
values to create
create the activation
record and stack
pointer is raised
raised by twelve
created activation record
words two words
reach the beginning
saving the return
address at top
care of creating
creating small activation
small activation record
activation record filling
call has occurred
address and put
simple single statement
return from merge
added one activation
record for sort
sort and registers
parameters and temporary
statements before returning
bring the return
first load statement
load statement loads
statement loads return
loads return address
pointer actually shrinks
shrinks the stack
basically the activation
record is disposed
bring the stack
jump register brings
brings the control
back so return
point where sort
calls to sort
record which corresponds
build another activation
showing only part
create a copy
thing okay copy
value is filled
call the parameter
prime b prime
prime n prime
showing the first
statement of sort
save the return
address okay return
sixty eight offset
stack so twenty
twenty forty forty
two and forty
forty two times
store return address
location one sixty
sixty eight deep
first lets pick
offset we load
load the address
minus twelve offset
offset which means
means the top
record which means
means the address
stored in minus
stored at minus
forty sorry eighty
sixty one sixty
four one sixty
two one seventy
immediately one eighty
minus four minus
brought the address
address in stack
brought the value
activation record generation
space for local
total space required
required just push
push the stack
two arrays twenty
total of forty
forty six words
eighty four bytes
create the space
space simply tranfer
return from sort
recover the return
address and dispose
dispose the stack
recovering the return
stack pointer equal
equal to stack
stack pointer minus
minus one eighty
complete this assembly
exercise as part
complete this write
values of small
small m small
lectures you recall
make the code
write a pointer
write same thing
thing in pointers
sort is made
creating a large
large activation record
record of size
size one eighty
equal to twenty
essentially two times
terms of words
times m words
bytes for rest
depth of recursive
chain of calls
calls it grows
return it shrinks
shrinks so depending
upto certain depth
depth and based
maximum use usage
usage of stack
analytically all right
experimentally for analytical
depth of recursion
size of array
describe the maximum
maximum stack size
experimentally by introducing
introducing some additional
address the minimum
empty stack assign
grows the value
allocating an array
passed as parameter
space for output
creating a local
space and reserve
improvement is required
rewrite this function
arrays all right
present algorithm written
written the space
create array everytime
everytime you make
depth of calls
calls the space
space gets multiplied
rewrite first first
usage is proportional
recursive functions entire
functions entire usage
usage of activation
stack and crucial
decisions are deciding
deciding a format
structure of activation
decided the structure
structure the usage
offsets are constants
easily access data
appropriately create space
today computer architecture
understand instruction set
architecture by taking
taking a simple
space which means
main key features
learnt about mips
examples so first
summarize the key
key points key
points key characteristics
characteristics of mips
two terms risc
risc and cisc
cisc which stand
stand for reduced
instruction set computer
computer and complex
complex instruction set
broadly different architectural
examples will elaborate
versus other architecture
things which characterize
characterize a instruction
set of basic
operations or primitive
structure is organized
organized um storage
terms of registers
registers that means
means the registers
registers are general
general purpose registers
registers or special
special purpose registers
memory address space
range of addresses
accessed by bytes
bytes or word
operands three operands
operands less operands
instructions in terms
characterize mips architecture
complete mips architecture
primarily about add
multiply and divide
divide logical operations
operations exist relational
exist relational operation
branch an equal
operation which compares
jump where flow
control is changed
point another instruction
represent the logic
call the procedure
procedure or return
return from procedure
instructions for movement
movement of data
data bringing data
memory to registers
registers or registers
registers to memory
memory or movement
operations which work
work on non
broadly this list
class of instructions
structure is shown
instructions are concerned
register with equal
two which requires
field to access
put any registers
play a specific
exception is register
hardware and register
register number thirty
task of programming
set of convention
address of curent
upto two raised
power thirty minus
four okay sothis
call as address
space that means
fifty six mega
bytes of memory
means that rest
physically have depends
type of configuration
access the operands
operands which participate
results of arithmetic
targets for branch
branch or jump
addressing mode register
mode register addressing
register addressing mode
addressing mode base
base or index
index pc relative
relative pseudo direct
direct and register
operand is put
number of instruction
versions of arithmetic
instructions like add
instructions can work
work with constant
provided as part
case of mips
mips these constants
mode is register
first addressing mode
mode is applicable
operand or destination
source of operand
applicable for source
field and source
lot of instructions
multiply divide slt
divide slt beq
slt beq bne
operand in registers
base addressing involves
involves two things
things a register
values are added
resulting address refers
destination for variety
variety of operation
instruction which make
reference to memory
instructions or logical
instructions always assume
registers or constants
source in case
case of load
load and destination
destination in case
case of store
similar to base
constant another difference
constant in base
base addressing refers
relative addressing refers
constant is hundred
hundred bytes hundred
bytes hundred words
thirty two byte
two byte address
add this constant
constant after multiplication
two subtle differences
refers to data
data in memory
memory this refers
instruction in memory
addressing the meaning
meaning of direct
instruction specifies address
source or destination
call it direct
addressing we call
call it pseudo
bits from program
instruction or jal
bit constant field
thirty bit word
bit word address
two zeros forms
forms a thirty
two bit byte
bit byte address
access an instruction
instruction is accessed
stricly speaking direct
speaking direct address
register indirect addressing
specifies the register
applicable to specific
specification of mode
mode and specification
totally independent manner
manner that means
set of modes
twelve or sixteen
completely orthogonal parts
finally the last
feature we wanted
wanted to focus
provision of sixteen
constant j format
format the largest
instructions actually follow
add it means
means all arithmetic
logical and comparison
important to summarize
firstly all instructions
number of general
purpose registers thirty
doan arithmetic operation
flow okay branch
conditional branch instruction
comparison being made
simpler hardware wise
wise as compared
compared to comparison
equal or greater
done with branch
doing any arbitary
comparison and branching
deliberately each instruction
limited addressing modes
fixed addressing modes
instruction which perform
arithmetic or logic
operation so source
source one source
counter which runs
sequentially through instruction
idea of store
store program computer
firstly in terms
terms of operations
processors which define
define very complex
operation has single
takes a variable
variable in memory
increments it compares
value and branches
memory access arithmetic
branching all happening
happening in single
make a logical
processor which provide
provide such instructions
copying a block
block of data
area in memory
goal of including
including such instructions
compact and shorter
danger the negative
side the flip
make the machine
giga hertz pentium
pentium that means
means the basic
basic time reference
giga hertz periodic
hertz periodic signal
signal and operations
include more complex
instruction in addition
clock cycles required
lectures that performance
performance does depend
factors the rate
sufficient for doing
doing any computation
fortunately that universality
implement any logic
express any computation
decision to include
include a complex
designing an architecture
make it worse
operands of instruction
instruction are located
faster to access
registers as compared
compared to accessing
takes much longer
instructions which work
work with register
register work faster
philosophy behind restricting
restricting arithmetic operations
support rr operations
possibilities do exist
refers to instruction
operand both operands
operands in registers
linked in somwhere
restricting the operands
operands to register
separate out memory
out memory access
access and arithmetic
fact that registers
registers and registers
type of instructions
number of operand
number the machines
machines or architectures
architectures get classified
address two address
address one address
main computing instructions
registers in general
two address machines
typically the result
two getting added
thing becomes implicit
implicit so acc
register called accumulator
acc is assumed
machine where instruction
performed on operand
lying on top
operands are removed
removed the result
stack so instruction
values from stack
stack perform addition
addition um put
prosessor an architecture
classify the machine
arithmetic and logical
basically three address
simply a jump
things two operands
operands being compared
fair amount fair
amount fair number
participating in operation
machine the stack
kind so registerless
registerless which means
means zero registers
registers accumulator based
accumulator based machine
machine which means
large then machines
mips like architectures
fifty six registers
registers um sun
registers are divided
divided into groups
groups each forms
kind of switching
switching is done
additional addressing modes
modes which machines
orthogonality between addressing
modes and opcodes
talked about pseudo
direct addressing mode
mode the entire
size becomes crucial
address is thirty
direct address instruction
instruction the instruction
two okay indirect
specifically called register
indirect that means
machines which support
simply called indirect
indirect and meaning
picking up address
making another access
talked about base
mentioned pc relative
instruction is added
added to contents
value the base
indexing mode interpretation
base and register
array is provided
constant so constant
index into array
array our case
call a base
doesn t work
times you perform
perform a sequential
access to data
order of address
address or decreasing
providing the address
increment or decrement
decrement the address
increment or auto
means that everytime
understood that address
incrementing or decrementing
decrement or post
decrement or pre
increment or post
increment that means
decrementing before making
making a memory
architecture is provide
case of auto
increment and auto
register to make
make memory access
processors which provide
provide a stack
stack based addressing
addressing with auto
increment and decrement
accessing a sequence
bytes or sequence
sequence of textual
textual data characters
accessing half words
accessing full word
access full words
accessing double words
double words lets
floating point numbers
complex in stack
decrement we require
require with stack
four or decrementing
sixty four depending
allocation or deallocation
deallocation we make
provisions for comon
cases are helpful
helpful but complete
difficult at times
concept of risc
cisc risc stands
stands for reduced
computer and cisc
stands for complex
coined in early
eighties by henassi
henassi and patterson
day which existed
argument in favor
favor of risc
uniformity of instruction
instruction in terms
number of formats
formats simple set
operations and addressing
modes and register
register based architecture
choices on hardware
implementation and performance
ideas were propagated
propagated basically targeting
targeting for achieving
achieving high performance
comparitively lower cost
machine called architecture
architecture called risc
risc one risc
berkley by patterson
contemporarily by henassi
architecture called mips
mips was designed
architecture so mips
versions of mips
purpose computing application
hand the basic
ideas of risc
risc architectures developed
architectures developed berkley
developed berkley found
found their place
place in sparc
beginning with eighties
developments new architecture
architectures do continue
intel x eighty
eighty six architecture
historical and commercial
commercial reason describing
describing so lets
mention so sun
sun s sparc
roots in risc
architecture of berkley
risc pa stands
stands for precison
architecture from hewlett
hewlett packard motorola
packard motorola developed
leading cisc machine
cisc machine manufacturer
architectures are risc
back to sixties
four the term
feature we talked
talked of today
high performance machine
architecture is vax
dec which stood
stood for digital
digital equipment coorporation
coorporation so vax
history in terms
popular mini computer
computer called pdp
instructions the instruction
size could vary
byte to fifty
fifty four bytes
extent of non
right and hardware
programming some crucial
system program operating
program operating system
system many critical
entire operating systems
systems are written
written in high
language and considerations
make assembly language
assembly language powerful
powerful and easy
found it difficult
hundreds of instructions
instructions to generate
generate optimal program
optimal program generate
program generate good
generate good code
instructions was difficult
difficult for compiler
hand with simple
instruction set compilers
generate very efficient
talking of small
programs um compilers
compilers can produce
produce machine code
efficient by hand
hand written code
programs of substantial
examples of cisc
series from motorola
starting with sixty
sixty eight thousand
thousand and sixty
sixty eight ten
ten twenty forty
twenty forty sixty
four bit version
version the first
microprocessor four thousand
sixteen bit processors
processors now thirty
features got added
place the architecture
redesigned so carrying
carrying old baggage
makes the architecture
clumsy and hard
hard to understand
understand and discuss
compatibility of code
code that means
possibily still run
run on modern
compatibility has helped
investment in technology
high performing processors
performing processors today
make things run
close by summarizing
instruction set complexity
performance by impact
cycles you require
good design principles
regularity and uniformity
uniformity um smaller
smaller is faster
accessing smaller structure
smaller structure working
working on smaller
compromise and make
exceptions and good
make a common
case more fast
lets say ninety
make that fast
fast as compared
remaining ten percent
percent the efforts
examples we began
began understanding instruction
understanding instruction set
conceptually very simple
directions architectural developments
place to bring
variety of features
mentioned about risc
stacks of architecture
emphasis on simplicity
simplicity and efficient
case the emphasis
emphasis on providing
providing powerful features
architecture and study
study in detail
studied in case
deal with instructions
simple and emphasis
emphasis on uniformity
uniformity of instructions
instructions are expressed
instruction the architecture
instruction performing arithmetic
arithmetic typically takes
takes three operands
two for sources
examples of risc
style of architecture
architecture i mentioned
mentioned are sun
motorola s power
power pc dec
dec s alpha
machine of nineteen
sixties namely cdc
kind of style
details of sun
cisc particularly machines
machines of earlier
earlier times seventies
machine which grew
compact code minimize
minimize the code
size and make
programmer the variation
variation in instruction
series of processors
eighty x eighty
eighty six starting
origin the idea
idea we needed
needed from earlier
earlier sixteen bit
bit eight bit
four bit macro
bit macro processors
vax and intel
starting with power
power pc architecture
company including ibm
including ibm motorola
motorola and apple
apple so motorola
primarily the semiconductor
business of macro
macro processor development
right from early
rival of intel
intel apple started
started with small
small desk top
desk top personal
top personal computers
computers and ibms
based on xcxc
architecture called power
system six thousand
essentially a machine
two bit architecture
versions in late
four bit kind
extensively in machintosh
versions which find
find a wide
variety of applications
lots of similarities
similarities between mips
architecture roughly similar
roughly similar principles
presented some instruction
branch instruction area
register so condition
set or reset
depending upon previous
operations in case
result of instruction
arithmetic is put
put in special
register or flags
comparing one bit
register would carry
carry the information
subtraction is done
done or addition
result was positive
result was odd
register called condition
two other special
addresses are stored
beginning the loop
loop address stored
information to jump
back you don
explicitly the address
register called count
store iteration count
decremented and tested
execution of loop
iterations are driven
count so lets
formats of power
find again lot
lot of similarity
bit register filelds
operations to provide
provide an operand
operand then register
terms of format
format the idea
opcode the main
main opcode field
expanding the number
group of instruction
distinguished by opcode
ten bit field
make an effect
enable condition setting
disable condition setting
requiring to test
change the value
disallow an instruction
instruction to modify
modify the condition
mentioned in context
context of mips
mips that base
addressing and index
two register contents
contents are read
carries the base
carries an index
index all right
bytes or array
array of words
byte or half
word or full
word or double
information about size
addition after adding
adding this index
auto increment auto
increment auto decrement
decrement where address
address gets modified
field actually carries
aspects and makes
two special bits
special bits rest
means a twenty
twenty four bit
four bit constant
unconditional jump instructions
fourteen bit constant
fourteen bit displacement
displacement is absolute
making a link
transfer of control
branch instructions unconditional
setting this bit
address gets saved
values are equal
equal or unequal
chck a condition
condition and make
make a control
control transfer based
contents of link
register and count
register so count
instructions will shorten
shorten the code
instruction in mips
side corresponding instruction
instruction in power
computed by adding
adding two registers
wasting this constant
index index mode
index both added
result is brought
offset also updates
loop in power
branch and count
count to loop
condition being checked
checked is count
lot of conditions
done when counter
taking is sparc
term sparc stands
stands for scalable
scalable processor architecture
scalability here means
architecture would scale
performance also scale
higher word size
size so infact
infact this architecture
scaled to sixty
main one texas
texas instruments toshiba
instruments toshiba fujitsu
toshiba fujitsu cypress
fujitsu cypress tatung
cypress tatung etcetera
two bit opcode
four different patterns
opcode extension fields
bit extension field
fields and size
sizes thirteen bit
thirteen bit twelve
bit twelve bit
cases and thirty
uncnditional jump instruction
addressability all right
right you don
address entire memory
entire memory space
reason why opcode
exceptions are made
made and extensions
extensions are made
displacement of twenty
twenty two bit
bit with reference
limited to thirteen
thirteen bit constant
constant is larger
address arithmetic type
out by sparc
concept of register
sees only thirty
window of thirty
worry a lot
caller what register
share the registers
lot of transfers
transfers to memory
addressed by register
call to aprocedure
aprocedure or function
set of registers
callee can work
linkages some flow
data between caller
caller and callee
callee in terms
terms of parameters
overlapping and overlap
parts um input
input local output
local output global
change the global
out of array
registers the first
state always part
window and local
out are overlapping
context you make
upto eight values
call the window
twenty four registers
registers the globals
current window pointer
pointer or cwp
pointer is pointing
window when return
thing so suppose
set of windows
window the first
saved in memory
saving and restoring
depth of lets
worry about saving
saving or restoring
purposes the depth
windows are fives
efforts in saving
restoring the windows
windows otherwise call
procedure is speeded
developed by dec
dec or digital
coorporation in nineteen
successor of pdp
eleven a mini
successful mini computer
eleven was sixteen
sixteen bit machine
two bit machine
discontinued um dec
started with architecture
architecture called alpha
predominant pc manufacturer
manufacturer system manufacturer
history un vax
concept of virtual
discuss this topic
topic in detail
sixteen general purpose
registers okay unlike
two in mips
mips or sparc
sparc or power
register also stack
condition codes similar
similar to power
orthogonality that means
operands is independent
support all addressing
specific addressing mode
mode all right
instructions whole lot
lot of addressing
lots of instructions
lots of addressing
combinations are valid
hard to remember
mentioned the size
lot one byte
easy the opcode
specifies many things
typically a byte
operations which operation
operands two operands
operands six operands
operands different modes
number of operands
working on integers
integers reals double
reals double precison
double precison bytes
information is packed
data types varying
deal with character
represent a character
character or string
string of decimal
digits one digit
four bits theer
theer are lots
constants eight bit
constants sixteen bit
sixteen bit constants
bit constants thirty
mode that means
means register carries
carries the operand
find the term
modes so deferred
kind of indirection
indirection that means
address and make
operand so register
register mode means
means that register
operand register deferred
register deferred means
deferred means register
carries the address
memory access cycle
cycle so displacement
displacement with respect
respect to registers
relative and register
two different modes
two bit displacement
version that means
address so indexing
indexing with scaling
scaling that means
two four depending
depending upon operand
operand size autoincrement
size autoincrement autodecrement
autodecrement with deferred
variety of data
data transfer variety
variety of operations
things like operations
work on polynomials
directly or operations
insertion in queue
counting the destination
bit long integer
long integer integer
integer here means
bit they call
variety of addressing
thing naturally don
don t make
operation the datatype
datatype and number
number of addresses
byte two specifies
specifies the mode
addresses and register
bits specified mode
base addressing mode
means the constant
two byte carry
carry the constant
reason why instruction
instruction size varies
size varies depending
depending upon modes
modes and number
operands the instruction
modes were registers
instruction would occupy
occupy less number
two additional bytes
constant immediate mode
carry this constant
vary in size
adding two decimal
two decimal numbers
number is represented
string of digits
digits packed digits
packed digits means
pack a digit
destination each requires
two two operand
two operand specification
case the length
confined to thirty
bits or sixty
strings of digits
digits and single
instruction could add
finally lets talk
talk of intel
bit sixteen bit
sixteen bit thirty
starting with sixeen
sixeen bit processor
bit processor eighty
processor eighty eighty
introduced in seventy
amount of compatibility
announced in seventy
essentially sixteen bit
sixteen bit architecture
companion floating point
floating point processor
point processor coprocessor
coprocessor was added
added in nineteen
eighty two eighty
introduced which increase
increase the address
space to twenty
twenty four bits
sixty four kilo
four kilo bytes
increased the space
twenty four byte
four byte twenty
sixteen mega bytes
instructions are added
added with eighty
newer addressing modes
modes were defined
paging in terms
terms of virtual
memory was introduced
eighty forties eighty
pentium pentium pro
pentium pro pentium
adding more instructions
compatibility is maintained
added for higher
higher performance mmx
operations on arrays
core instruction set
set has remained
remained so lets
read some interesting
illustrates the impact
handcuffs of compatibility
compatibility the architecture
sort of constrained
adding new features
difficult to explain
explain and impossible
impossible to love
difficult to make
lacks in style
style is made
size like vax
two address machine
sources also doubles
type of architecture
architecture all right
right you remember
remember i talked
memory so vax
complex addressing modes
modes almost similar
mode or scaled
bit or thirty
bit and index
access in series
series of bytes
bytes or series
series of words
words now difficulty
combination of instruction
instruction in addressing
extremes of mips
lots of exceptions
difficult to remember
remember so lots
lots of special
hard to learn
instruction on condition
complex and irregular
frequently used instructions
difficult to build
build and compilers
compilers have learned
learned to avoid
avoid the portions
portions of architecture
compiler also focus
glimpse of register
registers of eighty
eax and ebx
ebx ecx edx
stands for extension
extension extended extended
extended a register
architectures with registers
stands for high
high l stands
stands for low
thirty bit registers
eax ebx ecx
means take data
work with quarters
ebp esp edi
stands for extended
base pointer stack
referred to operations
work on string
string and destination
indexing individual element
sixteen bit segment
bit segment registers
stands for code
code segment stack
segment stack segment
stack segment data
segment data segment
data so segmentation
brought into earlier
architecture to address
address larger memory
sixteen bit address
bit address register
sixteen bit register
register is limited
limited to sixty
four k bytes
access larger memory
register you set
sixty four register
register sorry sixty
addres another area
move your base
address um sixty
twenty bit twenty
four bit addressing
addressing you imagine
imagine that segment
register is shifted
sixteen bit value
add another address
full fledged twenty
four bit address
flags and program
mention another peculiar
concept of prefix
prefix that means
put a byte
code an instruction
modifies the meaning
upto three prefixes
instruction the kind
kind of modifications
modifications these prefixes
default data size
unlike vax case
size was carried
carried as part
size is set
prefixes can override
default segment register
implementing some special
instruction like semaphore
bus and bus
locked um prefixes
instruction certain number
default address size
modify effective instruction
impression of infact
infact a large
conclude by summarizing
two important features
beginning with power
set of branch
instructions um sparc
register windows vax
modes and strength
modes are orthogonal
orthogonal to opcodes
eighty six intel
discussion on performance
evaluation of processors
definitions may change
follow the definition
individual users perspective
machine which matters
community of architects
architects and users
users could share
share same ideas
interlink three aspects
aspects the number
require to execute
program the number
executing the program
number of seconds
terms of clocks
slightly higher level
done in terms
abstract less abstract
define which link
relationship between instructions
instructions and cycles
expressed as cycles
cycles per instructions
instructions okay number
talk of individual
talk of collection
collection of instructions
talking of entire
matter is average
cpi or average
program now remember
program to program
ipc or instructions
instructions per cycle
talk of instructions
talking of basic
two are reciprocal
conversely clock frequency
finally the relationship
takes okay seconds
seconds per instruction
seconds are required
talking of instruction
capture the entire
long a program
program may execute
instructions are done
done so instructions
unit you talk
talk of million
instructions per unit
unit or mips
instructions get executed
executed right reciprocal
number of micro
spending per instruction
talk of mips
talked of peak
instructions so peak
performance is determined
determined by execution
programmer or individual
people have talked
variables truly represent
possibilities are number
cycles to execute
instruction average number
important the execution
talking of number
instructions in program
statistically a program
bytes or kilo
bytes it occupies
talking of dynamic
instructions that number
execute certain number
indicators or performance
looked at last
today so suppose
architecture or isa
isa lets call
ways of implementing
suppose a implementation
ten nano seconds
twenty nano seconds
cpi the rate
instructions that executed
executed or number
instruction on average
two in case
program which machine
implementation is faster
apply the formula
instructions executed multiplied
quantities remain equal
remain equal number
things could vary
vary clock rate
varying um mips
number the rate
done will vary
instruction the number
find relative performance
essentially you product
figures okay ten
instructions where twenty
twenty four nano
four nano seconds
spent per instruction
instructions would vary
shoes of compiler
two alternative sequences
sequences of code
code to translate
level language computation
statement in high
two alternative ways
make a choice
architecture are first
first three classes
classes of instructions
differ in terms
terms of cycles
cycles the number
cases okay class
class a instructions
cycles and class
designer is debating
two code sequences
sequences first sequence
instructions of type
instruction of type
translate same computation
evaluate this choice
sequence the sequence
sequence will require
require a total
faster all right
instructions first sequence
sequence is shorter
information you realize
two fast instruction
quantify the difference
sequence two faster
ten all right
basically all right
counted the number
divide by number
instructions which means
two so cpi
kind of similarity
frequency is ten
ten hundred mega
instructions um similar
compiler one produces
entire program situation
situation is similar
program so compiler
million of type
compiler produces ten
produces ten million
producing more instruction
add these add
add the cycles
cycles are running
running is hundred
hertz so total
total of cycles
total ten million
ten million cycles
cycle takes point
point one nano
seconds all right
nano sorry ten
nano seconds multiplied
ten miliion cycles
ten just check
check my calculations
mips okay seventy
seventy million instructions
basically fifteen million
total time spent
point five times
pose to point
point one seconds
instructions being done
done is twelve
answers are seventy
mips in first
case and eighty
giving you faster
mips more mips
total time spend
two is producing
producing a poor
lower in first
mips is higher
clock fifty mega
seventy five mega
case the cpi
apparently whats happening
longer clock cycle
find the composite
ratio of execution
two and clock
factors two point
two by seventy
longer as compared
thirty one percent
percent more thirty
takes now question
clock rate keeping
keeping that cpi
factor as unknown
unknown and put
rate you require
change the design
change the compiler
examine the combined
faced the question
out the performance
long system works
set of programs
kind of average
average okay depending
area of application
compilations editings run
run some scientific
application so depending
typical work load
benchmarks okay benchmarks
testing the performance
bear in mind
mind that benchmark
set of benchmarks
set of users
users all right
user runs commercial
runs commercial applications
applications and benchmarks
type if user
application then benchmark
benchmark should reflect
reflect that kind
give a false
improvement of false
sense of related
set of features
misrepresent the level
small simple benchmarks
usefulness would vary
defines these benchmarks
defined by users
agreed upon small
benchmarks are easy
nice for discussing
discussing the performance
performance by lets
lets say designers
designers and architects
benchmark is performing
cases of small
benchmarks and cases
cases where computer
vendors would generate
highly optimized code
sense of high
consortium was developed
developed in middle
middle of nineties
stands for system
system performance evaluation
performance evaluation cooperative
number of industries
hands to standardize
standardize this process
process of defining
defining benchmarks declaring
benchmarks declaring performance
declaring performance summarizing
summarizing and tabulating
tabulating the performance
performance and bringing
bringing a common
write small artificial
artificial or synthetic
programs which users
standard implementations define
define some test
spent on small
make a machine
machine work faster
collection of benchmarks
number of programs
harder to pick
out the critical
programs and make
abuse but chances
benchmarks are valuable
indicators of performance
performance of hardware
hardware plus software
software the total
machine a hardware
compiler which generates
generates a code
defined in standard
standard high level
compiler is important
machine but compiler
out a set
set of benchmak
machine all right
comparison of benchmark
two different compilers
version of first
first one improved
number where higher
higher number means
number means higher
means higher performance
obtained by running
running the program
higher the number
pair of bars
bars each pair
takes to compile
compile a program
compiler was compiled
rating you don
circuit optimization program
optimization program spice
orange and dark
loops and give
give a dramatic
dramatic performance improvement
programs get designed
designed a set
involved in integer
computation so spec
int and spec
user who work
work with floating
floating point heavy
point heavy numerical
heavy numerical computation
set of typical
work in symbolic
non numeric computation
computation the set
things like compiler
compiler simulator lisp
simulator lisp interpreter
benchmarks and names
artificial intelligence program
intelligence program plays
plays the game
simulator so simulates
simulates a processor
gcc is gnu
gnu c compiler
program for compression
compression and decompression
decompression of files
lisp interpreter ijpeg
interpreter ijpeg ijpeg
ijpeg is graphics
graphics compression decompresion
compression decompresion perl
written in language
perl it manipulates
strings and prime
prime numbers vortex
database program tomcatv
mesh generation program
shallow water model
mixture of integer
integer and floating
benchmarks from quantum
quantum physics astrophysics
equations solver partial
solver partial differential
partial differential equations
cube solves problems
problems regarding temperature
temperature wind velocity
velocity and pollutant
change the machines
amount of memory
prevalent in ninety
programs different set
programs to evaluate
evaluate in benchmark
content ready machines
meaningful to work
variety of questions
two different versions
question whether doubling
doubling the clock
clock rate doubles
doubles the performance
program of spec
spec int set
set over pentium
pentium and pentium
refers to pentium
pentium this refers
hertz one fifty
doubled from hundred
factor what happened
account the memory
cycles for memory
spent if memory
memory is slow
doubling the processor
doubled the memory
memory io perpherals
benchmarks are run
run on physical
program from end
end to end
end from input
diagram the question
machine with slower
performance again simple
two machines pentium
points the benchmarks
means for floating
floating point performance
notice that pentium
out performing pentium
instructions pentium pro
concerned about speeding
speeding up execution
execution of programs
means by improving
improving the architecture
architecture improving instruction
improving instruction set
instruction set improving
improving the hardware
hardware implementation improving
implementation improving compiler
mind very simple
simple but important
law called amdahls
first lets define
reduced new execution
speedup so simple
ratio of performance
performance of load
speedup only part
big rectangle represents
represents the entire
spend by entire
attention was focussed
designed your architecture
architecture of compiler
mind which effects
remaining part remains
part remains unchanged
out the fraction
enhanced so fraction
fraction subscript enhanced
task is speeded
factor called speedup
speedup subscript enhanced
taking three fourths
program or seventy
seventy five percent
program and speeding
minus this fraction
fraction remains unchanged
enhanced is reduced
two five remains
unchanged and point
speeded up part
mind the part
big this fraction
suppose your attention
affected is divided
runs in hundred
multiplication instruction responsible
responsible for eighty
multiplying and remaining
remaining twenty percent
adding subtracting loading
subtracting loading data
memory taking decision
taking decision branching
multiply or multiplication
multiplication dominant program
improve the speed
speed of multiplication
run four times
four times faster
speedup factor required
required for multiplication
multiplication alone pardon
four times improvement
make it sixteen
principle which underlines
good enough fraction
mentioned earlier fifty
earlier fifty percent
machine and enhance
enhance its floating
floating point capability
capability okay suppose
suppose floating point
floating point instructions
instructions are speeded
floating point enhancement
enhancement is ten
seconds is spent
spent executing floating
executing floating point
half the instructions
instructions are floating
make them run
run five times
seconds are remaining
remaining unchanged remaining
remaining five seconds
seconds are speeded
speedup is ten
benchmark to show
floating point unit
point unit described
show a speedup
runs for hundred
floating point hardware
program in order
order to yield
yield the desired
instructions fifty percent
spent in floating
suppose you wanted
wanted to project
project your floating
floating point improvement
improvement what kind
kind of benchmark
choose a benchmark
runs three times
floating point computation
eighty three percent
improvement which takes
place with technology
assume a processor
processor currently requires
requires ten seconds
seconds to run
performance is improved
improved by fifty
percent every year
mega hertz today
times x mega
factor performance improves
point five raised
years would reduce
spot what assumtions
made what simplifying
memory is memory
effectively assumed memory
memory also improves
indicator which people
past is mflops
mflops or mega
point operations people
talked of mflops
mflops which stand
million floating point
metric again similar
similar to mips
focus is floating
relevant for people
predominantly floating point
point so advantage
easy to understand
measure and project
out the problem
good benchmarks standardized
benchmarks standardized benchmarks
industries for evaluation
evaluation and performance
performance such aspect
measures like mips
mips and mega
flops look easy
easy and simple
mind amdahls law
law while talking
talking of speedup
mesures of performance
focussed on execution
influenced by compiler
compiler technology instruction
technology instruction set
set architecture micro
architecture micro architecture
architecture which means
means how instructions
implemented in hardware
basic circuit technology
technology or fabrication
capture a large
fraction the common
computer architecture prof.anshul
architecture prof.anshul kumar
prof.anshul kumar department
alu design today
topic our discussion
set of architecture
discussing about micro
realized in hardware
done in hardware
hardware will talk
talk of arithmetic
operators um logical
processor called alu
alu arithmetic logic
unit is built
purpose of instruction
instruction and whats
whats the functionality
functionality they achieved
performance is defined
performance and instruction
develop and understanding
understanding micro architecture
architecture and relationship
relationship between instruction
architecture and micro
architecture and idea
idea of performance
case for mips
two bit operands
operands and produces
produces a result
result under control
instruction so depending
execute this unit
unit will perform
perform some operation
perform addition subtraction
addition subtraction multiplication
subtraction multiplication division
lectures the focus
sequence of sub
today starting today
talk about binary
arithmetic and design
design of alu
include um idea
idea of overflow
exceeds the limit
talk of multiplier
multiplier and divider
operation then simple
simple add subtract
techniques to speed
operation of addition
addition or subtraction
non integer operations
integer operations floating
numbers are represented
kind of operations
operations are performed
finally the hardware
out the operations
starting with binary
subtraction are done
circuit is built
built will talk
comparison little bit
bit logical operation
familiar with binary
inside um computer
represented in bits
bit um represents
represents two states
meaning a assign
assign two bit
bit a bit
bit could represent
represent different things
string of bit
represent an integer
represent a fractional
represent a piece
piece of text
symbols in encoded
set of bits
bits um dep
difference ways depending
begin with lets
talk of integers
represented as string
string of bits
essentially from mathematical
talking of binary
two or base
bits can represent
represent a number
represent two raised
range of numbers
numbers or non
non zero numbers
ticks you talk
ranging from minus
correspondent between integer
mathematics and integer
question of overflow
worry about sign
positive and negative
negative numbers number
number of choices
understand the implication
pattern representing numbers
sign and remaining
remaining n minus
typically could represent
represent as sign
typically zero corresponds
corresponds to negative
pattern would corresponds
magnitude can range
two bits gap
gap for magnitude
number ones compliment
number is positive
positive you represent
handling a positive
bits okay turn
side and minus
column here shows
whats called twos
twos compliment representation
positive number coincide
representation of positive
positive number identical
cases but negative
four okay minus
minus three minus
two and minus
essentially this representation
representation um remove
remove this ambiguity
ambiguity each number
range is unbalanced
right um range
unbalanced in sense
bits the range
range in negative
important positive point
positive point positive
point positive feature
easies the arithmetic
operations and makes
makes the hardware
hardware so work
compliment is defined
number like minus
obtained by inverting
shows the range
values in decimal
largest positive number
raised for thirty
thirty one minus
smallest negative number
end and add
magnitude is increasing
largest negative number
minus two raised
numbers are max
max int maximum
int maximum positive
maximum positive integer
positive integer value
value and min
negative integer value
subtraction with binary
presume some familiarity
method you add
paper and pencil
learnt in school
represent only thing
right so lets
positive two adding
adding five subtracting
bits are generated
generated from left
right to left
left because carry
carry a borrow
borrow will flow
number is larger
word can accompanied
bring in negative
adding or subtracting
subtracting positive numbers
representing in twos
twos compliment form
subtracting you continue
integers okay don
sign twos compliment
twos compliment number
compliment number perform
number perform addition
subtract operation ignoring
ignoring the sign
two we expect
basically we adding
subtraction of minus
two should give
give a negative
representation these number
representation of minus
compliment and add
invert all bits
bits and add
negative or positive
thing is happening
case let lets
step by step
borrow you gate
ultimately a borrow
represent you find
examples just listed
listed the point
mentioned earlier question
ignore the fact
fact that design
design the answer
minus x lets
talking about minus
number a negative
number with magnitude
large positive number
positive number minus
number minus positive
minus positive number
unsigned number systems
right um representation
talking four bits
complimenting these bits
subtract binary number
basically each bit
shows the relationship
doing we adding
adding and subtracting
subtracting twos compliment
minus negative number
number are bringing
additional two raised
suppose in fact
carrying an extra
extra two raised
series of number
number some positive
positive some negative
out as super
super flows carry
relating negative numbers
doing subtraction suppose
basically this subtraction
instruction programmable add
require one operand
integer one small
inside a processor
common for add
instruction or add
add immediate instruction
addition is added
capable of adding
two bits number
integers sixteen bit
sixteen bit integers
rerepresented in thirty
bit is repeated
repeated to fill
additional sixteen point
sixteen point addition
addition sixteen places
four bit negative
bit negative number
extension the sign
bit is extended
extended to fill
additional bit spaces
talked about load
bytes from memory
memory and fills
instruction load byte
load half word
word so load
load byte pixel
pixel one byte
byte from memory
memory and places
remaining three byte
position or remaining
byte and load
load byte unsigned
byte unsigned lbu
lbu so lbu
lbu will fill
twenty four bites
bit bit number
thirty one bit
signed bit replicates
replicates and filled
design a performing
addition the method
method is simples
basically we move
move from right
left and perform
perform addition bit
bit that means
means one bit
bit position adding
adding two bits
coming from right
thing for thirty
represents ith bit
bit of sum
sum ci represents
represents the carry
position from right
module which performs
performs one bit
circuit two add
add two thirty
array of thirty
two such units
carries the carry
connect one unit
unit and form
form a change
change okay initial
carry for bit
zooming that bit
bit and bit
twos compliment notation
notation i don
signed number unsigned
number unsigned numbers
design for unsigned
bit adder module
truth table defines
table defines row
row by row
combination of inputs
two column label
sum and carry
two one make
make it equivalent
equivalent of binary
two which means
means the number
number three sum
describes the relationship
relationship between input
captured by boolean
equations a boolean
equation then defined
defined whats circuit
circuit you require
require to implement
sum is concerned
familiar with crado
systematically by drawing
drawing a cardo
map and finding
finding a minimal
sum of product
boolean expressions representing
expressions representing output
gates you connect
number of possibilities
possibilities is large
ways of writing
writing the boolean
representing um depending
representation in terms
two input gates
stages of logic
two two stage
two stage logic
gates a signal
speed different cost
digital hardware design
easy to comprehend
easy to rivet
rivet and comprehend
build an adder
build a subtractor
two positive integers
inverted before making
care of doing
prime or adding
adding ones compliment
put these modules
form a thirteen
thirteen bits subtractor
care by making
making the initial
bit is inverted
carry is initial
carry is made
made one right
circuits for adder
adder and subtractor
multiplex what multiplex
case that choices
choices between taking
multiplexer to choose
subtraction depending depending
control the multiplexer
multiplexer is choosing
choosing this right
right it requires
requires it control
calling binv standing
multiplexer will select
select this input
subtraction so putting
showing that details
boxes is repeated
calling at adder
adder or subtractor
binv this control
bits of number
two arithmetic operations
looked at multiplied
multiplied and divide
move towards logical
mips and instruction
perform logical operation
logical operation bit
bit on thirty
two bit vectors
perform and operation
bit and operation
similarly or operation
numbers will give
circuit is doing
doing for bit
out of thirty
two or gates
addition subtraction anding
subtraction anding oring
put various thing
add in multiplexer
two and depending
adder come subtractor
purpose of subtraction
inverter and multiplexer
module one bit
unit of alu
capable of performing
two possible values
two among addition
doing and operation
subtraction it doesn
cascade of thirty
alu zero alu
initial carry position
position and binv
control also form
form another control
fact strictly speaking
instruction but additional
additional four instruction
instruction which corresponds
add negative constant
effective low subtract
effectively that means
means seven instructions
ori and add
utilize this part
part of circuit
two different types
types of add
add instruction add
add and add
add and aadd
aadd and addu
two separate instructions
separate instructions add
add and addu
reduction of overflow
two very large
adding two large
two large negative
large negative numbers
exist the result
subtracting a large
large negative number
number or vice
subtract large positive
limits were positive
negative numbers differ
differ or signed
signed and unsigned
unsigned numbers differ
working with signed
maximum negative number
number is minus
maximum positive number
working with unsigned
number the range
detection of overflow
numbers are signed
signed or unsigned
process of addition
addition subtraction remains
subtraction remains unchanged
circuit will cater
versions of coarse
addu and subtractu
version of add
add immediate addiu
sufficient to implement
things the register
file the program
instruction from memory
interpreting it storing
storing the result
unit which performs
performs the operation
looked up twos
representation for signed
brings unique representation
simplifies our mechanism
mechanism for performing
operation so circuit
circuit is simpler
notice that addition
hardware had lot
lot of commonality
share the hardware
included that design
simply by putting
putting those gates
gates and multiplex
extend the circuit
instruction like slt
slt or instruction
instruction like beq
beq so beq
beq makes comparison
argument our alu
operation which means
means the comparison
generating a result
discussed on alu
subtraction and logical
extend this design
design to include
comparison um equality
condition which defers
defers from signed
numbers and unsigned
lectures on design
discussed binary arithmetic
arithmetic how numbers
represented in signed
started with alu
compare signed numbers
extend the alu
include these operations
issue of overflow
detection for signed
numbers in addition
operation and subtraction
difference between instructions
suffix which stands
stands for unsigned
unsigned counter parts
manipulates the pattern
inputs each thirty
bits and produces
produces the result
desired which operation
done is desired
number of signals
change of identical
design is shown
inverter and small
care of addition
gate or gate
bits to decide
require another signal
signal one bit
bit to decide
put these blocks
change the carry
two bit alu
address the question
compare two integers
integers one possibility
check the result
perform the subtraction
position to design
design a circuit
directly perform comparison
circuit which produces
directly without resorting
resorting to subtraction
ways of performing
performing a direct
comparison for greater
greater than first
giving a result
result of bits
condition is equivalent
equivalent to comparison
comparison of bits
bit is concerned
possibility other possibility
define um result
two bits interval
lsb to msb
msb least significant
note that correction
bit and updating
updating the result
results of bits
generating the result
minus one thirty
starting from lsb
lsb and propagating
propagating the result
result to msb
reason is clear
bit which met
simple logic yields
yields a result
side to lsb
equal and comparison
additional bit inclusive
inclusive is equal
side to msb
comparing these bits
product or product
sense of logical
thirty one means
anding or conjuncting
individual bit comparisons
sign bit suppose
result of subtraction
strictly positive excluding
extend alu design
include slt instructions
slt instructions slt
instructions slt instructions
compare first operand
operand and set
set the result
subtraction for alu
output the msb
explore but calling
set all bits
extend this multiplexer
multiplexer to include
putting these putting
two alu thirty
input is connected
irrespective of comparison
comparison irrespective result
set these thirty
thirty one bits
result is negative
bits are set
execute slt instruction
slt instruction alu
instructive to perform
select the fourth
performing slt binv
thing does subtraction
control to select
select the last
put some thing
care of beq
output of subtraction
asked the adder
subtractor to perform
gates will check
input which means
means the result
comparison a result
alu is capable
capable of handling
handling this entire
slightly move involved
move involved issue
out is exceeding
exceeding the range
doing unsigned addition
restarting this point
taking a small
small word size
values can range
shows the sum
value will wrapper
shown in red
extreme left end
equal to thirty
overflow in unsigned
corresponds to first
corresponds to correct
corresponds to overflow
overflow the result
subtraction unsigned subtraction
two unsigned numbers
numbers two positive
two positive values
unsigned or positive
zooming that subtraction
out by adding
adding twos compliment
compliment ones compliment
result of subtracting
result of adding
put there twos
numbers these results
positive or unsigned
red region corresponds
subtracting is larger
flip this part
red angle flips
larger and larger
lets cn equal
out of range
slightly more involved
range from minus
two large positive
large positive numbers
move you increase
side beyond minus
overflow condition lets
top red region
sum is negative
adding two positive
two positive numbers
positive numbers positive
positive or non
non negative numbers
adding to negative
last two carries
msb it means
means that number
number is turning
positive number side
number is exceeding
turning the sign
sign to negative
carry is turning
indication of normal
normal negative numbers
subtraction um signed
two is negative
twos compliment value
pattern of numbers
numbers will remain
minus one minus
minus two minus
two three minus
four will remain
range is minus
color has changed
minus four value
four from minus
correct subtracting minus
turn to red
region which continuous
range this region
giving me wrong
flips the rows
case of signed
sign the indication
result is wrong
thing is wrong
change of sign
final bit position
understanding of overflow
overflow in signed
signed case unsigned
case unsigned case
looked at sign
overflow this result
overflow just reversive
simply goes reverse
case of unsigned
counter part add
part add subtract
add immediate mult
mult multiply divide
discussed multiply divide
divide in detail
understanding the meaning
word okay slt
counter part slti
suffix means unsigned
differs from instruction
instruction is concerned
overflow is detected
suffix overflow detection
green column overflow
column overflow detection
detection is run
happen then overflow
overflow the processor
halting the program
printing an error
add or addu
addu or subtract
instructions the result
result would differ
notice that divide
divide actually falls
category that means
difference of overflow
subtract is concerned
compliment of representation
matter of interpretation
numbers and perform
interpret these numbers
numbers as unsigned
correct unsigned sum
correct signed sum
discarding the result
result and taking
taking some special
overflow results identical
case with multiplication
multu the result
multu unsigned multiplication
signed comparison unsigned
comparison unsigned comparison
comparison the result
doing sign interpretation
find that first
comparison differs depending
interpreting this number
number is signed
load byte load
byte load half
load half words
words are concerned
loading a full
part gets filled
instruction is lbu
lbu or lhu
lhu and signed
extension is done
treat the byte
sign will fill
circle where signed
constant is sixteen
bits but operation
performed over thirty
question of filling
remaining sixteen bits
bits in add
add immediate unsigned
cases sign extension
slightly a misnomer
number and extension
constant is sign
cases in slti
slti um sign
interpretation of unsigned
instructions whether overflow
meaning in signed
case and unsigned
done to covert
covert small numbers
numbers into large
kind of operation
manipulate bit pattern
pattern or extracting
extracting bit fields
long bit pattern
operation is shift
shift left logical
shows um shifting
thirty one shifting
shifting at left
means all bits
bits up push
push to left
out and lost
part is shift
shift right logical
shifting the pattern
zeros to write
write so zeros
zeros get filled
interpreting these numbers
numbers as signed
sign could change
bit left shift
shift is multiplied
two three bit
two so shifting
numbers are unsigned
interpreted as division
division by power
two then problem
problem will occur
changing the sign
shift right arithmetic
right um shift
feeling in zeros
vacated or filled
filled by sign
picture shows shifting
replicated to fill
dividing a signed
number a sign
quotient the remainder
case of overflow
number was large
left and remain
suppose eight twenty
shift left multiplying
keeping one keeping
keeping a thirty
allowing other bits
bits to enter
reducing the number
artificial putting zeros
instructions in mips
instruction called sll
sll shift left
logical it takes
takes two registers
two registers destination
registers destination register
register and source
field you remember
talked of add
labeled as shift
field can carry
carry a number
amount of shift
instructions sll sllv
sllv which stands
stands for shift
left logical variable
providing a constant
srl for shift
logical and srlv
right logical variable
variable and shift
kind of hardware
hardware is required
showing a circuit
multiplexer and wire
first two positions
select this set
inputs and passed
out and zeros
zeros are filling
simply a multiplexer
input can select
shift and shift
put um multiple
precisely the first
first one selects
shift two shift
shift this selects
suitably choosing combination
choosing combination suppose
bit nine position
combination will give
give you shifting
showing the details
essentially a multiplexer
multiplexer with probate
mult this box
box is required
required to shift
suitably can shift
thirty one positions
detection in case
case of sign
sign addition subtraction
subtraction or unsigned
unsigned addition subtraction
discussed shift operations
terms of overflow
detection or action
action of overflow
circuit to support
support the instructions
g.sathis kumar computer
kumar computer architecture
discussed the design
alu with respect
respect to addition
addition subtraction comparison
comparison and logical
discussed other operation
operation like shift
slightly more complex
operation namely multiplier
point talk talk
simple design shift
shift and add
build the circuit
ways which defer
interms of cost
cost of hardware
simplicity of hardware
talk about signed
directly um signed
required for signed
begin with multiplication
pencil okay simple
simple multiplication method
translated to binary
binary in fact
vertex and simplify
multiplied with left
left most bit
multiplication is multiplication
straight forward multiplication
represents a partial
means the place
propagately towards left
add first partial
first partial product
add second partial
carrying out addition
addition of initial
initial zero value
positions and adding
means um performing
essentially and operation
equivalent to multiplication
multiplied by bits
circuit for doing
bits um situation
gate actually represents
represents an array
showing a single
single and gate
taking a vector
vector of bits
effectively an array
four and gates
add this point
require um shifters
shifter is doing
right these shifter
select between shift
matter of wiring
effectively shift takes
shift takes place
stage is addition
addition so starting
wiring it means
bits are connected
connected at propagate
input of adder
directly or shift
position or shift
capturing this idea
idea of summing
summing the partial
requires n adder
require n adder
adding one partial
simplify the circuit
keeping a count
repeated n times
done this loop
two separate assignments
two in hardware
adding a multiplied
doubled or shifted
hardware is concerned
updating i doubling
care of taking
simplify the hardware
bit but move
move the bits
detail is limited
care of performing
performing this type
events will happen
concurrently with edge
two n bit
shifted to left
adder of double
double the size
position and last
essentially double digits
digits to accumulate
double the length
end its reach
require another register
experience right shift
iteration we shift
work in conjunction
conjunction with control
firstly takes care
count the process
thirty two times
showing these red
working under control
circuit will pass
essence of circuits
step to step
step basically involves
involves these things
addition conditionally left
conditionally left shift
explicitly its part
changing on right
changing on left
arrange your information
value is positioned
denoting the high
high high end
shifting the part
partial product obtains
position and achieve
register a doesn
doesn t shift
added to left
introduce another step
right and rest
result of summation
summation and shifting
single single step
clarity we assume
assume that first
shift is done
pure um simple
simple right shift
reduced the size
size of adder
addition and shift
bits keep truckling
product can added
entering the right
register is filled
filled with value
possibility of combining
two actually match
two n bits
right most bit
put together performing
shift and rest
single n bit
mult multiplying instruction
takes two operand
two special register
thirty two general
two general purpose
output of multiplication
specific registers high
high and low
instructions for multiplication
multiplication which takes
takes three registers
two for operand
expects um small
move towards sign
sign in magnitude
separately that means
two signed numbers
numbers we find
find them magnitudes
product and determine
determine the sign
sign so sign
numbers are opposite
sign is negative
sign is positive
propagate form twos
form twos compliment
directly multiply sign
multiply sign integers
twos compliment representations
compliment representations made
sign and unsigned
addition subtraction process
process was oblivious
device a method
directly multiply signed
multiply signed numbers
common expressions representing
representing the values
values of positive
number in terms
find some thing
thing which handles
numbers again representation
representation is shown
kind of summation
bit n minus
bit is handled
done is put
put a negative
number is non
number is negative
negative the sign
out the last
term and put
sign it doesn
minus it doesn
positive in non
non negative integer
bit of analyses
basically minus magnitude
prefix with minus
find the magnitude
magnitude by knowing
representations so twos
compliment representation means
equivalent um magnitude
value and subtracted
definition of twos
minus two terms
summation and bring
corresponds to sign
times two raised
difference will correspond
thing is equivalent
rewritten um bringing
minus one back
write this multiplied
expressed in twos
expression which ignores
direct signed multiplication
basically a multiplied
first on negative
term in positive
terms are broken
two is written
effectively have put
put a factor
verified by working
minus two common
combined the term
factor two raised
minus n minus
similarly this term
term will combine
involving bn minus
minus bi weighted
introduced a dummy
dummy b minus
term will remain
unpaired to combine
introduced zero term
reduce the last
write a multiplied
require it requires
requires partial products
minus a means
means basically subtracting
subtracting a right
algorithm so lets
lets compare unsigned
compare unsigned multiplication
unsigned multiplication signed
multiplication signed multiplication
perform no addition
addition of perform
done no addition
addition no subtraction
doing bi minus
require no addition
small change introduce
thing you remember
shown as adder
bits and decides
instruct that circuit
circuit to perform
addition or addition
mentioned as booths
multiplication its motivation
doing some thing
scanning the bit
bit from lsb
run of zeros
write in number
algorithm was devised
devised by booth
attempt was made
made to minimize
minimize the number
number of addition
involving in addition
step not involving
involving the addition
perform one addition
mechanism to speed
speed up things
manner and carry
carry out signed
out signed multiplication
finally lets lets
range of values
multiplication would produced
talking of unsigned
numbers the result
result would vary
largest unsigned value
largest um sum
expressed i illustrated
first n minus
registers to hold
hold the result
largest most negative
two n minus
multiply most negative
first most positive
largest positive value
largest negative value
half the value
bit fully oaky
mult and multu
multu two instructions
lecture i ment
group where overflow
difference in signed
multu will interpret
operand as unsigned
mult will treat
integers and perform
multiplication get results
hand the pseudo
instruction these instructions
write this instruction
bits the result
move from high
move from low
put different register
register can move
gprs the high
part another gpr
instruction which works
multiply with overflow
results and ignoring
ignoring the high
higher n bits
paper pencil method
understood from earlier
earlier of school
multiply the multiplicand
digits by digits
translates to multiplying
multiplying the multiplicand
multiplicand by bits
adding these partial
sort of wrap
adder performs addition
gradually we made
made certain observation
improve the circuits
circuits the first
reduce the requirement
requirement of addition
holding the multiplicand
reduced by sharing
basically um derived
representations for positive
algorithm was booths
discuss how binary
division is carried
circuit to carried
out for processor
discussing various arithmetic
operation and logical
last we discussed
carry out multiplication
designs of multipliers
multipliers will continue
talk of binary
division and design
design of divider
multiplication and division
illustrate division operation
taking two numbers
derive the algorithms
ensure that algorithm
correct and discuss
discuss the circuits
talk of unsigned
multiplication we looked
work on paper
process was captured
captured by circuit
set of refinements
circuit in algorithm
essentially the multiplication
operation was broken
shifting and adding
absolute to add
talked about booths
discussed the range
types of multiplication
multiplication then mips
mips which type
type to produce
produce signed result
result or unsigned
single word output
two one word
integers the output
output is exceeding
exceeding one word
division by taking
taking two small
small four bit
stands for thirteen
naturally this division
set of shift
shift and subtract
multiplier this divider
four bit quotient
four bit divider
bit as part
dropping of zeros
finally we subtract
subtraction is carried
result is subtraction
subtraction not carried
mapping of normal
normal decimal division
require basically comparison
subtract we compare
step we shift
shift the position
divisor um multiplied
multiplied with powers
shifted three bits
record the results
attempt was subtract
value being subtracted
initially is put
repeat this comparison
comparison and subtraction
positioned at propagate
minus one position
shifted the divider
left we comparing
hold we don
quotient is recorded
simply then step
basic unsigned division
unsigned division algorithm
doing is correct
modification and improvements
transformations and implement
form of circuit
doing actually computes
invariant it maintains
invariant and first
reached a value
put i equal
unique this equality
equality a equal
two given values
positive non negative
ensuring the loop
quotient and remainder
remainder and remainder
inductively okay first
start after initialization
initialization this holds
initialization is making
making i equal
put these values
initially we store
right which ensured
put r equal
meet this condition
order to ensure
two four bit
four bits divisor
four bit number
number in general
means the left
left n bits
taking i working
left four bits
general in inductive
mathematical induction assume
iteration this holes
iteration that means
checked action depend
assume this condition
holds this inequality
carried out subtraction
minus i minus
means that atleast
atleast this equality
equality also holds
condition of subtraction
subtraction is ensuring
inequality is ensured
part is ensured
noticing that invariant
subtracted this quantity
subtract this quantity
iteration r lies
invariant both components
components of invariant
assume that invariant
holds before iteration
false that means
setting a bit
condition of omitting
lies in range
case also invariant
suitable hardware implementation
algorithm which added
case of multiplication
directions of shift
position n minus
making d shift
comparison becomes comparison
subtraction becomes subtraction
setting different bits
shifting q left
two and adding
shift um left
left and set
set the last
last bit set
basically same thing
move d right
draw a circuit
circuit which carries
out this operation
addition has replaced
replaced by subtractions
space gets created
subtractor is doing
doing compressed comparison
basically we assuming
indication that result
result is positive
modify the value
captures the straight
straight forward algorithm
carry similar kind
kind of improvements
subtractor is reduced
reduced in size
left and graduality
graduality shifting right
bits are significant
change this situation
situation and make
make d stationary
effect by shifting
keeping r stationary
stationary and shift
interms of algorithm
minus one bit
position is maintained
left n positions
two parts left
right n bits
left one bit
obtain this position
right not writing
bit shifted left
compared and subtraction
shifting r left
simply shifts left
size of register
position get vacated
stuffing the bits
utilize the part
vacated to accumulate
accumulate the bits
straight forward change
omitted a register
doing r equal
effect of shifting
sort of combine
leads to circuit
shifting another register
controls the operations
introduce another form
form of division
introduced the shifting
non restoring approach
subtract and alternative
carry out subtraction
subtraction in anticipation
made a mistake
restore of making
making a correction
make r equal
make any correction
part d equal
change has occurred
introduced an unconditional
two clock cycles
out um addition
steps the subtractor
motivation for doing
postponed this restorations
restoring by adding
subtract d min
doing any restoration
iteration the initial
initial unconditional subtraction
replaced by addition
equivalent to subtracting
subtracting sorry adding
wording an additional
step of restoring
effect by choosing
choosing the initial
initial unconditional step
pending restoration requirement
subtracted where subtraction
negative r value
negative r implies
case we start
showing a separate
recording a bit
completes the iteration
eliminated two steps
care that restoration
postponing your restoration
iterations are left
adding a step
make a final
doing initial addition
make q equal
two q minus
start with initial
subtraction and make
notice is happening
recording of bit
achieved by doing
require a correction
correction is done
examples and works
brought the algorithm
iteration by adding
bring r closer
initially um large
subtract half subtract
dividend was negative
adding a positive
negative by subtracting
subtract or add
opposite sign values
final correction step
step also makes
makes a similar
check it compares
relationship between signs
signs of dividend
dividend divisor quotient
remainder so lets
dividend and divisor
two right columns
right columns show
signs of quotient
quotient would follow
follow similar logic
multiplied two numbers
positive into positive
negative into negative
dividing a positive
quotient you divide
divide a negative
number by negative
number you gat
gat a positive
logic as multiplication
signs are opposite
opposite the quotient
quotient is negative
quotient is positive
remainder always takes
dividend because remainder
out of dividend
reduce the dividend
ensure that remainder
prove that remainder
written several algorithms
kind of proof
quotient would depend
sign of divisor
divisor and dividend
done we started
four bit division
basically compare shift
shift and subtraction
carry out division
develop basic algorithm
algorithm we analyze
derived the circuit
improvements were made
made first improvement
subtractor we reduce
improvisation and reduce
ultimately you work
concept of restoring
initially you carry
carry out anticipatory
out anticipatory subtraction
blindly you subtract
postponed which simplify
simplify each iteration
restoration of final
modify this algorithm
talking of signed
doing addition subtraction
subtraction with twos
long as representation
representation is twos
two signed integers
integers and performed
carry out basic
out basic arithmetic
basic arithmetic operations
manner without worrying
worrying about performance
sequence of lecture
discussed the basic
operation and today
talk of speeding
speeding up addition
out to floating
govern the performance
compute the carry
carry save addition
carry and wait
simple adder circuit
addition using paper
two operands perform
circuit which adds
adds two individual
two individual bits
adders are cascaded
cascaded or change
thirty two units
unit is dependent
two is depend
dependents of carry
account to complete
complete the operation
aspect of carry
edge one end
end from lsb
inputs ith bit
raise to defined
simple combination circuit
realization is shown
form of expression
simple a simpler
define the performance
suppose the input
gate has transistor
transistor which switch
gates are driving
driving some loader
loader some capacitance
dictates that delay
delay we assume
talking of gates
row of peek
peek of seconds
tens of peek
delays of wired
signal change propagate
propagate over wire
significant and comparable
gates are working
assume that wired
delays are significant
account that delay
delay which occurs
number of gates
fitting another gate
gate that feeds
feeds another gate
delay gets accumulated
delay would depend
larger the delays
ideal condition delay
gate is lets
change k gates
factor d independent
inputs the gate
gates this gate
gate is feeding
means that delay
delay is function
function of fan
slightly more delay
two input gate
four input gate
varies it increases
slowly it doesn
doesn t increase
increase but increases
number of inputs
inputs or outputs
making an approximation
gate is effected
effected by number
speed up circuit
circuit is effected
input to output
path the path
level of logic
express circuits boolean
circuits boolean circuits
two level sum
sum of products
alternatively do product
product of sum
parenthesis and deep
ands and ors
form a product
depth of logic
imagine that delay
level of anding
ignoring again inverters
inverters this compliments
smaller as compare
circuit can compute
compute this sum
restructure this gates
delay is reduced
improve your algorithm
doing same computation
delay is rippling
avoid this ripple
write for examples
four directly interms
lets go step
two level expression
left that parenthesis
two are anded
increasing the level
low or number
form and substitute
four billion terms
assumption we made
gate is constant
number of fan
thirty two inputs
thirty two input
input three input
input of gate
things two level
assumption about delay
delay of individual
gate will break
atleast a primary
two a inputs
two b inputs
lot of fan
number of term
playing in determination
determination of carry
bit position digest
generates the carry
carry and condition
coming from input
condition when carry
carry gets generated
carry is coming
propagate to output
generated by stage
earlier in terms
line and substitute
term this term
term we substitute
thirty two stages
reason this out
generated at stage
generated the stage
generation at stage
two which propagates
propagates through stage
carry which propagates
derive these expression
expression by substitution
substitution or reason
directly um based
understand the circuit
block which computes
computes all carry
computing the sums
delay this circuit
first stage delay
gate single level
shown for brevity
write as sum
sums are coming
built larger adders
represents this sum
collapsed three stages
suppressing internal retails
build larger adders
inputs one side
suppose we connect
ripple carry adder
four bit adders
eleven d units
allowed normal ripple
normal ripple carry
carry to operate
operate for sixteen
saving and saving
saving will show
increase the value
number of stages
rippling of carry
extern this block
stages or thirty
increases the cost
gates become wider
delay also starts
letting the carry
equivalent to propagate
propagate and generate
signal at block
level we generate
generate block propagate
small purple box
carries get generated
carry gets propagated
blocks propagate generate
propagate generate signals
signals or group
group propagate generates
propagate generates signals
call this group
generate or block
recall that expression
block propagates carry
generate condition generation
condition generation condition
means that generation
generation takes place
stage two stage
stages and propagate
four in terms
terms of capital
generates a carry
loop ahead manner
stages gi propagating
twelve c sixteen
basically same form
term was exponential
case the growth
growth is linear
two and substitute
substitute its value
term containing carry
substitution it grows
sort of abbreviated
term is essential
things um slow
added more stages
reasonable and feasible
lets move attention
attention to multiplication
number of multipliers
number of adders
adders to add
add the partial
adder so lets
number of orders
perform addition store
redo the addition
interms of speed
multipliers for natural
approaches for multiplication
adding four terms
add two terms
separately two terms
add several term
formed a tree
clause of multipliers
multipliers we focus
focus our attention
adding different terms
question of addition
addition or multiple
showing a multiplier
adds four numbers
multiplication these number
number will happen
four arbitrary values
adder which adds
adds two terms
adds fourth term
term so suppose
suppose we put
put the usual
usual ripple carry
count for propagation
signals to propagate
propagation of carry
equivalent that lets
right this adder
postponed this carry
left we make
leftward carry propagation
last stage carry
require one extra
fed us carries
symmetrical with respect
calling us carry
circuit is concerned
two output adder
reduces three inputs
inputs are interchangeable
stage is taking
move diagonally sums
input gets added
problem is showing
showing as minus
manner that delays
delays are smaller
compare the delays
noticing one extra
accommodate for extra
carries you don
don t throw
lets take paths
talking for small
circuit it doesn
doesn t show
path of length
adder see carry
expensive but faster
put extra logic
logic for carry
adder that means
faster and expensive
stage to make
principle is applied
multiplied b equal
equal to sigma
matter of waiting
term simplify things
simplify things denoting
denoting with pij
added a multiplied
require eight result
right these initial
normal carry ripple
four this delay
length but easier
easier to quantify
propagation some vertical
propagation some horizontal
approximately n right
saving you carry
require same twelve
twelve adder units
form okay takes
takes three inputs
column the sum
sum of indices
term gets added
addition is concerned
true for subtraction
subtraction the key
type of delay
levels if suppose
four bit addition
four another unit
proposal to log
putting a base
incase of multiplier
move from delay
doing carry save
floating point arithmetic
series of lectures
lectures on arithmetic
operation and arithmetic
arithmetic unit design
unit design today
talking of floating
represented as integers
integers you represent
operation on floating
primarily integer arithmetic
talked about logical
numbers what kind
kind of representation
unit for carrying
out the operation
operation so first
four then define
define the concept
concept of overflow
overflow and underflow
underflow in case
case of floating
out will talk
primarily add subtract
divide and talk
issue of accuracy
important in floating
finally i conclude
kind of provisions
processor like mips
familiar different data
encounter in programming
world of mathematics
mathematics we talk
subset of rational
subset of real
subset of complex
word and integers
topic of today
care of situation
large in terms
talk of huge
lets a pluto
pluto and sun
raised for twelve
requirement is limited
large that integer
quantity like mars
mars of electron
raised for minus
twenty eight grams
extend or thing
thing of deperent
deperent different representation
accommodate large range
part so representing
representing fractions means
non integers value
value as rational
number let select
minus two forty
forty seven point
represent um number
left of decimal
decimal and propagate
part of decimal
unlike this representation
corrector to represent
represent that position
position this position
point actually lies
right okay soum
point is fixed
fixed point notation
care of large
extremely large value
extremely small value
work with large
power to represent
represent extremely high
extremely high values
values and negative
represent extremely low
extremely low values
bits or digits
basically um values
represent irrational quantities
length of storage
number is concerned
represent only reasonable
infinite number bits
bits or bytes
representing rational number
deeper and understand
understand the meaning
meaning of binary
equivalent decimal value
representation but lets
multiply this fraction
collecting the integer
part and point
remaining fractional part
fractional part point
integer part point
fractional part repeat
repeat the process
follow same steps
show the repetition
repetition have shown
shown different colors
talking of finite
pair of integers
convenient to work
loss of accuracy
introduce the exponent
base and raise
typically a floating
floating point representation
minus one raised
care of sign
part so faction
fixed point sum
sum that means
assume binary point
talking a binary
mantissa or significant
concept the question
word of memory
parts that means
straight forward requires
lots of operations
lots of options
assume the point
standard has emerged
acceptable and today
four standard ieee
standard ieee stands
stands for institution
institution of electrical
electrical and electronics
publishing the scientific
define various standards
standard defines representation
precision and double
double precision double
precision double precision
number of significant
twenty three bits
mantissa in double
extend the precision
increase the range
makes a big
four bits representation
representation for double
precision so twenty
twenty remaining bits
word together fifty
fifty two bits
single precision case
bits we assume
sitting there invisible
point some thing
decide the range
point all zeros
similarly in double
invisible or implicit
implicit that means
means you assume
twenty three bit
two more precise
last bit twenty
twenty third bit
bit its equivalent
similarly for double
double precision numbers
numbers we accept
accept for twenty
representing the floating
floating point number
value actually falls
divide by suitable
make the propagate
propagate just make
two and adjusted
adjusted by increasing
increasing the exponent
small you multiplied
multiplied by powers
suitably and decrement
decrement the exponent
value always lies
two and make
adjust the exponent
sim single precision
single precision number
notation the sign
represented as twos
minus one twenty
carry a value
exponent two fifty
fifty four corresponds
corresponds to minus
minus one fifty
numbers the bias
range in range
precision is minus
excluding the cases
talked of positive
assume an explicit
decimal to left
bits zero sign
signifies floating point
principle any number
value of exponent
exponent would represents
corresponds to multiple
representation in ieee
non zero positive
compare so test
circuit which test
test a number
number for integer
test for sign
two cases integer
comparison now magnitude
comparison also turns
similar to integer
choice wehave made
terms of significance
significance its natural
compare to floating
point numbers treating
find that exponent
happen in case
case of integer
msb s give
representation so irrespective
irrespective of sign
exponent this comparison
comparison will work
comparison and unsigned
unsigned comparison differ
two floating point
numbers which means
excluding the sign
sign bit rest
rest we compare
magnitudes of integers
integer we talked
talked about overflow
overflow we talked
talked of overflow
large positive integer
large negative integer
exceed the positive
limit or negative
concept of underflow
limit of values
smallest floating point
floating point notation
integer the smallest
two and largest
largest positive power
twenty seven interms
approximately ten raised
terms of familiar
familiar decimal system
ten the smallest
sign is concerned
writing separate range
range of positive
smallest f value
smallest e value
powers of ten
two two raised
extremely large number
bits as twenty
translate to equivalent
equivalent decimal digits
divide this twenty
log of ten
number of digits
digits similarly divide
similarly divide fifty
two by log
thing eight digits
operations on floating
number be minus
bring the exponents
level so suppose
two okay find
exponent is made
change the fraction
prime is obtained
obtained by dividing
specifically two raised
power the difference
dividing by power
man y positions
position two adder
two adder subtract
prime so depending
sum or difference
logic for determining
difficult to work
shift it left
left and adjust
lock diagram indicating
flow of information
floating point adder
subtractor so lets
two register holding
two numbers sign
numbers sign exponent
exponent and significant
part the first
done is compare
compare the exponent
operands it computes
computes the difference
exponent get aligned
perform right shift
selected is determined
control unit control
unit control unit
unit is guided
out so knowing
two is greater
big alu adds
adds or subtracts
significants or mantissas
stage where exponent
circuit is compared
exponent is brought
stage where addition
stage where normalization
normalization takes place
place so normalization
normalization would involve
ignore this multiplexer
moment this output
two exponents selected
selected and passed
out for increment
rounding so rounding
throwing some thing
make an adjustment
adjust the mantissa
round of normalization
back and multiplexer
original value coming
coming from top
finally the result
hardware for add
consecutively multiply operation
result is exclusive
exponent gets summed
normalization and rounding
rounding the reason
two the product
require one smaller
two you divided
increment the exponent
exponent terms divide
divide is similar
similar two numbers
numbers same thing
thing um sign
sign is determined
fractions get divided
divided the exponents
exponents get subtracted
ration of fractions
fractions could lie
question of accuracy
accuracy and issue
issue of rounding
doing an operations
shifting the number
multiplying two fractions
bit or lets
two twenty twenty
four bits including
including the invisible
invisible one bit
four bit exponents
exponents sorry twenty
twenty two twenty
four bits fractions
multiplying the result
forty eight bits
bits in general
throw remaining bits
bits and retain
loss of precision
working with finite
finite word length
minimize the loss
bits for intermediate
finally do round
round off based
stands for guard
two more bits
calculation we retain
tells the distinguishes
zeros and case
atleast a single
relative sense lets
sense lets imagine
relative level lets
level lets assume
weightage of point
lsb now lsb
means the bit
corresponds to point
dead at point
numbers are equal
bit this bit
bit being considered
considered as lsb
leave the number
odd you add
meaning of round
gains may accumulate
party on loss
rounding up takes
takes place half
rounding down takes
place other half
codes for exponents
exponents or reserved
reserved for special
double precision number
last one represents
object what kind
kind of number
high the highest
value two fifty
sign the sign
point you lets
lets say reach
reach a situation
result is coming
program would understand
method for doing
represents a denormalized
requirement of normalization
situation that exponent
fifty four mantissa
non zero value
situation which lead
lead to number
choosing some code
programs specific meaning
give a summary
processor to handle
handle floating point
number so first
thirty two floating
floating point registers
point registers labeled
labeled as dollar
dollar f thirty
thirty two register
floating point activity
processor whose special
task to work
usual operations add
operations add subtract
multiply divide absolute
divide absolute value
absolute value negate
work on single
single precision data
data or multi
multi precision double
double precision data
dot d stands
stands for single
single precision addition
addition or double
double precision addition
integer mips addition
addition this requires
requires three floating
working with double
double precision arithmetic
form one pair
form another pair
processor and floating
processor is considered
instructions would load
unit that means
part sixteen bit
bit constant part
memory address store
address store instruction
instruction is similar
stands for true
determine the condition
instructions to set
set the condition
condition so imagine
comparison was brought
comparison is brought
test for truth
truth and test
test for false
mead single precision
precision or double
instructions for single
instructions for conversion
representation integer single
integer single precision
number three point
representation in single
precision some representation
representation double precision
two bit pattern
four bit pattern
conversions or conversion
conversion to integer
out the integer
convert to floating
point three point
precision to lower
lose some information
talked about range
range of value
definition of overflow
underflow we learnt
perform various operations
operations we talked
talked about accuracy
bits for rounding
looked at notations
instructions mips processor
last few lectures
focused on design
processor namely alu
alu or arithmetic
add more pieces
pieces of hardware
hardware to make
complete so first
blocks including alu
require to build
build the processor
put this building
simplest possible manner
data would flow
design more sophisticated
design this term
term multi cycle
two major parts
major parts data
parts data path
path and control
style of designing
designing the control
control called mac
mac program control
small low level
enhance our design
instructions we talked
talked of thing
thing like overflow
situation so first
enhance the design
design to accommodate
begin with taking
taking a set
instructions from mips
design we talk
simple manageable design
discuss and understand
understand the class
divided into data
types of building
building blocks combinational
combinational and sequential
issue of clock
clock which times
clock frequency puts
design what kind
kind of clock
specific to mips
initially the initial
thing which required
specifically build mips
instructions we learnt
instructions so lets
lets take add
two arithmetic instructions
instructions two logical
two logical instructions
two memory reference
memory reference instructions
reference instructions load
instructions load word
word two control
two control flow
control flow instructions
flow instructions branch
equal and jump
simple comparison slt
comparison and alu
circuits that comp
equality is simpler
simpler as compare
compare to comparison
comparing for equality
separately and check
written um recursive
recursive equation describing
describing the comparison
comparison like equ
test is combined
possibly with branch
design which cater
design by making
making small incremental
cases the change
nature of instruction
add an instructions
diverse from work
structure overall outline
design then adding
adding other things
intend to implement
implement a processor
instruction is located
fetching the instructions
file you read
read the values
values the instructions
instructions then tells
done whether addition
supply the address
calling a instructions
fields some fields
fields specify registers
registers some fields
fields specify operation
instruction we pick
register resist access
access the values
lets say alu
performing the operation
result of alu
load or stored
access data memory
memory a data
data memory accessing
accessing will required
required again address
quantent of register
alu for doing
doing this things
instruction or read
alu we looked
talking of today
today all covered
memory or data
hole one thing
controller so data
path so data
values or operands
working so data
data is stored
calculations get done
alu to perform
subtraction or comparison
controller will instruct
components in data
data path works
works under instruction
controller but controller
kinds of signals
signals which flows
flows from controller
controller to data
path and data
path to controller
controller in deciding
deciding the action
kind of element
element which operate
operate only data
call them combinational
elements so combinational
circuits have output
combinational circuit elements
inputs and respond
delay you remember
memory the remember
remember what happened
output is function
state contains state
represents a summary
past so summary
speaking the output
output of sequential
state encapsulates state
encapsulates state captures
captures the relevant
give some examples
examples all gates
gates are combinational
case we assume
assume zero delay
circuit have output
nand nor exclusive
exclusive or inverter
combinational circuits multiplexer
multiplexer which makes
combinational circuit decoder
circuit decoder decoder
input and identifies
identifies the bit
bit patterns suppose
suppose we talk
four input decoder
input then components
components like adder
adder subtractor comparator
subtractor comparator alu
circuits okay multiplier
multiplier we discuss
discuss various designs
simply a collection
collection of adders
circuits the sequential
bit of memory
signal which occurred
occurred past counters
counters are sequential
sequential circuits registers
registers so registers
registers are extension
essentially flip flops
dimension okay register
files and memories
memories are extension
extension of flip
talk of component
mips instruction set
circuits which work
work with clock
clocked state elements
elements and unclocked
unclocked state elements
occur with clock
playing a special
designated as clock
change in state
edges is assumed
edge is considered
transition alright suppose
convenience of keeping
keeping the rising
edge as active
examples of clocked
clocked and unclocked
simplest um unclocked
two nor gates
two nand gates
gates and cross
electronics we don
unclocked rs latch
stands for reset
reset s stands
cross couple signals
information gets stored
calling one signal
suppose d signal
signal is changing
analyses and convince
clock is high
output will change
holds the last
spend some times
clocked d flip
flop by putting
two d latches
diagram and put
connected to compliment
change it state
holding the last
falling edge triggered
right in fact
call level trigger
level trigger circuits
level of clock
edge trigger circuits
edge triggered circuits
triggered circuits edge
circuits edge triggered
require more hardware
give us nice
suppose a change
path that change
noticed that imagine
circuits from output
reflect a change
observed when clock
edge this case
trigger another change
brings this level
level of convenience
active because clock
clock is active
period of instability
clock period relates
portion or circuit
circuit we suppose
path through combinational
element two resulting
allowed for signals
delays these circuit
hold time requirement
flop may find
close to react
change becomes stable
instant and continuous
value or takes
flops some flip
flop may react
mixed of value
discuss the performance
performance and timings
create a design
design for implementing
instructions and lets
require registers adder
registers adder alu
adder alu multiplexer
alu multiplexer register
multiplexer register file
register file program
file program memory
program memory data
memory data memory
components for bit
manipulation so lets
value program counter
elements so clock
inputs and thirty
thirty two output
two output thirty
two bit input
bit input thirty
two bit output
output will address
change its value
clock edge occurs
adders and alus
alu will perform
perform main arithmetic
adder will perform
expressed in thirty
lots of zeros
simplify the design
constant but lets
lets no worry
put an adder
adding an offset
four for implementing
implementing branch instructions
carrying outer evaluate
outer evaluate branch
means the offset
instructions is added
two bit operand
bit operand produce
told which operation
multi function unit
function unit depending
test for equality
test is done
result of slt
result of beq
build the provision
provision for exception
handling will require
implemented by making
crucial component register
component register file
care of instruction
array of flip
two dimensional array
right a thirty
two by thirty
thirty two array
array of registers
register being thirty
two into thirty
bits of storage
provision for reading
reading two thirty
two bit values
values and writing
writing one thirty
label read data
register which register
addresses for read
read one address
address for write
memory for data
data and instruction
assume two separate
two separate memory
instructions we don
sequential element memories
memories are sequential
show any clock
counter and outcomes
outcomes the instructions
input and data
data output read
output read data
data and write
unlike register file
memory is concerned
instruction which writes
writes into memory
single address input
care of reading
done whether read
done or write
kind of circuit
require to put
complete the picture
require sign instruction
instruction so imagine
imagine the instructions
perform load operation
address calculation requires
requires a sixteen
sixteen bit offset
added to quantent
thirty bit number
require any active
wiring the inputs
inputs and outputs
bits are input
input eight bits
bits are output
upper four bits
word of set
byte of set
four so multiplying
require ant active
ant active element
element any gate
two the output
task of putting
summarize we began
subset of instructions
design the processor
concept of designing
interms of data
thing is divided
circuits are distinguished
distinguished from sequential
circuits how sequential
circuits are classified
classified as clocked
clocked or unclocked
looked at generic
combinational sequential circuits
clock and timing
post by clock
looked at specific
required to build
build mips processor
processor namely register
register multiplexer adder
multiplexer adder alu
adder alu register
memory and data
required to construct
construct the processor
improve the design
simplest possible solution
problem of taking
execute those instructions
build this design
instructions which includes
includes arithmetic logical
comparison add subtract
instructions by instruction
design will include
include other instructions
step so first
include load store
load store instructions
four five instructions
include the jump
jump and branch
put the data
interms of control
interconnect a controller
out to considered
considered for building
building this data
subtract two arithmetic
instructions and slt
result in register
store which access
basically the data
data is transferred
transferred between register
instructions which influence
influence the flow
conditional jump instruction
parts the data
controller the signal
signals and signals
controller i considered
signals so controller
controller um times
instant so status
information which controller
path to decide
instructions add subtract
memory taking program
taking program counter
program counter contents
contents as address
address then depending
file a passed
produce by alu
alu is passed
instructions the format
field is opcode
register five bit
bit third register
address of destination
begins by fetching
counter a register
carry the address
memory okay instruction
change the contents
instantly the instruction
right we assume
infact such memories
read only memories
process you load
load the contents
require a clock
function which transforms
transforms in input
output is fixed
feeds the address
instructions various field
field in instructions
address the register
remember and bits
two bit instructions
address register file
array of register
register with provision
provision of reading
read two registers
write one register
things two reading
writing or provided
inside but register
file will respond
inputs are read
address one read
two and write
two data outputs
data outputs read
outputs read data
input write data
bits so specific
bit number twenty
address bit number
form the fields
fields which defines
address is rad
taking two groups
bits and connecting
connecting into register
respond with data
couple of lecture
subtraction and operation
operation or operation
purpose of slt
inside we understand
understand that design
build a larger
outputs are forming
forming two inputs
produced by alu
file for storage
cycle of flow
data or cycle
talk of control
field and bit
signals to alu
file okay port
two read ports
file so bit
cycle is complete
file this information
assuming that transition
state of register
instruction so lets
lets a complete
complete that part
quantents and connect
connect the result
four one input
counting time interms
interms of clock
current instruction completes
completes by storing
storing its value
value and ready
completes one cycle
cycle that instruction
important thing note
clock cycle remember
talked of cpi
talked a figures
figures of cpi
cpi which add
design where instruction
design is aimed
aimed at doing
doing the instruction
talking of simple
simple possible design
include more instructions
making a small
small incremental changing
mechanism for calculation
calculation of memory
offset sixteen bit
number and contents
defines the register
exchange the data
add more things
add load instruction
instruction so first
bring in data
right unlike instruction
unlike instruction memory
address read port
read port write
port write port
two port memory
perform a read
single port memory
memory two read
single read write
read write port
write port infact
set of wires
wires which connected
send the data
line and bidirectional
bidirectional data line
common address line
single read port
positioned the memory
connect the inputs
produce by performing
require other arithmetic
address for doing
right um input
alu for calculating
directly connect register
connect register file
output to alu
performing address calculation
doing signed extensions
extensions it takes
takes sixteen bits
bits as input
input bit number
labeled things assume
bit output thirty
two bit signals
two bits exceptions
multiplexer to select
select this path
load or store
multiplexer control input
add subtract instruction
two paths conversing
responsibility of controller
controller to control
data gets passed
part takes care
care of inputs
data memory address
memory address input
data from register
arrangements for performing
performing store word
store word instruction
address generation part
mechanism same paths
data from data
memory and put
file at propagate
address so first
instructions the control
load instruction control
give the correct
correct write address
subtract instruction write
instruction write address
part okay bit
twenty for load
decides the write
introduce a multiplexer
make a provision
remove this line
line and put
done and add
slt and load
path is concerned
instruction is chosen
didn t modify
modify this part
part for load
alu for equality
done and alu
alu will produce
produce a bit
inputs for equal
added as word
retain as common
introduce more options
shift this number
number from word
simply wiring things
correct offset coming
discuss the control
moment we assume
wiring of signals
two bits takes
bits takes place
extension and shifting
active component involved
component involved sign
involved sign extension
sign extension means
extension means repeating
bit and shifting
means just rearranging
supplying a constant
diagram the sign
essentially these kind
kind of wiring
jump instruction jump
instruction jump instruction
fields the opcode
retain some bits
require another multiplexer
provide one additional
multiplexer here remove
line and pass
multiplexer is coming
taking this twenty
field okay shifted
number four bits
four okay bit
bits are concatenated
form a jump
counters so program
possibilities either plain
bits and instruction
single three input
apply control signals
multiplexer would require
exercise of identifying
identifying the control
purpose of reference
call this control
multiplexer as rdsd
rdsd or register
register file destination
first five instructions
distinguish whether alu
normal arithmetic logical
arithmetic logical operations
logical operations alu
alu would require
bits to control
recall the design
four input multiplexer
select and output
output or output
output for slt
bits are required
bit to choose
choose between add
standing for operation
view beq instruction
instruction so comparison
recall of based
subtraction and checking
control data memory
data memory requires
memory requires control
control for read
stands for memory
read mw stands
kind of arrangement
arrangement where read
lines are separate
address same location
source pc source
require some circuit
eleven these eleven
twelve inputs infact
complete the task
bits are sufficient
sufficient to distinguish
distinguish between jump
jump branch load
branch load store
group of add
add subtract etcetera
straight away figure
connect the output
show the outputs
outputs and connect
write register file
write and memory
distinguish between load
controller will activate
activate a signal
signal which tells
output to control
passes the upper
branch we don
controller will make
make this output
comparison was true
registers are equal
four will continue
recall the gross
path and controller
shown status signal
strictly speaking controller
simplifies a matter
separately with makes
multiplexer by figuring
left is opcode
operation which alu
kind of control
controller alu control
remember that alu
class of instruction
two bit information
class instruction add
possibility load store
store together grouped
calling it opc
opc which stands
stands for operation
basically this circuit
inputs eight inputs
inputs and producing
producing three outputs
number of input
lines and number
number of output
size of circuit
circuit the complexity
worried about keeping
keeping the numbers
numbers of input
input as low
larger numbers input
combine the results
information it requires
requires about opcode
enumerate what outputs
outputs you require
designed a processor
slt load word
store word beq
put the components
table connect wires
wires and build
group of first
similar in nature
control the alu
store and load
added beq beq
beq and jump
identified the control
controllers which expected
expected to produce
produce this signals
boxes and design
processor design simple
design simple design
design of processor
design the data
slightly different angle
details of control
design so data
doing the computation
computation and control
guides or directories
directories of computation
right action takes
action takes place
instruction gets executed
data path design
instruction or group
merge the results
results or merge
merge the outcome
inputs are required
required to drive
drive various components
path and based
build the specification
pla a programmable
programmable logic array
performance or analyze
analyze the delay
understand those limitation
design lets call
group namely arithmetic
arithmetic logical group
group we augmented
augmented or analyze
analyze the design
design by including
including store instruction
instruction we improved
including the load
added on beq
place j instructions
design the degradability
design this processor
entire instruction set
adding or enhancing
enhancing the design
instructions so first
separately then beq
beq an isolation
part will remain
solutions and put
point even yesterday
doing add subtract
add subtract operation
supply the instruction
register address fields
address fields fetch
fetch two operands
operands from register
isolation here alu
data memory component
address for data
input i don
address is found
found by adding
adding one register
data path portion
portion of data
instruction so notice
case of stored
stored both word
register takes care
care of address
destination of data
coming from memories
omitted data memory
data memory alu
fed to alu
case the condition
calculated by adding
four and note
two although similar
finally for jump
putting the right
form the destination
address we don
register file doesn
require alu doesn
circuitry to wire
wire the bits
forming the address
form the final
lets quickly sight
common each instruction
reconstruct the entire
sheets of paper
naturally the thing
common will fall
fall in place
corrective of majors
two different thing
identify the points
points of conflict
two different things
two different situations
point of conflict
add subtract instructions
subtract instructions send
send one thing
send some thing
adding two operands
two operands coming
back in load
load instruction output
output of data
address the right
fifteen or ins
twenty different fields
instructions are addressing
incase of branch
out of address
finally this point
point where jump
calculating address branch
multiplexers and multiplexer
driven by suitable
suitable control signals
connect the signal
conflict between non
put for branch
provision of passing
four will suffice
suffice for non
lets now remove
remove the conflicting
put a propagate
connection in place
arrive at yesterday
convenient that approach
follow nothing secured
move towards working
identified control points
controlling the multiplexers
controlling read write
read write operation
operation of memory
memory um write
operation of register
design is simplified
signals what input
basically arithmetic logic
arithmetic logic instruction
logic instruction rdst
address by bits
give this control
tells the register
file alu source
taking the bottom
diagram in relation
jump control multiplexer
signal the polarity
call it jump
set of inputs
give at control
input we give
give to opi
separately but lets
table of values
instruction and repeat
repeat this exercise
value of rdst
matter if alu
bottom input memory
input memory write
store instruction memory
instruction memory read
simplify your circuit
load instruction similar
instruction similar exercise
back into register
files so rdst
taking the top
register file brn
brn and jmp
instruction in beq
write from data
file in compare
brought into consideration
brn will control
control pc source
source jmp continues
instruction so jump
instruction again doesn
active so rdst
choosing alu doesn
give as input
multiplexer this control
control by jmp
inputs so doesn
inputs for jump
instruction and lets
lets now put
table for jump
tabulate the instruction
put the opcodes
derive this control
form a kind
kind of compact
compact truth table
table for controller
design a combinational
lets a put
arithmetic logical instruction
instruction this part
part is common
two control boxes
controller which controls
controls the alu
completed that design
first um define
encoding opc opc
instruction one category
category load store
store another category
category for jump
choose some code
code or type
bits as inputs
bits of opc
inputs ten outputs
ten outputs circuit
field in case
instruction and decide
decide three bits
bits input control
type is instruction
field um opcode
column shows individual
shows individual instructions
last column shows
shows the function
field the function
part of address
give to alu
alu control circuit
bits of inputs
inputs two bits
bits of function
function alu suppose
suppose to perform
operation for add
subtract for subtraction
perform subtract operation
operation for jump
enumerated the action
required by alu
position two define
define what control
control input required
required for alu
recollecting the alu
design one bit
bit of alu
control the output
doing a subtraction
form ones compliment
compliment and give
give initial carry
two bits control
operation b invert
invert becomes don
selecting the first
keeping b invert
picture is complete
inputs eight bit
stage of design
design actually finishes
forward almost mechanical
implement that truth
gate or gates
follow other realization
sum on nand
follow um pla
pla based design
basically it stands
stands for programmable
programmable logical array
array okay logic
logic array means
array of gates
ypu can program
describe the pla
restate the basic
plane which corresponds
type of implementation
implementation or sum
plane has set
gates which implement
out the output
set of signals
representing the products
plane actually sums
sums those products
products to form
form the sum
inside the plane
inputs called abc
implement the products
capable of taking
taking every input
input and gate
gate that means
form an arbitrary
means each literal
gate is forming
forming the product
product a bar
bar b bar
form um power
form enough number
number of terms
required sub set
term and sum
input gets connect
similarly which product
gate gates don
wired and gates
gates or wired
wired or gates
gates and real
nand nand organization
concisely lets continue
vertical line represents
represents one product
line is crossing
crossing every input
line which correspond
terms are crossing
connection is formed
outputs in product
place your dots
move this dots
term get formed
term get summed
kind of universal
universal programmable logic
placing this dots
form the required
gates of formed
showing that exact
suppose we leave
details to coarse
coarse on digital
interms of performance
calculate that delay
period so first
build it bottom
register one register
assume the delay
simplify the analysis
delay will assume
offset so lets
lets call lets
call lets denote
delay of alu
alu will denote
delay of multiplexer
multiplexer will assume
make the expression
expression are analysis
analysis little simpler
delay the delays
file tr program
memory ti data
finally the bit
bit mani manipulation
mani manipulation components
gates or logic
fast then wire
delay becomes comparable
comparable or significant
simplicity will ignore
determined the clock
analyze the paths
edge of clock
begins that data
ultimately you write
file or write
information to propagate
difference between register
delay and register
register file delay
collection of registers
registers register delay
talking of single
register like program
file has additional
giving an address
address that address
out output end
delay of memory
memory the bulk
access time register
influencing the clock
moment lets assume
designing we put
memory as part
simplification but lets
build other components
components of processor
delays are comparable
put as non
simplify the problem
put the results
computing the sum
instruction memory register
summed other path
adder to compute
straight away neglect
expression will dominant
period is max
two the reason
concerns since alu
attempt to make
make this alu
alu very fast
fast otherwise thing
logic and stuff
lets say cushion
delay in carry
addition and delay
carry propagate addition
propositional to log
writing both incase
incase of memory
memory and incase
incase of register
file in general
out of proportion
remains another path
picking the offset
comparison being done
put as max
group of expression
expression each row
instructions second line
store third line
line for load
load fourth line
line for beq
line for jump
word lw dominates
dominates the big
expression the first
coming form load
form load word
coming from beq
term each individual
factor each individual
individual t value
sake of arguments
seconds which means
means two hundred
mega hertz clock
things standard moment
slow slowest instruction
instruction is pulling
utilization is poor
put two adders
adders for doing
doing an operation
done so question
adders can alu
thing without loss
loss of performance
answer that question
cycle the answer
multiple clock cycle
instruction which read
constraint of data
memory with single
instruction which requires
cycle or complex
instruction which require
require a moving
moving a block
area would require
require several reads
reads several writes
writes or instruction
instruction which required
required in similar
similar manner multi
manner multi pole
multi pole operation
close with summarizing
approach to arrive
design and approaches
design and merge
conflict by putting
examine the control
identified the value
value of control
control parts specification
specification as truth
tables we looked
finally we analyze
design from performance
approach the slowest
slowest instruction pushed
discussed very simple
form of processor
design called single
lecture we ended
ended by making
making some observation
design these observations
kind of instruction
instruction so today
introduce another type
approach call multi
call multi cycle
overcome this problems
plan and today
start by repeating
repeating those problem
reobserving those problems
related to single
analyzed the delays
improved how clock
improving the resource
utilization the resources
main hardware components
share these components
memories and alu
half will lower
registers and multiplexers
instruction is completed
ends by updating
updating the state
processor in register
running as glow
glow as slowest
full fledge alu
data memory separate
fetch an instruction
today on first
first two issues
analyzed the performance
performance by taking
taking the delays
delays of individual
components some simple
assigned zero delay
hand some significant
significant delay denoted
simples are denoting
denoting the delays
instruction we enumerated
enumerated various paths
paths from storage
element to storage
decide the clock
putting these values
values in numeric
show the delays
involved in fetching
fetching the operands
file then doing
doing the arithmetic
dictate the clock
first three cases
kind of values
dominate and dictate
periods so clock
remember that horizontal
period is fixed
fixed all instructions
instructions are taking
introduce multi cycle
execution of instruction
done in first
lots of choices
equivalent and largest
decides the clock
improvement in performance
earlier okay earlier
taking one clock
taking five clocks
performance or save
reason the adders
jump branch instruction
instruction and doing
approach or instruction
takes four cycle
period is larger
sufficient to accommodate
taking four cycles
case taking longer
longer than single
cycle and beq
bit of saving
saving in jump
add the cycle
cycle per instruction
cpi of individual
instruction a class
calculate every cpi
ion a program
single cycle case
implemented um multiple
multiple cycle design
identify the activity
part that kind
kind of idea
done this action
reserved two clocks
picture the number
number of possibility
straight forward solution
find a suitable
suitable clock period
due to quantization
clock is minimized
identified the major
follow that approach
approach um keeping
back of mind
issue was improving
eliminate two adders
question in general
resources a clock
end of cycle
recall two design
design of multiplier
multiplier we discussed
types of design
cascaded of adders
partial some flew
flew through flows
active and signals
signals are propagating
hand the sequential
store the results
results in register
register and reuse
reuse that adder
store one result
case is free
mind is register
file okay alu
change is required
share this resources
separate clock cycle
lets a merge
merge instruction memory
memory okay replace
route its inputs
means the alu
supplying the address
supply an alternative
rerouted and brought
block so first
address for memory
memory is connected
bringing a conflict
bring all connections
similarly the data
output old output
memory is removed
brought from alu
remove this multiplexer
multiplexer and reorganize
multiplexer is required
alu so first
space for carrying
out an interconnection
thing with thing
eliminate this adder
eliminate that adder
route the interconnection
remove that adder
remove that connection
connection from top
generating jump address
put all values
resource which computed
make that connection
care of removing
removing the first
inputs again brought
operand is coming
output second input
adder is removed
simply get rid
output i make
make some space
main belated difficulty
addition is meant
happen is first
first this value
decision of sending
distinction will show
applied to show
kind of design
resource is stored
introduce a registers
reading two things
things the instruction
reading the data
store the data
small individual registers
place one register
carrying an information
holds the first
made the distinction
alu is doing
doing normal addition
normal addition subtraction
calculated for load
calculate by adding
offset will sit
purpose this register
register will serve
thing which remains
introduce the multiplexers
require fresh multiplexers
enhance the size
size or restructure
restructure the multiplexer
feeding the program
multiplexer three input
input one output
multiplexer which appears
physically just bring
inputs one input
first i switch
switch the output
result one input
alu okay alu
two input multiplexer
shown from register
feeding second input
register the constant
four this offset
instruction for calculating
calculating the address
instruction with signed
extension for branch
two separate values
place a bigger
connect this signals
control value control
value control input
input is required
move over attention
din to register
move that wire
coming from result
two address resources
res where load
load store address
extend this line
top same thing
path for multi
basically more effort
ensure that resources
collapse multiple components
feed different inputs
registers were introduced
introduced to break
interval gets broken
considered for delay
alu to result
sources of delay
components memory register
rearrange this diagram
diagram to make
lots of multiplex
control and multiplexer
require two bits
usual control requirement
requirement for memory
cycle we load
load this register
lets say add
res gets loaded
end of first
instruction and branch
similarly in jump
require two bit
input so total
signals we require
two for memory
memory one bit
bits for alu
simply combinational box
set of cycles
cycles four cycle
cycle five cycle
reason the single
design was considered
design to multi
compared their performance
attends to reduce
reduce the cost
careful that losses
overshadow of gains
eliminated those adders
eliminate one memory
incurred extra cost
extra cost interms
interms of registers
overhead of sharing
calculation and ensure
overshadow the gain
path conceptually simple
conceptually simple interms
interms of key
alu one memory
register and multiplexer
multiplexer which glue
issue of control
shobana computer architecture
architecture by prof
memory hierarchy basic
hierarchy basic idea
component of complete
recent few lecture
focused on increasing
increasing the performance
puts great demand
demand on memory
simple pipeline case
case one instruction
instruction per cycle
instruction to fetch
fetch per cycle
requirement of instruction
requirement of data
transfer for instruction
instruction which access
memory like load
assume that memory
memory is flat
flat that means
simply an array
words you give
write the word
technology if memory
memory is organized
meet the demands
demands of performance
start discussing today
notice a point
variation in cost
cost and speed
speed and sizes
memory hie hierarchy
attempt to put
principle of locality
case of hierarchy
hierarchy or specific
level of hierarchy
hierarchy called cache
simple cache organization
parameter called miss
miss rate varies
today for computer
online computer store
items you note
storage of information
two cache ram
cache ram fdd
technology or media
media for storing
part are arid
part ge generate
typically several mega
fdd or hdd
cache is faster
fast the processor
giga hertz spec
point four giga
four giga hertz
size of memory
memory so size
memory is important
types of memory
configuration is important
rate of clock
processor in terms
fifteen inch monitor
seventeen inch monitor
briefly be notice
solid state semiconductor
state semiconductor memory
moving parts involved
find in floppy
media for optical
differences in terms
stored here information
similarly in optical
memory there region
opaque or transparent
makes a difference
movement is involved
whi which makes
things somewhat slower
comparatively much faster
difference in organization
address it takes
words are organized
faster some information
slower because things
things are organized
organized along tracks
two factors mechanical
factors mechanical movement
movement and sequentiality
make these memories
magnetic or optical
optical memory case
memory case order
order of magnitude
cost of storage
storage per bit
byte are powered
incase of magnetic
magnetic and optical
capacity than fdds
fdds also hdd
hdd is faster
faster than fdd
part of cpu
memories and main
sram is faster
faster than dram
dram s sram
sram in sram
sram the information
information is stored
stored in terms
terms of flip
imagine cross coupled
cross coupled gates
two stable states
writing are sensing
sensing the state
flop or changing
changing the state
happened in dram
dram where information
terms of charge
longer to charge
charge and discharge
speed and cost
offer you larger
capacity and vise
idea of hierarchical
kinds of memory
typically the fastest
fastest memory close
close to cpu
cpu next slow
slow zone farthest
smallest in size
size the cost
cost per bit
largest in size
size and cost
effective um feeling
cost of cost
cost or size
developed over years
years in organizing
organizing hierarchical memories
memories um tend
tend to give
enjoy the capacity
processor would start
considered a hit
high hit rate
small miss rate
focus your attention
thing will work
hit the information
nt same thing
thing will happen
unit of data
processor is accessing
accessing the first
level of memory
fetching an instruct
read a word
information um keeping
keeping the future
requirements in mind
mind so unit
unit of transfer
transfer may differ
locality which means
means that references
references to memory
memory or localized
localized in sense
terms of space
space temporal locality
temporal locality means
spatial locality means
accessing a word
access other word
address features close
form of spatial
locality that means
accessing um neighboring
analytical way suppose
levels we call
levels in terms
level the size
size is increased
increased the unit
unit cost decreases
out one thing
level that means
slower and slower
cost and total
simply are weighted
lot of simplifications
adding the cost
controllers or interfaces
give um broad
overhead which lead
arrayed in general
configuring a system
designing a system
choices you make
composed of individual
levels so tow
spend at level
data at level
sum of access
made that level
sum of tow
tow one tow
expect the hit
ratios or hit
ninety percent chances
chances of finding
level but chances
level maybe ninety
ninety nine point
capacities are larger
information at level
misses before level
hit at level
terminates at level
right the chances
chances of misses
miss at levels
hitting at level
sor sorry level
higher larger value
level so first
minus one right
probability one minus
probability so miss
miss at level
level one miss
level two miss
level i minus
considered the total
cost and effective
basically s values
values and tow
choose s values
affect the miss
combination of cost
bring this cost
generally about hierarchy
hierarchy of memory
two particular hierarchal
memory or first
first few levels
levels of memory
forms a reference
level of cache
cache two levels
levels of cache
main memory virtual
memory virtual memory
virtual memory interface
cache and main
main memory interface
interface so lets
start with cache
cache the idea
cache le lets
first make reference
reference to cache
location you find
reference are made
fortunately that doesn
doesn t happen
bring in temporal
records were consecutive
locations get accessed
accessed some computation
memory main memory
larger size cache
cache of smaller
part you place
cache one simple
direct map cache
out its location
cache of size
thirty two words
words just simple
illustrate the idea
imagine the main
portions or size
first eight words
memory first quarter
memory and locations
locations of cache
four such quadrilles
main memory map
orange locations map
makes the task
task very simple
simple given memory
out which location
job is done
showing this illustration
illustration with thousand
twenty four words
addresses are thirty
two bit addresses
addresses which means
four giga bytes
last two bits
number or byte
word so lets
out the remaining
remaining thirty word
thirty word define
rest per thirty
thirty memory main
main memory words
words which means
address by ten
bits the lower
lower ten bits
carry some identity
address the lower
index and reach
reach one point
two bit tag
picture the remaining
remaining twenty bits
bits will identify
million possible words
words of main
carry a twenty
twenty bit tag
store in thirty
bits of data
restruction we carry
carry additional twenty
additional twenty bits
cache is filled
distinguish an empty
thirty bits address
remain twenty bits
address and match
valid that means
valid but tag
read out write
out write process
talking of interface
interface between cache
transfer one word
transfer more words
four word blocks
blocks that means
rate of point
locality ok locality
locality of space
structure i extend
word of data
data but multiple
words of data
data and rest
mechanism is sim
sim sim similar
field size change
assuming a larger
assuming a twelve
twelve bit index
part will minus
thousand are blocks
cache each block
cache is sixteen
sixteen k words
usual manner index
similarly tag matching
matching the tag
array ok pickup
pickup one row
matching and hand
out four words
block of set
word is missed
worry about miss
block size increases
series of graphs
graphs which show
show miss rate
miss rate depicted
percentage versus block
versus block size
total cache size
notice for obvious
increase the cache
size the miss
top one corresponds
sixteen kb sixty
increasing the cache
rates are lower
size is increasing
capturing more spatial
decrease in miss
rate to increase
pronounced in smaller
cache get replaced
cache is small
number of localities
typically a program
program would behave
accessing some data
large larger block
larger block size
block size means
size means fewer
means fewer blocks
throwing something throwing
number of block
point it doesn
doesn t pay
increase the block
gainfully also depends
caches are large
impact of block
size which doesn
process a miss
miss rate miss
rate miss rate
derive the expressions
impact um cache
key indicator cycles
spends more cycles
cycles in executing
influence by miss
throw some light
transfer now multiple
words between memory
memory and cache
done one approach
approach is shown
word width connecting
width connecting cpu
cpu and cache
cache and cpu
cache and memory
cpu cache connection
transfer a multiple
multiple word block
block between memory
kind of organization
four word wide
memory gets organized
word is thirty
transferring one twenty
make things expensive
necessarily cpu cycle
cycle one cycle
memory as banks
wide memory connected
bank and interleave
interleave the addresses
bank zero address
bank one address
two in bank
bank two address
addresses are interleaved
four word block
block is spread
four memory banks
four will respond
words gets transferred
give the address
narrower but faster
organization of cache
block of main
flexibility of placing
showing a direct
relay on tag
thing is sitting
word and place
found in parallel
memory so cache
supply the tag
direct map caches
fully associated match
associative um cache
doesn t match
miss such memory
memory can turn
match the tags
give a limited
limited fle flexibility
make the set
reduces to direct
hand you make
fully associative memory
memory so set
sets so suppose
two places whi
whi which means
skip the cache
policies and stop
looked at memory
technologies get speed
means same data
data or instruction
locality of addresses
talked of direct
direct mapped cache
simple simplest cache
simplest cache organization
briefly the possibility
possibility of associative
looked at miss
miss rate variation
types of cache
lecture we discuss
discuss the basic
principles of memory
locality of reference
instructions from lower
lower level memory
memory to higher
higher level memory
gain in terms
high level memory
attention on cache
processor and lies
light of cache
accesses in light
light of memory
influence of choosing
choosing different memory
addition time analyze
analyze to spend
alternative which exist
stages read stage
read stage load
stage load stage
typically three levels
closer to cpu
cpu main memory
faster memory closer
memory but giving
giving large capacity
variation in terms
registers with kind
fraction of nanosecond
nanosecond to access
order of lets
lets say point
point one nanosecond
figure which change
change every year
ball path figure
talking of exact
made of sram
cache gets integrate
integrate with processor
cases the value
dynamic ram technology
typically an order
slower as compared
compared to cache
build around hard
hard disc drive
two different kind
kind of timing
disk to reach
reach that point
moving um med
couple of milliseconds
point the transfer
transfer it takes
takes place faster
rate of transfer
ten mega bytes
organizing these levels
mind that kind
kind of order
magnitude of difference
levels of technologies
technologies which exists
map the addresses
instruction which reside
memory address modulo
modulo the cache
implication of doing
maximum fl flexibility
range of locations
set of locations
memory are set
set of address
locations in main
main memory compete
four location cache
flexibility the degree
degree of set
degree of associativity
associativity in set
set associative case
typically you talk
eventually it shows
redrawn the diagrams
diagrams of hardware
access with direct
direct access mechanism
size or larger
size and associative
address will vary
four k words
words cache size
right and main
main memory address
address we assuming
four k word
word which means
sixteen k bytes
talking of sixteen
sixteen k byte
byte cache memory
direct access case
twelve bit field
field will select
select one word
access will require
match the tag
main memory addresses
address this cache
location would differ
terms of tag
hit if tag
call as valid
lot of misses
matter of replacement
words they replace
conditions are met
hit now lets
lets um extend
extend the size
effectively each block
transfer each word
accessible or addressable
capacity of cache
cache would involve
carry a single
capturing some spatial
terms of transfer
set of words
advantages to transfer
blocks of data
work and reap
reap the advantages
case the index
reduces to ten
eighteen bit tags
neighborhood that entire
entire block absent
block is line
talk of cache
line which means
means same thing
thing as block
logically you imagine
set associative organization
diagram some lines
four way set
organization that means
means each block
line here forms
fifty six sets
sets get indexed
two two bits
previous um situations
size have shrunk
block which means
means four words
four four blocks
accessing this entire
done in parallel
reading out tags
out tags matching
match may occur
show a match
shows a match
pickup a word
righ the required
four words coming
round of selection
signals will enable
spending on tags
overheads of increasing
increasing the degree
reduce the miss
associativity is lower
type of graphic
twenty bit tags
accessing one word
byte address memory
send one word
showing there read
operation right operation
alignment again multiple
talking of reading
writing a word
answer your question
memory address divide
effectively three parts
call as tags
part is set
tag gets compared
cache set index
select a set
parts of word
field this selects
selects an addressable
characterize a performance
hierarchy n level
hierarchy in terms
achieve a suitable
combination of effective
cost now lets
case two levels
two is main
two is tow
made an attempt
attempt at cache
cache level failed
made an access
main memory level
level beyond main
miss before level
start from level
simply one minus
express t effective
two by tow
hit or miss
miss the addition
written as average
average memory access
hit plus miss
measure of performance
performance so ins
count into cycle
typically we talk
memory stall cycles
miss you hold
back the cpu
cpu you similar
hazard you introduce
cycles still data
cycle you spend
factor memory stalls
stalls per instruction
miss rate multiplied
multiplied by miss
miss penalty multiplied
multiplied by memory
accesses per instruction
access per instruction
instruction would dep
instruction are executed
made to fetch
fetch that instruction
instruction and load
store are instruction
make another access
find the average
number of memory
instruction so miss
rate and miss
times you make
spend per instruction
misses any question
performance from cache
cache organization point
sort of subsumed
account while counting
counting the cycles
change which reduces
ensure that advantage
reduce miss penalty
penalty or reduce
reduce miss rate
rate or reduce
reduce this product
reduce a product
penalty is dependant
word wide memory
word wide bus
bus other extreme
memory as wide
degree of interleaving
block size suppose
size suppose block
suppose block size
size is sixteen
four way interleaving
larger the width
larger the degree
send the address
required for ram
internal that means
means after address
address um ram
data so lets
assuming that bus
bus also takes
cycle for sending
assume that block
spending fifteen cycles
cycles for access
access one cycle
cycle for transferring
data so total
number of cpu
four factor reduces
access four words
four words transfer
spend only seventeen
banks of memory
bus to send
imagine intermediate situation
intermediate situation suppose
suppose in case
memory and bus
two words wide
words out spend
spend two cycles
cycles in sending
addresses are interlinked
dram in dynamic
dram the storage
cells are organized
two dimensional structure
structure in row
row and columns
part row row
row row address
address and column
give row address
address an entire
row is accessed
pick out things
out things faster
access one word
make faster access
access so first
first word takes
word takes longer
longer but subsequent
faster so reading
reading multiple bit
give even column
repeatedly you give
give on column
randomly read bits
row by giving
giving only column
column address row
address row address
lots of variation
varieties of ways
read that means
means initiate data
data of initiate
initiate data transfer
transfer between memory
cache load means
data gets filled
cache fetch means
initiate a transfer
transfer replacement means
choose which block
reading one variation
making an access
initiate an access
access to main
memory in anticipation
cache um shows
shows a miss
required for cache
sequential or concurrent
cache one approach
fill up entire
block you give
give one word
doing load word
entire word entire
word entire block
two are sequentialized
kind of forwarding
memory to processor
typically one cycle
cycle two cycle
cycle an ideal
read one cycle
typically first level
load different words
words which form
form a block
simple more simple
forwarding the data
data to cpu
advantageous to fill
leave the words
round robin fashion
robin fashion start
back and fill
wrap around fashion
start the transfer
encounter a miss
fetch the data
prefetch which means
prefetching or software
miss and artificial
force a hardware
initiate a prefetch
prefetch by software
super flows work
load the memory
memory memory processor
memory processor bus
bus our question
matter of trade
four way associative
commonly used policy
policy is lru
replaced alternative strategies
simply fifo approach
brought in earliest
kind of heuristics
found in fact
kinds of write
focus our discussion
terms of read
follow two approaches
first lets assume
cases first lets
first lets examine
lets examine write
examine write hit
write hit case
case so write
write hit means
write that block
block is present
write back case
write into cache
write into main
consequence um main
update the main
memory is updated
maintain a bit
clean but moment
moment you write
write you call
call it dirty
trouble in write
write in cache
cache in parallel
write in main
memory um incase
incase of write
miss um write
write back arrangement
arrangement would require
require that first
block from main
serve the miss
allocate and write
allocate that means
means now imagine
cache it doesn
encounter more misses
bring a block
writing in cache
cache because writing
writing into mein
mein main memory
write into buffers
write back policy
policy the buffer
writing one block
writing one word
buffer would allocate
buffer would accommodate
accommodate a couple
couple of words
required to read
data is sitting
buffer it doesn
doesn t reach
reach main memory
buffer gets cleared
data you wanted
wanted to read
read is waiting
buffer and read
complication arise moment
complication or side
effect which arise
writing into main
main memory means
write in memory
attempted to write
last um lets
lets say last
updation of main
terminating the program
reason for transferring
word was modified
maintain one bit
trouble of writing
experience with locality
dirtied many words
word is dirty
maintain the set
set block level
talk of couple
couple of variations
right or separate
cache for instruction
instruction and data
basically split cache
split cache unified
unified cache means
cons of split
split and unified
cache allows specializing
policy may suit
suit instruction cache
cache different set
set of policy
caches in unified
common policy split
policy split cache
cache also noted
two separate caches
separate caches means
simultaneously accessing data
data and instructions
hand a unified
capacity ok suppose
lets say sixteen
make a decision
decision eight byte
byte eight kilo
execution your requirement
point more requirement
entire sixteen kilo
sixteen kilo bytes
data will share
unified cache utilize
utilize a capacity
incase of split
words and instruction
short in data
typically in multi
multi level caches
caches the first
invariably um split
talk of on-chip
cache or off-chip
cache ok cache
advantages of speed
speed so on-chip
fast but small
small off-chip cache
multi level cache
level two level
level three level
position multiple caches
addresses from main
memory to cache
cache we looked
looked at direct
direct mapping associative
mapping associative mapping
set associative mapping
mapping we looked
expression for performance
cycles or total
spend for executing
executing a program
miss penalty depending
dram s serves
serves similar purpose
purpose as interleaving
variety of policies
policies for reading
reading loading fetching
loading fetching replacement
replacement and writing
discussed various aspects
aspects of cache
organization in today
today s lecture
give some illustration
accesses are done
numerical problems pertaining
pertaining to cache
essentially like simulation
change the block
change the associativity
individual access level
miss gets converted
hit or hit
hit gets converted
miss by making
making a change
detailed view detailed
view detailed illustration
illustration is meant
mechanism which works
cache accesses misses
misses and hits
spend little bit
organization in terms
bits you required
required for holding
holding the tags
couple of numerical
cache with sixteen
worrying about bytes
bytes and words
words lets assume
sequence from memory
access a memory
sequence of address
number of accesses
number of hits
encountered and misses
kind of cache
memory the location
cache is fixed
address modulo sixteen
essentially which word
memory is sitting
supposed to sit
cache was empty
record the addresses
record the misses
lost of misses
address is start
misses lets proceed
position eight sits
column but assume
numbers are sitting
happen um address
helped right nineteen
position three fifty
fifty six replaces
fifty six modulo
forty three replaces
replaces the eleven
couple of steps
quickly so twenty
four throws twenty
back again imagine
four and twenty
thirteen are misses
suppose we change
size we increase
size what block
continue with direct
data was brought
cache with block
block size equal
split the cache
form one block
form another block
block level tags
tags are stored
find a miss
memory and filling
block got filled
four was encountered
block get referred
fills another block
replaces this block
four was replaced
replaced by twenty
block as seventeen
block beginning fifty
miss again eleven
remains a hit
number of blocks
blocks is reduced
effect of increasing
increasing the block
hits maybe lost
shown you variation
rate by versus
versus a block
miss rate decreases
increase a block
loosing and miss
rate may increase
follow lru policy
repeated those addresses
effectively each row
form a set
addresses now modulo
set so twenty
short of space
extend the degree
associativity further lets
sixteen block cache
block cache sixteen
cache sixteen word
sixteen word cache
cache is divided
capture same number
kind of situation
scenario is concerned
concerned by increasing
types of misses
compulsory miss compulsory
miss compulsory misses
starting with empty
cache they compel
compulsorily some misses
misses because noting
cache so first
capacity misses capacity
misses capacity misses
cache has limited
limitation are categorized
categorized as capacity
conflict misses conflict
misses conflict miss
specific mapping approach
misses so conflicts
main memory location
examples ok lets
misses are compulsory
lots of compulsory
compulsory misses lets
misses lets find
out which misses
making second reference
reference ok tha
due to conflict
conflict or limited
compulsory miss misses
reduced compulsory misses
kind of miss
bit of problem
call it capacity
miss or conflict
miss and conflict
hard to pinpoint
pinpoint for individual
conflict or capacity
ninety nine hits
compulsory misses point
capacity misses point
define um capacity
fully associative cache
cache which means
misses and capacity
terms of average
average in terms
total gross behavior
attributed to conflict
problem to categorize
categorize a miss
lets um move
issue of sizes
sizes and bits
size certain organization
incur as overheads
overheads for storing
storing the times
suppose the memory
space is address
two and suppose
suppose cache size
memory is byte
cache in bytes
size of block
denote the degree
direct mapping cache
number of sets
two way set
associative the total
half the num
bits you require
require to index
address is divided
divided into tag
part um index
block to access
access a byte
block so number
required to access
required to address
address a byte
block is log
subtract the number
bits and number
byte the remaining
remaining are tag
required to define
define each tag
increases the tag
size will increase
right the total
number of tag
tag bits equal
tag size multiplied
number of tags
tags and number
calculate the overhead
cache in terms
tag the cache
parts cache directory
move to lets
relate various performance
cpi in terms
cycles they depend
rate miss penalty
penalty that means
means additional cycles
additional cycles encountered
cycles encountered additional
encountered additional stall
additional stall cycles
stall cycles encountered
encountered per miss
factor is number
point two right
right um miss
point five percent
percent and block
find the miss
find miss penalty
assume that number
penalty will depend
memory cache interface
wide and multiple
words can flow
suppose it takes
cycle to transfer
transfer either data
data or address
assuming a bus
bus bus cycle
cpu cycle assume
latency is ten
cycle that means
means once address
delay of ten
find out miss
out miss penalty
penalty for case
word is accessed
word you spend
spend one cycle
address ten cycle
memory one cycle
back so total
total twelve cycles
sixteen word block
block this process
total of miss
means this cycle
forty eight cycles
last case suppose
suppose we assume
wide that means
transaction will send
cycle then memory
memory takes ten
takes ten cycles
cpu so total
total of fifteen
repeated four times
block of sixteen
total miss penalty
penalty of sixty
answers for cpi
back to cpi
fraction here miss
substitute the values
values and number
putting the value
two as miss
case um miss
penalty is forty
forty eight cpi
four third case
case miss penalty
penalty is sixty
variation from lets
change the miss
terms of cpi
architectures so suppose
two are direct
set associative cache
two way associative
access the block
misses and data
out of hundred
similarly we make
make hundred access
remaining cases miss
cases miss penalty
details lets lets
instruction make reference
reference to data
makes one reference
reference for fetching
percent of ins
ins instruction make
instruction make data
make data reference
calculate the number
four for data
make data access
multiply by half
two the miss
penalty is ten
ten because block
two d miss
case again similar
factor is reduced
arid over basic
cpi two point
point zero point
stalls cache stalls
case two point
point zero minus
number of cycle
clocks clock cycle
clock cycle clock
cycle clock period
cache the cycle
figure is figure
map caches clock
caches clock period
point four nanoseconds
multiply the cpi
making it associative
miss getting reduced
two level caches
processor in cpi
running at clock
hertz the main
main memory access
two hundred nanoseconds
cache second level
suppose the miss
access time data
cache and suppose
twenty nanoseconds main
nanoseconds main memory
two is twenty
cache is subsumed
nanoseconds to convert
cycles we divided
two or hundred
penalty for making
bus architectural block
architectural block size
result is lets
rate into hundred
made an assumption
suppose we introduce
twenty nanoseconds divided
nanoseconds which means
means ten cycles
cpi plus stalls
due to misses
cycles you incur
cpi five percent
reference per instruction
two level multiplied
multiplied by hundred
first one first
factor has performance
divide um cpi
earlier six point
clarify certain terminology
two percent miss
level cache terminology
cache is put
system is taking
care of ninety
ninety eight percent
two is receiving
receiving some access
receiving some requests
term called solo
solo miss solo
miss solo miss
two level cache
level cache system
system you remove
two solo means
inclusive of data
typically of larger
hold but suppose
suppose it holds
two will turn
miss having put
request and reducing
reducing the penalty
global miss sponsored
suppose hundred request
request are made
two is taking
miss is forty
percent right local
right local miss
requests are coming
property the inclusion
retain some data
structure and replacement
independently the degree
policies like write
write through write
situations could arrive
simulate um cache
situations an idea
attention on individual
hits and misses
factor is affecting
moved on quantify
quantify the storage
cache organization countered
countered the tag
influence the performance
penalty um stall
cycles not miss
miss penalty stall
penalty stall cycle
effect the cpi
due to change
level how things
educational technology services
technology services centre
services centre iit
centre iit delhi
iit delhi computer
delhi computer architecture
computer architecture lecture
memory hierarchy huh
discussed the cache
organization we move
virtual memory huh
compare huh virtual
huh virtual memory
make changes huh
problem of mapping
mapping virtual addresses
addresses to physical
virtual memory organization
organization is huh
start with virtual
addresses and map
structure of page
page tables huh
huh how huh
huh one major
handle is due
memory are shown
cache primary memory
memory or main
back up memory
discussed the interface
turn may update
structures at architecture
view main memory
programmer and cache
memory and huh
sense that programmer
typically be aware
device a magic
memory organization built
size of main
huh done huh
manner huh transparent
user program huh
program or application
totally huh unaware
large memory huh
huh the objective
noticed the main
overcome the size
huh most convenient
programmer it huh
bother about moving
moving the data
instruction between virtual
huh that disk
divide the program
data into portions
portions and huh
huh take huh
care of bringing
bringing the right
memory at right
huh old contents
contents upto brought
automate this process
objective another purpose
purpose virtual memory
memory organization serves
programs to share
share same physical
physical memory huh
personal typing type
processes which huh
huh are serving
serving the purpose
programs or multiple
manner which provide
huh a task
huh it makes
reposition or relocate
relocate a program
in into earlier
state of program
flexibility of huh
putting a program
problem of relocation
relocation you call
recall that huh
language programming huh
instruction in relation
instruction is re-locatable
position your data
shift your program
problem so huh
on one device
device which huh
huh the register
point of program
program plus data
space is allocated
relocate the program
bu but virtual
makes the program
flexible in terms
huh our focus
care of providing
providing large size
virtual memory virtual
simply an illusion
memory so huh
basically a large
large virtual address
virtual address space
memory physically present
present and huh
memory is present
machines are bought
bought with huh
memory five twelve
amounts of memory
processor so huh
total physical space
occupied for financial
imagine a larger
larger virtual space
space where huh
huh programmer huh
huh can place
huh without worrying
physically smaller amount
the virtual address
physical address space
divided into huh
chance of equal
pages so virtual
divided into pages
pages of equal
mapping huh takes
huh takes place
level of page
out of entire
set of virtual
constitute the virtual
memory some pages
huh physical memory
set could change
program ok huh
remember that huh
huh i talked
talked about multiple
multiple processes multiple
processes multiple programs
share some memory
separate virtual space
talked of dividing
spaces into huh
areas of equal
equal size huh
possibility of doing
group of functions
structure or group
group of da
da data structures
call as segment
data is divided
size an an
talk of keeping
keeping some segments
huh the advantage
complete logical entity
executing a function
memory whereas page
taking a program
program and chopping
equal parts huh
huh which makes
makes things convenient
divide into pages
pages equally huh
huh implement huh
implement huh virtual
memory you implement
basically by relying
relying on hard
firstly a non
non volatile medium
cost so we
we we begin
begin by assuming
pages are huh
made to change
change overtime huh
happen the instruction
architecture should support
support a larger
larger disk space
space so huh
bits ok addresses
bits which means
means four gigabyte
gigabyte of space
huh a programmer
gigabytes of virtual
virtual space and
work with smaller
megabytes so huh
huh you takes
rest its huh
huh some hardware
software which huh
huh we huh
basically the opening
opening system software
cache the answer
hierarchy and huh
concerned huh things
things are similar
mind while huh
fact that huh
speeds are huh
talk of speed
difference between cache
memory we notice
huh this figure
large ok so
techniques which worked
fact in mind
memory several orders
nt find things
huh you expect
hold the processor
needful and continue
special software doing
cycles so hardware
memory and serve
serve a miss
afford to switch
context because context
context switch means
means that huh
require huh large
huh large amount
working with virtual
disk the times
switch the context
mille several milliseconds
milliseconds of gap
gap the processor
task it switches
handle by software
conveniently by software
th the terminology
historical reasons things
differently so we
talking of pages
talking of huh
huh we talk
talk of page
miss and huh
efficient terminology difference
huh another implication
huh miss rate
remember the expression
talking of effective
penalty is small
penalty is huh
cycles then point
point one miss
rate will make
penalty is lets
lets say huh
ten to hundreds
thousands then miss
figure at hand
tremendously in terms
huh miss miss
miss miss rate
huh large physical
large physical memory
physical memory size
size as compared
compared to huh
huh small cache
small cache size
context of cache
big the cache
cache is larger
larger the cache
smaller the miss
rate so huh
huh basically depends
large miss rate
rate is lower
terms kilo bytes
kilo bytes main
bytes main memory
terms of megabytes
lower huh miss
organize other things
helps in keeping
keeping the miss
rate as low
larger than huh
huh in cache
increase the miss
two larger block
words four words
words sixteen words
words but huh
generally not larger
large page size
page size huh
capture much larger
data from disk
huh it doesn
doesn t make
spend few milliseconds
milliseconds to reach
transfer substantial amount
amount of data
huh four kilo
bytes to sixteen
thirty-two or sixty-four
sixty-four kilo bytes
mapping in case
case of cache
mapping and set
common is set
associative with degree
fully associative mapping
nt use associative
flexibility in terms
terms of mapping
choice of write
back and write
write through huh
write back write
write through doesn
sense to write
write one word
word into disk
write back choice
choice also reduces
reduces the number
number of misses
point of write
back it caches
back is larger
write a word
word is smaller
word and write
write back approach
memory with write
write back huh
point is huh
huh what replacement
throwing back throwing
huh wrong piece
piece of information
huh the ideal
data for instruction
easy to implement
tagging each block
case each page
bound ok unbounded
practical to huh
huh use huh
restrict huh programs
limited time huh
people doing research
research who huh
put their program
program for execution
execution for days
huh an order
call it number
recently used call
shuffle the order
order as accesses
accesses take place
huh again th
th the problem
huh su suppose
blocks and huh
sophisticate data structures
make one access
memory you huh
nicely so huh
hardware is infact
infact more difficult
huh and doing
worry about doing
approximate policy huh
case of virtual
background lets huh
picture which shows
shows virtual memory
side and physical
pages each page
page of virtual
memory each virtual
virtual page huh
mapped to physical
disk huh infact
infact strictly speaking
mechanism which defines
address huh imagine
showing thirty-two bits
huh page offset
offset and virtual
virtual page number
suppose huh page
huh page size
bytes which means
means a twelve
twelve bit number
bits specifying page
number and twelve
bits specifying address
physical memory present
power thirty huh
thirty huh bytes
huh four gigabytes
gigabyte now physical
memory can physical
physical memory address
divided into page
number and offset
problem now remains
translate virtual page
number into physical
physical page number
mechanism using page
table so page
page table huh
page is located
give you physical
page number right
page number huh
page is present
present in physical
huh the disk
address or pointed
pointed to area
area where disk
huh the location
obtained from huh
huh a register
page table register
process ok huh
in in terms
in in cache
cache we huh
huh we didn
didn t huh
huh in direct
bits and huh
cache where huh
make a check
tag bits huh
access the huh
huh higher level
table to huh
reach the position
directly reached huh
huh the cache
direct memory access
locations are fixed
fixed in terms
associative cache whe
making any comparison
entry per virtual
entry per cache
number of entries
entries in cache
directories is equal
number of huh
blocks in high
huh the number
number of entry
equal to number
number of pages
low level memory
huh this picture
shows the mapping
mapping process huh
huh virtual page
page number taking
taking it taking
table is telling
miss then huh
fault and page
page fault result
result in huh
huh context switch
context switch so
so so first
huh the current
made this request
request is suspended
initiate a request
transfer meanwhile disk
disk is ready
ready several milliseconds
execute thousand thousand
thousand of instruction
instruction so control
control is transferred
waiting for execution
page table stored
understand how big
big that table
typical example suppose
suppose virtual address
thirty-two bits page
bits page size
page table entry
bit and physical
information about memory
protection in context
context of multiple
bytes of information
information per entry
number of page
page table entries
power thirty-two virtual
thirty-two virtual memory
virtual memory size
memory size divided
divided by page
memory and size
obtained by multiplying
million by huh
hundreds and thousands
thousands of processes
decided to huh
allocate same amount
amount of virtual
direct separate memory
main memory huh
huh but main
terms of huh
megabytes few hundreds
hundreds of megabytes
hundreds of huh
huh page table
simply huh leave
leave no space
listed here common
page table size
table size exploit
exploit the sparseness
sparseness that means
huh whole page
techniques like paging
paging the page
huh you give
tens of megabytes
bound and huh
reduce the memory
memory huh virtual
size the page
size also reduces
reduces so allocate
expand or grow
requirement typically huh
huh the programs
programs are organized
organized to grow
area is stand
stand ok huh
huh which grows
grows or shrinks
shrinks as call
wh which grows
shrinks as memory
randomly allocated reallocated
two opposite directions
opposite directions suppose
space huh stack
huh stack grows
grows in stack
direction keep grows
difficult to accomod
two virtual memory
virtual memory segments
two page tables
stack and heap
requirement substantially huh
huh one thing
table because huh
keeping one entry
pages actually present
huh keep track
entries of page
huh have current
huh one possibility
back to cache
cache like approach
associative memory huh
entries would correspond
correspond to number
size is impractical
impractical so alternative
apply suitable hashing
suitable hashing function
hashing function huh
index which takes
directly the huh
huh physical page
inverted page table
table because you
entries huh organized
huh more common
tabl two level
two level page
level page table
table or huh
organize the virtual
space in terms
terms of segments
segments are divided
earlier which correspond
boundaries or function
function in data
structure so lets
segments of equal
huh entire virtual
entire virtual memory
memory is divided
divided into smaller
segment and huh
reducing of space
requirement the segment
huh this organization
page table page
table page table
four page table
table i page
table n minus
smaller page table
form your good
good old single
single monolithic page
monolithic page table
huh the starting
tables is pointed
calling segment table
table so first
first you make
access to segment
table now imagine
imagine that virtual
virtual addresses divided
parts segment number
segment number page
number page number
segment and byte
number you pick
table is lets
page page table
number and index
huh the physical
address or physical
huh by making
two step access
step access huh
reach the required
fault will occur
point and first
bring this page
table into physical
memory then make
access to huh
right so the
the the starting
points two places
encounter page fault
page fault huh
huh when accessing
accessing a page
table itself huh
table but huh
page page fault
huh lastly huh
keeping the page
imagining page table
huh and worrying
place the page
automatically some part
make accesses huh
huh few entries
locate this page
access any memory
table if page
keeping page table
user page table
table in huh
huh system virtual
system virtual space
assigned a virtual
virtual space huh
space huh lets
lets keep user
space and huh
ensure that huh
huh system space
system space table
entire page table
find that part
page table wh
the the address
address of huh
number so huh
huh if lets
lets say page
times this number
huh normally imagine
imagine if page
memory directly read
read the page
entry and proceed
huh this address
physical counter part
huh systems page
systems page table
system page table
access that huh
huh the page
table entry huh
entry huh hoping
memory you make
access there huh
out whether page
ultimately is present
huh two step
two step process
process one first
step is huh
accessing the system
memory then accessing
accessing huh users
huh users page
users page table
access to physical
totally three steps
steps are involved
huh we started
started by virtual
organization and noticed
similarities also noticed
noticed the differences
differences are important
important otherwise things
translate virtual addresses
physical addresses page
addresses page tables
tables are tend
large which poses
poses a problem
techniques to counter
techniques basically exploit
exploit the limited
size the sparse
sparse sparseness locality
ultimately the relevant
part of page
discussed virtual memory
memory as huh
mechanism to give
give an illusion
large huh adjustable
huh adjustable space
performance as good
physical memory today
mechanism in organizing
organizing a virtual
memory which helps
translating virtual addresses
huh we notice
notice that storage
storage of page
large in size
size we looked
introduce another structure
present in hardware
translation lookaside buffer
possibility of huh
huh addressing cache
cache by virtual
huh physical addresses
role of virtual
organization in memory
out the physical
page is absent
page is stored
stored on hard
directly disk track
track and sector
huh in concept
large size we
size we notice
me mega bytes
processes simultaneously active
require a separate
separate page table
entire physical memory
tables so huh
huh we discussed
possibilities and huh
huh multilevel page
multilevel page table
page table structure
simple flat huh
flat huh array
array but you
you you structure
level or larger
tree like structure
helps in reducing
reducing the requirement
table in virtual
problem is huh
entire virtual space
virtual space divided
huh thousand segments
segments each segment
segment containing thousand
page table wi
thousand pages huh
thousand such small
small small tables
tables and depending
existing somewhere huh
table and huh
huh the entry
table will point
points of huh
huh these page
indication valid bit
memory or present
call this division
division as segments
segments and pages
call it huh
work it works
huh the virtual
parts huh higher
higher few bits
bits will diff
diff will decide
decide which segment
huh one field
field you address
address this segment
basically this leads
table you index
diagram where huh
made so starting
huh virtual address
segment field huh
imagine a register
call segment register
huh the required
table ok huh
showing a multiplying
multiplying constant multiplying
constant multiplying factor
factor here huh
suppose each segment
segment table entry
huh the idea
huh starting point
weightage here huh
location of segment
assuming that segment
smaller ok lets
kilo bytes huh
storage to huh
hit this address
relevant page table
add the page
find a page
page number concatenated
complete physical address
access huh instruction
speaking three steps
steps one step
making one access
access second access
mentioned was huh
huh not structuring
structuring into multiple
level but huh
allowing the page
fragmented ok huh
consisting of pages
area some data
data structure huh
huh and huh
pages so huh
mechanism to work
table are present
memory the rest
placing the page
avoid huh cyclic
huh cyclic references
user virtual space
space in system
access to system
huh we made
assumption that huh
address and huh
stands for users
users virtual space
space s stands
point is virtual
usel users virtual
consist of page
page part page
part page number
byte number huh
number huh notice
make a reference
address of user
stands for user
table in system
address plus page
thirty-two bit number
page number part
byte number part
page table base
table base address
find huh pointed
entry in system
assuming that system
system base system
base system page
page number offset
location either tells
huh page number
number ok physical
number that physical
huh users huh
users huh page
access to users
address is huh
huh translated part
two address translation
means one offset
virtual to physical
physical in system
basically that edition
translating this virtual
address using users
access to da
da huh data
it may huh
huh first translation
huh user page
number of user
address and user
table base huh
access here huh
huh with concatenation
concatenation of byte
address this part
translation and huh
forming another address
huh next level
proceed but huh
huh physical space
two mechanism huh
land up huh
huh we lets
small huh miss
rate or page
page fault rate
reduce the effect
simple page table
table structure suppose
suppose the page
require two physical
two physical access
access two access
two memory accesses
memory accesses made
reduce the performance
performance by factor
hit us huh
times the physical
physical memory access
access time huh
paged page table
access second memory
access third memory
memory access assuming
memory access to
make three access
pretty bad huh
huh the solution
special memory huh
huh as part
recent address translation
recently accessed entries
preserved for future
idea of locality
make this successful
huh this buffer
stands for translation
lookaside buffer huh
two column table
column table huh
calling as tag
captured by huh
remembering the virtual
page number physical
number physical page
page number pairs
last few pairs
huh associative memory
valid bit huh
page number field
pick up physical
number and make
process of translation
translation through page
out but huh
dividing the process
huh typically lets
right and huh
reduced the hit
huh time memory
inaudible background noise
suppose you miss
cache in principle
cache so imagine
bringing in bringing
virtual address consisting
thirty-two bit address
address the page
typically twenty bits
size is twelve
bits and remaining
remaining twelve bits
page so first
doing is huh
associative memory comparing
check the valid
bit is huh
bit so huh
huh dirty bit
bit is dirty
bit or clean
operation you remember
remember in cache
track of huh
blocks are replaced
date with respect
respect to huh
table so huh
entry is thrown
thrown page table
shows that huh
hit we read
out this huh
page number stored
stored here concatenate
view of cache
differently into fields
field and index
field and huh
field you access
access the cache
cache right huh
huh direct map
location we match
tag as part
bit is set
level then hit
consequence of huh
finding a success
success or failure
mentioned that huh
diagram first thing
basically a shortcut
page table access
showing two outcomes
outcomes here huh
access you notice
resort to page
access ok lets
find a hit
made to physical
ends at cache
miss here huh
ends here huh
access to cache
straight to memory
effectively this branch
branch is leading
point here huh
service this page
fault so context
switch will occur
occur and huh
levels no physical
access is required
process just done
done one physical
memory access huh
make another physical
two physical memory
access are made
made here huh
made one physical
fault and make
make another memory
tests ok huh
huh together huh
possibilities a hit
right so total
page table ea
possibilities huh question
level and huh
eventually you suppose
suppose you succeed
access cache huh
simply count huh
leading here imagine
imagine huh repetition
huh a tree
assuming that inclusive
property here suppose
assume lets assume
lets assume inclusive
assume inclusive property
property that huh
cache is subset
assumption some huh
out that means
hit at cache
tha that combination
combination gets ruled
out so whi
two combinations huh
combinations huh miss
hit so tho
two are huh
huh huh lets
lets say non-existent
leaves six huh
huh eventually subset
subset of huh
wont be holding
holding an entry
hit the cache
translate huh virtual
address to physical
address that means
cache is concerned
cache is organized
basis of physical
organized as part
huh a cache
memory but huh
huh in principle
straight away access
huh the first
cache miss huh
huh main memory
path is short
hope will occur
access and cache
first time huh
fastest possible approach
approach so the
huh a merit
cost somewhat huh
done so huh
huh the problem
huh aliasing bu
mention that huh
huh to achieve
distinguish huh entries
processes because huh
address space huh
huh or lets
for for process
confusion huh ho
huh a process
taking its virtual
extending another field
field that in
distinguish the entries
context switch occurs
process you start
start with clearing
empty the cache
start a fresh
lose by doing
processes genuinely shared
data and huh
huh part part
spend more bits
huh having done
problem of aliasing
aliasing aliasing means
huh shared object
two different virtual
virtual addresses huh
addresses huh lets
shared data structure
structure in process
process a virtual
lying somewhere process
process b virtual
processes are running
mapped to huh
two different areas
two copies exist
address gets translated
inconsistency one process
process may update
update one copy
read a wrong
eliminate this kind
kind of problem
virtually address cache
physically address cache
virtually indexed cache
cache that means
picture huh cache
huh cache requires
requires two parts
tag so huh
difficult to imagine
index ok you
first need index
out and make
make a comparison
two is dependent
address translation process
translation process in
bits of index
done the translation
translation but suppose
suppose the picture
huh this huh
tag was larger
bits were independent
cache the page
manner that huh
huh the index
case huh index
out from virtual
translation this part
bit the field
access immediately whe
ready for comparison
part is coming
physical address huh
index is coming
virtual address huh
infact it huh
virtual and physical
address but huh
huh this part
huh very huh
huh inexpensive arrangement
bit about huh
memory for expanding
expanding the address
huh in spite
spite of limited
limited physical memory
huh another thing
helping in huh
putting the protection
protection in place
place protection means
processes huh data
huh data area
area or ins
ins instruction area
area also huh
huh user processes
access restricted part
huh is allowed
huh which huh
huh user program
control over page
table gets initialized
initialized by operating
updated automatically huh
automatically huh huh
huh huh as
huh as huh
as huh pages
pages are brought
out huh updation
page table takes
table takes place
place automatically user
automatically user process
protection gets maintained
requires that huh
huh a processor
supports two modes
modes of execution
execution the kernel
mode or supervisor
accesses all permissions
initializing the page
accessible in user
lets say user
program is running
register some status
mode or kernel
huh naturally user
naturally user program
allowed to set
set a reset
running that bit
bit is reset
reset that means
huh its running
running in user
user mode huh
makes a system
system call th
call th th
huh this bit
set that means
transiting from user
program to huh
huh system call
huh the bit
bit will flip
bit and user
change the mode
mode so huh
basis of huh
huh is protection
ultimately actually huh
protection or security
huh deep huh
deep huh multilayered
huh multilayered mechanism
modes and restriction
operating system data
huh the application
programs are huh
huh communication processes
huh we began
huh the techniques
techniques to handle
handle the issue
issue of large
large page table
two level structure
structure and paged
noticed that huh
table huh based
huh based approach
data but huh
introducing these strategies
makes it huh
huh see memory
level three memory
memory accesses means
means your hit
high to improve
cache page table
possibility of accessing
directly by virtual
additional important role
virtual memory mechanism
introduction huh today
input output subsystem
talked about processor
processor and memory
entire system huh
programs are executed
memory is essential
essential in order
order to hold
huh some instruction
operate and huh
huh input output
output is important
important to connect
connect the computer
means of input
output no information
information can enter
huh the memory
essential to make
data you process
process and produce
produce the results
talk about performance
performance considerations huh
talk of peripheral
computer system huh
data gets transformed
understandable by huh
computer in form
form of huh
talk about interfaces
means to connect
connect the input
input output huh
output huh devices
devices or peripherals
peripherals to rest
output is carried
first two aspects
huh is contributed
talk of huh
huh your benefit
benefit of performance
program which takes
takes hundred seconds
consume ninety percent
huh ten percent
means the data
data is brought
brought in results
out and huh
technological innovations huh
huh the speed
speed of processor
improving and huh
fifty percent improvement
improvement every year
seconds which huh
reduced to sixty
sixty forty twenty-seven
forty twenty-seven eighteen
eighteen and twelve
improvement by factor
half time huh
performance remains unchanged
total time huh
hundred next state
seventy next state
ratio of hundred
improvement so huh
huh not improving
performance could bring
expected performance improvements
performance improvements huh
improvements huh so
program is computation
computation bound computation
bound computation bound
computation bound means
means that majority
performing computation arithmetic
computation arithmetic logic
arithmetic logic decision
comparatively much small
bound where process
essentially huh input
huh scientific computation
scientific computation huh
computation huh lets
lets say weather
prediction or nuclear
crunching or huh
huh heavy computation
business data processing
data processing huh
processing huh or
or or database
database oriented application
spent in input
output so huh
lets say ratios
ratios were reversed
ten percent part
huh its important
improvement also huh
perspective your requirement
requirement huh the
throughput oriented measure
measure that means
output gets done
transfer gets done
done per unit
unit time huh
talk of amount
transfer in unit
talk of number
operations per unit
operation may involve
involve some transfer
lets say maximize
transfers take place
action you give
give some command
command and huh
huh it takes
takes to respond
huh reservation system
system for railways
railways or airlines
individual user huh
done as fast
requirements are fed
system to respond
immediately so huh
request are huh
central database huh
perspectives the huh
interested in lets
lets say total
divide the total
execution for computation
data or sending
out the data
super computing application
typically huh scientific
huh scientific application
typically a computation
computation bound application
application but huh
lots of results
results or simulation
measured in kilo
bytes or megabytes
huh transaction processing
huh is important
request for drawing
drawing some money
immediately so response
file server suppose
cluster of computers
department and huh
server would receive
request for creating
creating files opening
files opening files
opening files reading
files reading writing
operation ok so
depending upon huh
describe your huh
huh in terms
huh while talking
discrepancy in terms
terms of units
we we talk
talking of kilo
talk of memory
memory size huh
huh one kilo
kilo byte huh
two four bytes
two is power
similarly one megabyte
megabyte is huh
two four kilo
bytes or huh
two huh tenth
huh tenth power
talking of thousands
thousands and millions
millions in huh
thousand kilo bytes
mind that huh
talking in memory
domain so huh
word of caution
lets huh move
move towards huh
huh peripheral devices
conceive a stored
stored program computed
classical block diagram
block diagram showing
showing five units
control arithmetic memory
arithmetic memory input
control and arithmetic
huh are huh
mentioned here huh
huh these form
form the central
bringing in huh
huh two levels
memory and main
huh the interconnection
point to point
point here -like
the the processor
huh in subsequent
two things involved
devices or peripheral
controllers which huh
devices and rest
care of multiple
devices and controllers
connected so huh
talk of buses
buses and huh
huh other means
means of connection
finally we talk
attention on devices
devices and controller
things ok huh
physically the controller
controller and device
speaking that devices
lets say printer
printer you send
bits and bytes
printed page huh
huh the processor
processor and buses
hand and huh
mechanism so the
wh which takes
care of movement
variety of peripheral
ways so yo
behavior in terms
input that means
means bring information
information into processor
processor in memory
out or play
input device printer
output device huh
communicate or huh
devices make processor
make processor talk
human programmer human
programmer human operator
computer another machine
environment in general
machine nor huh
huh a human
huh some kind
kind of internal
store information disk
huh human huh
human huh operators
operators ok huh
huh network controller
controller will connect
connect one machine
machine huh environment
huh environment huh
temperature or huh
turn a motor
motor huh storage
huh a disk
characterized in terms
kind of data
speed some devices
devices very slow
megabytes getting huh
huh the device
device is capable
capable of transferring
transferring so huh
huh that capability
ca ca capacity
capacity gets utilized
nt huh disk
ready to transfer
data gets transferred
chunk one quantum
data which means
information goes bit
bit ok as
bits sixteen bits
huh one group
kind of encoding
encoding and huh
huh whole variety
current situation huh
set of peripheral
years ago so
picture of huh
huh paint huh
huh when huh
exposed to computer
devices only peripheral
device at hand
paper tape reader
reader and paper
paper tape punch
tape punch huh
punch huh huh
huh the paper
strip of paper
paper with holes
group of holes
form one character
device called huh
huh a typewriter
typewriter like device
end so as
run a punch
sheet of paper
paper so huh
computer is concerned
directly connected peripherals
peripherals are paper
punch so eve
eve everything huh
form of paper
tape the outputting
system the compiler
punched on paper
tape and huh
larger room huh
typewriter like devices
prepare a programs
you you print
couple of years
additional device introduced
tape where program
stored for repeated
ten twenty character
printer so li
li line printer
line printer huh
hundred lines huh
huh per minute
print one line
life little easier
subsequently huh tape
tape got replaced
replaced by punched
system also moved
cards each card
one one statement
put back huh
huh new cards
change a card
editing in paper
paper tape environment
tape environment huh
huh was huh
cut the tape
tape and patch
surprising that people
huh some people
tape and read
punched holes huh
holes huh disk
huh disk drive
disk drive was
was again added
faster then huh
tape the tape
sequential but huh
track completely tape
huh twenty megabytes
memory was huh
huh thirty-two kilo
thirty-two kilo bytes
bytes or sixty-four
bytes that order
variety of peripherals
peripherals and huh
huh with huh
kind of classification
earlier so lets
introduction with human
beings ok human
programmer or operator
putting here huh
rate or throughput
throughput rate huh
huh these peripherals
peripherals are dealing
design a complete
huh a feel
things so huh
devices like keyboard
keyboard and mouse
limited by huh
type so it
fraction of kilo
is the rate
faster than huh
input and voice
huh the trend
developing these type
type of capabilities
capabilities voice input
voice input voice
input voice output
voice output huh
output huh pictorial
huh pictorial input
pictorial input pictorial
input pictorial output
pictorial output huh
output huh wh
huh wh wh
natural to human
talk to computer
issue of peripheral
recognition of huh
spoken or generating
generating speech outputs
speech outputs huh
voice input huh
input huh voice
digitized and huh
sequence of samples
textbook are huh
huh twenty bytes
rate of information
typically the speech
speech huh inputs
inputs are sampled
kilo ten sample
sample is huh
ten kilo bytes
huh a plain
range of forty
forty fifty huh
fifty huh thousand
huh thousand samples
device is scanner
basically scan huh
scan huh text
text or image
paper and huh
rates so huh
th the resolution
accuracy here measured
measured in terms
terms of dots
dots per inch
huh six hundred
th that means
finely the information
value is lower
finer shaper picture
variety of output
output devices line
devices line printers
line printers laser
printers laser printers
laser printers huh
printers huh graphic
huh graphic display
notice graphic display
highly demanding huh
demanding huh peripheral
shown as sixty
sixty thousand kilo
screen suppose huh
huh roughly speaking
thousand by thousand
accurately thousand twenty-four
approximate calculation suppose
settings so huh
byte to represent
represent one pixel
means three bytes
bytes per pixel
million pixel means
pixel means huh
present on screen
persistent display huh
rate of repetition
twenty-five huh frame
huh peripheral device
variety of huh
devices which connect
connect a computer
network of computers
kinds of modems
fax modem huh
modem huh cable
huh cable modem
cable modem cable
modem cable modem
cable modem connects
connects to huh
cable ok fax
fax modem connects
modem also connects
telephone line huh
capable of carrying
carrying digital information
digital information huh
huh lan adapters
lan adapters local
adapters local area
local area network
area network adapters
network adapters wired
wired or wireless
data rates huh
huh for lans
lans are higher
higher huh depending
huh ten megabytes
lan or hundred
lan so typi
translated into bytes
reducing one order
variety of speeds
speeds huh th
modem which works
works on telephone
fifty-six kilo bauds
bauds is fifty-six
fifty-six kilo bits
heard the term
thing as bits
terms of communication
rates in terms
terms of bits
bauds are fifty-six
devices for storage
storage huh floppy
huh floppy disk
disk drive optical
drive optical disk
form of optical
optical so huh
transparent and depending
huh opaque region
region and transparent
bits per huh
huh unit area
area and huh
much of data
out as huh
huh the medium
devices so information
end in serial
long time storage
hundred kilo bytes
drive to huh
ten thousand kilo
huh hard disk
huh another huh
list is huh
drive the kind
carrying my lecture
lecture and plugged
plugged into huh
huh a semiconductor
type called flash
exact figure huh
figure huh lets
disk drive huh
group of rotating
shows two platters
huh each platter
typically is capable
capable of storing
form of polarity
polarity or magnetization
set of read
read write heads
rotation this end
head can move
center or move
tracks and huh
huh these heads
heads get positioned
positioned over huh
huh some tracks
heads are positioned
positioned on track
track number ten
movement of head
head from track
track to track
movement of disk
disk is rotary
reach some point
head and head
effectively this moves
done by information
recorded or read
surfaces eight recording
surfaces and huh
point and so
head will move
move outside outwards
outwards or inwards
move from track
track the rotational
typically huh the
huh the they
they they follow
follow certain standards
standards so huh
thirty-six hundred revolution
revolution per minute
change to fifty-four
fifty-four hundred revolution
seventy-two hundred revolution
point three thousand
thousand or fif
fif fifteen thousand
disk from sea
gate so huh
huh fifteen point
huh highest speed
speed you find
find these days
commercially and huh
that that decides
decides how fast
data ok huh
huh it inferences
takes to reach
reach the initial
disk is rotating
right point huh
huh the rate
determines the rate
encountering the data
capacity of huh
speed is fifteen
seek time seek
reach the desired
interface also huh
transfer three twenty
interface huh th
th that interface
disk you connect
rotating at huh
actual data generated
huh very high
huh somewhat slower
half the speed
huh but capacity
capacity is larger
larger so capacity
huh two fifty
huh buffer size
size which means
processor or memory
directly its first
size eight megabytes
transferred average latency
average latency huh
latency so huh
point is determined
determined by huh
huh two things
case four point
point two millisecond
millisecond and huh
revolutions per minute
average huh rotational
huh rotational latency
point two milliseconds
two milliseconds huh
huh the seek
milliseconds and huh
move one track
reading eight point
point nine milliseconds
milliseconds and writing
writing ten point
basically a huh
reach the first
transfer the data
point then things
things are faster
buffer to disk
thirty-seven mega bits
buffer to host
interface this takes
takes hundred megabyte
transfer between disk
disk and buffer
busy in transferring
busy in seeking
disk is faster
in-between it spends
moving to huh
huh the desired
parameters which define
define the storage
storage layout huh
layout huh cylinder
sort of coinciding
platters so suppose
platters on huh
huh you talk
talk of tenth
cylinder so of
of often huh
write in terms
number of tracks
tracks you talk
talk of total
number of cylinders
figure the total
number of heads
huh each surface
surface is accessed
huh then number
track is divided
divided into number
number of sectors
western digital internet
digital internet site
rest huh number
sectors per track
huh total capacity
bytes per sector
half kilo byte
huh lets huh
important peripheral device
device that disk
communicate with disk
huh from samsung
views are shown
shown huh interesting
huh interesting thing
view which shows
shows how thin
twenty into twelve
hundred and huh
huh the viewing
limited viewing angle
wireless lan adapters
serial bus we
inside the computer
huh graphics card
card so th
cards which drive
drive really high
high resolution monitors
show you huh
huh changing scenes
scanners are characterized
number of colors
forty-eight bit color
color six bytes
bytes huh the
the these scanners
document feeder attached
attached that means
put a bunch
bunch of papers
huh automatically feed
huh inkjet printers
effective and huh
continuously improving huh
number of dots
figures here huh
huh direct network
direct network interface
picture my idea
inkjet printing mech
printing mech huh
mech huh printer
huh printer mechanism
printer mechanism huh
paper gets set
area where printing
printing gets done
out here huh
essentially paper feed
feed and huh
interface but huh
happened over last
huh ink ve
drops of ink
huh huh thrown
thrown on paper
paper to form
huh high quality
high quality pictures
huh piezoelectric mechanism
huh that vibration
finely controlled droplet
controlled by huh
huh the electrical
an another view
chamber where ink
droplet gets thrown
vibration of piezoelectric
piezoelectric huh disk
mechanism where huh
huh the ink
droplet is thrown
localized hitting process
hitted by electrical
current and huh
out so huh
huh you remember
talking of resolution
resolution of nature
nature of twelve
twelve hundred dots
level of control
droplet to make
technology of peripheral
devices which existed
couple of decades
summarize we talked
talked of huh
briefly we talked
talked about throughput
definition or response
response time type
type of definition
huh we looked
looked at variety
counts huh tired
data transfer rates
examples of peripherals
interfaces and buses
lecture on input
subsystem we talked
sense trans carrying
trans carrying information
information from huh
processor of memory
world and vice
versa and transforming
transforming the information
information into suitable
interfaced to huh
types of alternatives
interconnect various subsystems
focus on buses
buses as huh
types of buses
buses how buses
role and huh
huh the information
information which flows
buses can follow
follow different types
types of protocol
synchronous or asynchronous
asynchronous synchronous means
clock and asynchronous
huh not synchronized
carry the event
event sequence information
performance of huh
two different protocols
huh processor memory
processor memory cache
typically the case
connecting to huh
controller may connect
huh this open
in-between which connects
flow between huh
huh processor cache
processor cache combination
combination and memory
combination and devices
device directly huh
side or vice
alternatives which exist
straight forward huh
forward huh answer
memory to talk
talk to huh
huh this device
device so establish
establish a connection
cache or processor
processor to talk
connection also connection
connection between cache
memory so whichever
pairs of devices
devices or subsystem
huh shared set
bus so bus
shared communication link
link where huh
huh different types
types of information
collection of huh
huh basically wires
wires and signals
wires would carry
carry different types
huh the data
direction and control
bus huh so
huh the nature
nature of information
huh the design
bus is determined
organize these signals
number of wires
information is carried
carried the basic
wires to connect
huh one pair
anytime ok huh
huh they the
the the conversation
sequenced but it
convenient and cost
huh to put
sort of exchange
cross bar switch
bar switch huh
huh here huh
huh make establish
make establish connections
connected and huh
in in general
pairs so huh
so huh th
point connection bus
bus and cross
bar in terms
cost bus offers
expensive the throughput
throughput is low
low in case
case of bus
higher in case
require multiple ports
two separate ports
distinct isolated connections
connections and huh
four five parties
th the cost
links but huh
issue of multiple
question is expansion
expansion that huh
add more huh
easier in case
case of point
create more links
increase the capacity
huh three specific
huh the limitation
provide multiple buses
spectrum you form
completely low cost
low cost low
slightly improve things
things by introducing
introducing more buses
buses you incur
incur more cost
monolithic single cross
single cross bar
switch which connects
divide into huh
huh a fewer
fewer but smaller
smaller cross bar
cross bar switches
switches and huh
device to talk
complete huh cross
huh cross bar
cross bar capability
huh multiple smaller
multiple smaller switches
effectively huh reduce
bar will make
huh which means
pairs ok huh
number of communicating
incur less lower
point onwards huh
onwards huh lets
huh lets focus
system huh the
the are the
buses or huh
mixes is characteristics
processor memory bus
bus whose responsibility
memory huh wh
typically mean processor
processor and cache
buses are required
extremely high speed
high speed buses
short in length
length that means
standard huh standardization
standardization is required
connect a large
variety of subsystems
based on huh
intel s pentium
four so huh
pentium s behavior
processor to huh
sense that huh
subsystem and plug-in
connected to peripheral
primarily it connects
bus where huh
huh the main
devices to rest
bus and huh
huh this bus
bus is com
carrying comparatively huh
comparatively huh lower
huh lower huh
lower huh speed
speed of traffic
larger in number
ph physically spread
out this necessarily
expected that huh
manufactured by huh
huh different manufacturers
definition of huh
huh the bus
operation the bus
bus signals huh
bus width data
width data rate
huh multiple parties
parties to design
design their system
standard are required
examples of standard
subsequent lectures huh
issue of huh
huh may connect
connect processor memory
backpanel back back
back back backplane
back backplane bus
bus a question
reasons because earlier
system was designed
designed was huh
box where huh
huh each subsystem
connecting a single
front front side
huh a dis
board or multiple
single chip memory
typically one board
typically a bus
located the backside
cabinet so no
system like huh
pentium four huh
which which huh
huh backplane bus
bus but in
in logical sense
plugged in huh
nt have huh
huh processor board
board and memory
memory board plug-in
devices all connecting
co complete subsystem
physically integral part
transforms information huh
memory will understand
huh in case
case huh lets
laser printer huh
characters of pictures
huh binary encoded
connecting a processor
output is organized
organized in terms
buses so the
bus and backplane
bus takes care
connected to processor
adapters or interfaces
nt simply connect
the the reason
wo the width
transferring thirty-two bit
bit or sixty-four
sixty-four bit data
character by character
character or byte
byte by byte
byte the speeds
slower the speed
catering for processor
the they occupy
occupy the bus
bus mainly huh
usage so huh
expensive in terms
terms of fits
fits huh design
huh design cost
huh various reasons
seperate infact multiple
infact multiple huh
storage devices disk
disk and huh
care of huh
huh serial peripheral
serial peripheral lets
connect your scanner
huh grouping peripheral
grouping peripheral devices
types of bus
adapters which connect
connect backplane bus
kinds of adapters
definition of signals
signals the protocols
protocols the speeds
ends and make
make them match
match right huh
so so infact
huh a typical
typical sophisticated system
huh infact huh
huh our pentium
huh a bus
the the controllers
th the device
right that huh
huh multiple devices
no now lets
sharing of information
information or sharing
bus by multiple
devices so huh
connecting multiple devices
multiple devices huh
firstly as huh
huh would multiple
question and then
system together are
are are multiple
devices simultaneously speak
speak to memory
memory that means
means the huh
disk to memory
memory some file
memory end huh
reading a word
word or writing
word so how
lets say localized
the the disk
data is flowing
sequentialized but huh
printer its flowing
suppose this capacity
two different streams
streams of data
sort of inter
designed this bus
traffic is coming
road it merges
highway so on
kind of structure
structure huh brings
huh a huh
printer busy huh
utilized there huh
huh capacity huh
it its managed
managed in terms
sequence so huh
lets say coming
figure suppose backplane
suppose backplane bus
rate of twenty
sake of argument
wide which means
huh every fifty
nano second huh
data each byte
byte of data
data occupies fifty
occupies fifty nano
twent yeah fifty
fifty nano seconds
huh each byte
occupies this bus
bus for huh
hundred nano seconds
coming one byte
two hundred nano
huh every huh
huh thousand nano
data is coming
someway sequenced right
sequenced right huh
inter at huh
level or group
group of byte
byte level huh
level huh tha
tha that depends
depends upon huh
organize this bus
huh this adapter
adapter may collect
collect several bytes
bytes and put
chance it puts
huh own packet
bus so huh
huh if bus
bus as higher
things in sequence
huh considering huh
devices like disk
disk are sitting
huh these ideas
bus organization huh
huh but lets
huh and lot
lot of variations
types of lines
lines which tells
address since the
words or memory
bytes so huh
show an output
transaction that means
device so huh
shade huh memory
reading or writing
writing so huh
huh if right
half is shaded
begin with huh
data so me
me memory huh
huh internally pick
word or byte
addressed and bring
data will flow
lines and huh
huh this disk
disk is supposed
data and absorb
absorb it write
write so huh
huh the the
sequence of huh
huh information flowing
data or memory
shows the opposite
operation where huh
disk and writing
address and told
write and huh
disk is told
told to read
data this data
out and memory
nature of signals
huh this information
organized huh asynchronous
asynchronous and synchronous
synchronous in asynchronous
involved to synchronize
huh the events
party which involved
lets huh lets
case of reading
memory will huh
send a signal
calling as read
signal is activated
activated the meaning
operation and send
send out data
out data huh
data bus huh
active is carrying
carrying the address
parties that huh
bus is carrying
sending the address
receiving the address
change of read
memory would send
send an acknowledgement
huh in asynchronous
asynchronous huh transaction
response to read
nano seconds huh
huh this carries
noticed that read
huh this read
originated from processor
shown by arrow
done these events
huh since data
bus becomes free
huh signal shape
signal shape indicating
indicating that huh
occurring here huh
huh an individual
bunch of signals
change is occurring
worried about huh
huh what change
level is huh
huh level indicating
indicating that bus
bus is free
huh these buses
buses are organized
organized as huh
high impedance state
impedance state huh
state huh high
huh high impedance
impedance state means
bus is infact
connected its nei
bus the bus
huh floating state
huh low impedance
low impedance path
path to huh
level nor huh
path to power
upto this point
point was floating
point the data
data is removed
address is removed
huh now huh
huh this sequence
completed by huh
lowering the acknowledge
signal so memory
huh after raising
raising acknowledge signal
four which complete
complete huh cycle
homework and huh
back with data
bus and activate
activate the signal
data is ready
device to acknowledge
read the data
remove the data
lower the signal
th the data
device will lower
lower the acknowledge
cycle is completed
recognized that data
four huh events
lock lock manner
bus to bus
variations in terms
terms of nomenclature
pulse or negative
negative pulse huh
event is timing
event that event
huh transaction completes
will huh sort
sort of read
out aloud huh
handshaking to occur
huh internally huh
device and memory
sequence of states
states and huh
state it response
observed and huh
device and huh
huh the requesting
device is putting
address on data
lines and asserts
asserts read request
read request signal
signal ok huh
waiting for read
state when read
huh it observes
observes the data
address it remembers
remembers the address
asserts the acknowledgement
done this huh
watching the acknowledgement
long as acknowledgement
huh this proceeds
release the data
lines and reassert
reassert read request
acknowledgement signal huh
signal huh memory
remain in read
read request state
remain in state
long as read
notice that huh
th the transitions
two state diagrams
diagrams are occurring
follow these diagrams
previous huh wave
huh wave form
form is captured
indicating how huh
huh this action
out inside the
inside the memory
memory and inside
device so the
huh observe occurrences
carry out state
state changes inside
synchronous bus huh
buses and multiple
multiple synchronous buses
twenty megahertz clock
hundred megahertz clock
case all events
timed by huh
huh the clock
show huh lets
lets say raising
occur here huh
cycle where transaction
signal called start
start and huh
cycle or mu
mu multiple integral
multiple integral number
cycle most common
clock cycles huh
device can make
make this assumption
assumption that bus
waiting to check
check whether memory
huh no confirmation
pick up data
assumed that huh
huh memory understands
device huh sitting
form there huh
fixed clock cycle
compare and huh
huh how throughput
determined huh depending
so so lets
huh asynchronous bus
running at fifty
megahertz and huh
huh the address
means one cycle
cycle memory takes
seconds to respond
respond after bus
huh after address
fixed four clock
cycles and suppose
suppose huh fifty
huh fifty nano
required to send
huh entire sequence
clear one cycle
cycle you send
address then huh
huh four cycle
cycle to huh
require six cycles
transferring one word
word lets assume
bytes are transferred
four bytes divided
point three megabytes
bandwidth or bus
basic operations lets
similar speed asynchronous
speed asynchronous bus
huh no constraint
constraint on timing
timing in term
term in terms
event is coming
coming in response
sake of calculation
calculation lets assume
huh is taking
minimum of forty
forty nano seconds
minimum time huh
four five etcetera
huh these pertain
chain of events
huh first step
first step huh
step huh takes
huh takes forty
takes forty nano
seconds its huh
huh basically delay
delay one event
huh this delay
delay this interval
interval this interval
interval effectively huh
huh the interval
availability of data
protocol is concerned
concerned is forty
forty plus forty
quantities three times
requiring forty nano
huh the total
upto three sixty
sixty nano seconds
bus is huh
huh one word
bandwidth of eleven
point one megabyte
huh well huh
indicating is synchronous
picked up huh
th the relative
huh synchronous buses
faster because huh
waiting for huh
sensing the signals
signals and acknowledging
increase bus bandwidth
increase the bus
thirty-two bit wide
bit wide bus
sixty-four bit wide
twenty-eight bit wide
huh block transfer
transfer between cache
transfer huh multi
huh multi block
multi block words
transfer multiple words
split transaction split
transaction split transaction
split transaction means
huh between initiation
transfer and completion
noticed that buses
buses lie unutilized
delay is large
initiate another transaction
transaction gets splits
in two parts
two parts initiation
parts initiation part
huh le lets
le lets huh
word but multiple
transferred so huh
talk of block
block size varying
sixty-four bits synchronous
bits synchronous bus
synchronous bus frequency
two hundred megahertz
hundred megahertz takes
takes one clock
clock to send
send either data
address two clocks
clocks between huh
huh each bus
two clock cycle
bus huh memory
huh memory access
memory access takes
access takes huh
first four words
words but subsequent
huh faster lets
lets say subsequent
two twenty nano
inter-leaving or huh
huh page mode
huh bus transfer
transfer and reading
reading next data
overlap that means
huh one data
bus meanwhile memory
memory is working
word are overlapping
find the bandwidth
bandwidth and latency
latency for transferring
two fifty-six words
words ok total
words which huh
blocks of size
four or blocks
require sixty-four transactions
count the cycle
sending address huh
address huh forty
forty for memory
clock period huh
huh we send
cycles of idle
cycles are forty-five
cycles is sixty-four
multiplied by forty-five
require for entire
words and huh
huh each cycle
latency in terms
huh nano seconds
effectively the bus
point one megabytes
huh four word
blocks same exercise
sixteen word blocks
blocks the number
number of transactions
sixteen and huh
sixteen sixteen words
sixteen words huh
fifty-seven the total
cycles is sixteen
number of transaction
transaction into fifty-seven
latency this number
rate sixteen transactions
means three point
bandwidth is huh
two twenty-four point
huh and summarize
interconnection alternatives huh
alternatives huh bus
huh most popular
buses namely backplane
backplane bus processor
bus processor memory
huh standard buses
standard buses standard
applicable across multiple
organizations whereas processor
processor memory buses
buses are proprietary
proprietary and backplane
types of protocols
synchronous and asynchronous
generally faster huh
effect of huh
choosing a suitable
suitable bla block
bla block size
size in terms
improves the bus
output subsystem consist
consist of huh
connected to huh
system through buses
buses so buses
typically the medium
medium of huh
communication between peripherals
buses in terms
throughput or bandwidth
discussion huh talk
talk about huh
issue of bus
bus we noticed
factors which huh
exploited to increase
bus that means
bit of data
huh is carried
buses sixteen bit
sixteen bit buses
buses thirty-two bit
thirty-two bit buses
bit buses sixty-four
the the rate
proportional to width
bus maybe multiplexed
lines are multiplexed
multiplexed that means
bus or data
communicated so huh
huh provide separate
provide separate lines
lines which means
means additional cost
asynchronous synchronous protocol
synchronous protocol implies
implies that huh
events occur huh
huh at active
times are measured
asynchronous bus huh
bus huh th
interlocked response huh
request from huh
memory or processor
huh one event
event occurs huh
huh which triggers
triggers another event
event that triggers
events get chained
chained or interlocked
huh allow arbitrary
event these protocols
lower as compared
compared to synchronous
th the higher
higher speed buses
buses typically follow
typically follow huh
follow huh synchronous
huh synchronous approach
approach we huh
huh the block
transfer larger blocks
larger blocks chunks
chunks of larger
throughput is faster
typically the bus
bus is occupied
starting a transaction
transactions or initiate
initiate other transactions
split transaction protocol
device another mechanism
mechanism to improve
improve the bus
throughput so lets
back to huh
effect on bus
asynchronous handshaking protocol
sixty-four bit synchronous
bit synchronous bus
varying the block
cycle to send
require two clock
cycles between huh
bus and memory
accessed is capable
capable of huh
huh sending first
four words huh
huh at huh
additional word huh
word huh requires
huh requires twenty
requires twenty nano
huh a mechanism
words within huh
huh twenty nano
means when huh
groups of sixteen
calculation of finding
finding the latency
latency that means
means how long
takes to transfer
width that means
means the total
total huh rate
possibilities the block
words or sixteen
transfer that transaction
transferring four words
done sixty-four times
transferring sixteen words
done sixteen times
make a total
cycles each transaction
transaction takes huh
takes huh involves
huh involves sending
sending an address
address which takes
clock then allowing
memory to access
access the data
data which takes
takes forty clocks
hundred megahertz means
means five nano
period so forty
forty clock periods
clock periods huh
memory is fetching
fetching four words
bus is sixty-four
wide ok lets
takes two hundred
takes twenty nano
two word wide
requires two cycles
cycles to send
send this data
huh between huh
huh one transfer
huh these figures
huh sending huh
huh four words
words only huh
multiplying this part
size in words
takes forty-five word
forty-five word forty-five
word forty-five cycles
takes fifty-seven cycles
cycle per transaction
transactions to make
words so forty-five
multiplied by sixty-four
product of the
seconds by multiplying
total time required
required to transfer
fifty-six to read
talk of transaction
means different thing
transaction here means
sending four words
four words transaction
means sending sixteen
sending sixteen words
words so number
huh thousand times
huh four point
four million transactions
bytes being transferred
bandwidth or throughput
throughput is huh
lets say measured
measured in megabytes
fifty-six words multiplied
four which means
throughput so seventy
seventy one point
throughput there so
thing we talked
suppose one transaction
transaction huh begins
right and sending
sending a request
request to memory
in-between huh the
the the device
released and made
signals that data
ready or huh
synchronous you wait
bus and read
data now in-between
transaction to begin
link the beginnings
means the device
device which send
send a request
request here huh
huh s bu
obvious that utilization
huh many huh
huh parties connected
typically a concept
concept of master
master and slave
initiates a transaction
request for read
write and slave
situation processor talking
talking to memory
memory so processor
data containing instructions
instructions ok or
write a block
memory huh conversation
huh conversation processor
master and memory
slave another scenario
write into memory
memory or read
case the disk
disk drive controller
scenario that processor
transfer so processor
instruct the disk
huh set number
send one thousand
bytes of data
data to memory
huh initiation process
huh among masters
processors or peripherals
peripherals and slaves
peripherals or memory
memory so peripherals
slaves while talking
talking to processor
master while talking
huh multiple masters
huh after bus
master another master
arrangement of priorities
priorities so huh
huh this priority
resolve the conflict
conflict when multiple
huh would depend
depend upon huh
fairness is es
es essential huh
huh whether huh
party as low
priority or higher
huh reasonably distributed
four different mechanisms
mechanisms called daisy
daisy chaining centralized
chaining centralized parallel
centralized parallel arbitration
parallel arbitration distributed
arbitration distributed arbitration
arbitration and arbitration
arbitration by collision
detection so which
huh different mechanisms
scenario showing huh
approach called daisy
chain for huh
resolving the huh
huh accessed issued
access the bus
showing the bus
bus completely bus
lines and address
define the discipline
discipline of transfer
control of bus
master we assume
huh a block
bus arbiter huh
devices are arranged
arranged in huh
huh decreasing order
order of priority
priority highest priority
priority is sitting
lowest priority sits
priority sits farthest
huh bus request
bus request signals
signals and bus
bus release signals
device can send
bus huh device
bus any longer
bus grant signal
arbiter is chained
chain so grant
highest priority device
device say device
two in response
arbiter will send
send a grant
device one doesn
signal to pass
device two device
huh grant signal
blocked if the
the are multiple
multiple devices requesting
arbiter will block
huh down stream
priorities are managed
sequence of events
raising this line
line bus request
bus request line
convention but huh
sake of explanation
assuming that huh
huh the request
device is requesting
requesting in response
free the huh
arbiter will activate
activate the grant
signal and huh
lower the request
activate release signal
assuming that release
arbiter huh sees
sees that bus
lower the grant
lower its release
acquiring the bus
bus and releasing
releasing the bus
bus now lets
happen if the
requesting the bus
lets say bus
bus was free
bus arbiter notices
bus now huh
imagine that imagine
release and request
request are wired
huh each device
device may send
send its individual
devices are requesting
bus arbiter doesn
doesn t worry
simply huh activates
activates the grant
grant line indicating
naturally the device
chain will wait
bus huh wh
priority device completes
completes the cycle
but but huh
huh this line
line will stay
high because huh
lower priority device
bus huh grant
lowered down release
lowered down huh
give the grant
huh eventually huh
huh if multiple
devices had requested
huh one device
device gets served
served then huh
happen if huh
higher priority device
device comes huh
find that grant
huh the grant
situation because huh
huh the high
high priority device
device will hijack
huh while low
low priority device
avoid that huh
we we follow
follow a rule
rule that huh
signal is sufficient
sufficient to ensure
priority device coming
device coming in-between
in-between when bus
priority device huh
find grant signal
mentioned raising edge
signal is significant
level th the
huh release signal
request signal huh
usage of bus
huh a device
removed its request
persisting you wont
wont know huh
huh this change
change so you
arrangement is huh
huh very simple
simple and inexpensive
request and release
release and activates
chain is long
propagation huh the
delay so huh
signal as changed
huh the operation
back to previous
previous diagram huh
happen that huh
huh high priority
huh a low
suppose huh device
huh two releases
two releases grant
huh meanwhile request
huh getting passed
high priority devices
devices at low
disallowed to reacquire
sees the request
line go low
line will continue
line as serve
line goes low
huh no device
requesting that means
requested some point
huh is served
served so huh
mentioned about arbitration
huh many devices
separate request line
device and separate
separate grant line
line for device
grant line request
line request line
two grant line
two request line
logic is contained
arbiter arbiter huh
huh is supposed
request and issue
issue them grants
individually so huh
huh then the
fair manner huh
manner huh assign
assign the bus
bus or give
devices huh turn
turn by turn
turn alright huh
th the priority
lowest priority but
priority but but
but huh th
th the position
huh the priority
arbitrarily define priorities
devices and huh
resolution of multiple
kind of huh
arbiter so arbiter
complex then huh
distribute this task
task of arbitration
huh democratic kind
kind of system
sort of negotiate
huh collectively decide
bus so you
devices can send
send their request
put their identity
huh specific lines
lines so ea
huh the identities
device two sees
sees that device
requesting and device
requesting and huh
huh the priorities
devices are understood
manner all devices
bus what request
detection so th
huh shared medium
devices are connected
notice each device
device simply sees
initiate your transaction
multiple huh devices
huh devices happen
check if huh
huh did collide
collision takes place
collide that means
indication of collision
huh to ensure
huh both devices
devices which collided
delay is huh
huh five microseconds
lost in huh
collision so huh
coming from huh
devices and priorities
priorities are fixed
kind i mentioned
mentioned earlier huh
huh then starvation
starvation could occur
huh re request
request actually huh
huh get held
modifying the priorities
dynamically the priorities
priorities could rotate
device which lets
bus huh kind
queue and stand
huh one scenario
typically a proprietary
proprietary bus connects
bus connects processor
connects processor memory
backplane huh bus
indirectly and processor
indirectly all connected
huh disk drives
huh maybe huh
huh printers scanners
ty typically huh
buses are standard
standard processor memory
proprietary backplane buses
huh standard huh
highest at processor
memory bus level
level and lowest
bus level huh
buses will tend
huh would tend
asynchronous but huh
lines backplane buses
generally synchronous huh
huh oversimplified situation
real system huh
system huh thing
typical huh pentium
four huh type
two huh controllers
motherboard is built
huh which interface
motherboard so the
two complex chips
memory control hub
graphics memory control
hub so huh
side it connects
connects to memory
simply a video
huh this connects
peripherals including huh
bus and the
variety of devices
lan ok huh
diagram so huh
cases of frequencies
huh the hub
front side bus
designed to connect
run at huh
huh three thirty-three
four hundred megahertz
thirty-three megahertz huh
basically disk drive
drive huh interfaces
huh interfaces huh
kind of serial
talked of adapters
connecting multiple buses
buses ok huh
huh device high
device high speed
high speed devices
devices like graphic
display are connecting
directly to memory
huh are connecting
connecting are coming
huh display devices
huh the huh
huh the transfer
demand the bandwidth
highest throughput requirement
huh we talked
didn t show
huh two buses
huh backside bus
backside bus front
bus front side
connects the main
memory ok huh
bus which connects
bus right huh
huh a and
motherboard its huh
the are numerous
huh real system
the are huh
lots of variations
mentioning the term
term standard bus
standards are huh
manufacturers could talk
case if the
standard buses huh
expect entire system
compatibility is ensured
define a standard
interface so huh
huh one company
company can build
build different huh
peripherals so huh
parties to build
build different things
good at huh
technology develops huh
develops huh the
the these huh
huh speeds change
change and huh
huh various requirements
requirements huh change
two contradictory requirements
contradictory requirements huh
things to improve
defined a bus
make one device
compatible two hundred
megahertz you make
make it compatible
sort of agreed
agreed and frozen
make my devices
megahertz so huh
huh by standardizing
sort of freezing
freezing and huh
arresting the growth
an an commercial
an commercial pressure
revising and refining
refining your standards
huh a continuous
continuous process huh
huh so you
huh formal mechanisms
mechanisms of huh
defining these standards
done by huh
huh either groups
groups of industries
collectively defining standards
define the standard
acceptable to larger
larger huh community
huh a proprietary
interface or proprietary
proprietary huh mechanism
popular gets adapted
standard so other
other see benefit
benefit in huh
huh a popular
person is doing
buses are concerned
huh is defined
level at physical
level at electrical
shape size dimension
connectors ok huh
huh the voltage
voltage and current
levels the impedances
define the meaning
events take place
place so huh
logical level huh
level huh lets
examples of huh
huh various kinds
kinds of buses
domain huh in
in in early
transformed industry standard
industry standard architecture
standard architecture huh
bus then huh
felt that huh
link and peripherals
link so huh
stands for video
video electronics standards
electronics standards association
association a local
bus is defined
bus was defined
stands for peripheral
peripheral component interconnect
component interconnect bus
backplane bus huh
stands for accelerated
accelerated graphics port
graphics port huh
devices get connected
earlier eight bit
thirty-two bit bus
point three megahertz
megahertz later versions
sixty-six to double
huh one megabyte
meant to represent
represent two power
two power twenty
figure by huh
huh lets spend
lets spend huh
huh a couple
couple of minutes
invariably there in
huh thirty-three megahertz
thirty-three megahertz synchronous
megahertz synchronous bus
synchronous bus width
huh peak transfer
peak transfer rate
rate that means
continuously transferring data
delays and idle
address which flows
address four gigabytes
gigabytes of memory
terms of voltage
point three volt
lead to huh
version two point
wide sixty-six megahertz
roughly four times
factor get doubled
version also huh
rate of huh
huh one thirty-three
megahertz so bandwidth
two sixty-six version
two sixty-six megahertz
megahertz and bandwidth
variations like mini
details of huh
huh what signals
serial version serial
version serial buses
typically huh cheaper
cables are cheaper
cheaper the connectors
connectors are cheaper
cost is lower
ob obviously huh
sending one bit
total data rate
rate gets reduced
port ok huh
connect huh external
huh external modems
external modems huh
modems huh parallel
huh parallel port
typically connect printer
extended parallel port
huh flash memory
flash memory device
devices like cameras
huh other high
high performance serial
performance serial de
serial de serial
de serial ports
ports like fire
fire wire fiber
wire fiber channel
terms of throughput
rate huh starting
starting from huh
huh a fraction
fraction of megabytes
four hundred megabytes
disk disk drives
disk drives huh
small computer system
computer system interface
system interface huh
standards have evolved
ultra wide fast
improve so starting
upto one sixty
huh steps in-between
close at point
today is huh
variation of block
block size huh
huh would huh
huh per huh
huh would change
change the performance
quantitatively we huh
methods of arbitration
arbitration of bus
bus when the
huh the requirement
lead to starvation
fairness we huh
organization of buses
we we huh
huh briefly looked
series of buses
drive or huh
huh time progresses
progresses the buses
refined and redefined
redefined the standards
changing to huh
huh keep pace
continuing our discussion
buses which interconnect
entire activity appears
devices are addressed
addressed and huh
huh one crucial
operation is checking
checking the status
status or identifying
events are occurring
occurring and huh
devices to talk
talk from software
finally how memory
memory directly interacts
huh a high
activity in terms
statements like printf
printf and scanf
huh your view
levels of abstraction
abstraction so huh
machine language level
language level the
the are lots
lots of details
worry about huh
huh the formatting
formatting of data
data so huh
data as huh
huh high level
language program sees
arrays and structures
structures and huh
huh these structures
structures could consist
huh various types
primitive elements integers
elements integers floating
integers floating point
floating point strings
converted into raw
form of data
data huh th
th that formatting
done the values
devices can understand
huh display device
display device understands
device understands things
things in terms
matrix or pixels
huh a character
character level device
terms of ascii
form which huh
device is sending
form which programmer
versa then huh
memory what kind
kind of bus
data through huh
huh these paths
huh timing characteristics
track it takes
huh taken care
software and huh
role of system
format conversions examples
conversions examples huh
lot of huh
lots of library
library function library
function library routines
care of converting
operations into low
low level operation
operation so things
things like format
level then huh
question of huh
tracks and sectors
drive these details
huh specific peripheral
specific peripheral devices
family of peripheral
devices and understand
understand th details
require to work
work with interrupts
devices or the
the their timings
handled through interrupts
interrupts or exceptions
exceptions and huh
earlier that huh
handled by exception
routine or interrupt
interrupt handling routine
kernel so huh
interrupt system huh
number of interrupts
huh given processor
handled by huh
huh a portion
question of multiple
processes huh sharing
sharing different peripheral
huh several programs
programs or processors
share a disk
disk or share
share a printer
printer or display
display on display
multiple windows coming
coming up due
due to huh
huh multiple tasks
tasks so th
th the sharing
huh the role
devices like base
base or huh
hard disk drives
drives pro properties
pro properties drives
information is organized
terms of files
view of files
program but the
the these files
huh physical devices
mapping is done
file system part
part of huh
huh operating system
huh take lot
huh could vary
depending upon nature
device the kind
kind of speed
huh th th
th th the
the the demand
keyboard or mouse
huh are producing
operator can enter
keyboard is limited
th the demand
character one byte
groups of bytes
mou mouse huh
mouse huh th
th the mouse
basically is tracking
huh the position
move the mouse
huh essentially huh
minus x direction
the the movement
huh is huh
huh slow huh
slow huh imagine
imagine that processor
processor is working
huh several gigahertz
pretty small huh
huh so th
handling small volume
peripheral huh the
block of information
talking of sending
sending a byte
network or sending
sending ten bytes
bytes on network
huh big blocks
blocks or packets
packets so the
huh network operation
memory ok you
position of memory
the the network
the network standards
network standards talk
talk of ten
going to ten
tens or hundreds
turn our attention
attention to graphic
graphic display huh
huh in graphic
human eye sees
refresh it huh
huh several times
huh twenty-five huh
twenty-five huh times
maintain an image
image of huh
screen in memory
screen you you
you you modify
modify certain area
huh some activity
activity which takes
takes huh matrix
matrix of pixels
pixels as stored
refresh certain number
screen so huh
modern systems work
systems work huh
huh in earlier
sep separately huh
port so huh
sequence of characters
characters or sequence
huh some intelligence
device would huh
characters and huh
modify the display
huh there huh
huh the chan
chan the rate
encode the changed
information and send
huh serial port
serial port huh
huh all workstations
disk drive typical
drive typical operation
head read write
read write head
involve huh bulk
bulk of data
data transfer huh
variety in terms
transferred the quantum
quantum of data
handled and huh
mechanism of data
automatically being picked
transferred whereas huh
huh in network
mouse or keyboard
keys get huh
information gets transferred
transferred or huh
in in network
change that huh
huh pixel matrix
transfer from pixel
pixel matrix huh
continuous activity huh
address huh the
the are large
number of devices
address them huh
speaking the controller
processor ok huh
registers or view
view them ports
call them ports
huh give commands
peripheral device huh
load some huh
treated as command
expected to work
involve some parameters
command to seek
seek the disk
number and sect
read the status
huh certain register
designated as status
huh that register
register and check
check specific bits
bits to find
things have occurred
huh if key
keyboard or huh
read or written
written so huh
huh each de
device each device
registers and huh
huh these registers
huh a program
write a register
two ways addresses
memory space memory
space memory address
leave some area
space you leaving
utilized for memory
last one thousand
addresses are reserved
reserved for register
reducing the memory
huh very critical
critical and huh
tha that area
separate address space
mentioned in memory
part of memory
space is reserved
instructions for reading
writing the register
memory is designed
designed to ignore
huh the addresses
instruction is good
doesn t respond
assigned will respond
doing a store
store instruction huh
instruction huh depending
address falls address
falls address falls
falls in memory
huh address space
space for input
large as huh
ten to fifteen
large address space
device the distinction
first case huh
case huh depending
determine whether address
address is meant
address could fall
additional to distinguish
distinguish whether address
memory so the
additional control lines
instructions to work
case so huh
additional instruction similar
similar to load
right but huh
huh different op-codes
huh transferring data
huh before huh
transferring data huh
device is ready
ready for transferring
case of keyboard
keyboard huh the
determine if key
check whether huh
periodically and huh
out this approach
sampling and huh
read a status
status register check
check particular bit
bit and figure
huh processor doesn
and whenever huh
device to invoke
send an exception
exception or interrupt
device will intimates
intimates its readiness
readiness by raising
raising an exception
exception in huh
basically means huh
processor is activated
activated and an
an processor huh
huh a hardware
transfer its control
control to exception
signal gets activated
activated so huh
huh in general
general a processor
huh multiple interrupt
multiple interrupt signal
interrupt signal coming
huh time huh
visualize the polling
the some status
status is changing
polled here spent
reading the status
status and figuring
out if huh
back here find
find that status
status is ready
out the process
huh and put
put some numerical
value see huh
suppose it consumes
consumes four hundred
four hundred cycles
types of devices
speeds so lets
lets say first
an this figure
figure is huh
mind how fast
mouse second case
drive which transfers
transfers the data
fifty kilo bytes
data of data
cases huh the
huh vast variation
terms of speed
speed and you
you your polling
faster and faster
faster accordingly huh
tied up huh
rate of thirty
cycles so thirty
consumed in polling
running huh lets
hundred million cycles
executing other computation
divide this huh
ratio huh convert
percent so huh
spent and huh
settling out mind
doing huh polling
polling of mouse
manner ok huh
drive huh th
th the rate
rate of sampling
sampling or rate
rate of polling
polling is higher
rate ok huh
data huh we
rate ok sixteen
transferring is fifty
huh into tens
divid may lead
percent that means
huh are dedicated
comfortable as huh
percentages would add
activities finally huh
huh we move
fast even faster
device four megabytes
figure is divided
divided by sixteen
transfer four words
transfer we spend
spend four hundred
hundred cycles divides
figure of twenty
twenty percent wh
spend twenty percent
huh just polling
interrupt driven input
driven input output
device to inform
inform the processor
readiness so huh
processor will huh
huh probably instruct
instruct the device
send an interrupt
interrupt or send
attention so processor
device by transferring
exception handling routine
routine and huh
huh exception handling
needful so th
exceptions here coming
coming from external
word of input
output the mechanism
instruction or page
asynchronous with respect
instruction whereas huh
huh internal exceptions
instruction but huh
instruction and huh
huh therefore huh
end of instruction
exception from external
huh these exceptions
comparatively lower priority
priority as compared
compared to internal
external exceptions huh
speed so devices
priority slow devices
similar to internal
interrupt or non
non vector interrupt
vector interrupt vector
interrupt vector interrupt
vector interrupt means
huh the control
directly gets transferred
non vector case
set the calls
calls of exception
register but transfer
control takes place
location and then
run some code
register and branch
points so huh
huh similar scenario
quantify the overheads
overheads of interrupt
interrupt driven transfer
hundred megahertz huh
overhead per interrupt
hundred cycles huh
work in case
case of hard
drive now huh
huh if disk
active then things
bad as polling
continuous interrupt infact
interrupt the overhead
overhead is larger
huh but th
device or huh
active so suppose
suppose its active
entire huh duration
duration of program
busy then data
device would inform
happen and the
polling based approach
continuously keep polling
huh the overhead
continuously busy huh
expression four megabytes
transferring sixteen bytes
cycles per interrupt
interrupt and divided
huh we assuming
busy or active
active five percent
two five percent
score now huh
huh at times
percent huh overhead
devices huh hard
overheads are added
added then lot
processor in transfer
group of words
device to deposit
role in direct
huh the trans
trans or setup
device that huh
huh from track
huh tra huh
huh that initialization
initialization is done
done the processor
words or bytes
memory and processor
done and th
huh check huh
found a bad
occurred then status
entrusted to huh
huh special controller
huh specify memory
memory addresses amount
amount of huh
huh word amount
transferred the direction
direction of transfer
device but multiple
multiple peripheral devices
devices which huh
huh are required
huh four channel
four high speed
devices to transfer
data to huh
data comes huh
updating the memory
transfer is done
lets huh le
processor huh running
hundred megahertz suppose
megahertz suppose huh
suppose huh initiation
requires thousand cycles
setup and huh
processor gets involved
involved when huh
spending thousand cycle
hundred cycle lets
cycle lets imagine
huh the chunk
chunk of data
cycles the processor
processor will achieve
process so huh
situation when hard
kind we discussed
discussed in previous
transfer four megabytes
huh four megabytes
rate and huh
requires eight kilo
two will give
done ok huh
end and divided
clock frequency huh
huh will give
lots of work
work the work
factor the ratio
tens power minus
figure alright as
transfer to interrupt
chose a suitable
mechanism for transfer
transfer and huh
higher and higher
higher performance huh
controller means huh
means huh additional
huh additional cost
cost similarly interrupt
interrupt also requires
requires certain mechanism
huh one step
transfer but huh
huh be asked
read a block
number one send
send a block
sequence of operations
huh block size
defined and huh
sequence so fo
huh each appears
the these instructions
huh a dedicated
activity and huh
processor will sequence
communication between memory
work when memory
hierarchy is present
present so huh
caused by presence
presence of virtual
memory in terms
work with physical
address so huh
controller that transfer
address huh an
working in huh
addresses so huh
created an array
address now huh
page huh contiguous
map to huh
huh two pages
done once huh
ways to handle
huh you restrict
suppose a page
transfer eight kilo
you your data
huh one physical
huh in contiguous
area in virtual
limit your data
transfer larger piece
in the overhead
overhead of multiple
huh what problems
bring in huh
essentially a problem
problem of consistency
talking to cache
read from main
memory so th
problem of huh
information as compared
happening the information
coming from devices
devices getting put
out of date
cache what processor
cache is huh
reverse happening huh
huh that huh
block and huh
control will pick
pick up information
information from memory
write back cache
updating main memory
huh in write
recall huh data
memory gets updated
updates into cache
blocks and bu
huh corresponding block
similar problem occurs
cases also huh
share same memory
imagine two processors
common shared memory
data which huh
communicate to huh
two through shared
shared memory huh
memory huh th
inconsistent so huh
first problem virtual
problem virtual memory
limiting your data
fo for huh
increasing the overhead
overhead so suppose
virtual memory problem
supply appropriate physical
problem but huh
overhead has occurred
occurred four times
increase the overhead
protocols are huh
huh additional actions
actions which huh
huh cache controllers
copies of data
exist in multiple
caches and memory
cache in memory
problem of coherence
coherence so huh
huh these protocols
coherence is maintained
maintained for at
out of sync
occurs so huh
means additional overhead
additional overhead work
point and summarize
role of huh
huh system software
software in huh
software is required
required a system
handle huh device
huh device specific
device specific details
care of sharing
sharing of device
device by multiple
multiple processor huh
devices are viewed
viewed as set
space or defining
defining huh separate
huh separate address
mechanism of checking
device status huh
status huh polling
polling and interrupts
interrupts huh polling
polling as higher
overhead particularly huh
undesirable for fast
devices and interrupts
interrupts also huh
huh not acceptable
huh direct communication
essential for fast
fast devices huh
huh like network
network controller disk
controller disk drive
designing i systems
previous two lectures
talked about individual
talked about peripherals
interconnect them huh
system design issues
huh the discussion
form of examples
huh certain performance
designing the system
performance in mind
earlier the performance
performance could focus
throughput aspects or
latency is important
important in terms
achieving certain response
occurs outside huh
huh the system
respond and huh
huh the response
data which moves
moves from external
system it processed
back so huh
delays get added
data gets generated
crosses through controller
buses and adapters
adapters and huh
huh somewhat similar
throughput issue huh
pipeline and th
th the slowest
throughput is concerned
comparatively huh easier
huh easier huh
state with data
understand the capability
rate the data
data can flow
huh but latency
data and counters
pieces of information
information which flow
flow through huh
huh various components
system and huh
simulate the entire
accurate manner huh
huh what kind
kind of latenc
huh li li
give as idea
idea of throughput
first example huh
application where huh
huh huge amount
read out read
disks so huh
huh s lots
lots of data
memory and lots
lots of disk
maximize our throughput
capacity of processor
huh certain number
number of adapters
supporting multiple disks
disks and huh
send the blocks
blocks which huh
huh gets read
amount of processing
processing involved huh
view to organize
instruction execution rate
hundred million instruction
quantifies the capacity
processor to perform
perform certain tasks
tasks the bus
memory is capable
handling a throughput
throughput of hundred
sources is huh
arrive at huh
huh bus throughput
bus throughput limit
the the size
suppose that analysis
analysis was carried
figure of hundred
hundred megabytes performance
capacity of twenty
buses are huh
carrying the data
controller is capable
upto seven disk
drive huh requires
huh requires ten
requires ten milliseconds
milliseconds to access
latency plus controller
data gets huh
read out data
operation involves sixty-four
involves sixty-four kilo
track but eve
milliseconds of delay
huh have incurred
incurred the ten
ten milliseconds delay
delay then huh
huh sixty-four kilo
huh five megabytes
bus is concerned
disk is busy
seeking or huh
huh its rotating
huh other disk
transferring the data
seeking and transfer
disk could overlap
operation of huh
kilo bytes transfer
bytes transfer requires
transfer requires huh
huh some work
hundred thousand instructions
instructions are executed
program and fifty
fifty thousand instructions
executed by operating
system so huh
imagine that huh
huh each transfer
transfer takes place
process which means
th the processor
initially setup huh
huh the process
showing so lets
control is lumped
controller to read
supplies the address
memory where things
instruction get executed
thousand instructions huh
huh all put
put together beginning
beginning and end
end and th
data huh is
huh is processed
huh it requires
requires huh hundred
hundred k instructions
maximum input output
input output rate
rate that huh
huh this system
system can sustain
processor one single
single processor memory
flexibilities in terms
system and depending
number of disk
require certain number
problem involves first
involves first finding
operations as defined
controllers are required
huh to solve
solve this fo
huh first lets
first lets analyze
limits of individual
individual huh component
component and huh
hundred plus fifty
fifty thousand instruction
huh this execution
hundred million instructions
processor is concerned
concerned is huh
hundred million divided
processor if rest
system was capable
matching this rate
processor is ready
two thousand operations
object is processor
bandwidth of hundred
transfer of sixty-four
figure out huh
out huh hundred
hundred million bytes
sixty-four k bytes
figures two thousand
two of huh
neck so processor
dictate the rate
huh out first
out first answer
achieve this huh
put to huh
seek plus rotational
rate and sixty-four
bytes of block
size the transfer
kilo bytes divided
point eight milliseconds
milliseconds ok so
operation basically disk
spend ten milliseconds
busy for huh
huh the sum
ten milliseconds latency
latency plus twelve
asked to seek
seek and transfer
transfer the rate
blocks is reciprocal
milliseconds or forty-three
the the throughput
huh the throughput
disk is huh
sustaining is sixty-four
huh although transfer
point eight megabytes
demand each disk
disk is placing
bus will con
disks and send
huh to begin
number of disks
drive is forty-three
require to saturate
fifteen sixty-two divided
divided by forty-three
distribute this thirty-six
disks to huh
number of controllers
controllers you require
huh addressing capability
number of controller
number of drives
controller is assigned
drives are grouped
groups and huh
huh each controller
times two point
limit of huh
exercise where huh
parameter were number
disks and number
analyze and de
question so huh
calculation very simple
complicate formula you
things are put
understand the operation
things are happening
happening huh rest
huh rest huh
huh design problem
design problem huh
design a multi-function
multi-function unit huh
photocopy and huh
send and receive
low cost scanner
scanner a low
low cost printer
cost printer huh
modem and connect
processor and huh
huh suitable memory
put these peripheral
scan a document
document and fax
fax and print
scan and print
modem plus printer
function as fax
fax receiver scanner
scanner plus modem
sender and scanner
scanner plus printer
calculation that huh
operation may require
number of copies
print a couple
couple of copies
copies you print
scan is huh
kind of scenario
work so lets
heavy huh fax
huh fax load
load so huh
huh continuously fax
fax are coming
huh the telephone
continuously kept busy
busy so ha
ha huh lets
lets say half
incoming and outgoing
faxes are balanced
balanced that means
al almost equal
number of fax
fax is coming
coming and equal
huh each fax
nt want to
worry about complication
complication of sending
sending multiple pages
four size pages
size pages huh
pages huh so
so both printer
printer and scanner
huh after satisfying
satisfying the fax
fax load huh
capacity of scanner
scanner and printer
utilized for photocopying
eventually the throughput
type of operation
rate of fax
sustained and huh
rate of photocopying
huh this sim
make it low
low cost huh
cost huh setup
bus so the
bus adapter sitting
sitting here huh
huh a scanner
scanner printer modem
modem which hooks
specification so huh
sort of dedicated
dedicated system huh
doing this huh
huh fax machine
so whatever program
put in huh
huh non-volatile memory
required we wont
bit of money
huh these huh
huh am ignoring
ignoring the details
type of port
ignore that last
last point detail
detail and assume
single bus huh
sort of fixed
choices we make
make so lets
low or medium
medium resolution print
resolution print huh
print huh machines
machines three hundred
hundred or twelve
page size fixed
size fixed page
fixed page size
modes one mode
mode is when
huh simply work
simply work huh
huh with black
black and white
gray levels huh
black or white
white ok and
two fifty-six gray
fifty-six gray level
will use mode
for photocopy purpose
mode two huh
two huh lets
pages per minute
minute and printer
modem available huh
modem we lets
lets take huh
huh thirty-three kilo
thirty-three kilo bits
modem and huh
ten percent overhead
bits as part
modem and lets
ten percent extra
percent extra data
disk available huh
latency of ten
milliseconds and transfer
low cost processor
cost processor huh
two options hundred
options hundred megahertz
directly accesses memory
accesses memory huh
huh the fax
requires certain encoding
encoding actually compresses
compresses the size
similarly the fax
decoded and put
number is mentioned
compression or decompression
decompression of factor
factor of ten
huh this process
process of encoding
encoding or decoding
decoding involves hundred
involves hundred instructions
instructions per byte
byte of raw
scanned the image
image is huh
huh ten kilo
require hundred instructions
executed performance byte
algorithm of encoding
sending a fax
fax would involve
scanning and huh
average the program
lets say thirty
make additional access
two sizes sixty-four
sizes sixty-four megabytes
two speeds huh
speeds huh forty
huh forty million
forty million words
sixty million words
proceed and huh
kind of rates
made for processor
lets first huh
huh what information
information each page
page carries huh
size of eleven
number of pixels
pixels as eleven
gray scale mode
bits per pixel
pixel so mode
bit per pixel
pixel and mode
two mega pixels
megabytes or point
megabytes ok huh
converted to bytes
huh the compression
compression in fax
fax and coding
coding was ten
send or receive
receive a page
fax line huh
line huh will
memory and disk
disk size lets
huh sixty-four megabytes
megabytes of memory
put one twenty-eight
megabytes will accommodate
easily the program
buffer several pages
waiting for printing
megabytes so sixty-four
cushion for accommodating
accommodating a couple
couple of scan
accommodated in memory
huh nonvolatile memory
huh volatile memory
volatile memory huh
memory huh augmented
augmented with flash
memory because flash
memory is slower
directly from flash
put a huh
huh fax process
process so modem
speed is thirty-three
thirty-three kilo bytes
two five kilo
huh the compressed
page or encoded
page is point
ninety-nine kilo bytes
percent of overhead
find out transmission
transmission or re
right so ninety-nine
point four seconds
page huh takes
received plus huh
line huh th
establish a call
call and modem
modem will respond
connection or huh
dialed and connection
established so lets
lets say twenty
fo for establishing
establishing a call
twenty is total
modem and line
line are busy
rate the rate
huh handling faxes
handling faxes huh
faxes huh incoming
convenient figure in
in per minute
huh one point
two per minute
th th setup
th setup huh
things actually limited
th the modem
rate which modem
modem can sustain
sustain and rest
turn out attention
attention to scanner
printer so scanning
or in terms
terms of pages
huh the outgoing
outgoing fax rate
fax rate huh
rate huh point
two we divide
divide into point
incoming and point
th the scanner
match the outgoing
th the capacity
capacity of point
continuously scan pages
scanned and huh
faxed out rest
photocopying purpose huh
hand printing rate
incoming fax rate
rate is point
photocopying is point
two two pages
spare capacity and
capacity and huh
and huh photocopy
huh photocopy operations
recall i mentioned
average three copies
copies so printer
slightly higher load
load and huh
basically huh printer
printer would dictate
dictate the photocopying
average so point
scanned and point
scanner and huh
sustain the throughput
huh so wh
receiving a fax
coming from modem
similarly for outgoing
bus similarly huh
huh from memory
memory to printer
printer or scanner
scanner to memory
memory will happen
happen at huh
huh this rate
huh each page
page per page
megabytes per page
printer scanner traffic
data rate huh
operation is point
two two faxes
multiply by huh
two four megabytes
operation for photocopy
photocopy operation huh
traffic between memory
huh to printer
huh that sends
data and point
data so sum
bus so sum
two huh point
is one point
-cept that solution
processor is doing
execute per fax
fax message huh
message huh is
huh i mentioned
the are hundred
page huh data
decoding a page
fax out involves
involves two operation
operation so ei
ei either huh
modem or writing
huh either scanning
scanning or printing
total of instructions
executed is huh
huh either sending
sending or receiving
two million instructions
huh per fax
incoming or outgoing
executed per photocopy
doing one scan
doing three prints
four here huh
instructions so total
total instructions throughput
instructions throughput required
scan rate huh
small so small
small factor huh
makes minor difference
total huh instruction
huh instruction rate
instruction rate required
part of processor
talked of hundred
basically hundred megahertz
deliver twenty-five mips
huh very comfortable
comfortable to handle
hundred megahertz processor
megahertz process infact
fifty megahertz version
version available huh
memory bandwidth huh
huh now we
capacity but suppose
tra that suppose
run at full
stroll for lack
work or lack
lack of work
huh twenty-five mips
mips would require
require twenty-five million
twenty-five million instruction
million instruction words
huh load store
store we noticed
earlier was thirty
load store type
traffic which processor
processor will generate
memory ok twenty-five
twenty-five million words
point five words
traffic and data
data traffic load
traffic load store
load store traffic
huh very small
small one point
mem huh memory
huh memory bandwidth
handling this twenty-five
forty and sixty
sixty t possibilities
huh throughput rate
rate for fax
fax and huh
huh photocopy operation
processors and slower
huh i hope
hope these huh
manner and huh
fixed huh rule
rule or procedure
procedure to solve
solve such problems
huh no accumulations
accumulations of data
data or huh
huh getting st
st for huh
huh all traffic
traffic all data
traffic or instruction
traffic is flowing
huh multiple buses
multiple buses converging
add the traffic
out of huh
huh multiple de
multiple de devices
huh we we
takes to print
issue or huh
press a scan
complicated and huh
add the delays
delays because huh
huh these operations
you huh receiving
receiving and sending
sending faxes photocopying
photocopying is taking
interleaved and huh
huh th the
huh bandwidth calculation
two huh wh
huh wh when
bus be free
printer be free
huh that analysis
analysis may require
scenario and huh
then then study
latency is involved
moment any questions
realistic and it
simultaneous but lets
one one disk
huh started transferring
huh get put
lets say they
taking huh twelve
huh twelve point
disk is active
active for twelve
bus is twenty
interleaving of huh
huh the blocks
sources and huh
sixty-four kilo bits
data over huh
so basically huh
interleaved leaving huh
buffer this sixty-four
disk controller end
scsi controller end
end and huh
the then put
bus right let
lets say spent
huh lets imagine
imagine this data
occupying a scsi
shorter period huh
fraction of milliseconds
bus now in-between
contiguously but the
line three point
milliseconds it spends
spends on th
th scsi bus
spend three point
two by huh
basically these streams
bus so suitable
lecture on computer
conclude huh series
lectures so today
stand so lets
first lecture huh
learn how computer
analyze the performance
build the computers
computers and huh
huh improve performance
modern processors issues
issues like caches
caches or memory
memory hierarchy pipelining
covered various topics
topics we talked
set and huh
discussed some code
out to build
out those instructions
constructed a complete
execute these instructions
concept of pipelining
pipelining to improve
memory is hierarchical
array of huh
finally to complete
picture we talked
talked about input
decades and huh
you would notice
growth in performance
single monetary unit
unit so performance
performance per rupee
vacuum tube system
huh the computers
historical into generations
huh focus huh
talking of architecture
interface of hardware
essentially huh machine
huh machine instructions
huh the building
blocks like huh
adders registers multiplexers
registers multiplexers buses
focused is shown
huh risk variety
risk variety reduce
th computer huh
instructions and simple
instruction each instruction
mix many things
things the advantage
building a fast
fast processor huh
processor huh ease
ease of doing
ease of generating
code so huh
instruction we talked
talked about huh
huh nicely fall
beginning and huh
lot of discussion
discussion was huh
design a system
huh power consumption
important and huh
power being produced
produced or power
power being dissipated
chip per lets
lets say square
square centimeters increasing
view we looked
two possible directions
throughput huh throughput
huh several tasks
tasks being executed
user huh execution
basic huh parameters
parameters the instructions
program the instruction
instruction count cycles
period or clock
rate the factor
factor which influence
influence these are
varied the compiler
compiler w generates
architecture what instruction
micro-architecture that means
implement those instruction
performance its important
case and huh
make everything fast
make the common
common case fast
instructions from programming
view and huh
developing some understanding
out to design
processor which carries
out all arithmetic
huh its design
design was done
construction was huh
huh put hardware
hardware in place
huh thirty-two times
additional logic shown
equality comparison so
worked with huh
huh while doing
operations like multiplier
primarily discussed iterative
discussed iterative algorithm
huh thirty-two steps
produce one result
result of the
the one bit
structure here huh
division was done
restoring manner non-restoring
manner non-restoring manner
non-restor non-restoring division
merge the multiplier
hardware and divider
lot in common
huh the key
huh the big
case and left
ways and organize
organize the control
control appropriately huh
make this huh
huh this unit
capable of doing
huh a single
multiplication or division
huh design huh
technique ok huh
takes from huh
improvement to speed
speed up multiplication
looked at huh
possibility using huh
huh carry save
carry save adders
doing iteratively huh
out into huh
adders which add
carry save additions
improves the delay
noticing the limitation
limitation of huh
huh integer operation
operation we talked
talked about floating
floating point operation
the are varieties
four standard huh
issues of huh
underflow so underflow
feature which occurs
occurs in floating
round and sticky
instructions which support
support this type
type of arithmetic
huh having understood
understood how basic
done we looked
process of instruction
instruction executions starting
starting from fetch
fetching of instructions
doing the operation
back in place
design we looked
entire instruction execution
execution is finished
simple combinational circuit
huh data path
clear distinction made
notice the limitations
huh various points
points of view
helps in huh
sharing the resources
implement much larger
variety of instructions
takes the instruction
th this flow
in multiple cycles
cycles each box
box represents activity
execution is divided
divided into cycle
determines that influences
determines how wide
wide the clock
huh the slowest
divide these things
distribute these things
instruction take multiple
cycle but huh
instructions get issued
huh this design
design was obtained
design and introducing
registers which separate
separate pipeline stages
so in terms
terms of concept
simple but huh
notice some hazards
hazards huh structure
huh structure hazards
structure hazards data
hazards so structure
simpler to handle
provide enough resources
occur but data
data and control
inherent huh in
design and pa
huh program logic
provide for huh
huh extra control
flushing out instructions
out instructions huh
instructions huh wh
instruction may fetched
huh for handling
data hazards huh
delay by forwarding
forwarding data huh
in some data
huh a number
huh data flow
flow from instruction
spent several lectures
lectures on processor
discussion on memory
advantage of huh
bulk of huh
huh inexpensive and
inexpensive and dense
advantage of size
manner so huh
typical cache organization
cache organization is
organization is shown
shown here huh
we we looked
organizations direct map
cache with varying
degree of huh
four alternative slots
slots and huh
huh this number
kind of flexibility
placing a block
larger the number
larger the flexibility
number also implies
huh more hardware
doing parallel comparison
parallel comparison huh
huh parallel comparison
comparison and associative
associative huh search
increase the degree
degree of associative
associative the clock
period becomes larger
larger which means
impact on performance
huh the positive
giving more flexibility
flexibility you reduce
throw away huh
space is required
hierarchy is virtual
main memory form
form one level
disk stores huh
process of accessing
accessing huh virtual
finally we moved
first huh lecture
huh a computer
fan on top
huh graphics display
graphics display card
things could of
huh very recent
two three years
part of motherboard
graphics display huh
connected as close
processor memory interconnection
interconnection whereas huh
huh other things
things might sit
sit on huh
points of motivation
huh so ideal
opportunity to design
architecture new instruction
instruction set build
design take place
design or build
huh from software
view this knowledge
huh to write
write better software
software ok huh
ap application level
understanding of huh
huh what architectural
architectural huh com
com are you
software or if
compiler operating system
operating system area
doing a technical
development of hardware
hardware software huh
software huh understanding
architecture and performance
issues is important
purchasing a computer
computing or general
computing in mind
huh embedded computers
embedded computers huh
opportunities and huh
basically designing huh
designing huh huh
huh adapt huh
adapt huh building
building a complete
it its interesting
typically gets sold
sold every year
classes of systems
systems are put
table servers huh
servers huh desktops
desktops and embedded
so the figures
wise over last
last huh ov
varying by orders
server to desktop
desktop to embedded
huh but embedded
embedded are huh
huh very fast
machines per person
com here huh
huh per person
person but embedded
huh other devices
devices various appliances
appliances your mobile
huh num number
purpose computing device
huh intelligent function
nt have user
typically do fix
set of functions
functions they operate
operate in real
real time interact
environment and huh
discussed that huh
address that issue
address the hardware
software design issues
combined hardware software
hardware software co-design
huh a design
size rate power
power and cost
customized so huh
opportunities of huh
huh do doing
doing some interesting
huh where huh
huh the knowledge
th the question
huh different processors
processors huh fo
types of things
huh servers desktop
servers desktop embedded
desktop embedded huh
difference between processors
desktops laptops mobile
laptops mobile phones
phones and appliances
appliances like washing
washing machines etcetera
aspects in performance
difference in power
general purpose huh
purpose huh operation
bit processor huh
processor plus memory
th the program
program and huh
repeatedly just execute
huh so huh
talks of huh
lots of huh
huh real life
briefly and huh
interesting huh possibilities
possibilities so huh
and towards end
attempt to huh
huh take computers
designed by huh
group of people
people for huh
villages the idea
make it huh
affordability for people
people with huh
huh small means
hard disk huh
couple of generations
charged by huh
huh a bicycle
bicycle wireless internet
wireless internet cards
cards which connect
solar powered hilltop
powered hilltop relay
hilltop relay station
huh it connects
linux and huh
language its communication
nt know english
heard of simputer
attempt to build
build a small
small huh low
huh low cost
low cost computer
computer and huh
bangalore the processor
strong arm huh
low power consumption
power consumption huh
and input output
work through icons
text to speech
input but speech
medium of communication
communication so huh
track the information
coming from computer
spoken out and
and the input
touching the icons
computers and modern
carrying out huh
huh some scientific
tree and huh
huh some scientist
wanted to study
study huh th
th the biological
phenomenon here huh
trees and huh
huh they wanted
tree absorb moisture
moisture from huh
atmosphere from fog
fog so initial
attempts were huh
huh to place
lot of heavy
lot of cables
replaced by huh
huh some simple
simple huh sensors
huh sensors miniature
sensors miniature battery
battery driven wireless
driven wireless sensor
wireless the scientist
scientist could move
running huh huge
huh huge cables
safety into huh
automobiles or huh
key to safety
computer based huh
entire huh track
huh track system
system is divided
segments or blocks
blocks of huh
size one point
point five kilometer
kilometer so at
at at places
essentially huh sensors
sensors and computers
system issues commands
commands to huh
supposed to huh
continue or stop
commands and act
fails to listen
putting the details
details here huh
news medium wh
huh basically huh
huh from huh
huh web sources
web sources huh
collected and published
automatically and huh
th that crosses
crosses huh th
th the typical
boundaries and regional
totally different nontraditional
nontraditional nonlocal source
source of news
huh how computers
pieces of art
huh image processing
image processing techniques
computers in huh
diagnosis through huh
huh some interesting
interesting huh applications
device for scanning
vehicle in general
general for security
security so huh
huh what huh
huh the security
increasingly important concern
huh prevent huh
huh some dangerous
thing being attached
car being brought
car the traditional
huh security people
people would carry
carry a mirror
drill but doesn
car so exhaustive
basically a camera
camera base system
units each unit
huh these bright
sources which emit
digital camera video
camera video camera
video camera sitting
lights illuminate th
bottom gets illuminated
illuminated and cameras
cameras take picture
limited huh field
field of view
sees only part
car is passing
passing a camera
small part and
and each camera
camera actually captures
captures a video
video of huh
huh a strip
huh each video
huh you generate
generate a single
requires sophisticated huh
techniques to form
strip of huh
strips are put
form a complete
image is divided
huh the stitching
stitching is done
huh computer it
computer it it
computer is performing
performing huh single
task of creating
creating this image
huh to automate
automate the kind
kind of process
entry exit gates
exit gates huh
huh the car
carry a sticker
windscreen and huh
huh the person
supposed to carry
carry a card
gate the security
check the card
huh identification number
card identification number
person is driving
driving the right
system in principle
huh its impossible
put this kind
works right huh
patience in people
driving to wait
huh which carries
carries huh small
huh small huh
small huh computer
huh computer huh
computer huh so
variation of huh
prom huh erasable
erasable and programmable
basically same processor
processor is sitting
sitting there huh
huh which communicates
communicates with huh
huh this pair
pair of devices
basically huh th
th this th
th the main
source infrared huh
infrared huh sender
sender and receiver
sending and receiving
receiving infrared signals
number is printed
carries my identity
huh a smart
huh this golden
basically a chip
plastic to make
credit card size
card size thing
thing so huh
huh basically th
th this carries
carries the identity
huh well th
th these cards
and and huh
cash also huh
huh electron electronic
electron electronic cash
huh a set
case this carries
driving the car
car and huh
huh this identity
is actually huh
inside this device
you you insert
seek the identity
identity so identity
encrypted and communicated
huh then computer
turn a light
light huh green
green or red
red or open
the are interesting
interesting design issues
battery driven device
driven device huh
power consumption reducing
reducing the power
consumption becomes ex
ex extremely important
consumption is minimized
numerous other areas
specially designed computer
designed computer based
computer based system
system could touch
touch our lives
lives so th
areas very challenging
challenging and huh
lot of excitement
brindha computer
computer architecture
architecture prof
prof anshul
anshul kumar
kumar department
computer science
engineering iit
iit delhi
delhi lecture
processor design
multi cycle
cycle design
discussing design
multiple clock
clock cycles
data path
controller aspects
simple design
single clock
clock cycle
control signals
control steps
meaningful operations
micro operations
simplify establishing
control states
signal values
control part
starting point
key resources
memory register
register file
maximum utilization
intermediate results
instruction register
data register
alu operation
signal indicating
similarly control
alu register
registers multiplexer
class instruction
first cycle
instruction address
relevant fields
bit twenty
single box
cycle number
actual operation
generic sense
function field
last cycle
involve transferring
bits eleven
destination register
careful choice
store word
cycle involves
program counter
address calculation
adding offset
sign extension
memory write
load word
word instruction
address corresponds
calculate address
fourth cycle
cycle memory
memory access
memory address
complete load
doing lot
target address
case branch
condition holds
jump instruction
taking bits
bit shift
single cycle
access required
operation required
total delay
consuming activity
additional cycle
cycle approach
taking equivalent
instruction access
sequencing pins
first clock
clock period
simple activity
clock periods
change things
put things
global view
single screen
main resources
exist memory
file performing
logical operations
operations storing
memory reading
instructions taking
instructions require
first part
common state
things start
state transition
transition diagram
single graph
single state
pro point
important thing
point onwards
instruction group
cycle onwards
complex design
full cycle
opcode decoding
first step
special action
instructions read
common action
branch instruction
energy consumption
result register
instruction tha
beq action
unnecessary activity
common decoding
decoding cycle
operand fetch
fetch cycle
clean situation
common cycles
branch address
separate branches
broader cycle
last states
small finite
finite state
state machine
fetch decode
instruction cycle
small improvement
improvement possibility
cycle common
load store
reduces number
ten states
control signal
res write
signals control
cha state
flow chart
multiplexer decides
accessing instruction
single multiplexer
usual control
cycle data
related control
meaningful operation
micro operation
understandable action
things group
group wise
last multiplexer
write signal
signals pwu
call pwu
correct source
jump address
write output
bring register
signal coming
signal takes
takes multiple
multiple value
binary code
decimal value
default value
write signals
source doesn
unconditional write
activate pwc
correct value
takes care
taking care
taking place
make things
subsequent discussion
relevant signals
read control
signal decides
signals decide
controls writing
multiplexer code
controller design
write read
register load
load signals
memory read
read memory
file group
file write
write rdst
rdst don
case m2r
value rdst
signals rdst
rs2a rt2b
rt2b res2rd
res2rd mem2rt
alu group
bit value
function bits
multiplexer control
store offset
branch offset
simply perform
perform addition
store instruction
address calculations
alu controller
alu perform
perform subtraction
last case
care doesn
arithmetic memory
address branch
symbols put
operation symbol
doing fetch
doing rs2a
control state
first relationship
group memory
memory group
distinct state
arithmetic operation
class instructions
store operation
performs memory
read operation
performs transfer
branch operation
operation branch
branch micro
operation shows
bit vector
vector defines
relevant control
truth table
control design
state transitions
opcode value
conditions wont
truth tables
combinational block
state value
table shown
register holding
bit register
register hold
control operations
operations control
defined relationship
identified control
design microprogrammed
microprogrammed control
previous lecture
started design
multi multi
cycle datapath
microprogrammed design
part design
design pla
part produces
part decides
picture shows
chart indicating
control control
basic operation
signals required
symbolic names
crucial part
implementation starts
indicating don
table description
binary form
part showing
showing black
upto twenty
twenty output
table describes
input coming
twenty signal
present state
column combination
binary equivalent
substitute code
state codes
compact representation
notice lot
input combinations
current state
instruction combination
raise power
power ten
ten entries
ten bits
relevant combinations
fixed state
state numbers
numbers state
state labels
conventional form
column represent
ten bit
bit input
bit output
specific tables
state register
current control
single combination
combination circuit
ten inputs
smaller pla
general purpose
purpose component
combinational circuit
out contents
address word
output column
output part
alternative compare
total number
output circuit
rows running
true logic
false logic
vertical lines
product terms
column number
vertical line
product term
expanded form
compact form
total size
roughly area
dimension multiplied
plane accommodates
plane corresponds
reasonable alternative
define output
last input
expanded truth
simple illustration
raised power
thousand twenty
rom things
small program
small computer
program flow
simple programs
basic operations
generates control
manipulating data
main memory
register files
step involves
micro program
out words
memory based
based design
bit pattern
twenty bits
sequentially word
right address
correct word
micro sequencer
microprogrammed counter
counter part
main program
memory locations
micro programmed
programmed memory
right signals
micro instruction
current value
programmed counter
signals coming
opcode bits
inputs ten
simple incrementer
incrementer adder
simple sequence
branch point
program terminology
lets call
sequence dispatch
specific case
bit field
bits coming
sequence control
small boxes
correct address
small tables
small roms
small plas
main point
small number
ten instructions
low level
level program
single language
language program
simple primitive
primitive operations
line represents
program memory
incidentally micro
control store
first instruction
normal sequencing
doing dispatch
labels beginning
program written
symbolic form
micro assembler
horizontal micro
micro programming
horizontal microprogramming
high degree
low degree
ten words
program run
compact encoding
vertical approach
low memory
memory requirement
lose performance
programmed approach
approach versus
non micro
hardwired approach
machine based
based approach
specific advantages
good work
separate memory
memory chip
program implementation
fixed architecture
internal registers
temporary registers
person working
signal level
microprogrammed level
make access
performance penalty
final state
machine design
assembler fill
today tools
hardwired controllers
controllers starting
multiple options
initial representation
representation level
machine diagram
program micro
sequencing control
control level
state function
dispatch roms
logic equations
implementation level
finally implement
large size
microprogram memory
micro instructions
microprogram counter
determines contents
pipelined processor
last lecture
pipelined design
low cpi
high frequency
maximum benefit
structural hazards
hazards data
data hazards
control hazards
skeleton datapath
normal condition
ideal condition
datapath design
components multiplexers
bit rooters
simple pipeline
pipeline design
design behaves
subsequent lectures
pipelined datapath
simplify things
sign extenders
separate stages
first stage
instruction fetch
fetch stage
instruction memory
decoded control
add subtract
final stage
fourth stage
writing results
pipeline operates
uniform manner
first register
large registers
intermediate design
special case
peculiar thing
thing happening
value generate
lets leave
adding data
data coming
memory output
file output
memory stage
uniform fashion
slight problem
back operation
stage activity
register stages
taking data
bit pieces
register length
extension unit
sixteen lines
allowing thirty
right solution
sixteen bits
idea clear
crucial thing
lets move
control controller
generate control
files multiplexers
thi thi
point lets
longest path
storage element
neglecting treating
real life
small delay
maximum path
path delay
critical path
path delays
data memory
memory delay
choices achieves
hardware cost
length register
register size
universal answer
specific design
things changed
add control
cycle type
multi-cycle type
instruction generates
sig generates
multi-cycle design
state control
organized things
control transition
students asked
fetch state
decode state
instruction suppose
state machines
mealy machine
machine type
moore machine
multiple cycles
decide control
simple change
signal goint
write operation
operation register
small controller
feeding alu
write control
signal result
comparison coming
address coming
output end
decode stage
synchronizing address
current stage
cycle signals
data signals
alu stage
alu control
write back
simple arrangement
inserting register
register extend
sequential circuit
sense carrying
twelve bit
correction required
signal required
enables write
convenience tapping
datas addresses
complete design
design datapath
out jump
interesting point
instruction change
subsequent cycles
instruction code
file operation
small path
out kind
kind arrangement
data hazard
consecutive instructions
value computed
gap depending
deep pipeline
add instruction
register read
read stage
register write
back stage
file half
writing half
ideal cycles
introduce delays
register fields
register field
relevant information
consecutive cycles
information forward
fields lets
write field
write address
read addresses
forwarding path
passed instruction
instruction doesn
value means
basic idea
whats happening
hazards occur
instruction label
instruction freeze
freeze don
point decide
correct thing
branch prediction
inline operation
backward branch
last instruction
static prediction
dynamic prediction
simple prediction
first thing
detect instructions
suitable number
insert bubbles
complex approach
data forwarding
delaying logic
including fetching
hazards require
identify branch
branch instructions
wrong instruction
inline instructions
straight forward
complex dynamic
last question
software solutions
hardware resources
compiler whichever
rearrange instruction
dependent instructions
key line
out instruction
dependent insert
worst case
instruction sequence
similar spirit
put instructions
part lets
extra instructions
delay slots
follow branch
tagged instructions
compiler assembler
hazard data
delay starts
learnt today
inter stage
stage registers
right number
datapath controller
stage involves
data control
hazards requires
requires detection
detection stalling
stalling flushing
handling data
handle data
functionality remains
introduce techniques
instruction sequences
stall cycles
cycles required
additional control
control circuitry
additional path
additional paths
introducing data
previous lectures
introduce inter
introducing controls
things looked
signal pass
data dependent
load instruction
instruction storing
instruction starts
instruction happen
makes sense
written lets
cycle remember
horizontal axis
correct picture
cycle wha
correct values
read values
instruction stays
show instruction
axis indicating
put show
shot snap
snap shots
previous instruction
remain stuck
null instruction
shown alu
alu shaded
moves forward
understanding lets
instruction wise
wise background
inactive stage
nops introduced
stage onwards
alu onwards
profile nop
condition persists
cycle instruction
remains stuck
shown control
define control
operation instruction
null control
subsequent stages
cycle land
inactive situation
operation nop
nop instruction
desired result
first first
hazard condition
back instruction
instruction alu
conditional persists
tow nops
cycles introduced
stage register
means instruction
register addresses
instruction setting
instruction intends
hat instruction
alternative destination
destination addresses
reason suppose
register bates
bubble signal
combinational logic
simple solution
forwarding paths
consecutive instruction
delay introduced
earlier instruction
forwarding techniques
activate means
paths leading
dependent instruction
alu state
cycle delay
solid thing
actual requirement
fourth possibility
alu output
alu input
lets identify
additional multiplexer
normal input
input labeled
multiplexer output
normal path
out conditions
proper value
similar equations
conditions don
first lets
special care
earlier case
destination matches
latest value
relevant register
forward data
similar condition
stage intends
right forwarding
stalling condition
stage reads
alu stages
instruction reached
introduced nops
stage view
define conditions
introducing stalls
control condition
special cases
cases introduce
handling control
mips processor
bypass paths
cases delay
stall cycle
improve performance
branch hazards
eliminating branches
dynamic scheduling
instruction level
level parallel
parallel architecture
nop instructions
stage wise
wise view
subsequent instructions
improve things
derive control
source address
destination address
processor continues
point suppose
address change
target instruction
additional delay
cycle shifts
delay calculation
multiplexer delay
similar action
make contents
simple manner
condition evaluation
subtract instruction
real evaluation
evaluation takes
takes place
preceding instruction
previously instruction
eliminate branches
branch execution
decision making
actual branching
rare event
probabilistic sense
dynamic predication
small illustration
branch elimination
conditional structure
conditional instruction
predicated instruction
conditional branch
mips language
current instruction
means non
instruction explicit
explicit branch
condition testing
start preparation
generate target
instruction find
calculate target
virtual memory
page table
virtual address
real address
omit page
harm done
stretch things
last stages
make space
adverse effect
bit comparison
inequality comparison
fast alu
beq bna
bna kind
simpler comparison
flush instruction
slight improvement
condition code
code evaluation
separate instructions
evaluate condition
hazard situation
delayed branch
unconditional statement
code generator
suitable independent
independent instruction
make branch
treat branches
unconditional branches
means don
branch continues
idea question
fixed prediction
guess inline
branch condition
make choice
forward jump
exception condition
condition checking
dynamic branch
times inside
previous occurrences
sophisticated decision
programmer flexibility
delay slot
exercise option
simple branch
last occurrence
strict forward
forward logic
simple loop
loops back
larger loop
outer loop
predict based
previous outcome
vice versa
loop instance
static branch
branch policy
prediction strategy
bit information
machine remembers
suppose branch
means branch
actual outcome
continuously branch
single loop
general mechanism
double mistakes
actual computation
previous occurrence
constant address
beq type
beq bne
contrantive decibel
decibel memory
field carries
carries instruction
field carry
carry prediction
prediction statistics
first field
match occurs
store target
instruction branch
instruction carries
repeated occurrences
hundred percent
percent accuracy
simple case
global history
means history
recent occurrences
incurring cost
control hardware
wrong decisions
powerful method
avoid stalls
dynamic solutions
doing data
correct action
similar mechanism
producing result
compiler doesn
dynamic pipeline
expensive thing
extra hardware
find instructions
pipeline busy
order instruction
speculative execution
super scalar
scalar architecture
multiple instruction
level parallelism
parallel parallelism
multiple processors
processors doing
doing multiple
multiple instructions
carrying multiple
multiple operations
long instruction
instruction word
coded multiple
instructions put
term vliw
large instruction
compiler driven
driven vliw
vliw approach
basic thing
multiple functional
functional units
multiple alu
handle multiple
basic requirement
support multiple
multiple read
write ports
compiler forms
long instructions
instructions carrying
complicated decode
issue unit
scalar instruction
special instruction
operational fields
alternative architecture
architecture versus
versus timing
top picture
stage pipeline
pipeline lets
decode execute
ideal case
scalar suppose
instructions decoding
instructions executing
instructions doing
single instruction
multiple operation
execute operations
common perspective
modern processors
scalar processors
high performance
performance desktop
desktop computing
computing machines
processors vliw
varied applications
purpose computing
main reason
code compatibility
scalar version
compatibility exists
older machines
code code
instruction set
machine doing
doing executing
code faster
achieve speed
vliw technique
specialized compiler
level pack
source level
level compatibility
object level
commercial point
major issue
processor require
normal scalar
scalar machine
code super
scalar processor
earlier code
code density
cost super
super scalars
higher degree
vlwi technique
technique provided
good compiler
exception handling
exceptional handling
design exception
main problem
showing overflow
page fault
illegal opcode
wrong opcode
makes things
precise interrupt
interrupt means
detect interrupts
machines insist
imprecise interrupts
complexities involved
improve branch
branch performance
performance including
including branch
elimination branch
branch speed
dynamic manner
vliw architecture
basically instruction
parallel architectures
make cpi
real case
vliw manner
scalar manner
engineering,iit delhi
start discussion
set arhitecture
lecture instructions
instructions form
software instructions
instructions provide
hardware point
view instructions
basic behaviour
behaviour definitions
simple instructions
arithmetic operations
addition subtraction
move data
constant operands
machine instructions
machine language
assembly language
basic building
building blocks
maximize performance
performance maximize
maximize efficiency
instructions hardware
power consumption
toy machine
real machine
early eighties
typical architecture
risk reduced
reduced instruction
set computers
eighties onwards
typical architectures
video games
games silicon
silicon graphics
graphics computers
play station
real architecture
toy architecture
fairly simple
short period
full grasp
simple architecture
arithmetic instructions
simplest arithmetic
simplest form
register dollar
special symbol
variable names
mips machine
infix symbols
adding contents
infact simplicity
design goals
simplicity favors
favors regularity
similar format
primitive instruction
bit numbers
bit registers
arbitary sides
atleast make
single step
larger numbers
common case
fast beat
complex expressions
temporary location
high level
level language
first statement
subtraction operation
restate forward
forward manner
hold bulk
bulk data
larger data
data structures
records structures
structures arrays
mips registers
specific locations
dimensional array
array consisting
addressable unit
bit operations
final resolution
individual byte
byte addresses
byte number
power thirty
words thirty
bit words
typically addresses
thirty words
spelling error
big endian
endian means
numbering bytes
significant side
left side
significant bit
right side
endian convention
bit end
machines follow
intel processors
processors follow
convention spark
spark processor
simulator depending
host machine
computer centre
word beginning
fourth byte
logical word
point ending
byte address
word consisting
physical words
excess memory
array add
eigth element
lets assume
integer array
load byte
number thirty
starting address
type integer
data loaded
instruction writes
simple situation
constant indices
complex situation
complex expression
memory perform
arithmetic put
moving data
variable index
small function
temporary variable
standard thing
structural view
put values
multiply instruction
multiply contents
instruction takes
byte offset
final address
variable part
entire address
complete address
register fifteen
load load
opposite order
reverse order
instructions written
machine machine
machine instruction
add operation
registers involved
involved registers
etcetera numbered
previous examples
registers labelled
add dollar
bit word
field specifies
bit fields
first bit
code field
zeros subtract
code divide
machine requires
last field
fuction field
infact subtract
instruction add
numbers numbering
shift amount
shift instructions
fields correspond
register destination
register source
code eighteen
bit number
long string
hexa decimal
decimal form
store instructions
instructions load
machine representation
form uniform
similar nature
good design
design demands
sixteen bit
decimal equivalents
eighteen line
offset thirty
constant part
define flow
bne stands
beq stands
equality comparison
symbolic assembly
instructions allowing
equality doesn
branch statement
conditional branches
testing condition
unconditional branch
instruction symbol
unconditional jump
condition doesn
label lab
instruction subtract
instruction subtracts
instruction addition
control flows
common point
language statement
equality equality
slt stands
slt dollar
set value
equivalent definition
blt suppose
holds suppose
bne types
compare make
make comparison
comparison result
instruction lets
beq follow
assembly form
exact thing
remaining twenty
address slt
slt instruction
fields shift
amount field
define slt
constants put
constant data
possibilities exist
register number
normal add
memory location
logical operation
larger constants
special constant
special register
contents remain
program suppose
separate move
move instruction
large constants
bit constants
instructions deal
bit constant
constant rate
larger design
eighteen twenty
twenty twenty
instruction handling
handling thirty
total thirty
left half
half left
instruction fills
right half
special extraction
load upper
lui upper
upper means
upper part
register left
lui dollar
upper half
instruction ori
lower half
constant put
executed register
small constant
register operand
subtract add
subtract follow
format add
logical instruction
odd man
word store
format lui
lui load
full form
bne bne
equal beq
size adding
smaller numbers
entererd swap
swap instruction
instruction swap
swap operation
key part
load instructions
first multiply
operation bit
bit operation
sixteen positions
first number
sixteen zeros
instruction ors
large constant
natural question
performance point
term means
architectural choices
design alternatives
deign choice
design choice
quantitative metric
precise definition
users perpective
designers perspective
perpesctive suppose
computer system
lab organisation
personal computer
compare performance
performance wise
machine vendor
cost implication
save money
lower performance
performance price
price ratio
instruction sets
major styles
styles load
store style
memory memory
memory style
style stack
stack style
accumulator type
instruction design
design stage
hardware stage
cheapest option
performance means
precised terms
measurable quantity
summary number
good choices
issues involved
involved performance
performance number
performance method
measurement method
summarizing method
design choices
choice performs
doing word
word processing
factors influencing
hardware design
performance factors
architectural issues
instruction style
basic points
computer performance
daily life
aircrafts shows
perfomance comparison
carrying capacity
simple matter
speed concorde
maximum speed
long flights
thousand miles
non stop
stop flight
passenger capacity
carry lets
fifty passengers
achieve whats
points lets
passengers carried
composite measure
view boeing
multiple criteria
multiple machines
aircraft context
wall clock
interactive environment
environment lets
database query
atm type
generic term
out number
machine run
average execution
execution rate
individual user
important factor
lets put
system manager
user community
user programs
single computer
high throughput
waiting times
quick access
machine busy
maximize throughput
complete grasp
improve response
define performance
throughput aspect
individual concern
bigger number
larger number
number represents
takes measure
forward definition
relative performance
performance numbers
numbers performance
power execution
suppose machine
twenty seconds
twenty times
percent faster
concorde versus
versus boeing
travel times
mph divided
twenty percent
percent times
hours divided
reciprocal ratio
compared throughput
pmph figure
figure passenger
capacity multiplied
sixty percent
throughput sense
first comparison
speed sense
current discussion
faster clock
processor replace
faster processor
giga hertz
throughput change
jobs suppose
programs run
improve throughput
taking multiple
multiple jobs
scheduled manner
throughput infact
sharing processor
lab environment
work done
processor takes
ten machines
fifty machines
atm machine
back end
atm machines
similar environment
waiting waitin
practical question
cost factor
aircraft situation
budget limiting
limiting budget
minimum cost
access files
input output
multi tasking
tasking environment
cpu execution
disk access
total cpu
user code
peripheral design
processor architecture
user cpu
scheduling policy
user program
user component
ninety seconds
hundred twelve
twelve seconds
fifty seconds
cpu spent
processors run
periodic signal
ano seconds
seconds cycle
events takes
hardware activity
discrete edges
clock frequency
hundred mega
mega hertz
nano seconds
cpu clock
milli seconds
cycles divivded
clock rate
cycles depend
instruction count
cpi stands
write cpu
count multiplied
cpi multiplied
cpi divided
thee quantities
equation cpu
program cpi
instructions cancel
left hand
hand side
side seconds
seconds required
lets illustrate
fifty mega
find execution
thousand instructions
find cpu
thousand cpi
ten raised
power minus
seventy macro
macro seconds
frequency increases
case clock
factors remain
inverse ratio
clock rates
direct ratio
fractional cpi
hardware takes
takes longer
individual instructions
instructions suppose
instruction types
individual instruction
present fifty
fifty percent
category twenty
ten percent
percent branches
alu instruction
instruction cpi
alu stands
arithmetic logic
logic unit
unit instruction
cycle load
load takes
store takes
cycles branch
branch takes
find cpi
taking fraction
instruction spends
doing alu
alu instructions
doing load
load instrution
total cpi
fraction point
fourteen percent
processor spends
spend maximum
doing loads
efficient manner
integer operations
floating point
point operations
operations floating
operations memory
memory accesses
accessing registers
instruction depends
cycle faster
cycle right
multiply operation
period multiplied
composite effect
formula seconds
program multiplied
program right
simple equations
complicated statement
statement lets
ten seconds
computer design
expensive technology
cpu design
design causing
causing machine
target pardon
doubled reduce
first case
system cpu
system means
means operating
operating system
architecture today
exciting area
integral part
daily activities
typical computer
storage capacity
nineteen fifties
big hall
sitting today
common form
weather prediction
prediction nuclear
nuclear simulation
astronomical calculation
bio informatics
computing power
small computers
home appliances
appliances cameras
cameras mobile
mobile phones
entire variety
computers entire
entire diversity
common principle
term computer
computers work
basic principle
important issue
performance people
wrong notion
chip area
basic principles
computer works
construction aspects
sophisticated techniques
todays architectures
memory structure
modern concepts
advanced courses
basic features
modern computers
improved version
existing system
small today
software stream
devolping software
good understanding
stream understanding
agin understanding
basic performance
embedded computers
design opportunities
embedded component
computer achitecture
architectural buildings
buildings building
building architecture
decide functionality
residential building
living area
dining area
civil engineer
structured design
strains durability
computer architect
logic design
circuit design
functionality realise
circuit designer
basic components
transistors registers
registers capacitors
design aspect
find abstractions
abstraction means
out details
circuit point
mind boggling
software abstraction
essentially solution
trivial function
language programmer
eqivalent program
simple computation
right place
circuitary inside
inside processor
last statement
assembler assembler
forward process
machine code
number number
number notation
decimal number
base sixteen
decimal digits
decimal notation
binary notation
notation inside
binary numbers
program data
numbers don
hardware understands
major module
processor cpu
central processing
processing unit
output devices
mouse keyboard
keyboard display
display disk
disk drive
system bus
memory bus
bridge connecting
labelled cpu
sub divided
counter register
file alu
bus interface
interface program
file stores
stores operand
arithmetical logical
logical relational
relational comparison
comparison operation
large number
basic devices
devices transistor
transistor register
harware level
sub systems
complex electronic
components mounted
bottom side
floppy disk
hard disk
drive cdrom
parallel bar
heat sink
output cards
processor area
slots pci
memory module
package form
individual memory
memory chips
complete memory
memory system
seagate hard
disk controller
controller circuit
highest level
language programs
lowest level
hardware side
major building
building block
block registers
registers adders
individual components
hardware software
software boundary
basic capability
major harware
harware components
machine defined
hardware designer
hardware levels
software architecture
set level
micro architecture
architecture level
set architecture
architecture refers
flip flops
basic unit
logic modules
typical view
place instruction
application programs
system software
level programs
compile load
execute programs
broad cpu
lower level
physical dimension
physical manifestation
language view
view defines
processor state
execute instruction
state defined
defined state
memory contents
permanent data
hardware components
files alu
hand held
held devices
devices devices
computers lap
lap tops
consuming power
large rate
out computation
dominating issue
suitable trade
extreme power
power saving
require lots
architect lies
making right
right choice
specialized structure
create functions
program abstractions
key components
alu registers
registers condition
condition codes
desired operation
right thing
providing branches
level languages
sophisticated processor
simple processor
specific examples
common thing
processor works
simple instruction
real problem
real situation
memory words
supposedly integers
understand mathematics
real programs
real hardware
finite number
real numbers
finite precison
finite range
nice properties
real number
mathematical domain
real instructions
life program
asembly language
physical reality
abstract model
unbounded array
physically memory
fixed number
flat array
hierarchial structure
real practice
discussion focuses
asymptotic complexity
bottom line
theoritical consideration
seconds seconds
computers domain
designing hardware
embedded processor
intelligent function
conventional view
computing engine
proces information
communication opens
application possibilities
embedded computer
computer domain
embedded domain
embedded application
customized design
standard processor
completary design
simplest part
desk top
top computers
phones washing
washing machines
executing instructions
tremendous difference
consumption cost
purpose means
top computer
power point
point presentation
special purpose
purpose computer
mobile phone
specific task
top processor
pentium processor
micro controller
actual chip
small rectangular
rectangular tcq
circular window
big space
packaging requirements
forty pins
accommodate forty
smaller packages
roughly lets
contrasting devices
purpose processor
performance consumes
consumes lot
purpose applications
lower power
right works
transparent window
quartz window
program inside
make correction
ultra violet
violet light
memory content
major topics
architectural aspects
specific instruction
instructions work
express computation
doing instructions
design aspects
arithmetic unit
build circuitory
put register
put buses
put program
data flow
common technique
performance system
important component
good performance
reasonable cost
devices input
output controllers
announcements put
lab exercises
similar list
incidently doctor
doctor kolin
kolin paul
preparing presentation
presentation material
teaching assistant
harsh dand
lab homepage
first lab
lab exercise
make submission
computer services
services centre
main book
computer organisation
organisation design
software interface
system design
terms computer
design computer
organisation computer
term architecture
design refers
hardware building
building aspects
minors majors
majors lab
class asignment
discussed today
peripheral computer
computer interface
phone mobile
understand computer
processor memory
main functionality
user point
computer point
palm palm
palm top
communication variety
computers history
studying history
good insight
political history
economic history
significant impact
past half
landmark development
regular generation
develop computer
computer systems
electronic system
major technological
technological development
development takes
drastic sudden
sudden change
size size
earlier computer
large organisations
individual computers
computer density
appliances mobile
situation today
extended periods
first generation
basic device
vacuum tube
tube vacuum
basic electronic
electronic device
switch voltage
current levels
expensive bulky
huge roomful
punched cards
paper tapes
rotating drum
magnetic rotating
generation computers
generation ends
rapid transition
growth development
development improvement
generation change
texas instruments
transistors perform
similar function
smaller faster
faster cheaper
language people
people started
early versions
fortran cobol
technology moved
single silicon
silicon chip
integrated circuits
single device
early chip
chip depending
ssi msi
lsi ssi
ssi stands
small scale
scale integration
integration medium
medium scale
large scale
naturally equipment
equipment computer
speed increased
efficiency increased
additional peripherals
paper tape
batch processing
processing environment
punching program
central facility
small syntactic
syntactic mistakes
full stop
program result
error message
correction submit
tedious process
computing started
online mode
major change
change occur
vlsi appeared
entire processor
single chip
arise lsi
vlsi vlsi
vlsi stands
scale integrated
ulsi ultra
late seventies
infact tens
initially vlsi
individuals owning
personal computing
computing home
home computing
means computers
large system
graphical user
user interface
fourth generation
microprocessor era
find mention
technological revolution
artificial intelligence
parallel processing
input outputs
human life
generation computing
massive project
previous definition
previous generation
hardware technology
technical features
performance divided
unit cost
astonishing improvement
relative scale
tube transistor
transistor integrated
integrated circuit
years nineteen
cost raises
interesting thing
memory capacity
entire period
dynamic ram
basic semiconductor
semiconductor memory
computers today
linear rise
log scale
exponential rise
early period
twenty years
capacity change
half years
capacity doubles
graph shows
complete computer
include performance
performance contribution
contribution made
single figure
ten years
years period
early machines
mix machines
machines ibm
ibm machine
key developments
technology changed
significant events
major events
events beginning
first programmable
programmable computer
konrad zuse
nineteen forty
harvard mark
harvard architecture
storing program
storing data
commonly today
single memory
accomodates program
memory units
previous attempts
computers developed
formed basis
pin point
competing claims
john fon
fon newman
store program
takes instruction
simple idea
changed history
commercial computer
kind system
research lab
first computer
ibm enters
significant player
language fortran
first high
original form
fortran seventy
nineteen fifty
first version
stanford research
research institute
banking industry
magnetic ink
ink corrector
corrector reading
ics integrated
circuits date
computer game
game nineteen
nineteen sixty
computer mouse
computer network
network arpanet
network developed
defence funding
funding arpa
arpa stands
advanced research
research project
project agency
defence agency
funds research
research projects
integration begins
first memory
first dynamic
ram chip
first microprocessor
flexible storage
storage unit
flexible disk
flexible nature
ethernet computer
computer networking
nineteen seventy
first computers
first home
home computer
consumer computers
popular computers
apple trs
trs eighty
spreadsheet program
first spreadsheet
visicalc developed
first word
word processor
processor wordstar
wordstar nineteen
important landmark
nineteen eighty
personal level
series computing
earlier consumer
consumer computer
reaped maximum
first operating
microsoft operating
system msdos
apple lisa
lisa computer
extensive gui
graphic user
textual interface
give command
graphic interface
popular computer
apple apple
apple macintosh
traced history
end lets
early computer
ibm ibm
compute tables
tables indicating
indicating moon
moon positions
apollo flight
fifty multiplications
pumched tape
vacuum tubes
control voltage
ideal size
required floor
floor space
twenty feet
feet twenty
forty feet
feet univac
first commercial
magnetic tape
tape printer
printer memory
memory size
thousand words
words thousand
thousand numbers
twelve digits
delay lines
magnetic tapes
fifty thousand
todays system
similar order
popular systems
systems ibm
cdc sixty
modern day
day processors
architectural details
details illiac
parallel system
system developed
illionos urbana
urbana champaign
major attempt
large parallel
high computers
computers computers
computers shrunk
mini computers
type writer
crt monitor
picture xerox
xerox alto
alto machine
first work
work stations
powerful desk
fledged capability
large computer
good user
pirating work
developing window
window based
based interface
granted today
super computer
early super
super computers
computers cray
performance computer
highest performance
circular form
wire length
cable short
extensive cooling
high speed
interesting pictures
atomic dimensions
specific elements
nano technology
technology area
area nano
technology means
nano meters
computing refers
spread world
massive number
hundred thousands
single problem
computing capability
extended quantum
quantum computing
computing based
quantum principles
tough computing
computing problems
dna computing
complex structure
technologies develop
depth understand
programmers point
discussing instruction
level architecture
arithmetic add
bne instructions
large thirty
loads upper
instructions format
register format
bit opcode
controlled constructs
thenelse type
simple check
typically beq
bne instruction
executing loops
switch type
mips instruction
subtle differences
lets start
summing elements
forward thing
unusual form
main body
submit update
perform loop
loop termination
termination check
forward move
single statement
first element
word loaded
running sum
index compare
means start
blt instruction
instruction blt
pseudo instruction
real instruction
pseudo instructions
blt compares
slt slt
slt compares
assembler temporary
temporary value
intermediate value
special role
assemblers usage
assembler directives
data area
code area
dot data
directive dot
dot space
hundred bytes
area leave
leave space
size hundred
dot text
load address
symbolic language
data directive
default data
arbitary size
size thirty
register requires
step loads
lower right
lui instruction
right portion
data fill
output code
faster code
improve code
modification made
performing sum
extra statements
pointer updation
lesser number
extra statement
loop efficient
hundred times
address dollar
previous case
initial address
address preparation
preparation steps
remaining part
notice whats
loop question
check pointer
final value
final code
programmed lets
nested loops
simple sorting
sorting algorithm
first position
loop makes
main step
key position
first outer
first iteration
position scan
interchange step
initial position
end value
last element
comparing elements
elements pointed
updated comparison
pointer initialization
statement prepares
comparison purpose
comparing limits
limits pointed
element pointed
abstract sense
earlier lecture
values pointed
blt statement
cross fashion
interchange manner
jump instructions
control structure
boolean comparison
false outcome
result falls
small pieces
switch statement
break statement
repeated comparisons
multiway branch
register content
starting addresses
label exit
add statement
jump table
table starting
prepared address
location address
properiat address
forward code
code doing
non continuos
continuos values
table approach
specific cases
thousand lets
twenty thousand
thousand fourty
thousand sixty
address thousand
general approach
base address
blt bge
lets begin
type load
register register
index register
base register
exact effect
negative right
offset lies
twos complement
complement form
complement notation
representation detail
word address
double word
exist instruction
varying size
aligned boundaries
instruction addresses
current position
positive offset
negative offset
instruction assembler
word offset
speaking notice
hardware implementation
hardware convenience
full fledged
fledged thirty
bit address
instruction dot
dot dot
dot twenty
lsb twenty
bits twenty
memory space
effectively twenty
byte twenty
current segment
power twenty
exception case
jump statement
initial value
last point
last word
thirty bit
instruction specifies
learned today
simple compare
branch statements
simple loops
loops nested
loop begins
tight loop
efficient loop
small nitty
nitty gritty
gritty improvements
compiler point
compiler writters
generate code
efficient code
improved code
inefficient program
final form
systematic tranformations
subtle manner
instructions address
point computer
important programming
programming language
language abstraction
build program
hierarchial manner
construct large
large program
logical instructions
constant comparison
jump load
store load
arbitary location
made load
address load
procedural abstraction
last class
times thinking
arbitary piece
single operation
control linkage
means tranfer
control returns
sub data
data flows
procedure parameters
result flow
calling program
carry values
carry value
local storage
storage decorations
procedural function
function multiple
multiple times
fresh allocation
global data
local data
previous picture
direct recursion
indirect recursion
control flow
flow data
global storage
sorting program
double loop
main operation
operation inside
suppose define
xchg exchange
assembly level
place instructions
call instruction
jal jump
link jal
jal stands
treating xchg
label attached
jal instruction
call transfer
additional thing
current address
return address
address register
return value
global values
return statement
takes contents
stored return
provide control
passing parameters
simplest method
specific registers
registers designated
cover lots
common cases
additional parameters
specific memory
simple extension
storage suppose
array declaration
storage area
area code
continuous allocation
code part
specific convention
data part
storage assignment
nested calls
calling fuction
return point
first call
call occurs
endless loop
procedure huh
last thing
location load
sorting case
case sorting
sorting problem
minimum value
start scanning
location pointer
loop call
exchange condition
conditional exchange
exchange compare
exchange update
exchange lets
callee understand
min procedure
exchange updates
forms body
address call
suitable offset
recursive call
recursive calls
parameter exchange
start return
appropriately exit
fixed memory
subsequent calls
generated inside
subsequent returns
return takes
original entry
entry point
natural structure
natural data
data structure
out structure
calls occur
out manner
return addresses
function push
direct instructions
stack pointer
make stack
stack grow
reducing addresses
increasing addresses
maximum address
start building
building stack
lower addresses
decrement stack
create space
side observation
listed subtract
negative constant
pointer put
desired register
pointer increase
longer considered
recursive environment
return doesn
fresh values
stack stack
declared suppose
local array
fixed address
natural place
earmark space
local arrays
local structures
longer required
pay attention
assume availability
occurs control
require register
conflict imagine
finishes tells
fixed vision
partial computation
convention helps
write programs
write program
leave values
partial results
callee feels
transparent manner
callers value
work left
concerned caller
similarly registers
caller requires
conventions define
case required
register names
hardware constraint
dollar eighty
expanding pseudo
instructions requires
temporary calculation
assembler dollar
parameter passing
basically number
returning values
passing values
saved temporaries
global pointers
continuous area
frame pointer
hardware wise
instruction assumes
hardware doesn
return instruction
general instruction
activation record
systems follow
everytime function
activation records
pointer points
first location
last location
previous activation
local local
make reference
top everythinh
dynamic storage
storage allocation
dynamically allocation
longer act
reference point
point accessing
constant offset
point offsets
lets summarize
summarize lets
basic ideas
first issue
arranging procedure
procedure call
follow lot
complex recursive
recursive procedure
record creation
data allocated
local link
function proceeds
link record
constant offsets
dynamic part
complex methods
simply access
aggregate terms
push arguments
push return
push registers
matched infact
common source
pops match
memory allocated
pointer stack
entire memory
typical case
data areas
opposite direction
direction grows
random allocations
automatic allocations
return happen
fixed partition
stack area
heap area
count policy
total space
program works
fixed space
recursive programs
previous class
sub routines
register usage
temporary areas
temporary words
recursive procedures
temporary values
create activation
function call
main funtion
sorting procedure
merge sort
recursive manner
recursive implementation
crucial points
assembly implementation
main function
sort function
recursive function
maximum dimension
actual size
sorted values
forward function
input perform
elaboration lets
merge function
function merge
recursive funtion
sub matrices
matrices sub
sub arrays
parts sort
equal halves
output output
temporary array
sorted arrays
stright forward
small thing
variable size
size array
maximum value
split portion
local variables
variables initialised
max limits
smaller element
larger element
creating array
array sorted
sorted array
ascending order
remaining elements
tail end
defining activation
records creating
lets define
merge procedure
parameters addresses
addresses starting
reserve space
parameters return
put upto
creating activation
smaller activation
entire requirement
usual convention
additional registers
procedure sort
array addresses
integer value
similar idea
entire array
half upper
defined activation
showing part
main loop
transfering elements
local values
instruction bge
bge branch
begins loop
steps multiplication
preparing address
register stored
loop ends
offset required
procedure merge
entire procedure
calling point
sort procedure
additional record
statement takes
starting twenty
twenty word
means eighty
eighty bytes
actual argument
forty forty
thethird statement
statement requires
requires correction
twenty forty
forty words
sixty bytes
sixty offset
offset bring
twelve bytes
created activation
small activation
record filling
simple single
temporary data
first load
load statement
statement loads
loads return
adding twelve
jump register
register brings
current invocation
values adress
store forty
store return
sort call
address place
lets pick
offset twenty
minus twelve
top position
offset forty
eighty eighty
record generation
space required
arrays twenty
stack dispose
pointer minus
assembly encoding
lab work
array size
pointer version
first write
assembly version
large activation
stack grows
analytical calculation
recursion related
maximum stack
stack size
additional code
empty stack
stack assign
value decreases
update value
maximum size
actual value
parameter value
input array
data size
present algorithm
algorithm written
space usage
create array
array everytime
recursive functions
entire usage
crucial decisions
easily access
access data
stack fill
return recover
today computer
architecture space
understand instruction
mips architecture
things work
level close
architectural space
main key
key features
key points
key characteristics
terms risc
set computer
complex instruction
architectural styles
lecture today
main things
storage structure
purpose registers
address space
represent instructions
binary patterns
predominant features
characterize mips
complete mips
basic instructions
common operation
small set
operations exist
relational operation
equal branch
slt operation
procedure linkage
data bringing
bringing data
non integers
sixteen registers
equal ease
register numbers
register play
specific role
value doesn
procedure linkages
harder fast
curent instruction
thirty minus
mega bytes
spaces empty
addressing mode
access operands
addressing modes
right column
mode register
register addressing
mode base
relative pseudo
register indirect
constant operand
first addressing
source operand
destination result
jump target
divide slt
slt beq
base addressing
addressing involves
resulting address
address refers
assume operands
destination source
relative addressing
implicit register
addressing refers
bytes hundred
hundred words
direct addressing
specifies address
address field
link instruction
constant field
significant end
zeros forms
bit byte
direct address
indirect addressing
register points
specific instructions
instruction opcode
independent manner
orthogonal parts
last feature
address fields
common format
largest number
arithmetic logical
comparison instruction
format type
limited number
instruction formats
fair number
registers thirty
small exception
implementation comparison
simpler hardware
arbitary comparison
instruction perform
wide number
logic operation
constrasting architecture
things change
common feature
program computer
complex operation
memory increments
comparison succeeds
incrementing comparison
logical sense
single instructions
program compact
negative side
flip side
machine slower
hertz pentium
hertz periodic
operations occur
individual cycles
negative impact
fast clock
clock ticks
small cost
small instruction
basic necessity
complex instructions
crucial factor
accessing data
register work
work faster
register operands
instruction instructions
out memory
accessed fact
operand fields
operand sources
address architecture
main computing
computing instructions
address machines
result replaces
acc stands
address instruction
real examples
address machine
stack machines
stack perform
address instructions
beq instruction
register organization
fair amount
amount fair
registers lets
extreme cases
single register
registerless machine
stack organization
registers accumulator
accumulator based
based machine
sun sparc
register window
additional addressing
instruction size
indirect address
support address
making access
indexing mode
data value
mode interpretation
register index
constant index
sequential access
increasing order
decreasing order
auto increment
auto decrement
decrementing depending
pre decrement
post decrement
post increment
make memory
stack based
textual data
data characters
accessing half
half words
full word
full words
double words
words lets
point numbers
specific provisions
comon cases
complete generalization
cisc risc
risc stands
cisc stands
popular machines
main features
formats simple
register based
based architecture
lower cost
henassi architecture
mips processors
computing application
risc architectures
architectures developed
developed berkley
berkley found
sparc architecture
fact beginning
architecture developments
risc type
cisc architectures
continue today
cisc kind
commercial reason
reason describing
risc architecture
precison architecture
hewlett packard
packard motorola
motorola developed
leading cisc
cisc machine
machine manufacturer
alpha architecture
modern architectures
term risc
performance machine
cisc architecture
company dec
digital equipment
equipment coorporation
popular mini
mini computer
pdp level
complex set
non uniformity
interpret instruction
wide range
complex objective
compact code
crucial components
system program
program operating
critical parts
entire operating
operating systems
compilers found
entire set
optimal program
program generate
good code
set compilers
produce machine
hand written
written code
code programs
substantial size
classical examples
cisc machines
ten twenty
forty sixty
long history
bit version
bit processors
modern pentium
money means
performing processors
processors today
elegant architecture
beautiful architecture
things run
set complexity
main issues
instruction execution
design principles
simplicity requires
smaller structure
structure working
smaller operands
make compromise
done lets
ninety percent
remaining ten
architecture examples
understanding instruction
directions architectural
architectural developments
cisc stacks
efficient implementation
powerful features
programmer today
salient features
recall risc
simple thing
instruction performing
risc style
risc motorola
earlier machine
nineteen sixties
numerous examples
earlier times
times seventies
seventies machine
machines vax
code minimize
code size
motorola sixty
processors starting
thousand ten
intels eighty
earlier sixteen
bit macro
macro processors
intel eighty
company including
including ibm
ibm motorola
semiconductor manufacturer
macro processor
processor development
early seventies
main rival
intel apple
apple started
small desk
top personal
personal computers
ibms experience
xcxc series
major companies
ibm system
initially power
bit architecture
late nineties
bit kind
hundred series
machintosh systems
embedded versions
wide variety
similar principles
instruction area
condition register
reset depending
previous arithmetic
instruction slt
instruction result
special bits
simply subtraction
special registers
link register
unlike dollar
link addresses
double purpose
procedural linkages
loop address
address stored
count register
store iteration
iteration count
special instructions
facilitates execution
register filelds
main opcode
opcode field
opcode extension
sixteen minus
condition bits
enable condition
condition setting
disable condition
set condition
additional mode
accessing memory
indexed addressing
index addressing
register contents
accessing array
constant indicating
half word
increment auto
modified value
carries information
long constant
bits rest
smaller constant
fourteen bit
bit displacement
specific register
indirect jump
control transfer
transfer based
require address
index index
index mode
update version
lwu means
counter maintained
register lets
negative value
term sparc
sparc stands
scalable processor
higher word
word size
open architecture
companies sun
instruments toshiba
toshiba fujitsu
fujitsu cypress
cypress tatung
tatung etcetera
extension fields
bit extension
extension field
sizes thirteen
thirteen bit
bit twelve
uncnditional jump
complete addressability
thirty bits
arithmetic type
interesting feature
register windows
size differs
program sees
larger requirement
memory save
fresh set
regular fashion
local output
windows change
global registers
first state
pass parameters
window slides
globals remain
carried information
local usage
cwp stands
current window
window pointer
suppose cwp
return occurs
finite set
windows act
registers acts
cyclic buffer
practical purposes
rare cases
vax architecture
pdp eleven
successful mini
bit machine
dec started
manufacturer system
system manufacturer
vax brought
larger memory
unlike thirty
separate register
key feature
extreme orthogonality
instructions support
specific addressing
intel machine
instructions lots
bit hard
byte stream
opcode specifies
things opcode
specifies operations
operand types
integers reals
double precison
precison bytes
data types
character strings
byte represent
digit coded
bits theer
constants thirty
register carries
term deferred
deferred refers
register mode
mode means
operand register
register deferred
deferred means
access cycle
displacement displacement
sixteen thirty
deferred version
operand size
size autoincrement
autoincrement autodecrement
data transfer
transfer variety
peculiar things
implies thirty
integer integer
naturally don
make sense
sixteen modes
byte carry
size varies
varies depending
registers suppose
additional bytes
decimal numbers
digits packed
packed digits
digits means
smallest number
digit unpacked
pack pack
operand specification
long numbers
long strings
lets talk
bit thirty
major breaks
sixeen bit
bit processor
processor eighty
reasonable amount
companion floating
point processor
processor coprocessor
kilo bytes
demand increased
sixteen mega
newer addressing
eighty forties
forties eighty
pentium pentium
pentium pro
pro pentium
higher performance
performance mmx
multimedia extension
simd instructions
performing operations
core instruction
interesting comments
history illustrates
golden handcuffs
maintain compatibility
adding features
adding clothing
packed bag
complex architecture
pursued manner
commercial success
large quantities
vax supports
complex addressing
similar set
scaled index
permitted combination
correspondence vax
peculiar combinations
saving grace
small subset
register structure
major thirty
ebx ecx
ecx edx
extension extended
bit architectures
eax ebx
quarters refered
earlier versions
ebp esp
esp edi
base pointer
source index
destination index
usual meaning
source string
destination string
individual element
bit segment
segment registers
code segment
segment stack
stack segment
segment data
data segment
segment register
access sixty
multiplication factor
twenty bit
bit addressing
fledged twenty
instruction pointer
peculiar feature
sense modifies
unlike vax
vax case
default size
default segment
default address
address size
effective instruction
important features
powerful set
significant feature
windows vax
strongest feature
performance evaluation
peformance issue
individual users
quantitative manner
large community
higher level
real measure
entire program
average cpi
average cycles
inverse manner
important talk
basic architectures
relates cycles
conversely clock
instruction rate
entire picture
program takes
fast rate
total instruction
convenient unit
million instructions
average rate
executed right
micro seconds
average people
peak mips
instantaneous rate
slow instructions
fast instructions
fastest instructions
nut shell
individual programmer
stages people
represent performance
program number
average number
instruction average
dynamic number
instructions executed
right term
data program
common pitfall
true indicators
isa lets
ten nano
quantities remain
equal number
program expressed
vary clock
varying cpi
common factor
suppose put
compiler designer
alternative sequences
language computation
alternative ways
cycles spent
cycle clas
code sequences
first sequence
ten cycles
compare number
cycle information
slow instruction
fast instruction
cycles divided
similar situation
program situation
compiler produces
produces ten
ten million
higher mips
total ten
million cycles
cycle takes
takes point
seconds multiplied
ten miliion
miliion cycles
seventy mips
seventy million
right lets
fifteen million
spent point
spendind point
twelve million
eighty mips
comparison criteria
program generated
faster mips
poor report
clock fifty
case seventy
longer clock
shorter cycles
execution times
remaining factors
taking thirty
percent longer
redesigned possibility
rate keeping
combined effect
complex situations
focussed user
single program
long system
system works
work load
compilations editings
editings run
scientific application
typical work
general sense
evaluating performance
general attempts
basically programs
user runs
commercial applications
false improvement
false sense
related performance
varied complexity
small simple
simple benchmarks
small benchmarks
computer vendors
optimized code
system performance
evaluation cooperative
joined hands
defining benchmarks
benchmarks declaring
declaring performance
performance summarizing
common platform
small artificial
synthetic programs
standard implementations
implementations define
test inputs
large programs
machine work
benchmarks number
critical code
valuable indicators
total environment
standard high
machine combination
typical result
benchmak tests
showing comparison
benchmark figures
lighter colour
enhanced version
vertical axis
performance rating
higher number
number means
running running
program finding
scaling factor
pair corresponds
compiler takes
marginal improvement
circuit optimization
optimization program
program spice
simulation program
lisp interpreter
light orange
dark orange
dramatic difference
clever trick
dramatic performance
performance improvement
startling results
benchmarks beginning
integer computation
spec int
heavy numerical
numerical computation
typical programs
symbolic computation
numeric computation
integer case
compiler simulator
simulator lisp
intelligence program
program plays
motorola eighty
chip simulator
processor gcc
compiler compress
interpreter ijpeg
ijpeg ijpeg
graphics compression
compression decompresion
decompresion perl
language perl
manipulates strings
prime numbers
numbers vortex
database program
program tomcatv
mesh generation
generation program
shallow water
water model
quantum physics
physics astrophysics
partial differential
differential equations
simulates turbulence
cube solves
solves problems
temperature wind
wind velocity
pollutant distribution
quantum chemistry
plasma physics
applications change
machines change
benchmark content
current set
answer variety
rate doubles
int set
performance varying
proportional factor
suppose cycles
memory speed
additional cycles
effective cpi
processor frequency
memory effect
small domain
things memory
physical systems
slower clock
simple question
machines pentium
point performance
put notice
performing pentium
instructions pentium
lower clock
out perform
architecture improving
improving instruction
set improving
implementation improving
improving compiler
important law
amdahls law
performance figures
program execution
big rectangle
rectangle represents
shaded area
effect rest
part remains
find figure
enhanced fraction
fraction subscript
subscript enhanced
speedup subscript
fraction lets
fraction remains
program speeded
noise captured
taking half
speeding speeding
large factor
total speedup
half remains
improvement factor
program runs
hundred seconds
multiplication instruction
eighty percent
adding subtracting
subtracting loading
loading data
memory taking
taking decision
decision branching
multiplication dominant
dominant program
speedup factor
factor required
sixteen times
huge improvement
times improvement
net result
common part
earlier fifty
small fraction
point capability
suppose floating
point instructions
times execution
point enhancement
executing floating
smaller fraction
question suppose
point unit
unit described
point hardware
desired speedup
previous program
point improvement
thing runs
original program
point computation
processor performance
simple terms
hertz today
factor performance
performance improves
simplifying assumptions
memory improving
assumed memory
performance indicator
mega flops
operations people
understand measure
reflecting performance
good benchmarks
standardized benchmarks
aspect measures
mind amdahls
performance execution
simple formula
compiler technology
technology instruction
architecture micro
basic circuit
circuit technology
fabrication technology
large fraction
prof.anshul kumar
binary arithmetic
alu design
design today
arithmetic operators
logical comparison
understanding micro
bit operands
subtraction multiplication
multiplication division
starting today
result exceeds
divider design
simple add
key operation
binary representation
mips instructions
inherent meaning
fractional number
logical value
encoded form
depends decides
difference ways
ways depending
integers represented
mathematical point
positive numbers
macro ticks
integers ranging
negative numbers
numbers number
choices existent
represent fractions
makes thing
test string
pattern representing
representing numbers
sign magnitude
represent magnitude
positive sign
negative sign
bits situation
integer shown
bits gap
positive side
word handling
positive number
turn zeros
shows whats
twos compliment
compliment representation
number coincide
unique representation
negative points
negative point
important positive
positive point
positive feature
work simpler
negative number
righting num
equivalent values
decimal base
largest positive
smallest negative
represents minus
largest negative
max int
int maximum
positive integer
min int
negative integer
compliment form
complicated life
positive integers
sign twos
compliment number
number perform
correct answer
subtract operation
operation ignoring
adding minus
answer subtracting
negative answer
carry flowing
earlier question
answer lies
represent minus
large positive
number minus
unsigned number
number systems
representing minus
binary number
subtracting twos
adding series
super flows
flows carry
representation bring
doing subtraction
subtraction suppose
carry subtraction
additional fact
programmable add
large integer
small integer
bits number
shorter integers
bit integers
sign bit
additional sixteen
sixteen point
point addition
sixteen places
positions filled
signed extension
additional bit
bit spaces
instruction load
load half
byte pixel
byte position
sign byte
unsigned byte
signed bit
unsigned lbu
bit bit
bit replicates
performing addition
simples method
addition bit
bit position
position adding
carry coming
bit addition
cascade array
carry signals
initial carry
compliment notation
signed number
number unsigned
unsigned numbers
bit adder
adder module
table defines
defines row
columns label
column label
means sum
unique case
boolean equations
boolean equation
defined whats
whats circuit
crado map
digital electronics
cardo map
minimal representation
product form
boolean expressions
expressions representing
representing output
input gates
representation means
stage logic
terms formed
form connection
complex issue
digital hardware
signed numbers
put inverter
thirteen bits
bits subtractor
slight difference
single circuit
multiplexer multiplex
put multiplexer
subtraction depending
control input
calling binv
binv standing
inverted input
blue boxes
carry input
signal binv
bit vectors
performed bit
lets combine
subtraction anding
anding oring
present target
bit unit
alu thirty
first unit
carry position
binv position
operation control
full instruction
low subtract
andi ori
subtract concern
instructions add
large numbers
large negative
exist limit
numbers differ
maximum negative
subtraction remains
overflow detection
unsigned versions
unsigned version
small unit
memory interpreting
key unit
brings unique
performing operation
subtraction hardware
doing addition
logical functions
commutate instruction
beq makes
makes comparison
equality check
key component
include comparison
permissible limits
overflow condition
logical part
unsigned fashion
addition operation
unsigned counter
counter parts
shift operation
controlled inputs
identical units
small multiplexer
selects output
blocks thirty
bit alu
lets address
hardware built
result check
positive negative
perform comparison
direct comparison
equate comparison
comparison giving
cursive definition
recursive definition
addition compa
additional conditions
condition generates
first method
simpler logic
higher bits
simple logic
logic yields
recursive form
msb side
lsb side
individual bit
bit comparisons
bit suppose
subtractor outputs
positive excluding
include slt
slt instructions
instructions slt
first operand
previous diagram
subtraction output
question mark
case bit
putting thirty
irrespective result
controlled input
execute slt
fourth output
performing slt
slt binv
subtraction result
basically subtraction
equality test
involved issue
unsigned addition
small word
value increase
sum increases
maximum limit
overflow area
extreme left
left end
output carry
last page
correct result
subtraction unsigned
unsigned subtraction
positive values
adding twos
lets verified
invalid case
unsigned result
smaller number
red region
region corresponds
right order
red angle
angle flips
entire region
signed addition
numbers range
axis numbers
condition lets
top red
normalness condition
positive sum
opposite polarity
first condition
number side
normal negative
signed subtraction
compliment value
remain minus
subtract minus
subtracting minus
wrong values
negative values
lets flips
problem area
internal sign
negative result
indication remains
wrong carry
final bit
signed case
case unsigned
unsigned case
reversive diseaser
instruction mips
precise difference
part add
part slti
suffix means
meaning differs
suffix overflow
green column
column overflow
overflow occurs
instruction results
subtract subtractu
unsigned sum
signed sum
overflow results
mult multu
result produces
unsigned multiplication
true sense
signed comparison
comparison unsigned
unsigned comparison
doing sign
sign interpretation
unsigned interpretation
comparison differs
differs depending
byte load
remaining bits
lbu lhu
operation performed
remaining sixteen
cases sign
interpretation result
unsigned results
true interpretation
meanings preserved
small numbers
shift operations
manipulate bit
extracting bit
long bit
restriction shows
shifting left
bits means
loose bits
right shift
shift left
bit left
left shift
integer division
sign extensions
sign bits
vacating positions
sign integer
wrong value
putting zeros
sll shift
registers destination
source register
add instructions
instructions sll
sll sllv
logical variable
value part
register thirty
large value
srlv shift
simple suppose
carried state
position shifted
left position
arbitrary shift
multiple units
choosing combination
combination suppose
position shift
probate wiring
sign addition
discussed shift
instruction differ
kumar computer
multiplier design
subtraction comparison
multiplier multiplication
point talk
talk talk
design shift
add multiplication
add approach
multiple ways
defer interms
signed multiplication
essential differences
simple multiplication
multiplication method
decimal system
thing translated
suitable vertex
simplify add
middle bit
zeros multiplied
individual multiplication
forward multiplication
partial products
partial product
place shifting
capture hardware
hardware work
first partial
change add
final results
out addition
thing breaks
single bit
fixed amount
active logic
fixed shift
effectively shift
shift takes
propagate points
iterative algorithm
initialization step
bit multiplication
separate assignments
improvements made
activities added
incrementky shifting
successive iteration
hardware equivalent
form input
first addition
extreme position
last addition
double digits
repeated thirty
times operation
red signals
controlled signal
instruct addition
closure step
things checking
bit wide
modified circuit
high high
high end
shifting right
product obtains
reality position
counter increments
crucial change
single single
conceptual clarity
circle point
vacant position
individuate carry
shuttle consideration
interesting observation
making spaces
observation leads
gradually bit
vacated bit
rest remain
final circuit
multiplying instruction
bit results
sign multiplication
handle sign
opposite sign
sign sign
propagate form
form twos
sign integers
unlike addition
compliment representations
representations made
overflow detections
subtraction process
common expressions
negative integers
handles positive
similar kind
last bit
negative signs
usual thing
last term
minus magnitude
minus sign
minus waited
unsigned integer
magnitude retained
inside summation
thing substitute
single expression
convenient form
working reverse
multiplying factor
term involving
facilitate writing
definition assuming
difficult minus
booths algorithm
lets compare
multiplication signed
small change
change introduce
decides instruct
word comprising
step involving
modern hardware
iteration takes
lets lets
unsigned value
common pattern
positive value
lets work
value half
unsigned operation
unsigned integers
signed integers
perform multiplication
cases irrespective
instructions move
high part
low part
high low
case result
operand result
high higher
exact description
paper pencil
pencil method
multiplicand digits
thing translates
adder performs
performs addition
first improvement
multiplicand sorter
register requirement
accumulated sum
common representations
resulting algorithm
original motivation
discussed range
detect overflow
binary division
discussed design
out multiplication
illustrate division
division operation
unsigned division
signed division
multiplication operation
signed result
single word
word output
word integers
subtract operations
lsb position
bit quotient
bit divider
simple mapping
normal decimal
decimal division
binary domain
basically comparison
dividend divisor
position number
last value
subtraction step
propagate power
division algorithm
improvements transformations
loop proceeds
required result
invariant put
single equation
positive non
loop invariant
right quotient
correct remainder
correct quotient
correct results
relation ship
bit product
bit dividend
bits divisor
right value
algorithm works
inductive manner
mathematical induction
induction assume
checked action
action depend
invariants hold
means subtraction
inequality holds
condition subtraction
out subtraction
equality holds
left part
invariant holds
invariant hold
difficult case
subtraction condition
omitting subtraction
half range
correct algorithm
suitable hardware
initial shift
bit set
directions addition
input result
controller sitting
compressed comparison
control acts
circuit captures
forward algorithm
bit subtraction
graduality shifting
bit subtractor
stationary achieve
relative position
correct position
units left
parts left
position left
bit shifted
starting position
bits size
registers shift
right end
forward change
register shifting
simple control
restoring division
first form
basic algorithm
shifting operation
restoring approach
complete step
unconditional subtraction
conditional addition
additional steps
big deal
initial subtraction
initial unconditional
additional step
unconditional step
pending restoration
restoration requirement
previous iteration
usual right
normal case
separate step
last step
final adjustment
final correction
initial addition
doing lets
anticipatory subtraction
adjust recording
part remain
final step
correction done
resome points
doing corrections
correction continues
subtracting divisor
sign values
correction step
similar check
final addition
divisor quotient
basically dividend
sign combinations
right columns
columns show
similar logic
positive quotient
correct sign
simple handwork
bit division
compare shift
out division
sequential manner
out anticipatory
comparison involved
final restoration
algorithm work
performed division
done transcriptor
fast addition
basic arithmetic
performance today
operation improve
basic design
simple adder
bottle neck
carry fast
fast manner
carry save
save addition
adder circuit
simple circuits
operands perform
individual bits
bit adders
form adder
simple task
simple combination
simpler form
gate behave
inherent delay
signal propagating
seconds tens
signal change
change propagate
wired delays
present discussion
logic part
larger circuit
gate fitting
condition delay
pico seconds
input gate
larger delay
idealize situation
approximate situation
maximum number
deepest level
express circuits
circuits boolean
boolean circuits
level sum
logic consideration
current design
algorithm doing
large delay
dependents means
primary input
usual expression
level expression
large expression
generate expression
impractical solution
inputs number
fan ins
longer case
individual gate
large fan
primary inputs
inputs thirty
unworkable circuit
fifteen terms
intermediate carries
individual circuits
position digest
preprocess form
stage generates
input side
position irrespective
output side
propagate condition
values interms
make substitution
first line
growing expression
limited stage
incoming carries
similarly lets
incoming carry
limited extern
lets understand
green boxes
gate generates
circuits computing
maximum delay
stage delay
single level
final carry
larger adders
abstract form
internal retails
block box
smaller form
chain form
ripple carry
carry adder
purple box
carry times
normal ripple
considerable saving
partial rippling
carry question
sixteen stages
carry ripple
block level
generate block
block propagate
generate signals
small purple
blocks propagate
group propagate
propagate generates
generates signals
block propagates
propagates carry
propagation condition
generate condition
condition generation
generation condition
generation takes
block generates
similar conditions
sixteen expressed
carry appearing
roughly doubles
generate term
propagate term
essential taking
made things
move attention
put number
multipliers number
single adder
sequential approach
addition store
signals propagate
storage involves
advantage interms
array multipliers
natural reasons
array multiplier
tree multipliers
cascade form
multiple terms
arbitrary values
fourth term
usual ripple
carry rippling
prevent propagation
left neighbor
adder cell
making carries
leftward carry
carry propagation
saving carry
last stage
stage carry
extra stage
previous stage
feed carries
operand fed
output adder
sums coming
carries coming
carries carries
diagonally sums
fourth input
resolution problem
sums position
adder cells
horizontal movement
vertical movement
extra adder
extra bits
small circuit
path lets
extra logic
carry computation
last adder
expensive adder
term simplify
things denoting
first term
result bits
initial carries
normal carry
path leading
times delay
horizontal propagation
vertical propagation
carry saving
twelve adder
adder units
order generates
diagonal movement
key idea
multiple levels
out sixty
propositional factor
doing carry
unit design
usual arithmetic
integer arithmetic
hardware unit
standard representation
special numbers
programming languages
rational number
complex number
large space
numeric word
integer lets
representing values
scientific domain
huge distances
twelve meters
fractional values
integer representation
minus twenty
small value
represents fractions
large range
representing fractions
fractions means
integer part
non integer
integers value
rational numbers
integer pairs
select minus
string minus
propagate sign
fixed position
binary point
number string
decimal point
fixed point
point notation
large names
fraction part
manner described
power associate
large ranges
positive power
high values
negative power
low values
significant digits
irrational quantities
infinite length
irrational number
reasonable approximation
infinite number
number bits
simple number
fractional part
negative powers
propagate weightage
base ten
binary fraction
hand suppose
decimal fraction
integer parts
part point
part repeat
represent point
exact representation
lets introduce
exponent part
point representation
point sum
positive exponent
negative exponent
allocate bits
multiple answers
standard ieee
ieee stands
electronics engineers
scientific literature
standard defines
defines representation
single precision
double precision
addition bits
small difference
big impact
total sixty
bits representation
twenty remaining
mantissa part
significant part
precision case
largest value
left extreme
value ranges
slightly sort
precision numbers
point number
normalized representation
suitable power
adjusted adjust
precision number
represent exponents
bias notation
sign exponents
real range
positive exponents
range excludes
signifies floating
multiple representation
similar test
sign test
positive requires
magnitude comparison
choice wehave
wehave made
larger exponent
larger weightage
mantissas lets
larger mantissa
natural places
numbers treating
exponent bits
exponent bit
bias representation
sign comparison
comparison differ
bit rest
comparing magnitudes
positive limit
negative limit
additional concept
smallest positive
smallest integer
extreme values
familiar decimal
separate bit
separate range
minus thirty
significant bits
equivalent decimal
finally lets
perform operations
hardware circuit
exponent exponent
adder subtract
operations sum
determining sign
normalization process
large shift
small shift
opposite manner
details circuit
lock diagram
diagram indicating
point adder
numbers sign
sign exponent
circuit comparing
small alu
alignment stage
control unit
unit control
big alu
alu adds
exponent circuit
small exponent
large exponent
normalization takes
involve output
normalized value
exponents selected
rounding means
rounding logic
lost normalization
original value
value coming
zeros result
initial alignment
largest side
smaller adjustment
exponent terms
terms divide
range point
bits including
bit exponents
bits fractions
integers result
throw remaining
retain twenty
finite word
word length
intermediate calculation
guard bit
round bit
sticky bit
additional bits
intermediate stages
relative sense
sense lets
lets imagine
relative level
level lets
lsb means
financial applications
rounding method
place half
highest value
stop computation
subsequent part
suppose exponent
mantissa non
denormalized number
underflow occurs
represent numbers
system normalization
smallest value
denormalized numbers
normal situation
specific meaning
handle floating
point registers
registers labeled
entire hardware
point activity
special task
usual operations
operations add
absolute value
value negate
precision data
multi precision
add dot
precision addition
integer mips
mips addition
register pairs
sixteen pair
instructions lwc
processor attached
main processor
integer register
usual manner
address store
false condition
compare instructions
separate flag
false hood
means compare
representation integer
integer single
higher precision
lower precision
handle definition
instructions mips
specific component
blocks including
including alu
involved design
sophisticated design
term multi
major parts
parts data
specific style
mac program
program control
small low
exceptional situation
simple manageable
manageable design
understand discuss
timing constraints
frequency puts
initial discussion
build mips
build circuit
memory reference
reference instructions
flow instructions
instructions branch
simple comparison
comparison slt
complex comparison
discuss comparison
alu circuits
overflow information
individual result
doing comparison
carry flows
information flowing
recursive equation
equation describing
instructions processor
addition instruction
small incremental
story begins
memory instruction
done subtraction
done comparison
shown connections
instructions memory
instructions instruction
register resist
resist access
registers passed
memory accessing
add quantent
half set
instructions register
provide address
designing alu
made provision
full design
drawn skeleton
instruct memory
path works
information coming
status signal
data values
combinational elements
call state
sequential elements
combinational circuits
output determine
current input
circuit elements
current inputs
previous input
state represents
previous inputs
sequential element
state encapsulates
encapsulates state
state captures
relevant part
gate depending
instantly react
output function
circuits multiplexer
makes choice
circuit decoder
decoder decoder
bit patterns
patterns suppose
input decoder
sixteen outputs
outputs depending
sixteen combination
adder subtractor
subtractor comparator
comparator alu
logic put
sequential multiplier
sequential circuits
past counters
circuits registers
essentially flip
clocked state
state elements
unclocked state
clocked case
state occur
unclocked elements
distinguish bet
clocked elements
active edge
rising edge
falling edge
unclocked circuits
unclocked element
nand gates
cross coupled
reset state
feedback loop
cross couple
couple signals
stable storage
inversion brings
stable states
stable state
put gates
data input
clock input
clocked element
point clock
flip flop
change state
edge triggered
level trigger
trigger circuits
active atleast
edge trigger
triggered circuits
circuits edge
nice property
change occurs
clock edge
change results
important point
change appears
change fur
period relates
state element
circuit presents
slow clock
recent value
stable atleast
register continuing
important consideration
require registers
adder alu
alu multiplexer
multiplexer register
file program
memory data
additional components
bit manipulation
value program
register implements
output thirty
input thirty
edge occurs
require adders
main arithmetic
adder noting
implementing branch
carrying outer
outer evaluate
evaluate branch
bit operand
operand produce
multi function
function unit
unit depending
doing test
require alu
crucial component
component register
bit values
read data
right data
address input
initial design
thing simple
read instructions
element memories
present contexts
input address
data output
write data
unlike register
doing read
single address
writing operation
external input
miscellaneous kind
require sign
sign instruction
perform load
load operation
calculation requires
bit offset
polarity preserved
circuit element
sixteen inputs
active components
branch addresses
beq instructions
equivalent byte
ant active
active element
manner suppose
bits connected
simple subset
system interms
generic examples
combinational sequential
timing issues
constraints post
circuit delay
specific circuits
register multiplexer
multiplexer adder
performance issues
circuit execute
small steps
clear picture
comparison add
basic skeleton
instructions step
basic set
require interms
right operation
detail design
registers perform
operation put
access memory
control beq
conditional jump
status signals
times activities
process involve
taking program
counter contents
register values
instruction fields
result produce
begin lets
single code
larger group
common opcode
action begins
current instructions
fixed contents
means infact
special process
bit instructions
discussed yesterday
address inputs
read address
data outputs
outputs read
specific fields
number twenty
address bit
twenty form
alu imagine
control alu
right function
right port
emphasis terminology
port means
read ports
write port
defines address
give lets
instruction completes
value storing
thing note
discuss design
multiple cycle
good reason
simple component
incremental changing
signed offset
register add
field defines
memory depending
add load
unlike instruction
address read
read port
port write
port memory
single port
single read
read write
port infact
address line
bidirectional data
data line
separate read
write lines
common address
calculating address
connect register
performing address
signed extensions
input bit
labeled things
things assume
bit signals
carrying thirty
bits exceptions
sign extended
give input
paths conversing
part takes
adder inputs
complete arrangements
address generation
generation part
propagate address
give control
instruction control
correct write
lets figure
instruction write
write destination
bit eleven
complete picture
instructions influence
part continues
format opcode
word number
wiring things
correct offset
offset coming
bits takes
active gate
active component
component involved
involved sign
extension means
shifting means
wiring arrangements
instruction jump
full thirty
additional choice
instruction bits
instruction field
program counters
input multiplexer
start worrying
apply control
require control
assign names
file destination
alu source
normal arithmetic
operations alu
minus output
status output
view beq
control data
memory requires
requires control
eleven outputs
twelve inputs
inputs infact
monolithic circuit
jump branch
branch load
subtract etcetera
controlling alu
eleven signals
lets connect
write register
multiplexer passes
upper input
test failed
gross diagram
shown status
speaking controller
inputs circuit
input circuit
opcode operation
control circuit
controller alu
possibility load
operation class
input lines
output line
complexity grows
numbers input
additional information
controller details
word beq
simple step
step approach
table connect
connect wires
added store
added beq
beq beq
block boxes
design simple
right action
action takes
simple implementation
entire instruction
performance consideration
path design
separate consideration
control inputs
programmable logic
logic array
analyze performance
design approach
improved design
design lets
logical group
including store
similar approach
separate design
brought components
design point
doing add
register address
fields fetch
alu result
first group
memory component
suppose leave
path portion
register takes
omitted data
memory alu
right bits
file doesn
alu doesn
require memory
bits forming
partial designs
final design
sub design
entire designs
identify conflicts
subtract instructions
instructions send
operands coming
conflict interms
instruction output
ins eleven
suitable control
introduce multiplexer
non branch
conflicting line
propagate connection
control points
controlling read
gate controlling
type instruction
logic instruction
instruction rdst
top input
bottom input
signal jmp
jump control
control multiplexer
jump signal
jump bar
instruction done
exercise rdst
input memory
cares doesn
similar exercise
putting thing
writing memory
file brn
jmp continue
green table
source jmp
jmp continues
values put
choosing alu
upper inputs
compact truth
control boxes
main control
encoding opc
opc opc
main controller
instruction falling
category load
turn outputs
ten outputs
outputs circuit
bits input
input control
type entry
opcode filed
column shows
last column
address offset
control circuits
output bits
first noticing
function alu
alu suppose
perform subtract
action required
output multiplexer
bits control
adder part
zeroth input
designed alu
input required
complete table
mechanical process
write sum
product expression
realization product
nand nand
multiple outputs
pla based
programmable logical
logical array
array means
universal ypu
desired function
product implementation
sum terms
signals representing
final output
direct correspondents
true form
complimentary form
output pla
arbitrary product
literal means
power terms
sum sum
required sub
sub set
summing output
actual practice
gate gates
gates don
nand organization
concisely lets
lets continue
top part
bottom part
comp compliments
dot put
inputs outputs
functional specification
power term
required connection
required function
exact circuit
cross point
transistor whe
cross wire
programmable structure
code work
fair interms
doing show
component delays
prominent component
register delay
adder delay
call lets
lets denote
rational assumption
small compare
bit mani
mani manipulation
manipulation components
interconnecting wires
wire delay
cycle begins
file delay
additional circuitry
out output
moment assume
normal memory
bulk memory
cache memory
moment lets
put memory
alu concerns
alu timing
make attempt
slow adder
carry propagate
propagate addition
upper group
row corresponds
fourth line
long expression
big expression
bottom expressions
coming form
form load
word coming
individual factor
basically lets
hertz clock
things standard
standard moment
slow slowest
slowest instruction
clock performance
resource utilization
extra adders
multiple steps
requires reading
address doing
similar manner
manner multi
multi pole
pole operation
necessarily sequence
fundamentally limitation
simpler design
resolve conflict
putting multiplexers
control requirement
instruction identified
control parts
parts specification
view looked
instruction pushed
subsequent lecture
simple form
approach call
call multi
lecture plan
problem reobserving
main hardware
activities begin
cycle ends
wide disparity
full fledge
fledge alu
fetch data
focus today
significant delay
delay denoted
final expression
simplified form
sub expressions
numeric sense
delay involved
instruction fetching
equal values
slight differences
point remember
introduce multi
divide execution
simple choice
major action
individual times
small dead
vast disparity
problem situation
individual activity
case taking
taking longer
significant saving
cpi depending
instruction ion
good infact
cycle case
activity perform
wasting lot
balance possibilities
multiple action
simplest thing
multiple periods
forward solution
suitable clock
dead times
major actions
single alu
share resources
solution lies
operation stored
adder store
key thing
resource adder
separate clock
firstly lets
merge instruction
single block
alternative address
lets bring
arithmetic instruction
conflict point
extra memory
thing move
offset addition
generating jump
first adder
first input
belated difficulty
identical right
design process
introduce registers
reading operands
small individual
individual registers
information brought
register holds
call res
normal addition
fresh multiplexers
multiplexer inputs
register result
earlier multiplexer
separate values
bigger multiplexer
control value
value control
fee din
extended brought
address resources
store address
collapse multiple
multiple components
delay analyses
shorter path
fetching instruction
similarly path
main sources
components memory
make redraw
required control
cycle res
value written
combinational box
sequential machine
cycle depending
control things
resource sharing
individual action
extra cost
cost interms
simple interms
shobana computer
memory hierarchy
main component
puts great
great demand
pipeline case
memory technology
discussing today
memory technologies
memory hie
hie hierarchy
frame work
specific level
cache organization
simple cache
performance parameter
miss rate
rate varies
architectural parameter
block size
cache policies
typical add
online computer
computer store
typical configuration
cache ram
ram fdd
storing information
similar things
generate doesn
backup memory
faster memory
cpu chip
hertz spec
prize differs
prize difference
powerful processor
price difference
inch monitor
notice presence
solid state
state semiconductor
moving parts
parts involved
magnetic memory
moving media
optical memory
magnetic form
storing medium
involved whi
movement involved
semiconductor memories
random access
information faster
information slower
mechanical movement
sequentiality make
memory case
case order
lower incase
optical memories
identical part
memories sram
imagine cross
coupled gates
discharge capacitor
slower offer
larger capacity
vise versa
hierarchical structure
kind memory
fastest memory
memory close
slow zone
zone farthest
hierarchical memories
largest memory
hit lets
ninety point
high hit
hit rate
small miss
single parameter
first level
instruct instruction
future requirements
thing works
temporal sense
spatial sense
temporal locality
locality means
spatial locality
address features
features close
special form
sequential locality
neighboring addresses
cost decreases
means thing
total cost
total effect
weighted sum
additional cost
broad picture
storage cost
individual access
previous level
earlier level
hit ratios
hit percentages
percent chances
greater probability
last level
higher larger
larger value
sum tow
hit probability
miss probability
technologies characterized
tow values
miss probabilities
right combination
simplified model
hierarchal interfaces
low levels
memory interface
subsequent reference
loops bring
small loop
arrays records
consecutive locations
memory main
larger size
size cache
smaller size
simple organization
direct map
map cache
fixed place
first quarter
direct correspondence
grey locations
memory map
grey location
orange locations
locations map
quarter maps
hardware structure
memory addresses
bit addresses
giga bytes
giga words
last last
remaining thirty
thirty word
word define
thirty memory
lower ten
found wha
word sitting
gray position
bit tag
cache word
ide identify
data restruction
additional twenty
valid bit
empty cache
bring thing
empty location
bits address
remain twenty
tags match
valid entry
write process
word blocks
multiple words
sim sim
field size
size change
larger cache
bit index
block consisting
total capacity
twelve bits
manner index
tag size
valid bits
tag matching
decide hit
selection signal
larger block
capture locality
feature references
size increases
show miss
rate depicted
percentage versus
versus block
curves correspond
total cache
cache size
obvious reasons
cache capacity
miss rates
smaller caches
original values
larger blocks
spend lot
large larger
size means
fewer blocks
work work
rate miss
cache misses
key indicator
indicator cycles
large block
miss occurs
word width
width connecting
connecting cpu
multiple word
word block
word wide
wider path
bit bus
bus cycle
cpu cycle
block transferred
high cost
reasonable performance
organized memory
wide memory
memory connected
wide bus
memory banks
bus narrow
memory memories
faster bus
additional transfer
reasonable arrangement
placing things
full flexibility
associative memory
tag value
map caches
form sets
cache area
limited flexibility
limited fle
fle flexibility
set size
single set
cache divide
places whi
limited context
mapped cache
simple simplest
simplest cache
associative cache
rate variation
underlying idea
bring data
level memory
mapping alternatives
performance issue
cache accesses
memory organization
miss penalty
stages read
stage load
load stage
performance implications
memory closer
slower memory
large capacity
vast variation
access times
cpu registers
technology require
ball path
path figure
exact values
static ram
cache memories
basically dram
ram technology
magnitude slower
secondary memory
hard disc
data exist
med medium
reset point
place faster
ten mega
gain mind
first question
simplest solution
address modulo
small pool
sixteen locations
memory compete
location cache
increased flexibility
set degree
associative case
direct access
access mechanism
associative access
words cache
byte cache
access case
tag match
tag field
cache address
cache location
tag matches
tag doesn
hit occur
program begins
forming part
single tag
misses occur
transfer blocks
index field
address reduces
eighteen bit
bit tags
entire neighborhood
entire block
block absent
line cache
cache line
associative organization
horizontal line
larger right
entire row
out tags
tags matching
required word
words coming
block offset
match signals
matching hardware
extra thing
graphic error
address memory
miss alignment
multiple access
address divide
set index
tag stored
cache set
single field
level hierarchy
suitable combination
lets simplify
cache level
level failed
memory level
hit probabilities
case spend
common term
average memory
term penalty
find things
ultimate interest
ultimate measure
extra cycles
memory stall
introduce stalls
executing instruction
factor memory
memory stalls
rate multiplied
penalty multiplied
dep depend
extra cycle
organization point
reduce miss
reduce hit
transfer data
fastest possibility
alternative arrangement
interleaved memory
size suppose
suppose block
sixteen words
lets quantify
fifteen cycles
memory transaction
bus cycles
sending data
taking figures
first organization
send address
spending fifteen
transferring data
factor reduces
words transfer
seventeen cycles
intermediate situation
situation suppose
out spend
intermediate case
similar effect
page mode
storage cells
dimensional structure
part row
row row
row address
column address
give row
out things
faster access
word takes
subsequent words
reading multiple
multiple bit
consecutive bits
read bits
address row
means initiate
initiate data
cache load
load means
cache fetch
fetch means
transfer replacement
replacement means
write hit
write miss
cache hit
concurrent read
data brought
word suppose
entire word
word entire
data state
cycle read
cycle write
multiple level
subsequent levels
cache suppose
simple taught
miss occurred
words invalid
round robin
robin fashion
fashion start
fetching means
demand fetching
anticipate things
hardware prefetching
software prefetching
simple mechanism
hardware prefetch
sequential references
artificial miss
open question
flows work
wasteful transfer
memory processor
processor bus
replacement issue
replacement policy
alternative strategies
simply fifo
fifo approach
profound influence
write policy
lets examine
hit case
hit means
back case
clean bit
dirty bit
back arrangement
cache serve
write allocate
back policy
allocate buffer
reach main
buffer figure
complication arise
arise moment
architectural improvement
side effect
wri writing
memory means
memory lets
bean read
cache update
mein main
transferring blocks
dirty flag
set block
separate cache
split cache
cache unified
behavior cache
suit instruction
instruction cache
suit data
separate caches
common policy
policy split
pipelined implementation
source cache
caches means
unified cache
afford lets
entire sixteen
sixteen kilo
instruction data
cache words
multi level
level caches
on-chip cache
off-chip cache
small off-chip
level cache
magnitude difference
position multiple
multiple caches
direct mapping
associative mapping
penalty depending
dram organization
similar purpose
interleaving looked
reading loading
loading fetching
fetching replacement
numerical problems
problems pertaining
cache performance
sample references
access level
statistical sense
detailed view
view detailed
detailed illustration
exact mechanism
accesses misses
small cache
address sequence
miss depending
cache numbered
accesses made
hits encountered
misses encountered
modulo sixteen
first address
start repeating
misses lets
lets proceed
space aspect
initially numbers
address twenty
twenty replaced
throws twenty
program behavior
sixteen accesses
additional hits
level tags
location filled
twenty replaces
seventeen replaces
seventeen fifty
block beginning
beginning fifty
total performance
hit remains
rate decreases
placing blocks
follow lru
lru policy
earlier bur
observe twenty
twenty modulo
lets extend
sixteen block
block cache
cache sixteen
sixteen word
word cache
fair comparison
situation point
compulsory miss
miss compulsory
compulsory misses
capacity misses
misses capacity
limited capacity
conflict misses
misses conflict
conflict miss
specific mapping
mapping approach
lets find
miss misses
reduced compulsory
longer miss
capacity miss
individual miss
statistical level
percent misses
misses point
additional misses
total gross
gross behavior
dep depends
suppose cache
byte addressable
mapping cache
num number
tag part
index part
bits required
index bits
tag bits
minus log
size multiplied
cache directory
cache data
performance parameters
cpi assuming
ideal situation
cycles encountered
additional stall
basic cpi
find miss
memory cache
cache interface
multiple world
page dram
bus bus
cycle assume
memory latency
ten cycle
cycle sending
address ten
total twelve
twelve cycles
encounter forty
case suppose
memory takes
required send
total miss
cpi calculation
case miss
sixty cpi
performance varies
cache caches
instruction misses
data misses
hundred instructions
hundred access
remaining cases
cases miss
details lets
instruction make
instruction makes
ins instruction
make data
data reference
data access
miss point
extra values
stalls cache
cache stalls
minus point
clocks clock
cycle clock
multiple comparison
bit exaggerated
caches clock
cpi figure
negative effect
analyze situation
cache brings
hundred nanoseconds
single cache
net effect
twenty nanoseconds
hundred cycle
architectural block
hundred cycles
nanoseconds divided
totals cpi
account misses
base cpi
percent miss
level multiplied
performance improved
cache terminology
global miss
local miss
solo miss
miss solo
term suppose
cache system
solo means
nice relationship
inclusion property
miss sponsored
processor ninety
forty percent
large figure
selected requests
lets conclude
simple situations
focus attention
individual hits
storage overheads
organization countered
factors influence
gross sense
penalty stall
ultimately effect
educational technology
technology services
centre iit
delhi computer
architecture lecture
cache hierar
hierarchy huh
memory huh
compare huh
virtual addresses
physical addresses
huh made
page tables
tables huh
located huh
major problem
referring fig
primary memory
main huh
access cache
architecture point
view main
huh processor
magic device
instructions huh
huh notice
organization built
extend size
huh done
done huh
manner huh
huh transparent
program huh
application program
concerned huh
huh unaware
disk huh
large memory
huh huh
main objective
size limitation
physical memory
earlier technique
primitive huh
huh care
contents upto
organization serves
multiple programs
single user
personal typing
typing type
multiple processes
provide protection
task combined
easily reposition
earlier part
huh putting
language programming
programming huh
absolute addresses
huh shift
huh on
local context
background noise
program bu
first aspect
large virtual
huh it
huh machines
larger physical
total physical
physical space
financial reasons
larger virtual
virtual space
huh programmer
programmer huh
data huh
smaller amount
the virtual
physical address
huh chance
equal sizes
equal size
mapping huh
huh takes
virtual pages
change huh
processes multiple
separate virtual
huh areas
size huh
logical plane
da data
size an
an an
huh talk
complete logical
logical entity
function huh
entire function
equal parts
parts huh
things convenient
implement huh
non volatile
volatile medium
change overtime
overtime huh
larger disk
disk space
space and
hardware support
opening system
huh change
huh things
important differences
huh organizing
main difference
huh speeds
speed difference
smaller difference
cache huh
continue execution
huh action
hardware you
special software
software doing
require huh
context switch
switch means
large amount
miss huh
software huh
huh differences
historical reasons
reasons things
efficient terminology
terminology difference
huh miss
performance ei
factor huh
small huh
huh small
huh lets
performance huh
miss miss
large physical
cache smaller
large miss
terms kilo
lower huh
huh reduce
sixty-four words
large page
page size
larger locality
substantial amount
huh the
access huh
sixty-four kilo
complete flexibility
right huh
back write
back choice
larger huh
back approach
wrong piece
ideal thing
realistic wh
basis huh
unbounded quantity
restrict huh
huh programs
people doing
doing research
huh put
workable huh
maintaining huh
number call
place huh
huh su
su suppose
maintaining order
cache blocks
sophisticate data
huh doing
difficult huh
lose efficiency
hardware huh
approximate policy
policy huh
huh case
background lets
lets huh
side huh
virtual page
page huh
huh infact
huh mechanism
address huh
huh imagine
huh page
page offset
page number
page rest
page suppose
huh physical
memory present
thirty huh
huh bytes
physical page
translation process
table huh
number right
number huh
disk address
table register
huh in
doing huh
bits huh
huh reach
reached huh
direct memory
cache whe
tags present
comparison huh
cache block
cache directories
huh blocks
mapping process
process huh
number taking
fault result
huh context
switch so
current process
execute thousand
thousand thousand
table stored
answer huh
space requirement
su lets
suppose virtual
bits page
table entry
memory protection
table entries
size divided
huh size
information huh
direct separate
huh megabytes
huh hundreds
table size
size exploit
huh functions
huh organized
opposite directions
directions suppose
space huh
huh stack
accomod accommodate
huh thinking
memory segments
heap huh
handle sparsesity
current requirement
hashing technique
suitable hashing
hashing function
smaller table
inverted page
cache situation
level page
huh paging
huh segments
logical boundaries
huh entire
larger chunks
smaller chunks
segment table
organization huh
track information
organized huh
table page
smaller page
single monolithic
monolithic page
calling segment
addresses divided
parts segment
segment number
number page
step access
required point
register huh
encounter page
fault huh
page page
imagining page
techniques suppose
make accesses
accesses huh
keeping page
user page
huh system
user processes
system process
system space
space table
huh find
entire page
table wh
making reference
huh entry
tenth entry
physical counter
huh systems
systems page
system page
entry huh
huh hoping
step process
huh accessing
accessing huh
huh users
users page
involved huh
clear idea
point huh
noticed similarities
differences differences
key mechanism
addresses page
problem an
limited size
sparse sparseness
sparseness locality
large huh
adjustable space
memory today
big issue
continue huh
details huh
translation lookaside
lookaside buffer
huh addressing
addressing cache
case page
directly disk
disk track
sector distribute
size we
we notice
separate page
entire physical
today huh
huh multilevel
multilevel page
table structure
simple flat
flat huh
huh array
larger levels
huh keeping
huh coming
huh organization
entire virtual
space divided
huh thousand
thousand segments
thousand pages
table wi
pages huh
small small
starting points
indication valid
huh level
huh byte
segment field
field huh
call segment
required entry
multiplying constant
constant multiplying
huh suppose
huh starting
huh leads
bytes huh
present huh
relevant page
exact location
number concatenated
complete physical
huh instruction
huh allowing
paging mechanism
relevant pages
active pages
avoid huh
cyclic references
addresses flowing
usel users
page part
part page
thing represents
byte part
huh sum
number part
table base
find huh
huh pointed
system base
base system
number offset
users huh
huh number
byte give
translated part
address translation
user space
translation means
offset edition
translation huh
final access
da huh
huh data
bit complicated
first translation
huh user
user address
base huh
activity and
huh addition
level function
mechanism huh
fault rate
simple page
structure suppose
physical access
paged page
access assuming
access to
reality things
bad huh
buffer huh
special memory
recent address
accessed entries
future reference
lookup table
huh entries
translation done
huh remembering
number pairs
parallel huh
huh associative
bit huh
number field
user process
incomplete information
inaudible background
shows huh
huh flow
address consisting
huh address
typically twenty
remaining twelve
tags huh
memory comparing
blank entries
huh dirty
thrown page
huh comparison
number stored
cache access
huh direct
huh finding
table access
access made
search ends
matter ends
failure huh
huh fault
huh service
desirable path
huh tests
table ea
possibilities huh
huh question
cache an
imagine huh
huh repetition
tree leading
missing huh
inclusive property
assume lets
huh cache
means huh
combinations huh
huh hit
translate huh
concerned cache
case huh
str straight
cache miss
reversed huh
case path
hand reverse
problems huh
huh aliasing
aliasing bu
huh mention
distinguish huh
confusion huh
huh ho
put process
extra overhead
switch occurs
huh part
part part
drawback huh
cost spend
aliasing aliasing
aliasing means
shared object
addresses huh
shared data
huh depending
running huh
copies exist
wrong copy
involved solution
problem the
virtually address
address cache
physically address
indexed cache
picture huh
cache requires
process in
parameters organized
huh index
part doesn
non-changing part
access completed
unchanged so
huh inexpensive
inexpensive arrangement
organization place
limited physical
place protection
protection means
unauthorized access
processes huh
access restricted
restricted part
systems area
physical pages
transition process
areas huh
direct control
huh as
as huh
huh pages
huh updation
table takes
explicit access
maintained huh
processor supports
kernel mode
supervisor mode
user mode
critical things
huh initializing
status register
processor huh
mode huh
system call
call th
th th
system area
executing code
user doesn
huh that
huh deep
deep huh
huh multilayered
multilayered mechanism
system data
security huh
huh communication
communication processes
network level
summarize huh
began today
level structure
huh based
physical data
huh introducing
strategies makes
accesses means
cache work
cache page
accessing cache
additional important
important role
memory mechanism
introduction huh
huh today
last topic
output subsystem
central component
entire system
system huh
executed memory
instruction operate
huh input
enter huh
computation involves
subsystem huh
performance considerations
considerations huh
peripheral devices
output huh
huh devices
operational aspect
neglected huh
huh speeding
processor executing
performance improvements
benchmark program
consume ninety
technological innovations
innovations huh
percent improvement
sixty forty
twenty-seven eighteen
performance remains
total figure
expected performance
improvements huh
computation bound
bound computation
bound means
performing computation
logic decision
small amount
process processing
scientific computation
computation huh
nuclear modeling
number crunching
heavy computation
business data
data processing
processing huh
huh or
oriented application
percent part
requirement huh
oriented measure
huh transfers
the huh
huh reservation
reservation system
user huh
huh response
involve computation
hand huh
central database
huh request
database huh
huh consideration
considerations suppose
super computing
huh scientific
bound application
simulation results
data throughput
huh transaction
transaction processing
system point
important huh
file server
server suppose
receive request
creating files
files opening
opening files
files reading
request huh
huh situation
memory we
kilo byte
byte huh
huh tenth
tenth power
twentieth power
real sense
thousand bytes
tens power
thousand kilo
dif difference
memory domain
processor domain
huh move
stored program
program computed
classical block
block diagram
diagram showing
computer huh
school days
memory input
arithmetic huh
central processor
huh elaborating
showing point
in-between the
things involved
multiple devices
understand huh
separate things
converts information
printed page
printing mechanism
controller wh
means bring
bring information
memory combination
aspect huh
input device
device printer
output device
device huh
devices make
make processor
processor talk
human programmer
programmer human
human operator
computer talk
internal devices
store information
information disk
huh keyboard
huh human
human huh
huh operators
huh network
network controller
machine huh
huh environment
environment huh
sensing temperature
huh computer
motor huh
huh storage
organize rest
ca ca
ca capacity
huh disk
serial data
means information
parallel data
bit means
variety exist
current situation
situation huh
huh years
huh paint
paint huh
present position
peripheral device
tape reader
tape punch
punch huh
holes punched
huh group
holes form
input information
device typewriter
typewriter wi
huh lot
tape attached
type information
punch tape
connected peripherals
outputting system
compiler huh
larger room
room huh
smaller room
huh prepare
additional device
device introduced
faster huh
hundred character
twenty character
line printer
li line
printer huh
make life
huh tape
current location
punch card
back huh
tape environment
people huh
punched holes
holes huh
drive was
added convenience
completely tape
sequential huh
disk capacity
huh twenty
twenty megabytes
big huh
me memory
huh kind
human beings
data rate
throughput rate
rate huh
mouse huh
feed information
fastest huh
voice input
voice output
capabilities voice
input voice
huh pictorial
pictorial input
input pictorial
pictorial output
huh wh
wh wh
generating speech
speech outputs
outputs huh
part huh
input huh
huh voice
huh brought
huh point
twenty bytes
speech huh
huh inputs
plain speech
higher rate
forty fifty
fifty huh
thousand samples
huh text
resolution huh
data rates
huh th
huh sort
finer shaper
shaper picture
devices line
line printers
printers laser
laser printers
printers huh
graphic display
demanding huh
sixty thousand
sixty megabytes
resolution on
screen suppose
suppose huh
thousand pixels
approximate calculation
calculation suppose
screen huh
color settings
huh yo
twenty-four bits
good quality
pixel means
information present
persistent display
display huh
persistent picture
twenty-five huh
huh frame
fifty frame
sixty frame
account huh
fax modem
modem huh
huh cable
cable modem
modem cable
modem connects
video cable
telephone line
line huh
carrying digital
digital information
huh lan
lan adapters
local area
area network
network adapters
adapters wired
rates huh
higher huh
huh ten
ten megabytes
hundred megabytes
common standards
speeds huh
telephone lines
fifty-six kilo
kilo bauds
kilo bits
term baud
communication huh
storage huh
huh floppy
optical disk
huh portions
huh opaque
opaque region
transparent regions
huh unit
unit area
medium moves
tape huh
sequential devices
serial form
archival purpose
huh varying
hundred kilo
floppy drive
flash memories
pen drive
moving part
non-volatile type
flash memory
transfer rate
magnetic disk
exact figure
figure huh
bit deeper
peripherals huh
drive huh
rotating disks
surface information
stored huh
write heads
arm huh
peripheral huh
circular tracks
heads move
huh platter
track number
number ten
real picture
huh hard
recording surfaces
inwards move
rotational speeds
the they
huh standards
changing huh
fifteen point
sea gate
huh fifteen
highest speed
initial point
rotating huh
right point
rotates determines
transfer huh
huh seek
desired point
average huh
rate sustained
interface huh
interface depending
actual data
data generated
high capacitors
fast disk
speed huh
huh buffer
buffer size
data doesn
first brought
local memory
average latency
latency huh
rotational latency
milliseconds huh
track seek
average figure
ten point
first piece
disk transfer
thirty-seven mega
mega bits
rotational speed
host huh
hundred megabyte
slower interface
continuing huh
layout huh
huh cylinder
huh collection
tenth track
form huh
heads huh
head huh
western digital
digital internet
internet site
rest huh
huh total
important peripheral
storage device
monitor huh
shown huh
huh interesting
unlike huh
high resolution
twelve hundred
viewing angle
monitors huh
seventy degree
wireless lan
serial bus
bus we
huh graphics
graphics card
resolution monitors
changing scenes
scanners scanners
forty-eight bit
bit color
document feeder
feeder attached
photocopy machine
huh inkjet
inkjet printers
cost effective
huh quality
improving huh
printing quality
resolve huh
direct network
network interface
inkjet printing
printing mech
mech huh
huh printer
printer mechanism
ink cartridges
ink cartridge
crucial mechanism
essentially paper
paper feed
huh movement
technological breakthrough
last couple
huh ink
ink ve
huh thrown
high quality
quality pictures
huh piezoelectric
piezoelectric mechanism
huh plate
controlled droplet
electrical signal
huh vibration
piezoelectric huh
thermal mechanism
ink droplet
hitting process
hitting register
electrical current
controlled hitting
hundred dots
existed couple
decades back
throughput type
performance definition
definition huh
counts huh
transfer rates
first lecture
huh peripheral
sense trans
trans carrying
carrying information
suitable forms
asynchronous synchronous
synchronous means
asynchronous means
uh-huh signals
event sequence
sequence information
huh beginning
controllers connecting
left huh
processor cache
cache combination
connecting huh
huh straight
huh answer
point connection
device establish
whichever pairs
dedicated connection
huh shared
shared set
shared communication
communication link
information flow
connect huh
wires run
bus huh
huh so
wires assigned
com huh
telephone exchange
cross bar
bar switch
switch huh
huh responsibility
huh make
make establish
establish connections
multiple conversations
point scenario
alternatives compare
connection bus
cost bus
bus offers
low cost
multiple ports
separate ports
distinct isolated
isolated connections
huh memory
multiple port
expensive affair
huh issue
designed system
huh pieces
uniform interface
things huh
specific possibilities
multiple buses
huh spectrum
increase performance
monolithic single
single cross
smaller cross
bar switches
complete huh
huh cross
bar capability
organize huh
huh multiple
multiple smaller
smaller switches
communicating pair
huh incur
onwards huh
lets focus
interconnecting subsystem
clear definitions
connect processor
speed buses
standard huh
huh standardization
large variety
subsystems huh
system based
huh intel
pentium huh
proprietary design
arbitrary subsystem
connects processor
main purpose
com carrying
huh lower
huh speed
huh standard
common definition
bus operation
bus signals
signals huh
bus width
width data
multiple parties
standard buses
lectures huh
backplane bus
hanging so
backpanel back
back back
back backplane
term backplane
earlier huh
separate card
single bus
front front
front side
dis huh
bus running
single board
multiple boards
chip memory
bus connecting
huh cabinet
huh pentium
huh backplane
huh wi
processor board
memory board
board plug-in
co complete
complete subsystem
controller huh
transforms information
laser printer
huh characters
printed form
memory process
huh binary
binary encoded
sixty-four bit
bit data
transferring character
free slots
fits huh
design cost
seperate infact
infact multiple
multiple huh
storage devices
devices disk
huh serial
peripheral lets
huh grouping
bus adapters
connect backplane
infact huh
typical sophisticated
sophisticated system
motherboard huh
common interface
crucial issue
connecting multiple
devices huh
multiple transactions
printer information
memory end
end huh
huh concurrency
localized area
disk data
printer data
common bus
data parallel
smaller lanes
bigger road
merges huh
faster highway
system level
structure huh
huh brings
concurrency huh
point things
printer busy
busy huh
huh capacity
capacity huh
figure suppose
suppose backplane
argument lets
byte wide
fifty nano
data occupies
huh twent
adapter huh
hundred nano
thousand nano
microsecond data
someway sequenced
sequenced right
byte level
packet level
level huh
huh tha
higher capacity
sequence inter
illustration huh
bus organization
output transactions
protocol huh
variations exist
control lines
data lines
carry address
memory bytes
physical lines
output transaction
shade huh
device reflecting
the the
huh information
responsible data
huh record
opposite operation
memory supposed
asynchronous case
clock involved
synchronize huh
huh send
read request
out data
data bus
understood huh
asynchronous huh
seconds huh
huh noticed
huh whosoever
acknowledge signal
sequencing shown
huh signal
signal shape
shape indicating
change occurring
individual signal
transition point
occurring huh
nature huh
level indicating
tri-state bus
high impedance
impedance state
state huh
huh high
state means
disk connected
huh floating
floating state
low impedance
impedance path
huh ground
intermediate level
state continues
removed huh
bus floats
huh lowering
raising acknowledge
huh cycle
expecting data
huh turn
huh device
huh sequence
huh events
lock lock
lock manner
positive pulse
negative pulse
pulse huh
exact sequence
event triggers
transaction completes
occur huh
huh states
huh step
state diagram
requesting device
putting address
asserts read
request signal
hand memory
acknowledgement line
acknowledgement signal
signal huh
request state
state diagrams
transition occurs
diagrams huh
previous huh
huh wave
wave form
the memory
huh observe
observe occurrences
huh carry
out state
synchronous bus
complete system
synchronous buses
independent clocks
twenty megahertz
megahertz clock
hundred megahertz
raising edge
transaction begins
mu multiple
integral number
cycle suppose
cycles huh
bus address
huh pick
memory understands
huh sitting
bus understand
fixed clock
determined huh
protocol so
asynchronous bus
fifty megahertz
takes huh
huh fifty
entire sequence
huh transfer
huh transferring
word lets
peak bandwidth
bytes divided
thirteen point
bus bandwidth
operations lets
similar speed
calculation lets
response huh
forty nano
maximum throughput
etcetera huh
huh first
step huh
takes forty
event huh
point acknowledgement
huh minimum
bus protocol
times forty
requiring forty
twenty nano
sixty nano
total bandwidth
eleven point
relative values
huh sensing
make assumption
increase bus
twenty-eight bit
huh block
block transfer
separate data
address lines
huh multi
multi block
block words
transfer multiple
moment huh
split transaction
transaction split
transaction means
buses lie
parts initiation
initiation part
ending part
huh close
size varying
sixty-four bits
bus frequency
megahertz takes
access takes
huh faster
faster lets
huh bus
bus transfer
data overlap
means lets
previous data
scenario huh
make blocks
sixty-four transactions
sending address
huh forty
period huh
total cycles
total latency
transaction rate
transactions huh
sixty-four transaction
huh nano
seventy-one point
transactions reduces
huh sixteen
sixteen sixteen
words huh
total adds
sixteen huh
fifty-seven latency
number multiplied
sixteen transactions
twenty-four point
tremendous increase
huh bandwidth
interconnection alternatives
alternatives huh
bus processor
multiple organizations
memory buses
backplane buses
huh choosing
suitable bla
bla block
subsystem consist
huh rest
buses form
peripherals processor
huh performance
discussion huh
bus arbitration
huh buses
serial buses
bit buses
data moves
typically address
separate lines
synchronous protocol
protocol implies
huh clock
events occur
interlocked response
event occurs
occurs huh
arbitrary amount
protocols tend
fast devices
sense signals
higher speed
huh synchronous
synchronous approach
blocks chunks
idle period
unutilized period
interleave transactions
transaction protocol
bus throughput
bus performance
asynchronous handshaking
handshaking protocol
huh sending
additional word
word huh
huh requires
requires twenty
huh repeat
additional words
busy reading
band width
total huh
huh rate
transaction required
transferring sixteen
transaction takes
huh involves
involves sending
allowing memory
forty clocks
megahertz means
forty clock
periods huh
data requires
takes twenty
sending huh
forty-five word
forty-five cycles
fifty-seven cycles
transaction multiplied
forty-five multiplied
sixty-four product
cycles product
huh convert
twelve multiplied
words transaction
sending sixteen
thousand times
words multiplied
huh throughput
transaction huh
huh begins
in-between huh
memory signals
huh you
huh parties
parties connected
general sitting
bus master
situation processor
processor talking
huh conversation
conversation processor
drive controller
master memory
slave huh
huh set
set number
huh initiation
initiation process
peripheral controller
slaves peripherals
masters memories
multiple masters
higher priority
lower priority
multiple request
priorities huh
es essential
essential huh
low priority
daisy chaining
chaining centralized
centralized parallel
parallel arbitration
arbitration distributed
distributed arbitration
collision detection
scenario showing
showing huh
first approach
daisy chain
huh accessed
term device
potential masters
huh define
bus arbiter
arbiter huh
huh decreasing
highest priority
sitting closest
lowest priority
priority sits
sits farthest
bus request
request signals
bus release
release signals
common signal
bus can
interesting part
bus grant
grant signal
priority device
device number
huh grant
devices requesting
line bus
request line
opposite convention
huh arbiter
huh assuming
activate release
release signal
huh sees
complete transaction
arbiter notices
signals release
individual request
arbiter doesn
huh activates
grant line
line indicating
device completes
request but
overlapping manner
request bu
disaster situation
high priority
bus granted
device coming
find grant
level th
th the
huh release
clear indication
activates grant
deactivates grants
propagation huh
long huh
diagram huh
priority devices
request pending
central arbiter
send grants
separate request
separate grant
line request
arbiter arbiter
the priorities
fair manner
huh assign
priority but
but but
but huh
define priorities
distributed manner
single arbiter
huh democratic
democratic kind
devices sort
huh specific
specific lines
honest manner
devices supposed
ethernet huh
shared medium
devices happen
collision occurred
free huh
collision takes
huh delay
usage requirement
heavy huh
fixed huh
repeated huh
huh modifying
queue end
proprietary bus
bus connects
backplane huh
disk drives
huh printers
printers scanners
huh ty
proprietary backplane
bus level
buses huh
lines backplane
synchronous huh
huh oversimplified
oversimplified situation
real system
huh thing
typical huh
huh type
huh controllers
huh adapters
chip set
complex chips
memory control
control hub
graphics memory
memory modules
display modules
huh variety
peripherals including
including huh
people call
north bridge
south bridge
side bus
thirty-three megahertz
megahertz huh
huh interfaces
interfaces huh
audio interface
speed devices
memory hub
huh display
display devices
transfer demand
bandwidth demand
throughput requirement
highest throughput
huh backside
backside bus
bus front
numerous varieties
huh lots
term standard
standard bus
huh subsystem
huh compatibility
build memory
single company
technology develops
develops huh
speeds change
requirements huh
contradictory requirements
improve huh
freezing huh
huh arresting
an commercial
commercial pressure
performance specs
continuous process
formal mechanisms
huh defining
formed industries
defining standards
professional bodies
huh organizations
huh community
proprietary interface
proprietary huh
popular person
standard standard
physical level
electrical level
logical level
shape size
size dimension
define huh
signals change
bus standard
complex definition
domain huh
early stages
transformed industry
industry standard
standard architecture
architecture huh
faster link
slower link
local bus
video electronics
electronics standards
standards association
defined stands
peripheral component
component interconnect
interconnect bus
accelerated graphics
graphics port
port huh
mentioned huh
frequency huh
width huh
huh meant
two power
huh combining
lets spend
huh thirty-three
huh peak
peak transfer
thirty-three megabyte
protocol delays
serial version
detail huh
version serial
huh cheaper
total data
serial port
huh external
external modems
modems huh
parallel port
connect printer
extended parallel
huh flash
memory device
connect devices
cameras printers
performance serial
serial de
de serial
serial ports
fire wire
wire fiber
fiber channel
upto huh
disk disk
drives huh
rom drives
system interface
ultra wide
wide fast
standards improve
sixty megabyte
huh steps
support priorities
huh we
backplane level
huh series
operations continuing
today talk
software point
entire activity
activity appears
processor point
processor participates
huh activity
abstract statements
high levels
language level
level the
printf statement
huh arrays
primitive elements
elements integers
integers floating
point strings
raw form
representing information
display device
device understands
understands things
huh matrix
pixels huh
character level
level device
keyboard huh
ascii characters
interconnection structure
huh timing
timing characteristics
head move
timings involved
abstract view
precise huh
format conversions
conversions examples
examples huh
library function
function library
library routines
object code
abstract operations
level operation
format conversion
complex details
huh dots
pixel matrix
huh tracks
device driver
device drivers
specific peripheral
th details
exception routine
interrupt handling
handling routine
interrupt system
multiple windows
windows coming
multiple tasks
properties drives
logical view
files huh
physical devices
file system
system part
huh operating
aspects huh
devices place
slow devices
producing information
small groups
mou mouse
tracking huh
direction minus
movement huh
huh slow
slow huh
mouse movement
small volume
small rate
big blocks
network operation
the network
network standards
standards talk
ten megabits
hundred megabits
ten gigabits
huh tens
lets turn
human eye
eye sees
constant image
huh twenty-five
huh times
thirty times
huh what
video memory
screen you
you you
huh refresh
modern systems
systems work
work huh
earlier days
peripheral sep
intelligence in
huh modify
changed information
workstations huh
typical operation
head read
write head
huh bulk
action huh
huh mouse
transfer occurs
huh pixel
matrix huh
continuous activity
activity huh
operations huh
device appears
ports huh
huh give
give commands
huh code
command commands
sect number
read huh
check specific
specific bits
de depending
program running
ways addresses
memory mapped
space memory
higher end
leaving huh
thousand addresses
separate address
usual load
ignore huh
load occurs
memory doesn
instruction huh
address falls
falls address
memory range
fifteen bits
large address
address value
additional instruction
huh take
huh key
check frequent
polling wh
register check
processor doesn
status it
task and
invoke action
an processor
multiple interrupt
interrupt signal
polling activity
back check
numerical value
processor running
decision suppose
polling overhead
fifty kilo
transfers data
cases huh
huh vast
wasting lots
significant extent
huh poll
cycles consumed
percentage huh
computation instruction
ratio huh
huh polling
poll huh
similar factors
processor clock
lost sufficient
tolerable device
faster device
sixteen bytes
cycles divides
percent wh
spend twenty
huh solution
interrupt driven
driven input
processor attention
transferring control
huh exception
handle exceptions
external word
internal exceptions
illegal instruction
arithmetic overflow
specific cycle
huh respond
external exceptions
exceptions huh
early attention
exceptions occurring
huh an
vector interrupt
non vector
interrupt vector
exception handler
specific exception
vector case
control takes
specific location
code check
similar scenario
driven transfer
processor working
continuous interrupt
interrupt infact
entire huh
huh duration
huh saving
attention when
polling based
clock sequence
twenty-five percent
we assuming
real overhead
percent huh
huh overhead
huh process
involve processor
deposit data
processors role
initiate huh
setup things
huh tra
tra huh
entire job
huh check
check huh
bad sector
processor interrupted
error huh
special controller
special piece
addresses amount
huh word
word amount
processor logic
sequential address
huh le
le lets
huh running
megahertz suppose
requires thousand
thousand cycles
huh end
spending thousand
thousand cycle
cycle lets
achieve transfer
operation requires
end and
and divided
first factor
hundred huh
huh polled
transfer depending
huh requirement
device we
suitable mechanism
cost issue
controller means
cost huh
huh read
operation number
dedicated memory
major activity
direct communication
thing work
huh wha
problems caused
huh translation
transfer lets
explicit conversion
huh remember
arbitrary addresses
contiguous areas
contiguous area
larger piece
huh consistency
recent information
input happening
copy exist
date huh
reverse happening
happening huh
upto date
back cache
making updates
similar problem
problem occurs
multiprocessor cases
shared memory
first problem
page fo
memory problem
huh additional
additional actions
cache controllers
multiple copies
protocols huh
huh coherence
sync huh
updation occurs
additional overhead
overhead work
handle huh
device specific
specific details
handle interrupts
multiple processor
file organization
defining huh
device status
status huh
interrupts huh
higher overhead
complex mechanism
controller disk
individual aspects
design issues
achieve huh
performance objectives
mind and
latency aspect
throughput aspects
huh achieving
huh when
huh crosses
controller buses
huh processing
similar path
throughput issue
issue huh
slowest link
huh easier
easier huh
data flowing
throughput huh
complicated issue
delay huh
complex interaction
last resort
entire behavior
huh then
accurate manner
latenc huh
state flow
huh li
li li
huge amount
out read
reverse that
simple application
huh attain
adapters buffer
supporting multiple
multiple disks
data send
processing involved
numerical parameter
components huh
huh con
throughput limit
discussed depends
protocol the
megabytes performance
ten milliseconds
rotation latency
controller delay
operation involves
single track
milliseconds delay
huh sixty-four
position huh
bytes transfer
transfer requires
requires huh
transfer takes
sector huh
deposited huh
initiation path
huh hundred
problem problem
maximum input
output rate
fixed components
single processor
problem involves
first finding
fo huh
lets analyze
individual huh
huh component
fixed component
thousand instruction
hundred mille
huh maximum
huh matching
thousand operations
huh object
block huh
out huh
smaller figure
first answer
twelve point
milliseconds latency
milliseconds transfer
transfer seek
forty-three point
huh sustaining
thirty-six disks
huh controller
addressing capability
pumping data
de huh
simple calculation
simple rules
complicate formula
formula you
huh design
design problem
problem huh
multi-function unit
unit huh
receive faxes
cost scanner
cost printer
inexpensive processor
suitable memory
incoming fax
photocopy operation
printer function
fax receiver
receiver scanner
modem function
fax sender
memory sitting
background huh
operating requirements
huh fax
fax load
continuously fax
ha huh
outgoing faxes
fax message
single page
to worry
sending multiple
multiple pages
size pages
load huh
spare capacity
photocopying process
mind huh
huh setup
bus adapter
adapter sitting
scanner printer
printer modem
huh build
dedicated system
huh work
fax machine
non-volatile memory
point detail
medium resolution
resolution print
print huh
size fixed
fixed page
eleven inch
simply work
gray levels
levels huh
gray level
fax purpose
for photocopy
photocopy purpose
scanner works
printer works
huh continuing
thirty-three kilo
percent overhead
percent extra
extra data
added huh
cost processor
options hundred
gigahertz type
accesses memory
operation huh
fax requires
huh decoding
scan image
huh compression
decoding involves
involves hundred
raw data
image huh
ten kilo
executed performance
performance byte
incur cum
computational load
flat rate
instructions performance
thirty percent
additional access
sixty-four megabytes
twenty-eight megabytes
forty million
million words
wh choice
so lets
page carries
carries huh
eleven inches
white mode
gray scale
scale mode
mega pixels
fax line
huh will
disk size
size lets
code huh
reasonable cushion
scan pages
huh nonvolatile
nonvolatile memory
volatile memory
huh augmented
execute program
flash huh
fax process
modem speed
compressed page
encoded page
ninety-nine kilo
out transmission
ninety-nine multiplied
incoming call
establish connection
purpose fo
call huh
fax rate
huh handling
handling faxes
faxes huh
convenient figure
figure in
minute huh
minute so
send fax
out attention
scanning rate
outgoing fax
out rest
photocopying purpose
purpose huh
hand printing
printing rate
capacity and
and huh
huh photocopy
photocopy operations
higher load
photocopying rate
huh churn
photocopy pages
printed huh
photocopy process
modem scanner
modem traffic
printer scanner
scanner traffic
bus sees
fax operation
faxing operation
doing photocopy
scanning point
total demand
photocopying operation
message huh
huh is
is huh
out involves
huh reading
small component
computation power
ninety-nine point
fax incoming
photocopy huh
requires hundred
total point
total instructions
instructions throughput
scan rate
small factor
minor difference
rate required
twenty-five mips
megahertz processor
megahertz version
memory bandwidth
bandwidth huh
full capacity
suppose processor
twenty-five million
million instruction
instruction words
huh load
store type
additional demand
huh traffic
instruction traffic
data traffic
store traffic
mem huh
end result
questions huh
proceed huh
huh rule
steady state
huh congestions
starving huh
sturdy state
buses converging
multiple de
de devices
we we
latency issue
scan button
copies printed
you huh
huh receiving
sending faxes
faxes photocopying
queuing delays
bandwidth calculation
wh when
processor execute
instructions required
require tools
queuing theory
huh scenario
huh started
disk end
controller end
bus do
taking huh
huh twelve
scsi bus
occupied huh
interleaved leaving
scsi controller
disk lets
shorter period
huh present
th scsi
thing coming
streams coming
suitable bus
concluding remarks
lecture huh
objectives huh
computer work
processors issues
hierarchy pipelining
summary huh
huh discussed
code instruction
complete processor
huh words
exponential growth
single monetary
monetary unit
dollar huh
tube system
divided huh
huh focus
focus huh
software meet
huh machine
program end
adders registers
registers multiplexers
multiplexers buses
hardware end
huh risk
risk variety
variety reduce
instruction tr
choice huh
huh building
fast processor
huh ease
doing pipelining
generating code
huh pertaining
huh aspects
huh power
processor chip
square centimeters
centimeters increasing
elaborate arrangement
directions execution
gross level
huh execution
basic huh
huh parameters
count cycles
are varied
case fast
programming point
huh developing
design huh
put hardware
additional logic
logic shown
comparison so
complex operations
divider huh
notice similarity
restoring manner
manner non-restoring
non-restoring manner
non-restor non-restoring
non-restoring division
multiplier hardware
divider hardware
common huh
key differen
big register
bottom shifts
unit capable
single unit
division depending
tremendous improvement
save adders
array form
huh adders
save additions
significant factor
huh noticing
huh integer
integer operation
point operation
standard method
additional feature
performed huh
accurate arithmetic
sticky bits
special number
entire process
instruction executions
executions starting
instructions picking
operands doing
first design
simple combinational
huh black
clear distinction
distinction made
huh sharing
huh makes
larger variety
box represents
represents activity
boxes determines
accommodate huh
box so
things distribute
huh pipelining
huh instructions
issued huh
introducing registers
separate pipeline
pipeline stages
hazards huh
huh structure
structure hazards
conflicts occur
inherent huh
huh program
program logic
huh extra
extra control
huh flushing
out instructions
bl decision
forwarding data
huh spent
flat structure
huh fast
inexpensive and
and dense
inexpens manner
typical cache
organization is
is shown
varying degree
associative huh
alternative slots
associative manner
doing parallel
parallel comparison
huh parallel
huh search
adv impact
positive impact
huh throw
huh main
memory form
disk stores
stores huh
virtual huh
associative buffer
first huh
huh lecture
network card
graphics display
display card
recent board
years huh
performance and
memory interconnection
complete motherboard
set build
rare opportunity
ap application
application level
architectural huh
huh com
compiler operating
deep understanding
technical development
huh understanding
al al
huh points
huh embedded
computers huh
designing huh
huh adapt
adapt huh
complete solution
huh statistics
table servers
servers huh
huh desktops
embedded processors
last huh
huh ov
cons years
saturating huh
curve th
fast growth
so wh
huh availability
person huh
huh num
computing device
huh intelligent
programming the
fix function
fix set
software design
combined hardware
size rate
rate power
tremendous opportunities
huh do
do doing
interesting work
area huh
processors huh
huh servers
servers desktop
embedded huh
desktops laptops
laptops mobile
machines etcetera
huh operation
micro-controller huh
program and
huh computers
interesting huh
huh possibilities
personal experience
huh villages
small means
delicate things
inexpensive intel
huh couple
cheap huh
car battery
bicycle wireless
wireless internet
internet cards
powered hilltop
hilltop relay
relay station
telephone system
local language
similar huh
huh bangalore
huh recognize
cost computer
strong arm
low power
consumption huh
modem linux
touch pad
speech capability
speech input
speech output
read text
illiterate person
reasonable medium
huh spoken
out and
modern technology
scientific experiments
redwood tree
scientist wanted
study huh
biological phenomenon
joint trees
tree absorb
absorb moisture
initial attempts
place lot
cables running
simple huh
huh sensors
sensors miniature
miniature battery
driven wireless
wireless sensor
huh trees
base and
huge cables
bring safety
huh automobiles
huh french
train system
fast system
signaling system
computer based
based huh
huh track
track system
signaling mechanism
system issues
issues commands
driver huh
huh continue
news medium
medium wh
traditional huh
newspaper medium
huh web
web sources
sources huh
regional boundaries
nontraditional nonlocal
nonlocal source
news huh
huh preserving
huh image
image processing
processing techniques
huh diagnosis
add huh
huh applications
developing huh
important concern
terrorism the
huh prevent
prevent huh
dangerous thing
traditional approach
huh security
security people
problem th
small part
exhaustive checking
camera base
bright dots
displays huh
emit light
digital camera
camera video
video camera
camera sitting
lights illuminate
vehicle rides
limited huh
huh field
part and
video signals
control room
video huh
you generate
single picture
sophisticated huh
complete image
careful huh
computer it
it it
dedicated application
performing huh
sophisticated task
entry exit
exit gates
gates huh
driven cars
driving huh
security man
card huh
huh identification
identification number
card identification
right person
right car
workable system
patience huh
device installed
car huh
packaging huh
prom huh
programmable read
main thing
infrared source
huh sender
infrared signals
carrying huh
smart card
golden thing
chip wh
tiny processor
credit card
card size
size thing
electronic cash
electron electronic
carries identity
control computer
car is
gate you
gate huh
light huh
interesting design
battery driven
driven device
consumption reducing
operation organized
in-house development
designed computer
based system
interesting areas
transcription
brindha
computer
architecture
prof
anshul
kumar
department
science
engineering
iit
delhi
lecture
processor
design
control
multi
cycle
discussing
execution
instruction
divided
multiple
clock
cycles
data
path
designed
today
controller
aspects
controlled
sequence
lectures
designing
started
simple
done
single
notice
problem
performance
issues
moved
style
wha
actions
instructions
putting
sequences
build
flow
carrying
out
identify
signals
required
steps
doing
group
groups
define
meaningful
operations
micro
viewed
set
simplify
establishing
relationship
states
signal
values
finally
transit
complete
part
starting
point
arrived
last
key
resources
memory
register
file
alu
maximum
utilization
recall
intermediate
results
store
registers
brought
stored
read
similarly
operand
operation
res
short
result
components
change
indicating
write
multiplexer
usual
changed
size
organization
redefine
first
lets
back
activity
recorded
start
working
noise
class
word
form
address
takes
value
concurrently
two
addresses
excuse
provided
relevant
fields
bit
twenty
sixteen
corresponds
meant
box
simultaneously
number
actual
performed
written
generic
sense
guided
function
field
involve
transferring
bits
eleven
fifteen
destination
things
made
careful
choice
involves
access
fetch
updation
program
counter
bringing
participate
calculation
carry
accessed
calculate
adding
offset
coming
sign
extension
temporarily
contents
require
four
load
similar
reading
manner
fourth
carried
move
beq
lot
work
operands
compared
ready
target
case
branch
free
comparison
don
transfer
immediately
condition
checked
checking
compare
holds
transferred
req
requires
lastly
jump
compose
taking
missed
shift
concatenated
impression
earlier
resource
consuming
accessing
total
delay
max
occupying
reason
sequentially
pick
incremented
incrementing
put
picked
sequenced
additional
approach
roughly
equivalent
addition
update
directly
formed
right
decided
encompasses
requiring
sequencing
pins
timings
conceived
imagining
basically
period
accommodate
quantized
discretized
periods
clear
proceed
worse
essential
division
separately
picture
global
view
thing
screen
omitted
pieces
text
matter
detail
retain
destinations
main
cases
exist
details
excess
performing
arithmetic
logical
storing
essence
skeleton
captured
task
commonality
common
merge
apparently
action
state
differing
boxes
correspond
arrive
sort
transition
diagram
describe
moment
graph
moves
merged
merging
pro
branching
important
noticed
stage
contemplating
bifurcation
splitting
onwards
opcode
split
fetched
typically
complex
decoding
understanding
circuit
allowed
full
place
fully
occupied
practically
occur
step
completed
chains
special
make
harm
answer
functionality
consume
energy
agree
attempt
calculated
repeat
occupy
discard
consumption
holding
overwritten
trouble
tha
postpone
superfluous
unnecessary
discarded
occurring
postponed
referred
hit
eventually
remember
frequency
occurrence
comparatively
lower
impact
loss
negligible
mind
clean
situation
end
separate
branches
broader
repeated
chain
concerned
small
finite
machine
ten
cycling
decode
follow
paths
long
power
range
varied
worry
perform
improvement
possibility
bifurcate
reduces
exercise
component
understand
abbreviating
rew
cha
chart
decide
multiplexers
controls
decides
sources
writing
calling
rdst
source
hand
handling
inputs
labeled
noiselor
table
exhaustively
related
call
considered
understandable
affect
grouping
wise
substantially
talk
list
psrc
pwu
pwc
unconditional
conditional
unconditionally
generate
derived
explain
imply
dont
care
selecting
output
check
correct
bring
keeping
gate
making
handled
differently
effect
generated
conditionally
activate
means
etcetera
binary
code
decimal
activities
default
feed
points
inactive
doesn
irrespective
dictates
produce
gates
derive
connected
question
worrying
happening
happen
overriding
suppress
select
input
changing
give
names
convenient
subsequent
discussion
increment
convenience
assigned
revolve
fetching
makes
heard
occurred
kind
redundancy
possibilities
totally
identical
observation
limit
low
talking
tells
m2r
modifying
complementary
reduce
rs2a
rt2b
res2rd
mem2rt
opc
circuitry
unchanged
appearing
influences
ensure
comparing
coding
simply
calculations
logic
subtraction
encoding
fill
assert
tabulate
redraw
symbols
sinamic
statements
replaced
symbol
described
previous
slides
paddr
numbered
tables
depend
bifurcating
listing
identified
shows
pair
mentioned
ends
calculating
sep
distinct
find
offsetting
completes
performs
infirmsed
influencing
replace
vector
defines
encode
truth
transitions
defining
depending
conditions
wont
kinds
combinational
block
implement
shown
plas
hold
draw
alternative
stop
summarize
defined
microprogrammed
datapath
scheme
concentrate
finish
alternatives
pla
rom
implementation
parts
produces
implemented
discuss
controlling
basic
pattern
effective
symbolic
assignments
transfers
label
crucial
starts
capture
describes
supposed
substitute
zeros
description
encoded
forms
showing
black
green
numbers
upto
discussed
altogether
present
grouped
row
column
combination
describing
capturing
flowchart
codes
opcodes
outputs
compact
representation
sparsity
dimensional
combinations
listed
vertically
current
raise
entries
lots
cares
fixed
rewritten
labels
conventional
represent
nex
implementing
specific
drives
generating
deciding
thought
smaller
general
purpose
suppose
expanded
truthtable
rows
essentially
apply
effectively
works
definition
implements
difference
terms
words
multiplied
plane
running
true
false
vertical
lines
product
governs
governed
factors
run
line
term
alternatively
area
rectangle
promotional
dimension
accommodates
height
proportional
width
economic
rom001234
sparkcity
reasonable
illustrate
contribute
show
option
illustration
raised
thousand
twelve
thirteen
fourteen
expands
expand
sixty
mention
executes
programs
generates
deal
manipulating
files
disadvantage
based
differences
imagine
applied
tho
remains
arrangement
presented
sequencer
ensuring
stepping
locations
programmed
correctly
information
communicated
wondering
isn
incrementer
adder
bulk
restarting
dispatch
terminology
reset
larger
sufficient
determining
selected
roms
leave
ways
determine
level
language
studied
initially
primitive
represents
incidentally
normal
rest
beginning
assembler
translate
variations
structure
horizontal
programming
microprogramming
support
provision
high
degree
concurrency
idea
conserve
space
past
thousands
patterns
utilize
log
requirement
lose
versus
non
contrast
hardwired
pros
cons
advantages
easy
easily
good
independently
chip
drawn
add
modify
remain
fact
times
families
attempts
emulation
hardware
process
emulate
simulation
simulate
internal
temporary
person
penalty
slower
tend
longer
popular
partly
tools
tdf
final
difficult
advantage
efficient
controllers
talked
options
levels
stages
initial
express
arrows
equations
technically
large
significant
thirdly
looked
microprogram
drive
microsequencer
determines
pipelined
type
objective
cpi
initiate
ideally
pipeline
benefit
situations
introduced
briefly
hinted
hazards
types
structural
eliminate
inherent
concept
rules
ignore
ideal
initiated
introduce
shifters
rooters
behaves
context
possibly
augment
handle
basis
complicated
easier
discussions
simplification
extenders
analyze
updating
decoded
subtract
facility
skip
wasting
operates
uniform
cutting
forward
cut
thirty
ninety
pass
couple
backward
passing
deliberately
turning
multiplexing
expecting
spirit
loop
turn
pumped
missing
removed
computing
choices
peculiar
consequence
experiencing
idling
homogenous
fashion
slight
day
delayed
amount
experience
feeding
position
consistent
mismatch
multiplex
logically
consequences
length
increase
early
argument
positioning
unit
allowing
positioned
solution
saving
reach
correction
thi
share
implications
influence
repositioning
dictated
longest
storage
element
neglecting
treating
real
life
combined
delays
critical
lumped
achieves
balance
slack
room
side
trade
cost
universal
optimize
multi-cycle
vision
purely
sig
organized
determined
questions
students
asked
theory
machines
mealy
moore
suit
flight
maintain
fortunately
turns
reconstruct
superimpose
goint
lsb
connect
gated
havnt
mixing
found
ing
sitting
ignoring
identity
places
solved
synchronizing
cur
applicable
extend
passed
extended
walls
units
inserting
sequential
portions
remembering
timed
focus
tension
enables
root
irrelevant
modified
remove
tapping
applying
datas
remaining
interesting
suggested
delaying
giving
stay
internally
pull
added
series
bothering
hazard
suffer
reduced
consecutive
dependence
computed
gap
deep
opportunities
extent
matches
sharing
half
bubbles
absence
valid
computation
wrong
detect
dependency
close
match
reached
forwarding
enable
halt
disable
whats
decision
tendency
realize
mistake
nullify
flush
detecting
freeze
prediction
statically
heuristic
predict
inline
loops
iterated
static
dynamic
track
happened
encountered
sophisticated
light
suitable
moving
smoothly
insert
suitably
introduction
flowing
held
including
blindly
flushed
predictions
fairly
straight
software
solutions
unlike
introducing
interacting
compiler
whichever
analysis
rearrange
minimized
dependent
meaning
rearrangement
order
independent
reordered
reordering
worst
ops
construction
extra
positions
slots
filled
tagged
transformation
programmer
simplifies
learnt
inter
carefully
con
fed
detection
stalling
flushing
minimize
face
therf
correcst
techniques
improve
examine
stall
stalls
detected
technique
bypass
spite
recollect
issue
begin
waste
middle
forwarded
axis
expect
prolong
fruitful
stuck
stays
proceeds
views
shot
snap
shots
emerge
throw
minus
tower
trace
shaded
ins
queue
null
utilizing
spent
culminate
stopping
fluid
air
bubble
instant
background
accurately
nop
nops
profile
persists
re-rooted
wires
sake
clarity
prevent
explicitly
turned
land
assuming
illustrated
achieve
desired
figure
stating
waiting
tow
occasion
precisely
notation
dot
active
satisfied
specification
matching
setting
intends
cache
haven
hat
reads
refined
omitting
multiplexed
bates
separated
conflict
scenarios
leading
solid
dotted
tap
dma
strictly
speaking
dm
send
augmented
copy
proper
symbolically
energize
equal
intending
digit
picking
writes
overwrite
latest
freshly
specifically
referring
shortcoming
analyzed
effects
slabs
inserted
activated
develop
developed
mips
worked
eliminating
speed
scheduling
parallel
instants
guide
continue
assume
continues
broken
entered
intended
expected
tested
outcome
latching
shifts
prove
trapping
ultimately
undergo
account
redistributed
borne
anticipation
loading
realized
acts
evaluated
evaluation
earliest
predicting
factor
architectures
flags
test
flag
trivial
preceding
previously
rid
decisions
events
rare
event
probabilistic
average
improved
dynamically
distinguish
predication
elimination
testing
predicated
processors
feature
attach
fused
attached
specifies
removing
explicit
preparation
saved
virtual
involved
page
translation
advantageous
omit
stretch
horizontally
thrown
quality
comparator
motivation
implication
adverse
equality
simpler
greater
proprigated
afford
inequality
fast
bna
speeded
marginally
losing
occurs
speeding
evaluate
statement
role
generator
treat
undo
guess
criteria
created
equally
exception
occasionally
executing
record
inside
occurrences
minded
intelligent
flexibility
selectively
bypassing
nullification
annulment
slot
poorly
strict
outer
iterations
strategy
vice
versa
instance
mispredictions
enter
bra
iterate
entering
exiting
chosen
policy
commonly
represented
remembers
summary
outcomes
arcs
transiting
arc
depict
comfortably
continuously
depicted
mechanism
avoid
double
mistakes
history
buffer
assumption
constant
obtained
bound
bne
organizations
associative
contrantive
decibel
carries
statistics
search
variation
assumed
due
anticipated
predicted
probability
percent
coupling
correlation
left
varies
hundred
accuracy
recently
recent
string
incurring
powerful
method
push
striking
causing
built
producing
pushed
expensive
busy
nicely
speculative
stuff
super
scalar
execute
necessarily
window
stream
parallelism
capable
finds
consistently
ilp
rely
query
whe
coded
vliw
driven
functional
ports
assign
operational
timing
top
overlapping
biw
scale
perspective
modern
pentium
ibm
risc
desktop
specialized
applications
compatibility
intel
eighty
version
exists
older
user
faster
architecturally
fundamentally
regenerate
pack
appropriately
object
commercial
major
specialize
impossible
features
specially
density
poor
packed
scalars
higher
vlwi
conclude
exceptional
cycle-design
processing
exceptions
overflow
fault
illegal
knowing
precise
interrupt
imprecise
interrupts
model
inconsistent
insist
status
naturally
resume
executed
partially
restart
realizing
complexities
pipelining
wrongly
dyna
led
superscalar
lies
slightly
cross
barrier
engineering,iit
architecture-1
arhitecture
interface
provide
behaviour
definitions
computations
distinction
assembly
building
blocks
harware
interpret
goal
expressed
efficiently
maximize
efficiency
goals
reaching
toy
people
stanford
eighties
typical
risk
computers
subsequently
developments
nec
nintendo
video
games
silicon
graphics
sony
play
station
grasp
simplest
assignment
sum
equivalently
dollar
signify
association
variable
established
arbitarily
infix
opponent
conventionally
infact
simplicity
favors
regularity
uniformity
format
adds
limiting
arbitary
sides
fit
atleast
possibily
spend
beat
expressions
subtracts
additions
location
seat
restate
structures
records
arrays
complexing
capacity
limited
mapped
array
consisting
bytes
convention
addressable
byte
quarter
addressability
resolution
individual
addressed
index
conventions
spelling
error
endian
big
numbering
minute
reverse
spark
lab
simulator
adapts
host
pentiums
fifty
centre
aligned
bottom
ending
physically
consists
twoand
spread
physical
direction
eigth
integer
stands
elements
contained
loaded
stand
indices
expression
interchange
arguments
standard
interchanging
variables
loads
preparing
multiply
elaborate
multiplication
indexing
prepared
entire
opposite
interchanged
temporaries
return
seventeen
examples
labelled
divide
signifies
fuction
contrary
filed
unused
shamt
appears
eighteen
hexa
deviate
uniformly
deviation
nature
demands
compromise
rigid
constants
equivalents
skipping
linked
subtracting
puts
flows
jumps
organised
slt
compares
sone
alter
combine
blt
told
formats
exact
intialized
suffix
obvious
deviated
hardwared
virtue
rate
devote
fills
extraction
lui
upper
ori
odd
job
flavors
counterpart
man
learned
circuitory
student
entererd
swap
swapped
ensured
integers
addressing
prefixing
ors
market
natural
designer
deeper
architectural
users
perspectives
deign
quantitative
metric
quantification
perpective
designers
purchasers
perpesctive
buy
system
organisation
personal
variety
manufacturers
vendors
vendor
intuitive
save
money
settle
rupee
price
ratio
pose
sets
styles
stack
accumulator
philosophies
fix
cheapest
study
precised
measuring
measurable
quantity
measure
report
measurement
experiments
summarizes
experiment
judgement
project
hype
requirements
reflects
summarizing
isimportant
piece
emailing
attention
domain
daily
parallels
aircrafts
airline
debating
declared
perfomance
columns
aircraft
miles
hour
refueling
passengers
parameters
telling
concorde
interested
flights
stoppage
airports
distance
passenger
boeing
trips
targets
interest
application
hours
atlantic
inversely
throughput
composite
figures
brings
notions
travel
response
latency
concern
wall
interactive
environment
database
atm
command
request
seconds
minutes
tasks
jobs
shoes
manager
catering
community
secondary
wait
service
collection
needed
choose
measures
quick
lead
policies
depends
perhas
aspect
predominantly
bigger
reciprocal
relative
runs
speeds
mph
persons
pmph
focussing
closely
upgrading
giga
hertz
increasing
scheduled
overhead
switching
knew
deteriorate
lying
counting
front
network
atmmachines
supporting
waitin
fire
transcaction
waits
transaction
respond
continuing
practical
reasons
costing
isolation
ticket
budget
minimum
cpu
disk
tasking
spends
exclude
communication
incurrs
attributable
serve
peripheral
clarify
break
periodic
ano
discrete
edges
mega
nano
relating
million
milli
divivded
reciprocals
count
thee
quantities
equation
dimensionally
balanced
cancel
fraction
formula
substituting
seventy
macro
increases
depended
inverse
rates
direct
fractional
shorter
waited
cpis
weightage
frequently
occuring
categories
category
totals
arithmetical
weighted
percentage
interestingly
instrution
forty
minimizing
explaination
multiplications
divisions
floating
accesses
picks
redesign
hoping
improving
closing
gradually
technology
informed
pardon
sir
doubled
seperately
operating
exciting
walks
integral
shapes
sizes
packs
capability
nineteen
fifties
began
hall
insufficient
weather
nuclear
astronomical
bio
informatics
tiny
hidden
home
appliances
cameras
mobile
phones
projector
remote
diversity
learn
principle
binds
outline
firstly
studying
structured
objectives
propose
notion
misleading
principles
todays
responsible
cahes
concepts
scope
advanced
courses
covered
glimpse
opportunity
existing
devolping
administrator
responsibility
agin
knowledge
relations
embedded
throws
open
achitecture
relate
buildings
plan
layout
residential
living
dining
kitchen
balcony
civil
engineer
wory
shouldn
fall
durable
stresses
strains
durability
architect
realise
transistors
capacitors
abstractions
disciplines
layers
abstraction
matters
consideration
depth
seperated
coping
complexity
millions
extremely
boggling
familiar
java
returns
translated
eqivalent
okat
automat
circuitary
link
understood
base
digits
originally
understands
module
central
devices
mouse
keyboard
display
bus
buses
bridge
connecting
sub
stores
relational
connects
modules
world
composed
exclusive
consisted
transistor
systems
fabricated
pictures
peep
motherboard
electronic
mounted
supply
peripherals
floppy
hard
cdrom
fan
bar
fins
heat
sink
heart
cards
zoomed
visible
plug
contollers
pci
package
chips
seagate
medium
recording
highest
lus
lowest
showed
adders
boundary
hierarchy
refers
flip
flops
concerns
manage
compile
isa
broad
fabricating
wire
interconnect
manifestation
permanent
layer
compilers
resistances
posssible
tricks
employed
lap
tops
battery
dominating
extreme
methods
progress
operate
create
functions
arithematic
operated
differ
invoke
helps
providing
languages
deviced
revolutionary
permits
lost
supposedly
reals
mathematics
unbounded
bounded
coincide
approximation
precison
nice
properties
satisfy
mathematical
associativity
property
abstracted
asembly
behave
feeling
limitations
isolated
reality
abstract
acess
slow
memories
flat
hierarchial
practice
focuses
asymptotic
answered
theoritical
designs
harder
treated
engine
proces
opens
customized
customize
completary
desk
washing
tremendous
apriory
presentation
listening
music
phone
calls
cpus
manufacturer
rectangular
tcq
circular
packaging
device
packages
approximately
spaced
contrasting
consumes
transparent
quartz
erase
forget
generally
upgrade
expose
ultra
violet
content
cared
infrequent
chage
topics
cover
feel
properly
dealing
homepage
announcements
exercises
overview
incidently
doctor
kolin
paul
conducting
tutorials
joining
material
teaching
assistant
harsh
dand
announced
submission
guidelines
submitting
spin
download
services
textbooks
book
readable
henasy
paterson
books
vocationally
refered
huring
jordan
haze
interchangeably
rigerously
minors
majors
quizs
asignment
consist
recollecting
mobiles
palm
organiser
net
delivered
insight
subject
political
future
tommorow
century
generations
landmark
development
labs
opinion
recognize
regular
generation
recognised
technological
drastic
sudden
shape
rise
fundamental
shunk
affordability
affordable
organisations
equipment
drastically
magnitude
reliability
reliabily
forties
vacuum
tube
bulb
amplify
switch
voltage
bulky
reliable
powerguzzlers
huge
roomful
punched
paper
tapes
rotating
drum
magnetic
suddenly
rapid
growth
marked
absolutely
abrupt
accord
arrival
transitor
texas
instruments
cheaper
fail
versions
fortran
cobol
integrated
circuits
integrate
integration
characterised
ssi
msi
lsi
tens
increased
tape
batch
submit
days
press
button
prepare
deck
progam
roll
punching
somedays
syntactic
nil
message
tedious
terminals
keyboards
interact
online
mode
evolved
vlsi
appeared
arise
ulsi
seventies
late
tending
hundreds
individuals
owning
posible
shrunk
capablities
emphasis
graphical
microprocessor
era
literature
revolution
artificial
intelligence
human
massive
undertaken
japan
technical
respect
decreased
astonishing
technologies
years
raises
dram
ram
semiconductor
linear
exponential
theyears
year
doubles
quadraple
doubling
include
contribution
decade
sunfour
mix
bakel
programmable
konrad
zuse
harvard
mark
accomodates
caches
traced
eniac
developers
eckert
mauchly
significantly
successful
researching
capabilities
pin
inventor
competing
claims
virtues
john
fon
newman
developing
wrote
neatly
stated
invented
univac
research
repeatable
commercially
ibms
enters
remained
player
industry
original
institute
bank
america
banking
micr
ink
corrector
ics
date
game
spacewar
invention
arpanet
defence
funding
arpa
agency
funds
projects
usa
begins
flexible
ethernet
networking
consumer
span
apple
trs
commodore
spreadsheet
visicalc
wordstar
hobby
companies
reaped
microsoft
largely
msdos
lisa
extensive
gui
graphic
primarily
textual
textually
macintosh
windows
photographs
ssec
compute
moon
apollo
pumched
tubes
relays
switched
floor
feet
printer
dollars
orders
cdc
pipelening
ideas
traceable
illiac
university
illionos
urbana
champaign
mini
cabinet
pedestal
pdp
writer
crt
monitor
terminal
xerox
alto
stations
fledged
pirating
granted
cray
company
clay
cabinets
arrange
cables
panels
cable
cooling
aragon
shrinking
atomic
dimensions
atoms
meters
grid
wide
billions
netrworked
solve
quantum
promise
solving
tough
problems
dna
dnas
grow
programmers
architecture-2
letter
constructs
thenelse
conjuction
pointer
subtle
summing
unusual
correlate
intialising
body
termination
header
prefix
ging
repair
comment
pseudo
tutorial
cursor
dedicated
restrain
mixed
assemblers
usage
core
directives
directive
initialize
leaving
bother
halves
denoting
superposes
portion
initialization
wanted
summation
pointers
modification
pointing
dereferencing
star
lesser
gain
worried
skipped
improvent
maintaining
eliminated
computes
improvements
nested
sorting
algorithm
iterates
smallest
detailed
scanning
iteration
scan
anchor
terminate
initialized
updated
pointed
prepares
limits
staement
encounter
lie
boolean
falls
comparisons
messy
elegant
multiway
exit
obtain
properiat
jumping
subtractions
btehe
jumped
offered
contiuous
continuos
sparse
bared
bodies
paded
blanks
fourty
bge
noted
positive
negative
twos
complement
varieties
varying
located
boundaries
multiples
aloop
automatically
lsbs
segment
segments
region
figuring
transfering
tight
importance
nitty
gritty
writters
transformations
comppiler
inefficient
convert
systematic
tranformations
architecture-3
procedure
construct
summarized
includes
felt
procedural
dealt
thinking
ease
procedures
linkage
tranfer
ruturn
everytime
parameter
caller
consumed
local
decorations
fresh
allocation
procure
accessable
nesting
recursion
indirect
organising
organize
xchg
exchange
enveloped
jal
saves
denote
pertaining
wiill
completing
prodedure
encapsulated
returning
void
callee
designated
convey
returned
resort
restricted
declaration
tructures
continuous
tranferred
lengthed
ddress
endless
precaution
restored
preserves
huh
redefined
min
repeating
replacement
updates
padded
elaboration
recursive
indirectly
exceeds
finding
restoring
looping
repeatedly
entry
popped
pushing
popping
pictorially
conceptually
reducing
decrement
pop
restore
allocating
earmark
pay
availability
freely
finishes
partial
preserve
destroy
fingers
safe
preserved
complying
feels
necessity
callers
stick
disturbed
aspected
calleee
untempored
guarantee
safely
recover
temporing
touching
constraint
expanding
kernel
reserved
shared
frame
shortly
conveniently
assumes
reported
usages
activation
abou
vary
allocated
sees
reference
accessible
everythinh
referenced
difficulty
act
bracket
offsets
arranging
complications
creation
shrink
couldn
aggregate
pushes
pops
isallocated
deallocated
matched
areas
heap
grows
shrinks
random
allocations
malloc
automatic
partition
clash
successfully
hope
allocate
routines
kep
disposed
funtion
funtions
inputting
matrix
sorted
matrices
arekept
stright
declarations
permit
spliting
wastage
utilised
creates
maintained
initialised
scanned
creating
ascending
exhausted
tail
disposing
reserve
inaccessable
recursively
vaue
initialising
fom
quickly
sample
filling
thethird
copying
copied
dispose
comparitively
invocation
labeling
prime
adress
recovering
peak
analytically
experimentally
analytical
empty
decreases
rewrite
restructure
existence
characteristics
cisc
broadly
characterize
predominant
flavour
movement
linkages
curent
sothis
supplied
spaces
configuration
modes
resulting
implicit
borrow
suffixed
stricly
completely
orthogonal
largest
fair
doan
orthogonality
constrasting
increments
succeeds
danger
slowing
ticks
universality
philosophy
restricting
mixture
somwhere
favor
classified
replaces
acc
participating
implicitly
prosessor
classify
registerless
sun
sparc
instances
interpretation
decreasing
auto
decrementing
pre
post
catered
generalities
characters
generality
deallocation
provisions
comon
helpful
generalization
coined
henassi
patterson
existed
approaches
propagated
targeting
achieving
berkley
contemporarily
popularly
historical
roots
hewlett
packard
motorola
dec
alpha
sixties
classical
vax
stood
digital
coorporation
considerations
optimal
substantial
intels
redesigned
baggage
clumsy
helped
pump
investment
beautiful
perfected
desirable
pays
efforts
directions
stacks
salient
numerous
grew
climax
origin
effort
business
rival
mainframes
xcxc
servers
nineties
extensively
machintosh
similarities
parity
worth
mentioning
decremented
facilitates
similarity
filelds
distinguished
choosing
disallow
indexed
versatile
displacement
absolute
subroutine
unequal
chck
shorten
lwu
scalable
scalability
scaled
toshiba
fujitsu
cypress
tatung
extensions
uncnditional
squeezed
implementations
differs
aprocedure
disjoint
overlap
globals
cwp
cyclic
sliding
purposes
fives
successor
discontinued
compaq
illusion
topic
extends
character
strings
theer
deferred
indirection
scaling
autoincrement
autodecrement
polynomials
insertion
datatype
implies
excluded
informations
packing
unpacked
confined
breaks
sixeen
companion
coprocessor
kilo
demand
newer
paging
mmx
multimedia
simd
comments
textbook
illustrates
golden
handcuffs
tied
constrained
clothing
bag
love
pursued
lacks
success
widely
headache
supports
permitted
irregular
extremes
correspondence
grace
subset
eax
ebx
ecx
edx
quarters
ebp
esp
edi
segmentation
addres
shifted
proceeded
modifies
prefixes
modifications
override
semaphore
locked
overridden
strength
strongest
contd
angles
peformance
professionally
architects
interlink
clocks
measured
ipc
confine
relates
conversely
talks
spending
instantaneous
fastest
nut
shell
statistically
occupies
pitfall
indicators
knock
classes
clas
tempted
essentilly
trades
quantify
counted
miliion
spendind
answers
unknown
faced
focussed
compilations
editings
scientific
personalized
evaluating
benchmarks
collectively
bear
benchmark
reflect
overly
misrepresent
usefulness
mutually
agreed
standardized
abused
highly
optimized
consortium
spec
cooperative
industries
joined
hands
standardize
declaring
tabulating
platform
synthetic
abuse
attack
chances
abuses
valuable
benchmak
tests
lighter
colour
orange
enhanced
optimization
rating
bars
gcc
compiled
marginal
stress
spice
lisp
interpreter
dark
dramatic
clever
trick
totality
startling
int
heavy
numerical
numeric
plays
ksim
simulates
gnu
compress
compression
decompression
ijpeg
decompresion
perl
manipulates
vortex
tomcatv
mesh
swim
shallow
water
physics
astrophysics
solver
differential
turbulence
cube
solves
temperature
wind
velocity
pollutant
distribution
chemistry
plasma
revised
prevalent
periodically
pent
ium
adjust
remind
perpherals
law
amdahls
speedup
subscript
fourths
infinitely
unaffected
affected
quantifying
multiplying
dominant
underlines
achievement
enhance
enhancement
yield
synthesize
tally
improves
spot
assumtions
simplifying
assumptions
indicator
mflops
fallacies
reflecting
avilable
enhancements
mesures
influenced
fabrication
prof.anshul
operators
achieved
aiming
multiplier
divider
presume
refresh
comfortable
quaintest
dep
circumstances
radix
complication
ranging
infinitive
correspondent
existent
fractions
representing
mathematically
compliment
representations
ambiguity
unique
inst
unbalanced
easies
flipping
inverting
righting
num
ber
closed
billion
familiarity
pencil
school
permissible
accompanied
invert
triple
unsigned
complimenting
flipped
rerepresented
conversion
signed
pixel
lbu
bites
replicates
simples
cascade
zooming
cater
crado
map
electronics
systematically
drawing
cardo
minimal
incases
oaring
connection
deeply
comprehend
rivet
subtractor
note
inverter
inverted
selects
binv
standing
blue
inversion
vectors
anding
oring
anasit
routed
mis
andi
aadd
addu
reduction
exceeded
coarse
subtractu
addiu
interpreting
included
commutate
accumulate
lau
defers
resorting
equate
cursive
compa
rison
interval
cond
ition
msb
propagating
met
yields
inclusive
individually
conjuncting
indication
excluding
explore
tapped
insure
instructive
mux
exceeding
ranges
wrapper
red
verified
progressing
diagonally
invalid
angle
flips
diagonal
normalness
polarity
propagately
color
corners
corner
reversive
diseaser
mult
slti
halting
printing
cores
discarding
multu
lhu
circle
misnomer
sltiu
meanings
covert
manipulate
extracting
restriction
shifting
loose
rising
interpreted
vacated
replicated
vacating
dividing
quotient
remainder
prevented
sll
wastages
sllv
srl
srlv
wired
wiring
arbitrary
shifter
probate
stopped
transcriptor
g.sathis
defer
interms
vertex
multipli
cation
multiplicand
products
successively
summit
illustrating
anded
propagate
iterative
accumulated
intention
accumulates
accumulation
accumulating
incrementky
successive
compensate
supplies
edge
conjunction
instruct
closure
mange
ial
obtains
consequent
conceptual
pure
vacant
individuate
accommodated
shuttle
truckling
leads
combining
initializes
expects
ignores
magnitudes
identically
detections
oblivious
handles
signs
analyses
retained
subtracted
subseq
uent
involving
summed
facilitate
dummy
unpaired
enumerate
insteadly
booths
devised
comprising
booth
produced
square
pos
itive
utilized
oaky
ment
ion
accommodating
gprs
gpr
translates
wrap
sorter
multipliers
algorithms
manually
refinements
dropping
insignificant
justified
regarded
mapping
dividend
divisor
powers
relation
displays
wholes
invariant
maintains
intuitively
inductively
ship
meet
intuition
learning
inductive
induction
holes
invariants
noticing
trivially
ensures
regressively
operationally
placing
compressed
captures
graduality
stationary
stuffing
restorations
restoration
wording
pending
fore
halved
collies
postponing
adjustment
anticipatory
corrected
resome
corrections
locally
putted
converted
suggest
convinced
closer
observe
governing
gat
proof
handwork
improvisation
remembered
conches
fits
chapter
focused
govern
bottle
neck
cascaded
dependents
realization
waveforms
attribute
driving
loader
capacitance
charged
charging
peek
comparable
fitting
feeds
pico
proportionally
slowly
idealize
approximate
idealizing
effected
strongly
deepest
parenthesis
ands
inverters
compliments
reorganize
rippling
ripple
primary
brocket
theoretically
impractical
thet
unworkable
verify
absorbed
preprocessing
playing
determination
digest
preprocess
propagates
substitution
growing
feasible
incoming
extern
sums
brevity
collapsed
suppressing
retails
separating
purple
considerable
wider
letting
capital
propagation
substituted
linearly
explaining
abbreviated
iteratively
redo
tree
clause
neighbor
cell
leftward
symmetrical
interchangeable
cells
rearranged
pij
sigma
excitable
easiest
finished
doubtful
proposal
propositional
incase
ieee
underflow
rational
distances
astronomy
pluto
mars
electron
grams
deperent
pairs
soum
ability
associate
precision
irrational
infinite
collecting
repetition
colors
truncated
exponent
faction
mantissa
emerged
acceptable
institution
electrical
engineers
publishing
standards
invisible
accept
normalized
adjusted
sim
exponents
bias
excludes
wehave
mantissas
significance
exceed
hen
normalization
lock
significants
alignment
rounding
throwing
round
consecutively
ration
aligning
guard
sticky
externally
distinguishes
dead
nearest
financial
gains
party
denormalized
force
undefined
negate
lwc
swc
hood
mead
conversions
lossy
notations
mac
manageable
constraints
comp
arity
equ
incremental
diverse
intend
story
quantents
connections
resist
quantent
hole
extract
instantly
encapsulates
react
nand
decoder
identifies
counters
clocked
unclocked
bet
ween
falling
coupled
latch
feedback
stable
convince
flop
latches
triggered
trigger
observed
fur
ther
instability
presents
tolerate
registered
unpredictable
manipulation
alus
noting
debate
contexts
responds
external
miscellaneous
restrictions
extending
ant
directs
seeks
beg
transforms
yesterday
rad
forming
port
gateways
aimed
mech
anism
bidirectional
conversing
arranged
arrangements
touch
sends
didn
sending
rearranging
supplying
plain
identifying
rdsd
distinguishing
monolithic
hardest
passes
failed
gross
dint
exponentially
guides
directories
limitation
belong
expended
degradability
continued
enhancing
union
curser
sight
sheets
corrective
erasing
superimposed
conflicts
resolved
suffice
conflicting
secured
simplified
jmp
breeze
reversed
opi
exploit
brn
amd
collide
sin
enumerated
zeroth
mechanical
ypu
correspondents
abc
def
complimentary
literal
derivable
concisely
crossing
dots
distributed
prominent
mani
wirings
interconnecting
additionally
sceneries
meaningless
neglect
cushion
quiet
vastly
proportion
accompanying
dominates
slowest
pulling
soso
pole
resolve
tabulated
ended
observations
overcome
reobserving
consensually
disparity
glow
fledge
denoted
dictate
dropped
invariably
dominate
defying
vast
broody
imbalance
productive
beneficial
quantization
flew
duration
reuse
clubbed
mul
tiple
route
rerouted
dissolved
collapse
interconnection
hanging
belated
retaining
precious
resting
sit
fee
din
neater
attends
losses
overshadow
crores
imbalanced
incurred
glue
shobana
attempting
great
nt
hie
locality
reused
miss
items
fdd
media
arid
backup
hdd
prize
usi
inch
presence
optical
dvd
surface
magnetized
opaque
whi
symmetrically
sequentiality
tracks
powered
fdds
sram
stably
sensing
charge
capacitor
discharge
typi
offer
vise
hierarchical
zone
farthest
closest
organizing
enjoy
optimistic
traverse
references
localized
temporal
spatial
neighboring
simplifications
interfaces
arrayed
configuring
ratios
percentages
capacities
unsuccessfully
misses
terminates
incur
decrease
expressible
hitting
sor
expresses
theses
characterized
probabilities
accurate
analyzing
overlooked
formulation
hierarchal
pickup
hits
localities
quadrilles
grey
maps
gray
tag
fondingly
ide
restruction
tags
inconsistency
selection
graphs
curves
peculiarly
pronounced
inaudible
fewer
replacing
gainfully
banks
chopped
interleave
interleaved
fanned
narrow
narrower
badly
relay
comparators
fle
underlying
effectives
nanosecond
ball
disc
med
millisecond
milliseconds
reside
modulo
compete
pool
anytime
redrawn
diagrams
gigabytes
laid
reap
neighborhood
absent
quadrants
righ
replication
overheads
visualize
formulated
lookup
punishment
ultimate
subsumed
dependant
interleaving
transactions
interlinked
organizes
gave
randomly
abort
concurrent
altered
stalled
sequentialized
synchronize
taught
unfilled
robin
anticipate
prefetch
prefetching
hopping
wasteful
judgment
lru
strategies
fifo
arbitrarily
heuristics
profound
judicially
dirty
mein
buffers
cleared
checks
wri
attempted
useless
print
bean
forced
terminating
dirtied
toss
unified
specializing
behavior
behaviors
sur
surplus
on-chip
off-chip
spectrum
serves
grossly
statistical
demo
examined
board
demonstration
sits
fighting
scenario
scrolling
loosing
bur
vacancy
compulsory
compel
compulsorily
categorized
pinpoint
attributed
categorize
parametes
directory
exaggerated
nanoseconds
gaining
drops
receiving
requests
solo
inclusion
serving
sponsored
affecting
countered
educational
fig
hierar
th
cough
throat_clearing
aware
magic
unaware
overlays
evicting
automate
typing
processes
protection
an
reposition
relocate
in
relocation
re-locatable
on
datum
sounds
coughing
bu
smack
it
bought
fifty-six
amounts
the
chance
pages
constitute
da
entity
chopping
organizationally
relying
volatile
we
overtime
thirty-two
gigabyte
and
megabytes
opening
so
needful
you
mille
switches
tolerated
ei
tolerable
tremendously
hair
faintly
sixty-four
when
trend
co
suits
realistic
wh
tagging
restrict
workable
shuffle
su
shuffled
sophisticate
housekeeping
residence
suspended
elapse
ruled
sparseness
one
reallocated
accomod
sparsesity
hashing
tabl
chunks
locate
tenth
poses
adjustable
wi
translating
lookaside
sector
distribute
me
multilevel
eased
diff
referral
dedicate
looking
is
structuring
fragmented
spreading
qualified
usel
edition
glance
concatenation
as
pretty
amortize
paged
to
bad
incomplete
hopeful
succeed
failure
sniffing
blank
evicted
concatenate
reinterpreted
shortcut
deliver
clutter
-ong
ea
um-hm
leaves
leaf
non-existent
ye
str
what
merit
aliasing
processed
for
confusion
ho
clearing
genuinely
drawback
copies
virtually
covering
non-changing
mis-normal
inexpensive
helping
unauthorized
inherently
not
which
supervisor
permissions
initializing
that
ba
security
multilayered
exits
played
subsystem
extremities
transformed
zeroes
clicking
contributed
neglected
innovations
twenty-seven
twenty-two
majority
modeling
crunching
or
oriented
ramped
megabyte
uh-huh
environments
reservation
railways
airlines
responding
at
bottleneck
printed
server
cluster
acting
homes
receive
sustain
discrepancy
twentieth
dif
caution
conceive
elaborating
-like
in-between
interconnected
packaged
converts
yo
roles
partner
communicate
operator
sensor
motor
classification
ca
chunk
serial
ago
paint
exposed
reader
punch
strip
typewriter
sheet
eve
outputting
library
li
card
editing
painful
patch
surprising
was
serially
beings
typist
voice
pictorial
nicer
recognition
spoken
speech
concentrating
digitized
samples
sampled
fort
scanner
image
finely
finer
shaper
printers
laser
demanding
pixels
twenty-four
re
settings
persistent
refreshed
twenty-five
modems
fax
modem
telephone
lan
adapters
wireless
lans
bauds
baud
regions
much
migrated
archival
disks
flash
pen
plugged
non-volatile
schematic
platters
platter
coating
magnetically
sensitive
magnetization
heads
arm
pivoted
rotates
rotation
head
center
circumference
rotary
rotate
contact
radically
surfaces
tip
outwards
inwards
rotational
they
thirty-six
fifty-four
seventy-two
fif
revolutions
sea
inferences
encountering
seventy-three
seek
sustained
rustling
figured
thirty-seven
seeking
cylinder
coinciding
of
cylinders
sectors
western
internet
site
samsung
thin
monitors
viewing
scenes
scanners
forty-eight
document
feeder
bunch
papers
photocopy
feeded
inkjet
cartridges
cartridge
breakthrough
ve
piezoelectric
thermal
chamber
plate
piezo
vibrate
vibration
droplet
receives
hitted
expansion
drop
decades
counts
tired
interfaced
trans
transforming
subsystems
protocol
synchronous
asynchronous
synchronized
protocols
establish
alimentation
com
communicating
conversation
conversations
offers
parties
affair
links
plug-in
now
blurred
mixes
proprietary
standardization
poss
hung
traffic
lengthy
ph
manufactured
compatible
interoperability
backplane
every
backpanel
connector
backside
dis
connectors
boards
no
wo
seperate
hook
meeting
adapter
adaptation
are
then
speak
how
streams
lanes
road
merges
highway
managed
twent
microsecond
someway
packet
collect
bust
shade
absorb
acknowledgement
originated
whosoever
acknowledge
lowered
confirmation
arrow
tri-state
impedance
nei
isolates
ground
floats
lowering
raising
monitoring
handshaking
homework
confirmed
recognized
nomenclature
pulse
triggers
texture
will
aloud
requesting
asserts
observes
watching
release
reassert
wave
megahertz
mu
bandwidth
chaining
pertain
acknowledging
twenty-eight
initiation
completion
unutilized
splits
le
inter-leaving
idle
forty-five
seventy-one
fifty-seven
would
bla
arbitration
exploited
fo
interlocked
chained
unoccupied
recollection
band
released
beginnings
requested
master
slave
initiates
masters
slaves
coordinate
transact
discipline
releasing
priorities
priority
urgency
urgent
fairness
es
mechanisms
daisy
centralized
collision
resolving
issued
potential
arbiter
can
grant
blocked
explanation
acquiring
notices
activates
but
persisting
served
disaster
hijack
rule
with
avoided
tran
this
deactivates
grants
carr
st
shuttling
releases
disallowed
reacquire
concentrated
democratic
negotiate
identities
honest
collided
microseconds
starved
starvation
ty
oversimplified
hubs
hub
-ser
north
south
frequencies
thirty-three
audio
derivative
develops
freezing
contradictory
frozen
standardizing
arresting
pressure
revising
refining
specs
formal
professional
adapted
other
impedances
sp
revisions
accelerated
sixty-six
quadruple
volt
signaling
ob
de
fiber
channel
infer
per
quantitatively
progresses
pace
participates
interacts
printf
scanf
formatting
raw
ascii
converting
driver
drivers
family
routine
drudgery
mou
tracking
sensed
gigahertz
volume
packets
megabits
gigabits
going
steadily
displayed
eye
reflected
al
chan
workstations
be
pr
keys
depressed
commands
sect
train
has
op-codes
take
frequent
polling
sampling
intimates
readiness
polled
poll
breathing
settling
divid
divides
undesi
inform
overthrow
handler
score
desi
deposit
setup
tra
interrupted
entrusted
augmentation
outsource
quit
-table
chose
progression
caused
initiating
contiguous
consistency
multiprocessor
coherence
sync
undesirable
crosses
sturdy
estimate
interaction
latenc
pipes
functionally
attain
travels
ul
quantifies
deposited
comes
flexibilities
-fully
forty-three
sustaining
pumping
saturate
sixty-two
rounded
complicate
commonsense
multi-function
faxes
receiver
sender
photocopier
ha
outgoing
satisfying
spare
photocopying
hooks
assembled
hooked
white
compresses
received
cum
computational
inches
adequate
nonvolatile
ninety-nine
transmission
recession
twenty-six
dialed
forty-six
responses
faxed
churn
faxing
-cept
prints
minor
stroll
lack
mem
steady
accumulations
congestions
starving
converging
queuing
stimulate
buffered
simultaneous
halfway
buffering
also
do
scsi
let
contiguously
concluding
remarks
review
spelt
constructed
monetary
-as
projected
instructs
tr
dissipated
centimeters
from
micro-architecture
under
non-restoring
non-restor
differen
look
de-normalize
indeterminate
executions
if
pa
bl
dense
inexpens
adv
ap
purchasing
adapt
sold
desktops
ov
saturating
curve
co-design
laptops
micro-controller
ge
encourage
villages
portable
delicate
cheap
car
bicycle
solar
hilltop
linux
english
bangalore
simputer
team
startup
strong
pad
icons
illiterate
redwood
scientist
biological
phenomenon
tall
joint
trees
moisture
atmosphere
fog
sensors
miniature
laptop
collected
climb
safety
automobiles
transporting
french
kilometer
section
fails
listen
news
traditional
newspaper
web
published
regional
nontraditional
nonlocal
preserving
art
diagnosis
underbelly
vehicle
increasingly
terrorism
dangerous
premise
explode
mirror
illumination
drill
exhaustive
camera
bright
emit
lights
illuminate
pit
rides
illuminated
cabling
stitch
strips
stitching
videos
cars
authorized
sticker
windscreen
se
identification
patience
installed
prom
erasable
communicates
infrared
smart
pocket
plastic
credit
cash
encrypted
ex
in-house
lives
challenging
excitement
