1 introduction to java 1.1 history java is a programming language created by james gosling from sun microsystems  sun  in 1991 the first publicly available version of java  java 1.0  was released in 1995 sun microsystems was acquired by the oracle corporation in 2010 oracle has now the steermanship for java over time new enhanced versions of java have been released the current version of java is java 1.7 which is also known as java 7 from the java programming language the java platform evolved the java platform allows software developers to write program code in other languages than the java programming language which still runs on the java virtual machine the java platform is usually associated with the java virtual machine and the java core libraries 1.2 java and open source software in 2006 sun started to make java available under the gnu general public license  gpl   oracle continues this project called openjdk 1.3 java virtual machine the java virtual machine  jvm  is a software implementation of a computer that executes programs like a real machine the java virtual machine is written specifically for a specific operating system  e.g  for linux a special implementation is required as well as for windows java programs are compiled by the java compiler into bytecode the java virtual machine interprets this bytecode and executes the java program 1.4 java runtime environment vs java development kit a java distribution typically comes in two flavors  the java runtime environment  jre  and the java development kit  jdk   the java runtime environment  jre  consists of the jvm and the java class libraries those contain the necessary functionality to start java programs the jdk additionally contains the development tools necessary to create java programs the jdk therefore consists of a java compiler  the java virtual machine and the java class libraries 1.5 characteristics of java the target of java is to write a program once and then run this program on multiple operating systems java has the following properties  platform independent  java programs use the java virtual machine as abstraction and do not access the operating system directly this makes java programs highly portable a java program  which is standard-compliant and follows certain rules  can run unmodified on all supported platforms  e.g  windows or linux object-orientated programming language  except the primitive data types  all elements in java are objects strongly-typed programming language  java is strongly-typed  e.g  the types of the used variables must be pre-defined and conversion to other objects is relatively strict  e.g  must be done in most cases by the programmer interpreted and compiled language  java source code is transferred into the bytecode format which does not depend on the target platform these bytecode instructions will be interpreted by the java virtual machine  jvm   the jvm contains a so called hotspot-compiler which translates performance critical bytecode instructions into native code instructions automatic memory management  java manages the memory allocation and de-allocation for creating new objects the program does not have direct access to the memory the so-called garbage collector automatically deletes objects to which no active pointer exists the java syntax is similar to c + +  java is case-sensitive  e.g  variables called myvalue and myvalue are treated as different variables 1.6 development process with java java source files are written as plain text documents the programmer typically writes java source code in an integrated development environment  ide  for programming an ide supports the programmer in the task of writing code  e.g  it provides auto-formating of the source code  highlighting of the important keywords  etc at some point the programmer  or the ide  calls the java compiler  javac   the java compiler creates the bytecode instructions these instructions are stored in .class files and can be executed by the java virtual machine 1.7 garbage collector the jvm automatically re-collects the memory which is not referred to by other objects the java garbage collector checks all object references and finds the objects which can be automatically released while the garbage collector relieves the programmer from the need to explicitly manage memory  the programmer still need to ensure that he does not keep unneeded object references  otherwise the garbage collector can not release the associated memory keeping unneeded object references are typically called memory leaks 1.8 classpath the classpath defines where the java compiler and java runtime look for .class files to load these instructions can be used in the java program for example  if you want to use an external java library you have to add this library to your classpath to use it in your program 2 installation of java 2.1 check installation to run java programs on your computer you must at least have the java runtime environment  jre  installed this might already be the case on your machine you can test is the jre is installed and in your current path by opening a console  if you are using windows  win + r  enter cmd and press enter  and by typing in the following command  java -version if the jre is installed and within your path  this commands print information about your java installation in this case you can skip the java installation description you may want to note down if you have a 32 bit or 64 bit version of java  see section 2.6  “ how can you tell you are using a 32 bit or 64 bit version of java ”  if the command line returns the information that the program could not be found  you have to install java 2.2 install java on ubuntu on ubuntu you can install java 7 via the following command on the command line sudo apt-get install openjdk-7-jdk 2.3 install java on ms windows for microsofts windows  oracle provides a native installer which can be found on the oracle website the central website for installing java is located under the following url and also contains instructions how to install java for other platforms java.com 2.4 installation problems and other operating systems if you have problems installing java on your system  search via google for how to install jdk on your_os  this should result in helpful links replace your_os with your operating system  e.g  windows  ubuntu  mac os x  etc 2.5 validate installation switch again to the command line and run the following command java -version the output should be similar to the following output java version " 1.7.0_25 " openjdk runtime environment  icedtea 2.3.10   7u25-2.3.10-1ubuntu0.13.04.2  openjdk 64-bit server vm  build 23.7-b01  mixed mode  2.6 how can you tell you are using a 32 bit or 64 bit version of java you can run a 32 bit or a 64 bit version of java on a 64 bit system if you use java -version and the output contains the " 64-bit " string you are using the 64 bit version of java otherwise your are using the 32 bit version the following is the output of a 64-bit version java version " 1.7.0_25 " openjdk runtime environment  icedtea 2.3.10   7u25-2.3.10-1ubuntu0.13.04.2  openjdk 64-bit server vm  build 23.7-b01  mixed mode  3 exercise  write  compile and run a java program 3.1 write source code the following java program is developed under linux using a text editor and the command line the process on other operating system should be similar  but is not covered in this description select or create a new directory which will be used for your java development in this description the path \ home \ vogella \ javastarter is used on microsoft windows you might want to use c  \ temp \ javastarter this path is called javadir in the following description open a text editor which supports plain text  e.g  gedit under linux or notepad under windows and write the following source code // a small java program public class helloworld  public static void main  string   args   system.out.println  " hello world "  ;   warning do not use a rich editor like microsoft word or libreoffice for writing java code if in doubt  google for " plain text editor for  your_os  "  writing java programs in a text editor save the source code in your javadir directory with the helloworld.java filename the name of a java source file must always equal the class name  within the source code  and end with the .java extension in this example the filename must be helloworld.java  because the class is called helloworld 3.2 compile and run your java program open a shell for command line access tip if you do n't know how to do this  google for " how to open a shell under  your_os  "  switch to the javadir directory with the command cd javadir  for example  in the above example via the cd \ home \ vogella \ javastarter command use the ls command  dir under microsoft windows  to verify that the source file is in the directory compile your java source file into a class file with the following command javac helloworld.java afterwards list again the content of the directory with the ls or dir command the directory contains now a file helloworld.class if you see this file  you have successfully compiled your first java source code into bytecode tip by default  the compiler puts each class file in the same directory as its source file you can specify a separate destination directory with the -d compiler flag you can now start your compiled java program ensure that you are still in the jardir directory and enter the following command to start your java program java helloworld the system should write " hello world " on the command line compiling and running java programs on the command line 3.3 using the classpath you can use the classpath to run the program from another place in your directory switch to the command line  e.g  under windows start run cmd switch to any directory you want type  java helloworld if you are not in the directory in which the compiled class is stored  then the system will show an error message  exception in thread " main " java.lang.noclassdeffounderror  test/testclass to use the class  type the following command replace " mydirectory " with the directory which contains the test directory you should again see the " helloworld " output java -classpath " mydirectory " helloworld 4 java language structure 4.1 basics  package  class and object it is important to understand the base terminology of java in terms of packages  classes and objects this section gives an overview of these terms 4.2 package java groups classes into functional packages packages are typically used to group classes into logical units for example  all graphical views of an application might be placed in the same package called com.vogella.webapplication.views it is common practice to use the reverse domain name of the company as top level package for example  the company might own the domain  vogella.com and in this example the java packages of this company starts with com.vogella other main reason for the usage of packages is to avoid name collisions of classes a name collision occurs if two programmers give the same fully qualified name to a class the fully qualified name of a class in java consists of the package name followed by a dot    and the class name without packages  a programmer may create a java class called test another programmer may create a class with the same name with the usage of packages you can tell the system which class to call for example  if the first programmer puts the test class into package report and the second programmer puts his class into package xmlreader you can distinguish between these classes by using the fully qualified name  e.g  xmlreader.test or report.test 4.3 class def  template that describes the data and behavior associated with an instance of that class note the class can be seen as the blueprint of an object it describes how an object is created in java source code a class is defined by the class keyword and must start with a capital letter the body of a class is surrounded by    package test ; class myclass   the data associated with a class is stored in variables ; the behavior associated to a class or object is implemented with methods a class is contained in a java source file with the same name as the class plus the .java extension 4.4 object def  an object is an instance of a class the object is the real element which has data and can perform actions each object is created based on the class definition 4.5 inheritance a class can be derived from another class in this case this class is called a subclass another common phrase is that a class extends another class the class from which the subclass is derived is called a superclass inheritance allows a class to inherit the behavior and data definitions of another class the following codes demonstrates how a class can extend another class in java a class can only extend a maximum of one class package com.vogella.javaintro.base ; class mybaseclass  @ override public void hello    system.out.println  " hello from mybaseclass "  ;   package com.vogella.javaintro.base ; class myextensionclass extends mybaseclass   4.6 object as superclass every object in java implicitly extends the object class the class defines the following methods for every java object  equals  o1  allows checking if the current object is equal to o1 getclass   returns the class of the object hashcode   returns an identifier of the current object tostring   gives a string representation of the current object 5 java interfaces 5.1 what is an interface in java an interfaces is a type similar to a class and is defined via the interface keyword like a class an interface defines methods classes can implement the interfaces and by this they must obey the contract defined in the interface  e.g  the clast provide implementation for all abstract methods defined in the interface 5.2 abstract  default and static methods in interfaces an interface can have abstract methods and default methods a default method is defined via the default keyword at the beginning of the method signature all other methods defined in an interfaces are public and abstract – explicit declaration of these modifiers is optional interfaces can have constants which are always implicitly public  static and final the following code shows an example implementation of an interface package testing ; public interface myinterface  // constant definition string url = " http  //www.vogella.com " ; // public abstract methods void test   ; void write  string s  ; // default method default string reservestring  string s   return new stringbuilder  s  .reverse   .tostring   ;   the following class implements this interface  its must implement the abstract method and can use the default methods 5.3 implementing interfaces a class can implement an interface in this case it must provide concrete implementations of the abstract interface methods if you implement a method defined by an interface  you can use @ override annotation to indicate to the java compiler that you actually want to implement a method defined by this interface this way the compiler can give you an error in you mis-typed the name of the method or in the number of arguments package com.vogella.javaintro.base ; public class myclassimpl implements myinterface  @ override public void test     @ override public void write  string s    public static void main  string   args   myclassimpl impl = new myclassimpl   ; system.out.println  impl.reservestring  " lars vogel "   ;   5.4 evolving interfaces before java 8 evolving interfaces  e.g  adding new methods to an interface  was not possible because such a change would break existing implementations java 8 introduced default methods  now you can extend an interface without breaking clients by simply suppling a default implementation with it adding such a default method is a source an binary compatible change a class can always override a default method so supply a better behavior 5.5 multiple inheritance of methods if a class implements two interfaces and if these interfaces provide the same default method  java resolves the correct method for the class by the following rules  superclass wins always against the superinterface  if a class can inherit a method from a superclass and a superinterface  the class inherts the superclass method this is true for concrete and abstract superclass methods this rule implies that default methods are not used if this method is also declared in the superclass chain subtypes win over supertypes  if a class can inherit a method from two interfaces  and one is a subtype of the other  the class inherts the method from the subtype in all other cases the class needs to implement the default method the following listing demonstrates listing number 3 public interface a  default void m      public interface b  default void m      public class c implements a  b  @ override public void m      in your implementation you can also call the super method you prefer public class c implements a  b  @ override public void m    a.super.m   ;   5.6 functional interfaces all interfaces that have only one method are called functional interfaces functional interfaces have the advantage that they can be used together with lambda expressions see section 20.1  “ what are lambdas ” to learn more about lambdas  e.g  the type of lambdas is a functional interface the java compiler automatically identifies functional interfaces the only requirement is that they have only one abstract method however  is possible to capture the design intent with a @ functionalinterface annotation several default java interfaces are functional interfaces  java.lang.runnable java.util.concurrent.callable java.io.filefilter java.util.comparator java.beans.propertychangelistener java also contains the java.util.function package which contains functional interfaces which are frequently used such as  predicate < t >  a boolean-valued property of an object consumer < t >  an action to be performed on an object function < t  r >  a function transforming a t to a r supplier < t >  provides an instance of t  such as a factory  unaryoperator < t >  a function from t to t binaryoperator < t >  a function from  t  t  to t 6 java basic terms 6.1 override methods and the @ override annotation if a class extends another class  it inherits the methods from its superclass if it wants to change these methods  it can override these methods to override a method  you use the same method signature in the source code of the subclass to indicate to the reader of the source code and the java compiler that you have the intention to override a method  you can use the @ override annotation the following code demonstrates how you can override a method from a superclass package com.vogella.javaintro.base ; class mybaseclass  @ override public void hello    system.out.println  " hello from mybaseclass "  ;   package com.vogella.javaintro.base ; class myextensionclass2 extends mybaseclass  public void hello    system.out.println  " hello from myextensionclass2 "  ;   tip it is good practice to always use the @ override annotation this way the java compiler validates if you did override all methods as intended and prevents errors 7 the type system of java 7.1 primitives and references java distinguishes between primitive types  such as boolean  short  int  double  float  char and byte  and reference types  such as object and string   7.2 primitives primitive types variables represents the number  true/false or character you can not call methods on variables which have a primitive types operators such as *    + or / are only supported for primitive types only + can also used for the reference type string to concatenate strings 7.3 reference types reference types variables represents a reference to an object  e.g  a variable is a pointer to the real object if you change the value of a reference type variable  the variable points to a different object or to null which represents the non-existing object reference changing the value of a reference type variable does not change the attributes of the object is was pointing to also changing the contents of an object does not affect the value of a variable referring to that object 7.4 autoboxing and wrapper types every primitive type has in java a fitting reference type this reference type allows to store the value of the primitive type in an object for example you have java.lang.integer for int converting a primitive value into an instance of a wrapper type and vice versa is called boxing / unboxing java performs these operations automatically of necessary this allows you to use a primitive as parameter in a method which expects an object of the wrapper type this automatic boxing and unboxing is known as autoboxing 8 variables and methods 8.1 variable variables allow the java program to store values during the runtime of the program a variable can either be a primitive variable or a reference variable a primitive variable contains the value while the reference variable contains a reference  pointer  to the object hence  if you compare two reference variables  you compare if both point to the same object to compare objects  use the object1.equals  object2  method call 8.2 instance variable instance variable is associated with an instance of the class  also called object   access works over these objects instance variables can have any access control and can be marked final or transient instance variables marked as final can not be changed after a value has been assigned to them 8.3 local variable local  stack  variable declarations can not have access modifiers final is the only modifier available to local variables this modifier defines that the variable can not be changed after the first assignment local variables do not get default values  so they must be initialized before use 8.4 methods a method is a block of code with parameters and a return value it can be called on the object package com.vogella.javaintro.base ; public class mymethodexample  void tester  string s   system.out.println  " hello world "  ;   methods can be declared with var-args in this case the method declares a parameter which accepts everything from zero to many arguments  syntax  type  name ;  a method can only have one var-args parameter and this must be the last parameter in the method overwrite of a superclass method  a method must be of the exact same return parameter and the same arguments also the return parameter must be the same overload methods  an overloaded method is a method with the same name  but different arguments the return type can not be used to overload a method 8.5 main method a public static method with the following signature can be used to start a java application such a method is typically called main method public static void main  string   args    8.6 constructor a class contains constructors that are invoked to create objects based on the class definition constructor declarations look like method declarations except that they use the name of the class and have no return type a class can have several constructors with different parameters each class must define at least one constructor in the following example the constructor of the class expects a parameter package com.vogella.javaintro.base ; public class myconstructorexample2  string s ; public myconstructorexample2  string s   this.s = s ;   if no explicit constructor is defined  the compiler implicitly adds a constructor if the class is sub-classed  then the constructor of the super class is always called implicitly in this case in the following example the definition of the constructor without parameters  also known as the empty constructor  is unnecessary if not specified  the compiler would create one package com.vogella.javaintro.base ; public class myconstructorexample  // unnecessary  would be created by the compiler if left out public myconstructorexample      the naming convention for creating a constructor is the following  classname  parameter p1       every object is created based on a constructor this constructor method is the first statement called before anything else can be done with the object 9 modifiers 9.1 access modifiers there are three access modifiers keywords available in java  public  protected and private there are four access levels  public  protected  default and private they define how the corresponding element is visible to other components if something is declared public  e.g  classes or methods can be freely created or called by other java objects if something is declared private  e.g  a method  it can only be accessed within the class in which it is declared the access levels protected and default are similar a protected class can be accessed from the package and sub-classes outside the package  while a default class can get accessed only via the same package the following table describes the visibility  table 1 access level modifier class package subclass world public y y y y protected y y y n no modifier y y n n private y n n n 9.2 other modifiers final methods  can not be overwritten in a subclass abstract method  no method body synchronized method  thread safe  can be final and have any access control native methods  platform dependent code  apply only to methods strictfp  class or method 10 import statements 10.1 usage of import statements in java you have to access a class always via its full-qualified name  i.e  the package name and the class name you can add import statements for classes or packages into your class file  which allow you to use the related classes in your code without the package qualifier 10.2 static imports static import is a feature that allows members  fields and methods  which are defined in a class with the public static access modifier to be used in java code without specifying the class in which the member is defined the feature provides a typesafe mechanism to include constants into code without having to reference the class that originally defined the field 11 more java language constructs 11.1 class methods and class variables class methods and class variables are associated with the class and not an instance of the class  i.e  objects to refer to these elements  you can use the classname and a dot  "  "  followed by the class method or class variable name class methods and class variables are declared with the static keyword class methods are also called static methods and class variables are also called static variables or static fields an example for the usage of a static field is println of the following statement  system.out.println  " hello world "   hereby out is a static field  an object of type printstream and you call the println   method on this object if you define a static variable  the java runtime environment associates one class variable for a class no matter how many instances  objects  exist the static variable can therefore be seen as a global variable the following code demonstrates the usage of static fields package com.vogella.javaintro.base ; public class mystaticexample  static string placeholder = " test " ; static void test    system.out.println  " hello "  ;   package com.vogella.javaintro.base ; public class tester  public static void main  string   args   system.out.println  mystaticexample.placeholder  ; mystaticexample.test   ;   if a variable should be defined as constant  you declare it with the static and the final keyword the static method runs without any instance of the class  it can not directly access non-static variables or methods 11.2 abstract class and methods a class and method can be declared as abstract an abstract class can not be directly instantiated if a class has at least one method  which only contains the declaration of the method  but not the implementation  then this class is abstract and can not be instantiated sub-classes need then to define the methods except if they are also declared as abstract if a class contains an abstract method  it also needs to get defined with the keyword abstract the following example shows an abstract class package com.vogella.javaintro.base ; public abstract class myabstractclass  abstract double returndouble   ;  12 cheat sheets the following can be used as a reference for certain task which you have to do 12.1 working with classes while programming java you have to create several classes  methods  instance variables the following uses the package test table 2 what to do how to do it create a new class called mynewclass package test ; public class mynewclass   create a new attribute  instance variable  called var1 of type string in the mynewclass class package test ; public class mynewclass  private string var1 ;  create a constructor for your mynewclass class which has a string parameter and assigns the value of it to the var1 instance variable package test ; public class mynewclass  private string var1 ; public mynewclass  string para1   var1 = para1 ; // or this.var1 = para1 ;   create a new method called dosomething in your class which does not return a value and has no parameters package test ; public class mynewclass  private string var1 ; public mynewclass  string para1   var1 = para1 ; // or this.var1 = para1 ;  public void dosomething      create a new method called dosomething2 in your class which does not return a value and has two parameters  an int and a person package test ; public class mynewclass  private string var1 ; public mynewclass  string para1   var1 = para1 ; // or this.var1 = para1 ;  public void dosomething     public void dosomething2  int a  person person     create a new method called dosomething2 in your class which returns an int value and has three parameters  two strings and a person package test ; public class mynewclass  private string var1 ; public mynewclass  string para1   var1 = para1 ; // or this.var1 = para1 ;  public void dosomething     public void dosomething2  int a  person person    public int dosomething3  string a  string b  person person   return 5 ; // any value will do for this example   create a class called myotherclass with two instance variables one will store a string  the other will store a dog create getter and setter for these variables package test ; public class myotherclass  string myvalue ; dog dog ; public string getmyvalue    return myvalue ;  public void setmyvalue  string myvalue   this.myvalue = myvalue ;  public dog getdog    return dog ;  public void setdog  dog dog   this.dog = dog ;   12.2 working with local variable a local variable must always be declared in a method table 3 what to do how to do it declare a  local  variable of type string string variable1 ; declare a  local  variable of type string and assign " test " to it string variable2 = " test " ; declare a  local  variable of type person person person ; declare a  local  variable of type person  create a new object and assign the variable to this object person person = new person   ; declare an array of type string string array   ; declare an array of type person and create an array for this variable which can hold 5 persons person array   = new person  5  ; assign 5 to the int variable var1  which was already declared  ; var1 = 5 ; assign the existing variable pers2 to the exiting variable pers1 ; pers1 = pers2 ; declare an arraylist variable which can hold objects of type person arraylist < person > persons ; create a new arraylist with objects of type person and assign it to the existing variable persons persons = new arraylist < person >   ; declare an arraylist variable which can hold objects of type person and create a new object for it arraylist < person > persons = new arraylist < person >   ; 13 integrated development environment the previous chapter explained how to create and compile a java program on the command line a java integrated development environment  ide  provides lots of ease of use functionality for creating java programs there are other very powerful ides available  for example  the eclipse ide for an introduction on how to use the eclipse ide please see eclipse ide tutorial the remaining description uses the phrase  " create a java project called "  this refers to creating a java project in eclipse if you are using a different ide  please follow the required steps in that ide 14 exercises  creating java objects and methods 14.1 create a person class and instantiate it create a new java project called com.vogella.javastarter.exercises1 and a package with the same name create a class called person add three instance variables to it  one for storing the first name of the person  one for storing the last name and one for storing the age of the person use the constructor of the person object to set the values to some default value add a tostring method as described by the following codeing and solve the todo this method is used to convert the object to a string representation @ override public string tostring    // todo replace " " with the following  // firstname + " " + lastname return " " ;  create a new class called main with a public static void main  string   args   in this method create an instance of the person class 14.2 use constructor add a constructor to your person class which takes first name  last name and age as parameter assign the values to your instance variables in your main method create at least one object of type person and use system.out.println   with the object as parameter 14.3 define getter and setter methods define methods which allow you to read the values of the instance variables and to set them these methods are called setter and getter getters should start with get followed by the variable name whereby the first letter of the variable is capitalized setter should start with set followed by the variable name whereby the first letter of the variable is capitalized for example  the variable called firstname would have the getfirstname   getter method and the setfirstname  string s  setter method change your main method so that you create one person object and use the setter method to change the last name 14.4 create an address object create a new object called address the address should allow you to store the address of a person add a new instance variable of this type in the person object also  create a getter and setter for the address object in the person object 15 solution  creating java objects and methods 15.1 create a person class and instantiate it the following is the expected result after section 14.1  “ create a person class and instantiate it ”  package exercises.exercise04 ; class person  string firstname = " jim " ; string lastname = " knopf " ; int age = 12 ; @ override public string tostring    return firstname + " " + lastname ;   package exercises.exercise04 ; public class main  public static void main  string   args   person person = new person   ; // this calls the tostring method on the pers object system.out.println  pers  ;   15.2 use constructor the following is the expected result after section 14.2  “ use constructor ”  package com.vogella.javastarter.exercises1 ; class person  string firstname ; string lastname ; int age ; public person  string a  string b  int value   firstname = a ; lastname = b ; age = value ;  @ override public string tostring    return firstname + " " + lastname ;   package com.vogella.javastarter.exercises1 ; public class main  public static void main  string   args   person p1 = new person  " jim "  " knopf "  12  ; system.out.println  p1  ; // reuse the same variable and assign a new object to it person p2 = new person  " henry "  " ford "  104  ; system.out.println  p2  ;   15.3 define getter and setter methods the following is the expected result after section 14.3  “ define getter and setter methods ”  package com.vogella.javastarter.exercises1 ; class person  string firstname ; string lastname ; int age ; public person  string a  string b  int value   firstname = a ; lastname = b ; age = value ;  public string getfirstname    return firstname ;  public void setfirstname  string firstname   this.firstname = firstname ;  public string getlastname    return lastname ;  public void setlastname  string lastname   this.lastname = lastname ;  public int getage    return age ;  public void setage  int age   this.age = age ;  @ override public string tostring    return firstname + " " + lastname ;   package com.vogella.javastarter.exercises1 ; public class main  public static void main  string   args   person person = new person  " jim "  " knopf "  21  ; person p2 = new person  " jill "  " sanders "  20  ; // jill gets married to jim // and takes his name p2.setlastname  " knopf "  ; system.out.println  p2  ;   15.4 solution  create an address object the following is the expected result after section 14.4  “ create an address object ”  package com.vogella.javastarter.exercises1 ; public class address  private string street ; private string number ; private string postalcode ; private string city ; private string country ; public string getstreet    return street ;  public void setstreet  string street   this.street = street ;  public string getnumber    return number ;  public void setnumber  string number   this.number = number ;  public string getpostalcode    return postalcode ;  public void setpostalcode  string postalcode   this.postalcode = postalcode ;  public string getcity    return city ;  public void setcity  string city   this.city = city ;  public string getcountry    return country ;  public void setcountry  string country   this.country = country ;  public string tostring    return street + " " + number + " " + postalcode + " " + city + " " + country ;   package com.vogella.javastarter.exercises1 ; class person  string firstname ; string lastname ; int age ; private address address ; public person  string a  string b  int value   firstname = a ; lastname = b ; age = value ;  public string getfirstname    return firstname ;  public void setfirstname  string firstname   this.firstname = firstname ;  public string getlastname    return lastname ;  public void setlastname  string lastname   this.lastname = lastname ;  public int getage    return age ;  public void setage  int age   this.age = age ;  public address getaddress    return address ;  public void setaddress  address address   this.address = address ;  @ override public string tostring    return firstname + " " + lastname ;   package com.vogella.javastarter.exercises1 ; public class main  public static void main  string   args   // i create a person person pers = new person  " jim "  " knopf "  31  ; // set the age of the person to 32 pers.setage  32  ; // just for testing i write this to the console system.out.println  pers  ; / * * actually system.out.println always calls tostring  if you do not * specify it so you could also have written system.out.println  pers  ; * / // create an address address address = new address   ; // set the values for the address address.setcity  " heidelberg "  ; address.setcountry  " germany "  ; address.setnumber  " 104 "  ; address.setpostalcode  " 69214 "  ; address.setstreet  " musterstr "  ; // assign the address to the person pers.setaddress  address  ; // dispose reference to address object address = null ; // person is moving to the next house in the same street pers.getaddress   .setnumber  " 105 "  ;   16 java statements the java language defines certain statements with a predefined meaning the following description lists some of them 16.1 if-then and if-then-else the if-then statement is a control flow statement a block of code is only executed when the test specified by the if part evaluates to true the optional else block is executed when the if part evaluates to false the following example code shows a class with two methods the first method demonstrates the usage of if-then and the second method demonstrates the usage of if-then-else 16.2 switch the switch statement can be used to handle several alternatives if they are based on the same constant value switch  expression   case constant1  command ; break ; // will prevent that the other cases or also executed case constant2  command ; break ;  default   // example  switch  cat.getlevel     case 0  return true ; case 1  if  cat.getlevel   = = 1   if  cat.getname   .equalsignorecase  req.getcategory      return true ;   case 2  if  cat.getname   .equalsignorecase  req.getsubcategory      return true ;   16.3 boolean operations use = = to compare two primitives or to see if two references refer to the same object use the equals   method to see if two different objects are equal && and | | are both short circuit methods which means that they terminate once the result of an evaluation is already clear example  true | |   is always true while  false &&   always is always interpreted as false usage   var ! = null && var.method1     ensures that var is not null before doing the real check table 4 boolean operations description = = is equal  in case of objects the system checks if the reference variable point to the same object it will not compare the content of the objects ! && and ! = is not equal  similar to = =  a.equals  b  checks if string a equals b a.equalsignorecase  b  checks if string a equals b while ignoring lower cases if  value false  true    negotiation  return true if value is not true 17 loops in java 17.1 the for loop a for loop is a repetition control structure that allows you to write a block of code which is executed a specific number of times the syntax is the following for  initialization ; expression ; update_statement   //block of code to run  the following shows an example for a for loop public class fortest  public static void main  string args     for  int i = 1 ; i < 10 ; i = i + 1   system.out.println  " value of i  " + i  ;    tip for arrays and collections there is also an enhanced for loop available this loop is covered in the array description 17.2 the while loop a while loop is a repetition control structure that allows you to write a block of code which is executed until a specific condition evaluates to false the syntax is the following while  expression   // block of code to run  the following shows an example for a while loop public class whiletest  public static void main  string args     int x = 1 ; while  x < 10   system.out.println  " value of x  " + x  ; x + + ;    17.3 the do while loop the do-while loop is similar to the while loop  with the exception that the condition is checked after the execution the syntax is the following do  // block of code to run  while  expression  ; the following shows an example for a do-while loop public class dotest  public static void main  string args     int x = 1 ; do  system.out.println  " value of x  " + x  ; x + + ;  while  x < 10  ;   18 arrays 18.1 arrays in java an array is a container object that holds a fixed number of values of a single type an item in an array is called an element every element can be accessed via an index the first element in an array is addressed via the 0 index  the second via 1  etc package com.vogella.javaintro.array ; public class testmain  public static void main  string   args   // declares an array of integers int   array ; // allocates memory for 10 integers array = new int  10  ; // initialize values array  0  = 10 ; // initialize second element array  1  = 20 ; array  2  = 30 ; array  3  = 40 ; array  4  = 50 ; array  5  = 60 ; array  6  = 70 ; array  7  = 80 ; array  8  = 90 ; array  9  = 100 ;   18.2 enhanced for loop for arrays and collections arrays and collections can be processed with a simpler for loop for  declaration  expression   // body of code to be executed  the following code demonstrates its usage package com.vogella.javaintro.array ; public class testmain  public static void main  string   args   // declares an array of integers int   array ; // allocates memory for 10 integers array = new int  10  ; // initialize values array  0  = 10 ; // initialize second element array  1  = 20 ; array  2  = 30 ; array  3  = 40 ; array  4  = 50 ; array  5  = 60 ; array  6  = 70 ; array  7  = 80 ; array  8  = 90 ; array  9  = 100 ; for  int i  array   system.out.println  " element at index " + i + "  " + array  i   ;    19 strings 19.1 strings in java the string class represents character strings all string literals  for example  " hello "  are implemented as instances of this class an instance of this class is an object strings are immutable  e.g  an assignment of a new value to a string object creates a new object 19.2 string pool in java for memory efficiency java uses a string pool the string pool allows string literals to be reused this is possible because strings in java are immutable if the same string literal is used in several places in the java code  only one copy of that string is created whenever a string object is created and gets a string literal assigned  e.g  as in string s = " constant "  the string pool is used however  the new operator forces a new string copy to be allocated  for example  in string s = new string  " constant "  ;  19.3 compare strings in java to compare the string objects s1 and s2  use the s1.equals  s2  method a string comparison with = = is incorrect  as = = checks for object reference equality = = sometimes gives the correct result  as java uses a string pool the following example would work with = =  this would work as expected string a = " hello " ; string b = " hello " ; if  a = = b   // if statement is true // because string pool is used and // a and b point to the same constant  this comparison would fail string a = " hello " ; string b = new string  " hello "  ; if  a = = b    else  // if statement is false // because string pool is used and // a and b point to the same constant  warning therefore  you should always use the equals   method when you compare strings 19.4 working with strings the following lists the most common string operations table 5 command description " testing " .equals  text1  ; return true if text1 is equal to " testing "  the check is case-sensitive " testing " .equalsignorecase  text1  ; return true if text1 is equal to " testing "  the check is not case-sensitive for example  it would also be true for " testing "  stringbuffer str1 = new stringbuffer   ; define a new string with a variable length str.charat  1  ; return the character at position 1  note  strings are arrays of chars starting with 0  str.substring  1  ; removes the first characters str.substring  1  5  ; gets the substring from the second to the fifth character str.indexof  " test "  look for the string " test " in string str returns the index of the first occurrence of the specified string str.lastindexof  " ing "  returns the index of the last occurrence of the specified string " ing " in the string str stringbuffer does not support this method hence first convert the stringbuffer to string via method tostring str.endswith  " ing "  returns true if str ends with string " ing " str.startswith  " test "  returns true if string str starts with string " test "  str.trim   removes leading and trailing spaces str.replace  str1  str2  replaces all occurrences of str1 by str2 str2.concat  str1  ; concatenates str1 at the end of str2 str.tolowercase   / str.touppercase   converts the string to lower or uppercase str1 + str2 concatenate str1 and str2 string   array = mystring.split  "  "  ; string   array2 = mystring.split  " \ \  "  ; splits the character separated mystring into an array of strings attention  the split string is a regular expression  so if you using special characters which have a meaning in regular expressions  you need to quote them in the second example the  is used and must be quoted by two backslashes 20 lambdas 20.1 what are lambdas the java programming language supports lambdas as of java 8 a lambda expression is a block of code with parameters lambdas allows to specify a block of code which should be executed later if a method expects a functional interface as parameter it is possible to pass in the lambda expression instead the type of a lambda expression in java is a functional interface 20.2 difference between a lambda expression and a closure a lambda is an anonymous function  e.g  it can be defined as parameter a closure is any function which closes over the environment in which it was defined this means that it can access variables not in its parameter list and assigned to a variable java supports lambdas but not closures 20.3 purpose of lambda expressions using lambdas allows to use a condensed syntax compared to other java programming constructs for example the collections in java 8 have a foreach method which accepts a lambda expression list < string > list = new arraylist < >   ; list.add  " vogella.com "  ; list.add  " google.com "  ; list.add  " heise.de "  ; list.foreach  system.out   println  ; 20.4 using method references you can use method references in a lambda expression method reference define the method to be called via calledfrom   method calledfrom can be instance   instancemethod someclass   staticmethod someclass   instancemethod list < string > list = new arraylist < >   ; list.add  " vogella.com "  ; list.add  " google.com "  ; list.add  " heise.de "  ; list.foreach  s > system.out.println  s   ; 21 streams 21.1 what are streams in java 8 a stream from the java.util.stream package is is a sequence of elements from a source that supports aggregate operations 21.2 intstream allow to create a stream of sequence of primitive int-valued elements supporting sequential and parallel aggregate operations package com.vogella.java.streams ; import java.util.arraylist ; import java.util.list ; import java.util.stream.intstream ; public class intstreamexample  public static void main  string   args   // printout the numbers from 1 to 100 intstream.range  1  101  .foreach  s  > system.out.println  s   ; // create a list of integers for 1 to 100 list < integer > list = new arraylist < >   ; intstream.range  1  101  .foreach  it  > list.add  it   ; system.out.println  " size " + list.size    ;   21.3 reduction operations with streams and lambdas allow to create a stream of sequence of primitive int-valued elements supporting sequential and parallel aggregate operations package com.vogella.java.streams ; public class task  private string summary ; private int duration ; public task  string summary  int duration   this.summary = summary ; this.duration = duration ;  public string getsummary    return summary ;  public void setsummary  string summary   this.summary = summary ;  public int getduration    return duration ;  public void setduration  int duration   this.duration = duration ;   package com.vogella.java.streams ; import java.util.arraylist ; import java.util.list ; import java.util.random ; import java.util.stream.collectors ; import java.util.stream.intstream ; public class streamtester  public static void main  string   args   random random = new random   ; // generate a list of random task list < task > values = new arraylist < >   ; intstream.range  1  20  .foreach  i  > values.add  new task  " task " + random.nextint  10   random.nextint  10     ; // get a list of the distinct task summary field list < string > resultlist = values.stream   .filter  t  > t.getduration   > 5  .map  t  > t.getsummary    .distinct   .collect  collectors.tolist    ; system.out.println  resultlist  ; // get a concatenated string of task with a duration longer than 5 hours string collect = values.stream   .filter  t  > t.getduration   > 5  .map  t  > t.getsummary    .distinct   .collect  collectors.joining  "  "   ; system.out.println  collect  ;   22 type conversion if you use variables of different types java requires for certain types an explicit conversion the following gives examples for this conversion 22.1 conversion to string use the following to convert from other types to strings // convert from int to string string s1 = string.valueof  10  ; // " 10 " // convert from double to string string s2 = string.valueof  math.pi  ; // " 3.141592653589793 " // convert from boolean to string string s3 = string.valueof  1 < 2  ; // " true " // convert from date to string string s4 = string.valueof  new date    ; // " tue jun 03 14  40  38 cest 2003 " 22.2 conversion from string to number // conversion from string to int int i = integer.parseint  string  ; // conversion from float to int float f = float.parsefloat  string  ; // conversion from double to int double d = double.parsedouble  string  ; the conversion from string to number is independent from the locale settings  e.g  it is always using the english notification for number in this notification a correct number format is " 8.20 "  thed german number " 8,20 " would result in an error to convert from a german number  you have to use the numberformat class the challenge is that when the value is  for example  98.00 then the numberformat class would create a long which can not be casted to double hence the following complex conversion class private double convertstringtodouble  string s   locale l = new locale  " de "  " de "  ; locale.setdefault  l  ; numberformat nf = numberformat.getinstance   ; double result = 0.0 ; try  if  class.forname  " java.lang.long "  .isinstance  nf.parse  s     result = double.parsedouble  string.valueof  nf.parse  s    ;  else  result =  double  nf.parse  new string  s   ;   catch  classnotfoundexception e1   e1.printstacktrace   ;  catch  parseexception e1   e1.printstacktrace   ;  return result ;  22.3 double to int int i =  int  double ; 22.4 sql date conversions use the following to convert a date to a sql date package test ; import java.text.dateformat ; import java.text.parseexception ; import java.text.simpledateformat ; public class convertdatetosqldate  private void convertdatetosql    simpledateformat template = new simpledateformat  " yyyy-mm-dd "  ; java.util.date enddate = new java.util.date  " 10/31/99 "  ; java.sql.date sqldate = java.sql.date.valueof  template.format  enddate   ;  public static void main  string   args   convertdatetosqldate date = new convertdatetosqldate   ; date.convertdatetosql   ;   23 schedule tasks java allows you to schedule tasks a scheduled tasks can perform once or several times java.util.timer and java.util.timertask can be used to schedule tasks the object which implements timetask will then be performed by the timer based on the given interval 