system which handles
handles or manages
manages primary memory
primary memory memory
memory memory management
management keeps track
free it checks
allocated to processes
processes it decides
decides which process
memory gets freed
freed or unallocated
correspondingly it updates
updates the status
status memory management
management provides protection
register the base
base register holds
holds the smallest
smallest legal physical
legal physical memory
physical memory address
limit register specifies
specifies the size
access all addresses
memory management instructions
instructions and data
data to memory
process will reside
compile time binding
generate the absolute
absolute code load
reside in memory
compiler generates re-locatable
generates re-locatable code
re-locatable code execution
done at run
run time dynamic
loading in dynamic
program all routines
re-locatable load format
format the main
program is loaded
loaded into memory
executed other routines
methods or modules
modules are loaded
loaded on request
request dynamic loading
dynamic loading makes
makes better memory
memory space utilization
utilization and unused
loaded dynamic linking
dynamic linking linking
process of collecting
collecting and combining
combining various modules
modules of code
code and data
memory and executed
executed operating system
system can link
link system level
system level libraries
combines the libraries
libraries at load
linking is done
linking in static
linked at compile
program code size
size becomes bigger
dynamic linking libraries
linking libraries linked
linked at execution
code size remains
size remains smaller
remains smaller logical
smaller logical versus
logical versus physical
versus physical address
physical address space
space an address
address whereas address
physical address logical
address logical address
virtual address virtual
virtual and physical
compile-time and load-time
load-time address-binding schemes
address-binding schemes virtual
physical addresses differ
differ in execution-time
execution-time address-binding scheme
scheme the set
logical addresses generated
program is referred
logical address space
space the set
addresses is referred
space the run-time
mapping from virtual
virtual to physical
address is done
memory management unit
hardware device mmu
mechanism to convert
convert virtual address
address to physical
address the value
register is added
treated as offset
base register value
reallocated to location
user program deals
deals with virtual
sees the real
real physical addresses
physical addresses swapping
addresses swapping swapping
out of main
back into memory
memory for continued
continued execution backing
execution backing store
hard disk drive
fast in access
access and large
capable of providing
providing direct access
memory images major
major time consuming
part of swapping
swapping is transfer
transfer time total
amount of memory
standard hard disk
disk with transfer
milliseconds process swapping
process swapping memory
swapping memory allocation
memory allocation main
allocation main memory
two partitions low
partitions low memory
operating system resides
memory high memory
processes then held
held in high
high memory operating
memory operating system
memory allocation mechanism
allocation mechanism s.n
mechanism s.n memory
s.n memory allocation
memory allocation description
type of allocation
protect user processes
changing operating-system code
data relocation register
register contains value
value of smallest
smallest physical address
address whereas limit
register contains range
range of logical
addresses each logical
memory is divided
number of fixed-sized
partition is free
process is selected
fragmentation as processes
processes are loaded
loaded and removed
removed from memory
free memory space
space is broken
allocated to memory
size and memory
memory blocks remains
blocks remains unused
unused this problem
two types s.n
types s.n fragmentation
s.n fragmentation description
external fragmentation total
fragmentation total memory
total memory space
satisfy a request
reside a process
internal fragmentation memory
fragmentation memory block
memory block assigned
assigned to process
process is bigger
bigger some portion
portion of memory
memory is left
process external fragmentation
reduced by compaction
compaction or shuffle
shuffle memory contents
contents to place
place all free
block to make
make compaction feasible
dynamic paging external
paging external fragmentation
fragmentation is avoided
paging technique paging
memory is broken
broken into blocks
size called pages
size is power
pages are loaded
memory frames logical
frames logical address
process is allocated
allocated physical memory
free memory frame
system keeps track
free frames operating
frames operating system
frames to run
run a program
program of size
size n pages
pages address generated
generated by cpu
cpu is divided
divided into page
page in physical
physical memory page
memory page offset
offset is combined
combined with base
address to define
define the physical
memory address paging
paging following figure
show the paging
paging table architecture
table architecture paging
paging example segmentation
technique to break
memory into logical
represents a group
group of related
segments or code
segment for operating
paging unlike paging
eliminates internal fragmentation
internal fragmentation external
fragmentation external fragmentation
fragmentation still exists
lesser extent logical
extent logical address
address space address
space address generated
divided into segment
segment in physical
limit of segment
segment segment offset
offset is first
checked against limit
memory address virtual
address virtual memory
execution of processes
memory the main
main visible advantage
larger than physical
physical memory virtual
memory virtual memory
separation of user
user logical memory
memory from physical
memory this separation
extremely large virtual
large virtual memory
provided for programmers
smaller physical memory
fully in main
main memory user
memory user written
user written error
written error handling
error handling routines
data or computation
computation certain options
options and features
rarely many tables
tables are assigned
assigned a fixed
amount of address
ability to execute
execute a program
partially in memory
memory would counter
counter many benefits
benefits less number
needed to load
load or swap
swap each user
program into memory
memory a program
longer be constrained
amount of physical
increase in cpu
utilization and throughput
throughput virtual memory
virtual memory virtual
implemented by demand
segmentation system demand
system demand segmentation
provide virtual memory
virtual memory demand
memory demand paging
paging a demand
demand paging system
system with swapping
execute a process
swapping the entire
process into memory
swapper called pager
guesses which pages
process is swapped
pages into memory
reading into memory
decreasing the swap
physical memory needed
memory needed hardware
needed hardware support
support is required
required to distinguish
valid-invalid bit scheme
scheme where valid
valid and invalid
checked by checking
checking the bit
marking a page
process never attempts
attempts to access
access the page
executes and accesses
proceeds normally demand
demand paging access
page marked invalid
trap this trap
system s failure
failure to bring
bring the desired
page into memory
memory but page
page fault step
fault step description
step description step
check an internal
invalid memory access
memory access step
reference was invalid
terminate the process
find a free
free frame step
schedule a disk
operation to read
read the desired
newly allocated frame
allocated frame step
read is complete
modify the internal
restart the instruction
illegal address trap
trap the process
operating system reads
reads the desired
memory and restarts
restarts the process
advantages of demand
demand paging large
paging large virtual
memory more efficient
memory unconstrained multiprogramming
limit on degree
degree of multiprogramming
disadvantages of demand
demand paging number
number of tables
tables and amount
amount of processor
overhead for handling
handling page interrupts
interrupts are greater
simple paged management
paged management techniques
management techniques due
jobs address space
address space size
space size page
size page replacement
page replacement algorithm
replacement algorithm page
algorithm page replacement
page replacement algorithms
operating system decides
decides which memory
pages to swap
write to disk
page of memory
page fault occurs
allocation purpose accounting
accounting to reason
reason that pages
number of free
pages is lower
lower than required
selected for replacement
completion this process
determines the quality
waiting for page-ins
algorithm a page
information about accessing
accessing the pages
provided by hardware
select which pages
replaced to minimize
minimize the total
number of page
costs of primary
storage and processor
algorithms we evaluate
evaluate an algorithm
algorithm by running
string of memory
reference and computing
computing the number
page faults reference
faults reference string
string the string
reference string reference
string reference strings
strings are generated
system and recording
recording the address
produces a large
number of data
note two things
immediately following references
references to page
page fault page
sequence of addresses
123,215,600,1234,76,96 if page
first in first
algorithm oldest page
page in main
easy to implement
tail and add
add new pages
first out optimal
out optimal page
optimal page algorithm
algorithm an optimal
optimal page-replacement algorithm
lowest page-fault rate
algorithms an optimal
page-replacement algorithm exists
opt or min
replace the page
optimal page replacement
recently used page
page buffering algorithm
pool of free
frames on page
select a page
write new page
frame of free
mark the page
table and restart
restart the process
process now write
write the dirty
out of disk
disk and place
place the frame
frame holding replaced
holding replaced page
page in free
replacement this algorithm
algorithm this algorithm
algorithm is based
memory management
operating system
primary memory
memory memory
memory location
status memory
base register
limit register
register holds
smallest legal
legal physical
physical memory
memory address
register specifies
legally access
management instructions
memory addresses
absolute code
code load
compiler generates
re-locatable code
code execution
memory segment
dynamic loading
re-locatable load
load format
main program
routines methods
loading makes
memory space
space utilization
unused routines
dynamic linking
linking linking
executable file
executed operating
link system
system level
level libraries
static linking
libraries linked
program code
code size
linking libraries
size remains
remains smaller
logical versus
physical address
address space
address generated
logical address
memory unit
virtual address
physical addresses
load-time address-binding
address-binding schemes
addresses differ
execution-time address-binding
address-binding scheme
logical addresses
addresses generated
run-time mapping
management unit
hardware device
device mmu
user process
register value
address location
user program
program deals
virtual addresses
real physical
addresses swapping
swapping swapping
main memory
backing store
continued execution
execution backing
hard disk
secondary storage
accommodate copies
memory images
direct access
consuming part
total transfer
memory swapped
standard hard
transfer rate
actual transfer
milliseconds process
process swapping
swapping memory
memory allocation
allocation main
low memory
system resides
memory high
high memory
user processes
memory operating
allocation mechanism
mechanism s.n
s.n memory
allocation description
single-partition allocation
relocation-register scheme
protect user
operating-system code
data relocation
relocation register
smallest physical
multiple-partition allocation
fixed-sized partitions
input queue
free partition
process terminates
process fragmentation
free memory
memory blocks
small size
blocks remains
remains unused
fragmentation fragmentation
types s.n
s.n fragmentation
fragmentation description
external fragmentation
fragmentation total
total memory
internal fragmentation
fragmentation memory
memory block
block assigned
shuffle memory
memory contents
large block
make compaction
dynamic paging
paging technique
technique paging
memory frames
memory frame
free frames
frames operating
pages address
page number
page table
base address
memory page
page offset
address paging
figure show
paging table
table architecture
architecture paging
segmentation segmentation
break memory
logical pieces
piece represents
related information
code segment
data segment
varying sizes
lesser extent
space address
segment number
segment table
segment segment
segment offset
virtual memory
main visible
visible advantage
logical memory
large virtual
smaller physical
entire program
memory user
user written
written error
error handling
handling routines
error occured
fixed amount
small amount
cpu utilization
demand paging
segmentation system
system demand
demand segmentation
memory demand
paging system
entire process
lazy swapper
pager guesses
pager brings
memory pages
memory needed
needed hardware
hardware support
valid-invalid bit
bit scheme
invalid pages
bit marking
process executes
accesses pages
memory resident
execution proceeds
paging access
page marked
page-fault trap
desired page
page fault
fault step
step description
description step
internal table
invalid memory
memory access
access step
free frame
frame step
disk operation
allocated frame
disk read
memory step
illegal address
address trap
system reads
memory advantages
memory unconstrained
unconstrained multiprogramming
multiprogramming disadvantages
paging number
processor overhead
handling page
page interrupts
simple paged
paged management
management techniques
explicit constraints
jobs address
space size
size page
page replacement
replacement algorithm
algorithm page
replacement algorithms
system decides
allocated paging
fault occurs
free page
allocation purpose
purpose accounting
free pages
required pages
process determines
limited information
pages provided
total number
page misses
primary storage
memory reference
page faults
faults reference
reference string
memory references
string reference
reference strings
choice produces
large number
page size
entire address
fault page
first reference
oldest page
replace pages
optimal page
page algorithm
optimal page-replacement
page-replacement algorithm
lowest page-fault
page-fault rate
algorithm exists
min replace
longest period
page buffering
buffering algorithm
process start
replaced write
free pool
dirty page
frame holding
replaced page
smallest count
algorithm suffers
initial phase
memory
management
functionality
operating
system
handles
manages
primary
track
location
allocated
process
free
checks
processes
decides
tracks
freed
unallocated
correspondingly
updates
status
protection
two
registers
base
register
limit
holds
smallest
legal
physical
address
specifies
size
range
program
legally
access
addresses
instructions
data
done
ways
compile
reside
binding
generate
absolute
code
load
compiler
generates
re-locatable
execution
moved
segment
delayed
run
dynamic
loading
routine
loaded
routines
disk
format
main
executed
methods
modules
request
makes
space
utilization
unused
linking
collecting
combining
executable
file
link
level
libraries
combines
static
linked
bigger
remains
smaller
logical
versus
generated
cpu
unit
virtual
compile-time
load-time
address-binding
schemes
differ
execution-time
scheme
set
referred
run-time
mapping
mmu
hardware
device
mechanism
convert
value
added
user
treated
offset
attempt
dynamically
reallocated
deals
sees
real
swapping
swapped
temporarily
out
backing
store
brought
back
continued
hard
drive
secondary
storage
fast
large
accommodate
copies
images
users
capable
providing
direct
major
consuming
part
transfer
total
directly
proportional
amount
assume
100kb
standard
rate
actual
100k
1000kb
milliseconds
allocation
partitions
low
resides
high
held
s.n
description
single-partition
type
relocation-register
protect
changing
operating-system
relocation
multiple-partition
divided
number
fixed-sized
partition
selected
input
queue
terminates
fragmentation
removed
broken
pieces
blocks
small
problem
types
external
satisfy
contiguous
internal
block
assigned
portion
left
reduced
compaction
shuffle
contents
place
make
feasible
paging
avoided
technique
pages
power
bytes
frames
non-contiguous
frame
page
index
table
combined
define
figure
show
architecture
segmentation
break
piece
represents
group
related
information
,data
segments
implemented
unlike
varying
sizes
eliminates
exists
lesser
extent
first
checked
completely
visible
advantage
programs
larger
separation
extremely
provided
programmers
situations
entire
required
fully
written
error
handling
occured
computation
options
features
rarely
tables
fixed
ability
execute
partially
counter
benefits
i
needed
swap
longer
constrained
increase
throughput
commonly
demand
provide
similar
lazy
swapper
pager
guesses
brings
avoids
reading
decreasing
support
distinguish
valid-invalid
bit
valid
invalid
checking
marking
effect
attempts
executes
accesses
resident
proceeds
marked
page-fault
trap
result
failure
bring
desired
fault
handled
step
check
determine
reference
terminate
find
schedule
operation
read
newly
complete
modify
restart
instruction
interrupted
illegal
reads
restarts
advantages
efficient
unconstrained
multiprogramming
degree
disadvantages
processor
overhead
interrupts
greater
case
simple
paged
techniques
due
lack
explicit
constraints
jobs
replacement
algorithm
algorithms
write
occurs
purpose
accounting
reason
lower
referenced
requires
completion
determines
quality
waiting
page-ins
limited
accessing
select
replaced
minimize
misses
balancing
costs
evaluate
running
string
computing
faults
references
strings
artificially
tracing
recording
choice
produces
note
things
immediately
sequence
123,215,600,1234,76,96
1,2,6,12,0,0
fifo
oldest
easy
implement
list
replace
tail
add
head
optimal
page-replacement
lowest
opt
min
longest
period
recently
lru
buffering
start
quickly
pool
mark
dirty
holding
frequently
lfu
count
suffers
situation
heavily
initial
phase
mfu
based
argument
