cs140 operating systems instructors  adam belay  ali mashtizadeh  david mazieres ` cas  michael chang  peter johnston  yutian liu  rush moody  rasmus rygaard  jayesh yerrapragada stanford university 1 / 33 administrivia class web page  http  //cs140.scs.stanford.edu/  all assignments  handouts  lecture notes on-line textbook  operating system concepts  8th edition  by silberschatz  galvin  and gagne  9th edition is way more expensive  i haven t looked at it  trying to ween class from textbook anyway consider it optional goal is to make lecture slides the primary reference  almost everything i talk about will be on slides  pdf slides contain links to further reading about topics  please download slides from class web page 2 / 33 administrivia 2 staff mailing list  cs140-staff @ scs.stanford.edu  please mail staff list rather than individuals for help google group 15wi-cs140 is main discussion forum key dates   lectures  mw 4  15 5  30pm  gates b01  section  some fridays  time/location tbd  midterm  monday  feb 9  4  15 5  30pm  in class   final  thursday  march 19  12  15pm 3  15pm exams open note  but not open book  bring notes  slides  any printed materials except textbook  no electronic devices permitted 3 / 33 lecture videos lectures will be televised for scpd students  can also watch if you miss a lecture  or to review  but resist temptation to miss a bunch of lectures and watch them all at once scpd students welcome to attend lecture in person  4  15pm lecture time conveniently at end of work day  many parking spaces don t require permit after 4pm other notes for scpd students   please attend exams in person if possible  feel free to use google group to find project partners 4 / 33 course topics threads & processes concurrency & synchronization scheduling virtual memory i/o disks  file systems  network file systems protection & security virtual machines note  lectures will often take unix as an example  most current and future oses heavily influenced by unix  windows is exception ; this quarter we will mostly ignore 5 / 33 course goals introduce you to operating system concepts  hard to use a computer without interacting with os  understanding the os makes you a more effective programmer cover important systems concepts in general  caching  concurrency  memory management  i/o  protection teach you to deal with larger software systems  programming assignments much larger than many courses  warning  many people will consider course very hard  in past  majority of people report 15 hours/week prepare you to take graduate os classes  cs240  240  a-z   6 / 33 programming assignments implement parts of pintos operating system  built for x86 hardware  you will use hardware emulator one setup homework  lab 0  due friday four implementation projects   threads  user processes  virtual memory  file system lab 1 distributed at end of this week  attend section this friday for project 1 overview implement projects in groups of up to 3 people  pick your partners today  lecture will end early so that you can do this 7 / 33 grading no incompletes  talk to instructors asap if you run into real problems 50 % of grade based on exams using this quantity  max  midterm > 0 final  0   midterm + final  /2  50 % of grade from projects  for each project  50 % of score based on passing test cases  remaining 50 % based on design and style most people s projects pass most test cases  please  please  please turn in working code  or no credit here means design and style matter a lot  large software systems not just about producing working code  need to produce code other people can understand  that s why we have group projects 8 / 33 style must turn in a design document along with code  we supply you with templates for each project s design doc cas will manually inspect code for correctness  e.g  must actually implement the design  must handle corner cases  e.g  handle malloc failure  will deduct points for error-prone code w/o errors  don t use global variables if automatic ones suffice  don t use deceptive names for variables code must be easy to read  indent code  keep lines and  when possible  functions short  use a uniform coding style  try to match existing code   put comments on structure members  globals  functions  don t leave in reams of commented-out garbage code 9 / 33 assignment requirements do not look at other people s solutions to projects  we reserve the right to run moss on present and past submissions  do not publish your own solutions in violation of the honor code you may read but not copy other oses  e.g  linux  openbsd/freebsd  etc cite any code that inspired your code  as long as you cite what you used  it s not cheating  in worst case  we deduct points if it undermines the assignment projects due fridays at noon ask cs140-staff for extension if you run into trouble  be sure to tell us  how much have you done how much is left when can you finish by 10 / 33 what is an operating system layer between applications and hardware makes hardware useful to the programmer  usually  provides abstractions for applications  manages and hides details of hardware  accesses hardware through low/level interfaces unavailable to applications  often  provides protection  prevents one process/user from clobbering another 11 / 33 why study operating systems operating systems are a maturing field  most people use a handful of mature oses  hard to get people to switch operating systems  hard to have impact with a new os high-performance servers are an os issue  face many of the same issues as oses resource consumption is an os issue  battery life  radio spectrum  etc security is an os issue  hard to achieve security without a solid foundation new smart devices need new oses web browsers increasingly face os issues 12 / 33 primitive operating systems just a library of standard services  no protection   standard interface above hardware-specific drivers  etc simplifying assumptions  system runs one program at a time  no bad users or programs  often bad assumption  problem  poor utilization     of hardware  e.g  cpu idle while waiting for disk      of human user  must wait for each program to finish  13 / 33 multitasking idea  run more than one process at once  when one process blocks  waiting for disk  network  user input  etc  run another process problem  what can ill-behaved process do  go into infinite loop and never relinquish cpu  scribble over other processes memory to make them fail os provides mechanisms to address these problems  preemption take cpu away from looping process  memory protection protect process s memory from one another 14 / 33 multitasking idea  run more than one process at once  when one process blocks  waiting for disk  network  user input  etc  run another process problem  what can ill-behaved process do  go into infinite loop and never relinquish cpu  scribble over other processes memory to make them fail os provides mechanisms to address these problems  preemption take cpu away from looping process  memory protection protect process s memory from one another 14 / 33 multi-user oses many oses use protection to serve distrustful users/apps idea  with n users  system not n times slower  users demands for cpu  memory  etc are bursty  win by giving resources to users who actually need them what can go wrong  users are gluttons  use too much cpu  etc  need policies   total memory usage greater than in machine  must virtualize   super-linear slowdown with increasing demand  thrashing  15 / 33 multi-user oses many oses use protection to serve distrustful users/apps idea  with n users  system not n times slower  users demands for cpu  memory  etc are bursty  win by giving resources to users who actually need them what can go wrong  users are gluttons  use too much cpu  etc  need policies   total memory usage greater than in machine  must virtualize   super-linear slowdown with increasing demand  thrashing  15 / 33 protection mechanisms that isolate bad programs and people pre-emption   give application a resource  take it away if needed elsewhere interposition/mediation   place os between application and stuff  track all pieces that application allowed to use  e.g  in table   on every access  look in table to check that access legal privileged & unprivileged modes in cpus   applications unprivileged  unprivileged user mode   os privileged  privileged supervisor/kernel mode   protection operations can only be done in privileged mode 16 / 33 typical os structure user kernel driver device p1 p2 p3 p4 sockets tcp/ip system file console disk device driver driver device network vm scheduler ipc most software runs as user-level processes  p  1-4   os kernel runs in privileged mode  shaded   creates/deletes processes  provides access to hardware 17 / 33 system calls applications can invoke kernel through system calls  special instruction transfers control to kernel     which dispatches to one of few hundred syscall handlers 18 / 33 system calls  continued  goal  do things app can t do in unprivileged mode  like a library call  but into more privileged kernel code kernel supplies well-defined system call interface  applications set up syscall arguments and trap to kernel  kernel performs operation and returns result higher-level functions built on syscall interface  printf  scanf  gets  etc all user-level code example  posix/unix interface  open  close  read  write   19 / 33 system call example standard library implemented in terms of syscalls  printf in libc  has same privileges as application  calls write in kernel  which can send bits out serial port 20 / 33 unix file system calls applications open files  or devices  by name  i/o happens through open files int open  char * path  int flags  / * mode * /  ;  flags  o rdonly  o wronly  o rdwr  o creat  create the file if non-existent  o excl   w o creat  create if file exists already  o trunc  truncate the file  o append  start writing from end of file  mode  final argument with o creat returns file descriptor used for all i/o to file 21 / 33 error returns what if open fails returns -1  invalid fd  most system calls return -1 on failure  specific kind of error in global int errno # include for possible values  2 = enoent no such file or directory  13 = eacces permission denied perror function prints human-readable message  perror  " initfile "  ; initfile  no such file or directory 22 / 33 operations on file descriptors int read  int fd  void * buf  int nbytes  ;  returns number of bytes read  returns 0 bytes at end of file  or -1 on error int write  int fd  const void * buf  int nbytes  ;  returns number of bytes written  -1 on error off t lseek  int fd  off t pos  int whence  ;  whence  0 start  1 current  2 end  returns previous file offset  or -1 on error int close  int fd  ; 23 / 33 file descriptor numbers file descriptors are inherited by processes  when one process spawns another  same fds by default descriptors 0  1  and 2 have special meaning  0 standard input  stdin in ansi c   1 standard output  stdout  printf in ansi c   2 standard error  stderr  perror in ansi c   normally all three attached to terminal example  type.c  prints the contents of a file to stdout 24 / 33 type.c void typefile  char * filename   int fd  nread ; char buf  1024  ; fd = open  filename  o_rdonly  ; if  fd = = -1   perror  filename  ; return ;  while   nread = read  fd  buf  sizeof  buf    > 0  write  1  buf  nread  ; close  fd  ;  25 / 33 different system contexts a system is generally in one of several contexts user-level cpu in user mode running application kernel process context  running kernel code on behalf of a particular process  e.g  performing system call  also exception  mem fault  numeric exception  etc   or executing a kernel-only process  e.g  network file server  kernel code not associated w a process  timer interrupt  hardclock   device interrupt  softirqs  tasklets  linux-specific terms  context switch code changing address spaces idle nothing to do  might powerdown cpu  26 / 33 transitions between contexts user kernel process context  syscall  page fault user/process context interrupt handler  hardware process context user/context switch  return process context context switch  sleep context switch user/process context 27 / 33 cpu preemption protection mechanism to prevent monopolizing cpu e.g  kernel programs timer to interrupt every 10 ms  must be in supervisor mode to write appropriate i/o registers  user code can not re-program interval timer kernel sets interrupt to vector back to kernel  regains control whenever interval timer fires  gives cpu to another process if someone else needs it  note  must be in supervisor mode to set interrupt entry points  no way for user code to hijack interrupt handler result  can not monopolize cpu with infinite loop  at worst get 1/n of cpu with n cpu-hungry processes 28 / 33 protection is not security how can you monopolize cpu use multiple processes for many years  could wedge most oses with int main    while  1  fork   ;   keeps creating more processes until system out of proc slots other techniques  use all memory  chill program  typically solved with technical/social combination  technical solution  limit processes per user  social  reboot and yell at annoying users  social  pass laws  often debatable whether a good idea  29 / 33 protection is not security how can you monopolize cpu use multiple processes for many years  could wedge most oses with int main    while  1  fork   ;   keeps creating more processes until system out of proc slots other techniques  use all memory  chill program  typically solved with technical/social combination  technical solution  limit processes per user  social  reboot and yell at annoying users  social  pass laws  often debatable whether a good idea  29 / 33 address translation protect memory of one program from actions of another definitions  address space  all memory locations a program can name  virtual address  addresses in process address space  physical address  address of real memory  translation  map virtual to physical addresses translation done on every load and store  modern cpus do this in hardware for speed idea  if you can t name it  you can t touch it  ensure one process s translations don t include any other process s memory 30 / 33 more memory protection cpu allows kernel-only virtual addresses  kernel typically part of all address spaces  e.g  to handle system call in same address space  but must ensure apps can t touch kernel memory cpu lets os disable  invalidate  particular virtual addresses  catch and halt buggy program that makes wild accesses  make virtual memory seem bigger than physical  e.g  bring a page in from disk only when accessed  cpu enforced read-only virtual addresses useful  e.g  allows sharing of code pages between processes  plus many other optimizations cpu enforced execute disable of vas  makes certain code injection attacks harder 31 / 33 resource allocation & performance multitasking permits higher resource utilization simple example   process downloading large file mostly waits for network  you play a game while downloading the file  higher cpu utilization than if just downloading complexity arises with cost of switching example  say disk 1,000 times slower than memory  1 gb memory in machine  2 processes want to run  each use 1 gb  can switch processes by swapping them out to disk  faster to run one at a time than keep context switching 32 / 33 useful properties to exploit skew  80 % of time taken by 20 % of code  10 % of memory absorbs 90 % of references  basis behind cache  place 10 % in fast memory  90 % in slow  usually looks like one big fast memory past predicts future  a.k.a temporal locality   what s the best cache entry to replace  if past future  then least-recently-used entry note conflict between fairness & throughput  higher throughput  fewer cache misses  etc  to keep running same process  but fairness says should periodically preempt cpu and give it to next process 33 / 33 