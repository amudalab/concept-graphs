structures and algorithms
naveen garg department
department of computer
science and engineering
engineering indian institute
institute of technology
dictionary abstract data
abstract data type
search is done
analysis for binary
hashing is done
collision resolution techniques
techniques a dictionary
type that stores
located very quickly
store bank accounts
accounts the notion
account has lots
lots of information
access the bank
account or data
account stores wealth
wealth of information
list of transactions
last few days
key a dictionary
stores the elements
talk of key
number that helps
information any application
application that wishes
kind of operation
provide the account
number as key
key the process
key the dictionary
basically an abstract
store the keyelement
pairs the key
key your entry
identifies particular student
dictionary is searching
searching by key
kinds of method
type the standard
standard container methods
queues and stacks
dictionary is empty
find the element
kind of settings
return all elements
insert an element
remove an element
remove all elements
remember the notion
special element nil
search it means
return a nill
element one thing
comparison of keys
keys for equality
two particular keys
doing is searching
notion of taking
taking two names
smaller or larger
operation we require
require is comparing
ways of implementing
implementing this abstract
type for instance
list to implement
implement a dictionary
implement this dictionary
dictionary every node
predecessor or successor
completely arbitrary manner
manner the nodes
throw them arbitrary
red or black
mechanisms of data
structures to implement
important data type
lectures in java
class called java.util.dictionary
java.util.dictionary which lays
out the specification
interface called java.util.map
problem of searching
discussions the problem
sequence of numbers
database i give
return the position
number or nil
sitting at position
technique called binary
recall the technique
search is divide
divide and conquer
problems in divide
divide and search
range of elements
suppose the elements
increasing or decreasing
decreasing for binary
search to work
set of elements
order this means
low and high
element which means
compare the middle
return this information
search the procedure
read and understand
understand this quickly
notion of low
range and high
end and high
end if low
basically that means
invoking something wrong
return a null
obtained by taking
taking the average
average of low
high and check
found the key
array the left
staring location low
ending location mid-1
array which means
means the mid
high else return
search for small
pieces of code
write an iterative
procedure the low
low to begin
high to begin
loop and updating
high and low
first step low
low becomes mid
element was larger
element is smaller
element then high
find the key
return the location
key or low
low becomes larger
larger than high
loop and return
write a binary
two different ways
problem is halved
essentially the range
comparison the range
log n comparison
log n comparisons
location you desire
desire in constant
write any base
base for log
suppose the numbers
array one element
compare your key
element you searched
spend some order
array is sorted
huge difference coming
sort the element
element to begin
small pseudo code
array that ends
asked to implement
implement a caller
caller id facility
large phone company
making the call
return the callers
case in delhi
delhi the range
range of phone
million phone numbers
numbers the number
numbers are present
actual different number
number of elements
searching take order
decides to give
remove it searching
searching itself takes
removing also takes
thing in order
putting the elements
location thus inserting
implementation is good
things is faliable
maintain log files
maintain some kinds
kinds of log
file for instance
instance any kind
kind of transactions
revert the transaction
system and maintain
maintain the log
search or removals
frequent but searches
searches and deletion
case this implementation
good because insertion
takes only constant
remove and insert
operation being performed
decide what type
type of data
implement the dictionary
dictionary data type
elements were put
key searching takes
searching takes log
log n provided
kind of direct
direct access mechanism
element you wanted
inserting and removing
maintain the sorted
insert the element
move it back
examples in previous
insertion take order
order n elements
recall your big-oh
lot of searching
insertions and deletions
array of size
huge array ankur
array and put
position which corresponds
corresponds to ankur
ankur phone number
number all operations
search and delete
insert a caller
caller id capability
array and retrieve
remove the element
wasting a lot
lot of space
operations very quickly
space is turning
two much space
create an array
create a smaller
users to locations
number of users
fancy i create
compute this value
ankur at location
insertion and delete
numbers but entry
numbers of students
class your entry
numbers is huge
set of values
create a table
table of size
spend more space
space than that.let
that.let me pick
function this function
previous example mod
takes the last
mapped to location
delete and search
address the problem
problem of clash
address this issue
keys which mapped
concept called chaining
ways of addressing
addressing this issue
issue and today
technique called chaining
chaining the blue
blue color thing
put the elements
linked list starting
linked list suppose
suppose my hash
taking the key
key and computing
keys were mapped
keys getting mapped
mapped to locations
problem of collision
resolved the collision
things in constant
keys get mapped
data structure reduces
linked list data
list data structure
delete still insert
insert has constant
person who sits
insert and delete
examples of hash
kinds of hash
typically used hash
functions the last
regarded as modulo
function to find
find the position
search or insert
insert or delete
maintain the list
order then insertion
unordered then insertion
end of linked
traverse the entire
list to reach
reach the end
maintaining one pointer
pointer to add
add an element
notion of order
notion to order
order the elements
elements an element
element with key
value of hash
function the hash
function is mapping
mapping the universe
compute the hash
simple arithmetic operations
operations to compute
compute the value
function is independent
choice of hash
functions are concerned
choices of hash
hash function lot
lot of research
research has done
function that people
motivate the concept
good hash function
function a good
distribute the keys
keys to location
structure would start
single linked list
function which distributes
list is small
small an ideal
ideal hash function
pick at random
locations then throw
throw the element
function which takes
takes a key
key and puts
takes the element
element and throws
simple uniform hash
uniform hash function
number of slots
call this load
load factor alpha
search is unsuccessful
unsuccessful it means
element i computed
computed the value
entire linked list
spend i spend
spend time propositional
computing the hash
hash function takes
function takes constant
right linked list
pointer by pointer
simple hash function
distributing the things
table the excepted
roughly a constant
ideal hash functions
create a bad
bad hash function
spent in computing
data structure relies
function we choose
good hash functions
class designing hash
designing hash function
art than science
data to design
design a good
class some principle
kind of hash
make a successful
find my element
process the position
ways of arguing
database the element
case of successful
successful search excepted
search excepted number
element was inserted
inserted and appended
compare that element
number of comparisons
hash function computation
roughly the excepted
excepted time required
required to insert
summing this quantity
elements and taking
average time computations
list or find
half the length
kind of behavior
low order term
successful and unsuccessful
taking a similar
pick the size
size of hash
size our hash
table should start
concept of growable
structures you start
elements you inserting
sizes of linked
move the entire
set of element
larger hash table
modify these things
design your hash
hash function keeping
keeping in mind
number of hash
hash table slots
slots was propositional
elements it depends
pick the number
table can accommodate
accommodate any number
attach any number
table would deteriorate
10,000 elements coming
average the linked
linked list length
case it make
sense to move
create a hash
wastage of space
small hash table
large hash table
bit of hashing
continue with hashing
hashing c concepts
concepts of good
ways of resolving
data structures
naveen garg
garg department
computer science
engineering indian
indian institute
delhi lecture
dictionary abstract
abstract data
data type
binary search
hash table
collision resolution
resolution techniques
hashing techniques
stores elements
store bank
bank accounts
account number
bank account
account numbers
account stores
stores wealth
current balance
account holder
transactions done
additional information
abstract model
keyelement pairs
case suppose
student records
natural notion
entry number
main operations
standard container
container methods
query methods
key find
update methods
standard thing
special element
element nil
unsuccessful search
require comparison
student record
comparing keys
keys dictionary
linked list
dictionary suppose
doing things
arbitrary manner
efficient today
binary tree
black trees
avl trees
important data
abstract class
subsequent discussions
numbers lets
single number
sitting index
found number
return nil
key idea
design technique
future classes
sorted order
work suppose
middle element
increasing order
entire array
2nd part
3rd part
recursive procedure
pseudo code
lower end
higher end
procedure call
return mid
left part
staring location
ending location
location mid-1
return binarysearch
recursive call
right part
small pieces
iterative procedure
blue color
first step
mid element
do-while loop
step range
first comparison
array implementation
elements sitting
entire process
decreasing order
worst case
first position
3rd position
huge difference
difference coming
small pseudo
dictionary problem
large phone
phone company
phone number
phone numbers
digit numbers
million phone
unordered sequence
arbitrary order
entire list
unordered list
element suppose
person decides
data record
takes order
small modification
entire thing
first location
inserting takes
maintain log
log files
log file
system administration
add data
add insertions
insertion takes
data structure
dictionary data
ordered sequence
key searching
searching takes
takes log
direct access
access mechanism
whichever element
element insertion
similarly deletion
previous class
create space
step right
move order
big-oh notation
make sense
subsequent discussion
huge array
array ankur
ankur phone
operations insert
phone connection
bad thing
previous technique
smaller array
hypothetical setting
small number
entry numbers
hash function
clash suppose
location number
grade shape
simple technique
color thing
list starting
list suppose
computing modulo
collision problem
structure reduces
list data
quick recap
hash functions
key modulo
constant amount
end suppose
simple arithmetic
arithmetic operations
good choices
function lot
simple examples
good hash
distributes things
ideal hash
random location
simple uniform
uniform hash
load factor
table divided
factor alpha
function takes
takes constant
right linked
follow pointer
average size
simple hash
excepted number
total search
excepted search
bad hash
structure relies
class designing
designing hash
successful search
10th element
excepted length
inserted was9m
search excepted
elements examined
function computation
list divided
similar kind
low order
order term
good choice
excepted sense
growable stack
entire set
larger hash
function keeping
smaller table
larger table
table slots
elements coming
list length
small hash
large hash
space today
data
structures
algorithms
naveen
garg
department
computer
science
engineering
indian
institute
technology
delhi
lecture
dictionaries
dictionary
abstract
type
binary
search
done
analysis
hashing
hash
table
collision
resolution
techniques
class
follow
stores
elements
located
quickly
store
bank
accounts
notion
key
account
number
lots
information
access
numbers
wealth
current
balance
address
holder
list
transactions
last
days
talk
element
additional
helps
application
wishes
kind
operation
provide
process
continued
basically
model
database
keyelement
pairs
case
suppose
student
records
natural
entry
integer
characters
uniquely
identifies
main
operations
supported
searching
kinds
method
standard
container
methods
queues
stacks
size
isempty
tells
empty
returns
query
find
findelem
settings
return
update
insert
remove
thing
remember
crucial
difficult
special
nil
returned
unsuccessful
means
procedure
nill
mind
require
comparison
keys
equality
two
required
doing
instance
record
taking
names
smaller
larger
comparing
order
lectures
implemented
ways
implementing
array
linked
implement
node
inefficient
things
predecessor
successor
organize
connect
completely
arbitrary
manner
nodes
throw
implementation
efficient
today
tree
red
black
trees
avl
b-trees
mechanisms
important
spending
java
java.util.dictionary
lays
out
specification
interface
java.util.map
understand
problem
small
making
end
subsequent
discussions
sequence
lets
give
single
5,10,7
databases
position
sitting
index
found
call
technique
recall
idea
divide
conquer
design
future
classes
applied
problems
narrow
range
sorted
increasing
decreasing
work
middle
compare
lies
lye
right
set
lie
variables
low
high
part
initially
entire
figured
2nd
repeat
left
3rd
diagram
location
write
recursive
pseudo
code
read
lower
higher
invoking
wrong
null
obtained
average
check
mid
staring
ending
mid-1
binarysearch
pieces
iterative
equivalent
written
happening
begin
blue
color
roughly
putting
loop
updating
first
step
do-while
shown
log
takes
halved
items
essentially
stop
comparisons
desire
constant
unit
base
assumed
worst
lucky
beginning
1st
searched
spend
huge
difference
coming
sorting
sort
run
ends
back
setting
asked
caller
facility
large
phone
company
based
figure
person
callers
assume
digit
million
present
actual
efficiently
unordered
put
traverse
decides
connection
removing
modification
inserting
care
clear
good
applications
faliable
maintain
files
file
revert
transaction
system
administration
track
activities
rarely
removals
add
frequently
insertions
frequent
searches
deletion
rare
insertion
performed
decide
structure
ordered
provided
direct
mechanism
whichever
wanted
shift
similarly
move
examples
previous
inserted
create
space
moving
big-oh
notation
make
sense
lot
deletions
discussion
ankur
9635-8904
corresponds
delete
capability
straight
retrieve
bad
wasting
turning
issue
excepted
users
wasted
locations
mapped
hypothetical
friends
fancy
compute
value
mod
depending
students
digits
infact
values
people
that.let
pick
function
picks
clash
2004cs50310
arise
grade
shape
showed
waste
deal
spot
concept
chaining
addressing
simple
starting
computing
modulo
adding
picture
resolved
reduces
identity
sits
quick
recap
determine
functions
typically
regarded
reason
options
amount
reach
pointer
points
maintaining
pointers
front
tail
ordering
stored
slot
mapping
universe
slots
m-1
rest
arithmetic
independent
choice
concerned
choices
research
gave
motivate
distribute
uniformly
map
collisions
start
distributes
ideal
random
shows
puts
picked
point
throws
randomly
probability
uniform
term
load
factor
divided
alpha
happen
computed
propositional
thrown
distributing
examined
total
denote
half
represents
spent
brings
question
efficiency
relies
critically
choose
designing
art
show
principle
theorem
successful
walking
arguing
10th
length
was9m
argued
appended
critical
prove
manners
computation
summing
quantity
math
computations
similar
behavior
ignore
like1
this1
intuitive
growable
stack
sizes
modify
keeping
depends
equal
accommodate
attach
performance
deteriorate
10,000
wastage
grow
bit
continue
concepts
resolving
