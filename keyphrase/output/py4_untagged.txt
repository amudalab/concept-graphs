the goal of this book is to teach you to think like a computer scientist this way of thinking combines some of the best features of mathematics  engineering  and natural science like mathematicians  computer scientists use formal languages to denote ideas  specifically computations   like engineers  they design things  assembling components into systems and evaluating tradeoffs among alternatives like scientists  they observe the behavior of complex systems  form hypotheses  and test predictions the single most important skill for a computer scientist is problem solving problem solving means the ability to formulate problems  think creatively about solutions  and express a solution clearly and accurately as it turns out  the process of learning to program is an excellent opportunity to practice problem solving skills that s why this chapter is called  the way of the program on one level  you will be learning to program  a useful skill by itself on another level  you will use programming as a means to an end as we go along  that end will become clearer 1.1 the python programming language the programming language you will be learning is python python is an example of a high-level language ; other high-level languages you might have heard of are c  c + +  perl  and java as you might infer from the name high-level language  there are also lowlevel languages  sometimes referred to as machine languages or assembly 2 the way of the program languages loosely speaking  computers can only execute programs written in low-level languages thus  programs written in a high-level language have to be processed before they can run this extra processing takes some time  which is a small disadvantage of high-level languages but the advantages are enormous first  it is much easier to program in a high-level language programs written in a high-level language take less time to write  they are shorter and easier to read  and they are more likely to be correct second  high-level languages are portable  meaning that they can run on different kinds of computers with few or no modifications low-level programs can run on only one kind of computer and have to be rewritten to run on another due to these advantages  almost all programs are written in high-level languages low-level languages are used only for a few specialized applications two kinds of programs process high-level languages into low-level languages  interpreters and compilers an interpreter reads a high-level program and executes it  meaning that it does what the program says it processes the program a little at a time  alternately reading lines and performing computations source output code interpreter a compiler reads the program and translates it completely before the program starts running in this case  the high-level program is called the source code  and the translated program is called the object code or the executable once a program is compiled  you can execute it repeatedly without further translation output code object executor code source compiler python is considered an interpreted language because python programs are executed by an interpreter there are two ways to use the interpreter  commandline mode and script mode in command-line mode  you type python programs and the interpreter prints the result  1.2 what is a program 3 $ python python 2.4.1  # 1  apr 29 2005  00  28  56  type help  copyright  credits or license for more information > > > print 1 + 1 2 the first line of this example is the command that starts the python interpreter the next two lines are messages from the interpreter the third line starts with > > >  which is the prompt the interpreter uses to indicate that it is ready we typed print 1 + 1  and the interpreter replied 2 alternatively  you can write a program in a file and use the interpreter to execute the contents of the file such a file is called a script for example  we used a text editor to create a file named latoya.py with the following contents  print 1 + 1 by convention  files that contain python programs have names that end with .py to execute the program  we have to tell the interpreter the name of the script  $ python latoya.py 2 in other development environments  the details of executing programs may differ also  most programs are more interesting than this one most of the examples in this book are executed on the command line working on the command line is convenient for program development and testing  because you can type programs and execute them immediately once you have a working program  you should store it in a script so you can execute or modify it in the future 1.2 what is a program a program is a sequence of instructions that specifies how to perform a computation the computation might be something mathematical  such as solving a system of equations or finding the roots of a polynomial  but it can also be a symbolic computation  such as searching and replacing text in a document or  strangely enough  compiling a program the details look different in different languages  but a few basic instructions appear in just about every language  4 the way of the program input  get data from the keyboard  a file  or some other device output  display data on the screen or send data to a file or other device math  perform basic mathematical operations like addition and multiplication conditional execution  check for certain conditions and execute the appropriate sequence of statements repetition  perform some action repeatedly  usually with some variation believe it or not  that s pretty much all there is to it every program you ve ever used  no matter how complicated  is made up of instructions that look more or less like these thus  we can describe programming as the process of breaking a large  complex task into smaller and smaller subtasks until the subtasks are simple enough to be performed with one of these basic instructions that may be a little vague  but we will come back to this topic later when we talk about algorithms 1.3 what is debugging programming is a complex process  and because it is done by human beings  it often leads to errors for whimsical reasons  programming errors are called bugs and the process of tracking them down and correcting them is called debugging three kinds of errors can occur in a program  syntax errors  runtime errors  and semantic errors it is useful to distinguish between them in order to track them down more quickly 1.3.1 syntax errors python can only execute a program if the program is syntactically correct ; otherwise  the process fails and returns an error message syntax refers to the structure of a program and the rules about that structure for example  in english  a sentence must begin with a capital letter and end with a period this sentence contains a syntax error so does this one for most readers  a few syntax errors are not a significant problem  which is why we can read the poetry of e e cummings without spewing error messages python is not so forgiving if there is a single syntax error anywhere in your program  python will print an error message and quit  and you will not be able to run your program during the first few weeks of your programming career  you will probably spend a lot of time tracking down syntax errors as you gain experience  though  you will make fewer errors and find them faster 1.3 what is debugging 5 1.3.2 runtime errors the second type of error is a runtime error  so called because the error does not appear until you run the program these errors are also called exceptions because they usually indicate that something exceptional  and bad  has happened runtime errors are rare in the simple programs you will see in the first few chapters  so it might be a while before you encounter one 1.3.3 semantic errors the third type of error is the semantic error if there is a semantic error in your program  it will run successfully  in the sense that the computer will not generate any error messages  but it will not do the right thing it will do something else specifically  it will do what you told it to do the problem is that the program you wrote is not the program you wanted to write the meaning of the program  its semantics  is wrong identifying semantic errors can be tricky because it requires you to work backward by looking at the output of the program and trying to figure out what it is doing 1.3.4 experimental debugging one of the most important skills you will acquire is debugging although it can be frustrating  debugging is one of the most intellectually rich  challenging  and interesting parts of programming in some ways  debugging is like detective work you are confronted with clues  and you have to infer the processes and events that led to the results you see debugging is also like an experimental science once you have an idea what is going wrong  you modify your program and try again if your hypothesis was correct  then you can predict the result of the modification  and you take a step closer to a working program if your hypothesis was wrong  you have to come up with a new one as sherlock holmes pointed out  when you have eliminated the impossible  whatever remains  however improbable  must be the truth  a conan doyle  the sign of four  for some people  programming and debugging are the same thing that is  programming is the process of gradually debugging a program until it does what you want the idea is that you should start with a program that does something and make small modifications  debugging them as you go  so that you always have a working program 6 the way of the program for example  linux is an operating system that contains thousands of lines of code  but it started out as a simple program linus torvalds used to explore the intel 80386 chip according to larry greenfield  one of linus s earlier projects was a program that would switch between printing aaaa and bbbb this later evolved to linux  the linux users guide beta version 1  later chapters will make more suggestions about debugging and other programming practices 1.4 formal and natural languages natural languages are the languages that people speak  such as english  spanish  and french they were not designed by people  although people try to impose some order on them  ; they evolved naturally formal languages are languages that are designed by people for specific applications for example  the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols chemists use a formal language to represent the chemical structure of molecules and most importantly  programming languages are formal languages that have been designed to express computations formal languages tend to have strict rules about syntax for example  3 + 3 = 6 is a syntactically correct mathematical statement  but 3 = + 6 $ is not h2o is a syntactically correct chemical name  but 2zz is not syntax rules come in two flavors  pertaining to tokens and structure tokens are the basic elements of the language  such as words  numbers  and chemical elements one of the problems with 3 = + 6 $ is that $ is not a legal token in mathematics  at least as far as we know   similarly  2zz is not legal because there is no element with the abbreviation zz the second type of syntax error pertains to the structure of a statement that is  the way the tokens are arranged the statement 3 = + 6 $ is structurally illegal because you can t place a plus sign immediately after an equal sign similarly  molecular formulas have to have subscripts after the element name  not before as an exercise  create what appears to be a well-structured english sentence with unrecognizable tokens in it then write another sentence with all valid tokens but with invalid structure 1.4 formal and natural languages 7 when you read a sentence in english or a statement in a formal language  you have to figure out what the structure of the sentence is  although in a natural language you do this subconsciously   this process is called parsing for example  when you hear the sentence  the other shoe fell  you understand that the other shoe is the subject and fell is the predicate once you have parsed a sentence  you can figure out what it means  or the semantics of the sentence assuming that you know what a shoe is and what it means to fall  you will understand the general implication of this sentence although formal and natural languages have many features in common tokens  structure  syntax  and semantics there are many differences  ambiguity  natural languages are full of ambiguity  which people deal with by using contextual clues and other information formal languages are designed to be nearly or completely unambiguous  which means that any statement has exactly one meaning  regardless of context redundancy  in order to make up for ambiguity and reduce misunderstandings  natural languages employ lots of redundancy as a result  they are often verbose formal languages are less redundant and more concise literalness  natural languages are full of idiom and metaphor if i say  the other shoe fell  there is probably no shoe and nothing falling formal languages mean exactly what they say people who grow up speaking a natural language everyone often have a hard time adjusting to formal languages in some ways  the difference between formal and natural language is like the difference between poetry and prose  but more so  poetry  words are used for their sounds as well as for their meaning  and the whole poem together creates an effect or emotional response ambiguity is not only common but often deliberate prose  the literal meaning of words is more important  and the structure contributes more meaning prose is more amenable to analysis than poetry but still often ambiguous programs  the meaning of a computer program is unambiguous and literal  and can be understood entirely by analysis of the tokens and structure here are some suggestions for reading programs  and other formal languages   first  remember that formal languages are much more dense than natural languages  so it takes longer to read them also  the structure is very important  so 8 the way of the program it is usually not a good idea to read from top to bottom  left to right instead  learn to parse the program in your head  identifying the tokens and interpreting the structure finally  the details matter little things like spelling errors and bad punctuation  which you can get away with in natural languages  can make a big difference in a formal language 1.5 the first program traditionally  the first program written in a new language is called hello  world ! because all it does is display the words  hello  world ! in python  it looks like this  print hello  world ! this is an example of a print statement  which doesn t actually print anything on paper it displays a value on the screen in this case  the result is the words hello  world ! the quotation marks in the program mark the beginning and end of the value ; they don t appear in the result some people judge the quality of a programming language by the simplicity of the hello  world ! program by this standard  python does about as well as possible 1.6 glossary problem solving  the process of formulating a problem  finding a solution  and expressing the solution high-level language  a programming language like python that is designed to be easy for humans to read and write low-level language  a programming language that is designed to be easy for a computer to execute ; also called machine language or assembly language portability  a property of a program that can run on more than one kind of computer interpret  to execute a program in a high-level language by translating it one line at a time 1.6 glossary 9 compile  to translate a program written in a high-level language into a lowlevel language all at once  in preparation for later execution source code  a program in a high-level language before being compiled object code  the output of the compiler after it translates the program executable  another name for object code that is ready to be executed script  a program stored in a file  usually one that will be interpreted   program  a set of instructions that specifies a computation algorithm  a general process for solving a category of problems bug  an error in a program debugging  the process of finding and removing any of the three kinds of programming errors syntax  the structure of a program syntax error  an error in a program that makes it impossible to parse  and therefore impossible to interpret   runtime error  an error that does not occur until the program has started to execute but that prevents the program from continuing exception  another name for a runtime error semantic error  an error in a program that makes it do something other than what the programmer intended semantics  the meaning of a program natural language  any one of the languages that people speak that evolved naturally formal language  any one of the languages that people have designed for specific purposes  such as representing mathematical ideas or computer programs ; all programming languages are formal languages token  one of the basic elements of the syntactic structure of a program  analogous to a word in a natural language parse  to examine a program and analyze the syntactic structure print statement  an instruction that causes the python interpreter to display a value on the screen 10 the way of the program chapter 2 variables  expressions and statements 2.1 values and types a value is one of the fundamental things like a letter or a number that a program manipulates the values we have seen so far are 2  the result when we added 1 + 1   and hello  world !  these values belong to different types  2 is an integer  and hello  world ! is a string  so-called because it contains a string of letters you  and the interpreter  can identify strings because they are enclosed in quotation marks the print statement also works for integers > > > print 4 4 if you are not sure what type a value has  the interpreter can tell you > > > type  hello  world !  > > > type  17  not surprisingly  strings belong to the type str and integers belong to the type int less obviously  numbers with a decimal point belong to a type called float  because these numbers are represented in a format called floating-point 12 variables  expressions and statements > > > type  3.2  what about values like 17 and 3.2 they look like numbers  but they are in quotation marks like strings > > > type  17  > > > type  3.2  they re strings when you type a large integer  you might be tempted to use commas between groups of three digits  as in 1,000,000 this is not a legal integer in python  but it is a legal expression  > > > print 1,000,000 1 0 0 well  that s not what we expected at all ! python interprets 1,000,000 as a comma-separated list of three integers  which it prints consecutively this is the first example we have seen of a semantic error  the code runs without producing an error message  but it doesn t do the right thing 2.2 variables one of the most powerful features of a programming language is the ability to manipulate variables a variable is a name that refers to a value the assignment statement creates new variables and gives them values  > > > message = what s up  doc > > > n = 17 > > > pi = 3.14159 this example makes three assignments the first assigns the string what s up  doc to a new variable named message the second gives the integer 17 to n  and the third gives the floating-point number 3.14159 to pi a common way to represent variables on paper is to write the name with an arrow pointing to the variable s value this kind of figure is called a state diagram because it shows what state each of the variables is in  think of it as the variable s state of mind   this diagram shows the result of the assignment statements  2.3 variable names and keywords 13 message n pi what s up  doc 17 3.14159 the print statement also works with variables > > > print message what s up  doc > > > print n 17 > > > print pi 3.14159 in each case the result is the value of the variable variables also have types ; again  we can ask the interpreter what they are > > > type  message  > > > type  n  > > > type  pi  the type of a variable is the type of the value it refers to 2.3 variable names and keywords programmers generally choose names for their variables that are meaningful they document what the variable is used for variable names can be arbitrarily long they can contain both letters and numbers  but they have to begin with a letter although it is legal to use uppercase letters  by convention we don t if you do  remember that case matters bruce and bruce are different variables the underscore character   can appear in a name it is often used in names with multiple words  such as my name or price of tea in china if you give a variable an illegal name  you get a syntax error  14 variables  expressions and statements > > > 76trombones = big parade syntaxerror  invalid syntax > > > more $ = 1000000 syntaxerror  invalid syntax > > > class = computer science 101 syntaxerror  invalid syntax 76trombones is illegal because it does not begin with a letter more $ is illegal because it contains an illegal character  the dollar sign but what s wrong with class it turns out that class is one of the python keywords keywords define the language s rules and structure  and they can not be used as variable names python has twenty-nine keywords  and def exec if not return assert del finally import or try break elif for in pass while class else from is print yield continue except global lambda raise you might want to keep this list handy if the interpreter complains about one of your variable names and you don t know why  see if it is on this list 2.4 statements a statement is an instruction that the python interpreter can execute we have seen two kinds of statements  print and assignment when you type a statement on the command line  python executes it and displays the result  if there is one the result of a print statement is a value assignment statements don t produce a result a script usually contains a sequence of statements if there is more than one statement  the results appear one at a time as the statements execute for example  the script print 1 x = 2 print x produces the output 2.5 evaluating expressions 15 1 2 again  the assignment statement produces no output 2.5 evaluating expressions an expression is a combination of values  variables  and operators if you type an expression on the command line  the interpreter evaluates it and displays the result  > > > 1 + 1 2 although expressions contain values  variables  and operators  not every expression contains all of these elements a value all by itself is considered an expression  and so is a variable > > > 17 17 > > > x 2 confusingly  evaluating an expression is not quite the same thing as printing a value > > > message = what s up  doc > > > message what s up  doc > > > print message what s up  doc when the python interpreter displays the value of an expression  it uses the same format you would use to enter a value in the case of strings  that means that it includes the quotation marks but if you use a print statement  python displays the contents of the string without the quotation marks in a script  an expression all by itself is a legal statement  but it doesn t do anything the script 17 3.2 hello  world ! 1 + 1 produces no output at all how would you change the script to display the values of these four expressions 16 variables  expressions and statements 2.6 operators and operands operators are special symbols that represent computations like addition and multiplication the values the operator uses are called operands the following are all legal python expressions whose meaning is more or less clear  20 + 32 hour-1 hour 60 + minute minute/60 5 2  5 + 9   15-7  the symbols +    and /  and the use of parenthesis for grouping  mean in python what they mean in mathematics the asterisk   is the symbol for multiplication  and is the symbol for exponentiation when a variable name appears in the place of an operand  it is replaced with its value before the operation is performed addition  subtraction  multiplication  and exponentiation all do what you expect  but you might be surprised by division the following operation has an unexpected result  > > > minute = 59 > > > minute/60 0 the value of minute is 59  and in conventional arithmetic 59 divided by 60 is 0.98333  not 0 the reason for the discrepancy is that python is performing integer division when both of the operands are integers  the result must also be an integer  and by convention  integer division always rounds down  even in cases like this where the next integer is very close a possible solution to this problem is to calculate a percentage rather than a fraction  > > > minute 100/60 98 again the result is rounded down  but at least now the answer is approximately correct another alternative is to use floating-point division  which we get to in chapter 3 2.7 order of operations when more than one operator appears in an expression  the order of evaluation depends on the rules of precedence python follows the same precedence rules for its mathematical operators that mathematics does the acronym pemdas is a useful way to remember the order of operations  2.8 operations on strings 17 parentheses have the highest precedence and can be used to force an expression to evaluate in the order you want since expressions in parentheses are evaluated first  2  3-1  is 4  and  1 + 1   5-2  is 8 you can also use parentheses to make an expression easier to read  as in  minute 100  / 60  even though it doesn t change the result exponentiation has the next highest precedence  so 2 1 + 1 is 3 and not 4  and 3 1 3 is 3 and not 27 multiplication and division have the same precedence  which is higher than addition and subtraction  which also have the same precedence so 2 3-1 yields 5 rather than 4  and 2/3-1 is -1  not 1  remember that in integer division  2/3 = 0   operators with the same precedence are evaluated from left to right so in the expression minute 100/60  the multiplication happens first  yielding 5900/60  which in turn yields 98 if the operations had been evaluated from right to left  the result would have been 59 1  which is 59  which is wrong 2.8 operations on strings in general  you can not perform mathematical operations on strings  even if the strings look like numbers the following are illegal  assuming that message has type string   message-1 hello/123 message hello 15 + 2 interestingly  the + operator does work with strings  although it does not do exactly what you might expect for strings  the + operator represents concatenation  which means joining the two operands by linking them end-to-end for example  fruit = banana bakedgood = nut bread print fruit + bakedgood the output of this program is banana nut bread the space before the word nut is part of the string  and is necessary to produce the space between the concatenated strings the operator also works on strings ; it performs repetition for example  fun 3 is funfunfun one of the operands has to be a string ; the other has to be an integer 18 variables  expressions and statements on one hand  this interpretation of + and makes sense by analogy with addition and multiplication just as 4 3 is equivalent to 4 + 4 + 4  we expect fun 3 to be the same as fun + fun + fun  and it is on the other hand  there is a significant way in which string concatenation and repetition are different from integer addition and multiplication can you think of a property that addition and multiplication have that string concatenation and repetition do not 2.9 composition so far  we have looked at the elements of a program variables  expressions  and statements in isolation  without talking about how to combine them one of the most useful features of programming languages is their ability to take small building blocks and compose them for example  we know how to add numbers and we know how to print ; it turns out we can do both at the same time  > > > print 17 + 3 20 in reality  the addition has to happen before the printing  so the actions aren t actually happening at the same time the point is that any expression involving numbers  strings  and variables can be used inside a print statement you ve already seen an example of this  print number of minutes since midnight   hour 60 + minute you can also put arbitrary expressions on the right-hand side of an assignment statement  percentage =  minute 100  / 60 this ability may not seem impressive now  but you will see other examples where composition makes it possible to express complex computations neatly and concisely warning  there are limits on where you can use certain expressions for example  the left-hand side of an assignment statement has to be a variable name  not an expression so  the following is illegal  minute + 1 = hour 2.10 comments as programs get bigger and more complicated  they get more difficult to read formal languages are dense  and it is often difficult to look at a piece of code and figure out what it is doing  or why 2.11 glossary 19 for this reason  it is a good idea to add notes to your programs to explain in natural language what the program is doing these notes are called comments  and they are marked with the # symbol  # compute the percentage of the hour that has elapsed percentage =  minute 100  / 60 in this case  the comment appears on a line by itself you can also put comments at the end of a line  percentage =  minute 100  / 60 # caution  integer division everything from the # to the end of the line is ignored it has no effect on the program the message is intended for the programmer or for future programmers who might use this code in this case  it reminds the reader about the ever-surprising behavior of integer division this sort of comment is less necessary if you use the integer division operation  // it has the same effect as the division operator1  but it signals that the effect is deliberate percentage =  minute 100  // 60 the integer division operator is like a comment that says  i know this is integer division  and i like it that way ! 2.11 glossary value  a number or string  or other thing to be named later  that can be stored in a variable or computed in an expression type  a set of values the type of a value determines how it can be used in expressions so far  the types you have seen are integers  type int   floating-point numbers  type float   and strings  type string   floating-point  a format for representing numbers with fractional parts variable  a name that refers to a value statement  a section of code that represents a command or action so far  the statements you have seen are assignments and print statements assignment  a statement that assigns a value to a variable 1for now the behavior of the division operator may change in future versions of python 20 variables  expressions and statements state diagram  a graphical representation of a set of variables and the values to which they refer keyword  a reserved word that is used by the compiler to parse a program ; you can not use keywords like if  def  and while as variable names operator  a special symbol that represents a simple computation like addition  multiplication  or string concatenation operand  one of the values on which an operator operates expression  a combination of variables  operators  and values that represents a single result value evaluate  to simplify an expression by performing the operations in order to yield a single value integer division  an operation that divides one integer by another and yields an integer integer division yields only the whole number of times that the numerator is divisible by the denominator and discards any remainder rules of precedence  the set of rules governing the order in which expressions involving multiple operators and operands are evaluated concatenate  to join two operands end-to-end composition  the ability to combine simple expressions and statements into compound statements and expressions in order to represent complex computations concisely comment  information in a program that is meant for other programmers  or anyone reading the source code  and has no effect on the execution of the program chapter 3 functions 3.1 function calls you have already seen one example of a function call  > > > type  32  the name of the function is type  and it displays the type of a value or variable the value or variable  which is called the argument of the function  has to be enclosed in parentheses it is common to say that a function takes an argument and returns a result the result is called the return value instead of printing the return value  we could assign it to a variable  > > > betty = type  32  > > > print betty as another example  the id function takes a value or a variable and returns an integer that acts as a unique identifier for the value  > > > id  3  134882108 > > > betty = 3 > > > id  betty  134882108 every value has an id  which is a unique number related to where it is stored in the memory of the computer the id of a variable is the id of the value to which it refers 22 functions 3.2 type conversion python provides a collection of built-in functions that convert values from one type to another the int function takes any value and converts it to an integer  if possible  or complains otherwise  > > > int  32  32 > > > int  hello  valueerror  invalid literal for int    hello int can also convert floating-point values to integers  but remember that it truncates the fractional part  > > > int  3.99999  3 > > > int  -2.3  -2 the float function converts integers and strings to floating-point numbers  > > > float  32  32.0 > > > float  3.14159  3.14159 finally  the str function converts to type string  > > > str  32  32 > > > str  3.14149  3.14149 it may seem odd that python distinguishes the integer value 1 from the floatingpoint value 1.0 they may represent the same number  but they belong to different types the reason is that they are represented differently inside the computer 3.3 type coercion now that we can convert between types  we have another way to deal with integer division returning to the example from the previous chapter  suppose we want to calculate the fraction of an hour that has elapsed the most obvious expression  minute / 60  does integer arithmetic  so the result is always 0  even at 59 minutes past the hour 3.4 math functions 23 one solution is to convert minute to floating-point and do floating-point division  > > > minute = 59 > > > float  minute  / 60 0.983333333333 alternatively  we can take advantage of the rules for automatic type conversion  which is called type coercion for the mathematical operators  if either operand is a float  the other is automatically converted to a float  > > > minute = 59 > > > minute / 60.0 0.983333333333 by making the denominator a float  we force python to do floating-point division 3.4 math functions in mathematics  you have probably seen functions like sin and log  and you have learned to evaluate expressions like sin  pi/2  and log  1/x   first  you evaluate the expression in parentheses  the argument   for example  pi/2 is approximately 1.571  and 1/x is 0.1  if x happens to be 10.0   then  you evaluate the function itself  either by looking it up in a table or by performing various computations the sin of 1.571 is 1  and the log of 0.1 is -1  assuming that log indicates the logarithm base 10   this process can be applied repeatedly to evaluate more complicated expressions like log  1/sin  pi/2    first  you evaluate the argument of the innermost function  then evaluate the function  and so on python has a math module that provides most of the familiar mathematical functions a module is a file that contains a collection of related functions grouped together before we can use the functions from a module  we have to import them  > > > import math to call one of the functions  we have to specify the name of the module and the name of the function  separated by a dot  also known as a period this format is called dot notation 24 functions > > > decibel = math.log10  17.0  > > > angle = 1.5 > > > height = math.sin  angle  the first statement sets decibel to the logarithm of 17  base 10 there is also a function called log that takes logarithm base e the third statement finds the sine of the value of the variable angle sin and the other trigonometric functions  cos  tan  etc  take arguments in radians to convert from degrees to radians  divide by 360 and multiply by 2 pi for example  to find the sine of 45 degrees  first calculate the angle in radians and then take the sine  > > > degrees = 45 > > > angle = degrees 2 math.pi / 360.0 > > > math.sin  angle  0.707106781187 the constant pi is also part of the math module if you know your geometry  you can check the previous result by comparing it to the square root of two divided by two  > > > math.sqrt  2  / 2.0 0.707106781187 3.5 composition just as with mathematical functions  python functions can be composed  meaning that you use one expression as part of another for example  you can use any expression as an argument to a function  > > > x = math.cos  angle + math.pi/2  this statement takes the value of pi  divides it by 2  and adds the result to the value of angle the sum is then passed as an argument to the cos function you can also take the result of one function and pass it as an argument to another  > > > x = math.exp  math.log  10.0   this statement finds the log base e of 10 and then raises e to that power the result gets assigned to x 3.6 adding new functions 25 3.6 adding new functions so far  we have only been using the functions that come with python  but it is also possible to add new functions creating new functions to solve your particular problems is one of the most useful things about a general-purpose programming language in the context of programming  a function is a named sequence of statements that performs a desired operation this operation is specified in a function definition the functions we have been using so far have been defined for us  and these definitions have been hidden this is a good thing  because it allows us to use the functions without worrying about the details of their definitions the syntax for a function definition is  def name  list of parameters   statements you can make up any names you want for the functions you create  except that you can t use a name that is a python keyword the list of parameters specifies what information  if any  you have to provide in order to use the new function there can be any number of statements inside the function  but they have to be indented from the left margin in the examples in this book  we will use an indentation of two spaces the first couple of functions we are going to write have no parameters  so the syntax looks like this  def newline    print this function is named newline the empty parentheses indicate that it has no parameters it contains only a single statement  which outputs a newline character  that s what happens when you use a print command without any arguments  the syntax for calling the new function is the same as the syntax for built-in functions  print first line newline   print second line the output of this program is  26 functions first line second line notice the extra space between the two lines what if we wanted more space between the lines we could call the same function repeatedly  print first line newline   newline   newline   print second line or we could write a new function named threelines that prints three new lines  def threelines    newline   newline   newline   print first line threelines   print second line this function contains three statements  all of which are indented by two spaces since the next statement is not indented  python knows that it is not part of the function you should notice a few things about this program  1 you can call the same procedure repeatedly in fact  it is quite common and useful to do so 2 you can have one function call another function ; in this case threelines calls newline so far  it may not be clear why it is worth the trouble to create all of these new functions actually  there are a lot of reasons  but this example demonstrates two  creating a new function gives you an opportunity to name a group of statements functions can simplify a program by hiding a complex computation behind a single command and by using english words in place of arcane code 3.7 definitions and use 27 creating a new function can make a program smaller by eliminating repetitive code for example  a short way to print nine consecutive new lines is to call threelines three times as an exercise  write a function called ninelines that uses threelines to print nine blank lines how would you print twentyseven new lines 3.7 definitions and use pulling together the code fragments from section 3.6  the whole program looks like this  def newline    print def threelines    newline   newline   newline   print first line threelines   print second line this program contains two function definitions  newline and threelines function definitions get executed just like other statements  but the effect is to create the new function the statements inside the function do not get executed until the function is called  and the function definition generates no output as you might expect  you have to create a function before you can execute it in other words  the function definition has to be executed before the first time it is called as an exercise  move the last three lines of this program to the top  so the function calls appear before the definitions run the program and see what error message you get as another exercise  start with the working version of the program and move the definition of newline after the definition of threelines what happens when you run this program 28 functions 3.8 flow of execution in order to ensure that a function is defined before its first use  you have to know the order in which statements are executed  which is called the flow of execution execution always begins at the first statement of the program statements are executed one at a time  in order from top to bottom function definitions do not alter the flow of execution of the program  but remember that statements inside the function are not executed until the function is called although it is not common  you can define one function inside another in this case  the inner definition isn t executed until the outer function is called function calls are like a detour in the flow of execution instead of going to the next statement  the flow jumps to the first line of the called function  executes all the statements there  and then comes back to pick up where it left off that sounds simple enough  until you remember that one function can call another while in the middle of one function  the program might have to execute the statements in another function but while executing that new function  the program might have to execute yet another function ! fortunately  python is adept at keeping track of where it is  so each time a function completes  the program picks up where it left off in the function that called it when it gets to the end of the program  it terminates what s the moral of this sordid tale when you read a program  don t read from top to bottom instead  follow the flow of execution 3.9 parameters and arguments some of the built-in functions you have used require arguments  the values that control how the function does its job for example  if you want to find the sine of a number  you have to indicate what the number is thus  sin takes a numeric value as an argument some functions take more than one argument for example  pow takes two arguments  the base and the exponent inside the function  the values that are passed get assigned to variables called parameters here is an example of a user-defined function that has a parameter  def printtwice  bruce   print bruce  bruce 3.9 parameters and arguments 29 this function takes a single argument and assigns it to a parameter named bruce the value of the parameter  at this point we have no idea what it will be  is printed twice  followed by a newline the name bruce was chosen to suggest that the name you give a parameter is up to you  but in general  you want to choose something more illustrative than bruce the function printtwice works for any type that can be printed  > > > printtwice  spam  spam spam > > > printtwice  5  5 5 > > > printtwice  3.14159  3.14159 3.14159 in the first function call  the argument is a string in the second  it s an integer in the third  it s a float the same rules of composition that apply to built-in functions also apply to user-defined functions  so we can use any kind of expression as an argument for printtwice  > > > printtwice  spam 4  spamspamspamspam spamspamspamspam > > > printtwice  math.cos  math.pi   -1.0 -1.0 as usual  the expression is evaluated before the function is run  so printtwice prints spamspamspamspam spamspamspamspam instead of spam 4 spam 4 as an exercise  write a call to printtwice that does print spam 4 spam 4 hint  strings can be enclosed in either single or double quotes  and the type of quote not used to enclose the string can be used inside it as part of the string we can also use a variable as an argument  > > > michael = eric  the half a bee > > > printtwice  michael  eric  the half a bee eric  the half a bee notice something very important here the name of the variable we pass as an argument  michael  has nothing to do with the name of the parameter  bruce   it doesn t matter what the value was called back home  in the caller  ; here in printtwice  we call everybody bruce 30 functions 3.10 variables and parameters are local when you create a local variable inside a function  it only exists inside the function  and you can not use it outside for example  def cattwice  part1  part2   cat = part1 + part2 printtwice  cat  this function takes two arguments  concatenates them  and then prints the result twice we can call the function with two strings  > > > chant1 = pie jesu domine  > > > chant2 = dona eis requiem > > > cattwice  chant1  chant2  pie jesu domine  dona eis requiem pie jesu domine  dona eis requiem when cattwice terminates  the variable cat is destroyed if we try to print it  we get an error  > > > print cat nameerror  cat parameters are also local for example  outside the function printtwice  there is no such thing as bruce if you try to use it  python will complain 3.11 stack diagrams to keep track of which variables can be used where  it is sometimes useful to draw a stack diagram like state diagrams  stack diagrams show the value of each variable  but they also show the function to which each variable belongs each function is represented by a frame a frame is a box with the name of a function beside it and the parameters and variables of the function inside it the stack diagram for the previous example looks like this  3.11 stack diagrams 31 cattwice chant1 chant2 pie jesu domine  dona eis requiem __main__ printtwice part1 part2 cat pie jesu domine  pie jesu domine  dona eis requiem dona eis requiem bruce pie jesu domine  dona eis requiem the order of the stack shows the flow of execution printtwice was called by cattwice  and cattwice was called by main  which is a special name for the topmost function when you create a variable outside of any function  it belongs to main  each parameter refers to the same value as its corresponding argument so  part1 has the same value as chant1  part2 has the same value as chant2  and bruce has the same value as cat if an error occurs during a function call  python prints the name of the function  and the name of the function that called it  and the name of the function that called that  all the way back to main  for example  if we try to access cat from within printtwice  we get a nameerror  traceback  innermost last   file test.py  line 13  in __main__ cattwice  chant1  chant2  file test.py  line 5  in cattwice printtwice  cat  file test.py  line 9  in printtwice print cat nameerror  cat this list of functions is called a traceback it tells you what program file the error occurred in  and what line  and what functions were executing at the time it also shows the line of code that caused the error notice the similarity between the traceback and the stack diagram it s not a coincidence 32 functions 3.12 functions with results you might have noticed by now that some of the functions we are using  such as the math functions  yield results other functions  like newline  perform an action but don t return a value that raises some questions  1 what happens if you call a function and you don t do anything with the result  i.e  you don t assign it to a variable or use it as part of a larger expression  2 what happens if you use a function without a result as part of an expression  such as newline   + 7 3 can you write functions that yield results  or are you stuck with simple function like newline and printtwice the answer to the last question is that you can write functions that yield results  and we ll do it in chapter 5 as an exercise  answer the other two questions by trying them out when you have a question about what is legal or illegal in python  a good way to find out is to ask the interpreter 3.13 glossary function call  a statement that executes a function it consists of the name of the function followed by a list of arguments enclosed in parentheses argument  a value provided to a function when the function is called this value is assigned to the corresponding parameter in the function return value  the result of a function if a function call is used as an expression  the return value is the value of the expression type conversion  an explicit statement that takes a value of one type and computes a corresponding value of another type type coercion  a type conversion that happens automatically according to python s coercion rules module  a file that contains a collection of related functions and classes dot notation  the syntax for calling a function in another module  specifying the module name followed by a dot  period  and the function name 3.13 glossary 33 function  a named sequence of statements that performs some useful operation functions may or may not take arguments and may or may not produce a result function definition  a statement that creates a new function  specifying its name  parameters  and the statements it executes flow of execution  the order in which statements are executed during a program run parameter  a name used inside a function to refer to the value passed as an argument local variable  a variable defined inside a function a local variable can only be used inside its function stack diagram  a graphical representation of a stack of functions  their variables  and the values to which they refer frame  a box in a stack diagram that represents a function call it contains the local variables and parameters of the function traceback  a list of the functions that are executing  printed when a runtime error occurs 34 functions chapter 4 conditionals and recursion 4.1 the modulus operator the modulus operator works on integers  and integer expressions  and yields the remainder when the first operand is divided by the second in python  the modulus operator is a percent sign  %   the syntax is the same as for other operators  > > > quotient = 7 / 3 > > > print quotient 2 > > > remainder = 7 % 3 > > > print remainder 1 so 7 divided by 3 is 2 with 1 left over the modulus operator turns out to be surprisingly useful for example  you can check whether one number is divisible by another if x % y is zero  then x is divisible by y also  you can extract the right-most digit or digits from a number for example  x % 10 yields the right-most digit of x  in base 10   similarly x % 100 yields the last two digits 4.2 boolean expressions a boolean expression is an expression that is either true or false one way to write a boolean expression is to use the operator = =  which compares two values and produces a boolean value  36 conditionals and recursion > > > 5 = = 5 true > > > 5 = = 6 false in the first statement  the two operands are equal  so the value of the expression is true ; in the second statement  5 is not equal to 6  so we get false true and false are special values that are built into python the = = operator is one of the comparison operators ; the others are  x ! = y # x is not equal to y x > y # x is greater than y x < y # x is less than y x > = y # x is greater than or equal to y x < = y # x is less than or equal to y although these operations are probably familiar to you  the python symbols are different from the mathematical symbols a common error is to use a single equal sign  =  instead of a double equal sign  = =   remember that = is an assignment operator and = = is a comparison operator also  there is no such thing as = < or = >  4.3 logical operators there are three logical operators  and  or  and not the semantics  meaning  of these operators is similar to their meaning in english for example  x > 0 and x < 10 is true only if x is greater than 0 and less than 10 n % 2 = = 0 or n % 3 = = 0 is true if either of the conditions is true  that is  if the number is divisible by 2 or 3 finally  the not operator negates a boolean expression  so not  x > y  is true if  x > y  is false  that is  if x is less than or equal to y strictly speaking  the operands of the logical operators should be boolean expressions  but python is not very strict any nonzero number is interpreted as true > > > x = 5 > > > x and 1 1 > > > y = 0 > > > y and 1 0 4.4 conditional execution 37 in general  this sort of thing is not considered good style if you want to compare a value to zero  you should do it explicitly 4.4 conditional execution in order to write useful programs  we almost always need the ability to check conditions and change the behavior of the program accordingly conditional statements give us this ability the simplest form is the if statement  if x > 0  print x is positive the boolean expression after the if statement is called the condition if it is true  then the indented statement gets executed if not  nothing happens like other compound statements  the if statement is made up of a header and a block of statements  header  first statement  last statement the header begins on a new line and ends with a colon     the indented statements that follow are called a block the first unindented statement marks the end of the block a statement block inside a compound statement is called the body of the statement there is no limit on the number of statements that can appear in the body of an if statement  but there has to be at least one occasionally  it is useful to have a body with no statements  usually as a place keeper for code you haven t written yet   in that case  you can use the pass statement  which does nothing 4.5 alternative execution a second form of the if statement is alternative execution  in which there are two possibilities and the condition determines which one gets executed the syntax looks like this  if x % 2 = = 0  print x  is even else  print x  is odd 38 conditionals and recursion if the remainder when x is divided by 2 is 0  then we know that x is even  and the program displays a message to that effect if the condition is false  the second set of statements is executed since the condition must be true or false  exactly one of the alternatives will be executed the alternatives are called branches  because they are branches in the flow of execution as an aside  if you need to check the parity  evenness or oddness  of numbers often  you might wrap this code in a function  def printparity  x   if x % 2 = = 0  print x  is even else  print x  is odd for any value of x  printparity displays an appropriate message when you call it  you can provide any integer expression as an argument > > > printparity  17  17 is odd > > > y = 17 > > > printparity  y + 1  18 is even 4.6 chained conditionals sometimes there are more than two possibilities and we need more than two branches one way to express a computation like that is a chained conditional  if x < y  print x  is less than  y elif x > y  print x  is greater than  y else  print x  and  y  are equal elif is an abbreviation of else if again  exactly one branch will be executed there is no limit of the number of elif statements  but the last branch has to be an else statement  if choice = = a  functiona   elif choice = = b  functionb   elif choice = = c  functionc   4.7 nested conditionals 39 else  print invalid choice each condition is checked in order if the first is false  the next is checked  and so on if one of them is true  the corresponding branch executes  and the statement ends even if more than one condition is true  only the first true branch executes as an exercise  wrap these examples in functions called compare  x  y  and dispatch  choice   4.7 nested conditionals one conditional can also be nested within another we could have written the trichotomy example as follows  if x = = y  print x  and  y  are equal else  if x < y  print x  is less than  y else  print x  is greater than  y the outer conditional contains two branches the first branch contains a simple output statement the second branch contains another if statement  which has two branches of its own those two branches are both output statements  although they could have been conditional statements as well although the indentation of the statements makes the structure apparent  nested conditionals become difficult to read very quickly in general  it is a good idea to avoid them when you can logical operators often provide a way to simplify nested conditional statements for example  we can rewrite the following code using a single conditional  if 0 < x  if x < 10  print x is a positive single digit the print statement is executed only if we make it past both the conditionals  so we can use the and operator  if 0 < x and x < 10  print x is a positive single digit 40 conditionals and recursion these kinds of conditions are common  so python provides an alternative syntax that is similar to mathematical notation  if 0 < x < 10  print x is a positive single digit this condition is semantically the same as the compound boolean expression and the nested conditional 4.8 the return statement the return statement allows you to terminate the execution of a function before you reach the end one reason to use it is if you detect an error condition  import math def printlogarithm  x   if x < = 0  print positive numbers only  please return result = math.log  x  print the log of x is  result the function printlogarithm has a parameter named x the first thing it does is check whether x is less than or equal to 0  in which case it displays an error message and then uses return to exit the function the flow of execution immediately returns to the caller  and the remaining lines of the function are not executed remember that to use a function from the math module  you have to import it 4.9 recursion we mentioned that it is legal for one function to call another  and you have seen several examples of that we neglected to mention that it is also legal for a function to call itself it may not be obvious why that is a good thing  but it turns out to be one of the most magical and interesting things a program can do for example  look at the following function  def countdown  n   if n = = 0  4.9 recursion 41 print blastoff ! else  print n countdown  n-1  countdown expects the parameter  n  to be a positive integer if n is 0  it outputs the word  blastoff ! otherwise  it outputs n and then calls a function named countdown itself passing n-1 as an argument what happens if we call this function like this  > > > countdown  3  the execution of countdown begins with n = 3  and since n is not 0  it outputs the value 3  and then calls itself the execution of countdown begins with n = 2  and since n is not 0  it outputs the value 2  and then calls itself the execution of countdown begins with n = 1  and since n is not 0  it outputs the value 1  and then calls itself the execution of countdown begins with n = 0  and since n is 0  it outputs the word  blastoff ! and then returns the countdown that got n = 1 returns the countdown that got n = 2 returns the countdown that got n = 3 returns and then you re back in main  what a trip   so  the total output looks like this  3 2 1 blastoff ! as a second example  look again at the functions newline and threelines  def newline    print def threelines    newline   newline   newline   42 conditionals and recursion although these work  they would not be much help if we wanted to output 2 newlines  or 106 a better alternative would be this  def nlines  n   if n > 0  print nlines  n-1  this program is similar to countdown ; as long as n is greater than 0  it outputs one newline and then calls itself to output n-1 additional newlines thus  the total number of newlines is 1 +  n  1  which  if you do your algebra right  comes out to n the process of a function calling itself is recursion  and such functions are said to be recursive 4.10 stack diagrams for recursive functions in section 3.11  we used a stack diagram to represent the state of a program during a function call the same kind of diagram can help interpret a recursive function every time a function gets called  python creates a new function frame  which contains the function s local variables and parameters for a recursive function  there might be more than one frame on the stack at the same time this figure shows a stack diagram for countdown called with n = 3  __main__ countdown countdown countdown countdown n 3 n 2 n 1 n 0 as usual  the top of the stack is the frame for main  it is empty because we did not create any variables in main or pass any arguments to it 4.11 infinite recursion 43 the four countdown frames have different values for the parameter n the bottom of the stack  where n = 0  is called the base case it does not make a recursive call  so there are no more frames as an exercise  draw a stack diagram for nlines called with n = 4 4.11 infinite recursion if a recursion never reaches a base case  it goes on making recursive calls forever  and the program never terminates this is known as infinite recursion  and it is generally not considered a good idea here is a minimal program with an infinite recursion  def recurse    recurse   in most programming environments  a program with infinite recursion does not really run forever python reports an error message when the maximum recursion depth is reached  file  line 2  in recurse  98 repetitions omitted  file  line 2  in recurse runtimeerror  maximum recursion depth exceeded this traceback is a little bigger than the one we saw in the previous chapter when the error occurs  there are 100 recurse frames on the stack ! as an exercise  write a function with infinite recursion and run it in the python interpreter 4.12 keyboard input the programs we have written so far are a bit rude in the sense that they accept no input from the user they just do the same thing every time python provides built-in functions that get input from the keyboard the simplest is called raw input when this function is called  the program stops and waits for the user to type something when the user presses return or the enter key  the program resumes and raw input returns what the user typed as a string  > > > input = raw_input   what are you waiting for > > > print input what are you waiting for 44 conditionals and recursion before calling raw input  it is a good idea to print a message telling the user what to input this message is called a prompt we can supply a prompt as an argument to raw input  > > > name = raw_input  what...is your name  what...is your name arthur  king of the britons ! > > > print name arthur  king of the britons ! if we expect the response to be an integer  we can use the input function  prompt = what...is the airspeed velocity of an unladen swallow \ n speed = input  prompt  the sequence \ n at the end of the string represents a newline  so the user s input appears below the prompt if the user types a string of digits  it is converted to an integer and assigned to speed unfortunately  if the user types a character that is not a digit  the program crashes  > > > speed = input  prompt  what...is the airspeed velocity of an unladen swallow what do you mean  an african or a european swallow syntaxerror  invalid syntax to avoid this kind of error  it is generally a good idea to use raw input to get a string and then use conversion functions to convert to other types 4.13 glossary modulus operator  an operator  denoted with a percent sign  %   that works on integers and yields the remainder when one number is divided by another boolean expression  an expression that is either true or false comparison operator  one of the operators that compares two values  = =  ! =  >  =  and < =  logical operator  one of the operators that combines boolean expressions  and  or  and not conditional statement  a statement that controls the flow of execution depending on some condition 4.13 glossary 45 condition  the boolean expression in a conditional statement that determines which branch is executed compound statement  a statement that consists of a header and a body the header ends with a colon     the body is indented relative to the header block  a group of consecutive statements with the same indentation body  the block in a compound statement that follows the header nesting  one program structure within another  such as a conditional statement inside a branch of another conditional statement recursion  the process of calling the function that is currently executing base case  a branch of the conditional statement in a recursive function that does not result in a recursive call infinite recursion  a function that calls itself recursively without ever reaching the base case eventually  an infinite recursion causes a runtime error prompt  a visual cue that tells the user to input data 46 conditionals and recursion chapter 5 fruitful functions 5.1 return values some of the built-in functions we have used  such as the math functions  have produced results calling the function generates a new value  which we usually assign to a variable or use as part of an expression e = math.exp  1.0  height = radius math.sin  angle  but so far  none of the functions we have written has returned a value in this chapter  we are going to write functions that return values  which we will call fruitful functions  for want of a better name the first example is area  which returns the area of a circle with the given radius  import math def area  radius   temp = math.pi radius 2 return temp we have seen the return statement before  but in a fruitful function the return statement includes a return value this statement means  return immediately from this function and use the following expression as a return value the expression provided can be arbitrarily complicated  so we could have written this function more concisely  def area  radius   return math.pi radius 2 48 fruitful functions on the other hand  temporary variables like temp often make debugging easier sometimes it is useful to have multiple return statements  one in each branch of a conditional  def absolutevalue  x   if x < 0  return -x else  return x since these return statements are in an alternative conditional  only one will be executed as soon as one is executed  the function terminates without executing any subsequent statements code that appears after a return statement  or any other place the flow of execution can never reach  is called dead code in a fruitful function  it is a good idea to ensure that every possible path through the program hits a return statement for example  def absolutevalue  x   if x < 0  return -x elif x > 0  return x this program is not correct because if x happens to be 0  neither condition is true  and the function ends without hitting a return statement in this case  the return value is a special value called none  > > > print absolutevalue  0  none as an exercise  write a compare function that returns 1 if x > y  0 if x = = y  and -1 if x < y 5.2 program development at this point  you should be able to look at complete functions and tell what they do also  if you have been doing the exercises  you have written some small functions as you write larger functions  you might start to have more difficulty  especially with runtime and semantic errors 5.2 program development 49 to deal with increasingly complex programs  we are going to suggest a technique called incremental development the goal of incremental development is to avoid long debugging sessions by adding and testing only a small amount of code at a time as an example  suppose you want to find the distance between two points  given by the coordinates  x1  y1  and  x2  y2   by the pythagorean theorem  the distance is  distance = p  x2 x1  2 +  y2 y1  2 the first step is to consider what a distance function should look like in python in other words  what are the inputs  parameters  and what is the output  return value  in this case  the two points are the inputs  which we can represent using four parameters the return value is the distance  which is a floating-point value already we can write an outline of the function  def distance  x1  y1  x2  y2   return 0.0 obviously  this version of the function doesn t compute distances ; it always returns zero but it is syntactically correct  and it will run  which means that we can test it before we make it more complicated to test the new function  we call it with sample values  > > > distance  1  2  4  6  0.0 we chose these values so that the horizontal distance equals 3 and the vertical distance equals 4 ; that way  the result is 5  the hypotenuse of a 3-4-5 triangle   when testing a function  it is useful to know the right answer at this point we have confirmed that the function is syntactically correct  and we can start adding lines of code after each incremental change  we test the function again if an error occurs at any point  we know where it must be in the last line we added a logical first step in the computation is to find the differences x2 x1 and y2 y1 we will store those values in temporary variables named dx and dy and print them 50 fruitful functions def distance  x1  y1  x2  y2   dx = x2  x1 dy = y2  y1 print dx is  dx print dy is  dy return 0.0 if the function is working  the outputs should be 3 and 4 if so  we know that the function is getting the right arguments and performing the first computation correctly if not  there are only a few lines to check next we compute the sum of squares of dx and dy  def distance  x1  y1  x2  y2   dx = x2  x1 dy = y2  y1 dsquared = dx 2 + dy 2 print dsquared is   dsquared return 0.0 notice that we removed the print statements we wrote in the previous step code like that is called scaffolding because it is helpful for building the program but is not part of the final product again  we would run the program at this stage and check the output  which should be 25   finally  if we have imported the math module  we can use the sqrt function to compute and return the result  def distance  x1  y1  x2  y2   dx = x2  x1 dy = y2  y1 dsquared = dx 2 + dy 2 result = math.sqrt  dsquared  return result if that works correctly  you are done otherwise  you might want to print the value of result before the return statement when you start out  you should add only a line or two of code at a time as you gain more experience  you might find yourself writing and debugging bigger chunks either way  the incremental development process can save you a lot of debugging time the key aspects of the process are  5.3 composition 51 1 start with a working program and make small incremental changes at any point  if there is an error  you will know exactly where it is 2 use temporary variables to hold intermediate values so you can output and check them 3 once the program is working  you might want to remove some of the scaffolding or consolidate multiple statements into compound expressions  but only if it does not make the program difficult to read as an exercise  use incremental development to write a function called hypotenuse that returns the length of the hypotenuse of a right triangle given the lengths of the two legs as arguments record each stage of the incremental development process as you go 5.3 composition as you should expect by now  you can call one function from within another this ability is called composition as an example  we ll write a function that takes two points  the center of the circle and a point on the perimeter  and computes the area of the circle assume that the center point is stored in the variables xc and yc  and the perimeter point is in xp and yp the first step is to find the radius of the circle  which is the distance between the two points fortunately  there is a function  distance  that does that  radius = distance  xc  yc  xp  yp  the second step is to find the area of a circle with that radius and return it  result = area  radius  return result wrapping that up in a function  we get  def area2  xc  yc  xp  yp   radius = distance  xc  yc  xp  yp  result = area  radius  return result we called this function area2 to distinguish it from the area function defined earlier there can only be one function with a given name within a given module 52 fruitful functions the temporary variables radius and result are useful for development and debugging  but once the program is working  we can make it more concise by composing the function calls  def area2  xc  yc  xp  yp   return area  distance  xc  yc  xp  yp   as an exercise  write a function slope  x1  y1  x2  y2  that returns the slope of the line through the points  x1  y1  and  x2  y2   then use this function in a function called intercept  x1  y1  x2  y2  that returns the y-intercept of the line through the points  x1  y1  and  x2  y2   5.4 boolean functions functions can return boolean values  which is often convenient for hiding complicated tests inside functions for example  def isdivisible  x  y   if x % y = = 0  return true else  return false the name of this function is isdivisible it is common to give boolean functions names that sound like yes/no questions isdivisible returns either true or false to indicate whether the x is or is not divisible by y we can make the function more concise by taking advantage of the fact that the condition of the if statement is itself a boolean expression we can return it directly  avoiding the if statement altogether  def isdivisible  x  y   return x % y = = 0 this session shows the new function in action  > > > isdivisible  6  4  false > > > isdivisible  6  3  true boolean functions are often used in conditional statements  5.5 more recursion 53 if isdivisible  x  y   print x is divisible by y else  print x is not divisible by y it might be tempting to write something like  if isdivisible  x  y  = = true  but the extra comparison is unnecessary as an exercise  write a function isbetween  x  y  z  that returns true if y x z or false otherwise 5.5 more recursion so far  you have only learned a small subset of python  but you might be interested to know that this subset is a complete programming language  which means that anything that can be computed can be expressed in this language any program ever written could be rewritten using only the language features you have learned so far  actually  you would need a few commands to control devices like the keyboard  mouse  disks  etc  but that s all   proving that claim is a nontrivial exercise first accomplished by alan turing  one of the first computer scientists  some would argue that he was a mathematician  but a lot of early computer scientists started as mathematicians   accordingly  it is known as the turing thesis if you take a course on the theory of computation  you will have a chance to see the proof to give you an idea of what you can do with the tools you have learned so far  we ll evaluate a few recursively defined mathematical functions a recursive definition is similar to a circular definition  in the sense that the definition contains a reference to the thing being defined a truly circular definition is not very useful  frabjuous  an adjective used to describe something that is frabjuous if you saw that definition in the dictionary  you might be annoyed on the other hand  if you looked up the definition of the mathematical function factorial  you might get something like this  0 ! = 1 n ! = n  n 1  ! this definition says that the factorial of 0 is 1  and the factorial of any other value  n  is n multiplied by the factorial of n 1 54 fruitful functions so 3 ! is 3 times 2 !  which is 2 times 1 !  which is 1 times 0 !  putting it all together  3 ! equals 3 times 2 times 1 times 1  which is 6 if you can write a recursive definition of something  you can usually write a python program to evaluate it the first step is to decide what the parameters are for this function with little effort  you should conclude that factorial has a single parameter  def factorial  n   if the argument happens to be 0  all we have to do is return 1  def factorial  n   if n = = 0  return 1 otherwise  and this is the interesting part  we have to make a recursive call to find the factorial of n 1 and then multiply it by n  def factorial  n   if n = = 0  return 1 else  recurse = factorial  n-1  result = n recurse return result the flow of execution for this program is similar to the flow of countdown in section 4.9 if we call factorial with the value 3  since 3 is not 0  we take the second branch and calculate the factorial of n-1 since 2 is not 0  we take the second branch and calculate the factorial of n-1 since 1 is not 0  we take the second branch and calculate the factorial of n-1 since 0 is 0  we take the first branch and return 1 without making any more recursive calls the return value  1  is multiplied by n  which is 1  and the result is returned the return value  1  is multiplied by n  which is 2  and the result is returned the return value  2  is multiplied by n  which is 3  and the result  6  becomes the return value of the function call that started the whole process 5.6 leap of faith 55 here is what the stack diagram looks like for this sequence of function calls  n 3 recurse 2 recurse 1 recurse 1 return 1 return 2 return 6 __main__ factorial n 2 n 1 n 0 factorial factorial factorial 1 1 2 6 the return values are shown being passed back up the stack in each frame  the return value is the value of result  which is the product of n and recurse notice that in the last frame  the local variables recurse and result do not exist  because the branch that creates them did not execute 5.6 leap of faith following the flow of execution is one way to read programs  but it can quickly become labyrinthine an alternative is what we call the leap of faith when you come to a function call  instead of following the flow of execution  you assume that the function works correctly and returns the appropriate value in fact  you are already practicing this leap of faith when you use built-in functions when you call math.cos or math.exp  you don t examine the implementations of those functions you just assume that they work because the people who wrote the built-in functions were good programmers the same is true when you call one of your own functions for example  in section 5.4  we wrote a function called isdivisible that determines whether one number is divisible by another once we have convinced ourselves that this function is correct by testing and examining the code we can use the function without looking at the code again the same is true of recursive programs when you get to the recursive call  instead of following the flow of execution  you should assume that the recursive 56 fruitful functions call works  yields the correct result  and then ask yourself  assuming that i can find the factorial of n 1  can i compute the factorial of n in this case  it is clear that you can  by multiplying by n of course  it s a bit strange to assume that the function works correctly when you haven t finished writing it  but that s why it s called a leap of faith ! 5.7 one more example in the previous example  we used temporary variables to spell out the steps and to make the code easier to debug  but we could have saved a few lines  def factorial  n   if n = = 0  return 1 else  return n factorial  n-1  from now on  we will tend to use the more concise form  but we recommend that you use the more explicit version while you are developing code when you have it working  you can tighten it up if you are feeling inspired after factorial  the most common example of a recursively defined mathematical function is fibonacci  which has the following definition  fibonacci  0  = 1 fibonacci  1  = 1 fibonacci  n  = fibonacci  n 1  + fibonacci  n 2  ; translated into python  it looks like this  def fibonacci  n   if n = = 0 or n = = 1  return 1 else  return fibonacci  n-1  + fibonacci  n-2  if you try to follow the flow of execution here  even for fairly small values of n  your head explodes but according to the leap of faith  if you assume that the two recursive calls work correctly  then it is clear that you get the right result by adding them together 5.8 checking types 57 5.8 checking types what happens if we call factorial and give it 1.5 as an argument > > > factorial  1.5  runtimeerror  maximum recursion depth exceeded it looks like an infinite recursion but how can that be there is a base case when n = = 0 the problem is that the values of n miss the base case in the first recursive call  the value of n is 0.5 in the next  it is -0.5 from there  it gets smaller and smaller  but it will never be 0 we have two choices we can try to generalize the factorial function to work with floating-point numbers  or we can make factorial check the type of its argument the first option is called the gamma function and it s a little beyond the scope of this book so we ll go for the second we can use the built-in function isinstance to verify the type of the argument while we re at it  we also make sure the argument is positive  def factorial  n   if not isinstance  n  int   print factorial is only defined for integers return -1 elif n < 0  print factorial is only defined for positive integers return -1 elif n = = 0  return 1 else  return n factorial  n-1  now we have three base cases the first catches nonintegers the second catches negative integers in both cases  the program prints an error message and returns a special value  -1  to indicate that something went wrong  > > > factorial  fred  factorial is only defined for integers -1 > > > factorial  -2  factorial is only defined for positive integers -1 if we get past both checks  then we know that n is a positive integer  and we can prove that the recursion terminates 58 fruitful functions this program demonstrates a pattern sometimes called a guardian the first two conditionals act as guardians  protecting the code that follows from values that might cause an error the guardians make it possible to prove the correctness of the code 5.9 glossary fruitful function  a function that yields a return value return value  the value provided as the result of a function call temporary variable  a variable used to store an intermediate value in a complex calculation dead code  part of a program that can never be executed  often because it appears after a return statement none  a special python value returned by functions that have no return statement  or a return statement without an argument incremental development  a program development plan intended to avoid debugging by adding and testing only a small amount of code at a time scaffolding  code that is used during program development but is not part of the final version guardian  a condition that checks for and handles circumstances that might cause an error chapter 6 iteration 6.1 multiple assignment as you may have discovered  it is legal to make more than one assignment to the same variable a new assignment makes an existing variable refer to a new value  and stop referring to the old value   bruce = 5 print bruce  bruce = 7 print bruce the output of this program is 5 7  because the first time bruce is printed  his value is 5  and the second time  his value is 7 the comma at the end of the first print statement suppresses the newline after the output  which is why both outputs appear on the same line here is what multiple assignment looks like in a state diagram  7 5 bruce with multiple assignment it is especially important to distinguish between an assignment operation and a statement of equality because python uses the equal sign  =  for assignment  it is tempting to interpret a statement like a = b as a statement of equality it is not ! 60 iteration first  equality is commutative and assignment is not for example  in mathematics  if a = 7 then 7 = a but in python  the statement a = 7 is legal and 7 = a is not furthermore  in mathematics  a statement of equality is always true if a = b now  then a will always equal b in python  an assignment statement can make two variables equal  but they don t have to stay that way  a = 5 b = a # a and b are now equal a = 3 # a and b are no longer equal the third line changes the value of a but does not change the value of b  so they are no longer equal  in some programming languages  a different symbol is used for assignment  such as <  or  =  to avoid confusion  although multiple assignment is frequently helpful  you should use it with caution if the values of variables change frequently  it can make the code difficult to read and debug 6.2 the while statement computers are often used to automate repetitive tasks repeating identical or similar tasks without making errors is something that computers do well and people do poorly we have seen two programs  nlines and countdown  that use recursion to perform repetition  which is also called iteration because iteration is so common  python provides several language features to make it easier the first feature we are going to look at is the while statement here is what countdown looks like with a while statement  def countdown  n   while n > 0  print n n = n-1 print blastoff ! since we removed the recursive call  this function is not recursive you can almost read the while statement as if it were english it means  while n is greater than 0  continue displaying the value of n and then reducing the value of n by 1 when you get to 0  display the word blastoff ! more formally  here is the flow of execution for a while statement  6.2 the while statement 61 1 evaluate the condition  yielding 0 or 1 2 if the condition is false  0   exit the while statement and continue execution at the next statement 3 if the condition is true  1   execute each of the statements in the body and then go back to step 1 the body consists of all of the statements below the header with the same indentation this type of flow is called a loop because the third step loops back around to the top notice that if the condition is false the first time through the loop  the statements inside the loop are never executed the body of the loop should change the value of one or more variables so that eventually the condition becomes false and the loop terminates otherwise the loop will repeat forever  which is called an infinite loop an endless source of amusement for computer scientists is the observation that the directions on shampoo  lather  rinse  repeat  are an infinite loop in the case of countdown  we can prove that the loop terminates because we know that the value of n is finite  and we can see that the value of n gets smaller each time through the loop  so eventually we have to get to 0 in other cases  it is not so easy to tell  def sequence  n   while n ! = 1  print n  if n % 2 = = 0  # n is even n = n/2 else  # n is odd n = n 3 + 1 the condition for this loop is n ! = 1  so the loop will continue until n is 1  which will make the condition false each time through the loop  the program outputs the value of n and then checks whether it is even or odd if it is even  the value of n is divided by 2 if it is odd  the value is replaced by n 3 + 1 for example  if the starting value  the argument passed to sequence  is 3  the resulting sequence is 3  10  5  16  8  4  2  1 since n sometimes increases and sometimes decreases  there is no obvious proof that n will ever reach 1  or that the program terminates for some particular values of n  we can prove termination for example  if the starting value is a power of two  then the value of n will be even each time through the loop until it reaches 1 the previous example ends with such a sequence  starting with 16 62 iteration particular values aside  the interesting question is whether we can prove that this program terminates for all positive values of n so far  no one has been able to prove it or disprove it ! as an exercise  rewrite the function nlines from section 4.9 using iteration instead of recursion 6.3 tables one of the things loops are good for is generating tabular data before computers were readily available  people had to calculate logarithms  sines and cosines  and other mathematical functions by hand to make that easier  mathematics books contained long tables listing the values of these functions creating the tables was slow and boring  and they tended to be full of errors when computers appeared on the scene  one of the initial reactions was  this is great ! we can use the computers to generate the tables  so there will be no errors that turned out to be true  mostly  but shortsighted soon thereafter  computers and calculators were so pervasive that the tables became obsolete well  almost for some operations  computers use tables of values to get an approximate answer and then perform computations to improve the approximation in some cases  there have been errors in the underlying tables  most famously in the table the intel pentium used to perform floating-point division although a log table is not as useful as it once was  it still makes a good example of iteration the following program outputs a sequence of values in the left column and their logarithms in the right column  x = 1.0 while x < 10.0  print x  \ t  math.log  x  x = x + 1.0 the string \ t represents a tab character as characters and strings are displayed on the screen  an invisible marker called the cursor keeps track of where the next character will go after a print statement  the cursor normally goes to the beginning of the next line the tab character shifts the cursor to the right until it reaches one of the tab stops tabs are useful for making columns of text line up  as in the output of the previous program  6.3 tables 63 1.0 0.0 2.0 0.69314718056 3.0 1.09861228867 4.0 1.38629436112 5.0 1.60943791243 6.0 1.79175946923 7.0 1.94591014906 8.0 2.07944154168 9.0 2.19722457734 if these values seem odd  remember that the log function uses base e since powers of two are so important in computer science  we often want to find logarithms with respect to base 2 to do that  we can use the following formula  log2 x = loge x loge 2 changing the output statement to  print x  \ t  math.log  x  /math.log  2.0  yields  1.0 0.0 2.0 1.0 3.0 1.58496250072 4.0 2.0 5.0 2.32192809489 6.0 2.58496250072 7.0 2.80735492206 8.0 3.0 9.0 3.16992500144 we can see that 1  2  4  and 8 are powers of two because their logarithms base 2 are round numbers if we wanted to find the logarithms of other powers of two  we could modify the program like this  x = 1.0 while x < 100.0  print x  \ t  math.log  x  /math.log  2.0  x = x 2.0 now instead of adding something to x each time through the loop  which yields an arithmetic sequence  we multiply x by something  yielding a geometric sequence the result is  64 iteration 1.0 0.0 2.0 1.0 4.0 2.0 8.0 3.0 16.0 4.0 32.0 5.0 64.0 6.0 because of the tab characters between the columns  the position of the second column does not depend on the number of digits in the first column logarithm tables may not be useful any more  but for computer scientists  knowing the powers of two is ! as an exercise  modify this program so that it outputs the powers of two up to 65,536  that s 2 16   print it out and memorize it the backslash character in \ t indicates the beginning of an escape sequence escape sequences are used to represent invisible characters like tabs and newlines the sequence \ n represents a newline an escape sequence can appear anywhere in a string ; in the example  the tab escape sequence is the only thing in the string how do you think you represent a backslash in a string as an exercise  write a single string that produces this output 6.4 two-dimensional tables a two-dimensional table is a table where you read the value at the intersection of a row and a column a multiplication table is a good example let s say you want to print a multiplication table for the values from 1 to 6 a good way to start is to write a loop that prints the multiples of 2  all on one line  i = 1 while i < = 6  print 2 i   i = i + 1 print 6.5 encapsulation and generalization 65 the first line initializes a variable named i  which acts as a counter or loop variable as the loop executes  the value of i increases from 1 to 6 when i is 7  the loop terminates each time through the loop  it displays the value of 2 i  followed by three spaces again  the comma in the print statement suppresses the newline after the loop completes  the second print statement starts a new line the output of the program is  2 4 6 8 10 12 so far  so good the next step is to encapsulate and generalize 6.5 encapsulation and generalization encapsulation is the process of wrapping a piece of code in a function  allowing you to take advantage of all the things functions are good for you have seen two examples of encapsulation  printparity in section 4.5 ; and isdivisible in section 5.4 generalization means taking something specific  such as printing the multiples of 2  and making it more general  such as printing the multiples of any integer this function encapsulates the previous loop and generalizes it to print multiples of n  def printmultiples  n   i = 1 while i < = 6  print n i  \ t  i = i + 1 print to encapsulate  all we had to do was add the first line  which declares the name of the function and the parameter list to generalize  all we had to do was replace the value 2 with the parameter n if we call this function with the argument 2  we get the same output as before with the argument 3  the output is  3 6 9 12 15 18 with the argument 4  the output is  4 8 12 16 20 24 66 iteration by now you can probably guess how to print a multiplication table by calling printmultiples repeatedly with different arguments in fact  we can use another loop  i = 1 while i < = 6  printmultiples  i  i = i + 1 notice how similar this loop is to the one inside printmultiples all we did was replace the print statement with a function call the output of this program is a multiplication table  1 2 3 4 5 6 2 4 6 8 10 12 3 6 9 12 15 18 4 8 12 16 20 24 5 10 15 20 25 30 6 12 18 24 30 36 6.6 more encapsulation to demonstrate encapsulation again  let s take the code from the end of section 6.5 and wrap it up in a function  def printmulttable    i = 1 while i < = 6  printmultiples  i  i = i + 1 this process is a common development plan we develop code by writing lines of code outside any function  or typing them in to the interpreter when we get the code working  we extract it and wrap it up in a function this development plan is particularly useful if you don t know  when you start writing  how to divide the program into functions this approach lets you design as you go along 6.7 local variables 67 6.7 local variables you might be wondering how we can use the same variable  i  in both printmultiples and printmulttable doesn t it cause problems when one of the functions changes the value of the variable the answer is no  because the i in printmultiples and the i in printmulttable are not the same variable variables created inside a function definition are local ; you can t access a local variable from outside its home function that means you are free to have multiple variables with the same name as long as they are not in the same function the stack diagram for this program shows that the two variables named i are not the same variable they can refer to different values  and changing one does not affect the other i 2 1 3 n 3 i 2 1 printmulttable printmultiples the value of i in printmulttable goes from 1 to 6 in the diagram it happens to be 3 the next time through the loop it will be 4 each time through the loop  printmulttable calls printmultiples with the current value of i as an argument that value gets assigned to the parameter n inside printmultiples  the value of i goes from 1 to 6 in the diagram  it happens to be 2 changing this variable has no effect on the value of i in printmulttable it is common and perfectly legal to have different local variables with the same name in particular  names like i and j are used frequently as loop variables if you avoid using them in one function just because you used them somewhere else  you will probably make the program harder to read 68 iteration 6.8 more generalization as another example of generalization  imagine you wanted a program that would print a multiplication table of any size  not just the six-by-six table you could add a parameter to printmulttable  def printmulttable  high   i = 1 while i < = high  printmultiples  i  i = i + 1 we replaced the value 6 with the parameter high if we call printmulttable with the argument 7  it displays  1 2 3 4 5 6 2 4 6 8 10 12 3 6 9 12 15 18 4 8 12 16 20 24 5 10 15 20 25 30 6 12 18 24 30 36 7 14 21 28 35 42 this is fine  except that we probably want the table to be square with the same number of rows and columns to do that  we add another parameter to printmultiples to specify how many columns the table should have just to be annoying  we call this parameter high  demonstrating that different functions can have parameters with the same name  just like local variables   here s the whole program  def printmultiples  n  high   i = 1 while i < = high  print n i  \ t  i = i + 1 print def printmulttable  high   i = 1 while i < = high  printmultiples  i  high  i = i + 1 notice that when we added a new parameter  we had to change the first line of the function  the function heading   and we also had to change the place where 6.9 functions 69 the function is called in printmulttable as expected  this program generates a square seven-by-seven table  1 2 3 4 5 6 7 2 4 6 8 10 12 14 3 6 9 12 15 18 21 4 8 12 16 20 24 28 5 10 15 20 25 30 35 6 12 18 24 30 36 42 7 14 21 28 35 42 49 when you generalize a function appropriately  you often get a program with capabilities you didn t plan for example  you might notice that  because ab = ba  all the entries in the table appear twice you could save ink by printing only half the table to do that  you only have to change one line of printmulttable change printmultiples  i  high  to printmultiples  i  i  and you get 1 2 4 3 6 9 4 8 12 16 5 10 15 20 25 6 12 18 24 30 36 7 14 21 28 35 42 49 as an exercise  trace the execution of this version of printmulttable and figure out how it works 6.9 functions a few times now  we have mentioned all the things functions are good for by now  you might be wondering what exactly those things are here are some of them  giving a name to a sequence of statements makes your program easier to read and debug 70 iteration dividing a long program into functions allows you to separate parts of the program  debug them in isolation  and then compose them into a whole functions facilitate both recursion and iteration well-designed functions are often useful for many programs once you write and debug one  you can reuse it 6.10 glossary multiple assignment  making more than one assignment to the same variable during the execution of a program iteration  repeated execution of a set of statements using either a recursive function call or a loop loop  a statement or group of statements that execute repeatedly until a terminating condition is satisfied infinite loop  a loop in which the terminating condition is never satisfied body  the statements inside a loop loop variable  a variable used as part of the terminating condition of a loop tab  a special character that causes the cursor to move to the next tab stop on the current line newline  a special character that causes the cursor to move to the beginning of the next line cursor  an invisible marker that keeps track of where the next character will be printed escape sequence  an escape character  \  followed by one or more printable characters used to designate a nonprintable character encapsulate  to divide a large complex program into components  like functions  and isolate the components from each other  by using local variables  for example   generalize  to replace something unnecessarily specific  like a constant value  with something appropriately general  like a variable or parameter   generalization makes code more versatile  more likely to be reused  and sometimes even easier to write development plan  a process for developing a program in this chapter  we demonstrated a style of development based on developing code to do simple  specific things and then encapsulating and generalizing chapter 7 strings 7.1 a compound data type so far we have seen three types  int  float  and string strings are qualitatively different from the other two because they are made up of smaller pieces characters types that comprise smaller pieces are called compound data types depending on what we are doing  we may want to treat a compound data type as a single thing  or we may want to access its parts this ambiguity is useful the bracket operator selects a single character from a string > > > fruit = banana > > > letter = fruit  1  > > > print letter the expression fruit  1  selects character number 1 from fruit the variable letter refers to the result when we display letter  we get a surprise  a the first letter of banana is not a unless you are a computer scientist in that case you should think of the expression in brackets as an offset from the beginning of the string  and the offset of the first letter is zero so b is the 0th letter  zero-eth  of banana  a is the 1th letter  one-eth   and n is the 2th  two-eth  letter to get the first letter of a string  you just put 0  or any expression with the value 0  in the brackets  72 strings > > > letter = fruit  0  > > > print letter b the expression in brackets is called an index an index specifies a member of an ordered set  in this case the set of characters in the string the index indicates which one you want  hence the name it can be any integer expression 7.2 length the len function returns the number of characters in a string  > > > fruit = banana > > > len  fruit  6 to get the last letter of a string  you might be tempted to try something like this  length = len  fruit  last = fruit  length  # error ! that won t work it causes the runtime error indexerror  string index out of range the reason is that there is no 6th letter in banana since we started counting at zero  the six letters are numbered 0 to 5 to get the last character  we have to subtract 1 from length  length = len  fruit  last = fruit  length-1  alternatively  we can use negative indices  which count backward from the end of the string the expression fruit  -1  yields the last letter  fruit  -2  yields the second to last  and so on 7.3 traversal and the for loop a lot of computations involve processing a string one character at a time often they start at the beginning  select each character in turn  do something to it  and continue until the end this pattern of processing is called a traversal one way to encode a traversal is with a while statement  index = 0 while index < len  fruit   letter = fruit  index  print letter index = index + 1 7.3 traversal and the for loop 73 this loop traverses the string and displays each letter on a line by itself the loop condition is index < len  fruit   so when index is equal to the length of the string  the condition is false  and the body of the loop is not executed the last character accessed is the one with the index len  fruit  -1  which is the last character in the string as an exercise  write a function that takes a string as an argument and outputs the letters backward  one per line using an index to traverse a set of values is so common that python provides an alternative  simpler syntax the for loop  for char in fruit  print char each time through the loop  the next character in the string is assigned to the variable char the loop continues until no characters are left the following example shows how to use concatenation and a for loop to generate an abecedarian series abecedarian refers to a series or list in which the elements appear in alphabetical order for example  in robert mccloskey s book make way for ducklings  the names of the ducklings are jack  kack  lack  mack  nack  ouack  pack  and quack this loop outputs these names in order  prefixes = jklmnopq suffix = ack for letter in prefixes  print letter + suffix the output of this program is  jack kack lack mack nack oack pack qack of course  that s not quite right because ouack and quack are misspelled as an exercise  modify the program to fix this error 74 strings 7.4 string slices a segment of a string is called a slice selecting a slice is similar to selecting a character  > > > s = peter  paul  and mary > > > print s  0  5  peter > > > print s  7  11  paul > > > print s  17  21  mary the operator  n  m  returns the part of the string from the n-eth character to the m-eth character  including the first but excluding the last this behavior is counterintuitive ; it makes more sense if you imagine the indices pointing between the characters  as in the following diagram  fruit b a n a n a index 0 1 2 3 4 5 6 if you omit the first index  before the colon   the slice starts at the beginning of the string if you omit the second index  the slice goes to the end of the string thus  > > > fruit = banana > > > fruit   3  ban > > > fruit  3   ana what do you think s    means 7.5 string comparison the comparison operators work on strings to see if two strings are equal  if word = = banana  print yes  we have no bananas ! 7.6 strings are immutable 75 other comparison operations are useful for putting words in alphabetical order  if word < banana  print your word  + word +  comes before banana elif word > banana  print your word  + word +  comes after banana else  print yes  we have no bananas ! you should be aware  though  that python does not handle upper and lowercase letters the same way that people do all the uppercase letters come before all the lowercase letters as a result  your word  zebra  comes before banana a common way to address this problem is to convert strings to a standard format  such as all lowercase  before performing the comparison a more difficult problem is making the program realize that zebras are not fruit 7.6 strings are immutable it is tempting to use the   operator on the left side of an assignment  with the intention of changing a character in a string for example  greeting = hello  world ! greeting  0  = j # error ! print greeting instead of producing the output jello  world !  this code produces the runtime error typeerror  object doesn t support item assignment strings are immutable  which means you can t change an existing string the best you can do is create a new string that is a variation on the original  greeting = hello  world ! newgreeting = j + greeting  1   print newgreeting the solution here is to concatenate a new first letter onto a slice of greeting this operation has no effect on the original string 76 strings 7.7 a find function what does the following function do def find  str  ch   index = 0 while index < len  str   if str  index  = = ch  return index index = index + 1 return -1 in a sense  find is the opposite of the   operator instead of taking an index and extracting the corresponding character  it takes a character and finds the index where that character appears if the character is not found  the function returns -1 this is the first example we have seen of a return statement inside a loop if str  index  = = ch  the function returns immediately  breaking out of the loop prematurely if the character doesn t appear in the string  then the program exits the loop normally and returns -1 this pattern of computation is sometimes called a eureka traversal because as soon as we find what we are looking for  we can cry eureka ! and stop looking as an exercise  modify the find function so that it has a third parameter  the index in the string where it should start looking 7.8 looping and counting the following program counts the number of times the letter a appears in a string  fruit = banana count = 0 for char in fruit  if char = = a  count = count + 1 print count this program demonstrates another pattern of computation called a counter the variable count is initialized to 0 and then incremented each time an a is 7.9 the string module 77 found  to increment is to increase by one ; it is the opposite of decrement  and unrelated to excrement  which is a noun  when the loop exits  count contains the result the total number of a s as an exercise  encapsulate this code in a function named countletters  and generalize it so that it accepts the string and the letter as arguments as a second exercise  rewrite this function so that instead of traversing the string  it uses the three-parameter version of find from the previous 7.9 the string module the string module contains useful functions that manipulate strings as usual  we have to import the module before we can use it  > > > import string the string module includes a function named find that does the same thing as the function we wrote to call it we have to specify the name of the module and the name of the function using dot notation > > > fruit = banana > > > index = string.find  fruit  a  > > > print index 1 this example demonstrates one of the benefits of modules they help avoid collisions between the names of built-in functions and user-defined functions by using dot notation we can specify which version of find we want actually  string.find is more general than our version first  it can find substrings  not just characters  > > > string.find  banana  na  2 also  it takes an additional argument that specifies the index it should start at  > > > string.find  banana  na  3  4 or it can take two additional arguments that specify a range of indices  78 strings > > > string.find  bob  b  1  2  -1 in this example  the search fails because the letter b does not appear in the index range from 1 to 2  not including 2   7.10 character classification it is often helpful to examine a character and test whether it is upper or lowercase  or whether it is a character or a digit the string module provides several constants that are useful for these purposes the string string.lowercase contains all of the letters that the system considers to be lowercase similarly  string.uppercase contains all of the uppercase letters try the following and see what you get  > > > print string.lowercase > > > print string.uppercase > > > print string.digits we can use these constants and find to classify characters for example  if find  lowercase  ch  returns a value other than -1  then ch must be lowercase  def islower  ch   return string.find  string.lowercase  ch  ! = -1 alternatively  we can take advantage of the in operator  which determines whether a character appears in a string  def islower  ch   return ch in string.lowercase as yet another alternative  we can use the comparison operator  def islower  ch   return a < = ch < = z if ch is between a and z  it must be a lowercase letter as an exercise  discuss which version of islower you think will be fastest can you think of other reasons besides speed to prefer one or the other another constant defined in the string module may surprise you when you print it  7.11 glossary 79 > > > print string.whitespace whitespace characters move the cursor without printing anything they create the white space between visible characters  at least on white paper   the constant string.whitespace contains all the whitespace characters  including space  tab  \ t   and newline  \ n   there are other useful functions in the string module  but this book isn t intended to be a reference manual on the other hand  the python library reference is along with a wealth of other documentation  it s available from the python website  www.python.org 7.11 glossary compound data type  a data type in which the values are made up of components  or elements  that are themselves values traverse  to iterate through the elements of a set  performing a similar operation on each index  a variable or value used to select a member of an ordered set  such as a character from a string slice  a part of a string specified by a range of indices mutable  a compound data types whose elements can be assigned new values counter  a variable used to count something  usually initialized to zero and then incremented increment  to increase the value of a variable by one decrement  to decrease the value of a variable by one whitespace  any of the characters that move the cursor without printing visible characters the constant string.whitespace contains all the whitespace characters 80 strings chapter 8 lists a list is an ordered set of values  where each value is identified by an index the values that make up a list are called its elements lists are similar to strings  which are ordered sets of characters  except that the elements of a list can have any type lists and strings and other things that behave like ordered sets are called sequences 8.1 list values there are several ways to create a new list ; the simplest is to enclose the elements in square brackets   and     10  20  30  40   spam  bungee  swallow  the first example is a list of four integers the second is a list of three strings the elements of a list don t have to be the same type the following list contains a string  a float  an integer  and  mirabile dictu  another list   hello  2.0  5   10  20   a list within another list is said to be nested lists that contain consecutive integers are common  so python provides a simple way to create them  > > > range  1,5   1  2  3  4  82 lists the range function takes two arguments and returns a list that contains all the integers from the first to the second  including the first but not including the second ! there are two other forms of range with a single argument  it creates a list that starts at 0  > > > range  10   0  1  2  3  4  5  6  7  8  9  if there is a third argument  it specifies the space between successive values  which is called the step size this example counts from 1 to 10 by steps of 2  > > > range  1  10  2   1  3  5  7  9  finally  there is a special list that contains no elements it is called the empty list  and it is denoted    with all these ways to create lists  it would be disappointing if we couldn t assign list values to variables or pass lists as arguments to functions we can vocabulary =  ameliorate  castigate  defenestrate  numbers =  17  123  empty =   print vocabulary  numbers  empty  ameliorate  castigate  defenestrate   17  123    8.2 accessing elements the syntax for accessing the elements of a list is the same as the syntax for accessing the characters of a string the bracket operator      the expression inside the brackets specifies the index remember that the indices start at 0  print numbers  0  numbers  1  = 5 the bracket operator can appear anywhere in an expression when it appears on the left side of an assignment  it changes one of the elements in the list  so the one-eth element of numbers  which used to be 123  is now 5 any integer expression can be used as an index  > > > numbers  3-2  5 > > > numbers  1.0  typeerror  sequence index must be integer 8.3 list length 83 if you try to read or write an element that does not exist  you get a runtime error  > > > numbers  2  = 5 indexerror  list assignment index out of range if an index has a negative value  it counts backward from the end of the list  > > > numbers  -1  5 > > > numbers  -2  17 > > > numbers  -3  indexerror  list index out of range numbers  -1  is the last element of the list  numbers  -2  is the second to last  and numbers  -3  doesn t exist it is common to use a loop variable as a list index horsemen =  war  famine  pestilence  death  i = 0 while i < 4  print horsemen  i  i = i + 1 this while loop counts from 0 to 4 when the loop variable i is 4  the condition fails and the loop terminates so the body of the loop is only executed when i is 0  1  2  and 3 each time through the loop  the variable i is used as an index into the list  printing the i-eth element this pattern of computation is called a list traversal 8.3 list length the function len returns the length of a list it is a good idea to use this value as the upper bound of a loop instead of a constant that way  if the size of the list changes  you won t have to go through the program changing all the loops ; they will work correctly for any size list  84 lists horsemen =  war  famine  pestilence  death  i = 0 while i < len  horsemen   print horsemen  i  i = i + 1 the last time the body of the loop is executed  i is len  horsemen   1  which is the index of the last element when i is equal to len  horsemen   the condition fails and the body is not executed  which is a good thing  because len  horsemen  is not a legal index although a list can contain another list  the nested list still counts as a single element the length of this list is four   spam !  1   brie  roquefort  pol le veq    1  2  3   as an exercise  write a loop that traverses the previous list and prints the length of each element what happens if you send an integer to len 8.4 list membership in is a boolean operator that tests membership in a sequence we used it in section 7.10 with strings  but it also works with lists and other sequences  > > > horsemen =  war  famine  pestilence  death  > > > pestilence in horsemen true > > > debauchery in horsemen false since pestilence is a member of the horsemen list  the in operator returns true since debauchery is not in the list  in returns false we can use the not in combination with in to test whether an element is not a member of a list  > > > debauchery not in horsemen true 8.5 lists and for loops the for loop we saw in section 7.3 also works with lists the generalized syntax of a for loop is  8.6 list operations 85 for variable in list  body this statement is equivalent to  i = 0 while i < len  list   variable = list  i  body i = i + 1 the for loop is more concise because we can eliminate the loop variable  i here is the previous loop written with a for loop for horseman in horsemen  print horseman it almost reads like english  for  every  horseman in  the list of  horsemen  print  the name of the  horseman any list expression can be used in a for loop  for number in range  20   if number % 2 = = 0  print number for fruit in  banana  apple  quince   print i like to eat + fruit + s ! the first example prints all the even numbers between zero and nineteen the second example expresses enthusiasm for various fruits 8.6 list operations the + operator concatenates lists  > > > a =  1  2  3  > > > b =  4  5  6  > > > c = a + b > > > print c  1  2  3  4  5  6  similarly  the operator repeats a list a given number of times  86 lists > > >  0  4  0  0  0  0  > > >  1  2  3  3  1  2  3  1  2  3  1  2  3  the first example repeats  0  four times the second example repeats the list  1  2  3  three times 8.7 list slices the slice operations we saw in section 7.4 also work on lists  > > > list =  a  b  c  d  e  f  > > > list  1  3   b  c  > > > list   4   a  b  c  d  > > > list  3    d  e  f  if you omit the first index  the slice starts at the beginning if you omit the second  the slice goes to the end so if you omit both  the slice is really a copy of the whole list > > > list     a  b  c  d  e  f  8.8 lists are mutable unlike strings  lists are mutable  which means we can change their elements using the bracket operator on the left side of an assignment  we can update one of the elements  > > > fruit =  banana  apple  quince  > > > fruit  0  = pear > > > fruit  -1  = orange > > > print fruit  pear  apple  orange  with the slice operator we can update several elements at once  8.9 list deletion 87 > > > list =  a  b  c  d  e  f  > > > list  1  3  =  x  y  > > > print list  a  x  y  d  e  f  we can also remove elements from a list by assigning the empty list to them  > > > list =  a  b  c  d  e  f  > > > list  1  3  =   > > > print list  a  d  e  f  and we can add elements to a list by squeezing them into an empty slice at the desired location  > > > list =  a  d  f  > > > list  1  1  =  b  c  > > > print list  a  b  c  d  f  > > > list  4  4  =  e  > > > print list  a  b  c  d  e  f  8.9 list deletion using slices to delete list elements can be awkward  and therefore error-prone python provides an alternative that is more readable del removes an element from a list  > > > a =  one  two  three  > > > del a  1  > > > a  one  three  as you might expect  del handles negative indices and causes a runtime error if the index is out of range you can use a slice as an index for del  > > > list =  a  b  c  d  e  f  > > > del list  1  5  > > > print list  a  f  88 lists as usual  slices select all the elements up to  but not including  the second index 8.10 objects and values 89 8.10 objects and values if we execute these assignment statements  a = banana b = banana we know that a and b will refer to a string with the letters banana but we can t tell whether they point to the same string there are two possible states  a b banana banana a b banana in one case  a and b refer to two different things that have the same value in the second case  they refer to the same thing these things have names they are called objects an object is something a variable can refer to every object has a unique identifier  which we can obtain with the id function by printing the identifier of a and b  we can tell whether they refer to the same object > > > id  a  135044008 > > > id  b  135044008 in fact  we get the same identifier twice  which means that python only created one string  and both a and b refer to it interestingly  lists behave differently when we create two lists  we get two objects  > > > a =  1  2  3  > > > b =  1  2  3  > > > id  a  135045528 > > > id  b  135041704 so the state diagram looks like this  a b  1  2  3   1  2  3  a and b have the same value but do not refer to the same object 90 lists 8.11 aliasing since variables refer to objects  if we assign one variable to another  both variables refer to the same object  > > > a =  1  2  3  > > > b = a in this case  the state diagram looks like this  a b  1  2  3  because the same list has two different names  a and b  we say that it is aliased changes made with one alias affect the other  > > > b  0  = 5 > > > print a  5  2  3  although this behavior can be useful  it is sometimes unexpected or undesirable in general  it is safer to avoid aliasing when you are working with mutable objects of course  for immutable objects  there s no problem that s why python is free to alias strings when it sees an opportunity to economize 8.12 cloning lists if we want to modify a list and also keep a copy of the original  we need to be able to make a copy of the list itself  not just the reference this process is sometimes called cloning  to avoid the ambiguity of the word copy the easiest way to clone a list is to use the slice operator  > > > a =  1  2  3  > > > b = a    > > > print b  1  2  3  taking any slice of a creates a new list in this case the slice happens to consist of the whole list now we are free to make changes to b without worrying about a  8.13 list parameters 91 > > > b  0  = 5 > > > print a  1  2  3  as an exercise  draw a state diagram for a and b before and after this change 8.13 list parameters passing a list as an argument actually passes a reference to the list  not a copy of the list for example  the function head takes a list as an argument and returns the first element  def head  list   return list  0  here s how it is used  > > > numbers =  1  2  3  > > > head  numbers  1 the parameter list and the variable numbers are aliases for the same object the state diagram looks like this  list  1  2  3  __main__ numbers head since the list object is shared by two frames  we drew it between them if a function modifies a list parameter  the caller sees the change for example  deletehead removes the first element from a list  def deletehead  list   del list  0  here s how deletehead is used  > > > numbers =  1  2  3  > > > deletehead  numbers  > > > print numbers  2  3  92 lists if a function returns a list  it returns a reference to the list for example  tail returns a list that contains all but the first element of the given list  def tail  list   return list  1   here s how tail is used  > > > numbers =  1  2  3  > > > rest = tail  numbers  > > > print rest  2  3  because the return value was created with the slice operator  it is a new list creating rest  and any subsequent changes to rest  have no effect on numbers 8.14 nested lists a nested list is a list that appears as an element in another list in this list  the three-eth element is a nested list  > > > list =  hello  2.0  5   10  20   if we print list  3   we get  10  20   to extract an element from the nested list  we can proceed in two steps  > > > elt = list  3  > > > elt  0  10 or we can combine them  > > > list  3   1  20 bracket operators evaluate from left to right  so this expression gets the threeeth element of list and extracts the one-eth element from it 8.15 matrices nested lists are often used to represent matrices for example  the matrix  1 2 3 7 8 9 4 5 6 8.16 strings and lists 93 might be represented as  > > > matrix =   1  2  3    4  5  6    7  8  9   matrix is a list with three elements  where each element is a row of the matrix we can select an entire row from the matrix in the usual way  > > > matrix  1   4  5  6  or we can extract a single element from the matrix using the double-index form  > > > matrix  1   1  5 the first index selects the row  and the second index selects the column although this way of representing matrices is common  it is not the only possibility a small variation is to use a list of columns instead of a list of rows later we will see a more radical alternative using a dictionary 8.16 strings and lists two of the most useful functions in the string module involve lists of strings the split function breaks a string into a list of words by default  any number of whitespace characters is considered a word boundary  > > > import string > > > song = the rain in spain > > > string.split  song   the  rain  in  spain  an optional argument called a delimiter can be used to specify which characters to use as word boundaries the following example uses the string ai as the delimiter  > > > string.split  song  ai   the r  n in sp  n  notice that the delimiter doesn t appear in the list the join function is the inverse of split it takes a list of strings and concatenates the elements with a space between each pair  > > > list =  the  rain  in  spain  > > > string.join  list  the rain in spain 94 lists like split  join takes an optional delimiter that is inserted between elements  > > > string.join  list  _  the_rain_in_spain as an exercise  describe the relationship between string.join  string.split  song   and song are they the same for all strings when would they be different 8.17 glossary list  a named collection of objects  where each object is identified by an index index  an integer variable or value that indicates an element of a list element  one of the values in a list  or other sequence   the bracket operator selects elements of a list sequence  any of the data types that consist of an ordered set of elements  with each element identified by an index nested list  a list that is an element of another list list traversal  the sequential accessing of each element in a list object  a thing to which a variable can refer aliases  multiple variables that contain references to the same object clone  to create a new object that has the same value as an existing object copying a reference to an object creates an alias but doesn t clone the object delimiter  a character or string used to indicate where a string should be split chapter 9 tuples 9.1 mutability and tuples so far  you have seen two compound types  strings  which are made up of characters ; and lists  which are made up of elements of any type one of the differences we noted is that the elements of a list can be modified  but the characters in a string can not in other words  strings are immutable and lists are mutable there is another type in python called a tuple that is similar to a list except that it is immutable syntactically  a tuple is a comma-separated list of values  > > > tuple = a  b  c  d  e although it is not necessary  it is conventional to enclose tuples in parentheses  > > > tuple =  a  b  c  d  e  to create a tuple with a single element  we have to include the final comma  > > > t1 =  a   > > > type  t1  without the comma  python treats  a  as a string in parentheses  > > > t2 =  a  > > > type  t2  96 tuples syntax issues aside  the operations on tuples are the same as the operations on lists the index operator selects an element from a tuple > > > tuple =  a  b  c  d  e  > > > tuple  0  a and the slice operator selects a range of elements > > > tuple  1  3   b  c  but if we try to modify one of the elements of the tuple  we get an error  > > > tuple  0  = a typeerror  object doesn t support item assignment of course  even if we can t modify the elements of a tuple  we can replace it with a different tuple  > > > tuple =  a   + tuple  1   > > > tuple  a  b  c  d  e  9.2 tuple assignment once in a while  it is useful to swap the values of two variables with conventional assignment statements  we have to use a temporary variable for example  to swap a and b  > > > temp = a > > > a = b > > > b = temp if we have to do this often  this approach becomes cumbersome python provides a form of tuple assignment that solves this problem neatly  > > > a  b = b  a the left side is a tuple of variables ; the right side is a tuple of values each value is assigned to its respective variable all the expressions on the right side are evaluated before any of the assignments this feature makes tuple assignment quite versatile naturally  the number of variables on the left and the number of values on the right have to be the same  9.3 tuples as return values 97 > > > a  b  c  d = 1  2  3 valueerror  unpack tuple of wrong size 9.3 tuples as return values functions can return tuples as return values for example  we could write a function that swaps two parameters  def swap  x  y   return y  x then we can assign the return value to a tuple with two variables  a  b = swap  a  b  in this case  there is no great advantage in making swap a function in fact  there is a danger in trying to encapsulate swap  which is the following tempting mistake  def swap  x  y   # incorrect version x  y = y  x if we call this function like this  swap  a  b  then a and x are aliases for the same value changing x inside swap makes x refer to a different value  but it has no effect on a in main  similarly  changing y has no effect on b this function runs without producing an error message  but it doesn t do what we intended this is an example of a semantic error as an exercise  draw a state diagram for this function so that you can see why it doesn t work 9.4 random numbers most computer programs do the same thing every time they execute  so they are said to be deterministic determinism is usually a good thing  since we expect the same calculation to yield the same result for some applications  though  we want the computer to be unpredictable games are an obvious example  but there are more 98 tuples making a program truly nondeterministic turns out to be not so easy  but there are ways to make it at least seem nondeterministic one of them is to generate random numbers and use them to determine the outcome of the program python provides a built-in function that generates pseudorandom numbers  which are not truly random in the mathematical sense  but for our purposes they will do the random module contains a function called random that returns a floatingpoint number between 0.0 and 1.0 each time you call random  you get the next number in a long series to see a sample  run this loop  import random for i in range  10   x = random.random   print x to generate a random number between 0.0 and an upper bound like high  multiply x by high as an exercise  generate a random number between low and high as an additional exercise  generate a random integer between low and high  including both end points 9.5 list of random numbers the first step is to generate a list of random values randomlist takes an integer argument and returns a list of random numbers with the given length it starts with a list of n zeros each time through the loop  it replaces one of the elements with a random number the return value is a reference to the complete list  def randomlist  n   s =  0  n for i in range  n   s  i  = random.random   return s we ll test this function with a list of eight elements for purposes of debugging  it is a good idea to start small 9.6 counting 99 > > > randomlist  8  0.15156642489 0.498048560109 0.810894847068 0.360371157682 0.275119183077 0.328578797631 0.759199803101 0.800367163582 the numbers generated by random are supposed to be distributed uniformly  which means that every value is equally likely if we divide the range of possible values into equal-sized buckets  and count the number of times a random value falls in each bucket  we should get roughly the same number in each we can test this theory by writing a program to divide the range into buckets and count the number of values in each 9.6 counting a good approach to problems like this is to divide the problem into subproblems and look for subproblems that fit a computational pattern you have seen before in this case  we want to traverse a list of numbers and count the number of times a value falls in a given range that sounds familiar in section 7.8  we wrote a program that traversed a string and counted the number of times a given letter appeared so  we can proceed by copying the old program and adapting it for the current problem the original program was  count = 0 for char in fruit  if char = = a  count = count + 1 print count the first step is to replace fruit with t and char with num that doesn t change the program ; it just makes it more readable the second step is to change the test we aren t interested in finding letters we want to see if num is between the given values low and high 100 tuples count = 0 for num in t  if low < num < high  count = count + 1 print count the last step is to encapsulate this code in a function called inbucket the parameters are the list and the values low and high def inbucket  t  low  high   count = 0 for num in t  if low < num < high  count = count + 1 return count by copying and modifying an existing program  we were able to write this function quickly and save a lot of debugging time this development plan is called pattern matching if you find yourself working on a problem you have solved before  reuse the solution 9.7 many buckets as the number of buckets increases  inbucket gets a little unwieldy with two buckets  it s not bad  low = inbucket  a  0.0  0.5  high = inbucket  a  0.5  1  but with four buckets it is getting cumbersome bucket1 = inbucket  a  0.0  0.25  bucket2 = inbucket  a  0.25  0.5  bucket3 = inbucket  a  0.5  0.75  bucket4 = inbucket  a  0.75  1.0  there are two problems one is that we have to make up new variable names for each result the other is that we have to compute the range for each bucket we ll solve the second problem first if the number of buckets is numbuckets  then the width of each bucket is 1.0 / numbuckets we ll use a loop to compute the range of each bucket the loop variable  i  counts from 0 to numbuckets-1  9.7 many buckets 101 bucketwidth = 1.0 / numbuckets for i in range  numbuckets   low = i bucketwidth high = low + bucketwidth print low  to  high to compute the low end of each bucket  we multiply the loop variable by the bucket width the high end is just a bucketwidth away with numbuckets = 8  the output is  0.0 to 0.125 0.125 to 0.25 0.25 to 0.375 0.375 to 0.5 0.5 to 0.625 0.625 to 0.75 0.75 to 0.875 0.875 to 1.0 you can confirm that each bucket is the same width  that they don t overlap  and that they cover the entire range from 0.0 to 1.0 now back to the first problem we need a way to store eight integers  using the loop variable to indicate one at a time by now you should be thinking  list ! we have to create the bucket list outside the loop  because we only want to do it once inside the loop  we ll call inbucket repeatedly and update the i-eth element of the list  numbuckets = 8 buckets =  0  numbuckets bucketwidth = 1.0 / numbuckets for i in range  numbuckets   low = i bucketwidth high = low + bucketwidth buckets  i  = inbucket  t  low  high  print buckets with a list of 1000 values  this code produces this bucket list   138  124  128  118  130  117  114  131  these numbers are fairly close to 125  which is what we expected at least  they are close enough that we can believe the random number generator is working as an exercise  test this function with some longer lists  and see if the number of values in each bucket tends to level off 102 tuples 9.8 a single-pass solution although this program works  it is not as efficient as it could be every time it calls inbucket  it traverses the entire list as the number of buckets increases  that gets to be a lot of traversals it would be better to make a single pass through the list and compute for each value the index of the bucket in which it falls then we can increment the appropriate counter in the previous section we took an index  i  and multiplied it by the bucketwidth to find the lower bound of a given bucket now we want to take a value in the range 0.0 to 1.0 and find the index of the bucket where it falls since this problem is the inverse of the previous problem  we might guess that we should divide by bucketwidth instead of multiplying that guess is correct since bucketwidth = 1.0 / numbuckets  dividing by bucketwidth is the same as multiplying by numbuckets if we multiply a number in the range 0.0 to 1.0 by numbuckets  we get a number in the range from 0.0 to numbuckets if we round that number to the next lower integer  we get exactly what we are looking for a bucket index  numbuckets = 8 buckets =  0  numbuckets for i in t  index = int  i numbuckets  buckets  index  = buckets  index  + 1 we used the int function to convert a floating-point number to an integer is it possible for this calculation to produce an index that is out of range  either negative or greater than len  buckets  -1  a list like buckets that contains counts of the number of values in each range is called a histogram as an exercise  write a function called histogram that takes a list and a number of buckets as arguments and returns a histogram with the given number of buckets 9.9 glossary 103 9.9 glossary immutable type  a type in which the elements can not be modified assignments to elements or slices of immutable types cause an error mutable type  a data type in which the elements can be modified all mutable types are compound types lists and dictionaries are mutable data types ; strings and tuples are not tuple  a sequence type that is similar to a list except that it is immutable tuples can be used wherever an immutable type is required  such as a key in a dictionary tuple assignment  an assignment to all of the elements in a tuple using a single assignment statement tuple assignment occurs in parallel rather than in sequence  making it useful for swapping values deterministic  a program that does the same thing each time it is called pseudorandom  a sequence of numbers that appear to be random but that are actually the result of a deterministic computation histogram  a list of integers in which each element counts the number of times something happens pattern matching  a program development plan that involves identifying a familiar computational pattern and copying the solution to a similar problem 104 tuples chapter 10 dictionaries the compound types you have learned about strings  lists  and tuples use integers as indices if you try to use any other type as an index  you get an error dictionaries are similar to other compound types except that they can use any immutable type as an index as an example  we will create a dictionary to translate english words into spanish for this dictionary  the indices are strings one way to create a dictionary is to start with the empty dictionary and add elements the empty dictionary is denoted    > > > eng2sp =   > > > eng2sp  one  = uno > > > eng2sp  two  = dos the first assignment creates a dictionary named eng2sp ; the other assignments add new elements to the dictionary we can print the current value of the dictionary in the usual way  > > > print eng2sp  one  uno  two  dos  the elements of a dictionary appear in a comma-separated list each entry contains an index and a value separated by a colon in a dictionary  the indices are called keys  so the elements are called key-value pairs another way to create a dictionary is to provide a list of key-value pairs using the same syntax as the previous output  106 dictionaries > > > eng2sp =  one  uno  two  dos  three  tres  if we print the value of eng2sp again  we get a surprise  > > > print eng2sp  one  uno  three  tres  two  dos  the key-value pairs are not in order ! fortunately  there is no reason to care about the order  since the elements of a dictionary are never indexed with integer indices instead  we use the keys to look up the corresponding values  > > > print eng2sp  two  dos the key two yields the value dos even though it appears in the third keyvalue pair 10.1 dictionary operations the del statement removes a key-value pair from a dictionary for example  the following dictionary contains the names of various fruits and the number of each fruit in stock  > > > inventory =  apples  430  bananas  312  oranges  525  pears  217  > > > print inventory  oranges  525  apples  430  pears  217  bananas  312  if someone buys all of the pears  we can remove the entry from the dictionary  > > > del inventory  pears  > > > print inventory  oranges  525  apples  430  bananas  312  or if we re expecting more pears soon  we might just change the value associated with pears  > > > inventory  pears  = 0 > > > print inventory  oranges  525  apples  430  pears  0  bananas  312  the len function also works on dictionaries ; it returns the number of key-value pairs  > > > len  inventory  4 10.2 dictionary methods 107 10.2 dictionary methods a method is similar to a function it takes arguments and returns a value but the syntax is different for example  the keys method takes a dictionary and returns a list of the keys that appear  but instead of the function syntax keys  eng2sp   we use the method syntax eng2sp.keys    > > > eng2sp.keys    one  three  two  this form of dot notation specifies the name of the function  keys  and the name of the object to apply the function to  eng2sp the parentheses indicate that this method has no parameters a method call is called an invocation ; in this case  we would say that we are invoking keys on the object eng2sp the values method is similar ; it returns a list of the values in the dictionary  > > > eng2sp.values    uno  tres  dos  the items method returns both  in the form of a list of tuples one for each key-value pair  > > > eng2sp.items     one  uno    three  tres    two  dos   the syntax provides useful type information the square brackets indicate that this is a list the parentheses indicate that the elements of the list are tuples if a method takes an argument  it uses the same syntax as a function call for example  the method has key takes a key and returns true  1  if the key appears in the dictionary  > > > eng2sp.has_key  one  true > > > eng2sp.has_key  deux  false if you try to call a method without specifying an object  you get an error in this case  the error message is not very helpful  > > > has_key  one  nameerror  has_key 108 dictionaries 10.3 aliasing and copying because dictionaries are mutable  you need to be aware of aliasing whenever two variables refer to the same object  changes to one affect the other if you want to modify a dictionary and keep a copy of the original  use the copy method for example  opposites is a dictionary that contains pairs of opposites  > > > opposites =  up  down  right  wrong  true  false  > > > alias = opposites > > > copy = opposites.copy   alias and opposites refer to the same object ; copy refers to a fresh copy of the same dictionary if we modify alias  opposites is also changed  > > > alias  right  = left > > > opposites  right  left if we modify copy  opposites is unchanged  > > > copy  right  = privilege > > > opposites  right  left 10.4 sparse matrices in section 8.14  we used a list of lists to represent a matrix that is a good choice for a matrix with mostly nonzero values  but consider a sparse matrix like this one  0 2 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 the list representation contains a lot of zeroes  matrix =   0,0,0,1,0    0,0,0,0,0    0,2,0,0,0    0,0,0,0,0    0,0,0,3,0   10.5 hints 109 an alternative is to use a dictionary for the keys  we can use tuples that contain the row and column numbers here is the dictionary representation of the same matrix  matrix =   0,3   1   2  1   2   4  3   3  we only need three key-value pairs  one for each nonzero element of the matrix each key is a tuple  and each value is an integer to access an element of the matrix  we could use the   operator  matrix  0,3  1 notice that the syntax for the dictionary representation is not the same as the syntax for the nested list representation instead of two integer indices  we use one index  which is a tuple of integers there is one problem if we specify an element that is zero  we get an error  because there is no entry in the dictionary with that key  > > > matrix  1,3  keyerror   1  3  the get method solves this problem  > > > matrix.get   0,3   0  1 the first argument is the key ; the second argument is the value get should return if the key is not in the dictionary  > > > matrix.get   1,3   0  0 get definitely improves the semantics of accessing a sparse matrix shame about the syntax 10.5 hints if you played around with the fibonacci function from section 5.7  you might have noticed that the bigger the argument you provide  the longer the function takes to run furthermore  the run time increases very quickly on one of our machines  fibonacci  20  finishes instantly  fibonacci  30  takes about a second  and fibonacci  40  takes roughly forever 110 dictionaries to understand why  consider this call graph for fibonacci with n = 4  fibonacci n 4 fibonacci n 3 fibonacci n 2 fibonacci n 0 fibonacci n 1 fibonacci n 1 fibonacci n 2 fibonacci n 0 fibonacci n 1 a call graph shows a set function frames  with lines connecting each frame to the frames of the functions it calls at the top of the graph  fibonacci with n = 4 calls fibonacci with n = 3 and n = 2 in turn  fibonacci with n = 3 calls fibonacci with n = 2 and n = 1 and so on count how many times fibonacci  0  and fibonacci  1  are called this is an inefficient solution to the problem  and it gets far worse as the argument gets bigger a good solution is to keep track of values that have already been computed by storing them in a dictionary a previously computed value that is stored for later use is called a hint here is an implementation of fibonacci using hints  previous =  0  1  1  1  def fibonacci  n   if previous.has_key  n   return previous  n  else  newvalue = fibonacci  n-1  + fibonacci  n-2  previous  n  = newvalue return newvalue the dictionary named previous keeps track of the fibonacci numbers we already know we start with only two pairs  0 maps to 1 ; and 1 maps to 1 whenever fibonacci is called  it checks the dictionary to determine if it contains the result if it s there  the function can return immediately without making any more recursive calls if not  it has to compute the new value the new value is added to the dictionary before the function returns 10.6 long integers 111 using this version of fibonacci  our machines can compute fibonacci  40  in an eyeblink but when we try to compute fibonacci  50   we see the following  > > > fibonacci  50  20365011074l the l at the end of the result indicates that the answer +  20,365,011,074  is too big to fit into a python integer python has automatically converted the result to a long integer 10.6 long integers python provides a type called long that can handle any size integer there are two ways to create a long value one is to write an integer with a capital l at the end  > > > type  1l  the other is to use the long function to convert a value to a long long can accept any numerical type and even strings of digits  > > > long  1  1l > > > long  3.9  3l > > > long  57  57l all of the math operations work on longs  so in general any code that works with integers will also work with long integers any time the result of a computation is too big to be represented with an integer  python detects the overflow and returns the result as a long integer for example  > > > 1000 1000 1000000 > > > 100000 100000 10000000000l in the first case the result has type int ; in the second case it is long 10.7 counting letters in chapter 7  we wrote a function that counted the number of occurrences of a letter in a string a more general version of this problem is to form a histogram 112 dictionaries of the letters in the string  that is  how many times each letter appears such a histogram might be useful for compressing a text file because different letters appear with different frequencies  we can compress a file by using shorter codes for common letters and longer codes for letters that appear less frequently dictionaries provide an elegant way to generate a histogram  > > > lettercounts =   > > > for letter in mississippi   lettercounts  letter  = lettercounts.get  letter  0  + 1  > > > lettercounts  m  1  s  4  p  2  i  4  we start with an empty dictionary for each letter in the string  we find the current count  possibly zero  and increment it at the end  the dictionary contains pairs of letters and their frequencies it might be more appealing to display the histogram in alphabetical order we can do that with the items and sort methods  > > > letteritems = lettercounts.items   > > > letteritems.sort   > > > print letteritems   m  1    i  4    p  2    s  4   you have seen the items method before  but sort is the first method you have encountered that applies to lists there are several other list methods  including append  extend  and reverse consult the python documentation for details 10.8 glossary dictionary  a collection of key-value pairs that maps from keys to values the keys can be any immutable type  and the values can be any type key  a value that is used to look up an entry in a dictionary key-value pair  one of the items in a dictionary method  a kind of function that is called with a different syntax and invoked on an object invoke  to call a method hint  temporary storage of a precomputed value to avoid redundant computation 10.8 glossary 113 overflow  a numerical result that is too large to be represented in a numerical format 114 dictionaries chapter 11 files and exceptions while a program is running  its data is in memory when the program ends  or the computer shuts down  data in memory disappears to store data permanently  you have to put it in a file files are usually stored on a hard drive  floppy drive  or cd-rom when there are a large number of files  they are often organized into directories  also called folders   each file is identified by a unique name  or a combination of a file name and a directory name by reading and writing files  programs can exchange information with each other and generate printable formats like pdf working with files is a lot like working with books to use a book  you have to open it when you re done  you have to close it while the book is open  you can either write in it or read from it in either case  you know where you are in the book most of the time  you read the whole book in its natural order  but you can also skip around all of this applies to files as well to open a file  you specify its name and indicate whether you want to read or write opening a file creates a file object in this example  the variable f refers to the new file object > > > f = open  test.dat,w  > > > print f the open function takes two arguments the first is the name of the file  and the second is the mode mode w means that we are opening the file for writing 116 files and exceptions if there is no file named test.dat  it will be created if there already is one  it will be replaced by the file we are writing when we print the file object  we see the name of the file  the mode  and the location of the object to put data in the file we invoke the write method on the file object  > > > f.write  now is the time  > > > f.write  to close the file  closing the file tells the system that we are done writing and makes the file available for reading  > > > f.close   now we can open the file again  this time for reading  and read the contents into a string this time  the mode argument is r for reading  > > > f = open  test.dat,r  if we try to open a file that doesn t exist  we get an error  > > > f = open  test.cat,r  ioerror   errno 2  no such file or directory  test.cat not surprisingly  the read method reads data from the file with no arguments  it reads the entire contents of the file  > > > text = f.read   > > > print text now is the timeto close the file there is no space between time and to because we did not write a space between the strings read can also take an argument that indicates how many characters to read  > > > f = open  test.dat,r  > > > print f.read  5  now i if not enough characters are left in the file  read returns the remaining characters when we get to the end of the file  read returns the empty string  > > > print f.read  1000006  s the timeto close the file > > > print f.read   > > > 11.1 text files 117 the following function copies a file  reading and writing up to fifty characters at a time the first argument is the name of the original file ; the second is the name of the new file  def copyfile  oldfile  newfile   f1 = open  oldfile  r  f2 = open  newfile  w  while true  text = f1.read  50  if text = =  break f2.write  text  f1.close   f2.close   return the break statement is new executing it breaks out of the loop ; the flow of execution moves to the first statement after the loop in this example  the while loop is infinite because the value true is always true the only way to get out of the loop is to execute break  which happens when text is the empty string  which happens when we get to the end of the file 11.1 text files a text file is a file that contains printable characters and whitespace  organized into lines separated by newline characters since python is specifically designed to process text files  it provides methods that make the job easy to demonstrate  we ll create a text file with three lines of text separated by newlines  > > > f = open  test.dat,w  > > > f.write  line one \ nline two \ nline three \ n  > > > f.close   the readline method reads all the characters up to and including the next newline character  > > > f = open  test.dat,r  > > > print f.readline   line one > > > 118 files and exceptions readlines returns all of the remaining lines as a list of strings  > > > print f.readlines    line two \ 012  line three \ 012  in this case  the output is in list format  which means that the strings appear with quotation marks and the newline character appears as the escape sequence 012 at the end of the file  readline returns the empty string and readlines returns the empty list  > > > print f.readline   > > > print f.readlines     the following is an example of a line-processing program filterfile makes a copy of oldfile  omitting any lines that begin with #  def filterfile  oldfile  newfile   f1 = open  oldfile  r  f2 = open  newfile  w  while true  text = f1.readline   if text = =  break if text  0  = = #  continue f2.write  text  f1.close   f2.close   return the continue statement ends the current iteration of the loop  but continues looping the flow of execution moves to the top of the loop  checks the condition  and proceeds accordingly thus  if text is the empty string  the loop exits if the first character of text is a hash mark  the flow of execution goes to the top of the loop only if both conditions fail do we copy text into the new file 11.2 writing variables the argument of write has to be a string  so if we want to put other values in a file  we have to convert them to strings first the easiest way to do that is 11.2 writing variables 119 with the str function  > > > x = 52 > > > f.write  str  x   an alternative is to use the format operator %  when applied to integers  % is the modulus operator but when the first operand is a string  % is the format operator the first operand is the format string  and the second operand is a tuple of expressions the result is a string that contains the values of the expressions  formatted according to the format string as a simple example  the format sequence % d means that the first expression in the tuple should be formatted as an integer here the letter d stands for decimal  > > > cars = 52 > > > % d % cars 52 the result is the string 52  which is not to be confused with the integer value 52 a format sequence can appear anywhere in the format string  so we can embed a value in a sentence  > > > cars = 52 > > > in july we sold % d cars % cars in july we sold 52 cars the format sequence % f formats the next item in the tuple as a floating-point number  and % s formats the next item as a string  > > > in % d days we made % f million % s %  34,6.1  dollars  in 34 days we made 6.100000 million dollars by default  the floating-point format prints six decimal places the number of expressions in the tuple has to match the number of format sequences in the string also  the types of the expressions have to match the format sequences  > > > % d % d % d %  1,2  typeerror  not enough arguments for format string > > > % d % dollars typeerror  illegal argument type for built-in operation 120 files and exceptions in the first example  there aren t enough expressions ; in the second  the expression is the wrong type for more control over the format of numbers  we can specify the number of digits as part of the format sequence  > > > % 6d % 62 62 > > > % 12f % 6.1 6.100000 the number after the percent sign is the minimum number of spaces the number will take up if the value provided takes fewer digits  leading spaces are added if the number of spaces is negative  trailing spaces are added  > > > % -6d % 62 62 for floating-point numbers  we can also specify the number of digits after the decimal point  > > > % 12.2f % 6.1 6.10 in this example  the result takes up twelve spaces and includes two digits after the decimal this format is useful for printing dollar amounts with the decimal points aligned for example  imagine a dictionary that contains student names as keys and hourly wages as values here is a function that prints the contents of the dictionary as a formatted report  def report  wages   students = wages.keys   students.sort   for student in students  print % -20s % 12.2f %  student  wages  student   to test this function  we ll create a small dictionary and print the contents  > > > wages =  mary  6.23  joe  5.45  joshua  4.25  > > > report  wages  joe 5.45 joshua 4.25 mary 6.23 by controlling the width of each value  we guarantee that the columns will line up  as long as the names contain fewer than twenty-one characters and the wages are less than one billion dollars an hour 11.3 directories 121 11.3 directories when you create a new file by opening it and writing  the new file goes in the current directory  wherever you were when you ran the program   similarly  when you open a file for reading  python looks for it in the current directory if you want to open a file somewhere else  you have to specify the path to the file  which is the name of the directory  or folder  where the file is located  > > > f = open  /usr/share/dict/words,r  > > > print f.readline   aarhus this example opens a file named words that resides in a directory named dict  which resides in share  which resides in usr  which resides in the top-level directory of the system  called / you can not use / as part of a filename ; it is reserved as a delimiter between directory and filenames the file /usr/share/dict/words contains a list of words in alphabetical order  of which the first is the name of a danish university 11.4 pickling in order to put values into a file  you have to convert them to strings you have already seen how to do that with str  > > > f.write  str  12.3   > > > f.write  str   1,2,3    the problem is that when you read the value back  you get a string the original type information has been lost in fact  you can t even tell where one value ends and the next begins  > > > f.readline   12.3  1  2  3  the solution is pickling  so called because it preserves data structures the pickle module contains the necessary commands to use it  import pickle and then open the file in the usual way  > > > import pickle > > > f = open  test.pck,w  122 files and exceptions to store a data structure  use the dump method and then close the file in the usual way  > > > pickle.dump  12.3  f  > > > pickle.dump   1,2,3   f  > > > f.close   then we can open the file for reading and load the data structures we dumped  > > > f = open  test.pck,r  > > > x = pickle.load  f  > > > x 12.3 > > > type  x  > > > y = pickle.load  f  > > > y  1  2  3  > > > type  y  each time we invoke load  we get a single value from the file  complete with its original type 11.5 exceptions whenever a runtime error occurs  it creates an exception usually  the program stops and python prints an error message for example  dividing by zero creates an exception  > > > print 55/0 zerodivisionerror  integer division or modulo so does accessing a nonexistent list item  > > > a =   > > > print a  5  indexerror  list index out of range or accessing a key that isn t in the dictionary  > > > b =   > > > print b  what  keyerror  what 11.5 exceptions 123 or trying to open a nonexistent file  > > > f = open  idontexist  r  ioerror   errno 2  no such file or directory  idontexist in each case  the error message has two parts  the type of error before the colon  and specifics about the error after the colon normally python also prints a traceback of where the program was  but we have omitted that from the examples sometimes we want to execute an operation that could cause an exception  but we don t want the program to stop we can handle the exception using the try and except statements for example  we might prompt the user for the name of a file and then try to open it if the file doesn t exist  we don t want the program to crash ; we want to handle the exception  filename = raw_input  enter a file name   try  f = open  filename  r  except ioerror  print there is no file named  filename the try statement executes the statements in the first block if no exceptions occur  it ignores the except statement if an exception of type ioerror occurs  it executes the statements in the except branch and then continues we can encapsulate this capability in a function  exists takes a filename and returns true if the file exists  false if it doesn t  def exists  filename   try  f = open  filename  f.close   return true except ioerror  return false you can use multiple except blocks to handle different kinds of exceptions the python reference manual has the details if your program detects an error condition  you can make it raise an exception here is an example that gets input from the user and checks for the value 17 assuming that 17 is not valid input for some reason  we raise an exception 124 files and exceptions def inputnumber    x = input  pick a number   if x = = 17  raise valueerror  17 is a bad number return x the raise statement takes two arguments  the exception type and specific information about the error valueerror is one of the exception types python provides for a variety of occasions other examples include typeerror  keyerror  and my favorite  notimplementederror if the function that called inputnumber handles the error  then the program can continue ; otherwise  python prints the error message and exits  > > > inputnumber   pick a number  17 valueerror  17 is a bad number the error message includes the exception type and the additional information you provided as an exercise  write a function that uses inputnumber to input a number from the keyboard and that handles the valueerror exception 11.6 glossary file  a named entity  usually stored on a hard drive  floppy disk  or cd-rom  that contains a stream of characters directory  a named collection of files  also called a folder path  a sequence of directory names that specifies the exact location of a file text file  a file that contains printable characters organized into lines separated by newline characters break statement  a statement that causes the flow of execution to exit a loop continue statement  a statement that causes the current iteration of a loop to end the flow of execution goes to the top of the loop  evaluates the condition  and proceeds accordingly format operator  the % operator takes a format string and a tuple of expressions and yields a string that includes the expressions  formatted according to the format string 11.6 glossary 125 format string  a string that contains printable characters and format sequences that indicate how to format values format sequence  a sequence of characters beginning with % that indicates how to format a value pickle  to write a data value in a file along with its type information so that it can be reconstituted later exception  an error that occurs at runtime handle  to prevent an exception from terminating a program using the try and except statements raise  to signal an exception using the raise statement 126 files and exceptions chapter 12 classes and objects 12.1 user-defined compound types having used some of python s built-in types  we are ready to create a userdefined type  the point consider the concept of a mathematical point in two dimensions  a point is two numbers  coordinates  that are treated collectively as a single object in mathematical notation  points are often written in parentheses with a comma separating the coordinates for example   0  0  represents the origin  and  x  y  represents the point x units to the right and y units up from the origin a natural way to represent a point in python is with two floating-point values the question  then  is how to group these two values into a compound object the quick and dirty solution is to use a list or tuple  and for some applications that might be the best choice an alternative is to define a new user-defined compound type  also called a class this approach involves a bit more effort  but it has advantages that will be apparent soon a class definition looks like this  class point  pass class definitions can appear anywhere in a program  but they are usually near the beginning  after the import statements   the syntax rules for a class defi nition are the same as for other compound statements  see section 4.4   128 classes and objects this definition creates a new class called point the pass statement has no effect ; it is only necessary because a compound statement must have something in its body by creating the point class  we created a new type  also called point the members of this type are called instances of the type or objects creating a new instance is called instantiation to instantiate a point object  we call a function named  you guessed it  point  blank = point   the variable blank is assigned a reference to a new point object a function like point that creates new objects is called a constructor 12.2 attributes we can add new data to an instance using dot notation  > > > blank.x = 3.0 > > > blank.y = 4.0 this syntax is similar to the syntax for selecting a variable from a module  such as math.pi or string.uppercase in this case  though  we are selecting a data item from an instance these named items are called attributes the following state diagram shows the result of these assignments  x y 3.0 4.0 blank the variable blank refers to a point object  which contains two attributes each attribute refers to a floating-point number we can read the value of an attribute using the same syntax  > > > print blank.y 4.0 > > > x = blank.x > > > print x 3.0 the expression blank.x means  go to the object blank refers to and get the value of x in this case  we assign that value to a variable named x there 12.3 instances as arguments 129 is no conflict between the variable x and the attribute x the purpose of dot notation is to identify which variable you are referring to unambiguously you can use dot notation as part of any expression  so the following statements are legal  print  + str  blank.x  +  + str  blank.y  +  distancesquared = blank.x blank.x + blank.y blank.y the first line outputs  3.0  4.0  ; the second line calculates the value 25.0 you might be tempted to print the value of blank itself  > > > print blank the result indicates that blank is an instance of the point class and it was defined in main  80f8e70 is the unique identifier for this object  written in hexadecimal  base 16   this is probably not the most informative way to display a point object you will see how to change it shortly as an exercise  create and print a point object  and then use id to print the object s unique identifier translate the hexadecimal form into decimal and confirm that they match 12.3 instances as arguments you can pass an instance as an argument in the usual way for example  def printpoint  p   print  + str  p.x  +  + str  p.y  +  printpoint takes a point as an argument and displays it in the standard format if you call printpoint  blank   the output is  3.0  4.0   as an exercise  rewrite the distance function from section 5.2 so that it takes two points as arguments instead of four numbers 12.4 sameness the meaning of the word same seems perfectly clear until you give it some thought  and then you realize there is more to it than you expected for example  if you say  chris and i have the same car  you mean that his car and yours are the same make and model  but that they are two different cars 130 classes and objects if you say  chris and i have the same mother  you mean that his mother and yours are the same person.1 so the idea of sameness is different depending on the context when you talk about objects  there is a similar ambiguity for example  if two points are the same  does that mean they contain the same data  coordinates  or that they are actually the same object to find out if two references refer to the same object  use the = = operator for example  > > > p1 = point   > > > p1.x = 3 > > > p1.y = 4 > > > p2 = point   > > > p2.x = 3 > > > p2.y = 4 > > > p1 = = p2 false even though p1 and p2 contain the same coordinates  they are not the same object if we assign p1 to p2  then the two variables are aliases of the same object  > > > p2 = p1 > > > p1 = = p2 true this type of equality is called shallow equality because it compares only the references  not the contents of the objects to compare the contents of the objects deep equality we can write a function called samepoint  def samepoint  p1  p2   return  p1.x = = p2.x  and  p1.y = = p2.y  now if we create two different objects that contain the same data  we can use samepoint to find out if they represent the same point 1not all languages have the same problem for example  german has different words for different kinds of sameness same car in this context would be gleiche auto  and same mother would be selbe mutter 12.5 rectangles 131 > > > p1 = point   > > > p1.x = 3 > > > p1.y = 4 > > > p2 = point   > > > p2.x = 3 > > > p2.y = 4 > > > samepoint  p1  p2  true of course  if the two variables refer to the same object  they have both shallow and deep equality 12.5 rectangles let s say that we want a class to represent a rectangle the question is  what information do we have to provide in order to specify a rectangle to keep things simple  assume that the rectangle is oriented either vertically or horizontally  never at an angle there are a few possibilities  we could specify the center of the rectangle  two coordinates  and its size  width and height  ; or we could specify one of the corners and the size ; or we could specify two opposing corners a conventional choice is to specify the upper-left corner of the rectangle and the size again  we ll define a new class  class rectangle  pass and instantiate it  box = rectangle   box.width = 100.0 box.height = 200.0 this code creates a new rectangle object with two floating-point attributes to specify the upper-left corner  we can embed an object within an object ! box.corner = point   box.corner.x = 0.0 box.corner.y = 0.0 the dot operator composes the expression box.corner.x means  go to the object box refers to and select the attribute named corner ; then go to that object and select the attribute named x 132 classes and objects the figure shows the state of this object  y x 0.0 0.0 width height 100.0 corner 200.0 box 12.6 instances as return values functions can return instances for example  findcenter takes a rectangle as an argument and returns a point that contains the coordinates of the center of the rectangle  def findcenter  box   p = point   p.x = box.corner.x + box.width/2.0 p.y = box.corner.y  box.height/2.0 return p to call this function  pass box as an argument and assign the result to a variable  > > > center = findcenter  box  > > > printpoint  center   50.0  -100.0  12.7 objects are mutable we can change the state of an object by making an assignment to one of its attributes for example  to change the size of a rectangle without changing its position  we could modify the values of width and height  box.width = box.width + 50 box.height = box.height + 100 we could encapsulate this code in a method and generalize it to grow the rectangle by any amount  def growrect  box  dwidth  dheight   box.width = box.width + dwidth box.height = box.height + dheight 12.8 copying 133 the variables dwidth and dheight indicate how much the rectangle should grow in each direction invoking this method has the effect of modifying the rectangle that is passed as an argument for example  we could create a new rectangle named bob and pass it to growrect  > > > bob = rectangle   > > > bob.width = 100.0 > > > bob.height = 200.0 > > > bob.corner = point   > > > bob.corner.x = 0.0 > > > bob.corner.y = 0.0 > > > growrect  bob  50  100  while growrect is running  the parameter box is an alias for bob any changes made to box also affect bob as an exercise  write a function named moverect that takes a rectangle and two parameters named dx and dy it should change the location of the rectangle by adding dx to the x coordinate of corner and adding dy to the y coordinate of corner 12.8 copying aliasing can make a program difficult to read because changes made in one place might have unexpected effects in another place it is hard to keep track of all the variables that might refer to a given object copying an object is often an alternative to aliasing the copy module contains a function called copy that can duplicate any object  > > > import copy > > > p1 = point   > > > p1.x = 3 > > > p1.y = 4 > > > p2 = copy.copy  p1  > > > p1 = = p2 false > > > samepoint  p1  p2  true once we import the copy module  we can use the copy method to make a new point p1 and p2 are not the same point  but they contain the same data 134 classes and objects to copy a simple object like a point  which doesn t contain any embedded objects  copy is sufficient this is called shallow copying for something like a rectangle  which contains a reference to a point  copy doesn t do quite the right thing it copies the reference to the point object  so both the old rectangle and the new one refer to a single point if we create a box  b1  in the usual way and then make a copy  b2  using copy  the resulting state diagram looks like this  y x 0.0 0.0 100.0 200.0 width height 100.0 corner 200.0 width height corner b1 b2 this is almost certainly not what we want in this case  invoking growrect on one of the rectangles would not affect the other  but invoking moverect on either would affect both ! this behavior is confusing and error-prone fortunately  the copy module contains a method named deepcopy that copies not only the object but also any embedded objects you will not be surprised to learn that this operation is called a deep copy > > > b2 = copy.deepcopy  b1  now b1 and b2 are completely separate objects we can use deepcopy to rewrite growrect so that instead of modifying an existing rectangle  it creates a new rectangle that has the same location as the old one but new dimensions  def growrect  box  dwidth  dheight   import copy newbox = copy.deepcopy  box  newbox.width = newbox.width + dwidth newbox.height = newbox.height + dheight return newbox an an exercise  rewrite moverect so that it creates and returns a new rectangle instead of modifying the old one 12.9 glossary 135 12.9 glossary class  a user-defined compound type a class can also be thought of as a template for the objects that are instances of it instantiate  to create an instance of a class instance  an object that belongs to a class object  a compound data type that is often used to model a thing or concept in the real world constructor  a method used to create new objects attribute  one of the named data items that makes up an instance shallow equality  equality of references  or two references that point to the same object deep equality  equality of values  or two references that point to objects that have the same value shallow copy  to copy the contents of an object  including any references to embedded objects ; implemented by the copy function in the copy module deep copy  to copy the contents of an object as well as any embedded objects  and any objects embedded in them  and so on ; implemented by the deepcopy function in the copy module 136 classes and objects chapter 13 classes and functions 13.1 time as another example of a user-defined type  we ll define a class called time that records the time of day the class definition looks like this  class time  pass we can create a new time object and assign attributes for hours  minutes  and seconds  time = time   time.hours = 11 time.minutes = 59 time.seconds = 30 the state diagram for the time object looks like this  59 30 hours minutes seconds time 11 as an exercise  write a function printtime that takes a time object as an argument and prints it in the form hours  minutes  seconds 138 classes and functions as a second exercise  write a boolean function after that takes two time objects  t1 and t2  as arguments  and returns true if t1 follows t2 chronologically and false otherwise 13.2 pure functions in the next few sections  we ll write two versions of a function called addtime  which calculates the sum of two times they will demonstrate two kinds of functions  pure functions and modifiers the following is a rough version of addtime  def addtime  t1  t2   sum = time   sum.hours = t1.hours + t2.hours sum.minutes = t1.minutes + t2.minutes sum.seconds = t1.seconds + t2.seconds return sum the function creates a new time object  initializes its attributes  and returns a reference to the new object this is called a pure function because it does not modify any of the objects passed to it as arguments and it has no side effects  such as displaying a value or getting user input here is an example of how to use this function we ll create two time objects  currenttime  which contains the current time ; and breadtime  which contains the amount of time it takes for a breadmaker to make bread then we ll use addtime to figure out when the bread will be done if you haven t finished writing printtime yet  take a look ahead to section 14.2 before you try this  > > > currenttime = time   > > > currenttime.hours = 9 > > > currenttime.minutes = 14 > > > currenttime.seconds = 30 > > > breadtime = time   > > > breadtime.hours = 3 > > > breadtime.minutes = 35 > > > breadtime.seconds = 0 > > > donetime = addtime  currenttime  breadtime  > > > printtime  donetime  13.3 modifiers 139 the output of this program is 12  49  30  which is correct on the other hand  there are cases where the result is not correct can you think of one the problem is that this function does not deal with cases where the number of seconds or minutes adds up to more than sixty when that happens  we have to carry the extra seconds into the minutes column or the extra minutes into the hours column here s a second corrected version of the function  def addtime  t1  t2   sum = time   sum.hours = t1.hours + t2.hours sum.minutes = t1.minutes + t2.minutes sum.seconds = t1.seconds + t2.seconds if sum.seconds > = 60  sum.seconds = sum.seconds  60 sum.minutes = sum.minutes + 1 if sum.minutes > = 60  sum.minutes = sum.minutes  60 sum.hours = sum.hours + 1 return sum although this function is correct  it is starting to get big later we will suggest an alternative approach that yields shorter code 13.3 modifiers there are times when it is useful for a function to modify one or more of the objects it gets as arguments usually  the caller keeps a reference to the objects it passes  so any changes the function makes are visible to the caller functions that work this way are called modifiers increment  which adds a given number of seconds to a time object  would be written most naturally as a modifier a rough draft of the function looks like this  140 classes and functions def increment  time  seconds   time.seconds = time.seconds + seconds if time.seconds > = 60  time.seconds = time.seconds  60 time.minutes = time.minutes + 1 if time.minutes > = 60  time.minutes = time.minutes  60 time.hours = time.hours + 1 the first line performs the basic operation ; the remainder deals with the special cases we saw before is this function correct what happens if the parameter seconds is much greater than sixty in that case  it is not enough to carry once ; we have to keep doing it until seconds is less than sixty one solution is to replace the if statements with while statements  def increment  time  seconds   time.seconds = time.seconds + seconds while time.seconds > = 60  time.seconds = time.seconds  60 time.minutes = time.minutes + 1 while time.minutes > = 60  time.minutes = time.minutes  60 time.hours = time.hours + 1 this function is now correct  but it is not the most efficient solution as an exercise  rewrite this function so that it doesn t contain any loops as a second exercise  rewrite increment as a pure function  and write function calls to both versions 13.4 which is better anything that can be done with modifiers can also be done with pure functions in fact  some programming languages only allow pure functions there is some evidence that programs that use pure functions are faster to develop and less error-prone than programs that use modifiers nevertheless  modifiers are convenient at times  and in some cases  functional programs are less efficient 13.5 prototype development versus planning 141 in general  we recommend that you write pure functions whenever it is reasonable to do so and resort to modifiers only if there is a compelling advantage this approach might be called a functional programming style 13.5 prototype development versus planning in this chapter  we demonstrated an approach to program development that we call prototype development in each case  we wrote a rough draft  or prototype  that performed the basic calculation and then tested it on a few cases  correcting flaws as we found them although this approach can be effective  it can lead to code that is unnecessarily complicated since it deals with many special cases and unreliable since it is hard to know if you have found all the errors an alternative is planned development  in which high-level insight into the problem can make the programming much easier in this case  the insight is that a time object is really a three-digit number in base 60 ! the second component is the ones column  the minute component is the sixties column  and the hour component is the thirty-six hundreds column when we wrote addtime and increment  we were effectively doing addition in base 60  which is why we had to carry from one column to the next this observation suggests another approach to the whole problem we can convert a time object into a single number and take advantage of the fact that the computer knows how to do arithmetic with numbers the following function converts a time object into an integer  def converttoseconds  t   minutes = t.hours 60 + t.minutes seconds = minutes 60 + t.seconds return seconds now  all we need is a way to convert from an integer to a time object  def maketime  seconds   time = time   time.hours = seconds // 3600 time.minutes =  seconds % 3600  // 60 time.seconds = seconds % 60 return time you might have to think a bit to convince yourself that this function is correct assuming you are convinced  you can use it and converttoseconds to rewrite addtime  142 classes and functions def addtime  t1  t2   seconds = converttoseconds  t1  + converttoseconds  t2  return maketime  seconds  this version is much shorter than the original  and it is much easier to demonstrate that it is correct as an exercise  rewrite increment the same way 13.6 generalization in some ways  converting from base 60 to base 10 and back is harder than just dealing with times base conversion is more abstract ; our intuition for dealing with times is better but if we have the insight to treat times as base 60 numbers and make the investment of writing the conversion functions  converttoseconds and maketime   we get a program that is shorter  easier to read and debug  and more reliable it is also easier to add features later for example  imagine subtracting two times to find the duration between them the na ve approach would be to implement subtraction with borrowing using the conversion functions would be easier and more likely to be correct ironically  sometimes making a problem harder  or more general  makes it easier  because there are fewer special cases and fewer opportunities for error   13.7 algorithms when you write a general solution for a class of problems  as opposed to a specific solution to a single problem  you have written an algorithm we mentioned this word before but did not define it carefully it is not easy to define  so we will try a couple of approaches first  consider something that is not an algorithm when you learned to multiply single-digit numbers  you probably memorized the multiplication table in effect  you memorized 100 specific solutions that kind of knowledge is not algorithmic but if you were lazy  you probably cheated by learning a few tricks for example  to find the product of n and 9  you can write n 1 as the first digit and 10 n as the second digit this trick is a general solution for multiplying any single-digit number by 9 that s an algorithm ! 13.8 glossary 143 similarly  the techniques you learned for addition with carrying  subtraction with borrowing  and long division are all algorithms one of the characteristics of algorithms is that they do not require any intelligence to carry out they are mechanical processes in which each step follows from the last according to a simple set of rules in our opinion  it is embarrassing that humans spend so much time in school learning to execute algorithms that  quite literally  require no intelligence on the other hand  the process of designing algorithms is interesting  intellectually challenging  and a central part of what we call programming some of the things that people do naturally  without difficulty or conscious thought  are the hardest to express algorithmically understanding natural language is a good example we all do it  but so far no one has been able to explain how we do it  at least not in the form of an algorithm 13.8 glossary pure function  a function that does not modify any of the objects it receives as arguments most pure functions are fruitful modifier  a function that changes one or more of the objects it receives as arguments most modifiers are fruitless functional programming style  a style of program design in which the majority of functions are pure prototype development  a way of developing programs starting with a prototype and gradually testing and improving it planned development  a way of developing programs that involves high-level insight into the problem and more planning than incremental development or prototype development algorithm  a set of instructions for solving a class of problems by a mechanical  unintelligent process 144 classes and functions chapter 14 classes and methods 14.1 object-oriented features python is an object-oriented programming language  which means that it provides features that support object-oriented programming it is not easy to define object-oriented programming  but we have already seen some of its characteristics  programs are made up of object definitions and function definitions  and most of the computation is expressed in terms of operations on objects each object definition corresponds to some object or concept in the real world  and the functions that operate on that object correspond to the ways real-world objects interact for example  the time class defined in chapter 13 corresponds to the way people record the time of day  and the functions we defined correspond to the kinds of things people do with times similarly  the point and rectangle classes correspond to the mathematical concepts of a point and a rectangle so far  we have not taken advantage of the features python provides to support object-oriented programming strictly speaking  these features are not necessary for the most part  they provide an alternative syntax for things we have already done  but in many cases  the alternative is more concise and more accurately conveys the structure of the program for example  in the time program  there is no obvious connection between the class definition and the function definitions that follow with some examination  it is apparent that every function takes at least one time object as an argument 146 classes and methods this observation is the motivation for methods we have already seen some methods  such as keys and values  which were invoked on dictionaries each method is associated with a class and is intended to be invoked on instances of that class methods are just like functions  with two differences  methods are defined inside a class definition in order to make the relationship between the class and the method explicit the syntax for invoking a method is different from the syntax for calling a function in the next few sections  we will take the functions from the previous two chapters and transform them into methods this transformation is purely mechanical ; you can do it simply by following a sequence of steps if you are comfortable converting from one form to another  you will be able to choose the best form for whatever you are doing 14.2 printtime in chapter 13  we defined a class named time and you wrote a function named printtime  which should have looked something like this  class time  pass def printtime  time   print str  time.hours  +  + \ str  time.minutes  +  + \ str  time.seconds  to call this function  we passed a time object as an argument  > > > currenttime = time   > > > currenttime.hours = 9 > > > currenttime.minutes = 14 > > > currenttime.seconds = 30 > > > printtime  currenttime  to make printtime a method  all we have to do is move the function definition inside the class definition notice the change in indentation 14.3 another example 147 class time  def printtime  time   print str  time.hours  +  + \ str  time.minutes  +  + \ str  time.seconds  now we can invoke printtime using dot notation > > > currenttime.printtime   as usual  the object on which the method is invoked appears before the dot and the name of the method appears after the dot the object on which the method is invoked is assigned to the first parameter  so in this case currenttime is assigned to the parameter time by convention  the first parameter of a method is called self the reason for this is a little convoluted  but it is based on a useful metaphor the syntax for a function call  printtime  currenttime   suggests that the function is the active agent it says something like  hey printtime ! here s an object for you to print in object-oriented programming  the objects are the active agents an invocation like currenttime.printtime   says hey currenttime ! please print yourself ! this change in perspective might be more polite  but it is not obvious that it is useful in the examples we have seen so far  it may not be but sometimes shifting responsibility from the functions onto the objects makes it possible to write more versatile functions  and makes it easier to maintain and reuse code 14.3 another example let s convert increment  from section 13.3  to a method to save space  we will leave out previously defined methods  but you should keep them in your version  class time  # previous method definitions here def increment  self  seconds   self.seconds = seconds + self.seconds 148 classes and methods while self.seconds > = 60  self.seconds = self.seconds  60 self.minutes = self.minutes + 1 while self.minutes > = 60  self.minutes = self.minutes  60 self.hours = self.hours + 1 the transformation is purely mechanical we move the method definition into the class definition and change the name of the first parameter now we can invoke increment as a method currenttime.increment  500  again  the object on which the method is invoked gets assigned to the first parameter  self the second parameter  seconds gets the value 500 as an exercise  convert converttoseconds  from section 13.5  to a method in the time class 14.4 a more complicated example the after function is slightly more complicated because it operates on two time objects  not just one we can only convert one of the parameters to self ; the other stays the same  class time  # previous method definitions here def after  self  time2   if self.hour > time2.hour  return 1 if self.hour < time2.hour  return 0 if self.minute > time2.minute  return 1 if self.minute < time2.minute  return 0 if self.second > time2.second  return 1 return 0 14.5 optional arguments 149 we invoke this method on one object and pass the other as an argument  if donetime.after  currenttime   print the bread is not done yet you can almost read the invocation like english  if the done-time is after the current-time  then 14.5 optional arguments we have seen built-in functions that take a variable number of arguments for example  string.find can take two  three  or four arguments it is possible to write user-defined functions with optional argument lists for example  we can upgrade our own version of find to do the same thing as string.find this is the original version from section 7.7  def find  str  ch   index = 0 while index < len  str   if str  index  = = ch  return index index = index + 1 return -1 this is the new and improved version  def find  str  ch  start = 0   index = start while index < len  str   if str  index  = = ch  return index index = index + 1 return -1 the third parameter  start  is optional because a default value  0  is provided if we invoke find with only two arguments  it uses the default value and starts from the beginning of the string  > > > find  apple  p  1 if we provide a third argument  it overrides the default  150 classes and methods > > > find  apple  p  2  2 > > > find  apple  p  3  -1 as an exercise  add a fourth parameter  end  that specifies where to stop looking warning  this exercise is a bit tricky the default value of end should be len  str   but that doesn t work the default values are evaluated when the function is defined  not when it is called when find is defined  str doesn t exist yet  so you can t find its length 14.6 the initialization method the initialization method is a special method that is invoked when an object is created the name of this method is init  two underscore characters  followed by init  and then two more underscores   an initialization method for the time class looks like this  class time  def __init__  self  hours = 0  minutes = 0  seconds = 0   self.hours = hours self.minutes = minutes self.seconds = seconds there is no conflict between the attribute self.hours and the parameter hours dot notation specifies which variable we are referring to when we invoke the time constructor  the arguments we provide are passed along to init  > > > currenttime = time  9  14  30  > > > currenttime.printtime   9  14  30 because the arguments are optional  we can omit them  > > > currenttime = time   > > > currenttime.printtime   0  0  0 or provide only the first  14.7 points revisited 151 > > > currenttime = time  9  > > > currenttime.printtime   9  0  0 or the first two  > > > currenttime = time  9  14  > > > currenttime.printtime   9  14  0 finally  we can make assignments to a subset of the parameters by naming them explicitly  > > > currenttime = time  seconds = 30  hours = 9  > > > currenttime.printtime   9  0  30 14.7 points revisited let s rewrite the point class from section 12.1 in a more object-oriented style  class point  def __init__  self  x = 0  y = 0   self.x = x self.y = y def __str__  self   return  + str  self.x  +  + str  self.y  +  the initialization method takes x and y values as optional parameters ; the default for either parameter is 0 the next method  str  returns a string representation of a point object if a class provides a method named str  it overrides the default behavior of the python built-in str function > > > p = point  3  4  > > > str  p   3  4  printing a point object implicitly invokes str on the object  so defining str also changes the behavior of print  > > > p = point  3  4  > > > print p  3  4  152 classes and methods when we write a new class  we almost always start by writing init  which makes it easier to instantiate objects  and str  which is almost always useful for debugging 14.8 operator overloading some languages make it possible to change the definition of the built-in operators when they are applied to user-defined types this feature is called operator overloading it is especially useful when defining new mathematical types for example  to override the addition operator +  we provide a method named add  class point  # previously defined methods here def __add__  self  other   return point  self.x + other.x  self.y + other.y  as usual  the first parameter is the object on which the method is invoked the second parameter is conveniently named other to distinguish it from self to add two points  we create and return a new point that contains the sum of the x coordinates and the sum of the y coordinates now  when we apply the + operator to point objects  python invokes add  > > > p1 = point  3  4  > > > p2 = point  5  7  > > > p3 = p1 + p2 > > > print p3  8  11  the expression p1 + p2 is equivalent to p1 add  p2   but obviously more elegant as an exercise  add a method sub  self  other  that overloads the subtraction operator  and try it out there are several ways to override the behavior of the multiplication operator  by defining a method named mul  or rmul  or both if the left operand of is a point  python invokes mul  which assumes that the other operand is also a point it computes the dot product of the two points  defined according to the rules of linear algebra  14.9 polymorphism 153 def __mul__  self  other   return self.x other.x + self.y other.y if the left operand of is a primitive type and the right operand is a point  python invokes rmul  which performs scalar multiplication  def __rmul__  self  other   return point  other self.x  other self.y  the result is a new point whose coordinates are a multiple of the original coordinates if other is a type that can not be multiplied by a floating-point number  then rmul will yield an error this example demonstrates both kinds of multiplication  > > > p1 = point  3  4  > > > p2 = point  5  7  > > > print p1 p2 43 > > > print 2 p2  10  14  what happens if we try to evaluate p2 2 since the first operand is a point  python invokes mul with 2 as the second argument inside mul  the program tries to access the x coordinate of other  which fails because an integer has no attributes  > > > print p2 2 attributeerror  int object has no attribute x unfortunately  the error message is a bit opaque this example demonstrates some of the difficulties of object-oriented programming sometimes it is hard enough just to figure out what code is running for a more complete example of operator overloading  see appendix b 14.9 polymorphism most of the methods we have written only work for a specific type when you create a new object  you write methods that operate on that type but there are certain operations that you will want to apply to many types  such as the arithmetic operations in the previous sections if many types support the same set of operations  you can write functions that work on any of those types 154 classes and methods for example  the multadd operation  which is common in linear algebra  takes three arguments ; it multiplies the first two and then adds the third we can write it in python like this  def multadd  x  y  z   return x y + z this method will work for any values of x and y that can be multiplied and for any value of z that can be added to the product we can invoke it with numeric values  > > > multadd  3  2  1  7 or with points  > > > p1 = point  3  4  > > > p2 = point  5  7  > > > print multadd  2  p1  p2   11  15  > > > print multadd  p1  p2  1  44 in the first case  the point is multiplied by a scalar and then added to another point in the second case  the dot product yields a numeric value  so the third argument also has to be a numeric value a function like this that can take arguments with different types is called polymorphic as another example  consider the method frontandback  which prints a list twice  forward and backward  def frontandback  front   import copy back = copy.copy  front  back.reverse   print str  front  + str  back  because the reverse method is a modifier  we make a copy of the list before reversing it that way  this method doesn t modify the list it gets as an argument here s an example that applies frontandback to a list  > > > mylist =  1  2  3  4  > > > frontandback  mylist   1  2  3  4   4  3  2  1  14.10 glossary 155 of course  we intended to apply this function to lists  so it is not surprising that it works what would be surprising is if we could apply it to a point to determine whether a function can be applied to a new type  we apply the fundamental rule of polymorphism  if all of the operations inside the function can be applied to the type  the function can be applied to the type the operations in the method include copy  reverse  and print copy works on any object  and we have already written a str method for points  so all we need is a reverse method in the point class  def reverse  self   self.x  self.y = self.y  self.x then we can pass points to frontandback  > > > p = point  3  4  > > > frontandback  p   3  4   4  3  the best kind of polymorphism is the unintentional kind  where you discover that a function you have already written can be applied to a type for which you never planned 14.10 glossary object-oriented language  a language that provides features  such as userdefined classes and inheritance  that facilitate object-oriented programming object-oriented programming  a style of programming in which data and the operations that manipulate it are organized into classes and methods method  a function that is defined inside a class definition and is invoked on instances of that class override  to replace a default examples include replacing a default value with a particular argument and replacing a default method by providing a new method with the same name initialization method  a special method that is invoked automatically when a new object is created and that initializes the object s attributes 156 classes and methods operator overloading  extending built-in operators  +     >  > > card1 = card  1  11  > > > print card1 jack of diamonds class attributes like suitlist are shared by all card objects the advantage of this is that we can use any card object to access the class attributes  > > > card2 = card  1  3  > > > print card2 3 of diamonds > > > print card2.suitlist  1  diamonds 160 sets of objects the disadvantage is that if we modify a class attribute  it affects every instance of the class for example  if we decide that jack of diamonds should really be called jack of swirly whales  we could do this  > > > card1.suitlist  1  = swirly whales > > > print card1 jack of swirly whales the problem is that all of the diamonds just became swirly whales  > > > print card2 3 of swirly whales it is usually not a good idea to modify class attributes 15.4 comparing cards for primitive types  there are conditional operators   = =  etc  that compare values and determine when one is greater than  less than  or equal to another for user-defined types  we can override the behavior of the built-in operators by providing a method named cmp  by convention  cmp has two parameters  self and other  and returns 1 if the first object is greater  -1 if the second object is greater  and 0 if they are equal to each other some types are completely ordered  which means that you can compare any two elements and tell which is bigger for example  the integers and the floatingpoint numbers are completely ordered some sets are unordered  which means that there is no meaningful way to say that one element is bigger than another for example  the fruits are unordered  which is why you can not compare apples and oranges the set of playing cards is partially ordered  which means that sometimes you can compare cards and sometimes not for example  you know that the 3 of clubs is higher than the 2 of clubs  and the 3 of diamonds is higher than the 3 of clubs but which is better  the 3 of clubs or the 2 of diamonds one has a higher rank  but the other has a higher suit in order to make cards comparable  you have to decide which is more important  rank or suit to be honest  the choice is arbitrary for the sake of choosing  we will say that suit is more important  because a new deck of cards comes sorted with all the clubs together  followed by all the diamonds  and so on with that decided  we can write cmp  15.5 decks 161 def __cmp__  self  other   # check the suits if self.suit > other.suit  return 1 if self.suit < other.suit  return -1 # suits are the same check ranks if self.rank > other.rank  return 1 if self.rank < other.rank  return -1 # ranks are the same it s a tie return 0 in this ordering  aces appear lower than deuces  2s   as an exercise  modify cmp so that aces are ranked higher than kings 15.5 decks now that we have objects to represent cards  the next logical step is to define a class to represent a deck of course  a deck is made up of cards  so each deck object will contain a list of cards as an attribute the following is a class definition for the deck class the initialization method creates the attribute cards and generates the standard set of fifty-two cards  class deck  def __init__  self   self.cards =   for suit in range  4   for rank in range  1  14   self.cards.append  card  suit  rank   the easiest way to populate the deck is with a nested loop the outer loop enumerates the suits from 0 to 3 the inner loop enumerates the ranks from 1 to 13 since the outer loop iterates four times  and the inner loop iterates thirteen times  the total number of times the body is executed is fifty-two  thirteen times four   each iteration creates a new instance of card with the current suit and rank  and appends that card to the cards list the append method works on lists but not  of course  tuples 15.6 printing the deck as usual  when we define a new type of object we want a method that prints the contents of an object to print a deck  we traverse the list and print each card  162 sets of objects class deck   def printdeck  self   for card in self.cards  print card here  and from now on  the ellipsis    indicates that we have omitted the other methods in the class as an alternative to printdeck  we could write a str method for the deck class the advantage of str is that it is more flexible rather than just printing the contents of the object  it generates a string representation that other parts of the program can manipulate before printing  or store for later use here is a version of str that returns a string representation of a deck to add a bit of pizzazz  it arranges the cards in a cascade where each card is indented one space more than the previous card  class deck   def __str__  self   s = for i in range  len  self.cards    s = s + i + str  self.cards  i   + \ n return s this example demonstrates several features first  instead of traversing self.cards and assigning each card to a variable  we are using i as a loop variable and an index into the list of cards second  we are using the string multiplication operator to indent each card by one more space than the last the expression i yields a number of spaces equal to the current value of i third  instead of using the print command to print the cards  we use the str function passing an object as an argument to str is equivalent to invoking the str method on the object finally  we are using the variable s as an accumulator initially  s is the empty string each time through the loop  a new string is generated and concatenated with the old value of s to get the new value when the loop ends  s contains the complete string representation of the deck  which looks like this  15.7 shuffling the deck 163 > > > deck = deck   > > > print deck ace of clubs 2 of clubs 3 of clubs 4 of clubs 5 of clubs 6 of clubs 7 of clubs 8 of clubs 9 of clubs 10 of clubs jack of clubs queen of clubs king of clubs ace of diamonds and so on even though the result appears on 52 lines  it is one long string that contains newlines 15.7 shuffling the deck if a deck is perfectly shuffled  then any card is equally likely to appear anywhere in the deck  and any location in the deck is equally likely to contain any card to shuffle the deck  we will use the randrange function from the random module with two integer arguments  a and b  randrange chooses a random integer in the range a < = x < b since the upper bound is strictly less than b  we can use the length of a list as the second argument  and we are guaranteed to get a legal index for example  this expression chooses the index of a random card in a deck  random.randrange  0  len  self.cards   an easy way to shuffle the deck is by traversing the cards and swapping each card with a randomly chosen one it is possible that the card will be swapped with itself  but that is fine in fact  if we precluded that possibility  the order of the cards would be less than entirely random  164 sets of objects class deck   def shuffle  self   import random ncards = len  self.cards  for i in range  ncards   j = random.randrange  i  ncards  self.cards  i   self.cards  j  = self.cards  j   self.cards  i  rather than assume that there are fifty-two cards in the deck  we get the actual length of the list and store it in ncards for each card in the deck  we choose a random card from among the cards that haven t been shuffled yet then we swap the current card  i  with the selected card  j   to swap the cards we use a tuple assignment  as in section 9.2  self.cards  i   self.cards  j  = self.cards  j   self.cards  i  as an exercise  rewrite this line of code without using a sequence assignment 15.8 removing and dealing cards another method that would be useful for the deck class is removecard  which takes a card as an argument  removes it  and returns true if the card was in the deck and false otherwise  class deck   def removecard  self  card   if card in self.cards  self.cards.remove  card  return true else  return false the in operator returns true if the first operand is in the second  which must be a list or a tuple if the first operand is an object  python uses the object s cmp method to determine equality with items in the list since the cmp in the card class checks for deep equality  the removecard method checks for deep equality to deal cards  we want to remove and return the top card the list method pop provides a convenient way to do that  15.9 glossary 165 class deck   def popcard  self   return self.cards.pop   actually  pop removes the last card in the list  so we are in effect dealing from the bottom of the deck one more operation that we are likely to want is the boolean function isempty  which returns true if the deck contains no cards  class deck   def isempty  self   return  len  self.cards  = = 0  15.9 glossary encode  to represent one set of values using another set of values by constructing a mapping between them class attribute  a variable that is defined inside a class definition but outside any method class attributes are accessible from any method in the class and are shared by all instances of the class accumulator  a variable used in a loop to accumulate a series of values  such as by concatenating them onto a string or adding them to a running sum 166 sets of objects chapter 16 inheritance 16.1 inheritance the language feature most often associated with object-oriented programming is inheritance inheritance is the ability to define a new class that is a modified version of an existing class the primary advantage of this feature is that you can add new methods to a class without modifying the existing class it is called inheritance because the new class inherits all of the methods of the existing class extending this metaphor  the existing class is sometimes called the parent class the new class may be called the child class or sometimes subclass inheritance is a powerful feature some programs that would be complicated without inheritance can be written concisely and simply with it also  inheritance can facilitate code reuse  since you can customize the behavior of parent classes without having to modify them in some cases  the inheritance structure reflects the natural structure of the problem  which makes the program easier to understand on the other hand  inheritance can make programs difficult to read when a method is invoked  it is sometimes not clear where to find its definition the relevant code may be scattered among several modules also  many of the things that can be done using inheritance can be done as elegantly  or more so  without it if the natural structure of the problem does not lend itself to inheritance  this style of programming can do more harm than good in this chapter we will demonstrate the use of inheritance as part of a program that plays the card game old maid one of our goals is to write code that could be reused to implement other card games 168 inheritance 16.2 a hand of cards for almost any card game  we need to represent a hand of cards a hand is similar to a deck  of course both are made up of a set of cards  and both require operations like adding and removing cards also  we might like the ability to shuffle both decks and hands a hand is also different from a deck depending on the game being played  we might want to perform some operations on hands that don t make sense for a deck for example  in poker we might classify a hand  straight  flush  etc  or compare it with another hand in bridge  we might want to compute a score for a hand in order to make a bid this situation suggests the use of inheritance if hand is a subclass of deck  it will have all the methods of deck  and new methods can be added in the class definition  the name of the parent class appears in parentheses  class hand  deck   pass this statement indicates that the new hand class inherits from the existing deck class the hand constructor initializes the attributes for the hand  which are name and cards the string name identifies this hand  probably by the name of the player that holds it the name is an optional parameter with the empty string as a default value cards is the list of cards in the hand  initialized to the empty list  class hand  deck   def __init__  self  name =   self.cards =   self.name = name for just about any card game  it is necessary to add and remove cards from the deck removing cards is already taken care of  since hand inherits removecard from deck but we have to write addcard  class hand  deck    def addcard  self,card   self.cards.append  card  again  the ellipsis indicates that we have omitted other methods the list append method adds the new card to the end of the list of cards 16.3 dealing cards 169 16.3 dealing cards now that we have a hand class  we want to deal cards from the deck into hands it is not immediately obvious whether this method should go in the hand class or in the deck class  but since it operates on a single deck and  possibly  several hands  it is more natural to put it in deck deal should be fairly general  since different games will have different requirements we may want to deal out the entire deck at once or add one card to each hand deal takes two arguments  a list  or tuple  of hands and the total number of cards to deal if there are not enough cards in the deck  the method deals out all of the cards and stops  class deck   def deal  self  hands  ncards = 999   nhands = len  hands  for i in range  ncards   if self.isempty    break # break if out of cards card = self.popcard   # take the top card hand = hands  i % nhands  # whose turn is next hand.addcard  card  # add the card to the hand the second parameter  ncards  is optional ; the default is a large number  which effectively means that all of the cards in the deck will get dealt the loop variable i goes from 0 to ncards-1 each time through the loop  a card is removed from the deck using the list method pop  which removes and returns the last item in the list the modulus operator  %  allows us to deal cards in a round robin  one card at a time to each hand   when i is equal to the number of hands in the list  the expression i % nhands wraps around to the beginning of the list  index 0   16.4 printing a hand to print the contents of a hand  we can take advantage of the printdeck and str methods inherited from deck for example  170 inheritance > > > deck = deck   > > > deck.shuffle   > > > hand = hand  frank  > > > deck.deal   hand   5  > > > print hand hand frank contains 2 of spades 3 of spades 4 of spades ace of hearts 9 of clubs it s not a great hand  but it has the makings of a straight flush although it is convenient to inherit the existing methods  there is additional information in a hand object we might want to include when we print one to do that  we can provide a str method in the hand class that overrides the one in the deck class  class hand  deck   def __str__  self   s = hand + self.name if self.isempty    return s + is empty \ n else  return s + contains \ n + deck.__str__  self  initially  s is a string that identifies the hand if the hand is empty  the program appends the words is empty and returns the result otherwise  the program appends the word contains and the string representation of the deck  computed by invoking the str method in the deck class on self it may seem odd to send self  which refers to the current hand  to a deck method  until you remember that a hand is a kind of deck hand objects can do everything deck objects can  so it is legal to send a hand to a deck method in general  it is always legal to use an instance of a subclass in place of an instance of a parent class 16.5 the cardgame class 171 16.5 the cardgame class the cardgame class takes care of some basic chores common to all games  such as creating the deck and shuffling it  class cardgame  def __init__  self   self.deck = deck   self.deck.shuffle   this is the first case we have seen where the initialization method performs a significant computation  beyond initializing attributes to implement specific games  we can inherit from cardgame and add features for the new game as an example  we ll write a simulation of old maid the object of old maid is to get rid of cards in your hand you do this by matching cards by rank and color for example  the 4 of clubs matches the 4 of spades since both suits are black the jack of hearts matches the jack of diamonds since both are red to begin the game  the queen of clubs is removed from the deck so that the queen of spades has no match the fifty-one remaining cards are dealt to the players in a round robin after the deal  all players match and discard as many cards as possible when no more matches can be made  play begins in turn  each player picks a card  without looking  from the closest neighbor to the left who still has cards if the chosen card matches a card in the player s hand  the pair is removed otherwise  the card is added to the player s hand eventually all possible matches are made  leaving only the queen of spades in the loser s hand in our computer simulation of the game  the computer plays all hands unfortunately  some nuances of the real game are lost in a real game  the player with the old maid goes to some effort to get their neighbor to pick that card  by displaying it a little more prominently  or perhaps failing to display it more prominently  or even failing to fail to display that card more prominently the computer simply picks a neighbor s card at random 16.6 oldmaidhand class a hand for playing old maid requires some abilities beyond the general abilities of a hand we will define a new class  oldmaidhand  that inherits from hand and provides an additional method called removematches  172 inheritance class oldmaidhand  hand   def removematches  self   count = 0 originalcards = self.cards    for card in originalcards  match = card  3  card.suit  card.rank  if match in self.cards  self.cards.remove  card  self.cards.remove  match  print hand % s  % s matches % s %  self.name,card,match  count = count + 1 return count we start by making a copy of the list of cards  so that we can traverse the copy while removing cards from the original since self.cards is modified in the loop  we don t want to use it to control the traversal python can get quite confused if it is traversing a list that is changing ! for each card in the hand  we figure out what the matching card is and go looking for it the match card has the same rank and the other suit of the same color the expression 3  card.suit turns a club  suit 0  into a spade  suit 3  and a diamond  suit 1  into a heart  suit 2   you should satisfy yourself that the opposite operations also work if the match card is also in the hand  both cards are removed the following example demonstrates how to use removematches  > > > game = cardgame   > > > hand = oldmaidhand  frank  > > > game.deck.deal   hand   13  > > > print hand hand frank contains ace of spades 2 of diamonds 7 of spades 8 of clubs 6 of hearts 8 of spades 7 of clubs queen of clubs 7 of diamonds 5 of clubs jack of diamonds 10 of diamonds 10 of hearts 16.7 oldmaidgame class 173 > > > hand.removematches   hand frank  7 of spades matches 7 of clubs hand frank  8 of spades matches 8 of clubs hand frank  10 of diamonds matches 10 of hearts > > > print hand hand frank contains ace of spades 2 of diamonds 6 of hearts queen of clubs 7 of diamonds 5 of clubs jack of diamonds notice that there is no init method for the oldmaidhand class we inherit it from hand 16.7 oldmaidgame class now we can turn our attention to the game itself oldmaidgame is a subclass of cardgame with a new method called play that takes a list of players as an argument since init is inherited from cardgame  a new oldmaidgame object contains a new shuffled deck  class oldmaidgame  cardgame   def play  self  names   # remove queen of clubs self.deck.removecard  card  0,12   # make a hand for each player self.hands =   for name in names  self.hands.append  oldmaidhand  name   # deal the cards self.deck.deal  self.hands  print  cards have been dealt self.printhands   174 inheritance # remove initial matches matches = self.removeallmatches   print  matches discarded  play begins self.printhands   # play until all 50 cards are matched turn = 0 numhands = len  self.hands  while matches < 25  matches = matches + self.playoneturn  turn  turn =  turn + 1  % numhands print  game is over self.printhands   some of the steps of the game have been separated into methods removeallmatches traverses the list of hands and invokes removematches on each  class oldmaidgame  cardgame    def removeallmatches  self   count = 0 for hand in self.hands  count = count + hand.removematches   return count as an exercise  write printhands which traverses self.hands and prints each hand count is an accumulator that adds up the number of matches in each hand and returns the total when the total number of matches reaches twenty-five  fifty cards have been removed from the hands  which means that only one card is left and the game is over the variable turn keeps track of which player s turn it is it starts at 0 and increases by one each time ; when it reaches numhands  the modulus operator wraps it back around to 0 the method playoneturn takes an argument that indicates whose turn it is the return value is the number of matches made during this turn  16.7 oldmaidgame class 175 class oldmaidgame  cardgame    def playoneturn  self  i   if self.hands  i  .isempty    return 0 neighbor = self.findneighbor  i  pickedcard = self.hands  neighbor  .popcard   self.hands  i  .addcard  pickedcard  print hand  self.hands  i  .name  picked  pickedcard count = self.hands  i  .removematches   self.hands  i  .shuffle   return count if a player s hand is empty  that player is out of the game  so he or she does nothing and returns 0 otherwise  a turn consists of finding the first player on the left that has cards  taking one card from the neighbor  and checking for matches before returning  the cards in the hand are shuffled so that the next player s choice is random the method findneighbor starts with the player to the immediate left and continues around the circle until it finds a player that still has cards  class oldmaidgame  cardgame    def findneighbor  self  i   numhands = len  self.hands  for next in range  1,numhands   neighbor =  i + next  % numhands if not self.hands  neighbor  .isempty    return neighbor if findneighbor ever went all the way around the circle without finding cards  it would return none and cause an error elsewhere in the program fortunately  we can prove that that will never happen  as long as the end of the game is detected correctly   we have omitted the printhands method you can write that one yourself the following output is from a truncated form of the game where only the top fifteen cards  tens and higher  were dealt to three players with this small deck  play stops after seven matches instead of twenty-five > > > import cards > > > game = cards.oldmaidgame   > > > game.play   allen,jeff,chris   176 inheritance  cards have been dealt hand allen contains king of hearts jack of clubs queen of spades king of spades 10 of diamonds hand jeff contains queen of hearts jack of spades jack of hearts king of diamonds queen of diamonds hand chris contains jack of diamonds king of clubs 10 of spades 10 of hearts 10 of clubs hand jeff  queen of hearts matches queen of diamonds hand chris  10 of spades matches 10 of clubs  matches discarded  play begins hand allen contains king of hearts jack of clubs queen of spades king of spades 10 of diamonds hand jeff contains jack of spades jack of hearts king of diamonds hand chris contains jack of diamonds king of clubs 10 of hearts 16.8 glossary 177 hand allen picked king of diamonds hand allen  king of hearts matches king of diamonds hand jeff picked 10 of hearts hand chris picked jack of clubs hand allen picked jack of hearts hand jeff picked jack of diamonds hand chris picked queen of spades hand allen picked jack of diamonds hand allen  jack of hearts matches jack of diamonds hand jeff picked king of clubs hand chris picked king of spades hand allen picked 10 of hearts hand allen  10 of diamonds matches 10 of hearts hand jeff picked queen of spades hand chris picked jack of spades hand chris  jack of clubs matches jack of spades hand jeff picked king of spades hand jeff  king of clubs matches king of spades  game is over hand allen is empty hand jeff contains queen of spades hand chris is empty so jeff loses 16.8 glossary inheritance  the ability to define a new class that is a modified version of a previously defined class parent class  the class from which a child class inherits child class  a new class created by inheriting from an existing class ; also called a subclass 178 inheritance chapter 17 linked lists 17.1 embedded references we have seen examples of attributes that refer to other objects  which we called embedded references  see section 12.8   a common data structure  the linked list  takes advantage of this feature linked lists are made up of nodes  where each node contains a reference to the next node in the list in addition  each node contains a unit of data called the cargo a linked list is considered a recursive data structure because it has a recursive definition a linked list is either  the empty list  represented by none  or a node that contains a cargo object and a reference to a linked list recursive data structures lend themselves to recursive methods 17.2 the node class as usual when writing a new class  we ll start with the initialization and str methods so that we can test the basic mechanism of creating and displaying the new type  180 linked lists class node  def __init__  self  cargo = none  next = none   self.cargo = cargo self.next = next def __str__  self   return str  self.cargo  as usual  the parameters for the initialization method are optional by default  both the cargo and the link  next  are set to none the string representation of a node is just the string representation of the cargo since any value can be passed to the str function  we can store any value in a list to test the implementation so far  we can create a node and print it  > > > node = node  test  > > > print node test to make it interesting  we need a list with more than one node  > > > node1 = node  1  > > > node2 = node  2  > > > node3 = node  3  this code creates three nodes  but we don t have a list yet because the nodes are not linked the state diagram looks like this  cargo next 2 node2 none cargo next 1 node1 none cargo next 3 node3 none to link the nodes  we have to make the first node refer to the second and the second node refer to the third  > > > node1.next = node2 > > > node2.next = node3 the reference of the third node is none  which indicates that it is the end of the list now the state diagram looks like this  17.3 lists as collections 181 cargo next 1 node1 cargo next 2 node2 cargo next 3 node3 none now you know how to create nodes and link them into lists what might be less clear at this point is why 17.3 lists as collections lists are useful because they provide a way to assemble multiple objects into a single entity  sometimes called a collection in the example  the first node of the list serves as a reference to the entire list to pass the list as an argument  we only have to pass a reference to the first node for example  the function printlist takes a single node as an argument starting with the head of the list  it prints each node until it gets to the end  def printlist  node   while node  print node  node = node.next print to invoke this function  we pass a reference to the first node  > > > printlist  node1  1 2 3 inside printlist we have a reference to the first node of the list  but there is no variable that refers to the other nodes we have to use the next value from each node to get to the next node to traverse a linked list  it is common to use a loop variable like node to refer to each of the nodes in succession this diagram shows the nodes in the list and the values that node takes on  182 linked lists node1 cargo y 1 cargo y 2 node2 cargo y 3 node3 none node by convention  lists are often printed in brackets with commas between the elements  as in  1  2  3   as an exercise  modify printlist so that it generates output in this format 17.4 lists and recursion it is natural to express many list operations using recursive methods for example  the following is a recursive algorithm for printing a list backwards  1 separate the list into two pieces  the first node  called the head  ; and the rest  called the tail   2 print the tail backward 3 print the head of course  step 2  the recursive call  assumes that we have a way of printing a list backward but if we assume that the recursive call works the leap of faith then we can convince ourselves that this algorithm works all we need are a base case and a way of proving that for any list  we will eventually get to the base case given the recursive definition of a list  a natural base case is the empty list  represented by none  def printbackward  list   if list = = none  return head = list tail = list.next printbackward  tail  print head  the first line handles the base case by doing nothing the next two lines split the list into head and tail the last two lines print the list the comma at the end of the last line keeps python from printing a newline after each node 17.5 infinite lists 183 we invoke this function as we invoked printlist  > > > printbackward  node1  3 2 1 the result is a backward list you might wonder why printlist and printbackward are functions and not methods in the node class the reason is that we want to use none to represent the empty list and it is not legal to invoke a method on none this limitation makes it awkward to write list-manipulating code in a clean object-oriented style can we prove that printbackward will always terminate in other words  will it always reach the base case in fact  the answer is no some lists will make this function crash 17.5 infinite lists there is nothing to prevent a node from referring back to an earlier node in the list  including itself for example  this figure shows a list with two nodes  one of which refers to itself  cargo next 1 cargo next 2 list if we invoke printlist on this list  it will loop forever if we invoke printbackward  it will recurse infinitely this sort of behavior makes infinite lists difficult to work with nevertheless  they are occasionally useful for example  we might represent a number as a list of digits and use an infinite list to represent a repeating fraction regardless  it is problematic that we can not prove that printlist and printbackward terminate the best we can do is the hypothetical statement  if the list contains no loops  then these functions will terminate this sort of claim is called a precondition it imposes a constraint on one of the arguments and describes the behavior of the function if the constraint is satisfied you will see more examples soon 184 linked lists 17.6 the fundamental ambiguity theorem one part of printbackward might have raised an eyebrow  head = list tail = list.next after the first assignment  head and list have the same type and the same value so why did we create a new variable the reason is that the two variables play different roles we think of head as a reference to a single node  and we think of list as a reference to the first node of a list these roles are not part of the program ; they are in the mind of the programmer in general we can t tell by looking at a program what role a variable plays this ambiguity can be useful  but it can also make programs difficult to read we often use variable names like node and list to document how we intend to use a variable and sometimes create additional variables to disambiguate we could have written printbackward without head and tail  which makes it more concise but possibly less clear  def printbackward  list   if list = = none  return printbackward  list.next  print list  looking at the two function calls  we have to remember that printbackward treats its argument as a collection and print treats its argument as a single object the fundamental ambiguity theorem describes the ambiguity that is inherent in a reference to a node  a variable that refers to a node might treat the node as a single object or as the first in a list of nodes 17.7 modifying lists there are two ways to modify a linked list obviously  we can change the cargo of one of the nodes  but the more interesting operations are the ones that add  remove  or reorder the nodes as an example  let s write a function that removes the second node in the list and returns a reference to the removed node  17.8 wrappers and helpers 185 def removesecond  list   if list = = none  return first = list second = list.next # make the first node refer to the third first.next = second.next # separate the second node from the rest of the list second.next = none return second again  we are using temporary variables to make the code more readable here is how to use this function  > > > printlist  node1  1 2 3 > > > removed = removesecond  node1  > > > printlist  removed  2 > > > printlist  node1  1 3 this state diagram shows the effect of the operation  cargo next 1 cargo next 2 second cargo next 3 none first what happens if you invoke this function and pass a list with only one element  a singleton  what happens if you pass the empty list as an argument is there a precondition for this function if so  fix the function to handle a violation of the precondition in a reasonable way 17.8 wrappers and helpers it is often useful to divide a list operation into two functions for example  to print a list backward in the format  3 2 1  we can use the printbackward function to print 3 2 1 but we need a separate function to print the brackets let s call it printbackwardnicely  186 linked lists def printbackwardnicely  list   print   printbackward  list  print   again  it is a good idea to check functions like this to see if they work with special cases like an empty list or a singleton when we use this function elsewhere in the program  we invoke printbackwardnicely directly  and it invokes printbackward on our behalf in that sense  printbackwardnicely acts as a wrapper  and it uses printbackward as a helper 17.9 the linkedlist class there are some subtle problems with the way we have been implementing lists in a reversal of cause and effect  we ll propose an alternative implementation first and then explain what problems it solves first  we ll create a new class called linkedlist its attributes are an integer that contains the length of the list and a reference to the first node linkedlist objects serve as handles for manipulating lists of node objects  class linkedlist  def __init__  self   self.length = 0 self.head = none one nice thing about the linkedlist class is that it provides a natural place to put wrapper functions like printbackwardnicely  which we can make a method of the linkedlist class  class linkedlist   def printbackward  self   print   if self.head ! = none  self.head.printbackward   print   class node   def printbackward  self   if self.next ! = none  17.10 invariants 187 tail = self.next tail.printbackward   print self.cargo  just to make things confusing  we renamed printbackwardnicely now there are two methods named printbackward  one in the node class  the helper  ; and one in the linkedlist class  the wrapper   when the wrapper invokes self.head.printbackward  it is invoking the helper  because self.head is a node object another benefit of the linkedlist class is that it makes it easier to add or remove the first element of a list for example  addfirst is a method for linkedlists ; it takes an item of cargo as an argument and puts it at the beginning of the list  class linkedlist   def addfirst  self  cargo   node = node  cargo  node.next = self.head self.head = node self.length = self.length + 1 as usual  you should check code like this to see if it handles the special cases for example  what happens if the list is initially empty 17.10 invariants some lists are well formed ; others are not for example  if a list contains a loop  it will cause many of our methods to crash  so we might want to require that lists contain no loops another requirement is that the length value in the linkedlist object should be equal to the actual number of nodes in the list requirements like these are called invariants because  ideally  they should be true of every object all the time specifying invariants for objects is a useful programming practice because it makes it easier to prove the correctness of code  check the integrity of data structures  and detect errors one thing that is sometimes confusing about invariants is that there are times when they are violated for example  in the middle of addfirst  after we have added the node but before we have incremented length  the invariant is violated this kind of violation is acceptable ; in fact  it is often impossible to modify an object without violating an invariant for at least a little while 188 linked lists normally  we require that every method that violates an invariant must restore the invariant if there is any significant stretch of code in which the invariant is violated  it is important for the comments to make that clear  so that no operations are performed that depend on the invariant 17.11 glossary embedded reference  a reference stored in an attribute of an object linked list  a data structure that implements a collection using a sequence of linked nodes node  an element of a list  usually implemented as an object that contains a reference to another object of the same type cargo  an item of data contained in a node link  an embedded reference used to link one object to another precondition  an assertion that must be true in order for a method to work correctly fundamental ambiguity theorem  a reference to a list node can be treated as a single object or as the first in a list of nodes singleton  a linked list with a single node wrapper  a method that acts as a middleman between a caller and a helper method  often making the method easier or less error-prone to invoke helper  a method that is not invoked directly by a caller but is used by another method to perform part of an operation invariant  an assertion that should be true of an object at all times  except perhaps while the object is being modified   chapter 18 stacks 18.1 abstract data types the data types you have seen so far are all concrete  in the sense that we have completely specified how they are implemented for example  the card class represents a card using two integers as we discussed at the time  that is not the only way to represent a card ; there are many alternative implementations an abstract data type  or adt  specifies a set of operations  or methods  and the semantics of the operations  what they do   but it does not specify the implementation of the operations that s what makes it abstract why is that useful it simplifies the task of specifying an algorithm if you can denote the operations you need without having to think at the same time about how the operations are performed since there are usually many ways to implement an adt  it might be useful to write an algorithm that can be used with any of the possible implementations well-known adts  such as the stack adt in this chapter  are often implemented in standard libraries so they can be written once and used by many programmers the operations on adts provide a common high-level language for specifying and talking about algorithms 190 stacks when we talk about adts  we often distinguish the code that uses the adt  called the client code  from the code that implements the adt  called the provider code 18.2 the stack adt in this chapter  we will look at one common adt  the stack a stack is a collection  meaning that it is a data structure that contains multiple elements other collections we have seen include dictionaries and lists an adt is defined by the operations that can be performed on it  which is called an interface the interface for a stack consists of these operations  init  initialize a new empty stack push  add a new item to the stack pop  remove and return an item from the stack the item that is returned is always the last one that was added isempty  check whether the stack is empty a stack is sometimes called a last in  first out or lifo data structure  because the last item added is the first to be removed 18.3 implementing stacks with python lists the list operations that python provides are similar to the operations that define a stack the interface isn t exactly what it is supposed to be  but we can write code to translate from the stack adt to the built-in operations this code is called an implementation of the stack adt in general  an implementation is a set of methods that satisfy the syntactic and semantic requirements of an interface here is an implementation of the stack adt that uses a python list  class stack  def __init__  self   self.items =   def push  self  item   self.items.append  item  18.4 pushing and popping 191 def pop  self   return self.items.pop   def isempty  self   return  self.items = =    a stack object contains an attribute named items that is a list of items in the stack the initialization method sets items to the empty list to push a new item onto the stack  push appends it onto items to pop an item off the stack  pop uses the homonymous1 list method to remove and return the last item on the list finally  to check if the stack is empty  isempty compares items to the empty list an implementation like this  in which the methods consist of simple invocations of existing methods  is called a veneer in real life  veneer is a thin coating of good quality wood used in furniture-making to hide lower quality wood underneath computer scientists use this metaphor to describe a small piece of code that hides the details of an implementation and provides a simpler  or more standard  interface 18.4 pushing and popping a stack is a generic data structure  which means that we can add any type of item to it the following example pushes two integers and a string onto the stack  > > > s = stack   > > > s.push  54  > > > s.push  45  > > > s.push  +  we can use isempty and pop to remove and print all of the items on the stack  while not s.isempty    print s.pop    the output is + 45 54 in other words  we just used a stack to print the items backward ! granted  it s not the standard format for printing a list  but by using a stack  it was remarkably easy to do 1 same-named 192 stacks you should compare this bit of code to the implementation of printbackward in section 17.4 there is a natural parallel between the recursive version of printbackward and the stack algorithm here the difference is that printbackward uses the runtime stack to keep track of the nodes while it traverses the list  and then prints them on the way back from the recursion the stack algorithm does the same thing  except that it uses a stack object instead of the runtime stack 18.5 using a stack to evaluate postfix in most programming languages  mathematical expressions are written with the operator between the two operands  as in 1 + 2 this format is called infix an alternative used by some calculators is called postfix in postfix  the operator follows the operands  as in 1 2 +  the reason postfix is sometimes useful is that there is a natural way to evaluate a postfix expression using a stack  starting at the beginning of the expression  get one term  operator or operand  at a time if the term is an operand  push it on the stack if the term is an operator  pop two operands off the stack  perform the operation on them  and push the result back on the stack when you get to the end of the expression  there should be exactly one operand left on the stack that operand is the result as an exercise  apply this algorithm to the expression 1 2 + 3  this example demonstrates one of the advantages of postfix there is no need to use parentheses to control the order of operations to get the same result in infix  we would have to write  1 + 2  3 as an exercise  write a postfix expression that is equivalent to 1 + 2 3 18.6 parsing to implement the previous algorithm  we need to be able to traverse a string and break it into operands and operators this process is an example of parsing  18.7 evaluating postfix 193 and the results the individual chunks of the string are called tokens you might remember these words from chapter 1 python provides a split method in both the string and re  regular expression  modules the function string.split splits a string into a list using a single character as a delimiter for example  > > > import string > > > string.split  now is the time    now  is  the  time  in this case  the delimiter is the space character  so the string is split at each space the function re.split is more powerful  allowing us to provide a regular expression instead of a delimiter a regular expression is a way of specifying a set of strings for example   a-z  is the set of all letters and  0-9  is the set of all digits the ^ operator negates a set  so  ^ 0-9  is the set of every character that is not a digit  which is exactly the set we want to use to split up postfix expressions  > > > import re > > > re.split    ^ 0-9    123 + 456 /   123  +  456    /   notice that the order of the arguments is different from string.split ; the delimiter comes before the string the resulting list includes the operands 123 and 456 and the operators and / it also includes two empty strings that are inserted as phantom operands  whenever an operator appears without a number before or after it 18.7 evaluating postfix to evaluate a postfix expression  we will use the parser from the previous section and the algorithm from the section before that to keep things simple  we ll start with an evaluator that only implements the operators + and  194 stacks def evalpostfix  expr   import re tokenlist = re.split    ^ 0-9    expr  stack = stack   for token in tokenlist  if token = = or token = =  continue if token = = +  sum = stack.pop   + stack.pop   stack.push  sum  elif token = =  product = stack.pop   stack.pop   stack.push  product  else  stack.push  int  token   return stack.pop   the first condition takes care of spaces and empty strings the next two conditions handle operators we assume  for now  that anything else must be an operand of course  it would be better to check for erroneous input and report an error message  but we ll get to that later let s test it by evaluating the postfix form of  56 + 47  2  > > > print evalpostfix  56 47 + 2  206 that s close enough 18.8 clients and providers one of the fundamental goals of an adt is to separate the interests of the provider  who writes the code that implements the adt  and the client  who uses the adt the provider only has to worry about whether the implementation is correct in accord with the specification of the adt and not how it will be used conversely  the client assumes that the implementation of the adt is correct and doesn t worry about the details when you are using one of python s built-in types  you have the luxury of thinking exclusively as a client of course  when you implement an adt  you also have to write client code to test it in that case  you play both roles  which can be confusing you should make some effort to keep track of which role you are playing at any moment 18.9 glossary 195 18.9 glossary abstract data type  adt   a data type  usually a collection of objects  that is defined by a set of operations but that can be implemented in a variety of ways interface  the set of operations that define an adt implementation  code that satisfies the syntactic and semantic requirements of an interface client  a program  or the person who wrote it  that uses an adt provider  the code  or the person who wrote it  that implements an adt veneer  a class definition that implements an adt with method definitions that are invocations of other methods  sometimes with simple transformations the veneer does no significant work  but it improves or standardizes the interface seen by the client generic data structure  a kind of data structure that can contain data of any type infix  a way of writing mathematical expressions with the operators between the operands postfix  a way of writing mathematical expressions with the operators after the operands parse  to read a string of characters or tokens and analyze its grammatical structure token  a set of characters that are treated as a unit for purposes of parsing  such as the words in a natural language delimiter  a character that is used to separate tokens  such as punctuation in a natural language 196 stacks chapter 19 queues this chapter presents two adts  the queue and the priority queue in real life  a queue is a line of customers waiting for service of some kind in most cases  the first customer in line is the next customer to be served there are exceptions  though at airports  customers whose flights are leaving soon are sometimes taken from the middle of the queue at supermarkets  a polite customer might let someone with only a few items go first the rule that determines who goes next is called the queueing policy the simplest queueing policy is called fifo  for first-in-first-out the most general queueing policy is priority queueing  in which each customer is assigned a priority and the customer with the highest priority goes first  regardless of the order of arrival we say this is the most general policy because the priority can be based on anything  what time a flight leaves ; how many groceries the customer has ; or how important the customer is of course  not all queueing policies are fair  but fairness is in the eye of the beholder the queue adt and the priority queue adt have the same set of operations the difference is in the semantics of the operations  a queue uses the fifo policy ; and a priority queue  as the name suggests  uses the priority queueing policy 19.1 the queue adt the queue adt is defined by the following operations  init  initialize a new empty queue insert  add a new item to the queue 198 queues remove  remove and return an item from the queue the item that is returned is the first one that was added isempty  check whether the queue is empty 19.2 linked queue the first implementation of the queue adt we will look at is called a linked queue because it is made up of linked node objects here is the class definition  class queue  def __init__  self   self.length = 0 self.head = none def isempty  self   return  self.length = = 0  def insert  self  cargo   node = node  cargo  node.next = none if self.head = = none  # if list is empty the new node goes first self.head = node else  # find the last node in the list last = self.head while last.next  last = last.next # append the new node last.next = node self.length = self.length + 1 def remove  self   cargo = self.head.cargo self.head = self.head.next self.length = self.length  1 return cargo the methods isempty and remove are identical to the linkedlist methods isempty and removefirst the insert method is new and a bit more complicated we want to insert new items at the end of the list if the queue is empty  we just set head to refer to the new node 19.3 performance characteristics 199 otherwise  we traverse the list to the last node and tack the new node on the end we can identify the last node because its next attribute is none there are two invariants for a properly formed queue object the value of length should be the number of nodes in the queue  and the last node should have next equal to none convince yourself that this method preserves both invariants 19.3 performance characteristics normally when we invoke a method  we are not concerned with the details of its implementation but there is one detail we might want to know the performance characteristics of the method how long does it take  and how does the run time change as the number of items in the collection increases first look at remove there are no loops or function calls here  suggesting that the runtime of this method is the same every time such a method is called a constant time operation in reality  the method might be slightly faster when the list is empty since it skips the body of the conditional  but that difference is not significant the performance of insert is very different in the general case  we have to traverse the list to find the last element this traversal takes time proportional to the length of the list since the runtime is a linear function of the length  this method is called linear time compared to constant time  that s very bad 19.4 improved linked queue we would like an implementation of the queue adt that can perform all operations in constant time one way to do that is to modify the queue class so that it maintains a reference to both the first and the last node  as shown in the figure  cargo next cargo next cargo next 1 2 3 head length 3 last 200 queues the improvedqueue implementation looks like this  class improvedqueue  def __init__  self   self.length = 0 self.head = none self.last = none def isempty  self   return  self.length = = 0  so far  the only change is the attribute last it is used in insert and remove methods  class improvedqueue   def insert  self  cargo   node = node  cargo  node.next = none if self.length = = 0  # if list is empty  the new node is head and last self.head = self.last = node else  # find the last node last = self.last # append the new node last.next = node self.last = node self.length = self.length + 1 since last keeps track of the last node  we don t have to search for it as a result  this method is constant time there is a price to pay for that speed we have to add a special case to remove to set last to none when the last node is removed  class improvedqueue   def remove  self   cargo = self.head.cargo self.head = self.head.next self.length = self.length  1 if self.length = = 0  self.last = none return cargo 19.5 priority queue 201 this implementation is more complicated than the linked queue implementation  and it is more difficult to demonstrate that it is correct the advantage is that we have achieved the goal both insert and remove are constant time operations as an exercise  write an implementation of the queue adt using a python list compare the performance of this implementation to the improvedqueue for a range of queue lengths 19.5 priority queue the priority queue adt has the same interface as the queue adt  but different semantics again  the interface is  init  initialize a new empty queue insert  add a new item to the queue remove  remove and return an item from the queue the item that is returned is the one with the highest priority isempty  check whether the queue is empty the semantic difference is that the item that is removed from the queue is not necessarily the first one that was added rather  it is the item in the queue that has the highest priority what the priorities are and how they compare to each other are not specified by the priority queue implementation it depends on which items are in the queue for example  if the items in the queue have names  we might choose them in alphabetical order if they are bowling scores  we might go from highest to lowest  but if they are golf scores  we would go from lowest to highest as long as we can compare the items in the queue  we can find and remove the one with the highest priority this implementation of priority queue has as an attribute a python list that contains the items in the queue class priorityqueue  def __init__  self   self.items =   def isempty  self   return self.items = =   202 queues def insert  self  item   self.items.append  item  the initialization method  isempty  and insert are all veneers on list operations the only interesting method is remove  class priorityqueue   def remove  self   maxi = 0 for i in range  1,len  self.items    if self.items  i  > self.items  maxi   maxi = i item = self.items  maxi  self.items  maxi  maxi + 1  =   return item at the beginning of each iteration  maxi holds the index of the biggest item  highest priority  we have seen so far each time through the loop  the program compares the i-eth item to the champion if the new item is bigger  the value of maxi is set to i when the for statement completes  maxi is the index of the biggest item this item is removed from the list and returned let s test the implementation  > > > q = priorityqueue   > > > q.insert  11  > > > q.insert  12  > > > q.insert  14  > > > q.insert  13  > > > while not q.isempty    print q.remove   14 13 12 11 if the queue contains simple numbers or strings  they are removed in numerical or alphabetical order  from highest to lowest python can find the biggest integer or string because it can compare them using the built-in comparison operators if the queue contains an object type  it has to provide a cmp method when remove uses the > operator to compare items  it invokes the cmp for one of the items and passes the other as an argument as long as the cmp method works correctly  the priority queue will work 19.6 the golfer class 203 19.6 the golfer class as an example of an object with an unusual definition of priority  let s implement a class called golfer that keeps track of the names and scores of golfers as usual  we start by defining init and str  class golfer  def __init__  self  name  score   self.name = name self.score = score def __str__  self   return % -16s  % d %  self.name  self.score  str uses the format operator to put the names and scores in neat columns next we define a version of cmp where the lowest score gets highest priority as always  cmp returns 1 if self is greater than other  -1 if self is less than other  and 0 if they are equal class golfer   def __cmp__  self  other   if self.score < other.score  return 1 # less is more if self.score > other.score  return -1 return 0 now we are ready to test the priority queue with the golfer class  > > > tiger = golfer  tiger woods  61  > > > phil = golfer  phil mickelson  72  > > > hal = golfer  hal sutton  69  > > > > > > pq = priorityqueue   > > > pq.insert  tiger  > > > pq.insert  phil  > > > pq.insert  hal  > > > while not pq.isempty    print pq.remove   tiger woods  61 hal sutton  69 phil mickelson  72 as an exercise  write an implementation of the priority queue adt using a linked list you should keep the list sorted so that removal is a constant time operation compare the performance of this implementation with the python list implementation 204 queues 19.7 glossary queue  an ordered set of objects waiting for a service of some kind queue  an adt that performs the operations one might perform on a queue queueing policy  the rules that determine which member of a queue is removed next fifo  first in  first out  a queueing policy in which the first member to arrive is the first to be removed priority queue  a queueing policy in which each member has a priority determined by external factors the member with the highest priority is the first to be removed priority queue  an adt that defines the operations one might perform on a priority queue linked queue  an implementation of a queue using a linked list constant time  an operation whose runtime does not depend on the size of the data structure linear time  an operation whose runtime is a linear function of the size of the data structure chapter 20 trees like linked lists  trees are made up of nodes a common kind of tree is a binary tree  in which each node contains a reference to two other nodes  possibly null   these references are referred to as the left and right subtrees like list nodes  tree nodes also contain cargo a state diagram for a tree looks like this  cargo 1 tree none none none none left right left right left right cargo 2 cargo 3 to avoid cluttering up the picture  we often omit the nones the top of the tree  the node tree refers to  is called the root in keeping with the tree metaphor  the other nodes are called branches and the nodes at the tips with null references are called leaves it may seem odd that we draw the picture with the root at the top and the leaves at the bottom  but that is not the strangest thing to make things worse  computer scientists mix in another metaphor the family tree the top node is sometimes called a parent and the nodes it refers to are its children nodes with the same parent are called siblings 206 trees finally  there is a geometric vocabulary for talking about trees we already mentioned left and right  but there is also up  toward the parent/root  and down  toward the children/leaves   also  all of the nodes that are the same distance from the root comprise a level of the tree we probably don t need three metaphors for talking about trees  but there they are like linked lists  trees are recursive data structures because they are defined recursively a tree is either  the empty tree  represented by none  or a node that contains an object reference and two tree references 20.1 building trees the process of assembling a tree is similar to the process of assembling a linked list each constructor invocation builds a single node class tree  def __init__  self  cargo  left = none  right = none   self.cargo = cargo self.left = left self.right = right def __str__  self   return str  self.cargo  the cargo can be any type  but the arguments for left and right should be tree nodes left and right are optional ; the default value is none to print a node  we just print the cargo one way to build a tree is from the bottom up allocate the child nodes first  left = tree  2  right = tree  3  then create the parent node and link it to the children  tree = tree  1  left  right  ; we can write this code more concisely by nesting constructor invocations  > > > tree = tree  1  tree  2   tree  3   either way  the result is the tree at the beginning of the chapter 20.2 traversing trees 207 20.2 traversing trees any time you see a new data structure  your first question should be  how do i traverse it the most natural way to traverse a tree is recursively for example  if the tree contains integers as cargo  this function returns their sum  def total  tree   if tree = = none  return 0 return total  tree.left  + total  tree.right  + tree.cargo the base case is the empty tree  which contains no cargo  so the sum is 0 the recursive step makes two recursive calls to find the sum of the child trees when the recursive calls complete  we add the cargo of the parent and return the total 20.3 expression trees a tree is a natural way to represent the structure of an expression unlike other notations  it can represent the computation unambiguously for example  the infix expression 1 + 2 3 is ambiguous unless we know that the multiplication happens before the addition this expression tree represents the same computation  cargo 2 cargo 1 cargo + cargo cargo 3 tree left right left right left right left right left right the nodes of an expression tree can be operands like 1 and 2 or operators like + and  operands are leaf nodes ; operator nodes contain references to their operands  all of these operators are binary  meaning they have exactly two operands  we can build this tree like this  > > > tree = tree  +  tree  1   tree   tree  2   tree  3    208 trees looking at the figure  there is no question what the order of operations is ; the multiplication happens first in order to compute the second operand of the addition expression trees have many uses the example in this chapter uses trees to translate expressions to postfix  prefix  and infix similar trees are used inside compilers to parse  optimize  and translate programs 20.4 tree traversal we can traverse an expression tree and print the contents like this  def printtree  tree   if tree = = none  return print tree.cargo  printtree  tree.left  printtree  tree.right  in other words  to print a tree  first print the contents of the root  then print the entire left subtree  and then print the entire right subtree this way of traversing a tree is called a preorder  because the contents of the root appear before the contents of the children for the previous example  the output is  > > > tree = tree  +  tree  1   tree   tree  2   tree  3    > > > printtree  tree  + 1 2 3 this format is different from both postfix and infix ; it is another notation called prefix  in which the operators appear before their operands you might suspect that if you traverse the tree in a different order  you will get the expression in a different notation for example  if you print the subtrees first and then the root node  you get  def printtreepostorder  tree   if tree = = none  return printtreepostorder  tree.left  printtreepostorder  tree.right  print tree.cargo  the result  1 2 3 +  is in postfix ! this order of traversal is called postorder finally  to traverse a tree inorder  you print the left tree  then the root  and then the right tree  20.4 tree traversal 209 def printtreeinorder  tree   if tree = = none  return printtreeinorder  tree.left  print tree.cargo  printtreeinorder  tree.right  the result is 1 + 2 3  which is the expression in infix to be fair  we should point out that we have omitted an important complication sometimes when we write an expression in infix  we have to use parentheses to preserve the order of operations so an inorder traversal is not quite sufficient to generate an infix expression nevertheless  with a few improvements  the expression tree and the three recursive traversals provide a general way to translate expressions from one format to another as an exercise  modify printtreeinorder so that it puts parentheses around every operator and pair of operands is the output correct and unambiguous are the parentheses always necessary if we do an inorder traversal and keep track of what level in the tree we are on  we can generate a graphical representation of a tree  def printtreeindented  tree  level = 0   if tree = = none  return printtreeindented  tree.right  level + 1  print level + str  tree.cargo  printtreeindented  tree.left  level + 1  the parameter level keeps track of where we are in the tree by default  it is initially 0 each time we make a recursive call  we pass level + 1 because the child s level is always one greater than the parent s each item is indented by two spaces per level the result for the example tree is  > > > printtreeindented  tree  3 2 + 1 if you look at the output sideways  you see a simplified version of the original figure 210 trees 20.5 building an expression tree in this section  we parse infix expressions and build the corresponding expression trees for example  the expression  3 + 7  9 yields the following tree  9 3 7 + notice that we have simplified the diagram by leaving out the names of the attributes the parser we will write handles expressions that include numbers  parentheses  and the operators + and  we assume that the input string has already been tokenized into a python list the token list for  3 + 7  9 is     3  +  7     9  end  the end token is useful for preventing the parser from reading past the end of the list as an exercise  write a function that takes an expression string and returns a token list the first function we ll write is gettoken  which takes a token list and an expected token as arguments it compares the expected token to the first token on the list  if they match  it removes the token from the list and returns true ; otherwise  it returns false  def gettoken  tokenlist  expected   if tokenlist  0  = = expected  del tokenlist  0  return true else  return false since tokenlist refers to a mutable object  the changes made here are visible to any other variable that refers to the same object 20.5 building an expression tree 211 the next function  getnumber  handles operands if the next token in tokenlist is a number  getnumber removes it and returns a leaf node containing the number ; otherwise  it returns none def getnumber  tokenlist   x = tokenlist  0  if not isinstance  x  int   return none del tokenlist  0  return tree  x  none  none  before continuing  we should test getnumber in isolation we assign a list of numbers to tokenlist  extract the first  print the result  and print what remains of the token list  > > > tokenlist =  9  11  end  > > > x = getnumber  tokenlist  > > > printtreepostorder  x  9 > > > print tokenlist  11  end  the next method we need is getproduct  which builds an expression tree for products a simple product has two numbers as operands  like 3 7 here is a version of getproduct that handles simple products def getproduct  tokenlist   a = getnumber  tokenlist  if gettoken  tokenlist    b = getnumber  tokenlist  return tree   a  b  else  return a assuming that getnumber succeeds and returns a singleton tree  we assign the first operand to a if the next character is  we get the second number and build an expression tree with a  b  and the operator if the next character is anything else  then we just return the leaf node with a here are two examples  > > > tokenlist =  9   11  end  > > > tree = getproduct  tokenlist  > > > printtreepostorder  tree  9 11 212 trees > > > tokenlist =  9  +  11  end  > > > tree = getproduct  tokenlist  > > > printtreepostorder  tree  9 the second example implies that we consider a single operand to be a kind of product this definition of product is counterintuitive  but it turns out to be useful now we have to deal with compound products  like like 3 5 13 we treat this expression as a product of products  namely 3  5 13   the resulting tree is  3 5 13 with a small change in getproduct  we can handle an arbitrarily long product  def getproduct  tokenlist   a = getnumber  tokenlist  if gettoken  tokenlist    b = getproduct  tokenlist  # this line changed return tree   a  b  else  return a in other words  a product can be either a singleton or a tree with at the root  a number on the left  and a product on the right this kind of recursive definition should be starting to feel familiar let s test the new version with a compound product  > > > tokenlist =  2   3   5   7  end  > > > tree = getproduct  tokenlist  > > > printtreepostorder  tree  2 3 5 7 next we will add the ability to parse sums again  we use a slightly counterintuitive definition of sum for us  a sum can be a tree with + at the root  a product on the left  and a sum on the right or  a sum can be just a product 20.5 building an expression tree 213 if you are willing to play along with this definition  it has a nice property  we can represent any expression  without parentheses  as a sum of products this property is the basis of our parsing algorithm getsum tries to build a tree with a product on the left and a sum on the right but if it doesn t find a +  it just builds a product def getsum  tokenlist   a = getproduct  tokenlist  if gettoken  tokenlist  +   b = getsum  tokenlist  return tree  +  a  b  else  return a let s test it with 9 11 + 5 7  > > > tokenlist =  9   11  +  5   7  end  > > > tree = getsum  tokenlist  > > > printtreepostorder  tree  9 11 5 7 + we are almost done  but we still have to handle parentheses anywhere in an expression where there can be a number  there can also be an entire sum enclosed in parentheses we just need to modify getnumber to handle subexpressions  def getnumber  tokenlist   if gettoken  tokenlist     x = getsum  tokenlist  # get the subexpression gettoken  tokenlist    # remove the closing parenthesis return x else  x = tokenlist  0  if not isinstance  x  int   return none tokenlist  0  1  =   return tree  x  none  none  let s test this code with 9  11 + 5  7  > > > tokenlist =  9     11  +  5     7  end  > > > tree = getsum  tokenlist  > > > printtreepostorder  tree  9 11 5 + 7 214 trees the parser handled the parentheses correctly ; the addition happens before the multiplication in the final version of the program  it would be a good idea to give getnumber a name more descriptive of its new role 20.6 handling errors throughout the parser  we ve been assuming that expressions are well-formed for example  when we reach the end of a subexpression  we assume that the next character is a close parenthesis if there is an error and the next character is something else  we should deal with it def getnumber  tokenlist   if gettoken  tokenlist     x = getsum  tokenlist  if not gettoken  tokenlist     raise valueerror  missing parenthesis return x else  # the rest of the function omitted the raise statement creates an exception ; in this case a valueerror if the function that called getnumber  or one of the other functions in the traceback  handles the exception  then the program can continue otherwise  python will print an error message and quit as an exercise  find other places in these functions where errors can occur and add appropriate raise statements test your code with improperly formed expressions 20.7 the animal tree in this section  we develop a small program that uses a tree to represent a knowledge base the program interacts with the user to create a tree of questions and animal names here is a sample run  20.7 the animal tree 215 are you thinking of an animal y is it a bird n what is the animals name dog what question would distinguish a dog from a bird can it fly if the animal were dog the answer would be n are you thinking of an animal y can it fly n is it a dog n what is the animals name cat what question would distinguish a cat from a dog does it bark if the animal were cat the answer would be n are you thinking of an animal y can it fly n does it bark y is it a dog y i rule ! are you thinking of an animal n here is the tree this dialog builds  bird n n y y can it fly does it bark cat dog at the beginning of each round  the program starts at the top of the tree and asks the first question depending on the answer  it moves to the left or right child and continues until it gets to a leaf node at that point  it makes a guess if the guess is not correct  it asks the user for the name of the new animal and a question that distinguishes the  bad  guess from the new animal then it adds a node to the tree with the new question and the new animal here is the code  216 trees def animal    # start with a singleton root = tree  bird  # loop until the user quits while true  print if not yes  are you thinking of an animal   break # walk the tree tree = root while tree.getleft   ! = none  prompt = tree.getcargo   + if yes  prompt   tree = tree.getright   else  tree = tree.getleft   # make a guess guess = tree.getcargo   prompt = is it a + guess + if yes  prompt   print i rule ! continue # get new information prompt = what is the animal s name animal = raw_input  prompt  prompt = what question would distinguish a % s from a % s question = raw_input  prompt %  animal,guess   # add new information to the tree tree.setcargo  question  prompt = if the animal were % s the answer would be if yes  prompt % animal   tree.setleft  tree  guess   tree.setright  tree  animal   else  tree.setleft  tree  animal   tree.setright  tree  guess   the function yes is a helper ; it prints a prompt and then takes input from the user if the response begins with y or y  the function returns true  20.8 glossary 217 def yes  ques   from string import lower ans = lower  raw_input  ques   return  ans  0  = = y  the condition of the outer loop is true  which means it will continue until the break statement executes  if the user is not thinking of an animal the inner while loop walks the tree from top to bottom  guided by the user s responses when a new node is added to the tree  the new question replaces the cargo  and the two children are the new animal and the original cargo one shortcoming of the program is that when it exits  it forgets everything you carefully taught it ! as an exercise  think of various ways you might save the knowledge tree in a file implement the one you think is easiest 20.8 glossary binary tree  a tree in which each node refers to zero  one  or two dependent nodes root  the topmost node in a tree  with no parent leaf  a bottom-most node in a tree  with no children parent  the node that refers to a given node child  one of the nodes referred to by a node siblings  nodes that share a common parent level  the set of nodes equidistant from the root binary operator  an operator that takes two operands subexpression  an expression in parentheses that acts as a single operand in a larger expression preorder  a way to traverse a tree  visiting each node before its children prefix notation  a way of writing a mathematical expression with each operator appearing before its operands 218 trees postorder  a way to traverse a tree  visiting the children of each node before the node itself inorder  a way to traverse a tree  visiting the left subtree  then the root  and then the right subtree 