dsa dat a s t r u c t u r e s a n d a l g o r i t hms annotated reference with examples granville barne ! luca del tongo data structures and algorithms  annotated reference with examples first edition copyright Â ° c granville barnett  and luca del tongo 2008  this book is made exclusively available from dotnetslackers  http  //dotnetslackers.com/  the place for .net articles  and news from some of the leading minds in the software industry  contents 1 introduction 1 1.1 what this book is  and what it is n't                 1 1.2 assumed knowledge                          1 1.2.1 big oh notation                        1 1.2.2 imperative programming language              3 1.2.3 object oriented concepts                   4 1.3 pseudocode                               4 1.4 tips for working through the examples                6 1.5 book outline                              6 1.6 testing                                 7 1.7 where can i get the code ?                       7 1.8 final messages                             7 i data structures 8 2 linked lists 9 2.1 singly linked list                           9 2.1.1 insertion                             10 2.1.2 searching                            10 2.1.3 deletion                             11 2.1.4 traversing the list                       12 2.1.5 traversing the list in reverse order              13 2.2 doubly linked list                           13 2.2.1 insertion                             15 2.2.2 deletion                             15 2.2.3 reverse traversal                        16 2.3 summary                                17 3 binary search tree 19 3.1 insertion                                 20 3.2 searching                                21 3.3 deletion                                 22 3.4 finding the parent of a given node                  24 3.5 attaining a reference to a node                    24 3.6 finding the smallest and largest values in the binary search tree 25 3.7 tree traversals                             26 3.7.1 preorder                             26 i 3.7.2 postorder                            26 3.7.3 inorder                             29 3.7.4 breadth first                          30 3.8 summary                                31 4 heap 32 4.1 insertion                                 33 4.2 deletion                                 37 4.3 searching                                38 4.4 traversal                                41 4.5 summary                                42 5 sets 44 5.1 unordered                                46 5.1.1 insertion                             46 5.2 ordered                                 47 5.3 summary                                47 6 queues 48 6.1 a standard queue                            49 6.2 priority queue                             49 6.3 double ended queue                          49 6.4 summary                                53 7 avl tree 54 7.1 tree rotations                             56 7.2 tree rebalancing                            57 7.3 insertion                                 58 7.4 deletion                                 59 7.5 summary                                61 ii algorithms 62 8 sorting 63 8.1 bubble sort                               63 8.2 merge sort                               63 8.3 quick sort                                65 8.4 insertion sort                              67 8.5 shell sort                                68 8.6 radix sort                               68 8.7 summary                                70 9 numeric 72 9.1 primality test                             72 9.2 base conversions                            72 9.3 attaining the greatest common denominator of two numbers   73 9.4 computing the maximum value for a number of a speci Â ¯ c base consisting of n digits                          74 9.5 factorial of a number                         74 9.6 summary                                75 ii 10 searching 76 10.1 sequential search                            76 10.2 probability search                           76 10.3 summary                                77 11 strings 79 11.1 reversing the order of words in a sentence              79 11.2 detecting a palindrome                        80 11.3 counting the number of words in a string              81 11.4 determining the number of repeated words within a string     83 11.5 determining the Â ¯ rst matching character between two strings   84 11.6 summary                                85 a algorithm walkthrough 86 a.1 iterative algorithms                          86 a.2 recursive algorithms                          88 a.3 summary                                90 b translation walkthrough 91 b.1 summary                                92 c recursive vs iterative solutions 93 c.1 activation records                           94 c.2 some problems are recursive in nature                95 c.3 summary                                95 d testing 97 d.1 what constitutes a unit test ?                     97 d.2 when should i write my tests ?                    98 d.3 how seriously should i view my test suite ?              99 d.4 the three a 's                              99 d.5 the structuring of tests                        99 d.6 code coverage                             100 d.7 summary                                100 e symbol de Â ¯ nitions 101 iii preface every book has a story as to how it came about and this one is no di Â ® erent  although we would be lying if we said its development had not been somewhat impromptu put simply this book is the result of a series of emails sent back and forth between the two authors during the development of a library for the .net framework of the same name  with the omission of the subtitle of course !   the conversation started o Â ® something like  \ why do n't we create a more aesthetically pleasing way to present our pseudocode ? " after a few weeks this new presentation style had in fact grown into pseudocode listings with chunks of text describing how the data structure or algorithm in question works and various other things about it at this point we thought  \ what the heck  let 's make this thing into a book ! " and so  in the summer of 2008 we began work on this book side by side with the actual library implementation  when we started writing this book the only things that we were sure about with respect to how the book should be structured were  1 always make explanations as simple as possible while maintaining a moder ately Â ¯ ne degree of precision to keep the more eager minded reader happy ; and 2 inject diagrams to demystify problems that are even moderatly challenging to visualise     and so we could remember how our own algorithms worked when looking back at them !  ; and Â ¯ nally 3 present concise and self-explanatory pseudocode listings that can be ported easily to most mainstream imperative programming languages like c + +  c #  and java  a key factor of this book and its associated implementations is that all algorithms  unless otherwise stated  were designed by us  using the theory of the algorithm in question as a guideline  for which we are eternally grateful to their original creators   therefore they may sometimes turn out to be worse than the \ normal " implementations | and sometimes not we are two fellows of the opinion that choice is a great thing read our book  read several others on the same subject and use what you see Â ¯ t from each  if anything  when implementing your own version of the algorithms in question  through this book we hope that you will see the absolute necessity of under standing which data structure or algorithm to use for a certain scenario in all projects  especially those that are concerned with performance  here we apply an even greater emphasis on real-time systems  the selection of the wrong data structure or algorithm can be the cause of a great deal of performance pain  iv v therefore it is absolutely key that you think about the run time complexity and space requirements of your selected approach in this book we only explain the theoretical implications to consider  but this is for a good reason  compilers are very di Â ® erent in how they work one c + + compiler may have some amazing optimisation phases speci Â ¯ cally targeted at recursion  another may not  for ex ample of course this is just an example but you would be surprised by how many subtle di Â ® erences there are between compilers these di Â ® erences which may make a fast algorithm slow  and vice versa we could also factor in the same concerns about languages that target virtual machines  leaving all the actual various implementation issues to you given that you will know your lan guage 's compiler much better than us...well in most cases this has resulted in a more concise book that focuses on what we think are the key issues  one Â ¯ nal note  never take the words of others as gospel ; verify all that can be feasibly veri Â ¯ ed and make up your own mind  we hope you enjoy reading this book as much as we have enjoyed writing it  granville barnett luca del tongo acknowledgements writing this short book has been a fun and rewarding experience we would like to thank  in no particular order the following people who have helped us during the writing of this book  sonu kapoor generously hosted our book which when we released the Â ¯ rst draft received over thirteen thousand downloads  without his generosity this book would not have been able to reach so many people jon skeet provided us with an alarming number of suggestions throughout for which we are eternally grateful jon also edited this book as well  we would also like to thank those who provided the odd suggestion via email to us all feedback was listened to and you will no doubt see some content in Â ° uenced by your suggestions  a special thank you also goes out to those who helped publicise this book from microsoft 's channel 9 weekly show  thanks dan !  to the many bloggers who helped spread the word you gave us an audience and for that we are extremely grateful  thank you to all who contributed in some way to this book the program ming community never ceases to amaze us in how willing its constituents are to give time to projects such as this one thank you  vi about the authors granville barnett granville is currently a ph.d candidate at queensland university of technology  qut  working on parallelism at the microsoft qut eresearch centre1 he also holds a degree in computer science  and is a microsoft mvp his main interests are in programming languages and compilers granville can be contacted via one of two places  either his personal website  http  //gbarnett.org  or his blog  http  //msmvps.com/blogs/gbarnett   luca del tongo luca is currently studying for his masters degree in computer science at flo rence his main interests vary from web development to research Â ¯ elds such as data mining and computer vision luca also maintains an italian blog which can be found at http  //blogs.ugidotnet.org/wetblog/  1http  //www.mquter.qut.edu.au/ vii page intentionally left blank  chapter 1 introduction 1.1 what this book is  and what it is n't this book provides implementations of common and uncommon algorithms in pseudocode which is language independent and provides for easy porting to most imperative programming languages it is not a de Â ¯ nitive book on the theory of data structures and algorithms  for the most part this book presents implementations devised by the authors themselves based on the concepts by which the respective algorithms are based upon so it is more than possible that our implementations di Â ® er from those considered the norm  you should use this book alongside another on the same subject  but one that contains formal proofs of the algorithms in question in this book we use the abstract big oh notation to depict the run time complexity of algorithms so that the book appeals to a larger audience  1.2 assumed knowledge we have written this book with few assumptions of the reader  but some have been necessary in order to keep the book as concise and approachable as possible  we assume that the reader is familiar with the following  1 big oh notation 2 an imperative programming language 3 object oriented concepts 1.2.1 big oh notation for run time complexity analysis we use big oh notation extensively so it is vital that you are familiar with the general concepts to determine which is the best algorithm for you in certain scenarios we have chosen to use big oh notation for a few reasons  the most important of which is that it provides an abstract measurement by which we can judge the performance of algorithms without using mathematical proofs  1 chapter 1 introduction 2 figure 1.1  algorithmic run time expansion figure 1.1 shows some of the run times to demonstrate how important it is to choose an e Â ± cient algorithm for the sanity of our graph we have omitted cubic o  n3   and exponential o  2n  run times cubic and exponential algorithms should only ever be used for very small problems  if ever !  ; avoid them if feasibly possible  the following list explains some of the most common big oh notations  o  1  constant  the operation does n't depend on the size of its input  e.g adding a node to the tail of a linked list where we always maintain a pointer to the tail node  o  n  linear  the run time complexity is proportionate to the size of n  o  log n  logarithmic  normally associated with algorithms that break the problem into smaller chunks per each invocation  e.g searching a binary search tree  o  n log n  just n log n  usually associated with an algorithm that breaks the problem into smaller chunks per each invocation  and then takes the results of these smaller chunks and stitches them back together  e.g quick sort  o  n2  quadratic  e.g bubble sort  o  n3  cubic  very rare  o  2n  exponential  incredibly rare  if you encounter either of the latter two items  cubic and exponential  this is really a signal for you to review the design of your algorithm while prototyp ing algorithm designs you may just have the intention of solving the problem irrespective of how fast it works we would strongly advise that you always review your algorithm design and optimise where possible | particularly loops chapter 1 introduction 3 and recursive calls | so that you can get the most e Â ± cient run times for your algorithms  the biggest asset that big oh notation gives us is that it allows us to es sentially discard things like hardware if you have two sorting algorithms  one with a quadratic run time  and the other with a logarithmic run time then the logarithmic algorithm will always be faster than the quadratic one when the data set becomes suitably large this applies even if the former is ran on a ma chine that is far faster than the latter why ? because big oh notation isolates a key factor in algorithm analysis  growth an algorithm with a quadratic run time grows faster than one with a logarithmic run time it is generally said at some point as n ! 1 the logarithmic algorithm will become faster than the quadratic algorithm  big oh notation also acts as a communication tool picture the scene  you are having a meeting with some fellow developers within your product group  you are discussing prototype algorithms for node discovery in massive networks  several minutes elapse after you and two others have discussed your respective algorithms and how they work does this give you a good idea of how fast each respective algorithm is ? no the result of such a discussion will tell you more about the high level algorithm design rather than its e Â ± ciency replay the scene back in your head  but this time as well as talking about algorithm design each respective developer states the asymptotic run time of their algorithm using the latter approach you not only get a good general idea about the algorithm design  but also key e Â ± ciency data which allows you to make better choices when it comes to selecting an algorithm Â ¯ t for purpose  some readers may actually work in a product group where they are given budgets per feature each feature holds with it a budget that represents its up permost time bound if you save some time in one feature it does n't necessarily give you a bu Â ® er for the remaining features imagine you are working on an application  and you are in the team that is developing the routines that will essentially spin up everything that is required when the application is started  everything is great until your boss comes in and tells you that the start up time should not exceed n ms the e Â ± ciency of every algorithm that is invoked during start up in this example is absolutely key to a successful product even if you do n't have these budgets you should still strive for optimal solutions  taking a quantitative approach for many software development properties will make you a far superior programmer  measuring one 's work is critical to success  1.2.2 imperative programming language all examples are given in a pseudo-imperative coding format and so the reader must know the basics of some imperative mainstream programming language to port the examples e Â ® ectively  we have written this book with the following target languages in mind  1 c + + 2 c # 3 java chapter 1 introduction 4 the reason that we are explicit in this requirement is simple | all our imple mentations are based on an imperative thinking style if you are a functional programmer you will need to apply various aspects from the functional paradigm to produce e Â ± cient solutions with respect to your functional language whether it be haskell  f #  ocaml  etc  two of the languages that we have listed  c # and java  target virtual machines which provide various things like security sand boxing  and memory management via garbage collection algorithms it is trivial to port our imple mentations to these languages when porting to c + + you must remember to use pointers for certain things for example  when we describe a linked list node as having a reference to the next node  this description is in the context of a managed environment in c + + you should interpret the reference as a pointer to the next node and so on for programmers who have a fair amount of experience with their respective language these subtleties will present no is sue  which is why we really do emphasise that the reader must be comfortable with at least one imperative language in order to successfully port the pseudo implementations in this book  it is essential that the user is familiar with primitive imperative language constructs before reading this book otherwise you will just get lost some algo rithms presented in this book can be confusing to follow even for experienced programmers ! 1.2.3 object oriented concepts for the most part this book does not use features that are speci Â ¯ c to any one language in particular  we never provide data structures or algorithms that work on generic types | this is in order to make the samples as easy to follow as possible however  to appreciate the designs of our data structures you will need to be familiar with the following object oriented  oo  concepts  1 inheritance 2 encapsulation 3 polymorphism this is especially important if you are planning on looking at the c # target that we have implemented  more on that in x1.7  which makes extensive use of the oo concepts listed above as a Â ¯ nal note it is also desirable that the reader is familiar with interfaces as the c # target uses interfaces throughout the sorting algorithms  1.3 pseudocode throughout this book we use pseudocode to describe our solutions for the most part interpreting the pseudocode is trivial as it looks very much like a more abstract c + +  or c #  but there are a few things to point out  1 pre-conditions should always be enforced 2 post-conditions represent the result of applying algorithm a to data struc ture d chapter 1 introduction 5 3 the type of parameters is inferred 4 all primitive language constructs are explicitly begun and ended if an algorithm has a return type it will often be presented in the post condition  but where the return type is su Â ± ciently obvious it may be omitted for the sake of brevity  most algorithms in this book require parameters  and because we assign no explicit type to those parameters the type is inferred from the contexts in which it is used  and the operations performed upon it additionally  the name of the parameter usually acts as the biggest clue to its type for instance n is a pseudo-name for a number and so you can assume unless otherwise stated that n translates to an integer that has the same number of bits as a word on a 32 bit machine  similarly l is a pseudo-name for a list where a list is a resizeable array  e.g a vector   the last major point of reference is that we always explicitly end a language construct for instance if we wish to close the scope of a for loop we will explicitly state end for rather than leaving the interpretation of when scopes are closed to the reader while implicit scope closure works well in simple code  in complex cases it can lead to ambiguity  the pseudocode style that we use within this book is rather straightforward  all algorithms start with a simple algorithm signature  e.g  1  algorithm algorithmname  arg1  arg2    argn  2    n  end algorithmname immediately after the algorithm signature we list any pre or post condi tions  1  algorithm algorithmname  n  2  pre  n is the value to compute the factorial of 3  n Â ¸ 0 4  post  the factorial of n has been computed 5  //   n  end algorithmname the example above describes an algorithm by the name of algorithmname  which takes a single numeric parameter n the pre and post conditions follow the algorithm signature ; you should always enforce the pre-conditions of an algorithm when porting them to your language of choice  normally what is listed as a pre-conidition is critical to the algorithms opera tion this may cover things like the actual parameter not being null  or that the collection passed in must contain at least n items the post-condition mainly describes the e Â ® ect of the algorithms operation an example of a post-condition might be \ the list has been sorted in ascending order " because everything we describe is language independent you will need to make your own mind up on how to best handle pre-conditions for example  in the c # target we have implemented  we consider non-conformance to pre conditions to be exceptional cases we provide a message in the exception to tell the caller why the algorithm has failed to execute normally  chapter 1 introduction 6 1.4 tips for working through the examples as with most books you get out what you put in and so we recommend that in order to get the most out of this book you work through each algorithm with a pen and paper to track things like variable names  recursive calls etc  the best way to work through algorithms is to set up a table  and in that table give each variable its own column and continuously update these columns  this will help you keep track of and visualise the mutations that are occurring throughout the algorithm often while working through algorithms in such a way you can intuitively map relationships between data structures rather than trying to work out a few values on paper and the rest in your head we suggest you put everything on paper irrespective of how trivial some variables and calculations may be so that you always have a point of reference  when dealing with recursive algorithm traces we recommend you do the same as the above  but also have a table that records function calls and who they return to this approach is a far cleaner way than drawing out an elaborate map of function calls with arrows to one another  which gets large quickly and simply makes things more complex to follow track everything in a simple and systematic way to make your time studying the implementations far easier  1.5 book outline we have split this book into two parts  part 1  provides discussion and pseudo-implementations of common and uncom mon data structures ; and part 2  provides algorithms of varying purposes from sorting to string operations  the reader does n't have to read the book sequentially from beginning to end  chapters can be read independently from one another we suggest that in part 1 you read each chapter in its entirety  but in part 2 you can get away with just reading the section of a chapter that describes the algorithm you are interested in  each of the chapters on data structures present initially the algorithms con cerned with  1 insertion 2 deletion 3 searching the previous list represents what we believe in the vast majority of cases to be the most important for each respective data structure  for all readers we recommend that before looking at any algorithm you quickly look at appendix e which contains a table listing the various symbols used within our algorithms and their meaning one keyword that we would like to point out here is yield you can think of yield in the same light as return  the return keyword causes the method to exit and returns control to the caller  whereas yield returns each value to the caller with yield control only returns to the caller when all values to return to the caller have been exhausted  chapter 1 introduction 7 1.6 testing all the data structures and algorithms have been tested using a minimised test driven development style on paper to Â ° esh out the pseudocode algorithm we then transcribe these tests into unit tests satisfying them one by one when all the test cases have been progressively satis Â ¯ ed we consider that algorithm suitably tested  for the most part algorithms have fairly obvious cases which need to be satis Â ¯ ed some however have many areas which can prove to be more complex to satisfy with such algorithms we will point out the test cases which are tricky and the corresponding portions of pseudocode within the algorithm that satisfy that respective case  as you become more familiar with the actual problem you will be able to intuitively identify areas which may cause problems for your algorithms imple mentation this in some cases will yield an overwhelming list of concerns which will hinder your ability to design an algorithm greatly when you are bom barded with such a vast amount of concerns look at the overall problem again and sub-divide the problem into smaller problems solving the smaller problems and then composing them is a far easier task than clouding your mind with too many little details  the only type of testing that we use in the implementation of all that is provided in this book are unit tests because unit tests contribute such a core piece of creating somewhat more stable software we invite the reader to view appendix d which describes testing in more depth  1.7 where can i get the code ? this book does n't provide any code speci Â ¯ cally aligned with it  however we do actively maintain an open source project1 that houses a c # implementation of all the pseudocode listed the project is named data structures and algorithms  dsa  and can be found at http  //codeplex.com/dsa  1.8 final messages we have just a few Â ¯ nal messages to the reader that we hope you digest before you embark on reading this book  1 understand how the algorithm works Â ¯ rst in an abstract sense ; and 2 always work through the algorithms on paper to understand how they achieve their outcome if you always follow these key points  you will get the most out of this book  1all readers are encouraged to provide suggestions  feature requests  and bugs so we can further improve our implementations  part i data structures 8 chapter 2 linked lists linked lists can be thought of from a high level perspective as being a series of nodes each node has at least a single pointer to the next node  and in the last node 's case a null pointer representing that there are no more nodes in the linked list  in dsa our implementations of linked lists always maintain head and tail pointers so that insertion at either the head or tail of the list is a constant time operation random insertion is excluded from this and will be a linear operation as such  linked lists in dsa have the following characteristics  1 insertion is o  1  2 deletion is o  n  3 searching is o  n  out of the three operations the one that stands out is that of insertion in dsa we chose to always maintain pointers  or more aptly references  to the node  s  at the head and tail of the linked list and so performing a traditional insertion to either the front or back of the linked list is an o  1  operation an exception to this rule is performing an insertion before a node that is neither the head nor tail in a singly linked list when the node we are inserting before is somewhere in the middle of the linked list  known as random insertion  the complexity is o  n   in order to add before the designated node we need to traverse the linked list to Â ¯ nd that node 's current predecessor this traversal yields an o  n  run time  this data structure is trivial  but linked lists have a few key points which at times make them very attractive  1 the list is dynamically resized  thus it incurs no copy penalty like an array or vector would eventually incur ; and 2 insertion is o  1   2.1 singly linked list singly linked lists are one of the most primitive data structures you will Â ¯ nd in this book each node that makes up a singly linked list consists of a value  and a reference to the next node  if any  in the list  9 chapter 2 linked lists 10 figure 2.1  singly linked list node figure 2.2  a singly linked list populated with integers 2.1.1 insertion in general when people talk about insertion with respect to linked lists of any form they implicitly refer to the adding of a node to the tail of the list when you use an api like that of dsa and you see a general purpose method that adds a node to the list  you can assume that you are adding the node to the tail of the list not the head  adding a node to a singly linked list has only two cases  1 head = ; in which case the node we are adding is now both the head and tail of the list ; or 2 we simply need to append our node onto the end of the list updating the tail reference appropriately  1  algorithm add  value  2  pre  value is the value to add to the list 3  post  value has been placed at the tail of the list 4  n Ã ƒ node  value  5  if head = ; 6  head Ã ƒ n 7  tail Ã ƒ n 8  else 9  tail.next Ã ƒ n 10  tail Ã ƒ n 11  end if 12  end add as an example of the previous algorithm consider adding the following se quence of integers to the list  1  45  60  and 12  the resulting list is that of figure 2.2  2.1.2 searching searching a linked list is straightforward  we simply traverse the list checking the value we are looking for with the value of each node in the linked list the algorithm listed in this section is very similar to that used for traversal in x2.1.4  chapter 2 linked lists 11 1  algorithm contains  head  value  2  pre  head is the head node in the list 3  value is the value to search for 4  post  the item is either in the linked list  true ; otherwise false 5  n Ã ƒ head 6  while n 6 = ; and n.value 6 = value 7  n Ã ƒ n.next 8  end while 9  if n = ; 10  return false 11  end if 12  return true 13  end contains 2.1.3 deletion deleting a node from a linked list is straightforward but there are a few cases we need to account for  1 the list is empty ; or 2 the node to remove is the only node in the linked list ; or 3 we are removing the head node ; or 4 we are removing the tail node ; or 5 the node to remove is somewhere in between the head and tail ; or 6 the item to remove does n't exist in the linked list the algorithm whose cases we have described will remove a node from any where within a list irrespective of whether the node is the head etc if you know that items will only ever be removed from the head or tail of the list then you can create much more concise algorithms in the case of always removing from the front of the linked list deletion becomes an o  1  operation  chapter 2 linked lists 12 1  algorithm remove  head  value  2  pre  head is the head node in the list 3  value is the value to remove from the list 4  post  value is removed from the list  true ; otherwise false 5  if head = ; 6  // case 1 7  return false 8  end if 9  n Ã ƒ head 10  if n.value = value 11  if head = tail 12  // case 2 13  head Ã ƒ ; 14  tail Ã ƒ ; 15  else 16  // case 3 17  head Ã ƒ head.next 18  end if 19  return true 20  end if 21  while n.next 6 = ; and n.next.value 6 = value 22  n Ã ƒ n.next 23  end while 24  if n.next 6 = ; 25  if n.next = tail 26  // case 4 27  tail Ã ƒ n 28  end if 29  // this is only case 5 if the conditional on line 25 was false 30  n.next Ã ƒ n.next.next 31  return true 32  end if 33  // case 6 34  return false 35  end remove 2.1.4 traversing the list traversing a singly linked list is the same as that of traversing a doubly linked list  de Â ¯ ned in x2.2   you start at the head of the list and continue until you come across a node that is ;  the two cases are as follows  1 node = ;  we have exhausted all nodes in the linked list ; or 2 we must update the node reference to be node.next  the algorithm described is a very simple one that makes use of a simple while loop to check the Â ¯ rst case  chapter 2 linked lists 13 1  algorithm traverse  head  2  pre  head is the head node in the list 3  post  the items in the list have been traversed 4  n Ã ƒ head 5  while n 6 = 0 6  yield n.value 7  n Ã ƒ n.next 8  end while 9  end traverse 2.1.5 traversing the list in reverse order traversing a singly linked list in a forward manner  i.e left to right  is simple as demonstrated in x2.1.4 however  what if we wanted to traverse the nodes in the linked list in reverse order for some reason ? the algorithm to perform such a traversal is very simple  and just like demonstrated in x2.1.3 we will need to acquire a reference to the predecessor of a node  even though the fundamental characteristics of the nodes that make up a singly linked list make this an expensive operation for each node  Â ¯ nding its predecessor is an o  n  operation  so over the course of traversing the whole list backwards the cost becomes o  n2   figure 2.3 depicts the following algorithm being applied to a linked list with the integers 5  10  1  and 40  1  algorithm reversetraversal  head  tail  2  pre  head and tail belong to the same list 3  post  the items in the list have been traversed in reverse order 4  if tail 6 = ; 5  curr Ã ƒ tail 6  while curr 6 = head 7  prev Ã ƒ head 8  while prev.next 6 = curr 9  prev Ã ƒ prev.next 10  end while 11  yield curr.value 12  curr Ã ƒ prev 13  end while 14  yield curr.value 15  end if 16  end reversetraversal this algorithm is only of real interest when we are using singly linked lists  as you will soon see that doubly linked lists  de Â ¯ ned in x2.2  make reverse list traversal simple and e Â ± cient  as shown in x2.2.3  2.2 doubly linked list doubly linked lists are very similar to singly linked lists the only di Â ® erence is that each node has a reference to both the next and previous nodes in the list  chapter 2 linked lists 14 figure 2.3  reverse traveral of a singly linked list figure 2.4  doubly linked list node chapter 2 linked lists 15 the following algorithms for the doubly linked list are exactly the same as those listed previously for the singly linked list  1 searching  de Â ¯ ned in x2.1.2  2 traversal  de Â ¯ ned in x2.1.4  2.2.1 insertion the only major di Â ® erence between the algorithm in x2.1.1 is that we need to remember to bind the previous pointer of n to the previous tail node if n was not the Â ¯ rst node to be inserted into the list  1  algorithm add  value  2  pre  value is the value to add to the list 3  post  value has been placed at the tail of the list 4  n Ã ƒ node  value  5  if head = ; 6  head Ã ƒ n 7  tail Ã ƒ n 8  else 9  n.previous Ã ƒ tail 10  tail.next Ã ƒ n 11  tail Ã ƒ n 12  end if 13  end add figure 2.5 shows the doubly linked list after adding the sequence of integers de Â ¯ ned in x2.1.1  figure 2.5  doubly linked list populated with integers 2.2.2 deletion as you may of guessed the cases that we use for deletion in a doubly linked list are exactly the same as those de Â ¯ ned in x2.1.3 like insertion we have the added task of binding an additional reference  previous  to the correct value  chapter 2 linked lists 16 1  algorithm remove  head  value  2  pre  head is the head node in the list 3  value is the value to remove from the list 4  post  value is removed from the list  true ; otherwise false 5  if head = ; 6  return false 7  end if 8  if value = head.value 9  if head = tail 10  head Ã ƒ ; 11  tail Ã ƒ ; 12  else 13  head Ã ƒ head.next 14  head.previous Ã ƒ ; 15  end if 16  return true 17  end if 18  n Ã ƒ head.next 19  while n 6 = ; and value 6 = n.value 20  n Ã ƒ n.next 21  end while 22  if n = tail 23  tail Ã ƒ tail.previous 24  tail.next Ã ƒ ; 25  return true 26  else if n 6 = ; 27  n.previous.next Ã ƒ n.next 28  n.next.previous Ã ƒ n.previous 29  return true 30  end if 31  return false 32  end remove 2.2.3 reverse traversal singly linked lists have a forward only design  which is why the reverse traversal algorithm de Â ¯ ned in x2.1.5 required some creative invention doubly linked lists make reverse traversal as simple as forward traversal  de Â ¯ ned in x2.1.4  except that we start at the tail node and update the pointers in the opposite direction  figure 2.6 shows the reverse traversal algorithm in action  chapter 2 linked lists 17 figure 2.6  doubly linked list reverse traversal 1  algorithm reversetraversal  tail  2  pre  tail is the tail node of the list to traverse 3  post  the list has been traversed in reverse order 4  n Ã ƒ tail 5  while n 6 = ; 6  yield n.value 7  n Ã ƒ n.previous 8  end while 9  end reversetraversal 2.3 summary linked lists are good to use when you have an unknown number of items to store using a data structure like an array would require you to specify the size up front ; exceeding that size involves invoking a resizing algorithm which has a linear run time you should also use linked lists when you will only remove nodes at either the head or tail of the list to maintain a constant run time  this requires maintaining pointers to the nodes at the head and tail of the list but the memory overhead will pay for itself if this is an operation you will be performing many times  what linked lists are not very good for is random insertion  accessing nodes by index  and searching at the expense of a little memory  in most cases 4 bytes would su Â ± ce   and a few more read/writes you could maintain a count variable that tracks how many items are contained in the list so that accessing such a primitive property is a constant operation  you just need to update count during the insertion and deletion algorithms  singly linked lists should be used when you are only performing basic in sertions in general doubly linked lists are more accommodating for non-trivial operations on a linked list  we recommend the use of a doubly linked list when you require forwards and backwards traversal for the most cases this requirement is present for example  consider a token stream that you want to parse in a recursive descent fashion sometimes you will have to backtrack in order to create the correct parse tree in this scenario a doubly linked list is best as its design makes bi-directional traversal much simpler and quicker than that of a singly linked chapter 2 linked lists 18 list  chapter 3 binary search tree binary search trees  bsts  are very simple to understand we start with a root node with value x  where the left subtree of x contains nodes with values < x and the right subtree contains nodes whose values are Â ¸ x each node follows the same rules with respect to nodes in their left and right subtrees  bsts are of interest because they have operations which are favourably fast  insertion  look up  and deletion can all be done in o  log n  time it is important to note that the o  log n  times for these operations can only be attained if the bst is reasonably balanced ; for a tree data structure with self balancing properties see avl tree de Â ¯ ned in x7   in the following examples you can assume  unless used as a parameter alias that root is a reference to the root node of the tree  23 14 31 7 17 9 figure 3.1  simple unbalanced binary search tree 19 chapter 3 binary search tree 20 3.1 insertion as mentioned previously insertion is an o  log n  operation provided that the tree is moderately balanced  1  algorithm insert  value  2  pre  value has passed custom type checks for type t 3  post  value has been placed in the correct location in the tree 4  if root = ; 5  root Ã ƒ node  value  6  else 7  insertnode  root  value  8  end if 9  end insert 1  algorithm insertnode  current  value  2  pre  current is the node to start from 3  post  value has been placed in the correct location in the tree 4  if value < current.value 5  if current.left = ; 6  current.left Ã ƒ node  value  7  else 8  insertnode  current.left  value  9  end if 10  else 11  if current.right = ; 12  current.right Ã ƒ node  value  13  else 14  insertnode  current.right  value  15  end if 16  end if 17  end insertnode the insertion algorithm is split for a good reason the Â ¯ rst algorithm  non recursive  checks a very core base case  whether or not the tree is empty if the tree is empty then we simply create our root node and Â ¯ nish in all other cases we invoke the recursive insertnode algorithm which simply guides us to the Â ¯ rst appropriate place in the tree to put value note that at each stage we perform a binary chop  we either choose to recurse into the left subtree or the right by comparing the new value with that of the current node for any totally ordered type  no value can simultaneously satisfy the conditions to place it in both subtrees  chapter 3 binary search tree 21 3.2 searching searching a bst is even simpler than insertion the pseudocode is self-explanatory but we will look brie Â ° y at the premise of the algorithm nonetheless  we have talked previously about insertion  we go either left or right with the right subtree containing values that are Â ¸ x where x is the value of the node we are inserting when searching the rules are made a little more atomic and at any one time we have four cases to consider  1 the root = ; in which case value is not in the bst ; or 2 root.value = value in which case value is in the bst ; or 3 value < root.value  we must inspect the left subtree of root for value ; or 4 value > root.value  we must inspect the right subtree of root for value  1  algorithm contains  root  value  2  pre  root is the root node of the tree  value is what we would like to locate 3  post  value is either located or not 4  if root = ; 5  return false 6  end if 7  if root.value = value 8  return true 9  else if value < root.value 10  return contains  root.left  value  11  else 12  return contains  root.right  value  13  end if 14  end contains chapter 3 binary search tree 22 3.3 deletion removing a node from a bst is fairly straightforward  with four cases to con sider  1 the value to remove is a leaf node ; or 2 the value to remove has a right subtree  but no left subtree ; or 3 the value to remove has a left subtree  but no right subtree ; or 4 the value to remove has both a left and right subtree in which case we promote the largest value in the left subtree  there is also an implicit Â ¯ fth case whereby the node to be removed is the only node in the tree this case is already covered by the Â ¯ rst  but should be noted as a possibility nonetheless  of course in a bst a value may occur more than once in such a case the Â ¯ rst occurrence of that value in the bst will be removed  23 14 31 7 # 1  leaf node 9 # 2  right subtree no left subtree # 3  left subtree no right subtree # 4  right subtree and left subtree figure 3.2  binary search tree deletion cases the remove algorithm given below relies on two further helper algorithms named findp arent  and findnode which are described in x3.4 and x3.5 re spectively  chapter 3 binary search tree 23 1  algorithm remove  value  2  pre  value is the value of the node to remove  root is the root node of the bst 3  count is the number of items in the bst 3  post  node with value is removed if found in which case yields true  otherwise false 4  nodetoremove Ã ƒ findnode  value  5  if nodetoremove = ; 6  return false // value not in bst 7  end if 8  parent Ã ƒ findparent  value  9  if count = 1 10  root Ã ƒ ; // we are removing the only node in the bst 11  else if nodetoremove.left = ; and nodetoremove.right = null 12  // case # 1 13  if nodetoremove.value < parent.value 14  parent.left Ã ƒ ; 15  else 16  parent.right Ã ƒ ; 17  end if 18  else if nodetoremove.left = ; and nodetoremove.right 6 = ; 19  // case # 2 20  if nodetoremove.value < parent.value 21  parent.left Ã ƒ nodetoremove.right 22  else 23  parent.right Ã ƒ nodetoremove.right 24  end if 25  else if nodetoremove.left 6 = ; and nodetoremove.right = ; 26  // case # 3 27  if nodetoremove.value < parent.value 28  parent.left Ã ƒ nodetoremove.left 29  else 30  parent.right Ã ƒ nodetoremove.left 31  end if 32  else 33  // case # 4 34  largestv alue Ã ƒ nodetoremove.left 35  while largestv alue.right 6 = ; 36  // Â ¯ nd the largest value in the left subtree of nodetoremove 37  largestv alue Ã ƒ largestv alue.right 38  end while 39  // set the parents ' right pointer of largestv alue to ; 40  findparent  largestv alue.value  .right Ã ƒ ; 41  nodetoremove.value Ã ƒ largestv alue.value 42  end if 43  count Ã ƒ count Â ¡ 1 44  return true 45  end remove chapter 3 binary search tree 24 3.4 finding the parent of a given node the purpose of this algorithm is simple  to return a reference  or pointer  to the parent node of the one with the given value we have found that such an algorithm is very useful  especially when performing extensive tree transforma tions  1  algorithm findparent  value  root  2  pre  value is the value of the node we want to Â ¯ nd the parent of 3  root is the root node of the bst and is ! = ; 4  post  a reference to the parent node of value if found ; otherwise ; 5  if value = root.value 6  return ; 7  end if 8  if value < root.value 9  if root.left = ; 10  return ; 11  else if root.left.value = value 12  return root 13  else 14  return findparent  value  root.left  15  end if 16  else 17  if root.right = ; 18  return ; 19  else if root.right.value = value 20  return root 21  else 22  return findparent  value  root.right  23  end if 24  end if 25  end findparent a special case in the above algorithm is when the speci Â ¯ ed value does not exist in the bst  in which case we return ;  callers to this algorithm must take account of this possibility unless they are already certain that a node with the speci Â ¯ ed value exists  3.5 attaining a reference to a node this algorithm is very similar to x3.4  but instead of returning a reference to the parent of the node with the speci Â ¯ ed value  it returns a reference to the node itself again  ; is returned if the value is n't found  chapter 3 binary search tree 25 1  algorithm findnode  root  value  2  pre  value is the value of the node we want to Â ¯ nd the parent of 3  root is the root node of the bst 4  post  a reference to the node of value if found ; otherwise ; 5  if root = ; 6  return ; 7  end if 8  if root.value = value 9  return root 10  else if value < root.value 11  return findnode  root.left  value  12  else 13  return findnode  root.right  value  14  end if 15  end findnode astute readers will have noticed that the findnode algorithm is exactly the same as the contains algorithm  de Â ¯ ned in x3.2  with the modi Â ¯ cation that we are returning a reference to a node not true or false given findnode  the easiest way of implementing contains is to call findnode and compare the return value with ;  3.6 finding the smallest and largest values in the binary search tree to Â ¯ nd the smallest value in a bst you simply traverse the nodes in the left subtree of the bst always going left upon each encounter with a node  termi nating when you Â ¯ nd a node with no left subtree the opposite is the case when Â ¯ nding the largest value in the bst both algorithms are incredibly simple  and are listed simply for completeness  the base case in both findmin  and findmax algorithms is when the left  findmin   or right  findmax  node references are ; in which case we have reached the last node  1  algorithm findmin  root  2  pre  root is the root node of the bst 3  root 6 = ; 4  post  the smallest value in the bst is located 5  if root.left = ; 6  return root.value 7  end if 8  findmin  root.left  9  end findmin chapter 3 binary search tree 26 1  algorithm findmax  root  2  pre  root is the root node of the bst 3  root 6 = ; 4  post  the largest value in the bst is located 5  if root.right = ; 6  return root.value 7  end if 8  findmax  root.right  9  end findmax 3.7 tree traversals there are various strategies which can be employed to traverse the items in a tree ; the choice of strategy depends on which node visitation order you require  in this section we will touch on the traversals that dsa provides on all data structures that derive from binarysearcht ree  3.7.1 preorder when using the preorder algorithm  you visit the root Â ¯ rst  then traverse the left subtree and Â ¯ nally traverse the right subtree an example of preorder traversal is shown in figure 3.3  1  algorithm preorder  root  2  pre  root is the root node of the bst 3  post  the nodes in the bst have been visited in preorder 4  if root 6 = ; 5  yield root.value 6  preorder  root.left  7  preorder  root.right  8  end if 9  end preorder 3.7.2 postorder this algorithm is very similar to that described in x3.7.1  however the value of the node is yielded after traversing both subtrees an example of postorder traversal is shown in figure 3.4  1  algorithm postorder  root  2  pre  root is the root node of the bst 3  post  the nodes in the bst have been visited in postorder 4  if root 6 = ; 5  postorder  root.left  6  postorder  root.right  7  yield root.value 8  end if 9  end postorder chapter 3 binary search tree 27 23 14 31 7 17 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9  a   b   c   d   e   f  17 17 17 17 17 figure 3.3  preorder visit binary search tree example chapter 3 binary search tree 28 23 14 31 7 17 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9  a   b   c   d   e   f  17 17 17 17 17 figure 3.4  postorder visit binary search tree example chapter 3 binary search tree 29 3.7.3 inorder another variation of the algorithms de Â ¯ ned in x3.7.1 and x3.7.2 is that of inorder traversal where the value of the current node is yielded in between traversing the left subtree and the right subtree an example of inorder traversal is shown in figure 3.5  23 14 31 7 17 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9  a   b   c   d   e   f  17 17 17 17 17 figure 3.5  inorder visit binary search tree example 1  algorithm inorder  root  2  pre  root is the root node of the bst 3  post  the nodes in the bst have been visited in inorder 4  if root 6 = ; 5  inorder  root.left  6  yield root.value 7  inorder  root.right  8  end if 9  end inorder one of the beauties of inorder traversal is that values are yielded in their comparison order in other words  when traversing a populated bst with the inorder strategy  the yielded sequence would have property xi Â · xi + 18i  chapter 3 binary search tree 30 3.7.4 breadth first traversing a tree in breadth Â ¯ rst order yields the values of all nodes of a par ticular depth in the tree before any deeper ones in other words  given a depth d we would visit the values of all nodes at d in a left to right fashion  then we would proceed to d + 1 and so on until we hade no more nodes to visit an example of breadth Â ¯ rst traversal is shown in figure 3.6  traditionally breadth Â ¯ rst traversal is implemented using a list  vector  re sizeable array  etc  to store the values of the nodes visited in breadth Â ¯ rst order and then a queue to store those nodes that have yet to be visited  23 14 31 7 17 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9 23 14 31 7 9  a   b   c   d   e   f  17 17 17 17 17 figure 3.6  breadth first visit binary search tree example chapter 3 binary search tree 31 1  algorithm breadthfirst  root  2  pre  root is the root node of the bst 3  post  the nodes in the bst have been visited in breadth Â ¯ rst order 4  q Ã ƒ queue 5  while root 6 = ; 6  yield root.value 7  if root.left 6 = ; 8  q.enqueue  root.left  9  end if 10  if root.right 6 = ; 11  q.enqueue  root.right  12  end if 13  if ! q.isempty   14  root Ã ƒ q.dequeue   15  else 16  root Ã ƒ ; 17  end if 18  end while 19  end breadthfirst 3.8 summary a binary search tree is a good solution when you need to represent types that are ordered according to some custom rules inherent to that type with logarithmic insertion  lookup  and deletion it is very e Â ® ecient traversal remains linear  but there are many ways in which you can visit the nodes of a tree trees are recursive data structures  so typically you will Â ¯ nd that many algorithms that operate on a tree are recursive  the run times presented in this chapter are based on a pretty big assumption  that the binary search tree 's left and right subtrees are reasonably balanced  we can only attain logarithmic run times for the algorithms presented earlier when this is true a binary search tree does not enforce such a property  and the run times for these operations on a pathologically unbalanced tree become linear  such a tree is e Â ® ectively just a linked list later in x7 we will examine an avl tree that enforces self-balancing properties to help attain logarithmic run times  chapter 4 heap a heap can be thought of as a simple tree data structure  however a heap usually employs one of two strategies  1 min heap ; or 2 max heap each strategy determines the properties of the tree and its values if you were to choose the min heap strategy then each parent node would have a value that is Â · than its children for example  the node at the root of the tree will have the smallest value in the tree the opposite is true for the max heap strategy in this book you should assume that a heap employs the min heap strategy unless otherwise stated  unlike other tree data structures like the one de Â ¯ ned in x3 a heap is generally implemented as an array rather than a series of nodes which each have refer ences to other nodes the nodes are conceptually the same  however  having at most two children figure 4.1 shows how the tree  not a heap data structure   12 7  3 2  6  9   would be represented as an array the array in figure 4.1 is a result of simply adding values in a top-to-bottom  left-to-right fashion figure 4.2 shows arrows to the direct left and right child of each value in the array  this chapter is very much centred around the notion of representing a tree as an array and because this property is key to understanding this chapter figure 4.3 shows a step by step process to represent a tree data structure as an array  in figure 4.3 you can assume that the default capacity of our array is eight  using just an array is often not su Â ± cient as we have to be up front about the size of the array to use for the heap often the run time behaviour of a program can be unpredictable when it comes to the size of its internal data structures  so we need to choose a more dynamic data structure that contains the following properties  1 we can specify an initial size of the array for scenarios where we know the upper storage limit required ; and 2 the data structure encapsulates resizing algorithms to grow the array as required at run time 32 chapter 4 heap 33 figure 4.1  array representation of a simple tree data structure figure 4.2  direct children of the nodes in an array representation of a tree data structure 1 vector 2 arraylist 3 list figure 4.1 does not specify how we would handle adding null references to the heap this varies from case to case ; sometimes null values are prohibited entirely ; in other cases we may treat them as being smaller than any non-null value  or indeed greater than any non-null value you will have to resolve this ambiguity yourself having studied your requirements for the sake of clarity we will avoid the issue by prohibiting null values  because we are using an array we need some way to calculate the index of a parent node  and the children of a node the required expressions for this are de Â ¯ ned as follows for a node at index  1  index Â ¡ 1  /2  parent index  2 2 Â ¤ index + 1  left child  3 2 Â ¤ index + 2  right child  in figure 4.4 a  represents the calculation of the right child of 12  2 Â ¤ 0 + 2  ; and b  calculates the index of the parent of 3   3 Â ¡ 1  /2   4.1 insertion designing an algorithm for heap insertion is simple  but we must ensure that heap order is preserved after each insertion generally this is a post-insertion operation inserting a value into the next free slot in an array is simple  we just need to keep track of the next free index in the array as a counter  and increment it after each insertion inserting our value into the heap is the Â ¯ rst part of the algorithm ; the second is validating heap order in the case of min-heap ordering this requires us to swap the values of a parent and its child if the value of the child is < the value of its parent we must do this for each subtree containing the value we just inserted  chapter 4 heap 34 figure 4.3  converting a tree data structure to its array counterpart chapter 4 heap 35 figure 4.4  calculating node properties the run time e Â ± ciency for heap insertion is o  log n   the run time is a by product of verifying heap order as the Â ¯ rst part of the algorithm  the actual insertion into the array  is o  1   figure 4.5 shows the steps of inserting the values 3  9  12  7  and 1 into a min-heap  chapter 4 heap 36 figure 4.5  inserting values into a min-heap chapter 4 heap 37 1  algorithm add  value  2  pre  value is the value to add to the heap 3  count is the number of items in the heap 4  post  the value has been added to the heap 5  heap  count  Ã ƒ value 6  count Ã ƒ count + 1 7  minheapify   8  end add 1  algorithm minheapify   2  pre  count is the number of items in the heap 3  heap is the array used to store the heap items 4  post  the heap has preserved min heap ordering 5  i Ã ƒ count Â ¡ 1 6  while i > 0 and heap  i  < heap   i Â ¡ 1  /2  7  swap  heap  i   heap   i Â ¡ 1  /2  8  i Ã ƒ  i Â ¡ 1  /2 9  end while 10  end minheapify the design of the maxheapify algorithm is very similar to that of the min heapify algorithm  the only di Â ® erence is that the < operator in the second condition of entering the while loop is changed to >  4.2 deletion just as for insertion  deleting an item involves ensuring that heap ordering is preserved the algorithm for deletion has three steps  1 Â ¯ nd the index of the value to delete 2 put the last value in the heap at the index location of the item to delete 3 verify heap ordering for each subtree which used to include the value chapter 4 heap 38 1  algorithm remove  value  2  pre  value is the value to remove from the heap 3  left  and right are updated alias ' for 2 Â ¤ index + 1  and 2 Â ¤ index + 2 respectively 4  count is the number of items in the heap 5  heap is the array used to store the heap items 6  post  value is located in the heap and removed  true ; otherwise false 7  // step 1 8  index Ã ƒ findindex  heap  value  9  if index < 0 10  return false 11  end if 12  count Ã ƒ count Â ¡ 1 13  // step 2 14  heap  index  Ã ƒ heap  count  15  // step 3 16  while left < count and heap  index  > heap  left  or heap  index  > heap  right  17  // promote smallest key from subtree 18  if heap  left  < heap  right  19  swap  heap  left  index  20  index Ã ƒ left 21  else 22  swap  heap  right  index  23  index Ã ƒ right 24  end if 25  end while 26  return true 27  end remove figure 4.6 shows the remove algorithm visually  removing 1 from a heap containing the values 1  3  9  12  and 13 in figure 4.6 you can assume that we have speci Â ¯ ed that the backing array of the heap should have an initial capacity of eight  please note that in our deletion algorithm that we do n't default the removed value in the heap array if you are using a heap for reference types  i.e objects that are allocated on a heap you will want to free that memory this is important in both unmanaged  and managed languages in the latter we will want to null that empty hole so that the garbage collector can reclaim that memory if we were to not null that hole then the object could still be reached and thus wo n't be garbage collected  4.3 searching searching a heap is merely a matter of traversing the items in the heap array sequentially  so this operation has a run time complexity of o  n   the search can be thought of as one that uses a breadth Â ¯ rst traversal as de Â ¯ ned in x3.7.4 to visit the nodes within the heap to check for the presence of a speci Â ¯ ed item  chapter 4 heap 39 figure 4.6  deleting an item from a heap chapter 4 heap 40 1  algorithm contains  value  2  pre  value is the value to search the heap for 3  count is the number of items in the heap 4  heap is the array used to store the heap items 5  post  value is located in the heap  in which case true ; otherwise false 6  i Ã ƒ 0 7  while i < count and heap  i  6 = value 8  i Ã ƒ i + 1 9  end while 10  if i < count 11  return true 12  else 13  return false 14  end if 15  end contains the problem with the previous algorithm is that we do n't take advantage of the properties in which all values of a heap hold  that is the property of the heap strategy being used for instance if we had a heap that did n't contain the value 4 we would have to exhaust the whole backing heap array before we could determine that it was n't present in the heap factoring in what we know about the heap we can optimise the search algorithm by including logic which makes use of the properties presented by a certain heap strategy  optimising to deterministically state that a value is in the heap is not that straightforward  however the problem is a very interesting one as an example consider a min-heap that does n't contain the value 5 we can only rule that the value is not in the heap if 5 > the parent of the current node being inspected and < the current node being inspected 8 nodes at the current level we are traversing if this is the case then 5 can not be in the heap and so we can provide an answer without traversing the rest of the heap if this property is not satis Â ¯ ed for any level of nodes that we are inspecting then the algorithm will indeed fall back to inspecting all the nodes in the heap the optimisation that we present can be very common and so we feel that the extra logic within the loop is justi Â ¯ ed to prevent the expensive worse case run time  the following algorithm is speci Â ¯ cally designed for a min-heap to tailor the algorithm for a max-heap the two comparison operations in the else if condition within the inner while loop should be Â ° ipped  chapter 4 heap 41 1  algorithm contains  value  2  pre  value is the value to search the heap for 3  count is the number of items in the heap 4  heap is the array used to store the heap items 5  post  value is located in the heap  in which case true ; otherwise false 6  start Ã ƒ 0 7  nodes Ã ƒ 1 8  while start < count 9  start Ã ƒ nodes Â ¡ 1 10  end Ã ƒ nodes + start 11  count Ã ƒ 0 12  while start < count and start < end 13  if value = heap  start  14  return true 15  else if value > parent  heap  start   and value < heap  start  16  count Ã ƒ count + 1 17  end if 18  start Ã ƒ start + 1 19  end while 20  if count = nodes 21  return false 22  end if 23  nodes Ã ƒ nodes Â ¤ 2 24  end while 25  return false 26  end contains the new contains algorithm determines if the value is not in the heap by checking whether count = nodes in such an event where this is true then we can con Â ¯ rm that 8 nodes n at level i  value > parent  n   value < n thus there is no possible way that value is in the heap as an example consider figure 4.7  if we are searching for the value 10 within the min-heap displayed it is obvious that we do n't need to search the whole heap to determine 9 is not present we can verify this after traversing the nodes in the second level of the heap as the previous expression de Â ¯ ned holds true  4.4 traversal as mentioned in x4.3 traversal of a heap is usually done like that of any other array data structure which our heap implementation is based upon as a result you traverse the array starting at the initial array index  0 in most languages  and then visit each value within the array until you have reached the upper bound of the heap you will note that in the search algorithm that we use count as this upper bound rather than the actual physical bound of the allocated array count is used to partition the conceptual heap from the actual array implementation of the heap  we only care about the items in the heap  not the whole array | the latter may contain various other bits of data as a result of heap mutation  chapter 4 heap 42 figure 4.7  determining 10 is not in the heap after inspecting the nodes of level 2 figure 4.8  living and dead space in the heap backing array if you have followed the advice we gave in the deletion algorithm then a heap that has been mutated several times will contain some form of default value for items no longer in the heap potentially you will have at most lengthof  heaparray  Â ¡ count garbage values in the backing heap array data structure the garbage values of course vary from platform to platform to make things simple the garbage value of a reference type will be simple ; and 0 for a value type  figure 4.8 shows a heap that you can assume has been mutated many times  for this example we can further assume that at some point the items in indexes 3 Â ¡ 5 actually contained references to live objects of type t in figure 4.8 subscript is used to disambiguate separate objects of t  from what you have read thus far you will most likely have picked up that traversing the heap in any other order would be of little bene Â ¯ t the heap property only holds for the subtree of each node and so traversing a heap in any other fashion requires some creative intervention heaps are not usually traversed in any other way than the one prescribed previously  4.5 summary heaps are most commonly used to implement priority queues  see x6.2 for a sample implementation  and to facilitate heap sort as discussed in both the insertion x4.1 and deletion x4.2 sections a heap maintains heap order according to the selected ordering strategy these strategies are referred to as min-heap  chapter 4 heap 43 and max heap the former strategy enforces that the value of a parent node is less than that of each of its children  the latter enforces that the value of the parent is greater than that of each of its children  when you come across a heap and you are not told what strategy it enforces you should assume that it uses the min-heap strategy if the heap can be con Â ¯ gured otherwise  e.g to use max-heap then this will often require you to state this explicitly the heap abides progressively to a strategy during the invocation of the insertion  and deletion algorithms the cost of such a policy is that upon each insertion and deletion we invoke algorithms that have logarithmic run time complexities while the cost of maintaining the strategy might not seem overly expensive it does still come at a price we will also have to factor in the cost of dynamic array expansion at some stage this will occur if the number of items within the heap outgrows the space allocated in the heap 's backing array it may be in your best interest to research a good initial starting size for your heap array this will assist in minimising the impact of dynamic array resizing  chapter 5 sets a set contains a number of values  in no particular order the values within the set are distinct from one another  generally set implementations tend to check that a value is not in the set before adding it  avoiding the issue of repeated values from ever occurring  this section does not cover set theory in depth ; rather it demonstrates brie Â ° y the ways in which the values of sets can be de Â ¯ ned  and common operations that may be performed upon them  the notation a = f4 ; 7 ; 9 ; 12 ; 0g de Â ¯ nes a set a whose values are listed within the curly braces  given the set a de Â ¯ ned previously we can say that 4 is a member of a denoted by 4 2 a  and that 99 is not a member of a denoted by 99 = 2 a  often de Â ¯ ning a set by manually stating its members is tiresome  and more importantly the set may contain a large number of values a more concise way of de Â ¯ ning a set and its members is by providing a series of properties that the values of the set must satisfy for example  from the de Â ¯ nition a = fxjx > 0 ; x % 2 = 0g the set a contains only positive integers that are even x is an alias to the current value we are inspecting and to the right hand side of j are the properties that x must satisfy to be in the set a in this example  x must be > 0  and the remainder of the arithmetic expression x = 2 must be 0 you will be able to note from the previous de Â ¯ nition of the set a that the set can contain an in Â ¯ nite number of values  and that the values of the set a will be all even integers that are a member of the natural numbers set n  where n = f1 ; 2 ; 3 ;    g  finally in this brief introduction to sets we will cover set intersection and union  both of which are very common operations  amongst many others  per formed on sets the union set can be de Â ¯ ned as follows a  b = fx j x 2 a or x 2 bg  and intersection a \ b = fx j x 2 a and x 2 bg figure 5.1 demonstrates set intersection and union graphically  given the set de Â ¯ nitions a = f1 ; 2 ; 3g  and b = f6 ; 2 ; 9g the union of the two sets is a  b = f1 ; 2 ; 3 ; 6 ; 9g  and the intersection of the two sets is a \ b = f2g  both set union and intersection are sometimes provided within the frame work associated with mainstream languages this is the case in .net 3.51 where such algorithms exist as extension methods de Â ¯ ned in the type sys tem.linq.enumerable2  as a result dsa does not provide implementations of 1http  //www.microsoft.com/net/ 2http  //msdn.microsoft.com/en-us/library/system.linq.enumerable_members.aspx 44 chapter 5 sets 45 figure 5.1  a  a \ b ; b  a  b these algorithms most of the algorithms de Â ¯ ned in system.linq.enumerable deal mainly with sequences rather than sets exclusively  set union can be implemented as a simple traversal of both sets adding each item of the two sets to a new union set  1  algorithm union  set1  set2  2  pre  set1  and set2 6 = ; 3  union is a set 3  post  a union of set1  and set2 has been created 4  foreach item in set1 5  union.add  item  6  end foreach 7  foreach item in set2 8  union.add  item  9  end foreach 10  return union 11  end union the run time of our union algorithm is o  m + n  where m is the number of items in the Â ¯ rst set and n is the number of items in the second set this runtime applies only to sets that exhibit o  1  insertions  set intersection is also trivial to implement the only major thing worth pointing out about our algorithm is that we traverse the set containing the fewest items we can do this because if we have exhausted all the items in the smaller of the two sets then there are no more items that are members of both sets  thus we have no more items to add to the intersection set  chapter 5 sets 46 1  algorithm intersection  set1  set2  2  pre  set1  and set2 6 = ; 3  intersection  and smallerset are sets 3  post  an intersection of set1  and set2 has been created 4  if set1.count < set2.count 5  smallerset Ã ƒ set1 6  else 7  smallerset Ã ƒ set2 8  end if 9  foreach item in smallerset 10  if set1.contains  item  and set2.contains  item  11  intersection.add  item  12  end if 13  end foreach 14  return intersection 15  end intersection the run time of our intersection algorithm is o  n  where n is the number of items in the smaller of the two sets just like our union algorithm a linear runtime can only be attained when operating on a set with o  1  insertion  5.1 unordered sets in the general sense do not enforce the explicit ordering of their mem bers for example the members of b = f6 ; 2 ; 9g conform to no ordering scheme because it is not required  most libraries provide implementations of unordered sets and so dsa does not ; we simply mention it here to disambiguate between an unordered set and ordered set  we will only look at insertion for an unordered set and cover brie Â ° y why a hash table is an e Â ± cient data structure to use for its implementation  5.1.1 insertion an unordered set can be e Â ± ciently implemented using a hash table as its backing data structure as mentioned previously we only add an item to a set if that item is not already in the set  so the backing data structure we use must have a quick look up and insertion run time complexity  a hash map generally provides the following  1 o  1  for insertion 2 approaching o  1  for look up the above depends on how good the hashing algorithm of the hash table is  but most hash tables employ incredibly e Â ± cient general purpose hashing algorithms and so the run time complexities for the hash table in your library of choice should be very similar in terms of e Â ± ciency  chapter 5 sets 47 5.2 ordered an ordered set is similar to an unordered set in the sense that its members are distinct  but an ordered set enforces some prede Â ¯ ned comparison on each of its members to produce a set whose members are ordered appropriately  in dsa 0.5 and earlier we used a binary search tree  de Â ¯ ned in x3  as the internal backing data structure for our ordered set from versions 0.6 onwards we replaced the binary search tree with an avl tree primarily because avl is balanced  the ordered set has its order realised by performing an inorder traversal upon its backing tree data structure which yields the correct ordered sequence of set members  because an ordered set in dsa is simply a wrapper for an avl tree that additionally ensures that the tree contains unique items you should read x7 to learn more about the run time complexities associated with its operations  5.3 summary sets provide a way of having a collection of unique objects  either ordered or unordered  when implementing a set  either ordered or unordered  it is key to select the correct backing data structure as we discussed in x5.1.1 because we check Â ¯ rst if the item is already contained within the set before adding it we need this check to be as quick as possible for unordered sets we can rely on the use of a hash table and use the key of an item to determine whether or not it is already contained within the set using a hash table this check results in a near constant run time complexity ordered sets cost a little more for this check  however the logarithmic growth that we incur by using a binary search tree as its backing data structure is acceptable  another key property of sets implemented using the approach we describe is that both have favourably fast look-up times just like the check before inser tion  for a hash table this run time complexity should be near constant ordered sets as described in 3 perform a binary chop at each stage when searching for the existence of an item yielding a logarithmic run time  we can use sets to facilitate many algorithms that would otherwise be a little less clear in their implementation for example in x11.4 we use an unordered set to assist in the construction of an algorithm that determines the number of repeated words within a string  chapter 6 queues queues are an essential data structure that are found in vast amounts of soft ware from user mode to kernel mode applications that are core to the system  fundamentally they honour a Â ¯ rst in Â ¯ rst out  fifo  strategy  that is the item Â ¯ rst put into the queue will be the Â ¯ rst served  the second item added to the queue will be the second to be served and so on  a traditional queue only allows you to access the item at the front of the queue ; when you add an item to the queue that item is placed at the back of the queue  historically queues always have the following three core methods  enqueue  places an item at the back of the queue ; dequeue  retrieves the item at the front of the queue  and removes it from the queue ; peek  1 retrieves the item at the front of the queue without removing it from the queue as an example to demonstrate the behaviour of a queue we will walk through a scenario whereby we invoke each of the previously mentioned methods observ ing the mutations upon the queue data structure the following list describes the operations performed upon the queue in figure 6.1  1 enqueue  10  2 enqueue  12  3 enqueue  9  4 enqueue  8  5 enqueue  3  6 dequeue   7 peek   1this operation is sometimes referred to as front 48 chapter 6 queues 49 8 enqueue  33  9 peek   10 dequeue   6.1 a standard queue a queue is implicitly like that described prior to this section in dsa we do n't provide a standard queue because queues are so popular and such a core data structure that you will Â ¯ nd pretty much every mainstream library provides a queue data structure that you can use with your language of choice in this section we will discuss how you can  if required  implement an e Â ± cient queue data structure  the main property of a queue is that we have access to the item at the front of the queue the queue data structure can be e Â ± ciently implemented using a singly linked list  de Â ¯ ned in x2.1   a singly linked list provides o  1  insertion and deletion run time complexities the reason we have an o  1  run time complexity for deletion is because we only ever remove items from the front of queues  with the dequeue operation   since we always have a pointer to the item at the head of a singly linked list  removal is simply a case of returning the value of the old head node  and then modifying the head pointer to be the next node of the old head node the run time complexity for searching a queue remains the same as that of a singly linked list  o  n   6.2 priority queue unlike a standard queue where items are ordered in terms of who arrived Â ¯ rst  a priority queue determines the order of its items by using a form of custom comparer to see which item has the highest priority other than the items in a priority queue being ordered by priority it remains the same as a normal queue  you can only access the item at the front of the queue  a sensible implementation of a priority queue is to use a heap data structure  de Â ¯ ned in x4   using a heap we can look at the Â ¯ rst item in the queue by simply returning the item at index 0 within the heap array a heap provides us with the ability to construct a priority queue where the items with the highest priority are either those with the smallest value  or those with the largest  6.3 double ended queue unlike the queues we have talked about previously in this chapter a double ended queue allows you to access the items at both the front  and back of the queue a double ended queue is commonly known as a deque which is the name we will here on in refer to it as  a deque applies no prioritization strategy to its items like a priority queue does  items are added in order to either the front of back of the deque the former properties of the deque are denoted by the programmer utilising the data structures exposed interface  chapter 6 queues 50 figure 6.1  queue mutations chapter 6 queues 51 deque 's provide front and back speci Â ¯ c versions of common queue operations  e.g you may want to enqueue an item to the front of the queue rather than the back in which case you would use a method with a name along the lines of enqueuefront the following list identi Â ¯ es operations that are commonly supported by deque 's  Â ² enqueuefront Â ² enqueueback Â ² dequeuefront Â ² dequeueback Â ² peekfront Â ² peekback figure 6.2 shows a deque after the invocation of the following methods  in order   1 enqueueback  12  2 enqueuefront  1  3 enqueueback  23  4 enqueuefront  908  5 dequeuefront   6 dequeueback   the operations have a one-to-one translation in terms of behaviour with those of a normal queue  or priority queue in some cases the set of algorithms that add an item to the back of the deque may be named as they are with normal queues  e.g enqueueback may simply be called enqueue an so on some frameworks also specify explicit behaviour 's that data structures must adhere to  this is certainly the case in .net where most collections implement an interface which requires the data structure to expose a standard add method in such a scenario you can safely assume that the add method will simply enqueue an item to the back of the deque  with respect to algorithmic run time complexities a deque is the same as a normal queue that is enqueueing an item to the back of a the queue is o  1   additionally enqueuing an item to the front of the queue is also an o  1  operation  a deque is a wrapper data structure that uses either an array  or a doubly linked list using an array as the backing data structure would require the pro grammer to be explicit about the size of the array up front  this would provide an obvious advantage if the programmer could deterministically state the maxi mum number of items the deque would contain at any one time unfortunately in most cases this does n't hold  as a result the backing array will inherently incur the expense of invoking a resizing algorithm which would most likely be an o  n  operation such an approach would also leave the library developer chapter 6 queues 52 figure 6.2  deque data structure after several mutations chapter 6 queues 53 to look at array minimization techniques as well  it could be that after several invocations of the resizing algorithm and various mutations on the deque later that we have an array taking up a considerable amount of memory yet we are only using a few small percentage of that memory an algorithm described would also be o  n  yet its invocation would be harder to gauge strategically  to bypass all the aforementioned issues a deque typically uses a doubly linked list as its baking data structure while a node that has two pointers consumes more memory than its array item counterpart it makes redundant the need for expensive resizing algorithms as the data structure increases in size dynamically with a language that targets a garbage collected virtual machine memory reclamation is an opaque process as the nodes that are no longer ref erenced become unreachable and are thus marked for collection upon the next invocation of the garbage collection algorithm with c + + or any other lan guage that uses explicit memory allocation and deallocation it will be up to the programmer to decide when the memory that stores the object can be freed  6.4 summary with normal queues we have seen that those who arrive Â ¯ rst are dealt with Â ¯ rst ; that is they are dealt with in a Â ¯ rst-in Â ¯ rst-out  fifo  order queues can be ever so useful ; for example the windows cpu scheduler uses a di Â ® erent queue for each priority of process to determine which should be the next process to utilise the cpu for a speci Â ¯ ed time quantum normal queues have constant insertion and deletion run times searching a queue is fairly unusual | typically you are only interested in the item at the front of the queue despite that  searching is usually exposed on queues and typically the run time is linear  in this chapter we have also seen priority queues where those at the front of the queue have the highest priority and those near the back have the lowest  one implementation of a priority queue is to use a heap data structure as its backing store  so the run times for insertion  deletion  and searching are the same as those for a heap  de Â ¯ ned in x4   queues are a very natural data structure  and while they are fairly primitive they can make many problems a lot simpler for example the breadth Â ¯ rst search de Â ¯ ned in x3.7.4 makes extensive use of queues  chapter 7 avl tree in the early 60 's g.m adelson-velsky and e.m landis invented the Â ¯ rst self balancing binary search tree data structure  calling it avl tree  an avl tree is a binary search tree  bst  de Â ¯ ned in x3  with a self-balancing condition stating that the di Â ® erence between the height of the left and right subtrees can not be no more than one  see figure 7.1 this condition  restored after each tree modi Â ¯ cation  forces the general shape of an avl tree before continuing  let us focus on why balance is so important consider a binary search tree obtained by starting with an empty tree and inserting some values in the following order 1,2,3,4,5  the bst in figure 7.2 represents the worst case scenario in which the run ning time of all common operations such as search  insertion and deletion are o  n   by applying a balance condition we ensure that the worst case running time of each common operation is o  log n   the height of an avl tree with n nodes is o  log n  regardless of the order in which values are inserted  the avl balance condition  known also as the node balance factor represents an additional piece of information stored for each node this is combined with a technique that e Â ± ciently restores the balance condition for the tree in an avl tree the inventors make use of a well-known technique called tree rotation  h h + 1 figure 7.1  the left and right subtrees of an avl tree di Â ® er in height by at most 1 54 chapter 7 avl tree 55 1 2 3 4 5 figure 7.2  unbalanced binary search tree 2 4 5 1 3 4 5 3 2 1 a  b  figure 7.3  avl trees  insertion order  -a  1,2,3,4,5 -b  1,5,4,3,2 chapter 7 avl tree 56 7.1 tree rotations a tree rotation is a constant time operation on a binary search tree that changes the shape of a tree while preserving standard bst properties there are left and right rotations both of them decrease the height of a bst by moving smaller subtrees down and larger subtrees up  14 24 11 8 2 8 14 24 2 11 right rotation left rotation figure 7.4  tree left and right rotations chapter 7 avl tree 57 1  algorithm leftrotation  node  2  pre  node.right ! = ; 3  post  node.right is the new root of the subtree  4  node has become node.right 's left child and  5  bst properties are preserved 6  rightnode Ã ƒ node.right 7  node.right Ã ƒ rightnode.left 8  rightnode.left Ã ƒ node 9  end leftrotation 1  algorithm rightrotation  node  2  pre  node.left ! = ; 3  post  node.left is the new root of the subtree  4  node has become node.left 's right child and  5  bst properties are preserved 6  leftnode Ã ƒ node.left 7  node.left Ã ƒ leftnode.right 8  leftnode.right Ã ƒ node 9  end rightrotation the right and left rotation algorithms are symmetric only pointers are changed by a rotation resulting in an o  1  runtime complexity ; the other Â ¯ elds present in the nodes are not changed  7.2 tree rebalancing the algorithm that we present in this section veri Â ¯ es that the left and right subtrees di Â ® er at most in height by 1 if this property is not present then we perform the correct rotation  notice that we use two new algorithms that represent double rotations  these algorithms are named leftandrightrotation  and rightandleftrotation  the algorithms are self documenting in their names  e.g leftandrightrotation Â ¯ rst performs a left rotation and then subsequently a right rotation  chapter 7 avl tree 58 1  algorithm checkbalance  current  2  pre  current is the node to start from balancing 3  post  current height has been updated while tree balance is if needed 4  restored through rotations 5  if current.left = ; and current.right = ; 6  current.height = -1 ; 7  else 8  current.height = max  height  current.left  ,height  current  right   + 1 9  end if 10  if height  current.left   height  current.right  > 1 11  if height  current.left.left   height  current.left.right  > 0 12  rightrotation  current  13  else 14  leftandrightrotation  current  15  end if 16  else if height  current.left   height  current.right  < Â ¡ 1 17  if height  current.right.left   height  current.right.right  < 0 18  leftrotation  current  19  else 20  rightandleftrotation  current  21  end if 22  end if 23  end checkbalance 7.3 insertion avl insertion operates Â ¯ rst by inserting the given value the same way as bst insertion and then by applying rebalancing techniques if necessary the latter is only performed if the avl property no longer holds  that is the left and right subtrees height di Â ® er by more than 1 each time we insert a node into an avl tree  1 we go down the tree to Â ¯ nd the correct point at which to insert the node  in the same manner as for bst insertion ; then 2 we travel up the tree from the inserted node and check that the node balancing property has not been violated ; if the property has n't been violated then we need not rebalance the tree  the opposite is true if the balancing property has been violated  chapter 7 avl tree 59 1  algorithm insert  value  2  pre  value has passed custom type checks for type t 3  post  value has been placed in the correct location in the tree 4  if root = ; 5  root Ã ƒ node  value  6  else 7  insertnode  root  value  8  end if 9  end insert 1  algorithm insertnode  current  value  2  pre  current is the node to start from 3  post  value has been placed in the correct location in the tree while 4  preserving tree balance 5  if value < current.value 6  if current.left = ; 7  current.left Ã ƒ node  value  8  else 9  insertnode  current.left  value  10  end if 11  else 12  if current.right = ; 13  current.right Ã ƒ node  value  14  else 15  insertnode  current.right  value  16  end if 17  end if 18  checkbalance  current  19  end insertnode 7.4 deletion our balancing algorithm is like the one presented for our bst  de Â ¯ ned in x3.3   the major di Â ® erence is that we have to ensure that the tree still adheres to the avl balance property after the removal of the node if the tree does n't need to be rebalanced and the value we are removing is contained within the tree then no further step are required however  when the value is in the tree and its removal upsets the avl balance property then we must perform the correct rotation  s   chapter 7 avl tree 60 1  algorithm remove  value  2  pre  value is the value of the node to remove  root is the root node 3  of the avl 4  post  node with value is removed and tree rebalanced if found in which 5  case yields true  otherwise false 6  nodetoremove Ã ƒ root 7  parent Ã ƒ ; 8  stackpath Ã ƒ root 9  while nodetoremove 6 = ; and nodetoremove  v alue = v alue 10  parent = nodetoremove 11  if value < nodetoremove.value 12  nodetoremove Ã ƒ nodetoremove.left 13  else 14  nodetoremove Ã ƒ nodetoremove.right 15  end if 16  path.push  nodetoremove  17  end while 18  if nodetoremove = ; 19  return false // value not in avl 20  end if 21  parent Ã ƒ findparent  value  22  if count = 1 // count keeps track of the # of nodes in the avl 23  root Ã ƒ ; // we are removing the only node in the avl 24  else if nodetoremove.left = ; and nodetoremove.right = null 25  // case # 1 26  if nodetoremove.value < parent.value 27  parent.left Ã ƒ ; 28  else 29  parent.right Ã ƒ ; 30  end if 31  else if nodetoremove.left = ; and nodetoremove.right 6 = ; 32  // case # 2 33  if nodetoremove.value < parent.value 34  parent.left Ã ƒ nodetoremove.right 35  else 36  parent.right Ã ƒ nodetoremove.right 37  end if 38  else if nodetoremove.left 6 = ; and nodetoremove.right = ; 39  // case # 3 40  if nodetoremove.value < parent.value 41  parent.left Ã ƒ nodetoremove.left 42  else 43  parent.right Ã ƒ nodetoremove.left 44  end if 45  else 46  // case # 4 47  largestv alue Ã ƒ nodetoremove.left 48  while largestv alue.right 6 = ; 49  // Â ¯ nd the largest value in the left subtree of nodetoremove 50  largestv alue Ã ƒ largestv alue.right chapter 7 avl tree 61 51  end while 52  // set the parents ' right pointer of largestv alue to ; 53  findparent  largestv alue.value  .right Ã ƒ ; 54  nodetoremove.value Ã ƒ largestv alue.value 55  end if 56  while path  count > 0 57  checkbalance  path.pop    // we trackback to the root node check balance 58  end while 59  count Ã ƒ count Â ¡ 1 60  return true 61  end remove 7.5 summary the avl tree is a sophisticated self balancing tree it can be thought of as the smarter  younger brother of the binary search tree unlike its older brother the avl tree avoids worst case linear complexity runtimes for its operations  the avl tree guarantees via the enforcement of balancing algorithms that the left and right subtrees di Â ® er in height by at most 1 which yields at most a logarithmic runtime complexity  part ii algorithms 62 chapter 8 sorting all the sorting algorithms in this chapter use data structures of a speci Â ¯ c type to demonstrate sorting  e.g a 32 bit integer is often used as its associated operations  e.g <  >  etc  are clear in their behaviour  the algorithms discussed can easily be translated into generic sorting algo rithms within your respective language of choice  8.1 bubble sort one of the most simple forms of sorting is that of comparing each item with every other item in some list  however as the description may imply this form of sorting is not particularly e Â ® ecient o  n2   in it 's most simple form bubble sort can be implemented as two loops  1  algorithm bubblesort  list  2  pre  list 6 = ; 3  post  list has been sorted into values of ascending order 4  for i Ã ƒ 0 to list  count Â ¡ 1 5  for j Ã ƒ 0 to list  count Â ¡ 1 6  if list  i  < list  j  7  swap  list  i  ; list  j   8  end if 9  end for 10  end for 11  return list 12  end bubblesort 8.2 merge sort merge sort is an algorithm that has a fairly e Â ± cient space time complexity  o  n log n  and is fairly trivial to implement the algorithm is based on splitting a list  into two similar sized lists  left  and right  and sorting each list and then merging the sorted lists back together  note  the function mergeordered simply takes two ordered lists and makes them one  63 chapter 8 sorting 64 4 75 74 2 54 0 1 2 3 4 4 75 74 2 54 0 1 2 3 4 4 74 75 2 54 0 1 2 3 4 4 74 2 75 54 0 1 2 3 4 4 74 2 54 75 0 1 2 3 4 4 74 2 54 75 0 1 2 3 4 4 74 2 54 75 0 1 2 3 4 4 2 74 54 75 0 1 2 3 4 4 2 54 74 75 0 1 2 3 4 4 2 54 74 75 0 1 2 3 4 2 4 54 74 75 0 1 2 3 4 2 4 54 74 75 0 1 2 3 4 2 4 54 74 75 0 1 2 3 4 2 4 54 74 75 0 1 2 3 4 2 4 54 74 75 0 1 2 3 4 figure 8.1  bubble sort iterations 1  algorithm mergesort  list  2  pre  list 6 = ; 3  post  list has been sorted into values of ascending order 4  if list.count = 1 // already sorted 5  return list 6  end if 7  m Ã ƒ list.count = 2 8  left Ã ƒ list  m  9  right Ã ƒ list  list.count Â ¡ m  10  for i Ã ƒ 0 to left.count Â ¡ 1 11  left  i  Ã ƒ list  i  12  end for 13  for i Ã ƒ 0 to right.count Â ¡ 1 14  right  i  Ã ƒ list  i  15  end for 16  left Ã ƒ mergesort  left  17  right Ã ƒ mergesort  right  18  return mergeordered  left  right  19  end mergesort chapter 8 sorting 65 54 2 74 75 4 75 4 54 2 74 4 75 74 54 2 2 54 divide 54 2 75 4 74 54 2 75 74 54 4 2 impera  merge  figure 8.2  merge sort divide et impera approach 8.3 quick sort quick sort is one of the most popular sorting algorithms based on divide et impera strategy  resulting in an o  n log n  complexity the algorithm starts by picking an item  called pivot  and moving all smaller items before it  while all greater elements after it this is the main quick sort operation  called partition  recursively repeated on lesser and greater sub lists until their size is one or zero  in which case the list is implicitly sorted  choosing an appropriate pivot  as for example the median element is funda mental for avoiding the drastically reduced performance of o  n2   chapter 8 sorting 66 4 75 74 2 54 pivot 4 75 74 2 54 pivot 4 54 74 2 75 pivot 4 2 74 54 75 pivot 4 2 54 74 75 pivot 4 2 pivot 2 4 pivot 74 75 pivot 74 75 2 4 54 74 75 pivot figure 8.3  quick sort example  pivot median strategy  1  algorithm quicksort  list  2  pre  list 6 = ; 3  post  list has been sorted into values of ascending order 4  if list.count = 1 // already sorted 5  return list 6  end if 7  pivot Ã ƒ medianvalue  list  8  for i Ã ƒ 0 to list.count Â ¡ 1 9  if list  i  = pivot 10  equal.insert  list  i   11  end if 12  if list  i  < pivot 13  less.insert  list  i   14  end if 15  if list  i  > pivot 16  greater.insert  list  i   17  end if 18  end for 19  return concatenate  quicksort  less   equal  quicksort  greater   20  end quicksort chapter 8 sorting 67 8.4 insertion sort insertion sort is a somewhat interesting algorithm with an expensive runtime of o  n2   it can be best thought of as a sorting scheme similar to that of sorting a hand of playing cards  i.e you take one card and then look at the rest with the intent of building up an ordered set of cards in your hand  4 75 74 2 54 4 75 74 2 54 4 75 74 2 54 74 4 74 75 2 54 2 75 2 4 74 75 54 54 2 4 54 74 75 4 figure 8.4  insertion sort iterations 1  algorithm insertionsort  list  2  pre  list 6 = ; 3  post  list has been sorted into values of ascending order 4  unsorted Ã ƒ 1 5  while unsorted < list.count 6  hold Ã ƒ list  unsorted  7  i Ã ƒ unsorted Â ¡ 1 8  while i Â ¸ 0 and hold < list  i  9  list  i + 1  Ã ƒ list  i  10  i Ã ƒ i Â ¡ 1 11  end while 12  list  i + 1  Ã ƒ hold 13  unsorted Ã ƒ unsorted + 1 14  end while 15  return list 16  end insertionsort chapter 8 sorting 68 8.5 shell sort put simply shell sort can be thought of as a more e Â ± cient variation of insertion sort as described in x8.4  it achieves this mainly by comparing items of varying distances apart resulting in a run time complexity of o  n log2 n   shell sort is fairly straight forward but may seem somewhat confusing at Â ¯ rst as it di Â ® ers from other sorting algorithms in the way it selects items to compare figure 8.5 shows shell sort being ran on an array of integers  the red coloured square is the current value we are holding  1  algorithm shellsort  list  2  pre  list 6 = ; 3  post  list has been sorted into values of ascending order 4  increment Ã ƒ list.count = 2 5  while increment 6 = 0 6  current Ã ƒ increment 7  while current < list.count 8  hold Ã ƒ list  current  9  i Ã ƒ current Â ¡ increment 10  while i Â ¸ 0 and hold < list  i  11  list  i + increment  Ã ƒ list  i  12  i Â ¡ = increment 13  end while 14  list  i + increment  Ã ƒ hold 15  current Ã ƒ current + 1 16  end while 17  increment = = 2 18  end while 19  return list 20  end shellsort 8.6 radix sort unlike the sorting algorithms described previously radix sort uses buckets to sort items  each bucket holds items with a particular property called a key  normally a bucket is a queue  each time radix sort is performed these buckets are emptied starting the smallest key bucket to the largest when looking at items within a list to sort we do so by isolating a speci Â ¯ c key  e.g in the example we are about to show we have a maximum of three keys for all items  that is the highest key we need to look at is hundreds because we are dealing with  in this example base 10 numbers we have at any one point 10 possible key values 0   9 each of which has their own bucket before we show you this Â ¯ rst simple version of radix sort let us clarify what we mean by isolating keys given the number 102 if we look at the Â ¯ rst key  the ones then we can see we have two of them  progressing to the next key  tens we can see that the number has zero of them  Â ¯ nally we can see that the number has a single hundred the number used as an example has in total three keys  chapter 8 sorting 69 figure 8.5  shell sort chapter 8 sorting 70 1 ones 2 tens 3 hundreds for further clari Â ¯ cation what if we wanted to determine how many thousands the number 102 has ? clearly there are none  but often looking at a number as Â ¯ nal like we often do it is not so obvious so when asked the question how many thousands does 102 have you should simply pad the number with a zero in that location  e.g 0102 here it is more obvious that the key value at the thousands location is zero  the last thing to identify before we actually show you a simple implemen tation of radix sort that works on only positive integers  and requires you to specify the maximum key size in the list is that we need a way to isolate a speci Â ¯ c key at any one time the solution is actually very simple  but its not often you want to isolate a key in a number so we will spell it out clearly here a key can be accessed from any integer with the following expression  key Ã ƒ  number = keytoaccess  % 10 as a simple example lets say that we want to access the tens key of the number 1290  the tens column is key 10 and so after substitution yields key Ã ƒ  1290 = 10  % 10 = 9 the next key to look at for a number can be attained by multiplying the last key by ten working left to right in a sequential manner the value of key is used in the following algorithm to work out the index of an array of queues to enqueue the item into  1  algorithm radix  list  maxkeysize  2  pre  list 6 = ; 3  maxkeysize Â ¸ 0 and represents the largest key size in the list 4  post  list has been sorted 5  queues Ã ƒ queue  10  6  indexofkey Ã ƒ 1 7  fori Ã ƒ 0 to maxkeysize Â ¡ 1 8  foreach item in list 9  queues  getqueueindex  item  indexofkey   .enqueue  item  10  end foreach 11  list Ã ƒ collapsequeues  queues  12  clearqueues  queues  13  indexofkey Ã ƒ indexofkey Â ¤ 10 14  end for 15  return list 16  end radix figure 8.6 shows the members of queues from the algorithm described above operating on the list whose members are 90 ; 12 ; 8 ; 791 ; 123 ; and 61  the key we are interested in for each number is highlighted omitted queues in figure 8.6 mean that they contain no items  8.7 summary throughout this chapter we have seen many di Â ® erent algorithms for sorting lists  some are very e Â ± cient  e.g quick sort de Â ¯ ned in x8.3   some are not  e.g  chapter 8 sorting 71 figure 8.6  radix sort base 10 algorithm bubble sort de Â ¯ ned in x8.1   selecting the correct sorting algorithm is usually denoted purely by e Â ± ciency  e.g you would always choose merge sort over shell sort and so on there are also other factors to look at though and these are based on the actual imple mentation some algorithms are very nicely expressed in a recursive fashion  however these algorithms ought to be pretty e Â ± cient  e.g implementing a linear  quadratic  or slower algorithm using recursion would be a very bad idea  if you want to learn more about why you should be very  very careful when implementing recursive algorithms see appendix c  chapter 9 numeric unless stated otherwise the alias n denotes a standard 32 bit integer  9.1 primality test a simple algorithm that determines whether or not a given integer is a prime number  e.g 2  5  7  and 13 are all prime numbers  however 6 is not as it can be the result of the product of two numbers that are < 6  in an attempt to slow down the inner loop the p n is used as the upper bound  1  algorithm isprime  n  2  post  n is determined to be a prime or not 3  for i Ã ƒ 2 to n do 4  for j Ã ƒ 1 to sqrt  n  do 5  if i Â ¤ j = n 6  return false 7  end if 8  end for 9  end for 10  end isprime 9.2 base conversions dsa contains a number of algorithms that convert a base 10 number to its equivalent binary  octal or hexadecimal form for example 7810 has a binary representation of 10011102  table 9.1 shows the algorithm trace when the number to convert to binary is 74210  72 chapter 9 numeric 73 1  algorithm tobinary  n  2  pre  n Â ¸ 0 3  post  n has been converted into its base 2 representation 4  while n > 0 5  list  add  n % 2  6  n Ã ƒ n = 2 7  end while 8  return reverse  list  9  end tobinary n list 742 f 0 g 371 f 0 ; 1 g 185 f 0 ; 1 ; 1 g 92 f 0 ; 1 ; 1 ; 0 g 46 f 0 ; 1 ; 1 ; 0 ; 1 g 23 f 0 ; 1 ; 1 ; 0 ; 1 ; 1 g 11 f 0 ; 1 ; 1 ; 0 ; 1 ; 1 ; 1 g 5 f 0 ; 1 ; 1 ; 0 ; 1 ; 1 ; 1 ; 1 g 2 f 0 ; 1 ; 1 ; 0 ; 1 ; 1 ; 1 ; 1 ; 0 g 1 f 0 ; 1 ; 1 ; 0 ; 1 ; 1 ; 1 ; 1 ; 0 ; 1 g table 9.1  algorithm trace of tobinary 9.3 attaining the greatest common denomina tor of two numbers a fairly routine problem in mathematics is that of Â ¯ nding the greatest common denominator of two integers  what we are essentially after is the greatest number which is a multiple of both  e.g the greatest common denominator of 9  and 15 is 3 one of the most elegant solutions to this problem is based on euclid 's algorithm that has a run time complexity of o  n2   1  algorithm greatestcommondenominator  m  n  2  pre  m and n are integers 3  post  the greatest common denominator of the two integers is calculated 4  if n = 0 5  return m 6  end if 7  return greatestcommondenominator  n  m % n  8  end greatestcommondenominator chapter 9 numeric 74 9.4 computing the maximum value for a num ber of a speci Â ¯ c base consisting of n digits this algorithm computes the maximum value of a number for a given number of digits  e.g using the base 10 system the maximum number we can have made up of 4 digits is the number 999910 similarly the maximum number that consists of 4 digits for a base 2 number is 11112 which is 1510  the expression by which we can compute this maximum value for n digits is  bn Â ¡ 1 in the previous expression b is the number base  and n is the number of digits as an example if we wanted to determine the maximum value for a hexadecimal number  base 16  consisting of 6 digits the expression would be as follows  166 Â ¡ 1 the maximum value of the previous example would be represented as ffffff16 which yields 1677721510  in the following algorithm numberbase should be considered restricted to the values of 2  8  9  and 16 for this reason in our actual implementation numberbase has an enumeration type the base enumeration type is de Â ¯ ned as  base = fbinary Ã ƒ 2 ; octal Ã ƒ 8 ; decimal Ã ƒ 10 ; hexadecimal Ã ƒ 16g the reason we provide the de Â ¯ nition of base is to give you an idea how this algorithm can be modelled in a more readable manner rather than using various checks to determine the correct base to use for our implementation we cast the value of numberbase to an integer  as such we extract the value associated with the relevant option in the base enumeration as an example if we were to cast the option octal to an integer we would get the value 8 in the algorithm listed below the cast is implicit so we just use the actual argument numberbase  1  algorithm maxvalue  numberbase  n  2  pre  numberbase is the number system to use  n is the number of digits 3  post  the maximum value for numberbase consisting of n digits is computed 4  return power  numberbase ; n  Â ¡ 1 5  end maxvalue 9.5 factorial of a number attaining the factorial of a number is a primitive mathematical operation many implementations of the factorial algorithm are recursive as the problem is re cursive in nature  however here we present an iterative solution the iterative solution is presented because it too is trivial to implement and does n't su Â ® er from the use of recursion  for more on recursion see xc   the factorial of 0 and 1 is 0 the aforementioned acts as a base case that we will build upon the factorial of 2 is 2 Â ¤ the factorial of 1  similarly the factorial of 3 is 3 Â ¤ the factorial of 2 and so on we can indicate that we are after the factorial of a number using the form n ! where n is the number we wish to attain the factorial of our algorithm does n't use such notation but it is handy to know  chapter 9 numeric 75 1  algorithm factorial  n  2  pre  n Â ¸ 0  n is the number to compute the factorial of 3  post  the factorial of n is computed 4  if n < 2 5  return 1 6  end if 7  factorial Ã ƒ 1 8  for i Ã ƒ 2 to n 9  factorial Ã ƒ factorial Â ¤ i 10  end for 11  return factorial 12  end factorial 9.6 summary in this chapter we have presented several numeric algorithms  most of which are simply here because they were fun to design perhaps the message that the reader should gain from this chapter is that algorithms can be applied to several domains to make work in that respective domain attainable numeric algorithms in particular drive some of the most advanced systems on the planet computing such data as weather forecasts  chapter 10 searching 10.1 sequential search a simple algorithm that search for a speci Â ¯ c item inside a list it operates looping on each element o  n  until a match occurs or the end is reached  1  algorithm sequentialsearch  list  item  2  pre  list 6 = ; 3  post  return index of item if found  otherwise Â ¡ 1 4  index Ã ƒ 0 5  while index < list.count and list  index  6 = item 6  index Ã ƒ index + 1 7  end while 8  if index < list.count and list  index  = item 9  return index 10  end if 11  return Â ¡ 1 12  end sequentialsearch 10.2 probability search probability search is a statistical sequential searching algorithm in addition to searching for an item  it takes into account its frequency by swapping it with it 's predecessor in the list the algorithm complexity still remains at o  n  but in a non-uniform items search the more frequent items are in the Â ¯ rst positions  reducing list scanning time  figure 10.1 shows the resulting state of a list after searching for two items  notice how the searched items have had their search probability increased after each search operation respectively  76 chapter 10 searching 77 figure 10.1  a  search  12   b  search  101  1  algorithm probabilitysearch  list  item  2  pre  list 6 = ; 3  post  a boolean indicating where the item is found or not ; in the former case swap founded item with its predecessor 4  index Ã ƒ 0 5  while index < list.count and list  index  6 = item 6  index Ã ƒ index + 1 7  end while 8  if index Â ¸ list.count or list  index  6 = item 9  return false 10  end if 11  if index > 0 12  swap  list  index  ; list  index Â ¡ 1   13  end if 14  return true 15  end probabilitysearch 10.3 summary in this chapter we have presented a few novel searching algorithms we have presented more e Â ± cient searching algorithms earlier on  like for instance the logarithmic searching algorithm that avl and bst tree 's use  de Â ¯ ned in x3.2   we decided not to cover a searching algorithm known as binary chop  another name for binary search  binary chop usually refers to its array counterpart  as chapter 10 searching 78 the reader has already seen such an algorithm in x3  searching algorithms and their e Â ± ciency largely depends on the underlying data structure being used to store the data for instance it is quicker to deter mine whether an item is in a hash table than it is an array  similarly it is quicker to search a bst than it is a linked list if you are going to search for data fairly often then we strongly advise that you sit down and research the data structures available to you in most cases using a list or any other primarily linear data structure is down to lack of knowledge model your data and then research the data structures that best Â ¯ t your scenario  chapter 11 strings strings have their own chapter in this text purely because string operations and transformations are incredibly frequent within programs the algorithms presented are based on problems the authors have come across previously  or were formulated to satisfy curiosity  11.1 reversing the order of words in a sentence de Â ¯ ning algorithms for primitive string operations is simple  e.g extracting a sub-string of a string  however some algorithms that require more inventiveness can be a little more tricky  the algorithm presented here does not simply reverse the characters in a string  rather it reverses the order of words within a string this algorithm works on the principal that words are all delimited by white space  and using a few markers to de Â ¯ ne where words start and end we can easily reverse them  79 chapter 11 strings 80 1  algorithm reversewords  value  2  pre  value 6 = ;  sb is a string bu Â ® er 3  post  the words in value have been reversed 4  last Ã ƒ value.length Â ¡ 1 5  start Ã ƒ last 6  while last Â ¸ 0 7  // skip whitespace 8  while start Â ¸ 0 and value  start  = whitespace 9  start Ã ƒ start Â ¡ 1 10  end while 11  last Ã ƒ start 12  // march down to the index before the beginning of the word 13  while start Â ¸ 0 and start 6 = whitespace 14  start Ã ƒ start Â ¡ 1 15  end while 16  // append chars from start + 1 to length + 1 to string bu Â ® er sb 17  for i Ã ƒ start + 1 to last 18  sb.append  value  i   19  end for 20  // if this is n't the last word in the string add some whitespace after the word in the bu Â ® er 21  if start > 0 22  sb.append  ` '  23  end if 24  last Ã ƒ start Â ¡ 1 25  start Ã ƒ last 26  end while 27  // check if we have added one too many whitespace to sb 28  if sb  sb.length Â ¡ 1  = whitespace 29  // cut the whitespace 30  sb.length Ã ƒ sb.length Â ¡ 1 31  end if 32  return sb 33  end reversewords 11.2 detecting a palindrome although not a frequent algorithm that will be applied in real-life scenarios detecting a palindrome is a fun  and as it turns out pretty trivial algorithm to design  the algorithm that we present has a o  n  run time complexity our algo rithm uses two pointers at opposite ends of string we are checking is a palindrome or not these pointers march in towards each other always checking that each character they point to is the same with respect to value figure 11.1 shows the ispalindrome algorithm in operation on the string \ was it eliot 's toilet i saw ? " if you remove all punctuation  and white space from the aforementioned string you will Â ¯ nd that it is a valid palindrome  chapter 11 strings 81 figure 11.1  left and right pointers marching in towards one another 1  algorithm ispalindrome  value  2  pre  value 6 = ; 3  post  value is determined to be a palindrome or not 4  word Ã ƒ value.strip   .touppercase   5  left Ã ƒ 0 6  right Ã ƒ word.length Â ¡ 1 7  while word  left  = word  right  and left < right 8  left Ã ƒ left + 1 9  right Ã ƒ right Â ¡ 1 10  end while 11  return word  left  = word  right  12  end ispalindrome in the ispalindrome algorithm we call a method by the name of strip this algorithm discards punctuation in the string  including white space as a result word contains a heavily compacted representation of the original string  each character of which is in its uppercase representation  palindromes discard white space  punctuation  and case making these changes allows us to design a simple algorithm while making our algorithm fairly robust with respect to the palindromes it will detect  11.3 counting the number of words in a string counting the number of words in a string can seem pretty trivial at Â ¯ rst  however there are a few cases that we need to be aware of  1 tracking when we are in a string 2 updating the word count at the correct place 3 skipping white space that delimits the words as an example consider the string \ ben ate hay " clearly this string contains three words  each of which distinguished via white space all of the previously listed points can be managed by using three variables  1 index 2 wordcount 3 inword chapter 11 strings 82 figure 11.2  string with three words figure 11.3  string with varying number of white space delimiting the words of the previously listed index keeps track of the current index we are at in the string  wordcount is an integer that keeps track of the number of words we have encountered  and Â ¯ nally inword is a boolean Â ° ag that denotes whether or not at the present time we are within a word if we are not currently hitting white space we are in a word  the opposite is true if at the present index we are hitting white space  what denotes a word ? in our algorithm each word is separated by one or more occurrences of white space we do n't take into account any particular splitting symbols you may use  e.g in .net string.split1 can take a char  or array of characters  that determines a delimiter to use to split the characters within the string into chunks of strings  resulting in an array of sub-strings  in figure 11.2 we present a string indexed as an array typically the pattern is the same for most words  delimited by a single occurrence of white space  figure 11.3 shows the same string  with the same number of words but with varying white space splitting them  1http  //msdn.microsoft.com/en-us/library/system.string.split.aspx chapter 11 strings 83 1  algorithm wordcount  value  2  pre  value 6 = ; 3  post  the number of words contained within value is determined 4  inword Ã ƒ true 5  wordcount Ã ƒ 0 6  index Ã ƒ 0 7  // skip initial white space 8  while value  index  = whitespace and index < value.length Â ¡ 1 9  index Ã ƒ index + 1 10  end while 11  // was the string just whitespace ? 12  if index = value.length and value  index  = whitespace 13  return 0 14  end if 15  while index < value.length 16  if value  index  = whitespace 17  // skip all whitespace 18  while value  index  = whitespace and index < value.length Â ¡ 1 19  index Ã ƒ index + 1 20  end while 21  inword Ã ƒ false 22  wordcount Ã ƒ wordcount + 1 23  else 24  inword Ã ƒ true 25  end if 26  index Ã ƒ index + 1 27  end while 28  // last word may have not been followed by whitespace 29  if inword 30  wordcount Ã ƒ wordcount + 1 31  end if 32  return wordcount 33  end wordcount 11.4 determining the number of repeated words within a string with the help of an unordered set  and an algorithm that can split the words within a string using a speci Â ¯ ed delimiter this algorithm is straightforward to implement if we split all the words using a single occurrence of white space as our delimiter we get all the words within the string back as elements of an array then if we iterate through these words adding them to a set which contains only unique strings we can attain the number of unique words from the string all that is left to do is subtract the unique word count from the total number of stings contained in the array returned from the split operation the split operation that we refer to is the same as that mentioned in x11.3  chapter 11 strings 84 figure 11.4  a  undesired uniques set ; b  desired uniques set 1  algorithm repeatedwordcount  value  2  pre  value 6 = ; 3  post  the number of repeated words in value is returned 4  words Ã ƒ value.split  ' '  5  uniques Ã ƒ set 6  foreach word in words 7  uniques.add  word.strip    8  end foreach 9  return words.length Â ¡ uniques.count 10  end repeatedwordcount you will notice in the repeatedwordcount algorithm that we use the strip method we referred to earlier in x11.1 this simply removes any punctuation from a word the reason we perform this operation on each word is so that we can build a more accurate unique string collection  e.g \ test "  and \ test ! " are the same word minus the punctuation figure 11.4 shows the undesired and desired sets for the unique set respectively  11.5 determining the Â ¯ rst matching character between two strings the algorithm to determine whether any character of a string matches any of the characters in another string is pretty trivial put simply  we can parse the strings considered using a double loop and check  discarding punctuation  the equality between any characters thus returning a non-negative index that represents the location of the Â ¯ rst character in the match  figure 11.5  ; otherwise we return -1 if no match occurs this approach exhibit a run time complexity of o  n2   chapter 11 strings 85 t e s t 0 1 2 3 4 p t e r s 0 1 2 3 4 5 6 word match i t e s t 0 1 2 3 4 p t e r s 0 1 2 3 4 5 6 i index t e s t 0 1 2 3 4 p t e r s 0 1 2 3 4 5 6 i index index a  b  c  figure 11.5  a  first step ; b  second step c  match occurred 1  algorithm any  word,match  2  pre  word ; match 6 = ; 3  post  index representing match location if occured  Â ¡ 1 otherwise 4  for i Ã ƒ 0 to word  length Â ¡ 1 5  while word  i  = whitespace 6  i Ã ƒ i + 1 7  end while 8  for index Ã ƒ 0 to match  length Â ¡ 1 9  while match  index  = whitespace 10  index Ã ƒ index + 1 11  end while 12  if match  index  = word  i  13  return index 14  end if 15  end for 16  end for 17  return Â ¡ 1 18  end any 11.6 summary we hope that the reader has seen how fun algorithms on string data types are strings are probably the most common data type  and data structure  remember we are dealing with an array  that you will work with so its important that you learn to be creative with them we for one Â ¯ nd strings fascinating a simple google search on string nuances between languages and encodings will provide you with a great number of problems now that we have spurred you along a little with our introductory algorithms you can devise some of your own  appendix a algorithm walkthrough learning how to design good algorithms can be assisted greatly by using a structured approach to tracing its behaviour in most cases tracing an algorithm only requires a single table in most cases tracing is not enough  you will also want to use a diagram of the data structure your algorithm operates on this diagram will be used to visualise the problem more e Â ® ectively seeing things visually can help you understand the problem quicker  and better  the trace table will store information about the variables used in your algo rithm the values within this table are constantly updated when the algorithm mutates them such an approach allows you to attain a history of the various values each variable has held you may also be able to infer patterns from the values each variable has contained so that you can make your algorithm more e Â ± cient  we have found this approach both simple  and powerful by combining a visual representation of the problem as well as having a history of past values generated by the algorithm it can make understanding  and solving problems much easier  in this chapter we will show you how to work through both iterative  and recursive algorithms using the technique outlined  a.1 iterative algorithms we will trace the ispalindrome algorithm  de Â ¯ ned in x11.2  as our example iterative walkthrough before we even look at the variables the algorithm uses  Â ¯ rst we will look at the actual data structure the algorithm operates on it should be pretty obvious that we are operating on a string  but how is this represented ? a string is essentially a block of contiguous memory that consists of some char data types  one after the other each character in the string can be accessed via an index much like you would do when accessing items within an array the picture should be presenting itself  a string can be thought of as an array of characters  for our example we will use ispalindrome to operate on the string \ never odd or even " now we know how the string data structure is represented  and the value of the string we will operate on let 's go ahead and draw it as shown in figure a.1  86 appendix a algorithm walkthrough 87 figure a.1  visualising the data structure we are operating on value word left right table a.1  a column for each variable we wish to track the ispalindrome algorithm uses the following list of variables in some form throughout its execution  1 value 2 word 3 left 4 right having identi Â ¯ ed the values of the variables we need to keep track of we simply create a column for each in a table as shown in table a.1  now  using the ispalindrome algorithm execute each statement updating the variable values in the table appropriately table a.2 shows the Â ¯ nal table values for each variable used in ispalindrome respectively  while this approach may look a little bloated in print  on paper it is much more compact where we have the strings in the table you should annotate these strings with array indexes to aid the algorithm walkthrough  there is one other point that we should clarify at this time  whether to include variables that change only a few times  or not at all in the trace table  in table a.2 we have included both the value  and word variables because it was convenient to do so you may Â ¯ nd that you want to promote these values to a larger diagram  like that in figure a.1  and only use the trace table for variables whose values change during the algorithm we recommend that you promote the core data structure being operated on to a larger diagram outside of the table so that you can interrogate it more easily  value word left right \ never odd or even " \ neveroddoreven " 0 13 1 12 2 11 3 10 4 9 5 8 6 7 7 6 table a.2  algorithm trace for ispalindrome appendix a algorithm walkthrough 88 we can not stress enough how important such traces are when designing your algorithm you can use these trace tables to verify algorithm correctness  at the cost of a simple table  and quick sketch of the data structure you are operating on you can devise correct algorithms quicker visualising the problem domain and keeping track of changing data makes problems a lot easier to solve  moreover you always have a point of reference which you can look back on  a.2 recursive algorithms for the most part working through recursive algorithms is as simple as walking through an iterative algorithm one of the things that we need to keep track of though is which method call returns to who most recursive algorithms are much simple to follow when you draw out the recursive calls rather than using a table based approach in this section we will use a recursive implementation of an algorithm that computes a number from the fiboncacci sequence  1  algorithm fibonacci  n  2  pre  n is the number in the Â ¯ bonacci sequence to compute 3  post  the Â ¯ bonacci sequence number n has been computed 4  if n < 1 5  return 0 6  else if n < 2 7  return 1 8  end if 9  return fibonacci  n Â ¡ 1  + fibonacci  n Â ¡ 2  10  end fibonacci before we jump into showing you a diagrammtic representation of the algo rithm calls for the fibonacci algorithm we will brie Â ° y talk about the cases of the algorithm the algorithm has three cases in total  1 n < 1 2 n < 2 3 n Â ¸ 2 the Â ¯ rst two items in the preceeding list are the base cases of the algorithm  until we hit one of our base cases in our recursive method call tree we wo n't return anything the third item from the list is our recursive case  with each call to the recursive case we etch ever closer to one of our base cases figure a.2 shows a diagrammtic representation of the recursive call chain  in figure a.2 the order in which the methods are called are labelled figure a.3 shows the call chain annotated with the return values of each method call as well as the order in which methods return to their callers in figure a.3 the return values are represented as annotations to the red arrows  it is important to note that each recursive call only ever returns to its caller upon hitting one of the two base cases when you do eventually hit a base case that branch of recursive calls ceases upon hitting a base case you go back to appendix a algorithm walkthrough 89 figure a.2  call chain for fibonacci algorithm figure a.3  return chain for fibonacci algorithm appendix a algorithm walkthrough 90 the caller and continue execution of that method execution in the caller is contiued at the next statement  or expression after the recursive call was made  in the fibonacci algorithms ' recursive case we make two recursive calls  when the Â ¯ rst recursive call  fibonacci  n Â ¡ 1   returns to the caller we then execute the the second recursive call  fibonacci  n Â ¡ 2    after both recursive calls have returned to their caller  the caller can then subesequently return to its caller and so on  recursive algorithms are much easier to demonstrate diagrammatically as figure a.2 demonstrates when you come across a recursive algorithm draw method call diagrams to understand how the algorithm works at a high level  a.3 summary understanding algorithms can be hard at times  particularly from an implemen tation perspective in order to understand an algorithm try and work through it using trace tables in cases where the algorithm is also recursive sketch the recursive calls out so you can visualise the call/return chain  in the vast majority of cases implementing an algorithm is simple provided that you know how the algorithm works mastering how an algorithm works from a high level is key for devising a well designed solution to the problem in hand  appendix b translation walkthrough the conversion from pseudo to an actual imperative language is usually very straight forward  to clarify an example is provided in this example we will convert the algorithm in x9.1 to the c # language  1  public static bool isprime  int number  2  f 3  if  number < 2  4  f 5  return false ; 6  g 7  int innerloopbound =  int  math.floor  math.sqrt  number   ; 8  for  int i = 1 ; i < number ; i + +  9  f 10  for  int j = 1 ; j < = innerloopbound ; j + +  11  f 12  if  i Â ¤ j = = number  13  f 14  return false ; 15  g 16  g 17  g 18  return true ; 19  g for the most part the conversion is a straight forward process  however you may have to inject various calls to other utility algorithms to ascertain the correct result  a consideration to take note of is that many algorithms have fairly strict preconditions  of which there may be several  in these scenarios you will need to inject the correct code to handle such situations to preserve the correctness of the algorithm most of the preconditions can be suitably handled by throwing the correct exception  91 appendix b translation walkthrough 92 b.1 summary as you can see from the example used in this chapter we have tried to make the translation of our pseudo code algorithms to mainstream imperative languages as simple as possible  whenever you encounter a keyword within our pseudo code examples that you are unfamiliar with just browse to appendix e which descirbes each key word  appendix c recursive vs iterative solutions one of the most succinct properties of modern programming languages like c + +  c #  and java  as well as many others  is that these languages allow you to de Â ¯ ne methods that reference themselves  such methods are said to be recursive one of the biggest advantages recursive methods bring to the table is that they usually result in more readable  and compact solutions to problems  a recursive method then is one that is de Â ¯ ned in terms of itself generally a recursive algorithms has two main properties  1 one or more base cases ; and 2 a recursive case for now we will brie Â ° y cover these two aspects of recursive algorithms with each recursive call we should be making progress to our base case otherwise we are going to run into trouble the trouble we speak of manifests itself typically as a stack over Â ° ow  we will describe why later  now that we have brie Â ° y described what a recursive algorithm is and why you might want to use such an approach for your algorithms we will now talk about iterative solutions an iterative solution uses no recursion whatsoever  an iterative solution relies only on the use of loops  e.g for  while  do-while  etc   the down side to iterative algorithms is that they tend not to be as clear as to their recursive counterparts with respect to their operation the major advantage of iterative solutions is speed most production software you will Â ¯ nd uses little or no recursive algorithms whatsoever the latter property can sometimes be a companies prerequisite to checking in code  e.g upon checking in a static analysis tool may verify that the code the developer is checking in contains no recursive algorithms normally it is systems level code that has this zero tolerance policy for recursive algorithms  using recursion should always be reserved for fast algorithms  you should avoid it for the following algorithm run time de Â ¯ ciencies  1 o  n2  2 o  n3  93 appendix c recursive vs iterative solutions 94 3 o  2n  if you use recursion for algorithms with any of the above run time e Â ± ciency 's you are inviting trouble the growth rate of these algorithms is high and in most cases such algorithms will lean very heavily on techniques like divide and conquer while constantly splitting problems into smaller problems is good practice  in these cases you are going to be spawning a lot of method calls all this overhead  method calls do n't come that cheap  will soon pile up and either cause your algorithm to run a lot slower than expected  or worse  you will run out of stack space when you exceed the allotted stack space for a thread the process will be shutdown by the operating system this is the case irrespective of the platform you use  e.g .net  or native c + + etc you can ask for a bigger stack size  but you typically only want to do this if you have a very good reason to do so  c.1 activation records an activation record is created every time you invoke a method put simply an activation record is something that is put on the stack to support method invocation activation records take a small amount of time to create  and are pretty lightweight  normally an activation record for a method call is as follows  this is very general   Â ² the actual parameters of the method are pushed onto the stack Â ² the return address is pushed onto the stack Â ² the top-of-stack index is incremented by the total amount of memory required by the local variables within the method Â ² a jump is made to the method in many recursive algorithms operating on large data structures  or algo rithms that are ine Â ± cient you will run out of stack space quickly consider an algorithm that when invoked given a speci Â ¯ c value it creates many recursive calls in such a case a big chunk of the stack will be consumed we will have to wait until the activation records start to be unwound after the nested methods in the call chain exit and return to their respective caller when a method exits it 's activation record is unwound unwinding an activation record results in several steps  1 the top-of-stack index is decremented by the total amount of memory consumed by the method 2 the return address is popped o Â ® the stack 3 the top-of-stack index is decremented by the total amount of memory consumed by the actual parameters appendix c recursive vs iterative solutions 95 while activation records are an e Â ± cient way to support method calls they can build up very quickly recursive algorithms can exhaust the stack size allocated to the thread fairly fast given the chance  just about now we should be dusting the cobwebs o Â ® the age old example of an iterative vs recursive solution in the form of the fibonacci algorithm this is a famous example as it highlights both the beauty and pitfalls of a recursive algorithm the iterative solution is not as pretty  nor self documenting but it does the job a lot quicker if we were to give the fibonacci algorithm an input of say 60 then we would have to wait a while to get the value back because it has an o  gn  run time the iterative version on the other hand has a o  n  run time do n't let this put you o Â ® recursion this example is mainly used to shock programmers into thinking about the rami Â ¯ cations of recursion rather than warning them o Â ®  c.2 some problems are recursive in nature something that you may come across is that some data structures and algo rithms are actually recursive in nature a perfect example of this is a tree data structure a common tree node usually contains a value  along with two point ers to two other nodes of the same node type as you can see tree is recursive in its makeup wit each node possibly pointing to two other nodes  when using recursive algorithms on tree 's it makes sense as you are simply adhering to the inherent design of the data structure you are operating on of course it is not all good news  after all we are still bound by the limitations we have mentioned previously in this chapter  we can also look at sorting algorithms like merge sort  and quick sort both of these algorithms are recursive in their design and so it makes sense to model them recursively  c.3 summary recursion is a powerful tool  and one that all programmers should know of  often software projects will take a trade between readability  and e Â ± ciency in which case recursion is great provided you do n't go and use it to implement an algorithm with a quadratic run time or higher of course this is not a rule of thumb  this is just us throwing caution to the wind defensive coding will always prevail  many times recursion has a natural home in recursive data structures and algorithms which are recursive in nature using recursion in such scenarios is perfectly acceptable using recursion for something like linked list traversal is a little overkill its iterative counterpart is probably less lines of code than its recursive counterpart  because we can only talk about the implications of using recursion from an abstract point of view you should consult your compiler and run time environ ment for more details it may be the case that your compiler recognises things like tail recursion and can optimise them this is n't unheard of  in fact most commercial compilers will do this the amount of optimisation compilers can appendix c recursive vs iterative solutions 96 do though is somewhat limited by the fact that you are still using recursion  you  as the developer have to accept certain accountability 's for performance  appendix d testing testing is an essential part of software development testing has often been discarded by many developers in the belief that the burden of proof of their software is on those within the company who hold test centric roles this could n't be further from the truth as a developer you should at least provide a suite of unit tests that verify certain boundary conditions of your software  a great thing about testing is that you build up progressively a safety net if you add or tweak algorithms and then run your suite of tests you will be quickly alerted to any cases that you have broken with your recent changes such a suite of tests in any sizeable project is absolutely essential to maintaining a fairly high bar when it comes to quality of course in order to attain such a standard you need to think carefully about the tests that you construct  unit testing which will be the subject of the vast majority of this chapter are widely available on most platforms most modern languages like c + +  c #  and java o Â ® er an impressive catalogue of testing frameworks that you can use for unit testing  the following list identi Â ¯ es testing frameworks which are popular  junit  targeted at jav  http  //www.junit.org/ nunit  can be used with languages that target microsoft 's common language runtime http  //www.nunit.org/index.php boost test library  targeted at c + +  the test library that ships with the incredibly popular boost libraries http  //www.boost.org a direct link to the libraries doc umentation http  //www.boost.org/doc/libs/1_36_0/libs/test/doc/ html/index.html cppunit  targeted at c + +  http  //cppunit.sourceforge.net/ do n't worry if you think that the list is very sparse  there are far more on o Â ® er than those that we have listed the ones listed are the testing frameworks that we believe are the most popular for c + +  c #  and java  d.1 what constitutes a unit test ? a unit test should focus on a single atomic property of the subject being tested  do not try and test many things at once  this will result in a suite of somewhat 97 appendix d testing 98 unstructured tests as an example if you were wanting to write a test that veri Â ¯ ed that a particular value v is returned from a speci Â ¯ c input i then your test should do the smallest amount of work possible to verify that v is correct given i a unit test should be simple and self describing  as well as a unit test being relatively atomic you should also make sure that your unit tests execute quickly if you can imagine in the future when you may have a test suite consisting of thousands of tests you want those tests to execute as quickly as possible failure to attain such a goal will most likely result in the suite of tests not being ran that often by the developers on your team this can occur for a number of reasons but the main one would be that it becomes incredibly tedious waiting several minutes to run tests on a developers local machine  building up a test suite can help greatly in a team scenario  particularly when using a continuous build server in such a scenario you can have the suite of tests devised by the developers and testers ran as part of the build process  employing such strategies can help you catch niggling little error cases early rather than via your customer base there is nothing more embarrassing for a developer than to have a very trivial bug in their code reported to them from a customer  d.2 when should i write my tests ? a source of great debate would be an understatement to personify such a ques tion as this in recent years a test driven approach to development has become very popular such an approach is known as test driven development  or more commonly the acronym tdd  one of the founding principles of tdd is to write the unit test Â ¯ rst  watch it fail and then make it pass the premise being that you only ever write enough code at any one time to satisfy the state based assertions made in a unit test we have found this approach to provide a more structured intent to the implementation of algorithms at any one stage you only have a single goal  to make the failing test pass because tdd makes you write the tests up front you never Â ¯ nd yourself in a situation where you forget  or ca n't be bothered to write tests for your code this is often the case when you write your tests after you have coded up your implementation we  as the authors of this book ourselves use tdd as our preferred method  as we have already mentioned that tdd is our favoured approach to testing it would be somewhat of an injustice to not list  and describe the mantra that is often associate with it  red  signi Â ¯ es that the test has failed  green  the failing test now passes  refactor  can we restructure our program so it makes more sense  and easier to maintain ? the Â ¯ rst point of the above list always occurs at least once  more if you count the build error  in tdd initially your task at this stage is solely to make the test pass  that is to make the respective test green the last item is based around appendix d testing 99 the restructuring of your program to make it as readable and maintainable as possible the last point is very important as tdd is a progressive methodology to building a solution if you adhere to progressive revisions of your algorithm restructuring when appropriate you will Â ¯ nd that using tdd you can implement very cleanly structured types and so on  d.3 how seriously should i view my test suite ? your tests are a major part of your project ecosystem and so they should be treated with the same amount of respect as your production code this ranges from correct  and clean code formatting  to the testing code being stored within a source control repository  employing a methodology like tdd  or testing after implementing you will Â ¯ nd that you spend a great amount of time writing tests and thus they should be treated no di Â ® erently to your production code all tests should be clearly named  and fully documented as to their intent  d.4 the three a 's now that you have a sense of the importance of your test suite you will inevitably want to know how to actually structure each block of imperatives within a single unit test a popular approach  the three a 's is described in the following list  assemble  create the objects you require in order to perform the state based asser tions  act  invoke the respective operations on the objects you have assembled to mutate the state to that desired for your assertions  assert  specify what you expect to hold after the previous two steps  the following example shows a simple test method that employs the three a 's  public void mytest   f // assemble type t = new type   ; // act t.methoda   ; // assert assert.istrue  t.boolexpr  g d.5 the structuring of tests structuring tests can be viewed upon as being the same as structuring pro duction code  e.g all unit tests for a person type may be contained within appendix d testing 100 a persontest type typically all tests are abstracted from production code  that is that the tests are disjoint from the production code  you may have two dynamic link libraries  dll  ; the Â ¯ rst containing the production code  the second containing your test code  we can also use things like inheritance etc when de Â ¯ ning classes of tests  the point being that the test code is very much like your production code and you should apply the same amount of thought to its structure as you would do the production code  d.6 code coverage something that you can get as a product of unit testing are code coverage statistics code coverage is merely an indicator as to the portions of production code that your units tests cover using tdd it is likely that your code coverage will be very high  although it will vary depending on how easy it is to use tdd within your project  d.7 summary testing is key to the creation of a moderately stable product moreover unit testing can be used to create a safety blanket when adding and removing features providing an early warning for breaking changes within your production code  appendix e symbol de Â ¯ nitions throughout the pseudocode listings you will Â ¯ nd several symbols used  describes the meaning of each of those symbols  symbol description Ã ƒ assignment  = equality  Â · less than or equal to  < less than * Â ¸ greater than or equal to  > greater than * 6 = inequality  ; null  and logical and  or logical or  whitespace single occurrence of whitespace  yield like return but builds a sequence  table e.1  pseudo symbol de Â ¯ nitions * this symbol has a direct translation with the vast majority of imperative counterparts  101 