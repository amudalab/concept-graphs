structures and algorithms
naveen garg department
department of computer
science and engineering
engineering indian institute
institute of technology
queues and linked
lecture we looked
looked at stacks
list and double
double ended queues
stack the stack
last-in first-out principle
removed first queue
principle whoever joins
joins the queue
queue for instance
element is inserted
remove an element
element from queue
insert an element
front is removed
removed the queue
abstract data type
queue the methods
operations the method
create a queue
queue and enqueue
method to add
add an element
queue and dequeue
dequeue a queue
queue the front
differ from dequeue
remove the front
implement the queue
queue and isempty
queue is empty
define similar axioms
axioms for queues
element or enqueue
enqueue an element
suppose i create
dequeue an element
enqueued an element
means i added
added an element
added another element
front of queue
notion of front
removed an element
element the element
queue was empty
result is true
first i added
cases the queue
procedure if queue
thing in enqueue
dequeued which means
means i removed
removed the front
element of queue
queue the queue
implement a queue
fashion to implement
suppose someone tells
allocate an array
array of size
element the blue
reach the blue
blue colored part
element i inserted
delete the elements
effect the elements
element has moved
moved to right
right this implies
deleted f-1 elements
inserting the elements
elements in queue
queue i insert
insert another element
insert anymore elements
reached the end
elements your queue
started the front
front was referring
point i reach
reach a situation
empty or full
removing the elements
adding the elements
move one step
empty and full
n-1 one elements
code for enqueue
number of elements
queue is full
return the queue
queue full exception
case then add
add the rear
put the element
insert and increment
modn is required
enclosed in brackets
return r-f r-f
r-f is negative
check this out
means the queue
method for front
raises an exception
return a front
removing the front
case of dequeue
increment the front
index and remove
element by setting
array to implement
implement our queue
queue the disadvantage
array is fixed
double the size
essentially a linked
list the first
node is referred
tail of list
list to implement
queue the head
2nd second element
remove the torcezo
element the linked
element from linked
remove that element
accessing that pointer
remove the rome
queue the removal
remove the element
implement our methods
dequeue which means
left head part
point the head
making the head
delete the head
node and make
make the head
node thus inserting
easy the head
move the head
queue the pointer
modified to point
newly added element
difficult to remove
element in constant
remove the tail
access the previous
kind of list
beginning and move
problem in removing
node the problem
last before node
make the tail
head and add
means the front
queue data type
introduce another data
type called double-ended
insert and delete
queue and remove
operations of insert
singly linked list
idea to implement
doubly linked list
implement double-ended queues
list has nodes
two sentinel nodes
nodes each node
operations of double-ended
queue in constant
delete the node
end the head
follow the pointer
element to delete
delete that node
port and set
pointer to trailer
trailer and send
send the previous
pointer of trailer
header and trailer
list these nodes
nodes or dummy
mark the start
delete san francisco
make the sentinel
sentinel node point
make that previous
node to point
node is deleted
done in constant
front or delete
meant by constant
independent of number
fairly generic data
generic data type
implement other data
types also suppose
implementation of double-ended
make a stack
implementation to implement
implement a stack
stack for instance
stack would correspond
queue.thus the method
return the last
queue the method
correspond to inserting
double ended queue
correspond to deleting
make the last
case the last
front and insert
corresponds to isempty
queue to implement
corresponds to last
removes the first
methods to implement
stack or queue
pattern thus adapter
adapter patterns implements
implements a class
class using methods
class in general
adapter classes specialize
classes specialize general
specialize general classes
applications one application
implement by changing
changing some methods
queue another application
stack we define
define an interface
interface called stack
stack and implemented
array that implementation
contents of array
adapt arraystack implementation
implementation called integerarraystack
cast the type
stack or removing
circularly linked list
element is pointing
head and tail
implement both queue
structure to implement
make the first
rear to add
make the pointer
make the element
node and create
node and copy
copy the element
node and copying
removing an element
corresponds to removing
removing the first
remove the first
problem in doing
copy the contents
rome i copy
seattle to rome
rome thus rome
rome has seattle
remove the 2nd
2nd node copying
copying just means
changing the reference
discusses about queues
queues and double-ended
talk about vectors
list and general
structures like arrays
arrays and linked
lists to implement
implement these data
vector data type
data type vector
type vector data
elements that supports
notion of rank
sequence of elements
methods like elematrank
elematrank r rank
rank here corresponds
integers first element
element at rank
give the element
replace the element
delete the element
suppose the departmental
department the department
implement the data
type using arrays
element with rank
put an element
n-1 one step
n-2 is moved
moved one step
right finally element
put at position
size is increased
sores the size
shifting the entire
elements one step
left all elements
sitting at location
worst case order
left this implementation
implementation is expensive
point of view
two operations insert
rank or remove
worst case spent
case spent order
operations are faster
array and retrieve
retrieve the elements
sitting there replaceatrank
location and replace
replace that element
element with element
methods all methods
methods except inserted
inserted at rank
rank and remove
remove at rank
rank take constant
implementing this list
implement a vector
operation of inserting
node and put
create the node
make a pointer
make the previous
previous pointer point
insert takes order
order n times
insert at rank
insert the element
code for inserting
assuming the existence
rank for instance
insert the node
node at rank
call the procedure
procedure with rank
previous to rank
prev i create
set its previous
prev = next.getprev
earlier at rank
manner i create
check the previous
doing here next.setprev
process of deletion
out the node
node and update
pointer will point
node and previous
code for doing
assuming the procedure
implement this procedure
incrementing my counter
reach that rank
list has hundred
point to start
vector abstract data
type is concerned
rank or insert
move the elements
insert or delete
delete linked lists
supporting node based
node based operations
delete this node
node in constant
node and insert
delete the inserted
insert a node
constant time operations
mentioned below removeatnode
give you access
implemented my list
pointers and stuff
node based operation
operation without knowing
knowing the actual
thing was done
notion of positions
captures the place
element is stored
data type position
call this method
making much sense
position as reference
access the element
pointer to update
node is implemented
type which hides
notion of position
order of positions
position is referring
similarly 1st position
define a list
list abstract datatype
methods like size
method which asks
methods like first
first will give
last would give
methods like swapelements
swaps the contents
positions it swaps
element at position
methods in constant
linked list data
list data structure
abstract datatype implementation
datatype this datatype
double linked list
sequence abstract data
type we talked
list data type
combines the vector
list abstract data
listed for vector
vector and list
two additional methods
methods which helps
identify the rank
implemented p corresponds
determine the position
suppose you gave
gave me rank
follow 1st reference
create new position
element would sit
change the ranks
ranks and update
update the position
position again inserting
deleting an element
wanted to delete
delete an element
comparison of sequence
implement a sequence
case of running
out the element
update the pointers
out the rank
list to figure
rank any rank
rank based operation
find the rank
out the position
learnt about queues
essentially a concretization
looked at sequence
sequence data types
data structures
naveen garg
garg department
computer science
engineering indian
indian institute
delhi lecture
linked lists
last lecture
data type
implement stacks
array today
linked list
first part
ended queues
last-in first-out
first-out principle
removed first
first queue
first-in-first-out principle
first element
rear element
front end
abstract data
standard operations
front element
support methods
isempty size
return false
defined axioms
similar axioms
empty queue
written front
initially empty
statement dequeue
remaining queue
circular fashion
blue part
queue reach
colored part
0th location
3rd element
queue drift
completely accurate
anymore elements
start inserting
right side
left side
front refers
rear refers
empty location
empty suppose
elements starting
element close
pseudo code
full exception
rear location
circular indices
modn point
method size
return r-f
r-f r-f
r-f tells
queue r-f
correct thing
positive quantity
right number
elements check
confused isempty
algorithm isempty
dequeue method
front index
maximum size
last class
size increases
first node
last node
head node
tail node
torcezo element
rome element
last place
methods suppose
left head
head part
tail part
head point
head element
head easily
first diagram
last element
rear end
added element
previous node
tail point
entire list
expensive operation
queue data
double-ended queue
delete operations
last operations
good idea
good solution
double-ended queues
previous pointer
sentinel nodes
trailer nodes
previous port
dummy nodes
data inside
san francisco
sentinel node
node point
generic data
data types
method top
top element
double-ended queue.thus
method push
method pop
ended queue
insert front
remove front
queue front
dequeue implementation
adapter pattern
adapter patterns
patterns implements
adapter classes
classes specialize
general classes
array stack
arbitrary objects
adapt arraystack
arraystack implementation
integer objects
pointers head
circular list
data structure
pointer point
big pointer
end make
element rome
node make
straight forward
queue removing
element corresponds
2nd node
node copying
general sequences
vector data
type vector
indicative methods
4th element
departmental rank
department rank
step right
entire elements
worst case
case order
operations insert
case spent
spent order
elements sitting
1st node
insert newyork
3rd diagram
takes order
java code
procedure nodeatrank
defining shortly
previous field
node dlnode
dlnode prev
dlnode node
procedure dlnode
original list
2nd diagram
previous pointers
final node
small improvement
hundred elements
vector abstract
require order
element correspond
delete linked
supporting node
node based
based operations
inserted node
operations provided
give access
based operation
actual implementation
positions position
method element
type position
previous fields
relative order
positions jus
3rd node
2nd position
3rd position
list abstract
abstract datatype
generic methods
query method
first position
last position
excessive methods
update methods
list data
datatype implementation
sequence abstract
multiple inheritance
additional methods
method atrank
array refers
rank suppose
1st reference
element stored
cross reference
sequence suppose
sequence operations
array implementation
rank based
sequence data
data
structures
algorithms
naveen
garg
department
computer
science
engineering
indian
institute
technology
delhi
lecture
queues
linked
lists
last
looked
stacks
type
implement
array
today
list
part
class
sequences
first
double
ended
queue
differ
stack
last-in
first-out
principle
element
inserted
removed
hand
first-in-first-out
joins
earlier
processed
familiar
instance
notion
rear
remove
sitting
front
end
insert
abstract
define
methods
standard
operations
method
create
enqueue
add
dequeue
support
size
isempty
elements
empty
return
true
false
defined
axioms
similar
suppose
obtained
similarly
enqueued
means
added
call
written
thing
operation
result
mentioned
procedures
q,w
check
out
assume
initially
statement
remaining
left
cases
procedure
dequeued
original
started
circular
fashion
tells
larger
allocate
variables
index
referring
blue
occupied
reach
colored
0th
location
1st
3rd
2nd
delete
effect
drift
right
moved
implies
deleted
f-1
completely
accurate
inserting
stage
anymore
reached
space
wrap
start
point
starting
side
minus
refers
situation
full
happen
removing
located
increment
adding
move
step
close
equals
ambiguity
resolve
manner
problem
ensure
n-1
declare
code
pseudo
number
stop
exception
case
put
modn
required
indices
pseudo-code
enclosed
brackets
returns
n-f
value
r-f
negative
setting
correct
quantity
positive
worst
confused
algorithm
raises
doing
null
disadvantage
fixed
maximum
idea
increases
allotted
implementation
essentially
nodes
pointers
basically
node
referred
head
tail
question
note
torcezo
permit
directly
change
pointer
accessing
rome
removal
done
place
making
easily
connect
make
easy
diagram
modified
newly
update
difficult
constant
access
previous
kind
beginning
entire
expensive
worth
introduce
double-ended
ends
singly
good
repeatedly
solution
doubly
two
sentinel
pointing
trailer
follow
port
set
send
header
dummy
inside
mark
san
francisco
shown
meant
independent
running
depended
fairly
generic
types
top
correspond
queue.thus
push
pop
deleting
corresponds
dependent
inserts
removes
adapter
pattern
patterns
implements
general
classes
specialize
applications
application
changing
interface
implemented
contents
arbitrary
objects
adapt
arraystack
integerarraystack
integer
suitably
cast
pushing
circularly
simple
list.there
structure
straight
forward
big
created
copy
copying
costly
reference
seattle
discusses
quickly
talk
vectors
positions
arrays
vector
sequence
supports
indicative
rank
7,11,13,19
4th
elematrank
integers
give
replace
students
departmental
shift
loop
moving
n-2
finally
position
increased
sores
shifting
order
view
spent
faster
takes
retrieve
replaceatrank
chart
shows
complexity
implementing
showing
diagrams
newyork
insertion
issues
find
times
17th
location.once
java
assuming
existence
nodeatrank
defining
shortly
next.getprev
prev
field
dlnode
next.setprev
prev.setnext
intimated
picture
show
process
deletion
selected
rid
final
write
march
incrementing
counter
small
improvement
hundred
concerned
implementations
require
supporting
based
efficient
provided
removeatnode
insertafternode
object
sense
telling
stuff
hide
information
knowing
actual
intuitively
captures
stored
situated
fields
implementer
hides
details
relative
jus
datatype
query
asks
excessive
swapelements
swaps
replaceelement
insertfirst
insertlast
capture
linear
talked
combines
inherits
interfaces
multiple
inheritance
listed
additional
helps
atrank
rankof
identify
middle
determine
gave
cross
sit
ranks
wanted
leave
exercise
comparison
previously
zap
figure
learnt
concretization
inheriting
