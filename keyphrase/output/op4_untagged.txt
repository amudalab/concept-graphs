principles of operating systems  lecture 1 1 ics 143  principles of operating systems lecture 1  introduction and overview mwf 11  00  11  50 a.m prof nalini venkatasubramanian  nalini @ ics.uci.edu   lecture slides contains some content adapted from  silberschatz textbook authors  john kubiatowicz  berkeley   john ousterhout  stanford  and others  welcome ! prof venkat has to be on travel to a meeting today and will be back for wednesday s class she will have a make-up lecture on friday afternoon during the discussion session  3  00 3  50 p.m   in addition to the regular class from 11  00 11  50 a.m principles of operating systems  lecture 1 2 principles of operating systems  lecture 1 3 ics 143 spring 2015 staff instructor  prof nalini venkatasubramanian  venkat   nalini @ ics.uci.edu  teaching assistant  michael beyeler  mbeyeler @ uci.edu  readers  ekin oguz  eoguz @ ics.uci.edu  hao zhang  hzhang10 @ uci.edu  principles of operating systems  lecture 1 4 course logistics and details course web page  http  //www.ics.uci.edu/ ~ ics143 lectures mwf 11  00-11  50 a.m  eh1200 discussions f 3  00-3  50 p.m  hib 100 ics 143 textbook  operating system concepts  eighth edition silberschatz and galvin  addison-wesley inc  seventh,sixth and fifth editions  and java versions are fine as well   alternate book principles of operating systems  l.f bic and a.c shaw  prentice-hall/pearson education  2003 isbn 0130266116 principles of operating systems  lecture 1 5 course logistics and details homeworks and assignments 4 written homeworks in the quarter 1 programming assignment  knowledge of c + + or java required   handed out at midterm ; submit/demo during finals week multistep assignment don t start in last week of classes ! ! ! late homeworks will not be accepted all submissions will be made using the eee dropbox for the course tests midterm tentatively wednesday  week 6 in class final exam tue  jun 9  1  30-3  30 pm  as per uci course catalog principles of operating systems  lecture 1 6 ics 143 grading policy homeworks  30 % 4 written homeworks each worth 5 % of the final grade 1 programming assignment worth 10 % of the final grade midterm  30 % of the final grade final exam  40 % of the final grade final assignment of grades will be based on a curve principles of operating systems  lecture 1 7 lecture schedule week 1  introduction to operating systems  computer system structures  operating system structures week 2  process management processes and threads week 3  process management cpu scheduling week 4  process management process synchronization week 5  process management process synchronization  deadlocks principles of operating systems  lecture 1 8 course schedule week 6  deadlocks deadlocks  midterm review and exam week 7  memory management memory management week 8 memory management memory management  virtual memory week 9  filesystems filesystems interface and implementation week 10  other topics i/o subsystems case study unix  windowsnt  course revision and summary principles of operating systems  lecture 1 9 introduction what is an operating system early operating systems simple batch systems multiprogrammed batch systems time-sharing systems personal computer systems parallel and distributed systems real-time systems computer system architecture principles of operating systems  lecture 1 11 what is an operating system an os is a program that acts an intermediary between the user of a computer and computer hardware major cost of general purpose computing is software os simplifies and manages the complexity of running application programs efficiently principles of operating systems  lecture 1 12 goals of an operating system simplify the execution of user programs and make solving user problems easier use computer hardware efficiently allow sharing of hardware and software resources make application software portable and versatile provide isolation  security and protection among user programs improve overall system reliability error confinement  fault tolerance  reconfiguration principles of operating systems  lecture 1 13 why should i study operating systems need to understand interaction between the hardware and applications new applications  new hardware inherent aspect of society today need to understand basic principles in the design of computer systems efficient resource management  security  flexibility increasing need for specialized operating systems e.g embedded operating systems for devices  cell phones  sensors and controllers real-time operating systems  aircraft control  multimedia services systems today principles of operating systems  lecture 1 14 irvine sensorium hardware complexity increases principles of operating systems  lecture 1 16 moore s law  2x transistors/chip every 1.5 years moore s law from berkeley os course 1 10 100 1000 10000 1978 1980 1982 1984 1986 1988 1990 1992 1994 1996 1998 2000 2002 2004 2006 performance  vs vax-11/780  25 % /year 52 % /year % /year from hennessy and patterson  computer architecture  a quantitative approach  4th edition  sept 15  2006 intel multicore chipsets software complexity increases principles of operating systems  lecture 1 17 from mit s 6.033 course principles of operating systems  lecture 1 18 computer system components hardware provides basic computing resources  cpu  memory  i/o devices   operating system controls and coordinates the use of hardware among application programs application programs solve computing problems of users  compilers  database systems  video games  business programs such as banking software   users people  machines  other computers principles of operating systems  lecture 1 19 abstract view of system system and application programs operating system computer hardware user 1 user 2 user 3 user n compiler assembler text editor database system  principles of operating systems  lecture 1 20 operating system views resource allocator to allocate resources  software and hardware  of the computer system and manage them efficiently control program controls execution of user programs and operation of i/o devices kernel the program that executes forever  everything else is an application with respect to the kernel   principles of operating systems  lecture 1 21 operating system spectrum monitors and small kernels special purpose and embedded systems  real-time systems batch and multiprogramming timesharing workstations  servers  minicomputers  timeframes transaction systems personal computing systems mobile platforms  devices  of all sizes  people-to-computer ratio over time from david culler  berkeley  principles of operating systems  lecture 1 23 early systems  bare machine  1950s  structure large machines run from console single user system programmer/user as operator paper tape or punched cards early software assemblers  compilers  linkers  loaders  device drivers  libraries of common subroutines secure execution inefficient use of expensive resources low cpu utilization  high setup time from john ousterhout slides hardware expensive ; human cheap simple batch systems  1960 s  reduce setup time by batching jobs with similar requirements add a card reader  hire an operator user is not the operator automatic job sequencing forms a rudimentary os resident monitor holds initial control  control transfers to job and then back to monitor problem need to distinguish job from job and data from program principles of operating systems  lecture 1 24 from john ousterhout slides principles of operating systems  lecture 1 25 supervisor/operator control secure monitor that controls job processing special cards indicate what to do user program prevented from performing i/o separate user from computer user submits card deck cards put on tape tape processed by operator output written to tape tape printed on printer problems long turnaround time  up to 2 days ! ! ! low cpu utilization i/o and cpu could not overlap ; slow mechanical devices ibm 7094 from john ousterhout slides principles of operating systems  lecture 1 26 batch systems  issues solutions to speed up i/o  offline processing load jobs into memory from tapes  card reading and line printing are done offline spooling use disk  random access device  as large storage for reading as many input files as possible and storing output files until output devices are ready to accept them allows overlap  i/o of one job with computation of another introduces notion of a job pool that allows os choose next job to run so as to increase cpu utilization principles of operating systems  lecture 1 27 speeding up i/o principles of operating systems  lecture 1 28 batch systems  i/o completion how do we know that i/o is complete polling  device sets a flag when it is busy program tests the flag in a loop waiting for completion of i/o interrupts  on completion of i/o  device forces cpu to jump to a specific instruction address that contains the interrupt service routine after the interrupt has been processed  cpu returns to code it was executing prior to servicing the interrupt principles of operating systems  lecture 1 29 multiprogramming use interrupts to run multiple programs simultaneously when a program performs i/o  instead of polling  execute another program till interrupt is received requires secure memory  i/o for each program requires intervention if program loops indefinitely requires cpu scheduling to choose the next job to run principles of operating systems  lecture 1 30 timesharing programs queued for execution in fifo order like multiprogramming  but timer device interrupts after a quantum  timeslice   interrupted program is returned to end of fifo next program is taken from head of fifo control card interpreter replaced by command language interpreter hardware getting cheaper ; human getting expensive principles of operating systems  lecture 1 31 timesharing  cont  interactive  action/response  when os finishes execution of one command  it seeks the next control statement from user file systems online filesystem is required for users to access data and code virtual memory job is swapped in and out of memory to disk principles of operating systems  lecture 1 32 personal computing systems single user systems  portable i/o devices  keyboards  mice  display screens  small printers laptops and palmtops  smart cards  wireless devices single user systems may not need advanced cpu utilization or protection features advantages  user convenience  responsiveness  ubiquitous hardware cheap ; human expensive principles of operating systems  lecture 1 33 parallel systems multiprocessor systems with more than one cpu in close communication improved throughput  economical  increased reliability kinds  vector and pipelined symmetric and asymmetric multiprocessing distributed memory vs shared memory programming models  tightly coupled vs loosely coupled ,message-based vs shared variable parallel computing systems principles of operating systems  lecture 1 34 climate modeling  earthquake simulations  genome analysis  protein folding  nuclear fusion research   illiac 2  uillinois  connection machine  mit  ibm blue gene tianhe-1  china  k-computer  japan  principles of operating systems  lecture 1 35 distributed systems distribute computation among many processors loosely coupled  no shared memory  various communication lines client/server architectures advantages  resource sharing computation speed-up reliability communication  e.g email applications  digital libraries  digital multimedia hardware very cheap ; human very expensive distributed computing systems principles of operating systems  lecture 1 36 globus grid computing toolkit cloud computing offerings planetlab gnutella p2p network principles of operating systems  lecture 1 37 real-time systems correct system function depends on timeliness feedback/control loops sensors and actuators hard real-time systems failure if response time too long secondary storage is limited soft real-time systems  less accurate if response time is too long useful in applications such as multimedia  virtual reality principles of operating systems  lecture 1 38 summary of lecture what is an operating system early operating systems simple batch systems multiprogrammed batch systems time-sharing systems personal computer systems parallel and distributed systems real-time systems principles of operating systems  lecture 1 1 ics 143  principles of operating systems lecture 1  introduction and overview mwf 11  00  11  50 a.m prof nalini venkatasubramanian  nalini @ ics.uci.edu   lecture slides contains some content adapted from  silberschatz textbook authors  john kubiatowicz  berkeley   john ousterhout  stanford  and others  welcome ! prof venkat has to be on travel to a meeting today and will be back for wednesday s class she will have a make-up lecture on friday afternoon during the discussion session  3  00 3  50 p.m   in addition to the regular class from 11  00 11  50 a.m principles of operating systems  lecture 1 2 principles of operating systems  lecture 1 3 ics 143 spring 2015 staff instructor  prof nalini venkatasubramanian  venkat   nalini @ ics.uci.edu  teaching assistant  michael beyeler  mbeyeler @ uci.edu  readers  ekin oguz  eoguz @ ics.uci.edu  hao zhang  hzhang10 @ uci.edu  principles of operating systems  lecture 1 4 course logistics and details course web page  http  //www.ics.uci.edu/ ~ ics143 lectures mwf 11  00-11  50 a.m  eh1200 discussions f 3  00-3  50 p.m  hib 100 ics 143 textbook  operating system concepts  eighth edition silberschatz and galvin  addison-wesley inc  seventh,sixth and fifth editions  and java versions are fine as well   alternate book principles of operating systems  l.f bic and a.c shaw  prentice-hall/pearson education  2003 isbn 0130266116 principles of operating systems  lecture 1 5 course logistics and details homeworks and assignments 4 written homeworks in the quarter 1 programming assignment  knowledge of c + + or java required   handed out at midterm ; submit/demo during finals week multistep assignment don t start in last week of classes ! ! ! late homeworks will not be accepted all submissions will be made using the eee dropbox for the course tests midterm tentatively wednesday  week 6 in class final exam tue  jun 9  1  30-3  30 pm  as per uci course catalog principles of operating systems  lecture 1 6 ics 143 grading policy homeworks  30 % 4 written homeworks each worth 5 % of the final grade 1 programming assignment worth 10 % of the final grade midterm  30 % of the final grade final exam  40 % of the final grade final assignment of grades will be based on a curve principles of operating systems  lecture 1 7 lecture schedule week 1  introduction to operating systems  computer system structures  operating system structures week 2  process management processes and threads week 3  process management cpu scheduling week 4  process management process synchronization week 5  process management process synchronization  deadlocks principles of operating systems  lecture 1 8 course schedule week 6  deadlocks deadlocks  midterm review and exam week 7  memory management memory management week 8 memory management memory management  virtual memory week 9  filesystems filesystems interface and implementation week 10  other topics i/o subsystems case study unix  windowsnt  course revision and summary principles of operating systems  lecture 1 9 introduction what is an operating system early operating systems simple batch systems multiprogrammed batch systems time-sharing systems personal computer systems parallel and distributed systems real-time systems computer system architecture principles of operating systems  lecture 1 11 what is an operating system an os is a program that acts an intermediary between the user of a computer and computer hardware major cost of general purpose computing is software os simplifies and manages the complexity of running application programs efficiently principles of operating systems  lecture 1 12 goals of an operating system simplify the execution of user programs and make solving user problems easier use computer hardware efficiently allow sharing of hardware and software resources make application software portable and versatile provide isolation  security and protection among user programs improve overall system reliability error confinement  fault tolerance  reconfiguration principles of operating systems  lecture 1 13 why should i study operating systems need to understand interaction between the hardware and applications new applications  new hardware inherent aspect of society today need to understand basic principles in the design of computer systems efficient resource management  security  flexibility increasing need for specialized operating systems e.g embedded operating systems for devices  cell phones  sensors and controllers real-time operating systems  aircraft control  multimedia services systems today principles of operating systems  lecture 1 14 irvine sensorium hardware complexity increases principles of operating systems  lecture 1 16 moore s law  2x transistors/chip every 1.5 years moore s law from berkeley os course 1 10 100 1000 10000 1978 1980 1982 1984 1986 1988 1990 1992 1994 1996 1998 2000 2002 2004 2006 performance  vs vax-11/780  25 % /year 52 % /year % /year from hennessy and patterson  computer architecture  a quantitative approach  4th edition  sept 15  2006 intel multicore chipsets software complexity increases principles of operating systems  lecture 1 17 from mit s 6.033 course principles of operating systems  lecture 1 18 computer system components hardware provides basic computing resources  cpu  memory  i/o devices   operating system controls and coordinates the use of hardware among application programs application programs solve computing problems of users  compilers  database systems  video games  business programs such as banking software   users people  machines  other computers principles of operating systems  lecture 1 19 abstract view of system system and application programs operating system computer hardware user 1 user 2 user 3 user n compiler assembler text editor database system  principles of operating systems  lecture 1 20 operating system views resource allocator to allocate resources  software and hardware  of the computer system and manage them efficiently control program controls execution of user programs and operation of i/o devices kernel the program that executes forever  everything else is an application with respect to the kernel   principles of operating systems  lecture 1 21 operating system spectrum monitors and small kernels special purpose and embedded systems  real-time systems batch and multiprogramming timesharing workstations  servers  minicomputers  timeframes transaction systems personal computing systems mobile platforms  devices  of all sizes  people-to-computer ratio over time from david culler  berkeley  principles of operating systems  lecture 1 23 early systems  bare machine  1950s  structure large machines run from console single user system programmer/user as operator paper tape or punched cards early software assemblers  compilers  linkers  loaders  device drivers  libraries of common subroutines secure execution inefficient use of expensive resources low cpu utilization  high setup time from john ousterhout slides hardware expensive ; human cheap simple batch systems  1960 s  reduce setup time by batching jobs with similar requirements add a card reader  hire an operator user is not the operator automatic job sequencing forms a rudimentary os resident monitor holds initial control  control transfers to job and then back to monitor problem need to distinguish job from job and data from program principles of operating systems  lecture 1 24 from john ousterhout slides principles of operating systems  lecture 1 25 supervisor/operator control secure monitor that controls job processing special cards indicate what to do user program prevented from performing i/o separate user from computer user submits card deck cards put on tape tape processed by operator output written to tape tape printed on printer problems long turnaround time  up to 2 days ! ! ! low cpu utilization i/o and cpu could not overlap ; slow mechanical devices ibm 7094 from john ousterhout slides principles of operating systems  lecture 1 26 batch systems  issues solutions to speed up i/o  offline processing load jobs into memory from tapes  card reading and line printing are done offline spooling use disk  random access device  as large storage for reading as many input files as possible and storing output files until output devices are ready to accept them allows overlap  i/o of one job with computation of another introduces notion of a job pool that allows os choose next job to run so as to increase cpu utilization principles of operating systems  lecture 1 27 speeding up i/o principles of operating systems  lecture 1 28 batch systems  i/o completion how do we know that i/o is complete polling  device sets a flag when it is busy program tests the flag in a loop waiting for completion of i/o interrupts  on completion of i/o  device forces cpu to jump to a specific instruction address that contains the interrupt service routine after the interrupt has been processed  cpu returns to code it was executing prior to servicing the interrupt principles of operating systems  lecture 1 29 multiprogramming use interrupts to run multiple programs simultaneously when a program performs i/o  instead of polling  execute another program till interrupt is received requires secure memory  i/o for each program requires intervention if program loops indefinitely requires cpu scheduling to choose the next job to run principles of operating systems  lecture 1 30 timesharing programs queued for execution in fifo order like multiprogramming  but timer device interrupts after a quantum  timeslice   interrupted program is returned to end of fifo next program is taken from head of fifo control card interpreter replaced by command language interpreter hardware getting cheaper ; human getting expensive principles of operating systems  lecture 1 31 timesharing  cont  interactive  action/response  when os finishes execution of one command  it seeks the next control statement from user file systems online filesystem is required for users to access data and code virtual memory job is swapped in and out of memory to disk principles of operating systems  lecture 1 32 personal computing systems single user systems  portable i/o devices  keyboards  mice  display screens  small printers laptops and palmtops  smart cards  wireless devices single user systems may not need advanced cpu utilization or protection features advantages  user convenience  responsiveness  ubiquitous hardware cheap ; human expensive principles of operating systems  lecture 1 33 parallel systems multiprocessor systems with more than one cpu in close communication improved throughput  economical  increased reliability kinds  vector and pipelined symmetric and asymmetric multiprocessing distributed memory vs shared memory programming models  tightly coupled vs loosely coupled ,message-based vs shared variable parallel computing systems principles of operating systems  lecture 1 34 climate modeling  earthquake simulations  genome analysis  protein folding  nuclear fusion research   illiac 2  uillinois  connection machine  mit  ibm blue gene tianhe-1  china  k-computer  japan  principles of operating systems  lecture 1 35 distributed systems distribute computation among many processors loosely coupled  no shared memory  various communication lines client/server architectures advantages  resource sharing computation speed-up reliability communication  e.g email applications  digital libraries  digital multimedia hardware very cheap ; human very expensive distributed computing systems principles of operating systems  lecture 1 36 globus grid computing toolkit cloud computing offerings planetlab gnutella p2p network principles of operating systems  lecture 1 37 real-time systems correct system function depends on timeliness feedback/control loops sensors and actuators hard real-time systems failure if response time too long secondary storage is limited soft real-time systems  less accurate if response time is too long useful in applications such as multimedia  virtual reality principles of operating systems  lecture 1 38 summary of lecture what is an operating system early operating systems simple batch systems multiprogrammed batch systems time-sharing systems personal computer systems parallel and distributed systems real-time systems 