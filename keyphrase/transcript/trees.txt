in the last class we discussed hashing 
we saw few collision resolution techniques 
so we first saw chaining then last class we saw double hashing linear programming 

you also did little bit of analysis of these collision resolution techniques right 
in today we are going to talk about trees 

in after we are also going to look at binary trees some data structures for trees 




so what is the tree 
many of you come across tree before  except this tree is going to be different from once  across before right 
so here the root will be at the top 
most trees around you see you you don't see the root 
so the root is going to be at the top of the tree 
so in this tree A is the root 
there is a notion of parent and children 
so the node B is the parent of node D and E 
okay by the same argument A is the parent of B and C 
C is parent of F G and H 
A is a parent of B which in turn parent of D and E 
so A is ancestor of D and E 
A is also ancestor of F G and H 
A is also an ancestor of I 
right A is a grandparent sometimes we use the grandparent 
A is a grandparent of D E F G and H yeah
you understand what the difference between ancestor and grandparent 
D and E are descendents of A yeah 
in fact B C D E F G H I are all descendents of A 
C B are siblings because they have the same parent 
B is a sibling of C C is a sibling of B    
G and E are not siblings 
G and E are not siblings please note
F G H are siblings 
D and E are children of node B right
so A is a parent of B 
B is a parent of D and E 
D and E are children of B 
B and C are children of A 
All of these are descendents of A
as are all of these 
I has three ancestors 
H C and A 
H is the parent 
C is the grandparent 
and A is the great grand parent 
all the way don't use the term 
just call it an ancestor okay 
what we at the terms we defined till not now more in the nature of family tree  
so now will come to real trees right
and then D E F G H I are called the leaves of the trees 
so this is the root 
so if you just turn it upside down 
then it should be the leaves right 
the extremists 
so what is the leaf 
a leaf is a these are also called generic terms for these also nodes of a tree 
so leaf is a node which has no children right 
if a node has a no children it's a leaf 
so H is not a leaf 
H as a child 
but I F G E and D are nodes which don't have any children and so they are 
leaves 




more definitions A B C and H are called internal nodes right 
node which is not a leaf is called an internal node 
okay now we associate a notion of level with each node 
the root is at level zero 
children of the root are at level one 
the children of those nodes which are level one are at level two 
 right so D E F G H all at level two right its not that h is at level two 
its not all these are at level two 
this is the level at three 
sometimes we also use the term depth right 
so depth in level of the same thing 
so this is depth zero depth two depth three 
the height of the tree is the maximum level of any node in the tree 
so what's the maximum level of any node 
the height of this tree is three 
any questions till this point 
the degree of the node 
the number of children in it 
B has a degree two 
C has a degree three 
H has a degree one 
the leaves have degree zero yeah
so basically basic terminology quite intuitive also 
any questions 




no what are trees used for 

they can represent the hierarchy in an organization right
so for instance there is company lets called electronics are used which has some divisions R&d one divisions another purchasing another manufacturing fourth division sales there is 
lets say domestic sales is one 
sub division of this division an international so on 
so you could represent the organizational structure
through out tree 
you could also use a tree to represent the table of contents in a book right 
so you have 
lets say book called student guide which has chapters overview grading environment programming support code 
this then has be chapter has come sections called exams homework's programs whatever right
they could have some some subsections so on to that would build up tree 





your file system in if you use the unix environment in the windows environment is also organized as a tree yeah 
this is the lets say one root directory certain directory these are two sub directories in mat
okay
and then with in the sub directory have some other sub directory within then i have homework's assignment whatever yeah
your file system is also organized like a tree 



so more definitions much of a todays class would be about definitions and then we start using definitions in later in later classes 





but you should understand then if there is any doubt kind please ask 

an ordered tree is one which the children of the each node are ordered right 
so what is that mean 
that means that this is will call this is as the 
there is a notion we would like like to put this child to the left of the child right
suppose you want to draw family tree 
in a family tree may be you want to draw the eldest child in the left 




right and the younger child as you move from left to right right 
so there is a notion of ordered there and some time you want to reflect that order in your tree but there would be no notion of order 
lets say in your this example right 
will this is an directory 

there are two sub directory trees here 
now whether i have placed to the left of his or to the right 
it doesn't really make a sense as far as the picture concerned right 
and it doesn't convey  any additional information 
but sometimes you might have the notion of order in the children's right 




such an tree is called an ordered tree 
a binary tree is an ordered tree right 
there is a notion of  left child and a right child 
actually it's a ordered tree which every node has a at most two children right
so this is an example of binary tree 
this is has two children this has only one child 
this has only one child 
this has no children 
these are leaves 
we have one two three four five leaves which have no children 
this node also one children one child right 
and these are ordered 
so there is a notion of left and right 
if i were to change this 
i i were to draw this on the left and this on the right 
then i get different binary tree its not the impact 



 that would still be a binary tree but it would different from binary tree 
[student:once we have defined the notion of some order once we interchange the  top two nodes how it will stil remain ordered wont wont be ordered be started then 
no this is one binary tree 

all these are saying  this is one binary tree 
if i were to draw in a slightly in a different manner which means i put this i move this entire piece to the left and the entire piece to the right 
then i get a different binary tree right 
the two different binary trees that's all we seen




  [student : different example if we change the]  all of this dependent upon what application you have 
this is just a way of would representing an information right 
sometimes the order  is um has has meaning to it sometime no meaning to it 
when it has some meaning to it then you would use an ordered tree and when therefore if your were to change the order then your representing something in the front 
because when your change the order yeah we ill see more example of this and this thing would become clear 
i can also define a binary tree recursive format follows right 



a binary tree i could say binary tree is just read the single node a leaf or it is internal node which is the root to which i have attached two trees binary tree 
this part is called the left sub tree and this is called the right sub tree 
so i can construct any binary tree in this manner  yeah
i take a node i attached left sub tree and right sub tree 
how do i get left sub tree right sub tree recursive that itself obtained by taking a node and attaching to left and right sub trees





right i have said and or which means i might this left sub tree might be null 
i might not attached anything here 
or i might not attached anything to the right or i might attached both right
so remember this term we have introduce other terms left sub tree right sub tree 
this is called the left sub tree of this node yeah 
and this is called right sub tree of this node 
what is the left sub tree of this node 
it would be this piece this piece that would be the left sub tree of the um 





okay more examples of so examples of binary trees 
arithmetic expressions right 
i have an arithmetic expression which looks like this 
i can represent this as a binary tree 
what is that mean well  this is look at the parenthesization of this expression and suppose i have parenthesized this manner we have four plus six 
so the numbers here will be the leaves of my binary tree and the internal node would correspond to the operations right 
so in fact this is one way you could evaluate this expression also right
you would take this thing four plus six sum that right 
you would draw tree which has one internal node and its two children are four and six 
this internal node would have plus operator in it 
whatever is the resulting value we are adding to that one 
so i draw a tree whose root is a plus operator 
one child is one and the other child is sub tree that obtained from this operation and so on and on i could built this tree right
this is just a way of representing another way of representing yeah 





decision trees is an another example of another binary tree right 
so this is an example taken from book much of  it would not make much sense may be star bucks cafe paragon we would not come across them nevertheless 
suppose you know what is the decision tree
each node on the each node in the decision tree corresponds to some decision you have to make  so whether you want so you come to top root node and ask whether you want a fast meal 
the answer is yes 
then you come to this node 
whether you want coffee or not 
the answer is yes 
you go to star bucks the answer is no 
you may be go to some other place right and so on and on 
so decision trees are another example of binary trees why binary because typically its yes and no right 
you would follow the decision tree in a particular node



okay this was just  more of terminology and examples right 
so lets see more competes stuff 
lets define a complete binary tree 

right so this still are binary trees as you can see every node in this tree has less than or equal to two children right 
at most  two children but i will call such a complete binary tree why it is complete 
well so we call a tree a complete binary tree 
if at the ith level 
there are two to the i nodes right 
in some sense its full  and every node has to no no no 
that is that is not equivalent right every node has two children saying it evry node has two children doesn't give you a complete binary tree okay 




lets see if i can quickly show you why not 
lets see this 
every node has two children 
every internal node have two children in this tree  
oh every node has a two children then telling that a tree has to have leaves right 
so it cannot be the the case every node has two two children
some nodes have no children 
so yeah so just the requirement that every node has two children 
every node other than the leaf that means every internal node has two children doesn't implies it's a complete binary tree 



this is a counter example 
every internal node here is two children 

this is not complete binary tree right 
so here is an example of a complete binary tree 
so we want to say at level i there are two to the i node 
this was level zero one node level one two nodes level two four level three eight right 
okay 
now if h is the height of the tree 
this example what is the height of the tree 
we call height was the maximum level number 
so don't count this as four 
count it as one two yeah 
if h is the 
if h is the height of the tree that means all the leaves are at level h yeah 
if the leaves are all at level h 
then in the definition of the binary tree we said that level i has two to the i nodes 
that means there are two to the h 
so number of leaves complete binary tree of height h is just to the h right 
what is the number of internal nodes here 
well at level zero we have one node level one we have two nodes and so on
this is this is sum one plus two plus two squared 
all though have to two to the h minus one right 
because at level h all the nodes are leaf nodes 
so this sum which is two to the h minus one right okay 
this is the number of internal nodes 
the number of leaves is two to the h 
so the number of internal nodes is number of leaves minus the one yeah
this is for this complete binary tree um for a complete binary tree 
number of internal nodes is number of leaves minus the one 
so what is the total number of nodes in this tree its two to the h which is the number of leaves plus two to the h plus one  which is the number of internal nodes it becomes two to the h plus one minus one right 
lets call this number n 
so if i have a tree n node if i have a complete binary tree n nodes what is the height of this tree 
lets go one step at a time 
whats the number of leaves in this tree 
if this is n 
so number of leaves two to the h 
so two to the h equals n plus n by two right just from this expression 
so the number of leaves in a complete binary tree on n nodes is n plus one by two 
if i have a complete binary tree on n nodes half the nodes are leaves in the remaining half our internal nodes




and similarly i can say that the 

if i have a tree on n nodes then the height of the tree is log of the number of leaves why i can evaluate h from here 
h will be n plus one by n plus one log of n plus one by two and so its log of number of nodes right 
we can go directly from here number of leaves two to the h and so h is log of n
log of the number of leaves sorry 21.05




any questions on this 
you just some simple counting that your doing here yeah 
you should be able to say that if i give you a tree of height h 

what is the number of complete binary tree of  height h 
whats the number of leaves is going to have whats the number of internal nodes it have 
if i give you a complete binary tree on n nodes then whats it height so on and on 
if you have tree on n nodes then its height is log of n plus one by two right this is the height of the tree 




and the other thing your have to keep in mind is that in such a tree is number of leaves is very large 
its roughly the total number of nodes yeah
its very leafy kind of  a tree 
okay now whats the binary tree that was the complete binary tree right but a binary tree is said any tree which every node as at most two children 
so what you can do is 

you can take a complete binary tree 
or two get any binary tree 
you can start suitably large complete binary tree and just cut it off 
right for instance here if i were to cut off this piece and this piece then i would get such a binary tree 
and i can always do it 
no matter what tree i wanted right 
if i had any if there was you said take this binary tree of height three then i would start with this complete binary tree of  height three and just cut off some pieces to get this 
i can always do that right  
this picture is proof  everyone with me 





so lets use this fact you can obtain any binary tree by just pruning of a complete binary tree 
take a complete binary tree take off some pieces cut off some branches you ill get a binary tree 

so if i have a binary tree of  height h 
then in a complete binary tree at level i there were at most there were exactly two to the i 
so in a binary tree at level i there will be level at most two to the i nodes 
there cannot be more than two to the i nodes because the binary tree is obtained from complete binary tree by pruning 






this is the  important fact at most two to the i nodes at level  i and if the at most two to the i nodes level i this implies 

that the total number of nodes in your complete binary tree in your binary tree height h is at most this 
one plus two plus two square which is this yeah  
its height h the last level is h at level zero there will be one node 
at level one 




there is at most two nodes 
at level two there are at most four nodes so on 
this is the maximum number of nodes that binary tree i have 
lets rewrite this 
suppose i told you that tree has n nodes right 

 then n is less than or equal to this quantity 
n is less than or equal to this that the height of the tree 
i just rearranged  is greater than log off plus one by two right 
if i give you a binary tree with n nodes in it 	
its height is at least log of n plus one by two 
and there is a particular binary tree which achieves this equality and that's a complete binary tree 




right think of a complete binary tree has the tree which acquires the smallest  height
if i create a binary tree with certain number of nodes the one which has the shortest height will be a complete binary tree 
right because they do packing all the nodes close to the root as possible by filling up all the levels to the maximum  that's the minimum height of the binary tree 
i give you a binary tree on n nodes 

which is minimum possible height of log of n right 
whats the maximum height that binary tree n nodes  right and so binary trees on n nodes has height n minus one 
this is obtained when every node exactly one child um every node yeah
every node is exactly one child this could be zig zag in any manner height here is one one two three four five six seven eight there nine nodes here height is it eight yeah 





plus maximum height of the binary tree 
so binary tree  on n nodes minimum height is log of n log of n plus one by two whatever but say log of n 
maximum height is n minus one 
that's the mistake many people make 
they always assume that binary tree means height is log n no could be anywhere between log n and n  
how he leaves does the binary tree have right 
26.44
whats the minimum number leaves can have whats the maximum number of leaves it can have 
lets figure it out 
we ill prove the number of leaves in a tree it is less than or equal to one plus number of internal nodes  
any binary tree 




the number of leaves this is useful inequality 
number of leaves is less than one plus the number of internal nodes or at most the number of leaves in a tree can be one more than the number of internal nodes
how will we prove this 

will prove it by induction 
induction on the number of internal nodes okay 
so base case consider a tree with one node 
if a tree as only one node internal nodes it have





zero because one node doesn't have child 
so that's the leaf 
so base cases when number of internal nodes is zero really 

in which case left hand side the right hand side is one number of leaves is one so inequality suspect (satisfy)
so we ill assume the statement is true for all trees with less than or equal to k minus one internal nodes 
right this should actually read statement is true for trees with at most k minus one internal nodes not just k minus one only thing even less this statement is true 
so we will not prove it for a tree with k internal nodes suppose i have a tree with k internal nodes right 
lets say on the left sub tree i have k one k sub one internal node 
then how many internal nodes to have on the in the right sub tree 
if in the left sub tree i have k sub one internal nodes 
then how many nodes to internal nodes  in the right sub tree exactly k minus k one minus one right
not at most such thing because all the internal nodes either there in the left sub tree or they in the right sub tree or it's the root node right
so minus one because of the root node 
so this is the number of internal nodes in the right sub tree 
now lets apply the induction hypothesis k one is less than k less than or equal to k minus one and this quantity also less than or equal to k minus one right 
so we can use induction hypothesis the number of leaves in the left sub tree in the left sub tree which has k one internal nodes the number of leaves is less than or equal to k plus one 
this sub tree the number of leaves is less than or equal to k minus k one minus one plus one which is k minus k one 
the total number of leaves is just the sum as two 
all the leaves either in the left sub tree or in the right sub tree 
so total number of leaves is just as the sum which is k plus one which is what we want to prove right
since we started with a k internal node 
so you have to show that the number of leaves is less than one k yeah
this is proof create on the simple proof which shows the number of leaves is at most one plus the number of internal nodes 





there was a tree we saw were the number of leaves is equal to the number of internal nodes plus one  in a complete binary tree right 
what was the number of leaves there  the number of leaves is two to the power h 
if h was the height the tree 
the number of internal nodes was one plus two plus two squared all the way to two to the h minus one which is two to the h minus one 
so there was a exactly s difference of one number of leaves and number of internal nodes right 
so the complete binary tree once again h achieves the equality 
right for any other tree the number of leaves will only be less than or equal to this right 
how small it can be 
so lets look at that 

so for a binary tree n nodes the number of leaves plus the number of internal nodes is n yeah because the every node is either a leaf and also we just saw the number of leaves is less than or equal to number of internal nodes plus one right
ill just rearrange this this implies the number of leaves is less than or equal to n plus one by two tree 
what i have done just number of internal nodes is greater than or equal to number of leaves minus one 
so i replace that here and so i get the number of leaves is less than or equal to n plus one by two 
for any binary tree 
so that's the another thing to keep in mind 
binary tree the number of leaves will never be more half the number of nodes in the tree 
never right 
and again this equality was achieved for for our complete binary tree that's the most leafy term yeah 
all others are dryer trees and the minimum number that tree might have is just one right 
whats the example for that the same example i showed you before that um tree on nine nodes only one leaf in it 




so now lets look at an abstract type of data types 
so you would have the generic methods which you seen all for the abstract data types right 
so these care generic container methods of size how many nodes are there in tree whether the tree is empty or not 
an element is a method list out 
all the elements of the tree  you could have position based container methods kind we saw for the list or sequence data types right right 
so swap elements p and q i have been specified two positions p and q 
so think of the positions as references to the tree 
except that using the position data type i have not able to access anything else but the elements sitting in that position    yeah 
 the position the  the  method positions
will specify all the positions in the tree it will give you all the positions the tree has a sequence  just the position the the position objects 
this positions methods has no parameters right 
when you invoke on it  a certain tree it will just give you a sequence of all the positions in the tree 
references to all the nodes in the tree  
once you access you a particular position then you can using the element method on that positions access the element 
swap elements p comma q given two positions p and q swapping the elements at these two positions replace element p comma e which means that given a position p you replacing the element at that position with p 
query methods given a particular position is this root of the tree yeah 
given a particular position is this is an internal node given a particular position is this external or leafs sometimes you use the external or some times use the leafs 
yeah this position does it correspond to leaf 
access a methods root when i call root now it will return to me a position of the root 
an object of type position right 
so what you understand difference between this and this 
given a position is it a root and this returns the root [student: a position of a root] the position of a root  exactly the position of the root means reference to that particular node except that this is not a reference to the node but its is a reference of type position so that you cannot access anything else  but the element um 
this was the same as the type casting um yes parent p given a particular position return to me parent node children p given a particular position return to me the children of this node right 






okay now what it will return if children there could be many children of a certain nodes 
how it will return the various children  as the sequence 
it will return all the nodes 
it will return an sequence an object type sequence which will contain the position of all the children's  that that can be note on that position 
position as a element method which will let you to access the data 
the update methods are typically application specific this would be the generic method okay 

binary tree should really be treated as a sub class as a derived class  tree
all we need to do is to continue to have the same method will describe for the tree but have additional methods now right 
they would be notion of a left child 
given a position give me the left child give me your right child or give me a sibling right um 




will come to these update methods when we see example of this so ill skip that for 
now 

what is the node structure in a binary tree right what are the data your keeping in an object corresponding to a node of the binary tree 
you would have data you would have reference to the left child could have reference to the right child 
you would have reference to the parent  typically yeah 
and you would also have a reference to key or data associated with this node any element that sitting in this node you would have reference to it 
these we all sitting together  [student: it has to the reference to the parent and the child] yeah where is the the reference to this node will not will not stored in the node doesn't make any sense right
so for instance if i access to this node suppose this was the root node and i use the root method to get a position to this node then using that position i can now access the left child by invoking the left child method and in this manner i can get the position of any node right and once i have the position of a node i can then invoke element method whatever i need to do to get the datas associated with that  
a node in this case would definitely implement the position exactly 





right this is what the binary tree would look like look at the links so on 
this node its parent link could be null 
because it has no parent the root node right and then it would have left child 
the left child would be referring to this node 
right child would be referring to this node so on and on right 
this doesn't not have any right child 
so its right child um member would be referring to null 
any questions 
okay that was for a binary tree 
how do we take care of arbitrary trees 
lets say unbounded trees for now right
this node has 
lets say three children 
this node also three children 
so are we going to have three different data members here for point to refer to the three children right that's not clear how to do it 
because then if it has four children then how would you create space for another member so on and on right 
so so the way to do it is that you have a reference to  one of the child only right and then all the children are in a linked list okay 
and each children will have a reference to the parent 
so all of these children would be pointing to this 
this would be pointing to only one of them 
which would be the head of this linked list 
yeah so from this node if i have want to refer to this children i can just come here essentially return all the elements of this linked list 
how do i know i have reach the last element of the linked list when the next is empty 
why does the first field of this node empty because it does not have children right 
so every node still has only three members three members right 
parent or three references one for the parent one for left most child and one for the sibling for the right sibling right 
so this would referred to  left most child not to all the children because that we do not know how many they are 
and it will have one more refer to the right child to the right sibling because for this it has to refer to the right sibling yeah 
is there any questions some question 
you can do with only three references  this one this one this one yeah 
this had only one child right 
if it had only one child its just pointing to the one child  there is no sense in left and right here 
this is not a binary tree 
left and right only make sense binary tree um
right actually i should not have return left child here 
i should right first child such thing  
any one child its just point to the one child 




and that one child then lets you access its siblings through a linked list right 
if you from the right child go to next child and to from the next child and do from the next child and so on 
so you can step through all the various children throughout linked list 
any questions in this 
so with that we ill end our discussion on binary trees today 
in the next class we are going to look at reversals of trees and yeah that's all 


in the last class we looked at definitions of trees we saw what a tree was what a binary tree is what is a complete binary tree what the height of these things are 
today we are going to continue with our discussion 
on trees in particular we are going to talk of what are called tree traversal or tree traversals 
so a tree traversal is is a way of visiting the nodes of a tree in a specified order 
and there are two different traversals that we ill first consider one is called the preorder traversal the other is called postorder traversal 
so in a preorder traversal what happens is that you first visit process each node and then you go process it children okay 
ill show you soon examples of follow this
clearer 
in a postorder you will first process all the children?s or visit all the children and only after you have done that would you process the node okay 
so lets see example which you clarified [doubt]
some problem with my 

some looking at examples preorder tree traversals here 
so suppose you have so recall that we said that um book or a paper 
we can construct a tree out of it tree we can look at the organization of a book as a tree 
so or lets say result such paper 
so you have the paper it has a certain sections so the first section lets says the title 
second section is the abstract discuss what is their in the paper and then you have section one section two section three and then at the end of it you have references you know what are the books saw the other papers that the this particular publication
as a reference    
section one let say has two such sub sections section ?one point one ? and ?one point two? 

section two has three sub sections section three two sub sections so on and on right 
now when you start reading the paper when you read the paper this is the order you would go in right
suppose your reading the paper end to end so first you will go to the title read the abstract then you will look at start with section one section sub section ?one point one? there ?one point two? so on and on right 
if you were to think of the listing  as the table of contents if you were to think of a book and how the table of contents of the book are listed right
so the way the table of contents are listed
is that first you have the chapter and then are listed the um sections within the chapter 
then the next chapter then the sub section within the chapter so on right 
so if i were to look at the 

this as the tree 
these as the nodes of tree in the first node that we are referring to our accessing is this node one right 
then we go to the this node two 
then we go to three 
then we go to four 
then five
then six 
and after we done with six in a table of contents you will have seven and eight nine ten then eleven twelve thirteen then fourteen [noise] 
yeah 
this is also called the preorder traversal of a tree right 
and pseudo code for preorder traversal would look something like in this 
if i have to do preorder traversal of an node v in a in the tree so to begin with i would call preorder traversal at the root 
of the tree then i would say first visit the node 
so visit here is a generic term we will use visit very often all it mean is that i am doing some computations that node in this particular case if i were listing out the the book as table of contents then visit would correspond to print the title print the heading print the title of that node right 
so for instance each node corresponds to a section or or some such thing then this would correspond to same print out the name of the section right 
and then once you done that then you go to each of the children nodes and repeat the process there 
repeat this same process there on each of the child nodes right
because this tree could be arbitrary d 
i could this section subsection ?one point one ? could be as could be three sub sub sections  ?one point one point one ? one point one point two ? and so on and on right
if you were to do a preorder traversal then you come to one then you would come ?one point one ? then you would go to ?one point one point one? ?one point one point two ? ?one point one point three ? and only then would you go to ?one point two ? right 
that?s the need for this kind of a recursive traversal 
so what your doing here 
you first first visit the node then visit all its children 
so these are the six children of that node 
so we are saying visit this what does visit correspond to well does it have any children so it just means visit this node 
this correspond to visit  this node 
this corresponds visit this node and then visit its children 
so that?s what we are doing visit its children and then the next child yeah and so on and on 
so this is what to called a preorder traversal 
this is different from so this this i gave you the example its like a reading a document from beginning to end 
yeah 
now we could also have whats called a postorder  traversal 
in a postorder traversal recall i said what we are going to do is i am going to visit the node and at the end
we ill first visit its children and only then we would visit the node 
okay
so lets say i  have a directory structure like this okay 
this is my root directory courses 

in that  i m there are two this is an example from the book 
there is two courses here 
cs 016 cs252 and then in there are two sub directory there is a file called  grades within this sub directory there are three files within this sub directory there are three files and so on and on 
this is the directory structure okay 
now suppose i want to do compute the total space occupied by this file system lets say this this entire directory okay now what would i do well i would compute the total space occupied by this subdirectory and then i would add these two up add this node to obtain the total spaces required here yes 
so in some sense the computation that i am doing i am actually visiting this node or doing some computation on this node after having done the computation at two children nodes 
after having computed the total spaces required by the sub directory and after having computed total spaces required by [doubt]  
only then  i am my doing this   right 
in a postorder traversal what you do is that for every child of the node when you do a postorder traversal of a node v for a every child of the node first going to perform a postorder on that 
so in this example postorder here corresponds to finding the total spaces occupied by that sub directory 
so to compute the total space is occupied by this directory 
we are first going to compute the total spaces occupied by this sub directory [noise] the total space occupied by this directory and having computed that you are then going to compute the total spaces required by this directory 
so in some sense the order in which computation is done is is reverse from the pervious example 
right and in fact this this is the this is the order in which the disk usage command unix if you ever have use this particular command in unix what it does is that if you typing this command in a directory it tells you what is the total spaces occupied by the various sub directory in their 
so it the way listed out is if you were to type the disk usage command in the sub directory it was first going to list out the total spaces occupied in this directory then the total spaces occupied in this directory and then eventually at the end it list out the total spaces required here because it would have computed the only after it had done this computation and how does do this computation in a recursive manner that is to compute the total spaces required by this directory its first going to compute the total spaces required here 
then the total space required here and then had them up to the total space required here 
yeah
so that would be  a postorder traversal 
is this clear [noise] yeah [noise] okay 
so we are so your question is which child hood would we visited first 

we are looking at ordered trees [noise]
so there is notion of a first child second child third child fourth child
so the first child is visited first second next and so on [noise] yeah
so if you drawn the the trees in such a manner such that the first child is at the left is leftmost that?s we would say the leftmost child is visited first after the one right so 
so it depends upon how you drawn your trees right
so for binary trees so so um what i just shown you was traversal was in general trees 
you it?s a preorder first visit the node then visit the childrens nodes 
in postorder visit the children node then visits the nodes 
lets look at how this specialized case of binary tree right 

so in a preorder traversal what we have seen 
so v is in node 
if v is not null if v is null then there is nothing to be done 
if v is not null then in a preorder traversal we are first saying visit to be 
visit is some generic computation we do not know what it really is right 
it depends upon what your particular application 
so first say visit then do a preorder traversal on the left  child and then do a preorder traversal on the right child 
so note that this is a recursive procedure right
we are calling order within the procedure here itself 
how does this work
this work by making the call to itself right when we are doing a preorder traversal on the left child and another right child 
the difference between preorder and postorder here is that visit now comes at the very end 
first you do a preorder traversal on the left child 
then you do a preorder traversal on the sorry postorder traversal on left child then you do a postorder traversal on the right child yeah and then eventually you do visit 
lets see if you understand 
lets look at an example [noise] right 
this is my tree 
it?s a binary tree 
i want you to tell me what the preorder and postorder traversal of this tree is 
what we are doing when you visit a node is that we just printing out the contents of the node right 
so lets first look at preorder [noise]
what do you think be the first thing get printed we are doing a preorder traversal [noise]
this is the root a right 
so we come here we printing then we have to go do a preorder traversal left sub tree 
so when we do a preorder traversal of the left sub tree we are going to come to the root of the left sub tree and first print the node
first visit the node visit corresponds to printing the content we will just print it out right  b 
then we ill go to the left sub tree left sub tree is c 
so we ill  come here will look at the root node first visit the node visit the node here means printing contents we will print c then we try to go to its left sub tree but its left sub tree is null yeah there is nothing there 
so then we go to right sub tree which is also null nothing to be done 
so now we are done with the preorder traversal of this guy 
so where do we go now to the right sub tree because first we went to visited the node we did a preorder traversal of the left sub tree then we did a preorder traversal now we have to do a preorder traversal of right sub tree which means that first visit the node here which is d then we go left f then again we try to go to left null go right null nothing to be done then we go to g and now we are done with the preorder traversal of this sub tree so we are done with a preorder traversal of the left sub tree we are done with a preorder traversal of the right sub tree which means we done with the preorder traversal of the entire sub tree yeah 
we are done with a preorder traversal 
so now we would go to the right sub tree 
right sub tree has only e in it 
this will be the preorder traversal of this tree 
any questions here 
is it clear to every one okay 
lets do a postorder traversal right 
which you think it?s a first node that would be printed [noise] c 
why c is the right answer lets see 
so we come to here to do postorder traversal so this will be printed at the very end after i have done postorder traversal of this and postorder traversal 
so ill first try to do a postorder traversal of this 
now when i try to postorder traversal to this i come here 
so first i will do a postorder traversal of this then i will do a postorder traversal of this then print this node 
so i have to come and do postorder traversal of this 
for doing that i will first do a postorder traversal of its left child which is null nothing to be done 
i do a postorder traversal of its right child null nothing to be done
so i am ready to operate the content of the node 
so the first thing you that you will get printed is c 
now i am done with the postorder traversal here 
so now i come and do the postorder traversal of the right sub tree to do a postorder traversal of the right sub tree 
once again come to the root here
i first do the postorder traversal of this left sub tree 
then postorder traversal of this right sub tree and then print this content
so postorder traversal this would  it?s a single node [noise] will just be f 
so a postorder traversal this would be g and then i would print the content of this which means d [HINDI] what will be print now 
so we have done the postorder traversal just we have done the postorder traversal so we can now print this node so we will print d 
so now we have done with postorder traversal of this 
so we go to the right sub tree do the postorder traversal here which means which print e and then we done with the postorder traversal here we done with the postorder traversal here so we can now print the root which is a so this would be the postorder traversal is this clear to every one yeah 
how the procedure works okay good
so one use of postorder traversal can also be in so i am showing an another example for evaluating arithmetic expression  right 
so this is an arithmetic expression you can we want to evaluate this expression 
so how does one evaluate expressions well 
this is minus 
so in essence we have to compute what the value of this quantity is what the value of this expression this sub expression yeah this corresponds to sub expression so you have to compute value of this sub expression 
we have to compute what the value of this  sub expression right 
whatever values we get then take the difference that will be the value the entire thing 
so as you can see its like a postorder traversal we have to compute first value of this then the value of this and then take the difference which is the operator sitting in this node and how do i compute value of the well i have to compute the value of this left sub tree i have to compute the value of this right sub tree and then do the division because that [doubt]
yeah 
so we can right a procedure something like this suppose i say evaluate the expression corresponding to v is a node let say this root node here i say evaluate this 
so v is a leaf then then i just return the variable stored v because that?s the 	value 
the leaf corresponds to numbers in this expression right else if v is not a leaf then that means we are some internal node yeah 
so to evaluate the expression corresponding to this node i have to first evaluate the left 
so let say evaluate  v dot left child this arrow should be the other direction so x lets say x gets the value of that y get the value of right child right when i evaluate on the right child and if o is the operator then i just compute x o y whatever that operator o is right
and return that value that will be the value of expression that corresponding to node v [noise] 
so this is pseudo code of course but i hope you understand what i am trying to say here 
so essentially it corresponds to this is like a postorder traversal small modification question [noise] 

yeah so we are not going to be addressing that problem 
so the problem of generating this tree given a arithmetic expression  has to you know have to incorporate the priority rules to be generated such a tree 
so will not worried about that for now right 
we just looking at traversal given such a tree how you can evaluate the tree expression correspond to this tree [noise]  
so we seem for a binary tree we seen a preorder traversal we seen inorder traversal 
preorder traversal and postorder traversal there is a third order kind of traversal which is called an inorder traversal 
so recall that preorder traversal we visited the node first then we went to the left then we went to the right 
in a postorder traversal we first went to the left went to the right then we visited the node 
so the third possibilities we just visit then node between the visits to the left and the right right
there should be an and between the visit to the left and right sub tree 
so pseudo code for inorder traversal [doubt] following 
so if v is null we just get out else we first do an inorder on the left child then we visit the node and then we do a inorder traversal right child right 
so these are the only possibilities these are threes binary trees right 
so whether you first go to the left where do you visit the node either you visit it before  you visit both the left and the right or you visit it after you visit both the left and the right or you visit it in between visits to the left [noise] these are the possibilities these are the traversals that are known 
so lets just look at an example and see that i have understood inorder traversal right 
so which is the first node [noise] a 
so first inorder to do a traversal we come here we first do an inorder traversal of this guy of this left sub tree then we come here and then do an inorder traversal of the right sub tree 
so to do an inorder traversal of the left sub tree will come here we first do an inorder traversal of the left then the right and then we will print the content 
to do an inorder traversal of sorry first the left then we will print the content then go right 
so do an inorder traversal this well this an single node 
so it corresponds to printing c out right 
so that?s the first thing we ill print 
then we ill printing the content of this which is will be b and then we will have do an order traversal of this right sub tree 
right sub tree inorder traversal 
so once again we ill first printout f then d and then g and now we done with the entire inorder traversal of right sub tree 
so we will now printout  a and eventually we will print out e right right that would be the inorder traversal of this tree [HINDI] traversals priority given
so there is a another way of traversing a tree that?s called a Eulers rule right 
suppose this is a tree corresponding to an arithmetic expression and this tours okay 
so the tour is basically the drawn in blue here right 
so we start from here keep going down  keep going down when we hit a leaf we go up to his parent go to the right sub tree right and so on and on okay
so its it?s a generic traversal of binary tree and all the three traversals that we seen preorder traversal postorder traversal that inorder traversal we can be viewed at a special cases of Eulers rule right
so each node is basically getting visited thrice why because once you are coming like this then other time we are going like this touching this node lets say third time we are coming like this and touching this node right 
so three times we touches any node 
except perhaps the  nodes where you can say that perhaps we are you can account this only once or thrice or what ever you want 
but every internal node will be touch thrice yeah 
i should actually qualify every internal node of degree which has two children 
if the node has only one child then you will touch it only twice okay
so suppose this this is the arithmetic expression this is tree corresponding to set an arithmetic expression i want to print this arithmetic expression out with parenthesis right 
i want to draw the parenthesis  print out in this manner 
okay 
so i can do an Euler walk this thing 
so before [noise] i so suppose i am here 
before i start on the left sub tree ill print an left bracket then before i start on the left sub tree when i finish with the right sub tree and ill print the right bracket 
right this corresponds to taking this path up going up like this and when i am coming like this and touching this node ill just print out the content of the node understand what i am saying 
so recall that every node was  visited thrice 
so once when i am visiting it  from the left then essentially i going to print bracket when i am touching it from the right essentially print the right bracket and when i am touching  from below i am going to print the content of this node yeah 
if you do that then you will get exact this yes 
first ill touch this node from left so ill print first bracket then touch this node on the left ill print other left bracket i touch this node on the left i print another left bracket i touch this node on the left another bracket 
so i get four bracket to begin with then i come to this node 
for leaf ill just print the content of the leaf and ill do nothing else just print three then i am going to touch this node from below i am just going to print a star or a multiplication right 
then i come at a touch it from the left print a left bracket then i come here one so on and on right 
so you can think of this as essentially printing out the arithmetic expression some kind of Euler walk  on this tree
so we can actually 

right a generic method for tree traversal and then specialized it for whatever particular application you have whether you want to do preorder traversal or postorder traversal inorder traversal or any such a thing right 
so we ill we have so this is just small example 
so you want to do you want to traverse this node at specified at  the position 
so if this an  external node then you will lets say called this method called external right 
you not done anything here just specified certain method left external is a method that you will this will invoke if the node that you trying to traverse is an external node yeah an external node is same as a leaf node 
so if it?s a leaf node then that?s the method you invoke when you visit the node you touch the node from the left yeah then you will invoke this method 
here you continue with the left child when you touch the node from below you will invoke this method then you continue with right child then when you touch the node right you will invoke this method right and now you can specify what these methods are yeah when you are 
so by specifying these methods you can create you can create the traversal of choice you can specialize this binary tree traversal the generic tree traversal yeah 
so this is an abstract class if you if you go want in to java details this is an abstract class which means that these methods in particular in result in external external is also specified in it result external left below right these are left unspecified right when in an class you left you leave certain methods unspecified then it will become abstract class because you cannot really create object of that class 
but then you can at some point specify those methods right 
and in that manner create a sub class sub class of this class which specifies these methods and in that manner specializes this generic tree traversal procedure 
this is a generic tree traversal procedure 
so if i were to specify left below and right in an certain manner then i could get a method i could get a class for printing out arithmetic expressions let say yeah
so let see [noise] left result was trying to store  you know what result was  this is just so when i go go from the left child when i come back from the left child may be i compute a certain result right
this could be utilize used for instance when we in that example of disk usage right we want to compute  what is the total space occupied by that directory right
so we compute the space required by let say the left the left child
directory in the left child corresponding to the left child compute the space required by the directory corresponding to right child 
so those when we computed that those could be stored in r dot left  result r dot right result and then we compute the sum

that would be your final value 
that would be the value return 
okay 
so let say just see how to specialize this our printing arithmetic expression example 
so recall that if the node is a leaf node then all we said was that we are going to print the content of that node yeah 
so thast what we are saying just print out the element in that node p is a position just print out the element in it that node what ever is the element there 
when we touch a node from a left we said just print out a left bracket so that?s what we are saying just print out the left 
then we touch a node from below we just said that whatever is the operator in their just print at out that exactly what we are doing 
when we touch it from the right print out the right bracket 
so once i have specialized these methods in this manner 
this becomes print traversal 
this is the class which is extending binary tree traversal and when i invoke the traversal method it will now print out with with the arithmetic expressions with the tree corresponding to arithmetic expression  it will print out the arithmetic expression in the parenthesis form right 
so i could specialized the same  class binary tree traversal to use it to compute the total space occupied by the files by certain directories structure right 
by specializing these methods in slightly different manner
so lets continue our discussion on preorder traversal and inorder traversal so 

suppose i give you preorder traversal preorder traversal inorder traversal of binary tree right 
i have mention this here 
can you use this to figure out the trees yes or no 
suppose this was the preorder traversal this was inorder traversal of the binary tree both are given yes 
i give you these two can you use these to print out to tell me what the tree is 
you can yes sir why why we can do that lets see 
so given this preorder traversal what can i say for [noise] a is the root [noise] okay
if a is the root so the a the root a is the root now what should i do b?s b?s left child [noise] is this true that b is the left child no not necessarily the tree might not a left child yeah i saw the root might not have a left child at all that can happen 
so we cannot anything

all we can say a is root [noise] 
now lets find a in the inorder traversal a is the root  know that let me just put down node for the root and i know that ill search for a in the inorder traversal [noise] now what i do know 
i know that e is to the right 
e is the right sub tree 
so i know that this is inorder traversal inorder traversal of the right sub tree and this is the inorder traversal of the left sub tree of a 
right 
the green is the inorder  traversal of the right sub tree and blue is the inorder of the left sub tree yeah 
so i am going to now once again 
so i note that the left sub tree has five elements in it 
this is the information i know 
so in the preorder traversal the first five elements following a would correspond to the preorder traversal of the left sub tree yes 
and their the one element following that would be the preorder preorder traversal of right sub tree 
so in essence what have manage to do 
i have manage to identify what the left and right sub tree and i know the preorder and inorder traversal 
i know the preorder traversal of the left sub tree and i know the preorder traversal and in the inorder traversal of the left sub tree 
so my problem i can use recursion now 
so i know e is the right sub tree and now i can basically work on this problem where i am given the preorder traversal of now another tree the rep order inorder traversal of a tree and in need to figure out what the tree is and whatever is that tree ill come in  plug it as the left sub tree of a yeah 
clear to every one 
so lets continue with the example let see what you will do now 
so once again we are going to b is the root of this left sub tree right
whatever i given to you before 
so b is the root of the left sub tree we are going to see  where b is in here 
b is here [noise] and b is the root 
so this would be the left sub tree of b now c and f d g is to be the right sub tree of b 
so on the left i have only one element so that would be c here 
so c this would be the left sub tree this would be preorder traversal  of the right sub tree yeah 
so i  figure out the c since on the left there is only one so i can put the c down i don?t know what the right sub tree  is yet
i just know preorder traversal and inorder traversal 
i know the it has three nodes  the right sub tree is three nodes 
so the problem recursively reduce to this problem of 
given the preorder and inorder traversal of this three node tree and i need to figure out about the trees is 
so once again i know now  the root is going to be d 
yeah 
ill look for d here its there 
so i know on the left i have f right i have g 
so i know the root is g and i know that the left sub tree would have f and the right would have g 
also sees that i get something like this 
is this clear to every one 
you can translate this in to a piece of code yeah it will require some thought because you right it in a recursive manner 
this is second assignment put it up in the web today 
okay
[student: these are given as arrays] um

this would be some input you will take from this from the user 
yeah 
the preorder traversal inorder traversal and you have to compute and you have to compute not the tree but you have to compute the postorder traversal which is simple if you compute the tree because you can do a postorder traversal this tree now [noise] give the result now 
now it might be possible that know given any arbitrary c sequence its not necessary there is a binary tree corresponding to that right 
so you will also have to flag out an error 
if the sequences that given to you are such that they could do not possibly d the rep and inorder traversal of a of any binary tree yeah 
this is preorder traversal and inorder traversal 
so nothing [doubt] preorder traversal and inorder traversal 
given post  and n also you should be able to compute the tree 
right 
suppose i gave you the postorder inorder can you use that to compute the tree
so recall what wee did do 
we try to first figure out where the root was right
in the preorder very first element is the root 
in a postorder the last element is the root 
so first once you know the root then you ill search for the root in your inorder traversal and wherever find the root that neatly divides the thing in to a left sub tree and right sub tree yes 
so once you know the left sub tree what the number of nodes in the left sub tree 
you can figure out what the postorder traversal of the right sub tree is right 
if there were five nodes in the left sub tree then the very first the first five nodes of your postorder traversal would be the postorder traversal of the left sub tree 
so in this manner again you can recursively work [noise]
yeah
you can recursive we ill figure what the left and right sub trees and then plugged them up to the tree ?so given a post and inorder

traversal also you can do 
given whats the third question given preorder traversal and postorder traversal can you do it 
no 
so given the preorder traversal and postorder traversal of a binary tree you can [noise] you can uniquely determine the tree and the reason for that that is there can be two trees which have the same preorder traversal and postorder traversal 
so suppose i gave you these this preorder traversal and this postorder traversal right
three nodes from tree okay 
so what do you think as a tree this this is the tree this preorder traversal a b c 
postorder traversal will be  c b a this tree also has preorder traversal and postorder traversal 
a b c is the preorder traversal postorder traversal c b a right 
which of this trees is right one don?t know both of them right 
so there is no unique tree [noise] we could also have right child 
so these only two but they could be many examples many trees that you concerned yeah 
so that?s the problem given a preorder traversal and postorder traversal you cannot uniquely determine the tree 
because there could be many many different trees with the same preorder traversal and postorder traversal yeah
but there note that what was happening was that your tree some nodes in the trees was only one child 
suppose i gave you this information that every internal node the tree has two children [noise] not complete every internal node of the tree  


internal node has two children um what is that called 
this is an example of a tree
which every internal node has two children this is not a full tree well this is just a tree 
every internal node having two children right 
there is no name to it
suppose i gave you this information did you say an Indian tree okay um then what 
if each internal node has binary tree has at least two has exactly two children right because the binary tree so i should be exactly two children then actually you can use the preorder and postorder to determine the tree uniquely again and lets see just has an exercise why this is  right
so i gave you the preorder traversal and postorder traversal right 
now what you can say whats the first thing you can say [noise] 
a is the root yeah s 
a is the root 
so we can quickly draw the root now 
what you can say [noise] b has to be the left child [noise] 
it has two children yeah  
so we know that something on the left or actually i have done the example with on the right okay 
what can i say is the right child of a 
a has the right child because every node ahs two children 
what is the right child of a [noise]
it has to be  right 
since my example worked it out that 
s e i know is the right child from here from this picture 
now i see where e is here yeah 
now e is here and after e there is nothing here what is that say [noise]
e is a leaf that says e is a leaf right because in a preorder traversal i would have first visited e and then want to it its children but there is nothing following it so which means that the nothing after e has no descends 
so basically the it means that the left sub tree has b c d f g 
so e is the right child and the left sub tree has b c d f g has the preorder traversal and c f g d b visits postorder traversal now the same thing since i have managed to do divide i am going to continue right 
so i have b c d f g the left has the preorder traversal left sub tree and c f g d b has the postorder traversal of the left sub tree 
so once again i know now the root has b i [doubt] the root right 
now what do i know about the right child of b its d 
i know the right child is d 
i see where d is here right no right child is d draw 
so d is the right child so every thing that follows d has to be the right sub tree 
everything that follows the d in the preorder traversal has to be in the right sub tree why because in the right sub tree when i did in a preorder traversal i have first visited the d and only then visited the other elements 
so d f g has the right sub tree and c from the left sub tree
so the left sub tree only one elements 
so that?s what i am going to do here also the right 
one element could be my left sub tree and this would be my right sub tree 
so now that i have figure out the left sub tree which has only single element i can just draw it yeah 
and now i know d f g  have to now i know that right sub tree is d f g sorry has no d f g preorder traversal d f g and postorder f g d 
so now i know root is d actually i have already drawn that out i know the right child is g g is here there is nothing beyond that means g has no children for i can draw that out and then i know what means is the left sub tree only one node it is left yeah 
so you can do the same same thing 
i am just showing you showing at you high level in fact this is the level ill be following for all the algorithms we do in this class right 
the code you will have have to translate in to code  right 
what you have to do is recursion of whatever it is 
so and you will have to so the idea is assignment of would be that many of these algorithms you should learn how to you should figure out how to best program efficiently 
are any other questions till this point right 
you can you can write down the code also for this you can given the preorder and postorder traversal of a binary tree every internal node of which has exactly two children you can even use that to figure out what the tree is yeah 
so we why did we work with two traversal why cant we just take preorder traversal and given just preorder traversal can used that to figure out what the tree is [noise]  
given just a preorder traversal can i figure out what the tree is 
so we had let say 
this has the preorder traversal right a b c d f g e was the preorder traversal of this tree 
this is one tree with with this as a preorder traversal can you think of another tree which has this has the preorder traversal [noise] i could just have all of the nodes in one line say right 
a b c d below it f after at it g after at it e at the very end right 
i could get um huge number of different combinations all of which would give rise to the same tree order traversal yeah 
so with just one just the knowledge of one traversal you cannot really do much similarly for postorder similarly for inorder right 
if i were to give the inorder traversal of this you can construct many many different trees same inorder traversal 
so just using one you cannot really do anything but two suffices for most purposes in the only case two doesn?t suffices when you are given the preorder and the postorder traversal in which case it doesn?t if the binary tree some internal nodes of it binary tree 
could have only one child but if you were told that every internal node has two children then even is sufficient right 
more questions 
[student: can you find how many tree binary  trees can be given only a preorder preorder ]
can you count the number of binary trees given [noise] only how many  lets say preorder traversal what do you think [noise] two to the power n minus one why [noise] why [student: because every point can ] [noise ] yeah at least two to the power n minus one right why because two to the power n minus just came from 

um  so two to the power so 

we said a b c d e f let say is my preorder traversal of binary tree right
wee said a b c d e and f this is one and all your saying is well i can make each one of them either left or right child right of its parent 
so this could be one the other option could be beside a b c d e f and so on and on right 
so just since each of the node can be either the left or right child of its parent 
but there are many many other possibilities right [student:this is the minimum number] this is absolute minimum right 
you can have many many other possibilities [noise] yeah 
there could be  lots and lots of things possible 
[noise] yes yeah of course it will be finite because there are only finitely many different trees with six nodes on them it will be of some finite number it will just a function of n exactly yeah 
but i do not know to compute the close form expression for such more questions 
okay
so with that we will stop today?s class so what we looked at was tree traversals how to traverse so three different ways of traversing trees um inorder traversal preorder traversal and postorder traversal for binary trees and for general trees there is notion of inorder traversal right as perhaps understand why there is no notion of inorder traversal for general trees [noise] right so in because if node has three children then when do you visit the node itself right 
after visiting the first child or after visiting the second child or when 
okay because but in a binary tree there is a notion of left in a right so first you visit the left then you visit the node then you visit the right so there is also a notion of n order traversal and we saw [noise] some applications of these and how given inorder traversal preorder traversal postorder traversal two of these traversals you can figure out what the tree was which gave raise to those traversals okay

AVL Trees 

In this class we are going to be talking about AVL trees in the last class we have seen binary search trees data structure now one problem with the binary search tree

if you recall is that the operations of insertion deletion search all of them take time proportional to the height of the tree height of the tree can be very bad ya we saw in the example with the height of the tree could be as bad as order end or n minus one 

so we want to some how created tree which doesnt have to bad a height and thats what we are going to do today we are going to look at the data structure call AVL trees okay what is an AVL tree  AVL tress are what are also called height balanced trees okay now ignore this white spots that are showing here they should not have shown here 

this is the binary search tree these are the keys inside the nodes of the keys right everything to the left of the root is everything which is less than to the root is left of the root is everything which is more than the root is to the right of it now what have also written next to each node is the height of a node now what will we call the height of a node we will not define this turn end we will just say the height of a node is the height of the sub tree rooted at that node ya

so for instance if i look at this node this is the sub tree rooted at this node right what is the sub tree rooted at that node is a just set of descendents

so i am looking at this tree now now in this previous classes we have define the height of such a tree as two and not three because we had said that this has this is level zero this is level one this is level two and so we had call this is height of the tree as two 
now we will just modify this we will say that if it is the single turn node just one node it is a height one instead of height zero as we will be calling it this sub tree has height two so level numbers are not beginning let say with one okay 

so this has height two this has height this sub tree has height three and this entire tree has height four okay ya so we are going to call this as height of the tree for let us say the purpose of the AVL tree 

so with every node i put down height of that node so what is the height of the node it is just height of the sub tree rooted at that node ya so this is height one because that is nothing below it this is height one this is all the leaves will have height one the parents of the leaves will have height two and so on ya now such a trees called AVL tree if it is height balanced what is height balanced means if i look at any node and i look at it children than the difference in their height is at most one there might be no difference in their heights as in the case with this node its two children have the same height this node has the difference the left sub tree has more  height than the right sub tree 

the left sub tree has the height two and the right sub tree has height one this also has a difference of one the right sub tree has height three now and the left sub tree has height two ya

but the differences is no more than a one right so this is the AVL tree this is what our definition of an AVL tree would be yes it is true for every node of the tree is there is a binary search tree so there are two properties it has to be a binary search tree and if a every internal node of the tree the heights of the children differ by at most one by away said internal well for a leaf node it has no children it doesnt make any incidence to call to talk up the height of the tree right so for this node the right sub tree has height one and sis the left sub tree is missing we call it height zero so now you understand why i had made this change today right absence of the tree i will note i will call it height zero ya 

and now single node will become height one and what ever right so thats why i shift the definition everyone okay with this ya let see what is not a tree what is not an AVL tree [noise]

once again that we just okay let me just switch over to the thing um so recall that one of our binary tree is which was very bad was which had a huge height was the tree like this yes right 

this is a binary search tree i kept put some keys so that it looks like a binary search tree and this has height equal to n minus one if there were n nodes yes is this an AVL tree no is this node height balanced yes it is a leaf node write is this node height balanced this is also height balanced is this node height balanced no because the right sub tree has height two and the left sub tree has height zero so this has height two and this has height zero so this has height balanced properties violated here its also violated here and its also violated here 

so we will never have such kind of trees as AVL trees (Refer slide time 07:24) ok good so lets trying figure outs since we since we said that we are not going to have such kind of trees as AVL trees lets trying the figure out how bad the height of an AVL trees can be ya [noise]


so let say i have an AVL tree of n nodes ya if its height can still we as bad as n minus one i am not gain anything so i am not gained anything so i would like to say  something like its height is no more than log n or something we will figure that out so thats what we are going to say this is what we are going to prove in lets say in the next few minutes the height of the AVL tree t which has n nodes in it is only order log in okay let see why this two 

so i am not going to prove this claim directly i am going to make a small slightly different argument right i am going to say let us take an AVL tree of height h amongst all possible of AVL tree of height h 

let me see the one which has the smallest number of nodes so define the quantities n of h here as the minimum number of nodes in an AVL trees of height h and lets us figure out what is the quantity and than we will see how this implies this proportion here okay so you dont know understand what i am saying 

so given an AVL tree of heritage we want to find out what is the smallest number of nodes it has can it have only h nodes than we will be in trouble we want to say many many  many more nodes right if you recall a binary search tree on h nodes  of height h can we have only h plus one nodes right this example that i showed you which was applied but a good tree which is like a complete binary tree of a height h will have two to the h nodes right what would you really like that is of AVL tree which was of height h have a large number of nodes not just h but more like two to the h something like that ya and thats what we are going to prove (refer slide time:11:31)


Okay so what let us understand what is the quantity so its the minimum number of nodes in an AVL tree of height h so if i take an AVL tree of height one what is an AVL tree of height one just a single ten node nothing else okay it has only one node in it if an AVL tree of height two rooted one node but it can also to be rooted two children right so why i have written two here and not three minimum i am counting minimum right so thats why end end two equals two the minimum number of nodes will be just two in an AVL tree of height two 

so suppose i have an AVL tree of height three or more so it will contain one root node so suppose AVL tree of height h it will contain one root node it will have an AVL tree of height h minus one on one side and an AVL tree of height h minus two on the other side why h minus one and why h minus two okay some one tell me well it has height h so its children its children can have height only h minus one not more than h minus one right 

so they can have a difference of at most one so if one of them is h minus one the other one can only be h minus two or h minus one right so one of the sub trees has height h minus one and other sub tree has height h minus one or h minus two but what will be the pick we would like to the other sub tree have height h minus two why minimum number of nodes so at tree which has smaller height will also have smaller number of nodes so we would like that the other sub tree have h minus two height ya 

so if n of h was the number of nodes in the tree of height h than what is the number of nodes n of h equal to it is the number of nodes in a tree of height h minus one the smallest possible because we would like that the left sub tree which is of lets of height h minus one in the right sub tree which is of height h minus two the h minus one sub tree have as small as little number of nodes as possible and the h minus two sub tree also as little number of nodes as possible

so the number of nodes sorry the number of nodes in the left sub tree is n of h minus one the number of nodes in the right sub tree n of h minus two there is one root node so this is what the recurrence relationship look like right 
once again we have seen the recurrence relation every one satisfied with this ya  so this is what we have to solve today ya and what are the base condition we know its  n of one is one and n of two is two right with that you can figure out what a n of three would be n of three would be one plus one one plus two four ya and so on and all but you would like a close form expression to be able to do this so we will solve this recurrence okay

so we are not going to be solving this recurrence exactly okay we are going to run approximately so first we use the fact that  n of h minus one is only going to be a larger than n of h minus two right because as the height of the tree grows the number of nodes cannot reduce right it will only be more right so n of h minus one is atleast as largest as h minus two and than this implies that what we had written earlier n of h equal to n of h minus one plus n of h minus two plus one this quantity is at least as largest two times n of h minus two strictly large because i also drop the one ya
i will place this n of h minus one by n of h minus two and this is what i get ya now this is becomes the simple thing to solve n of h is more than two times n of h minus two 

this is what i solved so n of h is more than two times n of h minus two ya and now n of h minus two is more than two time two times n of h minus four so this implies this entire thing is more than four times n of h minus four which implies that the entire thing is more than eight times n of h minus six ya you understand how this comes n of h minus four is more than two times n of h minus six and so on and on which will eventually take as to something like two to the i after i steps n of  h minus two i ya great

okay so suppose i pick i equals h by two minus one i am going to assume for now that this quantity is an integer ya so let as assume h was even to begin with so this is an integer and for this value i will get two to the h by two minus one n of h is more than more than two to the h minus one times n of so i am replacing i by h by two minus one so i get a two here yes so its n of two 

n of two recall was two so it becomes two times two to the h by two every one is be  so what is this say we just argued that if your AVL tree has height h than it has atleast two to the h by two nodes at least so many nodes right what is the maximum number of nodes it can have two to the h something like two to the h either two to the h or two to the h plus one one of those ya because it can be a complete binary tree ya

so now suppose i would have to take algorithms what would i get i would get that h is less than two times log of n yes right so if i have in AVL tree on n nodes so right so n of h is actually less than or n right

because i have an AVL tree whose height is let say h and it has n nodes so suppose i had an AVL tree of height h and n nodes than it will also satisfy this relation yes it will satisfy the relation because n is only going to be larger than n of h n of h what was n of h h was minimum possible number of nodes ya so any AVL tree on n nodes and height on n nodes has height at most login two login from this example from this argument

 is it something you did not follow are you confused about this n of h right so this is what we argued after taking algorithms now let me take a tree of height h and n nodes ya so n is going to be larger than n of h because n of h is the smallest possible is the minimum number of nodes that are possible in a tree of height h n of h is that quantity [noise] this is just a function dont confused this n with the number of nodes you can replace this n with something else 
[student:noise] 
staff: n of h is the minimum number of nodes in a tree of height h  [student:noise] 
okay if you are getting confused lets let me just clarify this [noise] so what we argued here was that h is less than [Refer slide time 18:47] two times log of n of h ya okay 


now take an AVL tree of height h and let say let me not call it m let me call it m nodes ya
so its height is h it has m nodes in it so what does this implies m is greater than n of h this follows from our definition of n of h m is more than and we know that h is less than two times log of n of h which is then less than two times log of m this implies h equals big o log of m ya 

the height so what was this this was height this was number of number of nodes the height of an AVL tree on m nodes is less than two times the two times log of the number of nodes is this clear now 
so the m and n confusion is (now) great so thats what being said here any question to this point 

ya so we shown that such a tree will have height no more than two log n the best possible tree can could have height only log n right if it were like a complete binary tree very dense and every thing 

but this has this has more height but not two much more just a factor two more much better than having a height of an n great 

so lets try and solve this recurrence slightly better this is more of an exercise also to to show you how recurrence is solved right

so we did fairly crude analysis here right we replace this with this n of h minus two and then we did this and we got this this trying get something better right just as just as an exercise

so we will show how to get a sharper bound on the height of an AVL tree [noise hindi 20:07] the bound we right now two times log of n let see if we can get something better than that 

so we were use an induction and we are going to do a tight analysis of the same thing we are going to show that the minimum number of nodes in an AVL tree of height h which was n of h is at least c times h now we are going to show it at least c times h 

were c will be some constant more than one what did we shown in the previous slide it was atleast n of h was at least [noise] two to the h by two two to the h by two so what was the c root two two to the half to the h right so there we showed a c of root two 

let see if we can get a bias c right larger c more than root two right and what would be the way of such a thing 
so we will assume that n of h is atleast as larger c to the h let see what we can argue where okay 
and we are going to be prove this by induction and we will figure out what the  c is later 
so i am we have proving a certain statement without actually knowing exactly what the statement is because i am not telling what the c is but you will see what the c has to be for the statement to be true right what is the base case h equals one h equals one pay n of h is one we want that 

so so this statement would be true this statement is true at h is equal to one right no just once again what we have said we have said the number of nodes is going to be at least as large as [noise] okay let us come back to this in the minute

so i assume to i made a mistake let us come back this base case again let we will have to perhaps redefine the height of a tree here okay 

let i thing may we should we should have c of h minus one or some such thing okay we come back to this 

suppose the claim is true for all h less than k and lets try and prove it for h equals k not 

so far we have to prove that n of k is greater than or equal to c to the k okay
we come back to this base case in a minute okay so the recall  this was our recurrence relation n of k equals n of k minus one plus n of k minus two plus one and induction hypothesis says that n of k minus one is at least c to the k minus one n of k minus two is at least c to is strictly larger right i just ignore this plus one again okay



now i have to show that n of k is larger than c to the k i can show that n of k is larger than c to the k if i can show that this quantity is larger than c to the k ya 

so this is what i have to show i have to show that c to the k minus one plus c to the k minus two is lager than c to the k yes right okay good

so what should cb so that this is true well i just cancel out terms appropriately and i get c square minus c minus one should be less than or equal to zero if c satisfy this then this will also be true yes why because i just multiply both side by c to the k minus two and i would get exactly that and if this is true then n to the k which is larger than this would also be larger than c to the k right i just have to pick a c which satisfy this right and you can you all know how to figure out c which satisfy this right 

so we will just solve this quadratic equation this has roots right one minus root five by two and one plus root five by two right this is negative

so anything in between would keep this less than zero right 
but i wont as large as c as possible so i will take one plus root five by two which is roughly one point six three and this quantity is also known as the golden ratio okay so we will we will see this more often perhaps
[noise] we can solve what exactly [student:noise]
no no this is not a fibonacci relation [noise] if you add one to both sides right okay good 
okay good okay okay
so you will get n of k would be with the fibonacci number minus one good ya you can also do that right so we get bound of roughly one point six three c as one point six three right so what is the mistake we have made so one thing is a base case have not worked out right so i guess this was the wrong thing to pick it should not be c to the h but may be c to the h minus one right

so induction hypothesis should be c to the h minus one (refer slide time 26:28)[noise] right so let us take c to the h minus one we will not make a different right so we take c to the h minus one you will not make a difference right so we take the c to the h minus one so precisely i am dividing out by c then the base would have also be satisfied if h equals one you would have more than one which is a case ya and so sorry about this and for the other two also it will be okay ya because h equals to two 
n of two is two and this would become c to the two minus one which is c c is less than two because we just argue it is one point six three (refer slide time 28:05) okay 


so please make that correction [noise] we really require that the induction hypothesis is h minus one 

it will not make any difference on this how ever [noise:hindi] k minus one if this become h minus one this will become k minus one right this would this continue as it is right this will become k minus two plus ck minus three we have to prove this is greater than equal to c k minus one every where there will be a minus one so that you will still get the same quadratic in equality ya so the value of the c would still turn out to be same [noise:student]  

one point six three to the power k minus one h minus one n of h minus one ya so please make that small correction okay and so you will have that the AVL tree on n nodes has height now log of n to the base one point six three this quantity okay 

because what are we said we have that if i take a tree on n nodes the same argument is before so we just see do the same argument as before we have i take a tree of height h and n nodes ya so we have just seen that n of h is greater than or equal to one point six three to the h let say minus one thats what we saw just now this is the tree with smallest possible number of nodes so n is going to be only larger than this let us take log of both sides


so we get log base one point six three n equals h minus one i am just using the definition of log i am taking log to the base one point six three ya so i will get this this implies h equals log of one point six three n plus one it will okay right

so we have been able to prove this kind of a sharper bound ya [noise:student] this equation does not satisfy n equals two it does okay great it also works for n equals two right so that was our base case 

so every one agreed okay great so lets continue so i have shown you two ways of solving this same recurrence right one was the much simpler way actually both are very simple right 

so the second technique is is also used quite often you make a guess on what you think it should be derived value should be right and then essentially verified that to be said suppose to be right value that some c to the h and then you figure out what you see should be and you get something better right so earlier we had root two one point four one four  and we could [ ] one point six three by using this [ ] technique

okay so lets look at the structure of an AVL tree in a little bit more detail (refer slide time 31:20) right 


so i once again have an AVL tree on n nodes okay 

now let me take the leaf that leaf of this tree which is closest to the root which means at it whose level number is as small as possible the smallest among to all the leaves suppose this leaf is at level k okay

we can show that the height of the tree is at most two k minus one is this clear no this requires the proof and lets do that [noise] okay

so whatever said i have an AVL tree (Refer slide time 35:45)which has n nodes in it although this is not going to be a particularly important the number of nodes in that tree so this is some tree okay i took that leaf of the tree which is closest to the root right suppose its this leaf here which is closest to the root and we said its at level k right so the other leafs could be at this level or could be below [noise:student]



no in this class for AVL tree lets say we work with level starting one doesnt make a big difference lets say we start with level one we are going to prove that the height of this tree is at most  two k minus one so height of this tree is less than or equal to two k minus one thats what we will prove let see why 

so i will draw this picture again here okay so this is the leaf i will let me color it red which is at level k and which is the one which is the closest to the root right from this node there will be some sub tree hanging out from this node ya from this node also they will be some sub tree hanging out and so on 

this is my root level zero level one sorry [noise] um now lets look at this node first which is at level k minus one what is the height of this node 

what can be the height well it has one child this child has height one this has height one so the heights are in blue ya so this means that this sub tree can have height at most two right 

so we want to get as large height as possible for this tree right so whenever we say at most two will just take the largest value right

so this can have height two so if this has height two what is the height of this node this sub tree will then have this sub tree will then have height three ya this sub tree will have height three
 if this sub tree has height three what is the largest height that this sub tree can have four so what is the height of this node five 

so what is the maximum height this sub tree can have know six and so this would be seven and nine and so on right so what will the root have height now no in general given that this was k ya 

so well right if ya just figure it out it should be two k minus one right if if it was just still up till here its basically k two height three so when k if k were two this was the picture then the height was three if k was three this was the picture height was 
five if k was four height was seven and so if for arbitrary k this is two k minus one ya very simple argument 

so which means that this entire tree can be no taller than two k minus one if the closest leaf was at level k this is the property of AVL tree is not a property of any arbitrary binary tree yes you understand that right in an arbitrary binary tree you might have leafs at any level (Refer slide time 37:03) 



but the height of the tree could be as bad as you want it here is a leaf at level one but this height [noise:hindi] but for an AVL tree if there is a leaf at level k that height of the tree can not be more than two k right

so an any AVL tree is basically if there is a leaf at this height if there is basically all over leafs now will be in this part only this band whose width is as larger this roughly right this was k and this was also k k k minus one i mean during that

ya i will come to back to this in a minute okay so we just argued that if the closest leaf is at the level k then the height of the tree is no more than two k minus one that is the largest possible height the tree can have okay now lets make another claim 

if the closet leaf is at level k then all nodes at level one through k minus two have two children ( )

every node on this first k minus two levels have to have two children right and why away said k minus two and not k minus one [noise: student]
so lets prove this by contradiction so what do we want to do contradict so lets take some node at level k minus two  which has only one child right 

this is the picture i have node u level k minus two it has only one child which is at level k minus one right i have shown know node at level k minus two but the same argument would applied to any node at one through k minus two ya so v is at level k minus one so it cannot be a leaf because the closest leaf for that level k right good ya

so it has to have another child i have shown only one but it can also have two children no right

but this guy u has only one child so sub tree rooted at v has height at least two yes because this has have two this has to have one child it cannot be a leaf so it has height at least two while the the right sub tree here has height zero because there is nothing there

so we have a height imbalance at this problem at this node so the height balance property is violated at u 

yes so every node on this levels one through k minus two have to have two children at level k minus one how ever there can be nodes only one child that you understand right everyone understands that [noise]

this is level k of course the tree extends this is the level at which the closest leaf is at level k minus one i can have a node with only one child and that child is this lets see here right 

this is okay provided this guide is not have any more descendants and need not have because it can be a leaf right 

so this is completely okay but if it have more descendants then we would again have a problem height balance property ya

so this is okay so which means that this guy can have only one child but everything here has to have at least two children okay great so so we said every node at level k minus two has to have two children so which means levels one through k minus one are full full means they have as many nodes as a possible on level on that level in a binary tree this will after all a binary tree okay so they are full 

so what is that mean that means the tree has at least two to the k minus one node ya we also argued we recall that height of the tree is at most two k minus one 
so if the height of the tree is two k minus one then it has at most two to the power of two k minus one nodes ya
 
this implies the number of nodes in the tree which was n is between two to the k minus one and two to the two k minus one ya

everyone agree so suppose since we have been using h for the height right lets substitute h for two k minus one lets see what the equation is look like this becomes two the h and this becomes two to the h minus one by two this is the same thing i am showing you over and over again what is the thing if you have a tree of height h an AVL tree of height h than it has at least two to the h by two nodes we had shown earlier right 

so now we are showing the two to the h minus two just roughly the same thing square root two to the h nodes all though we proved the sharper bound i am coming back to the older bound the point is it has an exponential number of nodes it has number of nodes which is some constant c to the h an exponential right because thats was give as the logarithmic height property right 

so this is actually a third way of proving that the height of the tree is only login right you can also use this as a proof right

so this did not require solving the recurrence relation that the two method we solving the recurrence relation the shop is long we were see so far is c to the h one point six to the h 

so lets summarize(Refer slide time 45:31) what we have seen as the structure of an AVL tree is concerned if the height of an AVL tree is h then the closest leaf can be at level h plus one by two right 



i have just change things around when i said when the closest was k than the height was two k minus one so i just change that around as if the height is h so suppose i give you an AVL tree and n nodes of height h then the leaf which is closest to the root is actually pretty far from the root its atleast half the height away is at least h plus one by two away ya

it doesnt require a proof its just i am just rewording what i have said earlier we also saw that on the first h minus one by two levels the AVL tree is it complete binary tree lets this what an AVL looks like essentially 

for the first half of half levels its complete very dense ya and then its starts thinking out right as its stars so it turn the tree around so with the root at the bottom so initially its dense

and then it kind of things to the full height okay but this part the fact that it is very dense for the first edge by two levels means at it has a lot of nodes it is a complete binary tree so it has two to the edge by two nodes straight away ya and that means that the height can not be too large if i had had n nodes the height can not be more than log n two log n right 
so once again i have said that if number of nodes in the AVL tree is atleast just on this fact since it is a complete binary tree on h minus one by two levels it has atleast two to the h minus one by two and at most two h nodes because that is the height of the tree 
this is the useful structural fact to keep in mind about AVL trees although we will not use it for any of our algorithms 
but it just gives you some intuition of what the tree is in wise it that this tree has only a logarithmic depth 
ya so now we looked at this height balance property right we said you know if this height balance property is there then then its nice the height of the tree is only lgorithmic 
and so now we want to say that all our operations are only logarithmic because we still want to say that you know you can do a search in certainty in log n time 
so search is easy there is no problem with search right because after its a binary search tree right forget the height balance property its just a binary  search tree so you just do search as you do in a binary search tree how much time will you take proportional to the height order it height is log n so you will take it only log n time ya great thats the best you can do in some sense ok
now suppose you have to try an insert right suppose when so you work when you are going to do an insert what what can go wrong so recall that we we call this height balanced that treat to be height balanced 

if the difference in the heights of its children is at most a one 
so when i insert a node it can change the height of some nodes ya and as a consequence the height balanced property may get violated ok
so when i insert so insert will be the same the first step of insertion would be the same as we did in the case of a binary search tree ya 
how did we insert in a binary search tree can someone tell me 
first you find the position how do you find that element will you just search for that element that you are trying to insert that will tell you where the position is and just put the node there put the node there and then you start marching up back to the route by following the parent pointers ok
and assume march up you keep updating the heights of the various nodes you encountered because these are the only nodes whose heights could have changed no one else yes
so these are the only nodes whose height we will look at this again in more detail perhaps in the next class i am just giving you the flavor of what needs to be done when we are doing an insertion so these are the nodes at whose height will going to change 
so we will going to the first place where  height change appears where height imbalance happens 
we are going to only start from the node where we inserted and move up the tree towards the route so basically keep going parent parent parent parent parent tell we hit the route and on this path that we follow we find the first node whose which has the height imbalance property right
so suppose that node is called z and its grandchild is called x ok
let me skip this part and wise up node in which 
so let i think its best of  show your picture and that will give you an idea 

so suppose this was my tree right forget this empty node for now this was my tree originally right 
if this will my original tree is that in AVL tree height balance is satisfied here because this is one this is one this is not there this forget this type of node right
this is also height balanced because this is two and this is one this is also height balance this is one and this is zero this is height balance because this is two and this is three initially 
but now suppose i went an certain a node lets say fifty four which came in here ya fifty four would come here i go right here left here right here and left here now the height balance property is violated so what i am going to do this i am going up the tree towards the route is the height balance property violated here no its not right 
so this is one this is zero is it violated here no one two this is height two this is height one is not violated here is it violated here yes because this is now three and this is one so these numbers are the new heights right this is three 
so this is the first node at which the height balance properties we call this nodes  its child will be y and its grand child will be x we wonder which child of this node will be y will the child on the path that we taken 
and now we need to do something to this tree to make it height balanced again this is not height balanced tree right all the things we said about log n and all we go out of the window if you leave the tree like this right
so what we are going to do is we are going to rotate do a kind of rotation operation and this will become my new tree ok so in some sense what i have done is a kind of move this up move this down and this fifty was here right 
it looks a bit mysterious here so thats what we are going to do in the next class right understand how this rotation operation is done so i can see now the height balance property is not violated at any node 
ya so its not clearly here its not here its not here both of them are height two this also this is height two this is height three and this is height two so its not violated

 this is still a binary search tree with the same keys as before we will not change the keys right there are other ways also right but this is you know you want a an automated way of doing it right you should not have to look at the you know you dont have to draw the picture and then figure out what rotation have to be done right so you will be able to do this program
so this is what we are going to do in the next class look at insertion look at how to do this rotations so that the height balance property is retained even after insertion so look at both insertion and deletion in the next class 
so in todays class we looked at
AVL trees we saw what how AVL trees are defined and crucially we saw that the height of an AVL tree is no more than actually we proved a bound of log n to the base one point six three today right
we spend a lot of time figuring out how to solve that recurrence relations so we saw two ways solving that recurrence relation we also look as some structural property of the tree which also proved a similar bound and the height of the tree ya so we that will end todays class  

So today we are going to continue on discussion on AVL trees in particular we are going to look at the insertion and deletion procedure in an AVL trees
so we will begin with the insertion 
so we had started this discussion on insertion on the last class also 
so suppose i am trying to insert a node v in to an AVL tree right 
actually what i am trying to do is insert a key right but so whats a process of insertion in a binary search tree 
first you find where the key is right you go to that place you put the key there 
that say the node in which i put the key is the node in which i put the key is v okay 
now this is something we had started the discussion of so if as a consequence of this insertion 
it doesnt remain an AVL tree then thats because the height balance property is violated ya and what are the nodes whose height could change as a result of this insertion right which of the nodes whose height could changes we  call the define the height of the node as the height of the subtree rooted at that node ya
so this is large tree and some where below there i insert a particular node ya 
so which of the nodes whose heights could change it could only be the ancestors of this particular node ya not because its return here but you should also understand why it is only ancestors because its only in the ancestors of that node would whose subtree has changed as result of this insertion process right
for any other node its subtree has not changes its remains as same other flow 
so the ancestor of this node their height might change and change it will only increased right 
because we add in a particular node so its the ancestor of this nodes whose height might increase as a consequence of this insertion 
so if (refer slide time 03:47) the insertion cause the tree to become imbalance or unbalanced then some ancestor of this node v is the culprit is the place where some one or more ancestors right where we have a height balance problem 



height problem means it will become height imbalanced height imbalance means one left subtree and right subtree the difference in heights is more than a one 
so what are we going to do we are going to essentially travel up the tree from this node v 
travel up the tree which means just keep following pin the parent pointer ya till we identify the node z which is unbalanced right
so as said it as till we find the first node x whose grandparent is unbalanced 
but you can also think of it as find the node z whose grandparent who which is unbalance and xz is it grandchild 
which  grandchild 
the  grandchild that we travels went through the  grandchild on the path right because the node can have many  grandchildren ya i will show in you example and this will be clearer and we will call if y the parent of x 
so y is the parent of x and the child of z then right 
so suppose this was the situation we had this was an AVL tree ya and i insert let say fifty four in to this tree 


so fifty four would come here why because its larger smaller larger smaller and so it would come here right
now if there is a problem actually this tree is not height balanced any more this is not a AVL tree any more 
so if there is a problem we said that the problem would be on one of these nodes 
so note that these are the only nodes whose heights are changed earlier this node had the height of zero 
now it is one this node had height of one 
now it is two this node had height of two now it is three this node had height of three now it is four which is the first node on this path whose height has which is now imbalanced 
this is imbalanced 
fifty 
no 
difference of height is one this is imbalanced yes 
right difference of height two this is one this is height three ya
the height of no other node is changed the height of this node is not changed ya 
so you understand why the heights of these nodes on this path would change 
right 
so this node will be z 
ya 
this node will be z 
x would be its grandchild on the path and the parent would be y 
[noise:student]
lets call that x is the node y is the node and z is the node ya 
so x is the node here 
okay 
every one with me 
so we travel up from here 
we find the first place where the imbalance happens lets call that z and x is the  grandchild of z  grandchild means parent sorry childs child 
so child is y and its child is x and now we are going to rebalance this tree 
so to rebalance this tree 
so we are going to particular rebalance this subtree 
subtree rooted at z and we will do that by performing the rotation and this is what will happen after the rebalance this is what the tree would look like okay and what we are going to today is understand how we came up with this picture as we can see i have only change to this subtree which subtree this subtree 
the one containing this six nodes forty eight fifty fifty four sixty two seventy eight eighty eight they are here the six nodes but organized in the manner now 	
so that this node is not height imbalanced any more and either is this node height imbalanced 
yes 
we are going to understand this process today okay 
so lets first understand what is the rotation right 
in the previous slide i use this system rotation 
what does the rotation mean 
so rotation is the way of locally re organizing the binary search tree okay 
so this is part of my binary search tree 
this could be huge tree i just consider the part of it ya
so u is one node 
v is its child and these are some subtrees
this is a right subtree 
this is the subtree rooted at the right child of u this is the subtree rooted at the right child of v 
these is the subtree rooted at the left child of u
this could be a null tree 
no node or could be a huge tree i dont care right 
what do i know because its a binary search tree and know all the keys in t one are less then the key in v 
all the keys in t two or more than the key in v 
keys in t two are less than the key in u and keys in t three are more than the key in u right this follows from the property of binary search tree yes okay
now what is the rotation step going to be okay 
so first what we are going to do is lets just forget these links okay lets us look at this and now this is what the rotation is as okay
so what has happen 
v is become the parent of u ya you want to replay of this okay 
[noise:student]
slow motion right 
so its sufficiently slow okay thats what a rotation is and will put the links back 
now right 
so what happened what happened was v became a parent of u the binary search tree properties still holds by the way 
keys of t one less are than v keys of t two are more than v 
so they come here and they are less than u so they come to the left of u right
so still a binary search tree 
but we have done some local reorganization right and this will be very useful and we will see why right
so t one earlier was the left child to the left of v it remains to the left of v ya t three was to the right of u 
if you remember 
lets see t three was to the right of u t one was to the left of v t two was to the right of v right 
so t three remains to the right of u 
t one remains to the left of v 
but t two moves from being right of v to the left of u 
its now the left child of u 
ya 
every one follows this what a rotation is okay 
now lets see how we will use these rotations to do or insertion okay (refer slide time 16:29)


so okay 
so suppose the insertion happens so this is the tree i am not drawn the links right but it should be clear what the links are who can tell me what the links are 
y is the child of z 
x is the child of y these two are the children of x t three is the right child of y 
and t four is the right subtree of z ya
so in the next few slides you will see the pictures with out these links but that just to avoid the clutter 
it it should be completely clear what the relationships are
now suppose i did an insertion in t one ya and these are the x y z that being counted in the procedure so may be  insertion happens some where in some leaf 
we went up along the path towards the root 
the root is may be some where here ya and z was the first place at which we had an imbalance and so y was the child of z and x was the child of y on this path that we took 
any questions to this point right
i have taken this one picture but it could also be different right y could have been the right child of z ya 
x could have been the left or the right child of y right 
so there are how many different cases possible 
four 
y could be the left of the right child of z and x could be the left of the right child of y 
two times two four different cases some looking at one particular case now 
that y is the left child of z an x is also left child of y and the insertion happened here 
so the insertion happened here 
so lets say the height of t one i am using this to denote the height of the particular thing the height of t one lets say originally it was h and now because of the insertion it became h plus one ya
it cannot increase by more than a one and because of tol i am just adding one more 
so the increasing height can be at most a one and so lets say there was an increasing in height ya
so there is an increase in height of this node x also 
there is an increase in height of node y and there is also an increase in height of node z right that is why z became a imbalanced right 
if there was no increasing height of y then z will not be come imbalanced right 
if [noise:hindi] insertion 
everything is a same as before that means height of y is also increased and height of y is increased because height of x is increased right and height of x is increased because height of t one as increased and height of t one let say increased from h to h plus one what can we say about the height of t two now 
what is the height of t two [noise:student ] okay
so x is  balanced even after the insertion because z was the first node which was imbalanced 
so x was balanced after insertion 
so if x was balanced after insertion other [noise:hindi] height h plus one but t two height h plus two ya h plus one ya h three [noise:hindi]
every one is with me 
so height of t two is one of these three 
which one okay 
can it be h plus two if it is h plus two then originally x is imbalance because originally height of t one was h 
if this is h and this is h plus two and then this was imbalance even to begin with but does not in the case right originally it was an AVL tree 
so height of t two can not be h plus two can it be h plus one 
if it is h plus one then height of h does not increased because this is h plus one then that means what was the height x to begin with h plus two and what is the height other if the height of this increased from h to h  plus one 
even then its height remains that h plus two 
the fact that the height of x has increased implies that this cannot be h plus one because this was h plus one then the height of x should not increased 
it remain what it for before h plus two 
everyone follows this ya 
so this implies height of t two cannot be h plus one 
so it has to be h
so height of t two is h 
if height of t two is h then height of this has increased from h to h plus one then what about height of x 
what was the original height of x 
original height was h plus one and now its become h plus two yes 
is this clear to everyone 
so the height of x is increased from h plus one to h plus two right 
lets continue this argument 
so this is the picture
so far we have argued that the height of t one has increased from h to h plus one then height of t two is h then the height of x is increased from h plus one to h plus two 
what about the height of t three now okay 
so once again since y remains balanced the new height of x is h plus two 
so and this is balanced 
this is height balanced 
so the height of t three is h plus three or h plus two or h plus one 
one of these three because the difference in heights can only be one so its one of these three 
now if it is h plus three we repeating the argument roughly ya 
if it is h plus three then that means y was originally imbalanced 
because original height of x was h plus one 
so y is originally imbalanced 
so height of t three can not be h plus three 
if it is h plus two then that means that the height of y has not increased right because if this was h plus two then the height of y that means originally was h plus three right [noise:hindi] 18:04 h plus 
so height of t three cannot be h plus two 
so height of t three has to be h plus one right
so height of t three is h plus one 
so if height of t three is h  plus one what is the height of y now 
so originally it was h plus two 
because both of these guys were h plus two h plus one 
so these was h plus two originally and now its become h plus three so its increased from h plus two to h plus three 
is it clear to everyone ya 
now what about height of t four 
note that z is imbalanced ya 
the new height is h plus three of these guy 
so what should the height of t four v or h plus five 
[noise:student]
initially it was balanced 
so since z was balanced z was balanced height of t four is h plus one or h plus two or h plus three right 
since this was originally h plus two 
this could only have been h plus one h plus two or h plus three and since it is now un balanced it cannot be h plus two or h plus three it has to be h plus one ya 
so this is h plus one 
whose not following 
if you have a question please ask 
your face will not come on the television you can ask the question 
no
so height of t four is h plus one ya 
so what is the height of z initially 
this was originally h plus two 
this was h plus one 
so this was h plus three originally 
ya and now of course its heights become h plus four but  now we will do some rotation and stuff like that 
so that will reduce its size so its original height was h plus three ya 
every one follows this good 
so you will keep this picture right 

so this is what we argued 
that we quickly this is the final thing we argued right 
these are the heights of the various things 
so when i said from here to here this the first thing is what it was originally and what it is now 
so we just need to look at the new values okay
now we are going to do a rotation around this pair y z 
so what is rotation do rotation is going to rotate this 
so that y is now going to become the parent of z 
yes 
ya 
is it clear to everyone 
so what do we want to do 
we want to move this up 
so that it will come here and y will become the parent of z ya and pardon 
yes this is what the rotation let me just write here 
so  y will now become the parent of z 
yes and where will i put these two 
so this this is one subtree this come remains as it is this will not be changed ya 
so t three and t four are only ones which have to be so t four recalls will remain at the right 
t three will come to the left and this big piece will remain as it is yes
thats what the rotation was so lets just 
this is what will happen  ya
y is become a parent of  z 
these two are the children of z t four and t three and this entire thing was to the left this is clear 
again i am not shown the link but it should be clear what a links are 
ya and i have written down the heights 
the height this was h plus one this was h this was h plus one this was h plus one h plus one h h plus one ya 
as a rotation after a rotation we already saw that the binary search tree properties are maintained
so this is still a binary search tree but now we want to argue that height balanced properties is also restored 
[noise:hindi] where was the height imbalanced happening on z z as you can see this has height h plus three this is height h plus one 
so this height imbalanced 
now let see what is the height of node x now ya because this is h plus one this is h what is the height of node z 
h plus two 
what is the height of node y 
h plus three is everything balanced now this is balanced this is only a difference of height of one this is balanced no difference this is balanced no difference ya 
so we have done a rotation 
this is called a single rotation you will soon see why it is called a single rotation 
how much time does this operation take just one rotation right 
we just have to do the constant number of operations right 
we have to may be y y we will have to in z will have to become a child of y 
 so there will be three or four different reference changes that you have to do 
may be five may be six some constant  number independent of the number of nodes in the graph in the tree okay 
now one interesting thing is happened 
the original height of z was h plus three yes 
thats why we have written this h plus three here  after this rotation the height of this subtree is also h plus three 
yes
whatever was the original height of this is the new height of this subtree also 
so the height of the subtree  remains the same the same after the rotation 

the remains the same as in what was whatever was the height before the insertion even h plus three was the height before the insertion ya
so after we inserted and dead the rotation the new height is also become h plus three 
why is this important ya 
because now i dont have to go up further ya 
because now any ancestor of this its height would not change any more because i have whatever was the original height of this h plus three of this node is the new height of this subtree also 
so any of the ancestor of z their heights would become the same as before and so they would be no imbalance on them 
right so 
as i marching up after i did my insertion as i well started moving up 
i find the first place where was there was an imbalance i did the rotation ya and i am done 
i dont have to go up any further 
lets see 
so we have actually consider only one case 
one out of four different cases 
yes 
why one case 
because we said y is the left child of z and x is the left child of y 
now there is one symmetric case which has the symmetric both are right right right that i am not going to handle because i trust all of you can be leave me there that it is the symmetric case completely right 
so the other case is this one ya 

where x is let see the right child of y which is the left child of z okay 
this has the symmetric case which is that y is the right child of z and x is the left child of y 
again thats completely symmetric and will not handle right okay okay
so lets repeat the argument that we had 
so once again i am assuming that the insertion happens here 
right it could happen in any one of these but again it its symmetric lets assume it happens here
so this height went from h to h plus one 
what about the height of this guy 
right 
so since this is balanced even after the insertion the new height so the height of this is either h plus two or h plus one or h 
if it is h plus two then that means x was originally imbalanced 
if it is h plus one then that means the height of x is not changed 
so it has to be h ya 
i am repeating the argument its as same as before ya
so this is h and the new height is h plus one 
so what is the new height of x h plus two and what was the original height h plus one 
so its height moves from h plus one to h plus two 
now lets look at the height of t one well since y is still balanced then that means the height of t one is either h plus three or h plus two or h plus one right
so if it is h plus three then that means y was originally not balanced 
if it was h plus two then ys height has not increased 
so it has to be h plus one which means y is height has increased h plus two to h plus three which means that now since z is imbalanced the height of t four has to be h plus one ya 
which implies that zs original height was h plus three ya 
exactly the same as before we do not make any difference ya okay 
but now the rotations will have to be different a bit okay
okay which of these three keys 
so in x y and z which of these three keys is the middle key x y or z which of these is middle x z is the largest y is the smallest right  
so if you recall in the previous rotation we are x y and z again there 
in the previous rotation which was the middle key why because all there in a line ya z was the top y was its left child so it means y is less than z and x was left child x is less than y is less than z
so after the rotation we ended up making y the root 
the middle child we the middle key we ended up making the root here also we want to do ended up making the root here also we would want to do something similar but except that the middle key is now x okay 
so we are going to do a two step rotation thats why it called a double rotation
so first i will rotate x y  okay
let see what will happen after i rotate x y 
this is what will look like it will look like x as moved up y is moved down 
t one remains the left child of y 
t three remains the right subtree of x and t two switch is loyalties from x to y 
so earlier it was the left subtree of x 
now it is the right of subtree of y and t four remains as it is 
yes 
every one with me and i have just copied the same height so t one has height h plus one t two has height h  plus one t three has height h 
t four has height h plus one 
no difference is this balanced this is height balanced height of y is h plus two ya because both of these height are h plus one 
height of x will be h  plus three actually now there is an imbalanced at x itself ya because this has h plus two and this has h there is an imbalanced here and height of z would be h plus four because this is height h plus three 
one more right 
so this rotation has not done the job for us yet ya
so we need to do one more rotation what other rotation i need to do rotation x ya 
so what will happen now 
x will go up and z will come down x will become the parent of z t four was the right subtree of z so it will remain the right subtree 
y had t one and t two as left they will remain as they are and t three which was the right subtree of x now becomes the left subtree of z 
the same thing ya okay 
now lets compute heights 
height of y h plus two height of z h plus two height of x h plus three 
height balance happens ya 
this is balanced here its balanced here its balanced here 
further more the height of this subtree is the same as the original subtree h plus three right 
so final tree as the same height of the original tree and we see need not go further up the tree 
everyone follows whats happening 
you understand the need for the double rotation here right
we ended up doing the same thing as i said the middle key ended up being at the top because we want to be able to split the thing uniformly now ya
why was the height here imbalance 
why was the height imbalance happening 
because you know this was the middle key it was coming way down right  
now when i kind of split uniformly the heights reduced and there is a height balanced its roughly what is happening here 
how much time does the double rotation take 
constant time ya okay 
everyone with me 
so so just as a quick recap we we have four different ways to rotate node in an AVL tree so the single rotation was something like this right there were all in a line x y and z are they were like this x y and z and after rotation this is the picture you get and here after rotation this is the picture you get right 


this is just as a recap you understand why we are doing this thing and why this picture is a balanced picture height balanced picture and we also sort the double rotations 
so either like this in which case after rotation you got something like this and or it could be like this left and right and which case again after rotation you got something like that ya
this is just to show you a picture 
you dont have to understand much here you are hopefully understood why the single and double rotations are done in the way they are done okay
so now lets come to deletion  because exactly the same principle are going to be useful for deletion also [noise:student]
it is a  binary tree 
the difference between the height does it become zero 
we saw that right 
we see that lets see 
here it became here it became zero at this node but not at this node here the difference or here it is zero but this node the difference is a one but some nodes they  would be difference of a one they some other nodes they would be difference of zero okay
so now lets look at the deletion 
so in a binary search tree when i delete a node we will have three cases 
if  you remember right 
when i am deleting the node which is a leaf or i am deleting a node which is only one child or  i am deleting a node which has two children when i delete a node which has two children what did i do 
i went to the successor of that node i copied the content of their successor in to that node and deleted the successor 
so the actual node i deleted was the successor node and the successor node has only one child or no children 
why does the successor only one child [noise:student] 
because it does not have the left child
because if it had the left child then it would not be the successor 
it has only one child or it has no children 
so the actual node that you end up deleting is either a leaf node or a node with only one child right 
everyone with me
this is the actual node that you ended up deleting okay
now so what is the node which has only one child in an AVL tree if i tell you here is a node which has only one child what can you say about that  node [noise:student]
this is a node with only one child right 
can it have another child 
can this node have the child 
no
if it had a child like this then what would be the problem they would be height imbalanced here 
so it cannot have this child or it cannot have this child so which means this node is a leaf exactly 
so if in an AVL tree and node has only one child then the child is a leaf
if in an AVL tree if a node has only one child then that child is a leaf ya
so what are we saying 
i am either deleting a leaf when i am deleting in an AVL tree or i am either deleting a leaf or i am deleting a parent of a leaf 
if i am deleting a node with only one child then its a parent of a leaf yes 
so which means that i am essentially deleting a leaf if i am deleting a parent of a leaf them essentially what i am doing i am just i can think of it as if i was deleting the leaf and copying the content of the leaf in to the pair 
so i am i can always think of it as if i am deleting a leaf ya 
so either deleting a leaf or parent let us keep that in mind okay
so lets lets say w is the node that we are deleting okay 
now we are going to define our x y and z slightly differently right 
so z is once again the first unbalanced node that the link counter as we go up from w towards the root 
when i deleted w once again whats going to happen 
the ancestors of w their height could reduce right 
so one of this one of these ancestors will be unbalanced if their if any are unbalanced then one of this will be unbalanced
so lets say z is the first unbalanced node encountered while we are traveling up the tree from w okay
now y is not the child of z on the path 
but we defining y as child of z with larger height and x is the child of y with larger height okay 
z has two children 
one of them has lef one of them has a larger height than the other one ya 
so we take that one 
so once again we perform it rotation to restore the balance of the the height balance of the subtree rooted at z 
now what is going to happen here is that this rotation now we are doing so in the case of insertion what was happening is that once you did the rotation you dont we did not have to worry any more on the ancestor nodes 
right 
everything was taken care of we could stop after doing the rotation
now in delete what we are going to see is that we might have to continue up and we will see what the reason for that is right
so you might have to continue up the tree go to the ancestor of z and once again find the first node which is unbalanced and repeat the rotation there and after that go even further up fine the first node which is unbalanced repeat the rotation  there and so on till you reach the root okay
so lets understand what is happening ya yes [noise:student]
z is the device the child x is the child of y will larger height ya 
if both of them have the same height then we will we will say which which which of them should be x will say that in a minute right 
it could happen 
so this is a valid question both the children of y might have the same height so then which is x 
we will see which is x okay [noise:student]
no 
the two children of z cannot have the same height 
because that is the imbalanced node right okay
ignore this h minus one or  h minus two for a minute 
they should not they should have come at the end so this is the picture i have z which is the first unbalanced node y is the child of z which has higher larger height and x is the child of y which has larger height right and i did a deletion in t four h i did a deletion in t four i started going up the tree i found a z ya i found a z y was a um okay can y be so valid question can y be this node here [noise:student]

right 
so the height of this if if if y was here then it heights would have actually decreased right 
so whats a problem 
[noise:student]any choosing y to be the larger so it cannot be y which is decreased 
okay ya so did everyone follow what using lets see 
so question is why did i draw y to be this 
so i so i am w is some where here the node i deleted some where here right i said i started walking up this and i came here and this was a first node i identified which hadnt balanced right and then what did i say 
let me take so this node has two children 
this is one child of z and the other child of z is this one i said let us take the child of z which has larger height why could it not have been this node which has larger height right[noise]
so this is very simple actually 
this is imbalanced that happened here earlier there was no imbalanced 
imbalance happens because this decreased the height of this guy decreased yes
so if there are two things which was balanced right if there are two things which are balance and one of them decreased yes then what can we say about the relationship between these two things initially could it have been could this have been this have been smaller than this 
no 
because this was smaller than this then actually it will become more balanced now so this must have been larger than this for imbalance to have happened right 
so this is y therefore okay 
so the height of t four has reduced from h to h minus one 
lets say what can i say about the what can i say about the height of y h plus one ya everyone with me on this 
so y because originally its h minus one now  right so this means that this must be h plus one or h plus two it cannot be h plus two because then originally also it was unbalanced it cannot be h minus three kind of  a thing because then initially it was unbalanced straight has to be h plus one 
so height of y is h plus one okay 
now x is the node the two of of the two of this x is the one which has the larger height 
so what is the height of so height of x is h ya what can i say about of height of t three [noise:student]
it can be h 
so since this is y is balanced this can be h or h minus one a because y is balanced okay good 
i will take these why these are in this in the next slide right 
so this is what we have argued so far
this goes from h to h minus this is h plus two this is h plus one h or h minus one right 
so this is height is h 

so one of them and this is also balanced right 
so the heights of these two are h minus one or h minus two h minus one[noise:student]
one has to have a height of h minus one 
so both cannot have a height of h minus two thats only thing we can say 
both can have the height of h minus one 
so you cant say that only one can have a height of h minus one thats a wrong statement at least one is the height of h minus one 
so lets do a rotation now to see what needs to be done so these are the various heights that have seen 
yes 
this is what we argued in the last two slides okay 
now what kind of rotation should i do 
i will do a rotation y z once again ya 
similar to what i did in my insertion so as a consequence you will have this kind of a picture now 
yes y went up z went down t four and t three became the two children of z and t one and t two are the children of x 
i have written down the  heights h minus one or h minus two h minus one or  h minus two h or h minus one and h minus one ya 
because t four went from h to h minus one 
so this is h minus one 
what is the height of x now 
this is h minus one or h minus two this is h minus one or h minus two but one of them is at least h minus one 
so x is h 
what is height of z [noise:student]
h or h plus one 
so what is the height of y [noise:student]
h plus one or h plus two 
what was the original height of this tree 
h plus two 
so if this is h plus two then we are okay 
we dont have to continue but if this is h plus one then we may have to continue because this now becomes the bigger tree [noise:hindi]
we will have to continue the argument as we go up 
everyone follows this ya 
the wave is said height is reduced from h to h minus one now we might have to say that this bigger thing height as reduced from h plus two to h plus one and we will have to repeat the argument at the next higher level and so on good 
so after rotation height of subtree might be one less than original height in that case we have to continue of the tree might be you understand might ya because it could not have reduced in which case we can just stop
so this is single rotation in the case when this was the picture y was the left child of z and x was the left child of y 
but we could have this kind of a picture 
that x is the right child of y yes 
so the first part of the argument is the same 
this has gone from h to h minus one 
so we argued that the height of y is what was it h plus one so height of y is h  plus one and height of y is height of x is h because x is the one which is larger height and height of z is h plus two because height of y is h plus one ya this is height h or h minus one good
how about the height of T one 
so y is balanced 
so height of T one is either h or h minus one 
now height of T one was h then what i would do is i would pick the root of T one as x right [noise] 
so so it will in that case i will be able to do that in a single rotation of mine the previous case 
if the height of this is x and the of this is h and the height of this is also h right that the same thing that the question here asked earlier which do we pick 
now which one like you like pick i will pick [noise] the one which will give me the single rotation case right 
i cant say i will pick the left child or the right child i will pick the left child if y is the left child of z if y where the right child of the z then i will pick the right child ya
so therefore since such was not the case height of t one if it was h then i would picked it pick x as the root of T one 
so height of T one is h minus one height of T one is h minus one ya and since the height of this is h these are the same as before h minus one or h minus two for both of them with one of them at least being h minus one [noise] 
this is the new picture now okay 
so let me just copy it here 
this about the heights of the various nodes and tress are okay now lets do the double rotation step 
so first i am going to rotate i will before xy the same process as an insertion essentially 
so with the rotation of xy 
y will come down x will move up i would get such a picture t three is the right child of x now 
t one and t two are the two children of y left and right of the child sub tress of y 
this is h minus one this is h minus one or h minus two this is h minus one or h minus two this is h minus one okay
now what are the heights of these nodes 
height of y is h what about height of x 
h plus one and there could be an imbalance at x if this where h minus two [noise] and height of z is h plus two because this is h plus one and there is an imbalance at this node 
so there could be here there is here there is none here ya um
but we are not done so we will will now do a rotation around xz yes and now what would be happen 
x moves up z moves down t three and t four become the two children of the z t three has height h minus one or h minus two t four has height h minus one and this is the height of  t four and this is the height of t three this is the height of t two h minus one h minus two t one has a height h minus one 
what about the height of y now 
h is it balanced yes this is h minus one this is h minus one or h minus two 
what is the height of z 
h is it balanced 
yes 
h minus one and h minus one or h minus two what is the height of x now [noise] h plus one 
it is also balanced 
but this height is now strictly one less than this this case may [noise : Hindi ] this no might this time um okay 
why did i require why did i make that argument [noise : Hindi ] height h minus one [noise : Hindi ] h [noise : student ] um we could have done single rotation [noise :hindi] and all that thing [noise : student ] [noise : Hindi ] you understand y y had to make this kind of argument [noise : Hindi ] 54:41 good 
so hopefully you all understand this that any questions right 
what has happened is final tree has height less than original tree 
we need to continue off the tree right you understand the need for continuing of the tree [noise] because height has reduced by one as the consequence they could still be imbalanced at the ancestors
ancestors of this now what ever is this node in the ancestor [noise :student ] 
no [noise :student ] um [noise :student ] right [noise :student ] okay 
this will require a proof even if it is correct right so thing about it 
its a good question 
he is asking me if youe know whether we can just be satisfied by checking the parent of this node right 
so thing about this and we will we will answer it may be in the next class may be after the class okay
so lets quickly look at what the running time of insert and delete okay
so for insertion 
we spent log n time in finding way to insert why log n height of the tree 
we actually spent time actually proportional to height of the tree which is the height we argued in the last class okay
so we spent log n time down then we spent log n time may be moving up at most log n right because thats the height and then we spent constant time in doing a rotation and one rotation and we have done 
so the entire thing is only log n deletion um recall that insertion what we said was that you will first find the node in the binary search tree whether the insertion has to be done 
you will insert the node then you will start moving up the tree to find the place where the imbalance occurs 
the first place and then in that place we said we will just do a rotation and with one rotation you will be able to satisfy the height balance property once again 
so insertion basically requires order log n time to insert the node and you might have to spend order log n time to move up and the constant time to do the rotation 
so in all it just takes a log n order time 
deletion of the other hand also requires only order log n time but we need to do a little bit more work right 
the reason for that is that to delete the node to recall that you have to identify which of those three cases the node is does in whether the node is deleting is leaf node or if it has only one child or if it has two children then we need to find the success around the node
so we need to go right and go keep going left find the successor swap contents and then delete delete the successor node 
once you deleted now you have to move up the tree to find the first place where the imbalance occurs having found that you do a rotation that rotation may or may not solve your problem 
if it does not solve the problem of height balanced it doesnt restore height balance then you might have to continue up from that from that node right
and may be once again performer rotation if thats also the problem then you stop otherwise you will have to continue up 
so in all the number of rotations you might require is as large as the height of the tree right because every rotation you are moving one level up 
so you might require as many as order log n rotations but each of those rotations only taking a constant time 
so the total time require for all this rotations put together this only order log n and we took order log n time to delete the node all the rotations also took order log n time and so the total time required for the entire delete operation is still order log n right
so that will end todays class we saw how did do an insertion and deletion in AVL trees and we argued eventually that the total time taken for both insertion and deletion is only order log n ya um 
in the last class we had seen that the time taken for search is also only order log n in the case of an AVL tree 
so all the three operations of insert search and delete can be done in log n time in a AVL tree
thank you. 

two four Trees
in todays  class we going to talking about to two four trees this is another way of representing (additionally)
so we are going to see operation of insert search and delete on this data structure and we are going to have same kind of performance guarantee as was the case in AVL trees 
but we us going to in later classes see how this data structure is useful 
so today I am just I will just begin with this 
so what are two four trees 
they are search trees they are kind of search trees but they are not binary search trees 
so recall in a binary search trees what was happening 
the tree was a binary tree ya 
each node at two at most two children right 
so this not going to be a binary tree thats a first point 
so nodes can have more then two children now 
so this two four trees are also called two three four trees right
I will tell you what this really needs 
so two three four actually refers to the number of children and node can have 
so node can have either two three or four children right

such trees in which node can have many children but satisfy a certain kind of search properties or called multi way search trees right
so each internal node of a multi way search tree has at least two children right
so besides the child so it will have so at least two which means it could have more then two children right any number of children more then two 
each node of tree also stored a collection of items the form key coma element right 
so just as a binary search in the binary tree in a binary search each node was storing one key and the element there was lets say reference to the element or the element itself could be stored there right 
if the key was lets say student record student entry number the student record as you said the key could also be stored in the node itself 
so in the similar way we have that in the multi way search tree you will have each node containing a pairs of this kind
 
key comma element and how many pairs there could be more then one right 
in the binary search tree there is only one such such pair and each node and in a multi way search tree there could be more then one 
in particular there could be d minus one search pairs or items right where d is the number of children that particular node has right
so just as so we just as generalizing a binary search trees 
in the binary search trees there is each node has two children ya 
each node could have two children and then there is only one keys that is left kept in the node 
because that keys helps us helps us determine if we should go left or right 
similarly here we have d children 
d is the number of children then you really needs to know in the search process whether you should go to the first child second child third child fourth child and so on 
so you will have d minus one difference keys sitting in the node to help you determine that 
i will soon showing the example and that should clear with that right and I think I come back to this after I show you the example  okay
so this is an example of multi way search tree okay
as you can see this node has two children 
this has three children this node has two children this has actually d children 
so sorry this is actually six children ya  okay 
now how many keys are there in a node 
the number of keys in a node is one less the number of children in that node has  and why is that ya 
so for instance this node has three children and you read need two keys in the node 
the key is determined you know the keys in the node determined what set of keys the various sub trees are going to have right 

so what I am trying to say here is this is key twenty two 
so everything in this sub tree 
so this sub tree is actually this is also in the left sub tree here ya 
so everything in this left sub tree here is less then twenty two and everything here is more then twenty two yes
is just clear everything here is more then twenty two and everything here is so if you look at this key everything to the left of this is less then five everything more then ten so in the right sub tree so we now have three children right 
so in this first sub tree everything would be less then five 
in the last sub tree everything will be more then ten and those in between five and ten would  lie in the middle sub tree 
so thats a concept right 
now you understand why you need d minus one keys if you have d children right 
so everything less then the first key would been in the first sub tree for that you have to follow in the first child 
everything between the first key and the second key you will have to follow in the second child and so on and on right
so with that let me go back to the previous slide 

so the children of each internal node are between this items right 
this is what I mean by between in code 
so you have certain node it has various keys or items 
so if you look at two consecutive keys then all the elements all the items which have key value between the consecutive pairs would be in one sub tree for that you will have to follow one child okay 
so lets get back to this 
this is an example of an multi way search tree right and how do you search such as tree searching is similar to the binary search procedure as you did in the binary search tree 
so suppose we are searching for eight you come down here compare eight with twenty two eight is less so you go here 
now you will have to find so eight is not less then five 
eight is not more then ten 

but eight lies between five and ten 
so you will follow this and then you will find that eight is sitting here 
so its a success visit right 
so when you searching for a key s you will compare it with k one 
k one is lets say the very first key in that node and k lets say k d minus one is the last key in that node 
so you compare it with the very first key if it is less then that means you go to the left most sub tree 
if it is more then k d minus one then you have to go to the right most sub tree okay
so when you searching for the node for instance when we searching here for for eight we came down we went left because eight is less then twenty two eight lies between five and ten so we came down here and then we found eight here right
so while we are when we are searching for twenty two we came down the sequence of steps and we found the twenty two was not yet sorry twelve yes 
we found that twelve was not yet okay

so in particular when you (are at) a node you have to determine that the key that you searching for which two keys is lies between right and once you determine that and you will follow the appropriate child now 
at the two extrimate is you will check whether it is less then the first key or its larger then the last key which keys is should follow either it left most child or right most child 
so as simple as that so what would in order driver in traversal tree look like that was the question we were at okay
so first what is the inorder traversal in a tree so we recall inorder traversal says left then you print the data of the data and then you go right but now there is no left and right a because a node can have many children 
so what should in what does an inorder traversal here here mean right 
so first go the left most then print the key then go to the next child then print the key then go to the third child then print the key then go to the next child and so on 
right that would correspond to inorder traversal right

so for instance in here if I have to do in a inorder traversal what would I do 
so first I would print twenty two no not first twenty two sorry what would first I would come down here first go left I will first do an inorder traversal on this part of the tree ya which means at first come in here I will first go left I will do an inorder traversal here which means I come in here I first go left but there is nothing so then I print the key thats three then I go to the middle child nothing there 
so then I print the next key four 
then I go to the right child nothing there 
so that finishes inorder traversal on this node 
I have finish the inorder traversal on that node I go back to the parent right and then I will print this key ya because first I went left then I print the key which I print five then having printed this key I will now doing inorder traversal of this tree this sub tree this sub tree here 

so when I doing inorder traversal of this I will get six and eight having finish that I go back print this key now 
it gives me ten and then I will do inorder traversal of this right sub tree here right and that would give me eleven first thirteen fourteen and then all of this ya
so seventeen eighteen nineteen twenty twenty one 
now I finishes the inorder traversal of this entire thing 
so I print the key twenty two and then I go right so we can see you will get the keys in sorted order thats see also easy to prove why
because in an inorder traversal I will first print out all these keys and only then  will i print out these key right 

so which means that in the order of printing all the keys which are less then this key will appear before and all the keys which have more then this key will appear after and this is true for every key so which means that what you get in this sorted order okay ya can a node which have more then two keys yes six eight  put more then other children also for instance I could have something some other here lets say five point five ya five point five would be a valid node here instead of this I could have just one node with five point five here yes ya
so that of course we can we could organized in a different manner 
but five point five is a valid node here right there could be a more nodes here 
okay great 
so now lets understand what two four trees okay so two four tree is something like this 
what are the properties each node has at most four children 
so first its a multi way search tree okay multi way search tree which mean every node has at least two children ya
now we are seeing each node has either two three or four children thats why its called two four tree or two three four tree 
each node has atmost two has two three or four children the second important property is a all the leaf nodes are at the same level right
so the leaf node here are this just forget this square boxes for now 
so these are the leaf nodes and they are in the same level they are all at level suppose we are numbering level zero one two again 

so they at level two right so these are the only two properties of the two four tree of course it is multi way search tree so that is two four tree is a multi way search tree with two addition properties 
search tree a it will have a properties that everything which is less then this key is going to be in that left everything that is more is going to be in the right 
this is an example of an two four tree as you can see this node has three children and this is two there is no node with four children but you could also have a node with four children in it 
yes its clear to everyone 
what is the height of an two four tree node
okay dont read from the slide tell why should the height of the tree the at least log n to the base four and at most log n to the base two right

so what is the worst case when would height of the tree be maximum [noise:student]
when everyone has two children right and when its in that case everyone has two children and all the leafs are at the last level 
then its basically its exactly a complete binary tree and complete binary tree we were argued with the height is log n base two there was plus one minus one some where while forge where it was but its some thing like that right 
log n base two thats a setting when the tree height is maximum the tree height is minimum when every node has four children in it ya 

because then the nodes are closer to root right you have four and then sixteen and then next level and then four to the sixteen to the four at the next level sixteen time four sixty four at the next level and so on and of ya
once again if we do the same analysis you will find the height of this tree is log n to the base four 
so height of the two four tree on n nodes always lies between these two quantities ya
its either log n base two its lies between log n base two and log n base four log n base four is essentially half of log n base two yes 
so basically the height of the two four tree lies between half of log n and log n okay

now you can tell me how much time it takes two for search how much time does it takes search for the two four tree then um 
why log n 
how do we search in a two four tree its a multi way search tree right so if I am searching for a particular key lets say suppose what do I want to search I want to search for eleven lets say
suppose I want to search for eleven once again I want to search for eleven I came here with eleven like where would i go compare eleven with twelve like come here right I will change color eleven I am comparing with ten so I go right and then I find eleven here 
so found eleven ya

so how much time it doesnt take for me too search in a two four tree height of the tree is it something more that need to do right 
it is correct it is order height of the tree I have to compare with in each node right because when I am searching for eleven after essentially now compare against how many keys there could been in a node 
how many keys there could be in a node and node we said has how many children 
four 
if it has four children how many keys ( ) it have three
the maximum number of keys therefore is three if it has two children how many keys do a require one right node has either one two or three keys so when I search for the key and I come with key then I have to compare it with this node with this key with this key and with this key 
some what require three comparison and all right
to determine which particular branch to take out some what require three comparison 
so that time three comparison with in a node times log n because thats log n is a number of node I would be given to order log n ya 

so order log n is correct but you have to careful about this 
right within each node you require more then one comparison is in a binary search tree you required only one comparison 
but now you could require up to three comparison great
why three log n 
so he is asking me why we did I say three log n 
when I am searching I start from here ya start at the root and then whatever key I have with the key is a node here this node has only one key but it could have three keys in it 

then I have to compare again each of those three keys to determine which particular branch to take out of that node right if it has three keys then there are four different branches which should I take to determine that if it make three comparison great
so now lets look at insertion in a two four trees 
so I am I have largest example that I am going to be using to show you the process okay 
so is it a two four tree this has four children this has four this has two children this has two children and the last one is also have two children 
I have shown the node with three location in it right 

so in each node will have space for three keys right and for four pointers 
so it has only one key but I am shown each node has having space for three okay
so first element I am going to insert as twenty one 
so how do we insert we insert just as in the case as in the case of the binary search tree right
so first we will search and wherever our search terminates 
if we found that element then it would say that okay its already exist you will not insert then right 
but wherever the search terminates we would insert element is so lets see twenty one I am trying to insert 
so twenty one I come and compare 
so here twenty one lies between thirteen and twenty two so which means I am going to take this branch out 

so take this branch out I compare against the eighty its larger then eighteen so i am going to take this branch out 
so take this and goes and sit that particular node ya
why does it go and sit this node 
why did I compare with the twenty and say okay let me go down further ya 
this is a leaf node 
right 
if i when I hit the leaf node you know if I okay I could also said it okay I compare it with twenty then I try to go right but right node is empty the right pointer is no its null pointer because its not going to any further 
so I know that this is the place where I have to insert and this is empty and there is space here so I just put it in 
[noise:student]

no we would not put it in next to eighty we would continue till we cant go any further this is what happens in the binary search tree right[noise:hindi] till you heat the null pointer and then you put it there 
so till we heat the null pointer 
so we comparing twenty one with twenty lets say we were trying to go right but this is a null pointer and so we put the node here okay
now you wound ring how am I going to use this page we will see how we are going to use this page what was if this was already filled [noise:hindi] you will have to wait till the next slide not next week but next slide okay 
so there is empty space no problem you can do the insertion 

lets say now we try to insert the twenty three okay 
so twenty three lie between twenty two and thirty two 
so we are going to take this link out 
so we took this link out 
twenty three is less then twenty five 
so we come down here okay 
so twenty three in an node we will try to keep this key in a inserted order so we keep them in a sorted order right ya
because only then ( ) twenty three should come in this place what should I do move twenty four to the right and twenty three will come at this place ya

so insertion always actually happens at the very last node at the leaf nodes
so here other way could think of it twenty four was here I compare twenty three at the right to go left thats null pointer 
so thats mean I have to insert that node itself 
okay so now we are trying to insert forty 
there should be no problem with forty forty is more then thirty two so I go right I come here forty is more then thirty five 
so again go right and there is space here so I compare forty with thirty nine is a null pointer so which is means I have to put it right here there is space I put it okay
so now lets say I was so  now if I am trying to insert a node 
so now the question if I am trying to insert a node and there is no space available I am trying to insert a key and there is no space available and then node in which the key should go then what do I do and thats an example 
so when I am inserting twenty nine that the kind of thing that could happen right 
so twenty nine between twenty two and thirty two 

so I follow this twenty nine more then twenty five so its wants to come and sit here between twenty eight and thirty except there is no space here 

so this is what we are going to do we are going to split the node 
which node have been going to split this node 
the one containing twenty six twenty eight twenty nine and thirty 
we are going to split it in to the two okay
lets say these are four keys the two smaller one will go to the left and two larger one will go to the right okay and we will remove this node ( ) we need to 
link up this node right this should be children of this guy here yes


because this are all originally children of this node right 
so this should also be child of this node 
but now its going to have three children but how many keys are there one so we need one more key if it has three children it should have two key so which key I should put here okay
I am going to have promote [noise:hindi] 

so its best to just promote twenty eight okay 
so thats what I will promote twenty eight here 
I could also have promote twenty nine 
you understand why twenty eight and why not twenty six if I promoted up twenty six what could be the problem then the search property would not be the valid yes 
so I have to promote either the largest key from this node up here or smallest from here everyone with me right

so this will become the new structure 
so we have promoted one key to the parent and inserted that key 
we could insert the key in to the parent because there was a space in to the parent it might happen that you know when I am trying to insert the key in to the parent the parent doesnt have any space [noise:hindi] 
seven less then thirteen so we have go to left 
seven between three and eight 

so we should follow the second child we follow the second pointer 
so it should come here and we want to put it here except that there is no space 
so we will split this node two nodes created four five go to the left node six seven to the right node we have get read of this node these are the five children 
of this node now [noise:hindi] 
so if parent node does not have sufficient split then it is split okay 
so we split in the parent node in to two 
three and five will go to the smaller one 
Eight ten will go to the larger one to the right to the other node okay 
now I have one two three four five children right and they have to be made children of these guys okay and one of the smaller [noise:hindi] that has to be promoted up 
because when a split happens then we take the key of the largest key of the smaller node and promoted up 
so we are going to create so the left two would go in to these two left children the first two children would be made children of this node the right three would be made in to this node 
right two of this and three of this 
because five is going to be promoted up right

so that means that only one key is going to be left here which means that this can have only two children the first two children will go here five is going to be promoted up so this will have two keys which means three children 
so these three would be its children and we promote five up right 
so we split this node [noise:hindi] that we split first then we went and split the parent and now we will see the split here also because this will not have any space 
so we split in to two five thirteen will go to in one node twenty two and thirty two will go to the other node 
this will disappear [noise] and now one two three four five these are five children so thirteen will get promoted up now remember right 
so the first two will become children of this and the next three will become children of this and thirteen gets promoted but where does it get promoted it is nothing at above right so we will create a new root eventually we may have to create a new root its what going to have we create a new root thirteen goes up there and these two become the children of this right 
so if we create the new root the height of the tree increases by one 
is everyone with me 

you understand the procedure right 
so you try to so first you will come down the tree till you hit the leaf 
you will try to put the key there if there is space great nothing to be done 
very simple 
if there is no space when you split that node ya and then we decided that the lower two lower keys will go to the one node and two higher keys will go to the other node 
the largest key in the lower part would be promoted up right 
so when we split there are four keys in a node there are four keys four [noise:hindi] 
to which mans the second key of those four ya is one which will get promoted up promoted up means we are trying to insert the key in to the parent node 
if there are successful if there is a space no problem otherwise repeat the split process of the parent node 

so split it right and these split my cascading all the way up to the root if its case up to the root and the root also get split then we have to create the new root thats it ya
any questions great 
how much time does insertion take so search was very clear search we take order log n time 
how many splits can be there in process of insertion right
its a each level we might be doing the split 
how much time does one split take how much time does it take me for the split the node I will create two some two node [noise:hindi] constant time independent of the number ya

so each node split takes constant time 
so that total time order log n [noise:hindi] great
so now lets look at deletion right
so suppose I wanted to delete twenty one 
so first as in the case of the binary search tree 
first you have to search for twenty one find out where the key is 
in the case of binary search tree we recall deletion require three different cases if the key was at the leaf then we just ( ) of the leaf nothing to be done 

if it was at the internal node then you had to then distinguish between one child and two child the one child cases not really happening here right 
so only two child cases we have to be worried about right if it is such as internal node two children then what it we do we found the successor or predecessor of the key lets say with form the predecessor and we move the predecessor to that and delete the predecessor thats what we would mean( )  right 
so we are going to do something similar here 
lets see 

suppose I want should delete twenty one so twenty one there is no problem twenty one is an node right so we will search for twenty one so we come down here go right go left go right and I find twenty one right here 
now why is the problem deleting twenty one its in a leaf node I can just remove it and I can remove it without violating the property of the two four tree 
in a two four tree we require each node has at least one key and at most three keys so after deleting this will still continue to have one key so no problem okay

so thats what is going to happen sorry so I am not shown the process but this twenty one will get deleted we just mark it up nothing to be done 
now if key to be deleted is an internal node is it an internal node 

fine for instance suppose I will try to delete twenty five right 
so I search for twenty five I fine twenty five  bite here ya
so what do I do 
I am going to swap it with its predecessor so what is the predecessor of twenty five how do I find the predecessor of twenty five i am now 
in the case of two four tree I will go left and then keep going right [noise:hindi] then I find the largest key in this node ya

I find the largest key its twenty four so predecessor of twenty five has to be twenty four I am going to swap this two okay then I am going to remove the twenty five from here 
this is a same thing now I can remove the twenty five from here why because its leaf node already yes and there are more then one more then there are two keys in the leaf 
so if I remove one there is no problem 

note that predecessor will always be in the leaf in this case not in the case of a binary search tree lets check this point out 
in the case of the binary search tree the predecessor of a node need not be a leaf node
right 
suppose this was my binary search tree this was a node then I am finding the predecessor so I go left and then I go right right 
this could have been in the binary search tree 
so what would be the predicessor of ten it could be this line right
yes this is not a leaf node 
but here predecessor will always be a leaf node 
why

why would be the predecessor always be so how do I find the predecessor I go left and then keep going right keep taking the right most child 
so when will I stop [noise:student]
what 
when there is no right child 
when there is no right child what does it mean [noise] right when my right child is null then that means that all the children are null right 
because I cannot have a situation in which there is a node which has a key it has no right child but it has left child 
this is not a permitted at all here right 

if there is a key then we have a both we will have two children 
if there were two keys then we will have three children and so on it great 
so my predecessor would also in be a leaf so I would just remove that leaf node and I would be done so thats what I do
now I have to recall I was deleting twenty five 
so I swapped twenty four and twenty five and now I have just get read of twenty five 
so I get read of oh sorry I just have to get read of twenty five 
so I will get read of twenty five by that right twenty five is a disappear from
so very simple case as you can imagine problem raising when I am in a leaf I am trying to delete a key from a leaf which was only that one key in it 

that leaf becomes empty what do I do now right
so lets look at there 
so if after deleting a key and node becomes empty then we borrow a key from its sibling 
lets see what that means
so suppose I am trying to delete twenty 
so I search for twenty I come down in this manner right 
I reach here 
now if I delete twenty so twenty is removed problem is this is in a empty node not permitted 

what will I do 
borrow from sibling 
what is borrow from sibling here 
well this guys means only one sibling this
so can I borrow fifteen from here to here no it is ( ) 38:57 right 
because search property is not going to be valid
so we are going to do something like a rotation like with in a AVL tree 
what is it mean fifteen goes up and eighteen comes down fifteen goes up eighteen comes down 
now everything is fine ya okay

so then the next thing you are wondering is if I cant borrow from my sibling ya if I cant when can I not borrow from my sibling   
when the sibling has only one key in it right for instance now if I trying to delete eighteen then that could be a problem 

wait lets see(Refer slide time 39:40) so if sibling has only one key then we merge with the sibling we merge with the sibling we combine with the sibling okay 



suppose I was trying to delete twenty three right so again so twenty three is right here if I deleted this is an empty node 
so if try to borrow from a sibling right okay 
now there is small catch here [noise:hindi] 
one and two right but I cannot borrow from this one
you see why 
because for the search property it will get because you know if I have to promote something then twenty eight is going to come down but this going to jumble this 

so when I say borrow from a sibling I really mean and adjusting sibling 
if I am I can borrow from here so when I am here I can borrow from here if I am here I can borrow from here 
if I am here I can borrow from here or from here right
but here I can only borrow from this guy 
everyone understand why this is require 
so I try to borrow from here but if I borrow from here that is twenty six goes up and twenty four come down this is going to become empty ya

so thats not going to solve our problem 
so what we are going to do is merge 
these two are going to merge combine but if these two combine then the number of children here of this guy will become two which means [noise:hindi] 
so the key in the parent node which separate this two sibling which is this key which is separating these two siblings is going to move down in to the merge okay

lets see I create a new node which is merge of this two nodes this goes moves down and this also is these are all the only keys in the new node right 
because there was one here there was none here and there was non here two keys and all so they come and sitting 
these two will now disappear and this becomes the child of this node right (noise:hindi) ok
now what can happen 

so essentially what we have done is we said we are going to one of the keys from the parent node is going to come down 
but  what if diverse only one key in the parent node right same as before right [noise:hindi] and so on and on 
so moving the key down from the parent node corresponds to deletion in the parent 

deleting the key from the parent node 
this procedure will be same as that we have done in so far in this leaf node 
but it can lead to the cascading right cascading as in right [noise:hindi]we will see that happening in this example [noise:hindi] 
this is the only child left of it parent right [noise:hindi] per sibling is also only one key 
so we are going to merge with the sibling
we are going to create a new node which is going to get the sibling key and the key from the parent which is twenty two 

so this is the situation now 
right and we will delete this and this [noise:hindi] right
so because of this deletion height can reduce by one after all we said height [noise:hindi] right log n base is less then what it was that means height has shrink what could happen ya or insertion may height 
so everyone understand this procedure right 
there are just very few concept that we really and it insertion may split [noise:hindi] or deletion may [noise:hindi] right 
[noise:student] [noise:hindi] no point is doing that

so first you try to copy try to borrow if not successful then you merge great 
so lets conclude todays discussion  height of a two four tree we seen is log n right 
this would actually be theta of log n right because its at least log n base four and at most log n base two right 
so as far as deletion was concern we have not looked at vaning time for deletion yet but you can see that that is also log n why it was come down the tree to search for the key thats log n right and then we keep moving back up 
at every step we might up we might go to all the way back up to the root right 
so another log n step each step where either borrowing one from the one from the sibling or we are merging with sibling 
but all of them are constant time operation right

borrowing could corresponds to [noise:hindi] constant time right [noise:hindi]
so what you seen in search insertion deletion all take order log n time in a two four tree 
so why did we come up with the very complicated data structure 
why are we doing all of this okay
so well they are fine right no [noise:student] okay
you dont  ( ) this is the another reason we are going to see another data structure called red black tree okay and thats also very fast data structure for implementing dictionaries and what we are going to see is that what we learnt about two four trees todays is going to be very helpful in understanding how the red black trees functions 
so we are going to look at this  in next class 
so that we done in that todays discussion on two four trees 

Red Black Trees (Time 01:09 min)

so in today s class we are going to talking about red black trees 
so we are going to spend some time(Refer slide time 01:17) discussion about red black trees are what is the relation to two four trees and what will discuss next and then we will see the process of  deletion in red black trees its going to be slightly more involve process 



so we will be spending fair bit of class on deletion in the next we are going to handle insertion and red black trees 
so whats a red black tree 

so red black tree first (Refer slide time 01:40) it s a binary search tree okay 



and in a each node in a red black tree would have a so we take the node of the binary search tree and we color them red and black and then it becomes the red black tree subject to certain properties 
so first the root has to be colored black okay 
that s important 
red node can have only black children that s another property that red black tree has to have 

If there is in a red node then its children have to be black 
Now one thing we are going to do is in our binary search tree if a node does not have left or a right child 
so we will create the left or a right child by creating what we will call in a external node right and I will show you what I mean by (that) right 
we will create an additional left or right child it might be that you know if it does not show if its leaf node of the binary search tree then it doesn t have either left child or right child right

so in which we will put in a two external nodes below that leaf node right it make it the left and the right child right 
so external node we are not going to color them 
so its only the non external node original nodes of the binary search tree that we are going to color red or black 
we define the black depth of an external node as the number of black its number of black ancestors right 
so what that means is that we are going to take an external node and we are going to walk up the external node towards the root and the number of  black nodes we counted is the black depth of this external node and the one key property of the red black tree is going to be that every external node has same black depth and that we will also refer to as the black height of this tree 
so lots of definition but we will see what this means (Refer slide time 06:42) 



a couple of examples right 
so this is a two examples of red black trees
so lets look at the one here 
so what do we have this is the binary search tree on five nodes I have colored the nodes black and red 
the root is black red node has only black children black node can have black or red children 
But red node can have only  black children right now as you can see this node does not have any left or right child 
This does not have any left right child this does not have any left or right child 

so I am going to add them right
these I will call external nodes
they are not colored 
so all the external nodes in this class today will be shown in the square boxes right
now what is the black depth of this external node one two 
it is two ancestor which are black similarly the black depth of this are external node is two of this is two of this is two of this is two and of this is also two 
so this is a red black tree [noise:student]
so we will add this external node also to node which have only one child right 
so lets look at this example and that will clearer here right
so once again the root is black red node has only black children 
that is the key the red node can have only black children 
black node can have red children or black children right
now we are going to add the external node so as you can this node has only one child so we will need to add a external node here also
similarly it will need to add two external nodes here 
one external node here and of course these will take two external nodes and so on

so these are the external nodes we will end of handing  
[student:noise]
yes ya black can have black children but red cannot have red children 
its not symmetric
[noise:student]student:if you going to take first case 
staff:ya
student:it has black and both the children left and right to be red right child is if we place the external node and we count the black height so it will be one 
staff:red so then it will not be a red black tree that s what you say 
so if I colored this red then this would not be a red black tree 
ya 

the black height of these guys is to what is the black height of these guy of this tree to take an any external node and look at how many ancestor are black and we will see that its two ancestor which are black right and these is two for every external node if I look at this it also has two black ancestor this also two black ancestor and so on right 
so this also black height of tree ya
so what are the key things we have to ensure first that no red node has the red child 
second root is black 
third black  height of the every external node is the same 
black height or depth I am I am sometimes use the term depth to say how far it is from the top 
so black depth of the every external node is the same the black depth that s what will call the black height of the tree 
depth of the node and height of the tree okay and these are the two examples of trees which are not red black(Refer slide time 07:54) why this is not red black [noise:student]


this red child this red node has red child 
so this is not so even I have put in the external node like this this will not be a red black tree 
why is this is not a red black tree [noise:student]
so the problem here is what we call a double red problem right 
we will use the term quiet often double re as in two reds occurring consecutively  one after the other
here I add the external nodes [noise:student]
the black height of the this node is the black depth of this node is two of this  node two of all of these is two 
these is also two 
this is one this is culprit for this reason this is not red black tree right 
so black height is not uniform 
black depth is not uniform okay

so lets look at what is the height (refer slide time 08:23)	of the red black tree is going to be 



so lets say h is the black height of a red black tree on n nodes right 
what is it means 
if I take an any external node and I will look at count this number of ancestor that it has exactly h ancestor black ancestor okay
when will the number of nodes in this tree 
suppose I just tell you this is the tree on black height h 
when will the number nodes in this tree v small 
when the smallest [noise:student]
when everything is black right that you don t want any red you want as you nodes as possible right 
so why include your red nodes and increase the number of nodes
so lets have everything black if you have everything black then this becomes a complete binary tree of height h or my red black tree because why because all the external nodes have to be at the same level now 

if they have to be at the same level all the external node then it  will become a complete binary tree of height h 
if I have a complete binary tree of height h then the number of nodes in that tree is two to the h minus one 
so the smallest number of nodes is possible in a red black tree of height of black height h is two to the h minus one 
when is the number of nodes the largest 
when would be have [noise:student] when every black node has two red children two red children 
but red node cannot have any red children right 
so then it will have to black children which will have to red children and so on 	
we will have to alternate layers of black and red 
so we start with the black then we have red layer the we have black layer then red layer and so on 
if the number of black layer is h then the number of red layer is also h right 
so total height of the tree  become two h and so number of nodes in the tree becomes two to the h two h minus one which is about four to the h minus which is four to the h minus one ya 
so this implies that h lies of n between log of n to the base four and log of n to the base two just plus one minus one you can figure out right 
so if I give you red black tree on n nodes 
so I just turn thing around then if I give you red black tree on n nodes then its height its at least login to the base four and at most login to the base two right 
and we had an exactly we see exactly of the same property for two four trees right

we said its minimum height is login to the base four and maximum height is login to the base two 
the same kind of the thing is happening here 
is everyone with me okay
so now you can immediately see that you know if I give you red black tree then to search in that tree will take how much time now 
login 
why
because it is first remember its binary search tree 
so it has the search property 

so I can do the search in this regular way that is start from the root compare key with the root go left or right and so on right and on
so I can do my search and the time taken for the search is just the height of the tree and the height is no more then login base two 
so that s that s the (timatic ) 11:55
now lets look at the correspondence between red black trees and two four trees 
so in particular I am going to say(Refer slide time 12:00) that given in a red black tree I can converted in to a two four tree okay


so what are we going to do 
we are going to take a black node 
that black node how many red children will it have 
will it s a binary tree right 
so it might have both its children could be black 
one child could be red the other could be black or both could be red both could be black both could be  red one could be red one could be black 	or both you know you could have external node also one could be external node but in any case the number of red nodes cannot exit two 

it will  be zero one or two right
so we are going to take this black node and its red children and combine them in to one node right 
now how many keys there will become in this one node at most three 
when 
when both at v when this node had two red children 
yes
this is clear to everyone 
lets see 
so just to make sure 

so what I am saying I am saying we have a black node and we look at its red children 
suppose it had two red children right 
so I am going to combine it in to one node all these three I combine in to one node 
so these one node will have three children 
suppose it had only one red child right and then it would be two keys in here and if it had no red child then there will be only one key in it okay
so each node so formed has at least one and at most three keys 
further more black height of all the external node is the same 
so the resulting two four so in the two four tree in all leaves will be the same will be at the same level and this might has not two make sense 

what are we saying 
black height of the all external node is the same 
so if  I start from the external node and go up the tree the number of black nodes are encounted would be the same no matter which leaf I started from and how many nodes so each of those black nodes is now part of a unique two four node two four node ya because took a black node and took its red children and I combine in to one

so each of a black node is a part of a unique two four tree nodes 
unique node of a two four tree so as I consequence when I start from a leaf and I go up to the root in count to the same number of nodes in a two four tree which means that all the leafs are in the same level of the node right 
we will show an example which this will become clear 
so this is my (Refer slide time 17:23) red black tree right 



I am going to converted in to a two four tree 
so I start with the root node I will look at its red children it has two red children right all of this will combine in to single node right of my two four tree great 
now I am going to look at another black node which is this look at its red children 
it has again three red children two red children so all of this combine in to one right and the combine in to one like this right okay 
now why is this so as you can see these combine in to one these four links that I am going out of this combination will be the four links going out of these node ya 
when I took this entire thing let me go up there are four one two three four children of this of this combine structure right 
they would be the four children of this node right 
so this is the first one 

then I look at this how many red children doesn t have 
only one 
so they would combine in to one 
so I get another node which is five seven this we comes a second child right as you can see this is more then four so this will be more then four here right and what will be my third child it would be just this black node it is no red children 

so I create a node and eleven in it and the fourth one nineteen and seventeen 
so I create another node just seventeen and nineteen 
so this is the two four tree I get right 
now you can see the black height was two 
it was the same for the every external that was the black tree and I get two four tree of height two ya

so I am giving a proof of my example but this should be clear why you know why I will get the two four tree 
so the property of a two four tree one critical property of the two four tree is all leaves are that same level right just saying that every node has two three or four children doesn t make it a two four tree 
All leaves have to be same level and that is in showed because of fact that the black depth of every external is the same 
this is clear right 

so this is how we can obtain the two four tree from a red black tree (refer slide time 18:29)


We can also go the other way that is given a two four tree you can make a red black tree 
so what are we going to do we are going to take a node of a two four tree replace it with one black node and then appropriate number of red nodes what do you mean by appropriate number if they were if they were two keys is in the two four tree nodes then I will have one red node 

if there were three keys then will have two red nodes 
If there was only one key then I will have no red nodes and these red nodes will be children of the black node 
so first I put down the black node then I put the appropriate number of red nodes right
now this ensures that I will not have the double red problem 
why 

I will not create one red node has child of another red node 
because what am i doing I am first taking a node of my two four tree first putting down a black node and then putting one zero one or the red children right and when then I taking a next node of a two four tree which is the child of the previous one 

then once again I will first put down the black node right 
so its not have two reds consceutely happening that we will see in the example shortly 
further more whats going to happen is that for every red every node of the two four tree I am putting in one black node right 
So since all the leaves of the two four tree are in the same level ya 
the black height of the resulting red black tree would be uniform the black depths of all the leaves would be the same okay
so lets take an example (Refer slide time 21:52)ignore this for now 



it should come later this is my two four tree right 
as you can see each has node one two word three keys which means two three of four children and the height of the tree is three 
okay
lets see 
i will go so lets see this is a first node which I convert in to a so there is a only one key here 

so I will just create a black node and nothing else no red nodes 
let me take this one so I will create a one black node and it will have two children two red children right what should be key in the black node b eight three and ten means two children ya
then I take this one eighteen just one black node eighteen no red children 
Let me take one two so this would have one black node and one red node right 

I have an option I might put one as the black and two as the red call the other way round right 
so I am going to put two as the black and one is the red right 
four five six 
five will be the black and four six will be the red for nine black nine anything else here twelve black lets say and eleven red fourteen fifteen fifteen black fourteen red and twenty twenty 
so now can you are you convince that you will not have double red problem right by the way just doing things when I take a node and I create some thing in the red black tree or first put down the black node and only then I put down the red node 
so at the next level I will in first I put down the black node
so it will never have two consecutive reds further more the black height of this red black trees 
So if I have to draw the external nodes and count their ancestors so if suppose there is an external node here it  has three black ancestors which is same as the height of the red black tree 

because of that all of them would have same same black depth right if I have look at the this external node which is here then it has black depths of three 
every one would have the same right
because you know if it is going from here to here then it is corresponds to going from here to here 
because each of those black nodes is one level here you understand this one 
so the black height is same as the height of the two four tree 
everyone with me 
so you understand what red black trees are and you understand how they are related to two four tree 

basically there is one to one corresponds 
given any two four tree I can create a red black tree given in a red black I can create a two four tree right
so in fact the operation of insertion and deletion in a red black tree or exactly the same as you do in a two four tree right
so we just going to mimic those operation in this setting right and that was one of the major reason for reading for doing the two four tree 
so we are going to mimic the operation but of course it will require you know do it carefully to understand the 
so I am going to look at the operation of deletion because this is the slightly more tricky operation(Refer slide time 28:22)



so lets so how do we delete in a binary search tree right
so the first the first up the deletion is the same as the binary search tree which is let we first search for the node you are in to five other node is if the node is a leaf then you just deleted right 
if the node is a internal node then you find it successor or predecessor swap and then you delete the successor or predecessor
so now the successor or predecessor suppose we are talking about successor so successor is a node which does not have a right child 
yes 

if does not have a right child then that means we would have its right child its an external node right we put an external node there right
so that means the node that I am deleting ya is always the parent of some external node 
if its leaf even then its parent of an external node ya
otherwise its doesn t have a right child if you talking of a successor if its doesn t have a right child we put in an external node 
so its always parent of an external node right
so these are the three settings we could have of that node that we are deleting these two correspondence to being a leaf right

so either node is a leaf either the node is a leaf if there is red leaf or black leaf and the third setting is when node that we are deleting does not have a right child 
so it does not have a right child right 
so it does not have a right child which means right child is an external node it does not have a right child but has a left child then the left child this left child has to be red 
why
 if it were to be black then black could not be remain consistence yes why because if I look at these external node verses this external node this if you follow what I am saying 
if this were black right then if this node has ten black ancestors then this one would have eleven black ancestor 
why

because all its black ancestor are also ancestor of this guy and this has one more ancestor 
this has to be red therefore right
If this is red then it cannot have any red children 
but it cannot have any black children either 
because if it had black children then once again it could have a same problem of black height of the same 
so this is the entire structure that we would have 
if this is the node that I am trying to delete and it did not have a right child and it was not a leaf either then that means that its right child is an external node we said that already its left child will be a red node which would  be a leaf 

so then in this case the node that we are deleting is really parent of a leaf node 
in this case the node we are deleting in each case we are deleting the node here right
In these two cases the node we are deleting or leaf node themselves and these case parent of a leaf node 
ya 
yes 
[noise:student]
nineteen 

if nineteen is a red node can nineteen be a red node and seventeen in a black node black height would not be the same 
he is saying suppose this is red and this is black this is red and this is red cannot be a red double red problem 
this is red and this is black [noise:hindi] right
okay 
sorry right
so now this is a easy case to handle if I am trying to delete this node what should I do 
its leaf just deleted nothing to be done right 
it cannot create double red problem if I delete this that was I am done just delete just replace this entire thing we just external node ya 
it cannot create a double red problem and it cannot also change as the black height of any node right because its red node after all 
similarly in this case this case is also easy 
why 
what will I do I am trying to delete this swap as an I am trying to delete this nineteen 

so what should I do
seventeen can move there and this entire can be removed ya
so I am not create a double red problem [noise:hindi]
before right and this has earlier ten black ancestors it still has ten black ancestors right and this node also has same number of black ancestor 
to the only tricky case is this one really ya 
by the way what do these two cases corresponds to in the case of two four tree 
this and this 

what are we deleting 
we are deleting in the key that we are removing is from a leaf always in a two four tree and this correponse to the case when the key that we are removing is part of node which has at least two keys 
yes
that we are removing the key that we are removing is in a node which has two keys and that was the very simple case there right you remember if I had a if I had this was my two four tree(Refer slide time 31:25) node and this had keys lets say three five three and five and I was trying to remove five or three its very simple operation 



nothing needs to be done and this case as well as this case both of them corresponds to this 
height is this corresponds to this 
this is the node right even here this has to have a black parent and so this is the node then corresponding node in the two four tree and this is a corresponding node it might be even larger actually it might have three keys this might also be red right [noise:hindi]
this how ever is a tricky case 
this corresponds to a single key in a two four tree node ya 
so in the two four tree node when I if I remove this key then the node becomes empty 
that s a problem and here this would come change in the black height 
right

so hence we can assume that the door deleted is a black leaf that is this is the only case which is really interesting for us and we removing this reduces the black depth of an external node by one and so in general we are going to assume the following we are going to look at the following steps right
that there is some sub tree whose black height is reduced by one okay and we want to re organize the tree to take care of that right 

why I am saying sub tree (Refer slide time 31:25) where this is a sub tree right what is going to  happen is that as we do reorganizing this tree could become larger and larger right 
this is a black height [noise:hindi] and we will see that okay
so this going to be a fairly (refer slide time 34:44) its going to have a bunch of cases procedure right 



so let me assume that this is a tree [noise:hindi] black height because of the deletion once [noise:hindi]
so what I am going to do I am going to look at the parent 
so this is the tree [noise:hindi]root has sub tree I am going to look at its parent the parent is lets say [noise:hindi]
so first I will check whether a is a black or a is red (Refer slide time 34:44)right depending upon this I will have two different cases happening 
so if a is red 
so this is a picture 
so what about the other child of a 
it has to be black right lets says b right lets look at the two children of b 
lets call them c right 

you do not know whether they are black or red 
a is just name for this node nothing else 
this is the this is the tree whose black height is reduced by one the sub tree I am just looking at the root of the sub tree and its parent 
so a is the parent [noise:student]
ya right right 
so let me just clarify this point 
so what you are saying is we are interested in when we are deleting this black node which has two external nodes right and this has some parents some where

when I delete this this entire thing I replace it will one external node here 
so essentially this sub tree 
this is a sub tree right this node and its two external node children [noise:hindi] 
it is getting replaced by this is black height zero [noise:hindi]
the problem y have to formulate this way is that this is going to you know in some cases what is going to happen is  this going to expand this tree okay
as we see the so just take this one now and we will see [noise:hindi] if you are confused then just think of this has the single node right with two children like this picture you can think of this blue drawing less that right its black height reduced by one okay 
so this is one possibility if this is red and this child is black and we do not know what its two children colored the other is that if this is black a is black then b could be red or black right 

so depending upon what the color b is will have different cases here we can depending upon what the color of c will have different cases 
so these are two cases either both both of these are black okay (Refer slide time 37:30)



that could be one case 
so I have not shown the black I am just showing you what the various cases are then we are going to handle these cases separately one after the other 
so one case when both of these are black 
the other cases when one of these is red right 
so this is lets see red and these is one case for us 
these is just part of the tree right 

there would be a left sub tree here there would be some sub tree is hanging here and so on and of course this will have something this will have a parent and more happening here( )
this is the case when both are black so I am not shown them here but will this will be another case okay
lets comes here 
now depending upon what b is will have two case red or black right
so b is red then this is the red node then it will have a right child which is black 
so right child cannot be a red right and this will be black and now I am going to look at two children depending upon what the two children are right I am going to have two more cases the other option is when b is black in which case will have two children and depending upon what the two children are once again we will have two  cases right
so here there is one case when one of this two is red 

so that is the case like this and the other is when both of them are black which means I will just look at the scan structure 
similarly here 
there would be one case when both of them are black and when one of them is red sorry 
one of them is red then I will have this and when both are black are have this 
so this manner this is just kind of a starting picture to show you that there will be six cases that we are be looking at and we will see what the tree organization re organization to be done right 
so I am going to refer this as a case one point one one point two this will be two point one point one so did you understand what them 37:54
so this is the first case we are going to look at right 
so this is what the picture would be 

so a b c and  basically a b c(Refer slide time 39:53) yes and this is the tree 



sub tree whose height is gone from h to h minus one let see 
the black height is gone from h to h minus one 
now what will be the black height 
so all these heights are black heights what is the black height of this sub tree 
I have written is h minus one 
why is it h minus one [noise:student]
earlier this had black height of h what should be the black height of this h minus one because there is one black node here already ya
so this will have the black height of h minus one similarly this will have black height of h minus one this will have the black height of h minus one right and these is if a node is red then both a children have to be black 
red node cannot have a red child simple 
red node cannot have a red child 

it s a double red problem right 
the other possibilities c is the left child of b right 
so its symmetric thing ya
now how are we going to reorganize this tree we are going to reorganize this tree in this manner 
so its basically a rotation right b goes to the top a c goes here a comes there and these have not label these thing but you can understand two three four one two three four this order will set there

we will see in this kind of reorganization when you are taking of AVL trees right
no what does this correspond in the case of a two four tree 
lets look at it okay 
so what this corresponds to this picture is basically that this node was empty that s why the height went down 
in the parent node I have an a and it is red which means the parent node the parent node in the two four tree has at lest two keys [noise:hindi] 
this will be always black okay [noise:hindi]
why is this rotation [noise:student]
student:c is greater then b 
okay so you are right perhaps 
so you are saying a is here [noise:hindi]	
so it will become a c and b right 
thank you
so its basically okay 
so ignore this one its for this one this picture right 
now lets see what the corresponds to in the case of two four tree 
because you know that s were all of this motivation is coming from so this is a red node which means its parent is a black so when I had created the two four tree node I would have at least two keys in the two four need tree node corresponding to this guy 
at least two may be three but at least two ya
so that is this one so it could be either two or three I put the a here 
now in the two four tree node corresponding to this guy actually I took this one 

so I would have b and I would have c ya 
I would have b and I would have c 
so I would have b and c may be there is another key and this guy was red may be right 
so this is what the picture is and then what to we do in the case of a two four tree well I have a problem because I don t have key in this node what do I do I borrow from my sibling my sibling can lend me because it has at least two keys right 

so it is going to lend me one 
so one of the key is going to go up from here to here and one is going to come down from here to here ya okay 
so that s exactly what is happening 
so [noise:hindi]one goes up lets say the b goes up c remains here 
so ya when I am looking at b c ya so I that this is corresponds to this yes okay so let me correct this in a second 
so what we are saying suppose we were to keep this one in picture 
so lets remove this one now okay and then this should be c and this should be b yes 

now its okay 
so lets keep this in mind okay now whats going to happen we have and we have b here 
so which is one which is going to go up c right and a is going to come down 
so the new node that i get here I would have only one key a in node that I have here c is not going to be there and in this node a will get replaced by the c 


in this node a is the only key which means a is black 
in this node um b is one of the key and if there were one other key here either b is only key in this node or if there was one other key here then it is already sitting here we don t have to worry about that 
so b becomes the black node right and this c why should c be a red node because there are more keys here 
so c can continue to be a red 
so this is just for motivation but if you have look at this 
this is good enough 
we have taken care of the height problem I this is my new re coloring this was red this is also red 
so they cannot be a double red problem 
why
because there is a double red problem if the parent is red right
but the parent is not red 

if the parent is red then there is a double red 
but the parent is red then the parent is this was also red which means there was already a double red problem right so this cannot so this is no double red problem lets check the height business 
so this is height black height is h minus one and now what is the new black height of this sub tree now 
so for all these external node it will be h all of this also it will be h for all this will be h for this it will be h the black height is h 
what was the black height of these guy 
h minus one plus one h minus one plus one h minus one plus one and this was h to begin with [noise:hindi]
so the problem is taken care of right 
you don t have you not introduced double red and the black height has been restored okay 

so that was what case was that 
so that was very first case right 
let me just show you so it was this one(Refer slide time 37:30) 
this case here 
so we have to go through this one ( )
so we quickly now start going thorugh them(Refer slide time 39:53)
so this is one parent is a red node 
so this is what is red 
so parent by parent I mean this is a sub tree whose height is decreased I am looking at the parent of this root it s a red node it has a child if it has it has a child which is black then black child has then black this has the red child then this what we do
so the other thing is when does not have any red child b does not have any red child that would be in a second case so lets look at that (Refer slide 47:55)



so b has no red child 
in this case the picture is a b and both of this sub tree have as the root black children right 
now what so this went from the h to h minus one 
so this has to have a black height of h minus one and this is also have a black height of h minus one right why because originally black height of entire tree was h ya 

so this must be h minus one this must be h minus one right
now what are we going to do level this just the (shop) of coloring just the re coloring solve the problem 
because I make this red and make this black ya 
what is the black height of the resulting tree now h right which is what the original height was why this is was not introduce the double red [noise:student] 
I made this red no this could be a red ya that s why we taken care of the other case first 
now you understand 
if any one of these where red [noise:hindi] and what does this corresponds to for our two four tree picture well this is the node [noise:hindi] right 
this is the only key in this node sitting all alone right and then what do we do 
if this goes up then this guy becomes empty 
so what do we do then merge 
these two combine in to one single node and one key comes down from the above yes 
so what will the new node the key is in the new node b b from here a from here which comes down from the above 
so this new node is going to have b a which is what is being done here this new node has b a in it 
this will be one node now right 
I take a black and look at all its red children this will be one node with be a in it right 

so this is one to one corresponding between what we did in the case of two four tree and what we are doing here right and that helps to clear things on 
so we are looked at both the cases when this guy when the parent was the red if then the parent was the red then we know this is a black 
if this had any red children we have taken care of it in previous case 
if this has no red children then we taken care of it now 
so now we go to the red next set of cases when this parent is a black right 
so parent is a black node (Refer slide time 52:54)




if parent is a black node then this could be a red or could be a black 
so first considering the case that the it has the red child b 
if this is red then this has to be black ya and if this is black then this may be red may not be red 

now again some two condition I am making some two assumption making of this is red first and that this is red 
in the next case I am going to consider this was not red this was black and this was black this node had no red children right and you see why this is required right you already seen one reason why to consider whether node has red child or not 

so this is a picture 
this height went down from h to h minus one 
so what is the black height of this tree this entire black height that means was originally h plus one [noise:hindi]
the first lets say make sure that the this is correct and then we will see why we came up with this and why we came with this justify by our two four tree right okay 
so lets just check it is correct 
so first well you can see here that b is less then a 
b is on the left c well 

c lies between c is more then b less then a so c lies between b and a d is more then b but less then c so d is more then b and less then c 
so search property is okay and one two three four five one two three four five I just organize as before right they just go in a same manner 
now this one is a this one right 
it has now black  height of h minus one 
this guy is this its black height of h minus one and this one is a very first one its black height of a h 
so now if you look at the black height of the external the black depth of the external node so these guys will have black depth of h plus one this will have h minus one plus one plus one h plus one h minus one plus one plus one h minus one plus one plus one 

so the black height black depth of all the external nodes are the same 
so the that thing is taken care of and for as a double red problem is concern the only thing could be that well this is red [noise:hindi] 
it was only a red black tree and it had only made changes in the this sub tree right

so this is a valid thing and in takes care of the problem okay now where is this coming from what is the motivation well again this was an empty node this corresponds to an empty node this this is my root this is a parent node this has a and this has red child so it means the two keys a and b right and this has one child here which has two keys c and d 
so that s what happening here right this corresponds to this node and a b corresponds to parent node and what happens now I can because my sibling has n of keys it will lend  me one 
so one of the key is go up and a would come down lets see right which is the key which is go up the largest one 

c would go up and a would come down this is the picture would have b c d a and what is this corresponds to this corresponds to exactly this b c here corresponding to this node a this one and d this one ya
so everything is coming from the two four tree ( )
what would you have done in this case 
this is direct one to one correspondence you just use this thing to decide what to do here 

so what is the case we consider here that this is black we also consider the case when this parent was the red and then we made the assumption that it has the red child then this has to have the black child and we made the assumption this is red 
so now we will get red of the last assumption that this is red that means this guy has no red child c has no red child which means both of these are black 
so we come to that key(Refer slide time 56:03)



c has no red child right and so this is the picture 
so this are two sub tree both of whose two root are black right and so this has to have black height of a h minus one 

because the entire black height was h plus one begin with same as before [noise:hindi]
right and we will see the motivation once again coming from the two four tree 
though once again c is between b and a 
so b here ya 
a is lager then b c is more then b but less then a 
so binary search tree property is okay and the same t one t two t three t four [noise:hindi] t one t two t three t four[noise:hindi] black height check [noise:hindi]
black depth [noise:hindi]

double red problem [noise:hindi] 
these are both black [noise:hindi]
where is this coming from once again 
well this is the node which is getting empty 
the parent has a and b in it and then this has one this has one child which has only c in it because both of its children s are black 
so now once again we cannot borrow we have to merge and merge may c [noise:hindi]

which corresponds to this[noise:hindi]
(tired) um we have two more cases to go 
so c has no red child 
now what is the case left 
we started assumption that the b is red 
so now we need work with assumption that b  is black ya 
that was assumption b is red 
so we come to b is black  [noise:hindi]
this is the node we are talking of this is black (Refer slide time 58:07)



so now again the next case then it has a red child and one possibility and the other is does not have a red child 
so if it have a red child lets say this is a red [noise:hindi]
d is between c and a 

so d is between c and a 
where is it coming from very simple this is empty 
a does not have any red child which means its only key in its node and this has a red child and that child so that means there are two here 
so once again it is going to borrow one from here 
so d is going to go up a is going to come down and will have this picture 
so d is the only key in its parent this may or may not be the only key in its node 

because this could also be a red ya 
but we are not bother about this [noise:hindi]
but this only be the one key its node [noise] 
because this node was earlier empty [noise:hindi]
c does not have the red child at all 
a c c no red child(Refer slide time 1:00:00) [noise:hindi]



right 
so now what we do we have to do [noise:hindi]
h minus one plus one h [noise:hindi]
i worked with the assumption that this is the sub tree [noise:hindi] black [noise:hindi] 
what case this correspond to this has only one single key this neighbor also has only one single key
 
so you kind of combine both of them they come here and the neighbor becomes empty sorry 
the parents becomes empty so the parents becomes empty so you have to them repeat the process for two four tree deletion in the parent which means its either has to borrow from one of its siblings or it has to merge with one of its sibling and all of that 
so there was the same kind of thing happening in the case of two four trees there 

that the process continued up right the deletion process in other parent became empty now 
the parent node become empty so you have to do something there and may be then again the parent became empty so you have to do something there and so on and all the way up to the root in which case you reduce the height of the tree at the end of the thing 
the same thing could be happening here except that here all we are doing is re coloring a node 
[noise:hindi]
essentially one bit of information [noise:hindi]
in one of the six cases we have to go up 
but when we have to go  up we don t have to do too much work 
we just  have to do one recolor right
so that s the summary 
so in all cases except the last(Refer slide time 1:01:45) case two point two point two 



so deletion can be completed by either some reorganizing by some rotation or by some re coloring [noise:hindi]
in this particular case the height of the sub tree reduces and so we need to proceed up the tree 
but in this case we are only re coloring the node [noise:hindi]
so what is happening is why is this is a fast procedure 
because you have to do essentially one rotation only [noise:hindi]
its  a very short 
so which is what makes the process really first 
except for the last case in all case the height preserving [noise:student]
[noise:hindi]

you have to check that [noise:hindi]
you have to check this last thing if you have to convince 	
but this is this is entire process of deletion 
next class we are going to look at the process of insertion its much simpler then this 
so this was the harder one right
but keep in mind you don t have to remember it if you remember the two four tree which was much simpler to understand conceptually right 
if you remember that you will also be able to remember this process 

Inserion in Red Black Trees (Time 01:09 min)
In the last class we saw what a red black tree was we saw the correspondence of red black trees and two four trees then we saw the deletion process (Refer slide time 01:20) in red black trees 
so this was the extensive process six cases and so on
today we are going to see how to insert the key in the red black tree with then also going to introduce the notion of an ab tree 
so first define the what an ab tree is then we are going to see the process of insertion and deletion in ab tree(refer slide time 01:40)



so we get to insertion 
so suppose we are trying to insert a key k in to red black tree 
so after all red black tree is a binary is a binary search tree 
so its binary search tree 
so first insertion process would be as is in the case of binary search which means that we would try to find whether the key already exist in the tree 
if its exist then we would not insert it 
right 

if it we does not then we are able to identify the place whether the key has to be inserted we create a node with that key we put it at that location and now we have to color this node right 
because after all red black tree differs from the binary search tree in the fact that each node is colored and this color is obeys certain properties
so now we color this node and we are going to begin by coloring this node red (Refer slide time 02:31) okay 



so lets say this is the node that i inserted ya 
this has the key k in it 
so which means that i must have come in my binary search tree i must have come up to this node gone right because k was larger then this key and found that this was an external node right 
earlier in the binary search tree this was an external node now 
so i decide to put my node here and i color it red and i will create two external nodes which will be the children of this node 

if the parent of this node is black then we have no problem right 
because this node is colored red the black height of the tree has not changed 
the black height of these external nodes is the same as the black height of the external node which was sitting earlier at this location and which was the same as the black height of the other external node in the tree which means that the black height of these two external nodes is the same as the black height of the all the other external nodes 
so that property of the red black tree continuous to hold that s primarily because we have introduce a red node and not a black node ya 

so the property that the black depth of the black height of all the external node should be the same continuous to hold 
the problem could how ever be one of what is called double red right and that happens if the parent of this node is red as is in the picture here right
so this is the node i created if its parent is red then we have the double red problem and we have to handle this problem right
so remember that in the case of deletion the problem was raising because the black height was changing and we were you know all along we were trying to take care of that problem we never en counter in a double red problem in the case of deletion 
in the case of insertion how ever we will never have the problem of black heights not being uniform 

the black height of all the external node will be the same 
no problem that front but the problem will be one of a double red okay 
so we have a double red problem lets see how to take care of this problem now 
so this is the node(Refer slide time 04:54) that i am inserting 
so just concentrate on this picture for now 
this is the node i am inserting 
this is k right 



in the previous picture i shown that its two children where external nodes
now i am just replace that by sub trees and you will see what is the reason for this is in a short while and now we have been would have a problem double red problem if the parent of this external of this node that we inserted is red 
so this parent which is node a  is colored red okay
now clearly the parent of this must be a black 

if the parent of this node was red then there was already a double red problem in my tree 
so this must be a black and the first case i am considering is when its other child is black which means that the sibling 
so this is the node that i am inserting its sibling its parent sibling is black that s the case i am considering 

its parent sibling is black ya and what do we do in this case 
we just do the simple rotation right note that a is larger then b and a is smaller then k 
so i can put a in the middle b on the left and k on the right and i get the this kind of the tree now ya
a will be colored black b and k would be colored red 
what is the black height of this tree now 

the black height of this tree is same as the black height of this 
if you are took any external node here its black height was whatever was black height of this plus one and for those height its still the same whatever the black height of these pieces plus one 
node that black height of all of this node would black height of all of this is the same 
suppose the black height of this is h 

the black height of this should also be h this should be h plus one 
this should be h plus one and this should h plus one 
so i can actually i just make sure that s you understand what s happening here just put down the black heights 
suppose its h its h then this will be h plus one h plus one and h plus one and so when i am writing down this should be h this  should be h this should be h plus one h plus one and h plus one right

and now you can see that the black height of all the black depth of all the external nodes so anything here it will be h plus one plus one h plus two h plus one plus one h plus two
this h plus one plus one h plus two 
so black height problem is the black height problem is not there at all its uniform 

now only (Refer slide time 07:48) thing we have to worry about whether is transformation we have introduced new double red problem and we have not we would have introduced new double red problem either this was this was  red or this was red or this was red that is the root of any one of these tree sub tree was red 


but if the root any one these tree sub tree was red then that means we have an double red problem we had two double red problem and not one double red problem ya we had if this was red the this is also red this is also double red problem this is red this is red this is also red 

so we have more then one double red problem right
but we have introduced only one double red problem by inserting that node ya 
so this cannot happen [student:noise]
in this case we are inserting k
right so for now just we assume that these are external noses okay and we will i will in the next slide i will come to why i have drawn this two sub trees here right 
you will see that shortly okay
now what is this correspondence to if you know if i have to think of this as a two four tree if i have to think of is two four tree then that means that i have a node which has these three keys in it right it had earlier b and a in it keys b and a 
this was another node ya 

this had b and a in it (Refer slide timem09:56)and then i am bringing in k and so it can be 
accommodate here without any problem ya 



this what we said 
but we are getting a double red problem 
why is that 
well its because you know this is not form in a right manner if i had three keys in a two four node then the middle key is the one which is to be set black right while it is not getting done here 
so just that simple rotation takes care of 
so its not we have changing the two four tree in the any manner right 
this is the node corresponding the two four tree these three goes together in to one two four tree these three nodes still go together in the same to node of the two four tree yes as the same as before 

if just that we are reorganizing it 
so that it is now in the form of our red black tree okay
so that was that was one case when the parent of this guy inserted node has the sibling which is black 
so the other cases this is red right and we will look at that now 
so these is second case (Refer slide time 12:26)the parent of the inserted node a is red and the other child of b is also red okay and we have this double red problem and we need to take care of this okay



what should i do now 
can i do what i did on the previous slide 
why not 
because then i would get double red problem on the other side right [noise:student]

right so what is happening good 
so what he is suggesting is that in the if i look at what is happening in the two four tree so that means that in the two four tree this is the corresponding node of the two four tree recall how do i get the node of two four tree i take a black and took at all its red children 
so this is the corresponding node 
so it already has c b and a in it and i am trying to bring in k in to this clearly there is no space 
so what do we do 
split it 

split it in to two right 
so that s exactly what we are going to see here 
this is what the transformation we are going to do 
no transformation really but we just recolor the nodes and this corresponds to as split and lets see why right
so this is the transformation i have done 
i have colored this black colored this black right 
so this the picture was c b a as sitting in one node and k is trying to come in and how do we split we split with c b on one side a k on the other side and then b goes up 
right 
so b goes up c on the one side and a k on the other side
since c on one side that corresponds to a single black node 
a k on the other side corresponds to a and k and this goes up so this is now trying to go up go up to the parent okay
does this take care of all problems okay
so there are two things issues 
first does it take care of so have we created a black height problem 
no right 

so lets say what should black height initial black height of all these sub trees b let say they would oops(Refer slide time 14:37)



so if they were all if this was h then they would all be h and the black height of these entire sub tree would be h plus one 
right which means these are all h and now the black height of these entire sub tree is h plus one 
so no problem its as it was before 
but now i have a red here and its parent could have been in a red 
so i have a double red problem right 
so this is the same thing 

but now what we have manage to do 
we have manage to do move the double red problem up one level up 
right and now you see why i had these sub tree hanging out of here when these moves one level up these will be one sub tree hanging from here and this would be the other sub tree hanging from here right
so these is the these is the continuation of the parent(Refer slide time 14:53) of b could also be red and that case the double red problem moves up one level right 



so we will repeat the process of the next level 
so we will consider the two cases right 
if we can be the rotation take care of it we would take care of it if not then the double red problem will move even one level up and so on and on 
right 
eventually what will happen 
we will end up the coloring the root which was originally black remember in a red black tree 

we will end up coloring it red 
but if the root is colored red now everything else is okay right that is the root is colored red 
so how do i take care of it color it black 
this color is black again 
so what will that do that will increase the black depth of all the external nodes by one 
but it remains the same 
we are not saying that black depth of the all the external node should remain the same 
we just say it will remain uniform 

the black depth of the one external node and the other external should be the same and if i color the root black it just you know it will effect the all the external nodes by one 
so that will be no problem right
so these essentially corresponds to moving all the way up and splitting the root when we split the root in the case of two four tree even then the height of two four tree went up by one and so we are seeing that the corresponds the height of the red black tree is corresponding increasing by one when we do a such thing 


is it clear to every one right 
so again(Refer slide time 16:31) what we have seen in this insertion process is that either 



we have to do one rotation to take care of the problem and if we could not take care of the problem by one rotation then we have move the problem up to the next level 
but when we move the problem up to the next level we just did a re coloring of the nodes ya 
lets see when we move the problem up to the next level in this case all i did was change the reds to black and change the black to red right and now its moved up to the next high level and may be if it has to moved up to the further heigher level it will just do corresponds to re coloring of nodes ya [noise:student]
student:the parent is also red 
staff: right 

student:the other child of the black 
staff:then the other child must be black
student:because every red child of the child is black so we finished either one step or two step because its gets the case one then 
staff: is that true okay [noise:student]
lets see he has very interesting question here let me just check so what he saying is lets confirm this 
so he is saying suppose the parent of this was red right then you are saying the other child of these guy has to be black it cannot be red clearly other wise there was already a double red problem right 

so now we have a no but its not these that we have worried  about 
its basically these guy we are worried about 
whether these is red or these is black [noise:student]
so where will we end up eventually right [noise:student]
so its not these guy we are worried about 
please remember right 

if we look at the previous case we looked at the parent nodes sibling whether it is red or black and so it is these node whose color we are worried about this node can be still red or black 
okay right 
so insertion what is happening is we just have to do one rotation right and if we move up the tree we just have to do re coloring the same was happening in the case of deletion also and i had mention these very clearly right

if we move up we just doing  some re coloring 
its one rotation the movement we do the rotation the process its other wise it just re coloring right and these is what it takes it makes the process very fast because re coloring is just one bit of information really in each node you just read one way one or zero we will just tell you whether it is red or black 
you just need to quickly change thse bit if you are moving up the tree and then the movement we do a rotation

rotation is slightly more expensive 
because it require some point to change six seven point have to be change ya and these is why its red black tree is faster insertion and deletion in red black tree is faster then in the case of AVL trees
in AVL trees re call  that we have to do more then one rotation 
we did the rotation then we moved up perhaps you have to do another rotation and so on and on right

so although the time is in the both of the data structure the worst case time for insertion and deletion is log in because even there you were doing login rotations right but that constant behind that login or much larger in the case of AVL tree then in the case of the red black tree right

so even with in these login these would be a faster process both insertion and deletion then in the case of a AVL tree 
is everyone with me okay (Refer slide time 16:31) 
so that s all we wanted to we are going to discuss about red black trees 
so we looked at search insert delete all of them take login time right you know you can also think of other operation like if i say find minimum element in a  red black tree 
how much time do you think its going to take right
minimum means its just keep going left
so time is height 
height is login you just that login right 
maximum element all of those we can do it in login time successor you know you can do all such kind of operations in login time 
most of those operations are not changing the tree 

so its much easier low
two operation we  change the tree or insert and delete but we seen that you can still take care of them in a login time
so now come to this notions of ab trees and this is a generalization of our idea of two four trees right 

so (refer slide time 23:49) what is in ab tree 



so i have drawn i have drawn in ab tree here and actually this is the same picture that i used for the two four tree if you remember 
so an ab tree first of all is a multi way search tree
each node now has at least a and at most b children right 

so when a is two and b is four then you get two four tree 
at least a and at most b children 
so if it has at least a children and at most b children then how many keys are there inside [noise:student]
how many keys are there in side a minus two b minus one 



what do you mean b minus a plus one 
if it has a children right (Refer slide time 23:49)if it has a children then it has a minus one keys if it has b children it has b minus one keys 
so the number of keys is between a minus one and  b minus one 
right 
i did a something else 
now one nodes which doesn t satisfy the properties root node 
the root node can have only two children right
so you know if a is three or seven or some such things then its not the root also has to have at least three children or seven children 

root is out of this definition 
so root can have only two children 
so root has at least two and at most b children 
so for the root the requirement is from two to b [noise:hindi]and we will see what is the need for this again all leaf nodes are at the same level and the height 
so what is the height of ab tree now right (Refer slide time 23:49)
so we will seen this before login to the base b is the minimum height and login to the base a is the maximum height 
minimum could be actually you can context this to the little bit because the root has the only two children right 

so the maximum height would be when the root has two children every one else is the a children 
so there would be a plus one here perhaps the some such thing right 
but this would be the roughly the bounds okay and these is in the example of two three tree event as you can see every node has at least two and at most three children ya 
so this is in the example of two three tree
so we can talk of two three tree is we can talk of two four tree we can talk of two five trees and so on and on for any choice of a and b 

i have to i will correct the statement as this discussion proceeds not any choice of a and b we will see what are our requirements on the relation between a and b right 
this will not work on any choice of a and b 
but for now we will just assume any choice of a and b 
insertion so as you can imagine(Refer slide time 24:59) these is going to be essentially a repeation of what we did for two four trees and it is right 



its small modification right 
so now i am you know i am trying to insert lets say this key twenty one so what do i do is a multi way search tree i will find position where this has to go 
so twenty one between thirteen and twenty two come down more then eighteen go right and it can fit in to that problem 
so nothing to be done 
so no problem if the node has an empty space right
similarly twenty three come here go right less then twenty five 
so its comes to this space and in a node we are just keeping order 
so lets say twenty three twenty four will make way and twenty  three will come at the place right[noise]

you must seen this slides before
so why are you smiling today 
ya 
because you are seeing this for the first time okay good 
now if there is no space in the node that we are trying to put the key in node gets split right 
so lets see twenty nine twenty nine compare with twenty two more then twenty two 	 goes right more then twenty five goes right again and now its here okay by the way i should have mention that i am looking at the two three tree this picture 
we are talking of ab but i did not want to make a and b very large because it would not fit on the slide 

so i am just looking at a equal two and b equals to three [noise:hindi]and the concepts or the same [noise:student] ya that remains right [noise:student] ya that s the same
so for an ab tree the leaves all haves to be at the same height as in the case of two four tree right 
so these is essentially two three tree 
so now this raise to basically two three tree means each node has between two and three children which means that each node can have one key or two keys only which is why each of those has been made with space for two keys 
each put have one key or two key yes okay

so now this can have only two keys but now i am coming with another one third 
so what do i do so 
if there is in sufficient space then split the node 
i am going to split this node and the medium key is promoted to the parent 
so which one is medium of these three twenty eight so it will get promoted to the parent 

(Refer slide time 27:54)so i split twenty six goes down twenty nine goes down and twenty eight goes up ya 
these disappear and these become children of this right and what else remains 

the split can case cade and we will see the example of that so now when trying to insert seven so i will compare seven with the first key seven less and thirteen i will go left seven lies between three and eight so i go take the middle path come down seven tries to come to this node except this node it doesn t have enough space 



so this node gets split in to two four will go down  
seven will go here medium is five so it will go up okay and well nothing left here because we just remove this node we will remove it shortly 
now this is trying go in to this node right except there is no space here either right 
so once again this gets split in to two three goes here eight goes here and medium five gets promoted to the parent same as in the red black we have done anything which is different from the red black tree 
but what i am point out through this is red black tree we need not have a two four tree we could also have two three tree right in the red black tree every node has space for three keys even if had every node space for two keys we can still make it work right and so that s what happens three goes there eight there and five goes to the top

once again five is trying to enter here but there is no space for five 
so first lets just reorganize these 
these four children have to be children of these nodes two left will go here two right would go here and now lets take care of this node five try to go there not able to go so this gets split in to two and one key gets promoted to the parent except this no parent this is the root so we create a new root right and we go like that okay and now these are the four children they would have to become children of this two nodes 

so two left most go to this and two right most will go to this and new root will have to this two children okay
exactly the same thing would happen for any a b tree 
you understand what i mean by that statement what so i am trying to insert if there is space put it there if there is no space split and move the medium up 
the medium might not be unique like in the case of the two four tree there were four keys there 

so the medium could be second element or third element [noise:hindi][noise:student]
at least a children yes [noise:student]
we cant insert in to an empty node what is this statement there would be no empty node right 
so at least a children at most b children means every node has at least a minus one keys and at most b minus one keys 
so this is the property 
so we can also rephrase it in this way  
every node has at least a minus one keys and at most b minus one keys okay
if you tree had less a minus one keys in it right 
so then all of them would basically set in the root 

so these property not true for the root 
root can have as small as one key only right 
because it can have as smallest two children 
so root can have only one key 
more questions is something not clear 
so we are saying every node has at least a children and at most b children which means that every node has at least a minus one keys and at most b minus one keys 
this property of at least a children and at most b children does not apply to the root node so the root node has at least two and at most b 
so the root node has at least one key and at most b minus one keys right and now you can see why we said that this property does not apply to the root 
because when we went in this manner inserted and we wended up spliting the root node in to two  and we created the new root node then this new root and that has only two children right 

so we have to permit the root have only two children 
these is why the requirements and the root can  have as smallest two children 
if we insist the root have to have at least a children then we might not be able to do this at all [noise:hindi] okay
so lets continue 
so node is split so now we are going back to from two three trees we are going back to ab trees 

so in ab trees we said we trying to insert in a node if it has space tell him good 
nothing to be done 
we put it there right how much space doesn t ab tree node have 
space for b minus one keys right 
if it has space we will put it 
if it does not have space 
what is that mean they were already b minus one keys there and i am trying to insert one more key b th key right
then we will split in to two yes 

we will split in to two one of the keys will go up and the remaining b minus one key will get some half will go one side and half will go on other side that s exactly what is being set here and node is split and when it has exactly b keys you understand why exactly b because earlier it had b minus one i was trying to put in one more there 
so then it means it has exactly b 
one guy goes up one of these promoted to the parent and the remaining are split in to two 

so what is the remaining b minus one
b minus one is getting split in to two 
so one part gets b minus one by two rounded up and the other part get one b minus one by two rounded down yes
b minus one by two if it is an integer then both of these are the same 
if it is not an integer [noise:hindi] like in the case of two four trees four was b is four in the case of a two four tree 
so you had four minus one by two one point five which means one side was getting two keys and the other side was getting one keys 
one point five rounded up this two one point one rounded down is one one was getting two and the other one 
so one node gets this many keys of the other gets so many keys 
but after this split these two nodes are valid nodes of the key 

so it must be that our requirement that the minimum so one node is getting so many keys [noise:student]
right this should be less then sorry (refer slide time35:47)



ok this so one node is getting so many keys right which means that a minus one this quantity should be less then or equal to b minus one by two 
thank you this is an error
i will correct this this should say less then or equal to b minus one by two right 
good 
you understand why this is coming because i am i am creating a node b minus one by two keys right so which means and i have a requirement that every nod has at least a minus one keys in it
so this quantity should be greater then or equal to a minus one 
because other wise if this was less then a minus one then there would be a problem because this node that i am not creating a valid node great okay

so now lets look at the deletion right 
so deletion again as same as the case of two four tree 
so you know the simple case is when i am deleting certain node and there are more then one node in that right for instance if i have deleting twelve is nothing to be done just delete twelve and its solve okay and ( ) one key left 
but suppose i was deleting twenty 
then the problem would be that when i am removing twenty this node becomes empty and node has to have at least one key and at most two keys 
so it has to have at least one 
so what do i try to do 
if the node becomes empty then i first try to borrow a key from its sibling 

sibling of this is this i will try to borrow one from here and recall what was the way we borrow one key went up and the other this one came down right 
so that s exactly what we are going to do twenty disappears and so one fifteen goes up  and eighteen comes down right and now this is valid two three tree right 
great 
now what happens if the sibling has only one keys 
just once again right 
if the sibling for instance now suppose i was trying to delete twenty three 
so now when i try to delete twenty three twenty three goes away (Refer slide time 38:33)



i try to borrow one key from its sibling right 
this is the only sibling i can borrow from i cannot borrow from here and you remember the reason for this 
i am trying to borrow it from here 
but this has only one key 

so if i borrow from here this becomes empty 
so in this case what did we say do in this case of two four tree we merge first try to borrow if not possible then merge 
so we will merge this and this 
so we will create a new node and this will get this key and one key will come down from the parent 
twenty four will come down twenty six will come from here right and this will become the merge node and this only one key left here so it become goes to the left and these become the two children of this node ya and we also saw in this same thing continues here we also saw that this process could go append up right because what we had effectively done is we have removed one key from this node now 
but if this node had only one key then it would have become empty [noise:hindi]

if this twenty eight was not there this would have become empty 
so then we have try to borrow one from here but we cannot borrow one from here because there is only once 
so this would have merged which means this would have come down  we would have created one node eighteen twenty two which essentially means i would have deleted something from here 
but if i am deleting something from here this become empty so again it will merge and this in this manner eventually it might be that the root has to be removed and the height of the tree reduces that we have seen this example from the case of the two four tree 
same thing happening here exactly the same thing right okay

so lets continue (Refer slide time 45:36) so in an ab tree we will merge a node with sibling when will we merge a node now we were coming back to the ab tree when i merge a node with its sibling when do merge a node with its sibling that s the question right 



(noise:student)
so this node that i am merging after i merge with this so the minimum number of keys is in a node is a minus one so which means it had a minus two keys 
so i am trying to borrow one from its sibling 
but i am merging with the sibling which means that the even the sibling does not have anything to lend me which means how much does the sibling have 
the minimum number a minus one 

so if i merging the node with the sibling then that means the sibling has a minus one keys and the node itself a minus two keys yes 
so after merging the new node that gets created how many key will it have 
the some of these two plus one 
why plus one [noise:hindi]
so it will have two a minus one keys ya 
now two times a minus one better be less then b minus one 

yes so this is the same as a minus one better be less then b minus one by two 
why i have set flow
a minus one has to be a integer right 
so if a minus one is so this one is saying a minus one is less then or equal to b minus one by two and you know since a minus one is integer it has to be less then or equal to the floor of this b minus one by two 
floor means rounded down 
the symbol means if this is not an integer rounded down to the nearest integer okay
we did we see the expression before right 
this was the error right 
so this was a minus one less then or equal to b minus one by two 
if this statement was an error a minus one should be less then or equal b minus one by two 

right so we are what are we seeing we are seeing that we getting the same expression from both 
right so this is the property that you re a and b should satisfied 
a minus one should less then or equal to b minus one by two right okay 
so what is this 
lets just quickly see what this means 
so what are the values of that given the particular value of a what are the value different value b can take right 

so this you just have to look at this can again 
so b can take a value two a minus two a minus one or more 
so b should be greater then or equal to two a minus one 
both of them are telling as this 
so when a was two 
what are the values b can take 
three four and so on right 
is it okay 
so that s the thing that we need to keep in mind right
so if we have a as five then b have to be at least nine and so you cannot have a five seven tree 
this will not work
five nine trees its okay 

will that we stopped todays discussion about let me just correct myself right 
will so as a quick summary what i can said is that for insertion and deletion we saw insertion and deletion in a ab trees right and the height of an ab tree we saw is login and so insertion and deletion both take order login time 
the reset for that same as was in the case of a two four tree right

the reason why the insertion and deletion was taking login time in two four tree was the height was login and you know we did we might have done some number of operations but we were doing the operation proportional to the height right 
we might move up all the way so first we move down in the case of insertion and deletion so that heights order login and then some you know some borrowing in the case of in the case of insertion sometimes splitting  but the number of times you have to split it at most the height in the case of deletion we would either borrow the key or we would merge or again the number of times we would have to do this is proportional to the height
because every time we did one of these operation we move one level up or we just stop the entire process right

so both of these operation take order login time and the other thing we saw was what should be the relation between a and b for this two work right that s for this ab tree was concern the other thing we did  today was red black tree and for that we saw the process of insertion and we saw that it takes only you know some number of re coloring and one rotation to complete an insertion so that s the key thing about the red black tree is that only require one rotation 
some number of re coloring right you might have re coloring many nodes 
but only one rotation is require and these is what gives the power these is what makes them very fast and practice right and they are faster then avl trees for this reason okay
so the next class we are going to see the particular kind of a ab tree which is called b tree and what role does it plays specially in searching very large databases okay 
so that we are going to do in next class thank you  

Disk Based Data Structures (Time 01:09 min)
So today we are going to be talking about disk based data structures in last class we looked at ab trees (Refer slide time 01:17) 



so these were the extension of the two four trees we will see today we are going to look at disk based data structure and particular we are going to look at b trees and we will see that they are very similar are they are in fact ab trees for specific value of b okay and so the setting now we are looking at is when we have a large amount of data over which to search okay 
till now all over search trees where limited to main memory 
in the sense you build a binary search tree or build a two four tree or a red black tree so we had this nodes which where objects in memory and you know the references corresponds to pointer addresses or addresses memory addresses

Right now we are looking at the setting where we have the huge amount data 
lets say some kind of transaction data which could be bank share markets you know setting we are large amount of data get generate and such huge amount of data is not stored in the main memory of computer right 
this is typically stored on disk and now you want to be able to search through this data or insert something in to this data or modify this data right how do you do that 
so you just imagine the setting where you  have lets say particular bank which has records of each of its customers right
so they could be a million customers each of those records would be huge right 
the data should set in the each account should be huge because it would have all the transaction data associated with what has been history of transaction and so on 
you cant expect all of that data to decide in the main memory of the computer so it would be kept on disk and now suppose type in particular account number you should be able to retrieve that particular account and the data associated with that account 

so question is how are going to do this right 
so we want to make a search tree which is some sense secondary storage in avl tree which will help you even when the data most of the data is stored on disk will still be able to search ( )okay
now the problem here is that the data is stored on disk that s fine 
but even the index that we are building right 
so what do you mean by index the search 
tree search that we have so huge that we cannot expect the entire search tree to fit in to the main memory 
will come to this in to the short while right 
so whats the problem in you have think on the disk verses when thinks are (Refer slide time 04:01) the main memory of the computer 



so one big problem is that disk access is very slow right 
so how how is disk accessed you have lets say this is the disk 
so you typically have bunch of disk in stack one and top of each other 
each one of them has its own read write head head which will traverse which can move along this disk and get to a particular track 
so these are the track on the disk right 
the disk rotates in one particular direction and these read write head can you know decide that it wants to go on this track or this track or this track and so on right

so this part is called okay so ya so when you have to read a particular location so track is further divided in to sectors right 
so when you have to read a particular sectors the disk rotates and this read write head gets to the appropriate tag and then starts reading the data from there right 
so significant fraction of the time is spend in this read write head moving determining  which track it has go to and moving and the rotation right
so one of this is called seek latency 
so this that time that is required for the head to get to the appropriate tag its called seek latency and the other one is called rotation latency the time required for the disk to rotate so that the head is position at the right place the right sector and once you have write at the right place then the entire sector is typically read 

So one sector or you know lets say one lets call it as page so the data then is read in units in larger units ( ) 05:53 one bite of data from the disk 
why don t you read one bite of data from the disk 
because you already spend so much in getting to that one byte then might it is well read whole lot of bytes right 
so you typically read or write in units called pages which are you know it could depend upon the particular computer system but it could be you know in this range two to sixteen kilo bytes okay
so you read this much amount so this is this could be one page setting here and you read this much amount of data and it will be moved in to the main memory
this is reading when you writing similarly you would write back and entire page okay


now so what are the problem associated with this 
we have to organize our search tree in such a manner then first it can sit suitably on this disk as i said or search structure itself is going to be so large that it cannot fit in to the main memory right and that s what we are going to do in next slides 

so when you have the disk based algorithm like this (Refer slide time 07:11) the running time is going to be measured in terms of the time taken by the comp by the CPU and the number of disk access right



now this time in the time taken by the CPU is insignificant compare to the number of disk access in the time spend in each disk access 
so what you would do in most of these algorithm is to organized the data in such a manner there is a number of time you have to access the disk is very small right and what i have said is you know so the red till now we see the algorithm which are called main memory algorithm where the entire data sets in the main memory 

so they cannot be easily ported to this module when you are you know when part of the data sit on the disk it cannot be ported in the straight forward way 
so what are the problem that are going to happen now that we have data setting on the disk right 
so one is as for as this pointer business is concern 
pointer is to same as references to objects right 
so till now we had reference to an object we knew that correspondence to the address in the main memory 
so you would go and access that location in the main memory 
now if part of your data structure is sitting on the disk right 
so just imagine that your red black tree or whatever it was part of it was in the main memory part it was sitting on the disk right know one of those pointer one of those references is referring to a location on the disk now right 

so if it is referring to something in the main memory then you can go and get it at that particular memory location but if it is referring to something on the disk (Refer slide time 09:15)then you will have to do something lets use the operation disk read to read the particular data from the disk and disk write to write bind of the disk 
it will have to use the such kind of operation to be able to access the data i will come to what key means in a short while (noise:hindi)


so one big problem is that you know the pointer now have to be translated suitably 
if it is if its just pointing to a memory location then it is easy you just get to the memory location and do your job 
but if its not pointing to a  memory location if it is referring to something that s its in to the disk then we have to first fetch that block of data the page of data from the disk in to the main memory and then you can access that particular object ya

so typical pattern would look like something (refer slide time 10:01)



so x is the pointer to some object so you would read object from the disk you will do some operation on this object and then you will eventually write it back 
right and you might omit this step if you did not modify the object at all right 
so we are going work with two operation today 
disk read and disk write reading a block from disk and writing block back to disk 

so now lets come to what a (Refer slide time 10:32) b tree is
 


b tree is a same as you ab tree right 
so we are so here i drawn in a example where in this ab tree each node has one thousand keys 
so you value of a here is at least thousand lets say is a thousand 
so recall in an ab tree each node has at least a children and at most b children 
so here i have taken my a value of a as one thousand one so each node has at least one thousand one children okay 

so here i have just write to illustrate why is this data structure now useful for disk based access right 
so you have this first node which has one thousand and one children right and since it has one thousand one children how many keys would it have inside it 
thousand keys right and just i have organize it very uniformly so that then this each of this each node has also thousand children and then further more these leaves so its just two level trees these leaves also have thousand keys and then okay 
so how many keys are there in all in this so that s a thousand plus million ya plus a billion right 

so there will be so many keys in this entire two levels structure right
so lets say i had a data base with so many records right so many different accounts 
so i could put those of this each of this accounts records you know lets say the key just the account number so i could put all of those keys in to this kind of a structure right 
now each node had contain thousand keys 
now this entire structure cannot fit in to main memory right you can see this is already ten to the nine keys write which each of this keys there is associated with the pointer each of the key itself could be lets say four bytes of memory 
so four bytes of memory lets say four bytes of pointers is about eighty bytes per key so that s eight bytes times billion right that eight giga bytes okay
so you need that kind of space just to keep this data structure in to a main memory and here we have not said anything about the data associated with this records 
each of those data themselves could be you know hundred mega bytes 
because i have you know my account num account  has listed with the all transaction that have been done on the that account lets say the last three years or four years some such thing that s huge amount of data that s lets says stored on the disk we are not even bringing that in to the main memory 
but what i am pointing out first is even if the actual data was stored on the disk just to be able to access the data just using keys and pointers is so huge that you cannot have all of it in to the main memory right

now why is this kind of structure useful right 
we are talking about this base right so what we are going to have now is that we are going to have this structure this called b tree now 
this structure itself would be kept on the disk 
so each of these nodes would now be one page on that disk okay
and it is just this very top node the root node which will be kept in the main memory 
yes 
now what happens 
if you have to search 
what would you do you will determine which of this one thousand keys between which two keys your particular key lies in 
suppose it lies so and then go to the appropriate child node 

suppose this is a child we have to go to now what will you do you will access this node from the disk and bring it in to memory right 
i am from here you will determine key which should be next node suppose it is this node so you will access this node from disk and bring it in to main memory and from here you will be able to find your account number and then you will have to follow the account data lets see right
so how many disk access would you need 
one to get this one to get this and one to may be get the actual data associated the information associated with that particular record that you are trying to access ya 

so how much disk access how many disk access would you need height of the tree right 
so to reduce the height of the tree you want what do you want 
so you want as little height as possible for the tree yes so you want how can you reduce the height of the tree [noise:student]
increase the value of a increase your whatever the number of children each of this nodes have right (Refer slide time 15:50)but what is limiting you from number of children each of this nodes and page size right instead of one thousand why did i put in ten thousand key here or hundred thousand keys in here 
that would have even better right that would reduce the height even further 
if i had ya that would reduce the height even further but i can even put too many because each of those keys is taking certain amount of space and i can only put as many keys as can fit in to one page and what is the page page is a unit of transfer between the disk and the main memory 

so that is define for the particular computer system [noise:hindi]
so depending upon you know each of your if each of your keys comma pointer per taking lets say eight bytes right your page size is sixteen kilo bytes each of key comma pointer pair is taking eight bytes that you can put at most two thousands keys in to one page right and so that determine [noise:hindi]
so this is just read writing what what the node  

so x is now referring to an particular node so what is node (Refer slide time 17:08) x have n of x is the number of keys in that node right and then once again the first key is going to be less then the second key is going to be less then the so key one of the node is less then the key two of the node and so and on 



so there are so n of x keys and they will have lets say methods or particular bit in a node which specify whether the node is a leaf node or not right 
whether it is has any further children  
so leaf if this is true then that means leaf node other wise not and if its not a leaf node it s a internal node then we will have if there are n of x keys then will have n of x plus one children of that node ya and this we all know we have seen this before if k sub i is in z e in the sub tree c sub i in the case of i is less then the ith key in the node right and so on 

so it s the same (Refer slide time 18:05)



so b tree is the essentially same structure as you ab tree right 
now only difference is so far as ab tree we say we provided a lower bound on the value of b we said b is should be at least some remember ( ) two a minus one right
today we are going to say that b should be exactly sorry so what are we saying today we want that b should be right 
so um if a node has degree t so t is the same as the a that we had talked off all nodes except the root had between t and two t 
so this so we want that b so today we want basically this is out bound for b so we were working about b equals two times a exactly 
so b tree is essentially special kind of ab tree with ab with bb exactly two times a 
right 

so each node has between t and two t children and so it has at least it may be between t minus one and two t minus one keys 
so the other way in which b tree differs from a ab tree is while ab tree is meant to be a data structure meant for an internal memory right b tree is a data structure meant for secondary storage 
so you really have to choose large value of b 
so that height of the tree is smallest possible and the entire node the key is all the key is in the node can fit in to one page right and the same as before the root node has between zero and two t children 
actually i have said zero but you know it need not be zero it could be two between two and two of the children that s make it two and two key right

so this has (Refer slide time 20:08)the root node in this example has exactly two children and then this is t minus one keys and lets say t children 



so this is the this is the setting in which the height of the tree is as large as possible right because each of the node has only t children 
so if this is all you know just making show that you remember things from the previous classes right 
so there are one node here two nodes here two t nodes here and so on 
so this is goes up to height h you can compute you know this would be the total number of nodes that would had and since n is equal to this that will give you the height of the tree has this quantity 

okay so (Refer slide time 20:53)searching so i will just show you some pseudo code also for searching so that you know that these things are completely clear in your head 



suppose i am searching for key k in a node x right 
so this will be a recursive search procedure what am i going to do i am going to first find out the key ya what should i do i first have to find out the key the first key which is larger then k ya keys are arranging lets say increasing order in a node 
so you have to find a first key which is larger the k so that s what i do here right keep moving till i find a key which is larger then k then i come out 

so if i found a key which is larger then k lets say that s that will give me the i th right 
so if  i found exactly the key i was searching for then i return if the node that i am in was leaf node that i can t procedure any further then i return else either then the key is not there else i fetch the next node if fetch the next node and i continue my search in the next node right
what you have to do here 
you were searching right 
this is lets say c i x we have to know excess the particular node what is c i x is just the reference to the child node the appropriate child node 
you just have to access that 
i am going to skip this (Refer slide time 22:54)okay 



so splitting nodes the same idea is before when you split nodes when they are full right 
so how many keys can set in a node we set two t two t minus one two t can two t children so it can have two t minus one keys 
so if it has two t minus one keys and new key if we have trying to insert a new key then we split the node right and what was the process of splitting if this is the node that i am splitting let say t q value is four 

so this already has seven keys if i am trying to put one more here then i need to splited so s goes up and this gets split in to these right ( )
so i put down code here(Refer slide time 23:38) you can have a look at this slides separately to understand this code i am not going to spend too much time during it here right 



its very straight forward what you have to do this is this is a procedure for splitting a node y whose parent is x and this is lets say the i th child of this parent 
so i refers to that and what you do you create a new node z right and then you have first you copy the appropriate number of keys t minus one keys from y to z right that s what being done here and then you also if this is not a leaf node then you will copy the children also from y to z that s being done here and then right seeing coping that here you are moving so this has to be promoted up here right which means that these keys in here have to be moved one step right in the array that s what is being done here and then this key that is moved up copied in to the appropriate place there and then we have these three describe operation because we have modified this node and this node and the new node we created 

so they all have to be return back to disk
so that is being done here right
so the same thing is before the only catch today is that we are doing this disk operation also you can look at this slides and understand the code 
so how much time does it take for 
so now today we are going to be measuring running time and terms of the number of disk access that we have to do 
so in doing the split the number of disk access we have to do was three right 
because we did three input out puts at the end right

the time the CPU time which will now be proportional to the number of keys (Refer slide time 25:37)in that node right 
because we have to moves certain keys and so on is going to be fairly small compare to this right 
so we will actually be counting time in terms of the number of disk access 
so today one variant of binary of  b trees also works with 	so if you recall inserting when you did inserting in to two four trees or in ab trees we went down the tree found down the place where we are insert the element then try to put the element there right and if that resulted in the node getting split 
we split that node and that may [noise] have to insert the key in the parent node and that could lead to another split and so on and on 

these is another way of doing this thing which is that we start from the top right 
so that is called the two parse operation where in first you come down and then you go up the tree 
one possibility is to do the entire thing is only one pass what is that mean that is as you are starting from the top you check to see if the node that you are looking at already has its full coata of keys 
what is the full coata 
two t minus one 
if its already has two t minus one keys then you are going to split that node right there and then and only then proceed down the tree 
this is everyone follow 

so we are going to start from the root and we are going to recursively travel all the way up to the leaf but before we descend to a lower level we make sure that the node contains strictly less then two t minus one keys 
if it has two t minus one keys right then we split the node right there okay 
lets understand this (Refer slide time 27:33)



so i will come back to the slide later lets look at so lets say this was my root node right 
i am not yet inserted the key right this was the very the very first root node that i already counted this is already fill up i am working with t equal to four right 
so this has two three minus one seven keys in it 

this is already full so before descending down i would i see this is already full i write at this step split this node in to a d f l n p and h moves up right and now i will continue down the tree wherever whatever key i am trying to insert i will now continue [noise:hindi]right 
so let me see lets show you an example i will skip this slide and come back to this later 
so lets take an example(refer slide time 28:33) and then i will look at the code again right so suppose this is the tree i am trying to t is the value of three i am trying to insert b so first i come here this node is not full right t is three so it node is full when it has five keys in it 



ya this is not yet full 
so i can come down and b is inserted at this place 
suppose i am trying to insert q 
so once again i come to this node right
this is not yet full 
so i go down so actually this should b here i come here this is not yet full i come down here okay and then i put q here 
but this is full already so which means it will call this is split 
so q r s would go on one  side u v on the other and t gets promoted here right

note the very interesting thing why did why did this node not get split [noise:student]
right 
so see in the previous example in what we had seen in the two four trees or ab trees what was happening was that when i inserted an element in to the parent the parent could also gets split and that s not going to happen here any more 
why 
because i came down from the parent only when the parent had room in it 
if the parent had room then when i came down and i split this node and i put the one key in to the parent the parent is now not going to get split right 
lets with this happening again 
so now when i am trying to insert the next key lets say l so now when i come to the root node i will straight away split this because this already full right doesn t mater where l is going l is you know l m n o m l m n 
it will come here this node is not full right so but i am then i am trying to insert l i will right away split in to g m t x p and then come and insert l okay

so now lets say when i try to insert f i come here this is not full so i can continue this is not full so i can continue then i come here insert it here split it and one guy gets promoted here 
so the fact that this is not full lets me accumulated this addition key here without crossing ripple effect in the splitting process right

so this can be you know(refer slide time 31:11) 


so in some this is like a one pass you know in just one one way down we have kind of access all the nodes 
in just single pass we have access to all the nodes of the tree and whatever splitting then it will be done right
so how many disk i was required basically it just move down the tree once right we have to access every node and then every time you split the node right you have to right down that down back to the disk its parent node back to the disk and one new node that you create back to the disk 

so for every every time you split you might have to write down three nodes back to the disk right 
so you will have to read as many nodes as the height of the tree and how many nodes will you have to write back 
you will have write back at most three times the number of splits that many nodes you will have to write back to the disk ya [noise:student]

okay so towards the end i will discuss what are potential disadvantages of doing in this way right 
if you keep splitting right because you will have to now see what i am going to do when i have to delete a key right 
there i will try and lets see what i try and do that and then it will be clear right
so when i am doing deletion some going to actually (refer slide time 32:50) skip the code i show you right so you can look at those slides and understand ( )32:55 right 



as far as deleting key is concern once again we recall the earlier procedure we went down the tree we deleted the key when we deleted the key that node could have less number of keys then it was supposed to have in which case we first try to borrow if not successful merge if we merge we have to remove one key from the parent that could cause the ripple effect the cascading effect 
so that we ended up doing all the way up to the top right 
now we are again trying to do the single pass delete procedure right which means that we just going to down from the top and do the deletes right 
so now what we are going to do is if we encounter a node which has already the minimum number of keys

what is the minimum of keys in a node t minus one if it already if it just t minus one keys then write then we are trying to we are going to make a effort to let it have more then t minus one keys strictly more at least t 
so what are we going to try the same thing is before 
first we try to borrow from a from a neighbor from a sibling if we are successful with that gray if not then that means the sibling also has t minus one then we merge and when we merge we bring one from above and why can we now successfully bring one from above because the upper has strictly more then t minus one right

so you can do the entire thing in a single pass in exactly this manner 
so that s what we being said here before descending to lower level in the tree make sure that the node contains at least t keys 
ya in the case of insertion we require it contains strictly less then two t minus one keys now we say it contain strictly more then t keys right
suppose this is the situation 
so we are once again working with the t equals three right t equals three means each node has to have at least two keys right
so this node its okay 
it is no problem with this node why because it has three keys so i can continue down 
i can continue down i come to this node and delete from here and there is no problem right
but if i was trying to delete something from here then when i counted this node which has only two key the minimum number then i will try to do something write then and there before proceeding down okay right 
so this is sect so you know i have actually put down all the cases here where you know the key that we are trying to delete not in the leaf then you have to do all of the snaps so you seen all of these before so lets skip see some of this right and this was the case when we have to merge right 
so sorry (refer slide time 36:12) just once again let me make sure what right 



so if this is the setting so if if the particular node has only two minus one keys then we have take action to show that it has at least  t keys before we continue down and first thing is that we can borrow from the sibling and if not then we merge right so this is the picture (Refer slide time 36:43) ya 


lets look at this one we trying to delete b 
we come here there is no problem here and when i trying delete here i have borrow one from the sibling right you seen many example of this by now 
so how do you borrow one goes up and one comes down so this is the sititng situation happening here and if we cannot borrow then you merge same as before you are deleting d you come here you delete okay 
so actually sorry 
so you come here see l when you are deleting d this is already has problem right because it has minimum number of nodes so you going trying borrow one from the sibling but you are not going to be successful in borrowing one because that also has minimum so you merge and you get c l p t x right bringing one down and then you go head and you delete d from here 

so this is the situation that s going to happen 
then this also illustrates why this is the bads key who can tell me why so this is answering the question that he had raised right
why did we do the same thing for the red black tree is and the ab trees [noise:student]
student:so we could have delete either he will have 
staff: okay but [student:noise]
okay i am looking for one other answer which is perhaps who can um [noise:student] good split again see whats going to happen i just deleted right and this is the picture i got suppose i insert now whats going to happen i am going to go back this one 
suppose i delete i am going to come back to this 
suppose i insert this kind of going to go you know back and forth between this and i spending lot of works in doing this  because splitting the node lots of pointer moments and (other hand)

so this key does not work in very well then this we have this kind of things happening right 
so insert and deletes its are you know very highly interspersed 
if you have a block of insert and block of delete happening then its okay 
then you can still work with the scheme fine right

because if you had just deletes happening [noise:hindi]
so they would be no problem right
this has large number of keys now so you know it can handle whole lots of delete without without significant trouble right
so if you had large sequence of delete then this is a fine strategy or if you had long sequence of insert 
but if you had these things alternating vary often this would be in some trouble right
so once again what are the disk i was going to look like (Refer slide time 39:52)



so we are going to have we are going to read as many nodes as the height of the tree and each point when i am borrowing one from the sibling merging one from the sibling and basically modify only my sibling node right
so if i am doing any of those operation i might have to right  back to the sibling my one node and the parent node by the parent node because even when i borrowing from the sibling one key goes up and one key comes down from the parent right 
so its parent nodes also gets modified are event then merging again the parent gets modified 

so every time i do some borrow or merge with the sibling i will have to right back three node and so that gives the number of disk right that we have to do a thing 
so again this two pass operation (Refer slide time 40:35)we have actually seen before right 


so this was single pass we have doing things the two pass we have already seen 
so you first go down and then you go up as much as necessary so to say ya okay 
but in the case of disk disk access you have to think carefully or you have to organize the things more carefully right because if you are if you first make one pass down and then you make a pass all the way back up then you spending twices much time as you should have by just having made a single pass right 
so one thing you can do is when you making first pass down you keeps all those blocks red in memory 

how many blocks is that 
how many pages is that just the height of the tree which is not too much 
you keep them in memory 
why do we keep them in memory because you might require them on the way back in second pass ya so those are in optimization that you can do to  try and reduce the type because i said  most of the time here spend in the disk access you have to reduce the number of disk access as much as possible [noise:hindi]
so with that we are going to end this class today 
so this was mainly ment as a recap of a data structure that we saw today was just small extension of the ab tree but it is specifically for disk based accesses and this useful in that setting 


