An operating system is a program that manages the computer hardware. It
also provides a basis for application programs and acts as an intermediary
between the computer user and the computer hardware. An amazing aspect
of operating systems is how varied they are in accomplishing these tasks.
Mainframe operating systems are designed primarily to optimize utilization
of hardware. Personal computer (PC) operating systems support complex
games, business applications, and everything in between. Operating systems
for handheld computers are designed to provide an environment in which a
user can easily interface with the computer to execute programs. Thus, some
operating systems are designed to be convenient, others to be efficient, and others
some combination of the two.
Before we can explore the details of computer system operation, we need
to know something about system structure. We begin by discussing the basic
functions of system startup, I/O, and storage. We also describe the basic
computer architecture that makes it possible to write a functional operating
system.
Because an operating system is large and complex, it must be created
piece by piece. Each of these pieces should be a well-delineated portion of the
system, with carefully defined inputs, outputs, and functions. In this    we
provide a general overview of the major components of an operating system.
   OBJECTIVES
  To provide a grand tour of the major operating systems components.
  To provide coverage of basic computer system organization.
1.1 What Operating Systems Do
We begin our discussion by looking at the operating system's role in the
overall computer system. A computer system can be divided roughly into
four components: the hardware, the operating system, the application programs,
and the users (  1.1).
  1.1 Abstract view of the components of a computer system.
The hardware the central processing unit (CPU), the memory, and the
input/output (I/O) devices provides the basic computing resources for the
system. The application programs such as word processors, spreadsheets,
compilers, and web browsers define the ways in which these resources are
used to solve users' computing problems. The operating system controls and
coordinates the use of the hardware among the various application programs
for the various users.
We can also view a computer system as consisting of hardware, software,
and data. The operating system provides the means for proper use of these
resources in the operation of the computer system. An operating system is
similar to a government. Like a government, it performs no useful function by
itself. It simply provides an environment within which other programs can do
useful work.
To understand more fully the operating system's role, we next explore
operating systems from two viewpoints: that of the user and that of the system.
1.1.1 User View
The user's view of the computer varies according to the interface being
used. Most computer users sit in front of a PC, consisting of a monitor,
keyboard, mouse, and system unit. Such a system is designed for one user
to monopolize its resources. The goal is to maximize the work (or play)
that the user is performing. In this case, the operating system is designed
mostly for ease of use, with some attention paid to performance and none
paid to resource utilization how various hardware and software resources
are shared. Performance is, of course, important to the user; but rather than
resource utilization, such systems are optimized for the single-user experience.
1.1 What Operating Systems Do 5
In other cases, a user sits at a terminal connected to a mainframe or
minicomputer. Other users are accessing the same computer through other
terminals. These users share resources and may exchange information. The
operating system in such cases is designed to maximize resource utilization 
to assure that all available CPU time, memory, and I/O are used efficiently and
that no individual user takes more than her fair share.
In still other cases, users sit at workstations connected to networks of
other workstations and servers. These users have dedicated resources at their
disposal, but they also share resources such as networking and servers file,
compute, and print servers. Therefore, their operating system is designed to
compromise between individual usability and resource utilization.
Recently, many varieties of handheld computers have come into fashion.
Most of these devices are standalone units for individual users. Some are
connected to networks, either directly by wire or (more often) through wireless
modems and networking. Because of power, speed, and interface limitations,
they perform relatively few remote operations. Their operating systems are
designed mostly for individual usability, but performance per amount of
battery life is important as well.
Some computers have little or no user view. For example, embedded
computers in home devices and automobiles may have numeric keypads and
may turn indicator lights on or off to show status, but they and their operating
systems are designed primarily to run without user intervention.
1.1.2 System View
From the computer's point of view, the operating system is the program
most intimately involved with the hardware. In this context, we can view
an operating system as a resource allocator. A computer system has many
resources that may be required to solve a problem: CPU time, memory space,
file-storage space, I/O devices, and so on. The operating system acts as the
manager of these resources. Facing numerous and possibly conflicting requests
for resources, the operating system must decide how to allocate them to specific
programs and users so that it can operate the computer system efficiently and
fairly. As we have seen, resource allocation is especially important where many
users access the same mainframe or minicomputer.
A slightly different view of an operating system emphasizes the need to
control the various I/O devices and user programs. An operating system is a
control program. A control program manages the execution of user programs
to prevent errors and improper use of the computer. It is especially concerned
with the operation and control of I/O devices.
1.1.3 Defining Operating Systems
We have looked at the operating system's role from the views of the user
and of the system. How, though, can we define what an operating system
is  In general, we have no completely adequate definition of an operating
system. Operating systems exist because they offer a reasonable way to solve
the problem of creating a usable computing system. The fundamental goal
of computer systems is to execute user programs and to make solving user
problems easier. Toward this goal, computer hardware is constructed. Since
bare hardware alone is not particularly easy to use, application programs are
developed. These programs require certain common operations, such as those
controlling the I/O devices. The common functions of controlling and allocating
resources are then brought together into one piece of software: the operating
system.
In addition, we have no universally accepted definition of what is part of the
operating system. A simple viewpoint is that it includes everything a vendor
ships when you order "the operating system." The features included, however,
vary greatly across systems. Some systems take up less than 1 megabyte of
space and lack even a full-screen editor, whereas others require gigabytes of
space and are entirely based on graphical windowing systems. (A kilobyte, or
KB, is 1,024 bytes; a megabyte, or MB, is l,0242 bytes; and a gigabyte, or GB, is
l,0243 bytes. Computer manufacturers often round off these numbers and say
that a megabyte is 1 million bytes and a gigabyte is 1 billion bytes.) A more
common definition is that the operating system is the one program running
at all times on the computer (usually called the kernel), with all else being
systems programs and application programs. This last definition is the one
that we generally follow.
The matter of what constitutes an operating system has become increasingly
important. In 1998, the United States Department of Justice filed suit
against Microsoft, in essence claiming that Microsoft included too much functionality
in its operating systems and thus prevented application vendors from
competing. For example, a web browser was an integral part of the operating
system. As a result, Microsoft was found guilty of using its operating system
monopoly to limit competition.
1.2 Computer-System Organization
Before we can explore the details of how computer systems operate, we need
a general knowledge of the structure of a computer system. In this section, we
look at several parts of this structure to round out our background knowledge.
The section is mostly concerned with computer-system organization, so you
can skim or skip it if you already understand the concepts.
1.2.1 Computer-System Operation
A modern general-purpose computer system consists of one or more CPUs
and a number of device controllers connected through a common bus that
provides access to shared memory (  1.2). Each device controller is in
charge of a specific type of device (for example, disk drives, audio devices, and
video displays). The CPU and the device controllers can execute concurrently,
competing for memory cycles. To ensure orderly access to the shared memory,
a memory controller is provided whose function is to synchronize access to the
memory.
For a computer to start running for instance, when it is powered
up or rebooted it needs to have an initial program to run. This initial
program, or bootstrap program, tends to be simple. Typically, it is stored
in read-only memory (ROM) or electrically erasable programmable read-only
memory (EEPROM), known by the general term firmware, within the computer
hardware. It initializes all aspects of the system, from CPU registers to device
1.2 Computer-System Organization 7.
controllers to memory contents. The bootstrap program must know how to
load the operating system and to start executing that system. To accomplish this
goal, the bootstrap program must locate and load into memory the operatingsystem
kernel. The operating system then starts executing the first process,
such as "init," and waits for some event to occur.
The occurrence of an event is usually signaled by an interrupt from either
the hardware or the software. Hardware may trigger an interrupt at any time
by sending a signal to the CPU, usually by way of the system bus. Software
may trigger an interrupt by executing a special operation called a system call
(also called a monitor call).
When the CPU is interrupted, it stops what it is doing and immediately
transfers execution to a fixed location. The fixed location usually contains
the starting address where the service routine for the interrupt is located.
The interrupt service routine executes; on completion, the CPU resumes the
interrupted computation. A time line of this operation is shown in   1.3.
Interrupts are an important part of a computer architecture. Each computer
design has its own interrupt mechanism, but several functions are common.
The interrupt must transfer control to the appropriate interrupt service routine.
The straightforward method for handling this transfer would be to invoke a
generic routine to examine the interrupt information; the routine, in turn,
would call the interrupt-specific handler. However, interrupts must be handled
quickly. Since only a predefined number of interrupts is possible, a table of
pointers to interrupt routines can be used instead to provide the necessary
speed. The interrupt routine is called indirectly through the table, with no
intermediate routine needed. Generally, the table of pointers is stored in low
memory (the first 100 or so locations). These locations hold the addresses of
the interrupt service routines for the various devices. This array, or interrupt
vector, of addresses is then indexed by a unique device number, given with
the interrupt request, to provide the address of the interrupt service routine for
the interrupting device. Operating systems as different as Windows and UNIX
dispatch interrupts in this manner.
The interrupt architecture must also save the address of the interrupted
instruction. Many old designs simply stored the interrupt address in a
fixed location or in a location indexed by the device number. More recent
architectures store the return address on the system stack. If the interrupt
routine needs to modify the processor state for instance, by modifying
register values it must explicitly save the current state and then restore that
state before returning. After the interrupt is serviced, the saved return address
is loaded into the program counter, and the interrupted computation resumes
as though the interrupt had not occurred.
1.2.2 Storage Structure
Computer programs must be in main memory (also called random-access
memory or RAM) to be executed. Main memory is the only large storage area
(millions to billions of bytes) that the processor can access directly. It commonly
is implemented in a semiconductor technology called dynamic random-access
memory (DRAM), which forms an array of memory words. Each word has its
own address. Interaction is achieved through a sequence of load or store
instructions to specific memory addresses. The load instruction moves a word
from main memory to an internal register within the CPU, whereas the store
instruction moves the content of a register to main memory. Aside from explicit
loads and stores, the CPU automatically loads instructions from main memory
for execution.
A typical instruction-execution cycle, as executed on a system with a von
Neumann architecture, first fetches an instruction from memory and stores
that instruction in the instruction register. The instruction is then decoded
and may cause operands to be fetched from memory and stored in some
internal register. After the instruction on the operands has been executed, the
result may be stored back in memory. Notice that the memory unit sees only
a stream of memory addresses; it does not know how they are generated (by
the instruction counter, indexing, indirection, literal addresses, or some other
means) or what they are for (instructions or data). Accordingly, we can ignore
hoio a memory address is generated by a program. We are interested only in
the sequence of memory addresses generated by the running program.
Ideally, we want the programs and data to reside in main memory
permanently. This arrangement usually is not possible for the following two
reasons:
1.2 Computer-System Organization 9
1. Main memory is usually too small to store all needed programs and data
permanently.
2. Main memory is a volatile storage device that loses its contents when
power is turned off or otherwise lost.
Thus, most computer systems provide secondary storage as an extension
of main memory. The main requirement for secondary storage is that it be able
to hold large quantities of data permanently.
The most common secondary-storage device is a magnetic disk, which
provides storage for both programs and data. Most programs (web browsers,
compilers, word processors, spreadsheets, and so on) are stored on a disk until
they are loaded into memory. Many programs then use the disk as both a source
and a destination of the information for their processing. Hence, the proper
management of disk storage is of central importance to a computer system, as
we discuss in    12.
In a larger sense, however, the storage structure that we have described 
consisting of registers, main memory, and magnetic disks is only one of many
possible storage systems. Others include cache memory, CD-ROM, magnetic
tapes, and so on. Each storage system provides the basic functions of storing
a datum and of holding that datum until it is retrieved at a later time. The
main differences among the various storage systems lie in speed, cost, size,
and volatility.
The wide variety of storage systems in a computer system can be organized
in a hierarchy (  1.4) according to speed and cost. The higher levels are
expensive, but they are fast. As we move down the hierarchy, the cost per bit
leqislorr,
cache
.
generally decreases, whereas the access time generally increases. This trade-off
is reasonable; if a given storage system were both faster and less expensive
than another other properties being the same then there would be no
reason to use the slower, more expensive memory. In fact, many early storage
devices, including paper tape and core memories, are relegated to museums
now that magnetic tape and semiconductor memory have become faster and
cheaper. The top four levels of memory in   1.4 may be constructed using
semiconductor memory.
In addition to differing in speed and cost, the various storage systems
are either volatile or nonvolatile. As mentioned earlier, volatile storage loses
its contents when the power to the device is removed. In the absence of
expensive battery and generator backup systems, data must be written to
nonvolatile storage for safekeeping. In the hierarchy shown in   1.4, the
storage systems above the electronic disk are volatile, whereas those below
are nonvolatile. An electronic disk can be designed to be either volatile or
nonvolatile. During normal operation, the electronic disk stores data in a
large DRAM array, which is volatile. But many electronic-disk devices contain
a hidden magnetic hard disk and a battery for backup power. If external
power is interrupted, the electronic-disk controller copies the data from RAM
to the magnetic disk. When external power is restored, the controller copies
the data back into the RAM. Another form of electronic disk is flash memory,
which is popular in cameras and personal digital assistants (PDAs), in robots,
and increasingly as removable storage on general-purpose computers. Flash
memory is slower than DRAM but needs no power to retain its contents. Another
form of nonvolatile storage is NVRAM, which is DRAM with battery backup
power. This memory can be as fast as DRAM but has a limited duration in
which it is nonvolatile.
The design of a complete memory system must balance all the factors just
discussed: It must use only as much expensive memory as necessary while
providing as much inexpensive, nonvolatile memory as possible. Caches can
be installed to improve performance where a large access-time or transfer-rate
disparity exists between two components.
1.2.3 I/O Structure
Storage is only one of many types of I/O devices within a computer. A large
portion of operating system code is dedicated to managing I/O, both because
of its importance to the reliability and performance of a system and because of
the varying nature of the devices. Therefore, we now provide an overview of
I/O.
A general-purpose computer system consists of CPUs and multiple device
controllers that are connected through a common bus. Each device controller
is in charge of a specific type of device. Depending on the controller, there may
be more than one attached device. For instance, seven or more devices can be
attached to the small computer-systems interface (SCSI) controller. A device
controller maintains some local buffer storage and a set of special-purpose
registers. The device controller is responsible for moving the data between
the peripheral devices that it controls and its local buffer storage. Typically,
operating systems have a device driver for each device controller. This device
1.2 Computer-System Organization 11
thread of execution
CPU (*N)
<3 5
1c
a
  instruction execution  
cycle
  data movement  
DMA
instructions
and
data
memory
  1.5 How a modern computer system works.
driver understands the device controller and presents a uniform interface to
the device to the rest of the operating system.
To start an I/O operation, the device driver loads the appropriate registers
within the device controller. The device controller, in turn, examines the
contents of these registers to determine what action to take (such as "read
a character from the keyboard")- The controller starts the transfer of data from
the device to its local buffer. Once the transfer of data is complete, the device
controller informs the device driver via an interrupt that it has finished its
operation. The device driver then returns control to the operating system,
possibly returning the data or a pointer to the data if the operation was a read.
For other operations, the device driver returns status information.
This form of interrupt-driven I/O is fine for moving small amounts of data
but can produce high overhead when used for bulk data movement such as disk
I/O. To solve this problem, direct memory access (DMA) is used. After setting
up buffers, pointers, and counters for the I/O device, the device controller
transfers an entire block of data directly to or from its own buffer storage to
memory, with no intervention by the CPU. Only one interrupt is generated per
block, to tell the device driver that the operation has completed, rather than
the one interrupt per byte generated for low-speed devices. While the device
controller is performing these operations, the CPU is available to accomplish
other work.
Some high-end systems use switch rather than bus architecture. On these
systems, multiple components can talk to other components concurrently,
rather than competing for cycles on a shared bus. In this case, DMA is even
more effective.   1.5 shows the interplay of all components of a computer
system.
12    1    
1.3 Computer-System Architecture
In Section 1.2 we introduced the general structure of a typical computer system.
A computer system may be organized in a number of different ways, which we
can categorize roughly according to the number of general-purpose processors
used.
1.3.1 Single-Processor Systems
Most systems vise a single processor. The variety of single-processor systems
may be surprising, however, since these systems range from PDAs through
mainframes. On a single-processor system, there is one main CPU capable
of executing a general-purpose instruction set, including instructions from
user processes. Almost all systems have other special-purpose processors as
well. They may come in the form of device-specific processors, such as disk,
keyboard, and graphics controllers; or, on mainframes, they may come in the
form of more general-purpose processors, such as I/O processors that move
data rapidly among the components of the system.
All of these special-purpose processors run a limited instruction set and
do not run user processes. Sometimes they are managed by the operating
system, in that the operating system sends them information about their next
task and monitors their status. For example, a disk-controller microprocessor
receives a sequence of requests from the main CPU and implements its own disk
queue and scheduling algorithm. This arrangement relieves the main CPU of
the overhead of disk scheduling. PCs contain a microprocessor in the keyboard
to convert the keystrokes into codes to be sent to the CPU. In other systems
or circumstances, special-purpose processors are low-level components built
into the hardware. The operating system cannot communicate with these
processors; they do their jobs autonomously. The use of special-purpose
microprocessors is common and does not turn a single-processor system into
a multiprocessor. If there is only one general-purpose CPU, then the system is
a single-processor system.
1.3.2 Multiprocessor Systems
Although single-processor systems are most common, multiprocessor systems
(also known as parallel systems or tightly coupled systems) are growing
in importance. Such systems have two or more processors in close communication,
sharing the computer bus and sometimes the clock, memory, and
peripheral devices.
Multiprocessor systems have three main advantages:
1. Increased throughput. By increasing the number of processors, we expect
to get more work done in less time. The speed-up ratio with N processors
is not N, however; rather, it is less than N. When multiple processors
cooperate on a task, a certain amount of overhead is incurred in keeping
all the parts working correctly. This overhead, plus contention for shared
resources, lowers the expected gain from additional processors. Similarly,
N programmers working closely together do not produce N times the
amount of work a single programmer would produce.
1.3 Computer-System Architecture 13
2. Economy of scale. Multiprocessor systems can cost less than equivalent
multiple single-processor systems, because they can share peripherals,
mass storage, and power supplies. If several programs operate on the
same set of data, it is cheaper to store those data on one disk and to have
all the processors share them than to have many computers with local
disks and many copies of the data.
3. Increased reliability. If functions can be distributed properly among
several processors, then the failure of one processor will not halt the
system, only slow it down. If we have ten processors and one fails, then
each of the remaining nine processors can pick up a share of the work of
the failed processor. Thus, the entire system runs only 10 percent slower,
rather than failing altogether.
Increased reliability of a computer system is crucial in many applications.
The ability to continue providing service proportional to the level of surviving
hardware is called graceful degradation. Some systems go beyond graceful
degradation and are called fault tolerant, because they can suffer a failure of
any single component and still continue operation. Note that fault tolerance
requires a mechanism to allow the failure to be detected, diagnosed, and, if
possible, corrected. The HP NonStop system (formerly Tandem) system uses
both hardware and software duplication to ensure continued operation despite
faults. The system consists of multiple pairs of CPUs, working in lockstep. Both
processors in the pair execute each instruction and compare the results. If the
results differ, then one CPU of the pair is at fault, and both are halted. The
process that was being executed is then moved to another pair of CPUs, and the
instruction that failed is restarted. This solution is expensive, since it involves
special hardware and considerable hardware duplication.
The multiple-processor systems in use today are of two types. Some
systems use asymmetric multiprocessing, in which each processor is assigned
a specific task. A master processor controls the system; the other processors
either look to the master for instruction or have predefined tasks. This scheme
defines a master-slave relationship. The master processor schedules and
allocates work to the slave processors.
The most common systems use symmetric multiprocessing (SMP), in
which each processor performs all tasks within the operating system. SMP
means that all processors are peers; no master-slave relationship exists
between processors.   1.6 illustrates a typical SMP architecture. An
example of the SMP system is Solaris, a commercial version of UNIX designed
by Sun Microsystems. A Solaris system can be con d to employ dozens of
processors, all running Solaris. The benefit of this model is that many processes
GPU GPU CPU
memory
  1.6 Symmetric multiprocessing architecture.
14    1    
can run simultaneously N processes can run if there are N CPUs without
causing a significant deterioration of performance. However, we must carefully
control I/O to ensure that the data reach the appropriate processor. Also, since
the CPUs are separate, one may be sitting idle while another is overloaded,
resulting in inefficiencies. These inefficiencies can be avoided if the processors
share certain data structures. A multiprocessor system of this form will allow
processes and resources such as memory to be shared dynamically among
the various processors and can lower the variance among the processors. Such
a system must be written carefully, as we shall see in    6. Virtually all
modern operating systems including Windows, Windows XP, Mac OS X, and
Linux now provide support for SMP.
The difference between symmetric and asymmetric multiprocessing may
result from either hardware or software. Special hardware can differentiate the
multiple processors, or the software can be written to allow only one master and
multiple slaves. For instance, Sun's operating system SunOS Version 4 provided
asymmetric multiprocessing, whereas Version 5 (Solaris) is symmetric on the
same hardware.
A recent trend in CPU design is to include multiple compute cores on
a single chip. In essence, these are multiprocessor chips. Two-way chips are
becoming mainstream, while N-way chips are going to be common in high-end
systems. Aside from architectural considerations such as cache, memory, and
bus contention, these multi-core CPUs look to the operating system just as N
standard processors.
Lastly, blade servers are a recent development in which multiple processor
boards, I/O boards, and networking boards are placed in the same chassis.
The difference between these and traditional multiprocessor systems is that
each blade-processor board boots independently and runs its own operating
system. Some blade-server boards are multiprocessor as well, which blurs the
lines between types of computers. In essence, those servers consist of multiple
independent multiprocessor systems.
1.3.3 Clustered Systems
Another type of multiple-CPU system is the clustered system. Like multiprocessor
systems, clustered systems gather together multiple CPUs to accomplish
computational work. Clustered systems differ from multiprocessor systems,
however, in that they are composed of two or more individual systems
coupled together. The definition of the term clustered is not concrete; many
commercial packages wrestle with what a clustered system is and why one
form is better than another. The generally accepted definition is that clustered
computers share storage and are closely linked via a local-area network (LAN)
(as described in Section 1.10) or a faster interconnect such as InfiniBand.
Clustering is usually used to provide high-availability service; that is,
service will continue even if one or more systems in the cluster fail. High
availability is generally obtained by adding a level of redundancy in the
system. A layer of cluster software runs on the cluster nodes. Each node can
monitor one or more of the others (over the LAN). If the monitored machine
fails, the monitoring machine can take ownership of its storage and restart the
applications that were running on the failed machine. The users and clients of
the applications see only a brief interruption of service.
1.4 Operating-System Structure 15
Clustering can be structured asymmetrically or symmetrically. In asymmetric
clustering, one machine is in hot-standby mode while the other is
running the applications. The hot-standby host machine does nothing but
monitor the active server. If that server fails, the hot-standby host becomes the
active server. In symmetric mode, two or more hosts are running applications,
and are monitoring each other. This mode is obviously more efficient, as it uses
all of the available hardware. It does require that more than one application be
available to run.
Other forms of clusters include parallel clusters and clustering over a
wide-area network (WAN) (as described in Section 1.10). Parallel clusters allow
multiple hosts to access the same data on the shared storage. Because most
operating systems lack support for simultaneous data access by multiple hosts,
parallel clusters are usually accomplished by use of special versions of software
and special releases of applications. For example, Oracle Parallel Server is a
version of Oracle's database that has been designed to run on a parallel cluster.
Each machine runs Oracle, and a layer of software tracks access to the shared
disk. Each machine has full access to all data in the database. To provide this
shared access to data, the system must also supply access control and locking
to ensure that no conflicting operations occur. This function, commonly known
as a distributed lock manager (DLM), is included in some cluster technology.
Cluster technology is changing rapidly. Some cluster products support
dozens of systems in a cluster, as well as clustered nodes that are separated
by miles. Many of these improvements are made possible by storage-area
networks (SANs), as described in Section 12.3.3, which allow many systems
to attach to a pool of storage. If the applications and their data are stored on
the SAN, then the cluster software can assign the application to run on any
host that is attached to the SAN. If the host fails, then any other host can take
over. In a database cluster, dozens of hosts can share the same database, greatlyincreasing
performance and reliability.
1.4 Operating-System Structure
Now that we have discussed basic information about computer-system organization
and architecture, we are ready to talk about operating systems.
An operating system provides the environment within which programs are
executed. Internally, operating systems vary greatly in their makeup, since
they are organized along many different lines. There are, however, many
commonalities, which we consider in this section.
One of the most important aspects of operating systems is the ability to
multiprogram. A single user cannot, in general, keep either the CPU or the
I/O devices busy at all times. Multiprogramming increases CPU utilization by
organizing jobs (code and data) so that the CPU always has one to execute.
The idea is as follows: The operating system keeps several jobs in memory
simultaneously (  1.7). This set of jobs can be a subset of the jobs kept in
the job pool which contains all jobs that enter the system since the number
of jobs that can be kept simultaneously in memory is usually smaller than
the number of jobs that can be kept in the job pool. The operating system
picks and begins to execute one of the jobs in memory. Eventually, the job
may have to wait for some task, such as an I/O operation, to complete. In a
16    1    
512M
operating
job
system
1
job 2
job
job
3
4
  1.7 Memory layout for a multiprogramming system.
non-multiprogrammed system, the CPU would sit idle. In a multiprogrammed
system, the operating system simply switches to, and executes, another job.
When that job needs to wait, the CPU is switched to another job, and so on.
Eventually, the first job finishes waiting and gets the CPU back. As long as at
least one job needs to execute, the CPU is never idle.
This idea is common in other life situations. A lawyer does not work for
only one client at a time, for example. While one case is waiting to go to trial
or have papers typed, the lawyer can work on another case. If he has enough
clients, the lawyer will never be idle for lack of work. (Idle lawyers tend to
become politicians, so there is a certain social value in keeping lawyers busy.)
Multiprogrammed systems provide an environment in which the various
system resources (for example, CPU, memory, and peripheral devices) are
utilized effectively, but they do not provide for user interaction with the
computer system. Time sharing (or multitasking) is a logical extension of
multiprogramming. In time-sharing systems, the CPU executes multiple jobs
by switching among them, but the switches occur so frequently that the users
can interact with each program while it is running.
Time sharing requires an interactive (or hands-on) computer system,
which provides direct communication between the user and the system. The
user gives instructions to the operating system or to a program directly, using a
input device such as a keyboard or a mouse, and waits for immediate results on
an output device. Accordingly, the response time should be short typically
less than one second.
A time-shared operating system allows many users to share the computer
simultaneously. Since each action or command in a time-shared system tends
to be short, only a little CPU time is needed for each user. As the system switches
rapidly from one user to the next, each user is given the impression that the
entire computer system is dedicated to his use, even though it is being shared
among many users.
A time-shared operating system uses CPU scheduling and multiprogramming
to provide each user with a small portion of a time-shared computer.
Each user has at least one separate program in memory. A program loaded into
1.5 Operating-System Operations 17
memory and executing is called a process. When a process executes, it typically
executes for only a short time before it either finishes or needs to perform I/O.
I/O may be interactive; that is, output goes to a display for the user, and input
comes from a user keyboard, mouse, or other device. Since interactive I/O
typically runs at "people speeds," it may take a long time to complete. Input,
for example, may be bounded by the user's typing speed; seven characters per
second is fast for people but incredibly slow for computers. Rather than let
the CPU sit idle as this interactive input takes place, the operating system will
rapidly switch the CPU to the program of some other user.
Time-sharing and multiprogramming require several jobs to be kept
simultaneously in memory. Since in general main memory is too small to
accommodate all jobs, the jobs are kept initially on the disk in the job pool.
This pool consists of all processes residing on disk awaiting allocation of main
memory. If several jobs are ready to be brought into memory, and if there is
not enough room for all of them, then the system must choose among them.
Making this decision is job scheduling, which is discussed in    5. When
the operating system selects a job from the job pool, it loads that job into
memory for execution. Having several programs in memory at the same time
requires some form of memory management, which is covered in   s 8
and 9. In addition, if several jobs are ready to run at the same time, the system
must choose among them. Making this decision is CPU scheduling, which is
discussed in    5. Finally, running multiple jobs concurrently requires
that their ability to affect one another be limited in all phases of the operating
system, including process scheduling, disk storage, and memory management.
These considerations are discussed throughout the text.
In a time-sharing system, the operating system must ensure reasonable
response time, which is sometimes accomplished through swapping, where
processes are swapped in and out of main memory to the disk. A more common
method for achieving this goal is virtual memory, a technique that allows
the execution of a process that is not completely in memory (   9).
The main advantage of the virtual-memory scheme is that it enables users
to run programs that are larger than actual physical memory. Further, it
abstracts main memory into a large, uniform array of storage, separating logical
memory as viewed by the user from physical memory. This arrangement frees
programmers from concern over memory-storage limitations.
Time-sharing systems must also provide a file system (  s 10 and 11).
The file system resides on a collection of disks; hence, disk management must
be provided (   12). Also, time-sharing systems provide a mechanism for
protecting resources from inappropriate use (   14). To ensure orderly
execution, the system must provide mechanisms for job synchronization and
communication (   6), and it may ensure that jobs do not get stuck in a
deadlock, forever waiting for one another (   7).
1.5 Operating-System Operations
As mentioned earlier, modern operating systems are interrupt driven. If there
are no processes to execute, no I/O devices to service, and no users to whom
to respond, an operating system will sit quietly, waiting for something to
happen. Events are almost always signaled by the occurrence of an interrupt
or a trap. A trap (or an exception) is a software-generated interrupt caused
either by an error (for example, division by zero or invalid memory access)
or by a specific request from a user program that an operating-system service
be performed. The interrupt-driven nature of an operating system defines
that system's general structure. For each type of interrupt, separate segments
of code in the operating system determine what action should be taken. An
interrupt service routine is provided that is responsible for dealing with the
interrupt.
Since the operating system and the users share the hardware and software
resources of the computer system, we need to make sure that an error in a user
program could cause problems only for the one program that was running.
With sharing, many processes could be adversely affected by a bug in one
program. For example, if a process gets stuck in an infinite loop, this loop could
prevent the correct operation of many other processes. More subtle errors can
occur in a multiprogramming system, where one erroneous program might
modify another program, the data of another program, or even the operating
system itself.
Without protection against these sorts of errors, either the computer must
execute only one process at a time or all output must be suspect. A properly
designed operating system must ensure that an incorrect (or malicious)
program cannot cause other programs to execute incorrectly.
1.5.1 Dual-Mode Operation
In order to ensure the proper execution of the operating system, we must be
able to distinguish between the execution of operating-system code and userdefined
code. The approach taken by most computer systems is to provide
hardware support that allows us to differentiate among various modes of
execution.
At the very least, we need two separate modes of operation: user mode
and kernel mode (also called supervisor mode, system mode, or privileged
mode). A bit, called the mode bit, is added to the hardware of the computer to
indicate the current mode: kernel (0) or user (1). With the mode bit, we are able
to distinguish between a task that is executed on behalf of the operating system
and one that is executed on behalf of the user. When the computer system is
executing on behalf of a user application, the system is in user mode. However,
when a user application requests a service from the operating system (via a
system call), it must transition from user to kernel mode to fulfill the request.
This is shown in   1.8. As we shall see, this architectural enhancement is
useful for many other aspects of system operation as well.
At system boot time, the hardware starts in kernel mode. The operating
system is then loaded and starts user applications in user mode. Whenever a
trap or interrupt occurs, the hardware switches from user mode to kernel mode
(that is, changes the state of the mode bit to 0). Thus, whenever the operating
system gains control of the computer, it is in kernel mode. The system always
switches to user mode (by setting the mode bit to 1) before passing control to
a user program.
The dual mode of operation provides us with the means for protecting the
operating system from errant users and errant users from one another. We
accomplish this protection by designating some of the machine instructions that
1.5 Operating-System Operations 19
user process executing calls system call return from system call
user mode
(mode bit = 1)
k e m e l mode bit = 0 ; mode bit =1
kernel mode
execute system call I (mode bit = 0)
  1.8 Transition from user to kernel mode.
may cause harm as privileged instructions. The hardware allows privileged
instructions to be executed only in kernel mode. If an attempt is made to
execute a privileged instruction in user mode, the hardware does not execute
the instruction but rather treats it as illegal and traps it to the operating system.
The instruction to switch to user mode is an example of a privileged
instruction. Some other examples include I/O control, timer management, and
interrupt management. As we shall see throughout the text, there are many
additional privileged instructions.
We can now see the life cycle of instruction execution in a computer system.
Initial control is within the operating system, where instructions are executed
in kernel mode. When control is given to a user application, the mode is set to
user mode. Eventually, control is switched back to the operating system via an
interrupt, a trap, or a system call.
System calls provide the means for a user program to ask the operating
system to perform tasks reserved for the operating system on the user
program's behalf. A system call is invoked in a variety of ways, depending
on the functionality provided by the underlying processor. In all forms, it is the
method used by a process to request action by the operating system. A system
call usually takes the form of a trap to a specific location in the interrupt vector.
This trap can be executed by a generic t r a p instruction, although some systems
(such as the MIPS R2000 family) have a specific syscall instruction.
When a system call is executed, it is treated by the hardware as a software
interrupt. Control passes through the interrupt vector to a service routine in
the operating system, and the mode bit is set to kernel mode. The systemcall
service routine is a part of the operating system. The kernel examines
the interrupting instruction to determine what system call has occurred; a
parameter indicates what type of service the user program is requesting.
Additional information needed for the request may be passed in registers,
on the stack, or in memory (with pointers to the memory locations passed in
registers). The kernel verifies that the parameters are correct and legal, executes
the request, and returns control to the instruction following the system call. We
describe system calls more fully in Section 2.3.
The lack of a hardware-supported dual mode can cause serious shortcomings
in an operating system. For instance, MS-DOS was written for the Intel
8088 architecture, which has no mode bit and therefore no dual mode. A user
program running awry can wipe out the operating system by writing over it
with data; and multiple programs are able to write to a device at the same time,
20    1    
with possibly disastrous results. Recent versions of the Intel CPU, such is the
Pentium, do provide dual-mode operation. Accordingly, most contemporary
operating systems, such as Microsoft Windows 2000 and Windows XP, and
Linux and Solaris for x86 systems, take advantage of this feature and provide
greater protection for the operating system.
Once hardware protection is in place, errors violating modes are detected
by the hardware. These errors are normally handled by the operating system.
If a user program fails in some way such as by making an attempt either
to execute an illegal instruction or to access memory that is not in the user's
address space then the hardware will trap to the operating system. The trap
transfers control through the interrupt vector to the operating system, just as
an interrupt does. When a program error occurs, the operating system must
terminate the program abnormally. This situation is handled by the same code
as is a user-requested abnormal termination. An appropriate error message is
given, and the memory of the program may be dumped. The memory dump
is usually written to a file so that the user or programmer can examine it and
perhaps correct it and restart the program.
1.5.2 Timer
We must ensure that the operating system maintains control over the CPU.
We must prevent a user program from getting stuck in an infinite loop or not
calling system services and never returning control to the operating system.
To accomplish this goal, we can use a timer. A timer can be set to interrupt
the computer after a specified period. The period may be fixed (for example,
1/60 second) or variable (for example, from 1 millisecond to 1 second). A
variable timer is generally implemented by a fixed-rate clock and a counter.
The operating system sets the counter. Every time the clock ticks, the counter
is decremented. When the counter reaches 0, an interrupt occurs. For instance,
a 10-bit counter with a 1-millisecond clock allows interrupts at intervals from
1 millisecond to 1,024 milliseconds, in steps of 1 millisecond.
Before turning over control to the user, the operating system ensures
that the timer is set to interrupt. If the timer interrupts, control transfers
automatically to the operating system, which may treat the interrupt as a fatal
error or may give the program more time. Clearly, instructions that modify the
content of the timer are privileged.
Thus, we can use the timer to prevent a user program from running too
long. A simple technique is to initialize a counter with the amount of time that a
program is allowed to run. A program with a 7-minute time limit, for example,
would have its counter initialized to 420. Every second, the timer interrupts
and the counter is decremented by 1. As long as the counter is positive, control
is returned to the user program. When the counter becomes negative, the
operating system terminates the program for exceeding the assigned time
limit.
1.6 Process Management
A program does nothing unless its instructions are executed by a CPU. A
program in execution, as mentioned, is a process. A time-shared user program
such as a compiler is a process. A word-processing program being run by an
1.7 Memory Management 21
individual user on a PC is a process. A system task, such as sending  utput
to a printer, can also be a process (or at least part of one). For now, you can
consider a process to be a job or a time-shared program, but later you will learn
that the concept is more general. As we shall see in    3, it is possible
to provide system calls that allow processes to create subprocesses to execute
concurrently.
A process needs certain resources including CPU time, memory, files,
and I/O devices to accomplish its task. These resources are either given to
the process when it is created or allocated to it while it is running. In addition
to the various physical and logical resources that a process obtains when it is
created, various initialization data (input) may be passed along. For example,
consider a process whose function is to display the status of a file on the screen
of a terminal. The process will be given as an input the name of the file and will
execute the appropriate instructions and system calls to obtain and display
on the terminal the desired information. When the process terminates, the
operating system will reclaim any reusable resources.
We emphasize that a program by itself is not a process; a program is a passive
entity, such as the contents of a file stored on disk, whereas a process is an active
entity. A single-threaded process has one program counter specifying the next
instruction to execute. (Threads will be covered in    4.) The execution
of such a process must be sequential. The CPU executes one instruction of the
process after another, until the process completes. Further, at any time, one
instruction at most is executed on behalf of the process. Thus, although two
processes may be associated with the same program, they are nevertheless
considered two separate execution sequences. A multithreaded process has
multiple program counters, each pointing to the next instruction to execute for
a given thread.
A process is the unit of work in a system. Such a system consists of a
collection of processes, some of which are operating-system processes (those
that execute system code) and the rest of which are user processes (those that
execute user code). All these processes can potentially execute concurrently 
by multiplexing the CPU among them on a single CPU, for example.
The operating system is responsible for the following activities in connection
with process management:
  Creating and deleting both user and system processes
  Suspending and resuming processes
  Providing mechanisms for process synchronization
  Providing mechanisms for process communication
  Providing mechanisms for deadlock handling
We discuss process-management techniques in   s 3 through 6.
1.7 Memory Management
As we discussed in Section 1.2.2, the main memory is central to the operation
of a modern computer system. Main memory is a large array of words or bytes,
22    1    
ranging in size from hundreds of thousands to billions. Each word or byte has
its own address. Main memory is a repository of quickly accessible data shared
by the CPU and I/O devices. The central processor reads instructions from main
memory during the instruction-fetch cycle and both reads and writes data from
main memory during the data-fetch cycle (on a Von Neumann architecture).
The main memory is generally the only large storage device that the CPU is able
to address and access directly. For example, for the CPU to process data from
disk, those data must first be transferred to main memory by CPU-generated
I/O calls. In the same way, instructions must be in memory for the CPU to
execute them.
For a program to be executed, it must be mapped to absolute addresses and
loaded into memory. As the program executes, it accesses program instructions
and data from memory by generating these absolute addresses. Eventually,
the program terminates, its memory space is declared available, and the next
program can be loaded and executed.
To improve both the utilization of the CPU and the speed of the computer's
response to its users, general-purpose computers must keep several programs
in memory, creating a need for memory management. Many different memorymanagement
schemes are used. These schemes reflect various approaches, and
the effectiveness of any given algorithm depends on the situation. In selecting a
memory-management scheme for a specific system, we must take into account
many factors especially on the hardware design of the system. Each algorithm
requires its own hardware support.
The operating system is responsible for the following activities in connection
with memory management:
  Keeping track of which parts of memory are currently being used and by
whom
  Deciding which processes (or parts thereof) and data to move into and out
of memory
  Allocating and deallocating memory space as needed
Memory-management techniques will be discussed in   s 8 and 9.
1.8 Storage Management
To make the computer system convenient for users, the operating system
provides a uniform, logical view of information storage. The operating system
abstracts from the physical properties of its storage devices to define a logical
storage unit, the file. The operating system maps files onto physical media and
accesses these files via the storage devices.
1.8.1 File-System Management
File management is one of the most visible components of an operating system.
Computers can store information on several different types of physical media.
Magnetic disk, optical disk, and magnetic tape are the most common. Each
of these media has its own characteristics and physical organization. Each
medium is controlled by a device, such as a disk drive or tape drive, that
1.8 Storage Management 23
also has its own unique characteristics. These properties include accessspeed,
capacity', data-transfer rate, and access method (sequential or random).
A file is a collection of related information defined by its creator. Commonly,
files represent programs (both source and object forms) and data. Data files may
be numeric, alphabetic, alphanumeric, or binary. Files may be free-form (for
example, text files), or they may be formatted rigidly (for example, fixed fields).
Clearly, the concept of a file is an extremely general one.
The operating system implements the abstract concept of a file by managing
mass storage media, such as tapes and disks, and the devices that control them.
Also, files are normally organized into directories to make them easier to use-
Finally, when multiple users have access to files, it may be desirable to control
by whom and in what ways (for example, read, write, append) files may be
accessed.
The operating system is responsible for the following activities in connection
with file management:
  Creating and deleting files
  Creating and deleting directories to organize files
  Supporting primitives for manipulating files and directories
  Mapping files onto secondary storage
  Backing up files on stable (nonvolatile) storage media
File-management techniques will be discussed in   s 10 and 11.
1.8.2 Mass-Storage Management
As we have already seen, because main memory is too small to accommodate
all data and programs, and because the data that it holds are lost when power
is lost, the computer system must provide secondary storage to back up main
memory. Most modern computer systems use disks as the principal on-line
storage medium for both programs and data. Most programs including
compilers, assemblers, word processors, editors, and formatters are stored
on a disk until loaded into memory and then use the disk as both the source
and destination of their processing. Hence, the proper management of disk
storage is of central importance to a computer system. The operating system is
responsible for the following activities in connection with disk management:
  Free-space management
  Storage allocation
  Disk scheduling
Because secondary storage is used frequently, it must be used efficiently. The
entire speed of operation of a computer may hinge on the speeds of the disk
subsystem and of the algorithms that manipulate that subsystem.
There are, however, many uses for storage that is slower and lower in cost
(and sometimes of higher capacity) than secondary storage. Backups of disk
data, seldom-used data, and long-term archival storage are some examples.
24    1    
Magnetic tape drives and their tapes and CD and DVD drives and platters are
typical tertiary storage devices. The media (tapes and optical platters) vary
between WORM (write-once, read-many-times) and RW (read-write) formats.
Tertiary storage is not crucial to system performance, but it still must
be managed. Some operating systems take on this task, while others leave
tertiary-storage management to application programs. Some of the functions
that operating systems can provide include mounting and unmounting media
in devices, allocating and freeing the devices for exclusive use by processes,
and migrating data from secondary to tertiary storage.
Techniques for secondary and tertiary storage management will be discussed
in    12.
1.8.3 Caching
Caching is an important principle of computer systems. Information is
normally kept in some storage system (such as main memory). As it is used,
it is copied into a faster storage system the cache on a temporary basis.
When we need a particular piece of information, we first check whether it is
in the cache. If it is, we use the information directly from the cache; if it is not,
we use the information from the source, putting a copy in the cache under the
assumption that we will need it again soon.
In addition, internal programmable registers, such as index registers,
provide a high-speed cache for main memory. The programmer (or compiler)
implements the register-allocation and register-replacement algorithms to
decide which information to keep in registers and which to keep in main
memory. There are also caches that are implemented totally in hardware. For
instance, most systems have an instruction cache to hold the next instructions
expected to be executed. Without this cache, the CPU would have to wait
several cycles while an instruction was fetched from main memory. For similar
reasons, most systems have one or more high-speed data caches in the memory
hierarchy. We are not concerned with these hardware-only caches in this text,
since they are outside the control of the operating system.
Because caches have limited size, cache management is an important
design problem. Careful selection of the cache size and of a replacement
policy can result in greatly increased performance. See   1.9 for a storage
performance comparison in large workstations and small servers that shows
the need for caching. Various replacement algorithms for software-controlled
caches are discussed in    9.
Main memory can be viewed as a fast cache for secondary storage, since
data in secondary storage must be copied into main memory for use, and
data must be in main memory before being moved to secondary storage for
safekeeping. The file-system data, which resides permanently on secondary
storage, may appear on several levels in the storage hierarchy. At the highest
level, the operating system may maintain a cache of file-system data in main
memory Also, electronic RAM disks (also known as solid-state disks) may be
used for high-speed storage that is accessed through the file-system interface.
The bulk of secondary storage is on magnetic disks. The magnetic-disk storage,
in turn, is often backed up onto magnetic tapes or removable disks to protect
against data loss in case of a hard-disk failure. Some systems automatically
1.8 Storage Management 25
Level
$!$r#$$f3'll
^cqess time Insji;:;: J
lanaielf;:;:;: | :i
S a e k e i f l i s y : ; 1 : - ;:; ; :
i ;: \ z )   -:   '  " ; :
isgistprs.;;: %.%%% .{;eacN. UM: U: j
Ifflfflif
':mul^ll;pM,ttfeJiS
cfoffipifer :;: |:;: |:;:
6Sflher ;:" :: " I : " ; '1;:'":;:'
  0 S - 2 S ; : S ;:;:,.;;,;
: 5Q0|| # , i ) | 1  !
iriafpari:: | f:|::i
 rilaiji memory::; : :
3 : :  :: '::  ' -:;
raaJft njenwJY; J
i otjeMini sysfew
:disl<: !:; :;; :|; :; :;:
:4:; : : :
:cfisk:Sti3fgge ;i; :;i
:s.0|3;Gl.;: ::; ^
"riaiHltieBsi:;::
m-^SK ;; M;
:opep!ti|:sii si;etTi
::dpi5fia|)e; j; ;f
  1.9 Performance of various levels of storage.
archive old file data from secondary storage to tertiary storage, such as tape
jukeboxes, to lower the storage cost (see    12).
The movement of information between levels of a storage hierarchy may
be either explicit or implicit, depending on the hardware design and the
controlling operating-system software. For instance, data transfer from cache
to CPU and registers is usually a hardware function, with no operating-system
intervention. In contrast, transfer of data from disk to memory is usually
controlled by the operating system.
In a hierarchical storage structure, the same data may appear in different
levels of the storage system. For example, suppose that an integer A that is to
be incremented by 1 is located in file B, and file B resides on magnetic disk.
The increment operation proceeds by first issuing an I/O operation to copy the
disk block on which A resides to main memory. This operation is followed by
copying A to the cache and to an internal register. Thus, the copy of A appears
in several places: on the magnetic disk, in main memory, in the cache, and in an
internal register (see   1.10). Once the increment takes place in the internal
register, the value of A differs in the various storage systems. The value of A
becomes the same only after the new value of A is written from the internal
register back to the magnetic disk.
In a computing environment where only one process executes at a time,
this arrangement poses no difficulties, since an access to integer A will always
be to the copy at the highest level of the hierarchy. However, in a multitasking
environment, where the CPU is switched back and forth among various
processes, extreme care must be taken to ensure that, if several processes wish
to access A, then each of these processes will obtain the most recently updated
value of A.
magnetic
disk
main
memory
hardware
register
  1.10 Migration of integer A from disk to register.
26    1    
The situation becomes more complicated in a multiprocessor environment
where, in addition to maintaining internal registers, each of the CPUs also
contains a local cache. In such an environment, a copy of A may exist
simultaneously in several caches. Since the various CPUs can all execute
concurrently, we must make sure that an update to the value of A in one cache
is immediately reflected in all other caches where A resides. This situation is
called cache coherency, and it is usually a hardware problem (handled below
the operating-system level).
In a distributed environment, the situation becomes even more complex.
In this environment, several copies (or replicas) of the same file can be kept
on different computers that are distributed in space. Since the various replicas
may be accessed and updated concurrently, some distributed systems ensure
that, when a replica is updated in one place, all other replicas are brought up
to date as soon as possible. There are various ways to achieve this guarantee,
as we discuss in    17.
1.8.4 I/O Systems
One of the purposes of an operating system is to hide the peculiarities of specific
hardware devices from the user. For example, in UNIX, the peculiarities of I/O
devices are hidden from the bulk of the operating system itself by the I/O
subsystem. The I/O subsystem consists of several components:
  A memory-management component that includes buffering, caching, and
spooling
  A general device-driver interface
  Drivers for specific hardware devices
Only the device driver knows the peculiarities of the specific device to which
it is assigned.
We discussed in Section 1.2.3 how interrupt handlers and device drivers are
used in the construction of efficient I/O subsystems. In    13, we discuss
how the I/O subsystem interfaces to the other system components, manages
devices, transfers data, and detects I/O completion.
1.9 Protection and Security
If a computer system has multiple users and allows the concurrent execution
of multiple processes, then access to data must be regulated. For that purpose,
mechanisms ensure that files, memory segments, CPU, and other resources can
be operated on by only those processes that have gained proper authorization
from the operating system. For example, memory-addressing hardware
ensures that a process can execute only within its own address space. The
timer ensures that no process can gain control of the CPU without eventually
relinquishing control. Device-control registers are not accessible to users, so
the integrity of the various peripheral devices is protected.
Protection, then, is any mechanism for controlling the access of processes
or users to the resources defined by a computer system. This mechanism must
1.9 Protection and Security 27
provide means for specification of the controls to be imposed and means for
enforcement.
Protection can improve reliability by detecting latent errors at the interfaces
between component subsystems. Early detection of interface errors can often
prevent contamination of a healthy subsystem by another subsystem that
is malfunctioning. An unprotected resource cannot defend against use (or
misuse) by an unauthorized or incompetent user. A protection-oriented system
provides a means to distinguish between authorized and unauthorized usage,
as we discuss in    14.
A system can have adequate protection but still be prone to failure and
allow inappropriate access. Consider a user whose authentication information
(her means of identifying herself to the system) is stolen. Her data could be
copied or deleted, even though file and memory protection are working. It is
the job of security to defend a system from external and internal attacks. Such
attacks spread across a huge range and include viruses and worms, denial-ofservice
attacks (which use all of a system's resources and so keep legitimate
users out of the system), identity theft, and theft of service (unauthorized use
of a system). Prevention of some of these attacks is consider an operatingsystem
function on some systems, while others leave the prevention to policy
or additional software. Due to the alarming rise in security incidents, operatingsystem
security features represent a fast-growing area of research and of
implementation. Security is discussed in    15.
Protection and security require the system to be able to distinguish among
all its users. Most operating systems maintain a list of user names and
associated user identifiers (user IDs). In Windows NT parlance, this is a security
ID (SID). These numerical IDs are unique, one per user. When a user logs in
to the system, the authentication stage determines the appropriate user ID for
the user. That user ID is associated with all of the user's processes and threads.
When an ID needs to be user readable, it is translated back to the user name
via the user name list.
In some circumstances, we wish to distinguish among sets of users rather
than individual users. For example, the owner of a file on a UNIX system may be
allowed to issue all operations on that file, whereas a selected set of users may
only be allowed to read the file. To accomplish this, we need to define a group
name and the set of users belonging to that group. Group functionality can
be implemented as a system-wide list of group names and group identifiers.
A user can be in one or more groups, depending on operating-system design
decisions. The user's group IDs are also included in every associated process
and thread.
In the course of normal use of a system, the user ID and group ID
for a user are sufficient. However, a user sometimes needs to escalate
privileges to gain extra permissions for an activity. The user may need
access to a device that is restricted, for example. Operating systems provide
various methods to allow privilege escalation. On UNIX, for example,
the setuid attribute on a program causes that program to run with the
user ID of the owner of the file, rather than the current user's ID. The process
runs with this effective UID until it turns off the extra privileges or
terminates. Consider an example of how this is done in Solaris 10. User
pbg has user ID 101 and group ID 14, which are assigned via /etc/passwd:
pbg:x:101:14::/export/home/pbg:/usr/bin/bash
28    1    
1.10 Distributed Systems *
A distributed system is a collection of physically separate, possibly heterogeneous
computer systems that are networked to provide the users with access
to the various resources that the system maintains. Access to a shared resource
increases computation speed, functionality, data availability, and reliability.
Some operating systems generalize network access as a form of file access, with
the details of networking contained in the network interface's device driver.
Others make users specifically invoke network functions. Generally, systems
contain a mix of the two modes for example FTP and NFS. The protocols
that create a distributed system can greatly affect that system's utility and
popularity.
A network, in the simplest terms, is a communication path between
two or more systems. Distributed systems depend on networking for their
functionality. Networks vary by the protocols used, the distances between
nodes, and the transport media. TCP/IP is the most common network protocol,
although ATM and other protocols are in widespread use. Likewise, operatingsystem
support of protocols varies. Most operating systems support TCP/IP,
including the Windows and UNIX operating systems. Some systems support
proprietary protocols to suit their needs. To an operating system, a network
protocol simply needs an interface device a network adapter, for example- 
with a device driver to manage it, as well as software to handle data. These
concepts are discussed throughout this book.
Networks are characterized based on the distances between their nodes.
A local-area network (LAN) connects computers within a room, a floor,
or a building. A wide-area network (WAN) usually links buildings, cities,
or countries. A global company may have a WAN to connect its offices
worldwide. These networks may run one protocol or several protocols. The
continuing advent of new technologies brings about new forms of networks.
For example, a metropolitan-area network (MAN) could link buildings within
a city. BlueTooth and 802.11 devices use wireless technology to communicate
over a distance of several feet, in essence creating a small-area network such
as might be found in a home.
The media to carry networks are equally varied. They include copper wires,
fiber strands, and wireless transmissions between satellites, microwave dishes,
and radios. When computing devices are connected to cellular phones, they
create a network. Even very short-range infrared communication can be used
for networking. At a rudimentary level, whenever computers communicate,
they use or create a network. These networks also vary in their performance
and reliability.
Some operating systems have taken the concept of networks and distributed
systems further than the notion of providing network connectivity. A
network operating system is an operating system that provides features such
as file sharing across the network and that includes a communication scheme
that allows different processes on different computers to exchange messages.
A computer running a network operating system acts autonomously from all
other computers on the network, although it is aware of the network and is
able to communicate with other networked computers. A distributed operating
system provides a less autonomous environment: The different operating
1.11 Special-Purpose Systems 29
systems communicate closely enough to provide the illusion that only a single
operating system controls the network.
We cover computer networks and distributed systems in   s 16
through 18.
1.11 Special-Purpose Systems
The discussion thus far has focused on general-purpose computer systems
that we are all familiar with. There are, however, different classes of computer
systems whose functions are more limited and whose objective is to deal with
limited computation domains.
1.11.1 Real-Time Embedded Systems
Embedded computers are the most prevalent form of computers in existence.
These devices are found everywhere, from car engines and manufacturing
robots to VCRs and microwave ovens. They tend to have very specific tasks.
The systems they run on are usually primitive, and so the operating systems
provide limited features. Usually, they have little or no user interface, preferring
to spend their time monitoring and managing hardware devices, such as
automobile engines and robotic arms.
These embedded systems vary considerably. Some are general-purpose
computers, running standard operating systems such as UNIX with
special-purpose applications to implement the functionality. Others are
hardware devices with a special-purpose embedded operating system
providing just the functionality desired. Yet others are hardware devices
with application-specific integrated circuits (ASICs) that perform their tasks
without an operating system.
The use of embedded systems continues to expand. The power of these
devices, both as standalone units and as members of networks and the Web,
is sure to increase as well. Even now, entire houses can be computerized, so
that a central computer either a general-purpose computer or an embedded
system can control heating and lighting, alarm systems, and even coffee
makers. Web access can enable a home owner to tell the house to heat up
before she arrives home. Someday, the refrigerator may call the grocery store
when it notices the milk is gone.
Embedded systems almost always run real-time operating systems. A
real-time system is used when rigid time requirements have been placed on
the operation of a processor or the flow of data; thus, it is often used as a
control device in a dedicated application. Sensors bring data to the computer.
The computer must analyze the data and possibly adjust controls to modify
the sensor inputs. Systems that control scientific experiments, medical imaging
systems, industrial control systems, and certain display systems are realtime
systems. Some automobile-engine fuel-injection systems, home-appliance
controllers, and weapon systems are also real-time systems.
A real-time system has well-defined, fixed time constraints. Processing
mustbe done within the defined constraints, or the system will fail. For instance,
it would not do for a robot arm to be instructed to halt after it had smashed
into the car it was building. A real-time system functions correctly only if it
30    1    
returns the correct result within its time constraints. Contrast this system with
a time-sharing system, where it is desirable (but not mandatory) to respond
quickly, or a batch system, which may have no time constraints at all.
In    19, we cover real-time embedded systems in great detail. In
   5, we consider the scheduling facility needed to implement real-time
functionality in an operating system. In    9, we describe the design
of memory management for real-time computing. Finally, in    22, we
describe the real-time components of the Windows XP operating system.
1.11.2 Multimedia Systems
Most operating systems are designed to handle conventional data such as
text files, programs, word-processing documents, and spreadsheets. However,
a recent trend in technology is the incorporation of multimedia data into
computer systems. Multimedia data consist of audio and video files as well as
conventional files. These data differ from conventional data in that multimedia
data such as frames of video must be delivered (streamed) according to
certain time restrictions (for example, 30 frames per second).
Multimedia describes a wide range of applications that are in popular use
today. These include audio files such as MP3 DVD movies, video conferencing,
and short video clips of movie previews or news stories downloaded over the
Internet. Multimedia applications may also include live webcasts (broadcasting
over the World Wide Web) of speeches or sporting events and even live
webcams that allow a viewer in Manhattan to observe customers at a cafe
in Paris. Multimedia applications need not be either audio or video; rather, a
multimedia application often includes a combination of both. For example, a
movie may consist of separate audio and video tracks. Nor must multimedia
applications be delivered only to desktop personal computers. Increasingly,
they are being directed toward smaller devices, including PDAs and cellular
telephones. For example, a stock trader may have stock quotes delivered
wirelessly and in real time to his PDA.
In    20, we explore the demands of multimedia applications, how
multimedia data differ from conventional data, and how the nature of these
data affects the desigii of operating systems that support the requirements of
multimedia systems.
1.11.3 Handheld Systems
Handheld systems include personal digital assistants (PDAs), such as Palm
and Pocket-PCs, and cellular telephones, many of which use special-purpose
embedded operating systems. Developers of handheld systems and applications
face many challenges, most of which are due to the limited size of such
devices. For example, a PDA is typically about 5 inches in height and 3 inches
in width, and it weighs less than one-half pound. Because of their size, most
handheld devices have a small amount of memory, slow processors, and small
display screens. We will take a look now at each of these limitations.
The amount of physical memory in a handheld depends upon the device,
but typically is is somewhere between 512 KB and 128 MB. (Contrast this with a
typical PC or workstation, which may have several gigabytes of memory!)
As a result, the operating system and applications must manage memory
efficiently. This includes returning all allocated memory back to the memory
1.12 Computing Environments 31
manager when the memory is not being used. In    9, we will explore
virtual memory, which allows developers to write programs that behave as if
the system has more memory than is physically available. Currently, not many
handheld devices use virtual memory techniques, so program developers must
work within the confines of limited physical memory.
A second issue of concern to developers of handheld devices is the speed
of the processor used in the devices. Processors for most handheld devices
run at a fraction of the speed of a processor in a PC. Faster processors require
more power. To include a faster processor in a handheld device would require
a larger battery, which would take up more space and would have to be
replaced (or recharged) more frequently. Most handheld devices use smaller,
slower processors that consume less power. Therefore, the operating system
and applications must be designed not to tax the processor.
The last issue confronting program designers for handheld devices is I/O.
A lack of physical space limits input methods to small keyboards, handwriting
recognition, or small screen-based keyboards. The small display screens limit
output options. Whereas a monitor for a home computer may measure up to
30 inches, the display for a handheld device is often no more than 3 inches
square. Familiar tasks, such as reading e-mail and browsing web pages, must
be condensed into smaller displays. One approach for displaying the content
in web pages is web clipping, where only a small subset of a web page is
delivered and displayed on the handheld device.
Some handheld devices use wireless technology, such as BlueTooth or
802.11, allowing remote access to e-mail and web browsing. Cellular telephones
with connectivity to the Internet fall into this category. However, for PDAs that
do not provide wireless access, downloading data typically requires the user
to first download the data to a PC or workstation and then download the data
to the PDA. Some PDAs allow data to be directly copied from one device to
another using an infrared link.
Generally, the limitations in the functionality of PDAs are balanced by
their convenience and portability. Their use continues to expand as network
connections become more available and other options, such as digital cameras
and MP3 players, expand their utility.
1.12 Computing Environments
So far, we have provided an overview of computer-system organization and
major operating-system components. We conclude with a brief overview of
how these are used in a variety of computing environments.
1.12.1 Traditional Computing
As computing matures, the lines separating many of the traditional computing
environments are blurring. Consider the "typical office environment." Just a
few years ago, this environment consisted of PCs connected to a network,
with servers providing file and print services. Remote access was awkward,
and portability was achieved by use of laptop computers. Terminals attached
to mainframes were prevalent at many companies as well, with even fewer
remote access and portability options.
32    1    
The current trend is toward providing more ways to access these computing
environments. Web technologies are stretching the boundaries of traditional
computing. Companies establish portals, which provide web accessibility
to their internal servers. Network computers are essentially terminals that
understand web-based computing. Handheld computers can synchronize with
PCs to allow very portable use of company information. Handheld PDAs can
also connect to wireless networks to use the company's web portal (as well as
the myriad other web resources).
At home, most users had a single computer with a slow modem connection
to the office, the Internet, or both. Today, network-connection speeds once
available only at great cost are relatively inexpensive, giving home users more
access to more data. These fast data connections are allowing home computers
to serve up web pages and to run networks that include printers, client PCs,
and servers. Some homes even have firewalls to protect their networks from
security breaches. Those firewalls cost thousands of dollars a few years ago
and did not even exist a decade ago.
In the latter half of the previous century, computing resources were scarce.
(Before that, they were nonexistent!) For a period of time, systems were either
batch or interactive. Batch system processed jobs in bulk, with predetermined
input (from files or other sources of data). Interactive systems waited for
input from users. To optimize the use of the computing resources, multiple
users shared time on these systems. Time-sharing systems used a timer and
scheduling algorithms to rapidly cycle processes through the CPU, giving each
user a share of the resources.
Today, traditional time-sharing systems are uncommon. The same scheduling
technique is still in use on workstations and servers, but frequently the
processes are all owned by the same user (or a single user and the operating
system). User processes, and system processes that provide services to the user,
are managed so that each frequently gets a slice of computer time. Consider
the windows created while a user is working on a PC, for example, and the fact
that they may be performing different tasks at the same time.
1.12.2 Client-Server Computing
As PCs have become faster, more powerful, and cheaper, designers have
shifted away from centralized system architecture. Terminals connected to
centralized systems are now being supplanted by PCs. Correspondingly, userinterface
functionality once handled directly by the centralized systems is
increasingly being handled by the PCs. As a result, many of todays systems act
as server systems to satisfy requests generated by client systems. This form
of specialized distributed system, called client-server system, has the general
structure depicted in   1.11.
Server systems can be broadly categorized as compute servers and file
servers:
  The compute-server system provides an interface to which a client can
send a request to perform an action (for example, read data); in response,
the server executes the action and sends back results to the client. A server
running a database that responds to client requests for data is an example
of such a svstem.
1.12 Computing Environments 33
client client ! i client client:
  network
server
  1.11 General structure of a client-server system.
  The file-server system provides a file-system interface where clients can
create, update, read, and delete files. An example of such a system is a web
server that delivers files to clients running web browsers.'
1.12.3 Peer-to-Peer Computing
Another structure for a distributed system is the peer-to-peer (P2P) system
model. In this model, clients and servers are not distinguished from one
another; instead, all nodes within the system are considered peers, and each
may act as either a client or a server, depending on whether it is requesting or
providing a service. Peer-to-peer systems offer an advantage over traditional
client-server systems. In a client-server system, the server is a bottleneck; but
in a peer-to-peer system, services can be provided by several nodes distributed
throughout the network.
To participate in a peer-to-peer system, a node must first join the network
of peers. Once a node has joined the network, it can begin providing services
to and requesting services from other nodes in the network. Determining
what services are available is accomplished in one of two general ways:
  When a node joins a network, it registers its service with a centralized
lookup service on the network. Any node desiring a specific service first
contacts this centralized lookup service to determine which node provides
the service. The remainder of the communication takes place between the
client and the service provider.
  A peer acting as a client must first discover what node provides a desired
service by broadcasting a request for the service to all other nodes in the
network. The node (or nodes) providing that service responds to the peer
making the request. To support this approach, a discovery protocol must be
provided that allows peers to discover services provided by other peers in
the network.
Peer-to-peer networks gained widespread popularity in the late 1990s with
several file-sharing services, such as Napster and Gnutella, that enable peers
to exchange files with one another. The Napster system uses an approach
similar to the first type described above: a centralized server maintains an
index of all files stored on peer nodes in the Napster network, and the actual
exchanging of files takes place between the peer nodes. The Gnutella system
uses a technique similar to the second type: a client broadcasts file requests
to other nodes in the system, and nodes that can service the request respond
directly to the client. The future of exchanging files remains uncertain because
34    1    
many of the files are copyrighted (music, for example), and there are* laws
governing the distribution of copyrighted material. In any case, though, peerto-
peer technology undoubtedly will play a role in the future of many sendees,
such as searching, file exchange, and e-mail.
1.12.4 Web-Based Computing
The Web has become ubiquitous, leading to more access by a wider variety of
devices than was dreamt of a few years ago. PCs are still the most prevalent
access devices, with workstations, handheld PDAs, and even cell phones also
providing access.
Web computing has increased the emphasis on networking. Devices that
were not previously networked now include wired or wireless access. Devices
that were networked now have faster network connectivity, provided by either
improved networking technology, optimized network implementation code,
or both.
The implementation of web-based computing has given rise to new
categories of devices, such as load balancers, which distribute network
connections among a pool of similar servers. Operating systems like Windows
95, which acted as web clients, have evolved into Linux and Windows XP, which
can act as web servers as well as clients. Generally, the Web has increased the
complexity of devices, because their users require them to be web-enabled.
1.13 Summary
An operating system is software that manages the computer hardware as well
as providing an environment for application programs to run. Perhaps the
most visible aspect of an operating system is the interface to the computer
system, it provides to the human user.
For a computer to do its job of executing programs, the programs must be
in main memory. Main memory is the only large storage area that the processor
can access directly. It is an array of words or bytes, ranging in size from millions
to billions. Each word in memory has its own address. The main memory is
usually a volatile storage device that loses its contents when power is turned off
or lost. Most computer systems provide secondary storage as an extension of
main memory. Secondary storage provides a form of non-volatile storage that
is capable of holding large quantities of data permanently. The most common
secondary-storage device is a magnetic disk, which provides storage of both
programs and data.
The wide variety of storage systems in a computer system can be organized
in a hierarchy according to speed and cost. The higher levels are expensive,
but they are fast. As we move down the hierarchy, the cost per bit generallydecreases,
whereas the access time generally increases.
There are several different strategies for designing a computer system.
Uniprocessor systems have only a single processor while multiprocessor
systems contain two or more processors that share physical memory and
peripheral devices. The most common multiprocessor design is symmetric
multiprocessing (or SMP), where all processors are considered peers and run
1.13 Summary 35
independently of one another. Clustered systems are a specialized form of
multiprocessor systems and consist of multiple computer systems connected
by a local area network.
To best utilize the CPU, modern operating systems employ multiprogramming/
which allows several jobs to be in memory at the same time, thus ensuring
the CPU always has a job to execute. Timesharing systems are an extension
of multiprogramming whereby CPU scheduling algorithms rapidly switch
between jobs, thus providing the illusion each job is running concurrently.
The operating system must ensure correct operation of the computer
system. To prevent user programs from interfering with the proper operation of
the system, the hardware has two modes: user mode and kernel mode. Various
instructions (such as I/O instructions and halt instructions) are privileged and
can be executed only in kernel mode. The memory in which the operating
system resides must also be protected from modification by the user. A timer
prevents infinite loops. These facilities (dual mode, privileged instructions,
memory protection, and timer interrupt) are basic building blocks used by
operating systems to achieve correct operation.
A process (or job) is the fundamental unit of work in an operating system.
Process management includes creating and deleting processes and providing
mechanisms for processes to communicate and synchronize with another.
An operating system manages memory by keeping track of what parts of
memory are being used and by whom. The operating system is also responsible
for dynamically allocating and freeing memory space. Storage space is also
managed by the operating system and this includes providing file systems for
representing files and directories and managing space on mass storage devices.
Operating systems must also be concerned with protecting and securing
the operating system and users. Protection are mechanisms that control the
access of processes or users to the resources made available by the computer
system. Security measures are responsible for defending a computer system
from external or internal attacks.
Distributed systems allow users to share resources on geographically
dispersed hosts connected via a computer network. Services may be provided
through either the client-server model or the peer-to-peer model. In a clustered
system, multiple machines can perform computations on data residing on
shared storage, and computing can continue even when some subset of cluster
members fails.
LANs and WANs are the two basic types of networks. LANs enable
processors distributed over a small geographical area to communicate, whereas
WANs allow processors distributed over a larger area to communicate. LANs
typically are faster than WANs.
There are several computer systems that serve specific purposes. These
include real-time operating systems designed for embedded environments
such as consumer devices, automobiles, and robotics. Real-time operating
systems have well defined, fixed time constraints. Processing must be done
within the defined constraints, or the system will fail. Multimedia systems
involve the delivery of multimedia data and often have special requirements of
displaying or playing audio, video, or synchronized audio and video streams.
Recently, the influence of the Internet and the World Wide Web has
encouraged the development of modern operating systems that include web
browsers and networking and communication software as integral features.
