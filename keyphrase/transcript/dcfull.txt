 Digital Circuits and Systems
Prof. S. Srinivasan Department of Electrical Engineering
Indian Institute of Technology Madras
 Lecture - 1 Introduction to Digital Circuits 

This course is on digital circuits and digital systems. We have this, signals. A signal is a variation in a physical parameter, temperature variation is a signal, speech as I speak now it?s a signal, video is a signal, light intensity variation. Now any of these signals that you get need to be may be processed to be available to the other end may be stored so you do lot of processing of signals in real life. For example, if you take a microphone the speech signal that you give into the microphone if necessary it needs to be amplified and then given out as a signal out of the speaker, the sound signal out of the speaker. So it is a typical signal processing scenario.

(Refer Slide Time 1:58)
 
 


We are in the electrical engineering domain we talk about only electrical signals that means variation of an electrical quantity a voltage or a current as a function of time. A signal is defined as a variation of electrical quantity usually a voltage or a current with time. Of course you can also a signal which does not change with time then it is not called a signal any more it is the DC value we say. For example, if you know that the value is not going to change there is no need for processing so you know the value so you can use the value wherever you want to use it. 

Now, once you have this variation any signal that naturally occurs the speech or temperature variation or as I said the illumination changes in the television or a seismic earthquake activity any signal first you need to convert it into electrical variations some other are mechanical so other physical parameters so there is a transducer a sort of a device this device which converts non electrical quantity into an electrical quantity electrical signal known as the transducer. So the output of the transducers in electrical signal is where we define the signal as the variation of the parameter of interests the voltage or current with time. 

Normally a signal can take any value of course within given limits and different instance of time a signal varies continuously. For example you have a time variation of signal voltage level of a signal as a function of time, if I plot like this then any number of values this signal can take as a function of time 

(Refer Slide Time 5:48)

 


But of course there is always a limit, what is the minimum, let us call this minimum value as 0 and maximum value as Vmax. With two different values we define and say that signal always varies within this range, this is the range of the signal. And at any instant of time it can take any value and what is the instant of time is also not defined, I can make a measurement here and immediately at very next instant of time or I can do a measurement here and measure much later here nothing is remaining here. This variation of signal which can take any value between these two limits and such a signal is called analog signal. Analog signal or analog quantity can take any value at any instant of time within of course the limit defined within the range specified. 






(Refer Slide Time 6:28)

        

And on the other one I want to process the signal only at discrete instance of time. Suppose I want to monitor the temperature of a system every minute or every hour or every thirty minutes or whatever you discretize the time at which you look at the value of the signal the signal will vary continuously all the time and you are looking only at the discrete instance of time at a definite instance of time only there you are looking at and such a signal suppose I put this value I will have equal intervals of time so call this t0 the starting point then t1 t2 need not be equal but just to explain it little easier I make it at equal intervals of time so I will monitor the value of the signal v(t) at instance of time t0 t1 t2 t3 t4 as long as I want or as long as I am interested in the parameter so such a signal is called as the discrete time signal. The signal still continuously varies.

An analog signal is a signal which takes any value between the two defined limits as a function of time. But even though the signal varies I am only interested in looking at specific intervals of time and such a signal is a subset of the analog signal that is called a discrete time signal. The problem in these two cases whether you want to continuously monitor what is continuous finally it has to be discrete. Even it is a one micro second then what happens between one microseconds even one nanosecond can change in between these. 










(Refer Slide Time 7:39)

 

Finally we can only observe. Physical parameter will vary with input and output but if you become an observer the observation can only be discrete.

But whether it is a discrete time signal or analog time signal the variation of the signals between these two limits is a continuous variation there is no defined points by which it can vary. What I am saying is supposing my initial value is 0V and Vmax is 5V as an example, as an example I make this 5V I am only allowing this signal to change from 0 to 5V and within this 0 to 5V it can take any value. 

You may have difficulty in representing because you have limitations in the digits you are having in your calculator or I cannot represent any number beyond a particular number of digits to be meaningful. But theoretically it can have number of levels between 0V and 5V. Now when you are trying to transmit a signal because after the entire signal itself as no meaning unless you use it somewhere. 

As a change in the speech, when I speak my speech is picked up in the microphone and it gets converted into electrical signals and the electrical signal is amplified by the amplifier and then is put out on the speaker which brings it out as a speech signal. So there is a processing involved in any signal and if there is no processing then we are not interested in any signal. We are not interested in looking at a signal just for the variation sake. We don?t want to stare at a signal just because it?s nice to see, it keeps changing it?s nice to watch so I am sitting and watching it, it is like a wave in the ocean. When you go to the beach and sit there and watch the waves I like to do that myself because that?s only for fun, for relaxation. 

But when you have a signal you have to use that signal somewhere. You transmit it or you store it for later use, one of the two things. I pick up the signal and process it and give it as an output to the another system another transducer which will convert this signal into the physical parameter like a sound or a light or whatever or I may even store it for later use. 

Suppose I want to know yesterday?s temperature variation over today?s temperature at 11 O?clock yesterday what was the temperature and at 11 O? clock today I want to know what is the temperature and at 11 O?clock take the temperature reading store it, today I take the 11 O?clock temperature and say that today is hotter than yesterday. 

So either you store or transmit it when I do that how accurately can I represent my variations within these limits of 0V and 5V as I said I can take infinite number of values I may not be limited by the channel, how accurately can I send the signal, I can directly send it or the output I can receive which will be an analog signal. But if you want to store it and reproduce it I would like to be limited by the number of digits I want to use. That way I can safely say this is within that and within that limit I will define various levels the signals can take and I will say the signal is in this level tomorrow in this level sot there is a change of so many levels. 

So if I further discretize it I discretize the time to start with. originally I had a signal with continuous time and continuous amplitude variation then I let the amplitude continuously vary but discretize the time, I am going to introduce one more discretization in the amplitude I will say I will only let the signal take a specific amount of level specific number of discrete levels so 0 to 5V even though signals allow to vary I have no control over the input signal, the temperature variation and when I record it I only record it as discrete levels or when I process it I only process those discrete levels, when I transmit it I only transmit those discrete levels. 

Of course how accurately I want the reproduction depend upon how many levels I want to have, I have only two levels, it is 0 or 1, 0V or 5V is the signal present or not present that is too crude or I can have four levels 0 to 1.25, 1.25 to 2.5, 2.5 to 3.75 and 3.75 to 5. I can say if signal is less than 1.25 then it is level 1, between 1.25 to 2.5 I will say it is level 2, 2.5 to 3.75 I will say level 3 signal and 3.75 to 5 I will say level 4 signal then you know that the signal is in this range. Therefore more and more levels are introduced and I can introduce more and more accuracy in transmission and reproduction but still it is a discrete level. So when I discretize the amplitude in addition to discretize the time I get what is known as digital signal. That means I will only allow this variations let us called this level 1 or this I write as 0, I will say L0, it will be level I, L2, L3, L4 etc. 










(Refer Slide Time 15:07)

 

Depending on how narrow or broad these ranges are the total number of steps will be decided. The total number of steps to be decided depending on the level of each of these steps I am going to take. 

Now I will say suppose I want to represent the signal value at t1 it is between L2 and L3. I cannot say it is between L2 and L3 it is not possible to store between L2 and L3 or it is not possible to transmit between L2 and L3 I have to either transmit between L2 and L3, I have to make a prior understanding I will always round it of to the nearest lower level or nearest upper level. 

(Refer Slide Time 15:24)

 
So for our example in this case let us always round it of to the nearest lower level I will say at t0 the signal is L2, at t1 also the signal is L2, at t2 the signal is L3 because here it has become between L3 and L4 at t2, at t3 it is L4 at t4 it may be L5 and so forth. 

Hence each of these levels can be stored or represented by a smaller number of digits than originally it had intended to be. Suppose I have infinite number of levels I need infinite number of digits to represent it. Now each of these levels is going to have discrete levels so I will have fewer digits to represent, fewer for storing and fewer levels to transmit in the case of transmission. 

Now let us say there are only a total of eight steps, between 0 and 5V I divide this range into only eight steps, I don?t expect much variation in temperature or I am not interested to find a variation, or I am not interested to find whether it is too hot today or too cool today it is all like if know where the temperature is in this range of 0 to 5V in eight levels you tell me and if I tell you that then I will use eight levels so these eight levels can be represented by eight different values so it is easy to store eight different values and transmit eight different values rather than having to store infinite, supposing the signal can be anywhere from 0 to 5V if is 4.7392481 I should have so many digits to represent it or so many digits to transmit it, I am now removing myself from it, the accuracy that much is not required. On the other had I have the flexibility of increasing the accuracy by increasing the number of levels. 

If I am willing to store more levels and transmit more levels we improve our accuracy. If you are not interested in storing more levels and transmitting more levels then your application can now decide the accuracy that you want. So there is flexibility in this digital domain which is not there in the analog domain. In analog domain if you make a measurement, suppose if you go to a physics lab make a measurement of current or voltage the representation is analog the needle moves, it stays somewhere between 3.2 and 3.3 but you will only interpret it is 3.2 or 3.3 or say 3.25 or 3.275 like that you will make a guess. But really if you want to be very accurate I should be in a very large meter with minor sub-divisions of each of those and then keep on doing it till you can get accuracy.

There is an accuracy built in analog also because of our observation power and because of the limitations we are using for measurement, now I am legalizing it that?s all I am making it official. So I am now saying I am going to tell you these are the levels permitted always represent your signal within these limits. But if you give an analog meter I approximate it, here I approximate it in a systematic way so now this is the digital domain we will be talking about.

Now why do we go for digital because even though there is inaccuracy built in analog also if you want to improve the accuracy of analog what will you do you will do a more precise meter with a large range and each range subdivided into many sub regions so that you will not make a mistake. Supposing you know the current always have to be between 2.5 and 2.7 I will make a reading of 2.5 to 2.7 so large and between that I will divide into smaller and smaller sub-divisions. This possibility improves the accuracy of the meter by any amount by putting more and more of precise instrumentation. By making a precise instrument for measuring current or voltage or any other quantity you are trying to measure I can always improve the measurements of analog signals. Likewise I can always improve the accuracy of my digital instruments also by having more and more levels because I need to store more and more levels or to transmit more and more levels. 

So accuracy can be decided based on the application required. Then what is the advantage of going digital. Analog also has the potential inaccuracy which can be improved depending on the need by extra hardware, I will call it hardware or extra precise instruments. What I mean by hardware put more money in other words. If you put more money you will get better system is it not? Anything if you put more money you may get a better system, more money you get a better car right? That is what it is. 

In digital also I have a potential of improving the accuracy by putting more and more levels which means more and more levels means more and more hardware then I should have some way of representing more digits more levels, earlier I had fewer levels now I have more levels so now I should have some other hardware to represent this so here also it is going to cost a little more in terms of instrument implementation.
 
(Refer Slide Time 21:47)

 

But now why analog why digital? So this is the difference between the analog signal, discrete time signal and digital signal so in this particular course we will be dealing with digital only, both in time and levels it will be digital. We are not talking about analog signals that is analog electronics POE Principles of Electronics, you will learn later on and discrete time you will learn some other time for some other specific applications. This course will deal with only digital signals and digital processing of signals, digital representation of signals; digitally you have to store it etc so this course is on digital circuits and digital systems. 

Now, one may say that signals are basically analog in nature when it is generated. When it is generated most of the signals are analog, temperature variation is there, you can?t say that temperature always jumps between one degree intervals can you say that? Today?s temperature you want to measure can you say that my temperature will only jump from 31 to 32 in between it should not jump, can you force it? No, you need not take cognizance of the fact 31.2, you will say either 31 or 32 but then see temperature will change, analog, there will be infinite levels, it will only take 31.2745 also it can change you don?t know. 

Likewise all signals are analog similarly when you put the thing back and after processing or storing, transmitting and get this back on the other transducer reverse transducer in this case, in the case of microphone the reverse transducer is the loud speaker, the signal makes the sound possible the loud speaker the electrical signal is converted into sound, the light is picked up as an electrical signal it is processed and in your picture tube at home television receiver the electrical signal is converted back into light where you see the shadows of all these movements which you are addicted to, all the time watching TV.

So it is again a conversion of analog to digital, digital to analog and back so why do we have to go through the digital path? Why can?t we take analog signals? Anyway inaccuracy is there, in digital also the accuracy can be defined by you, in analog also there is a provision to improve accuracy by spending more and more precise hardware and more and more money, in digital also I can do more and more hardware and then get better accuracy so when that is the case why suddenly make all of them learn this course digital? One thing is I am going to get salary out of this course teaching you that is the minor reason but the real reason is digital signals are easy to store and manipulate without much error, I will give you an example. 

Supposing I am measuring an analog value I am storing an analog value, how do you store an analog voltage? How do you store voltage? Capacitor, you store the value in a capacitor. 

Supposing I charge my capacitor to 1.27V today and tomorrow somebody else comes and measures it then it is equal to storing and retrieving it later or storing and transmitting it, you stored 1.27V and tomorrow somebody comes and measures 1.25V does that person know that you have stored 1.27 volts if he knows then there is no need for storing you can also tell him then there is no need for capacitor, if you are going to see that fellow tell him it is 1.27 he doesn?t have to come and measure. So when you leave a voltage of 1.27 volts on a capacitor and measure it again you don?t know how much is the last. 

For analog value because 1.27 is only our limitation, as I said it can be 1.27 to and in that case it can be measured as 1.27 too whatever value you put you should be able measure it accurately but there is always a leakage or I am transmitting analog signal let us say 1.72 instead of storing in a capacitor I am trying to send it across a wire to the other end as a signal so you try to send 1.72V the receiving end it is measured as 1.75V this person has no idea that you sent 1.72V and if he knows that you have sent 1.72V then there is no need for a transmission. So the other end receives it as 1.75 volts he was not sure about what you have sent that was one point seven two volts. There is a 0.03V noise which has been added in the transmission part which itself is 1.75V but he doesn?t know exactly how much is the noise added. Now there is uncertainty about the values of storage and the transmitted signal in an analog domain. 

Take a digital example; I have only eight levels as I said or a minimum number of levels whatever is the level but I will take eight as an example. Between 0 and 5V I have eight levels so when you divide 5V by 8 how much is each step? It is 0.625. So if the voltage level that I want to transmit is between 0 and 0.625 I am going to send it as a 0 level that is what I told you, I am going to round if off to the lowest level. If it is between 0.625 and one point two five if it is 0.625 and 1.25 you know it is L1 level one. 

Supposing I send 0.75 let us say there is a noise added, at the same .03 a noise was added same channel I am sending so the noise is added in it so 0.75 is going to be received as 0.78 but it will still be recorded as L1. The effect of noise on a digital transmission is much lower compared to the effect of noise on the analog transmission. Since I only know that predefined levels as the possible levels I know it cannot be 0.75 it cannot be 0.78 this guy must have send 0.625. I don?t care whether 0.75 became point seven eight because anyway you send only 0.625 which is level 0. 

Unless there is a marginal thing where you are trying to send 1.25V you send 1.24V which is referred to as L1 and 0.2 got added so 1.24 plus 0.2 will be I will not even say 0.2 so .01 got added so 1.24 becomes 1.25 then you are not sure whether what you sent was L1 or L2 but occasionally these type of extremities are there. I am not saying it as a perfect transmission I am saying it is better than analog in noise performance. That is one of the reasons why you want to go for analog. It can store and reproduce values not more accurately but I will say more reliably than, why did I not say accurately? Accuracy depends on number of levels I use. If I am going to truncate my 0.825 as 0.625 is not accurate by any stretch of imagination but I chose to have only eight levels. If I wanted I could have had 16 levels, also if I had wanted I would have had 256 levels, if I wanted I can have 1024 levels so that case becomes more and more accurate. Accuracy depends on the number of levels but more reliably I can store and reproduce and more reliably I can transmit and receive, that is one reason. Do you think it is a valid/good reason to for digital? No? You are not convinced. I think it is a good reason. 

Now second reason I will say is I will go back to accuracy a little bit more. I said accuracy can be improved by analog or digital case. In digital case it is having more number of levels and in analog it is by giving an instrument which is more accurate which can handle these lower order values better by increasing the sensitivity of the equipment. For example, a meter, how does it work? A meter works by the current carrying coil which just makes a deflection of the pointer and where it stops so if you want to make more accurate measurement I should have more sensitive coils but now the difference between having more levels and more sensitive analog is very different. 

To improve the accuracy it is easier in digital because all I have to do is to increase the number of levels. So reproduction of levels is the same effort. Hardware wise it is more but then the similar hardware I have more of it. So if I have similar hardware more of it I can improve the accuracy of a digital system. In analog system to get more accurate I need to struggle more I need to slog more. Analog improvement accuracy is more difficult than digital improved accuracy. Digital improved accuracy means more levels which are identical to the earlier levels. Instead of having eight of those levels whatever it is I will have sixteen of those whereas for analog I cannot say. 

For example, if I want to make a measurement of the distance from here to here if I ask you to measure and give me the feet you will very easily take your foot ruler and measure and say seven feet, eight feet and if I ask you to do in inches then you will be little more careful you need a scale with an inch, rule of an inch calibration in it and then have to be very careful and then finally if I say give me the nearest millimeter then I need an instrument with a millimeter calibration and then I have to be very careful in my measurement. So, by measuring more and more accurately in analog systems is difficult than having more and more levels and improving the accuracy or precision of a digital system, that is another reason I have given for a digital. So the cost of more accurate system is proportional to more accuracy in the case of digital whereas it increases the exponentially in the case of analog. In analog the increase in cost for most accurate systems is not proportional to the accuracy improvement but it is much more than that. 

For digital I spend more money I get a similar one. If a I am happy with four levels be happy, if you want eight levels give me double the cost I will give you, in analog I can?t say that so it is more difficult to make more meaningful measurements more accurate measurements in analog compared to digital or storage. When I say measurement it means storage and transmission everything. The quantity we may signal after all what did I say the signal has to be represented, stored, measured, transmitted, everything is part of signal that is called signal handling or signal processing. The signal has to be processed, you can call it handling of the signal doesn?t matter to me. So these are the reasons why we go for digital. So now the effort is to convert everything that you see in the world and why can?t you do everything in digital? It is not possible. 

So I told you why digital, why do we need analog? If you say so much about digital being so good can you not do away with analog altogether and have only a digital world and not have the principle of electronics course in your next semester? It is a good tempting thought but unfortunately not because all real life signals are analog signals. Be it a temperature variation of a body or a temperature variation of a parameter or anything or a speech or a light or heart rate or whatever you think of, have you seen the ECG waveforms in monitors, in hospitals, in movies? Suddenly the heart rate will come and then follows that that is how they represent a person dying in a movie is it not? 

So all are analog signals unfortunately or fortunately if you look at the analog people they will say otherwise they won?t have jobs. So analog signals are there and our job is to convert these analog signals to digital signals and because we live with digital people but today technology has improved so much it is easier to do digital as I said it is easier to do digital cost of the digital becoming lower and lower so we want to do more and more of digital so what we do is we cannot do away with analog I told you, first we pick up the signal analog by a transducer as I said, sometimes the signal is so weak that you need to amplify it before you convert into digital you need to amplify it. Supposing you don?t do an amplification sometimes the signal gets lost, the signal is lost completely, you get very weak signals and if the signal is not very weak you can directly convert into digital. 

Therefore take an analog signal convert it to digital preprocess if necessary that is if signal is very weak, convert to digital, by process I will put anything I am not going to put separately store measure and all that I combine all of them, manipulate do whatever you want with that signal that is called processing, just storing and reproducing is also processing and then convert it back to analog this is the flow of any processing today and because the technology advances because the digital domain being so dominant today in electronics they are trying to push as much as possible digital domain and have as little as possible in analog. 

(Refer Slide Time 37:44)

 

So in any system today you design ninety to ninety five percent of the activities are digital but that five ten percent of the analog is not real, without a proper signal whatever processing you try to do that is not going to help you. I am not trying to say analog is not important, I am not trying to say don?t go to analog but more effort is put on digital more amount of work is done in digital domain than analog domain. But design efforts are very difficult in analog as I said. To improve the accuracy in analog is not easy but digital is easy. So effort wise it may be even equal or slightly different but then I am not saying in reality in that sense please, do not misunderstand me, do not misquote me to analog professors and pick up a fight for me with analog professors who are my colleagues here, I am not saying that but digital as lot of these applications today and what we will be seeing is only this, we are going to do this process convert to digital, convert to analog and that we will learn later on in future courses but in this particular course what is this signal, how are these signals represented in digital, how are we going to use it in processing, what are the various things we can do, what are the various things we can do with this signal, this is the basic building blocks so what we will basically study in this course are building blocks of digital circuits and systems. There are several other things but we will not go into the details. 

We will have to do from the analysis point of view we have to analyze the behavior of them, how does it work, what is a building block, how do you define the input output relationship of this, how do you analyze it, how do you use it, analysis, use and design, how do you design it to build one? That is the crux of the subject matter of this course. We will go into the details of the subject matter this is further divided into combinations circuits and sequential circuits and all that we will see them as we go along.
 
So basically we will look at the basic building blocks of the digital systems and digital circuits find out their behavior how they are built and how to use them in known applications and in a reverse mode given a requirement in a digital system how do you go about designing the requirements or what are the building blocks you need and how to connect them in properly and so on, that is why we call it the design phase. Design is given the specifications of the circuit how are you going to choose the proper building blocks, how are you going to connect them together, how are you going to make it work to give you the satisfactory results.

There are two types of circuits basically; one is called combinational and the other is sequential, both come under the same digital category. I will define the difference between these two a little later on.

(Refer Slide Time 42:05)

 

So, in a nut shell you want to know the course content of this course we will be doing the analysis use and design of combinational sequential building blocks which are required for digital circuits and systems, one sentence course formulation and what are the books we will be using? A very good book is called ?Digital Design? by Moris Mano M. M Mano he is called as Moris M. Mano this print is all book I think, it has come in cheap edition it is available, I think it is available in our book stores. 

This Moris Mano has come through several iterations, it has been there for a while for the last twenty years this person has been writing books and updating and improving the contents, this one is the latest version called as the third edition, digital design edition 3. Then we have Roth Junior C. H. Roth ?Fundamentals of Logic Design? by Jaico Publishers, I don?t know what it is Jaico Publishers 1998, there are two typical but there are so many books.

(Refer Slide Time 44:13)

 

Any book which as title like digital design, logic design, digital and logic design digital circuits, good enough because these are all very basic stuff we are talking about, the basics, the first introductory material and digital there are scores of books at least about 15 to 20 good books you can see in any library and I will not be following one book strictly, I would like to teach you everything you need to know in your first level course but does not mean that we will be following the book that cover to cover it is not necessary because this is such an interesting course we have been teaching this course for a while so some books doesn?t cover one topic very well, some book does not cover a topic at all properly so in that case I will go on, I don?t even have to follow books because I am teaching this course so many times so I will just sort of give an essence of my experience of teaching this course over years, might as well has been a good practice I have been doing it for a while without any much complaints. So that?s what we will do but you need to have a book so that you need to follow the material and do more studies, sometimes we are not spending enough time in the classroom we want to do further studies, sometimes something is not very clearly explained in the class you want to go back and refer to a book so please have a book, I am not saying you should not have a book but do not expect me to follow a book from page to page and it always nice to have a basic digital because book because this is a first course lot of other things are done. 

As I said today digital world is technologically a very advanced world so lots of opportunities are there for you to do digital, there may be an advanced course in digital that you may do, you may be doing some mini project, you may be doing even a major project in digital area so it is always nice to have a reference book with you instead of always having to borrow or copy somebody else?s book and all that. 

So if you are thinking of buying a book you can buy one of these two books, there are so many others also. If you are doubtful about a particular book and if you want to know if it is good or not you can always ask me, you can browse through and that will tell you. So these are the various things we need to know and as we go on we develop a material and for homework I may have to prescribe some of these books so that may be a good idea that way to have, at least there must be enough for books available so that you know what problems are there for the class. 

This is where we will stop today and in the next lectures we will start with the detailed subject matter as I said levels and all that, we will be more specific how to present levels, what do you mean by level and what are digital signals and how do you represent digital signals and then we will start with the simple gates and then go on. It is a good idea to have a book and follow the book read the book sometimes it is better to read ahead of the class if possible so that way you can understand this topic better.
 
I will prescribe homework from the book so that you can start also working out problems, okay we will stop here today. 

Digital Circuits and Systems
Prof. S. Srinivasan Department of Electrical Engineering
Indian Institute of Technology Madras
 Lecture - 6 Karnaugh Maps and Implicants

Today we will continue with the simplification of Boolean functions or logic functions. The last lecture we talked about Boolean algebra being a set of formulae or identities to be used to simplify a given logic expression without changing the Boolean relationship. That is for a given set of input conditions an output is defined as true or false so when we make a simplification that should not change. Whatever simplifications you make the output should still be true for all the input combinations for which it is supposed to be true or it would still be false for all input combinations for which the output is supposed to be false.
 
Now we will continue this and use a graphical method. As I mentioned earlier it is not a new theory or anything. It is a systematic procedure actually. If you want to call it as a procedure at best it is a procedure, systematized for easy handling or when the function gets bigger and bigger so that it can be automate. 

There are other automated reduction techniques other than graph method. We will not see them in this course. But these are all having the same type of concept. Identify wherever possible the combining of the terms. What did you do yesterday? In order to reduce or simplify the function if you can reduce the number of terms it is good and in each term if you can reduce the number of variables it is good. So we will use the same method to see wherever possible we can combine the terms into a smaller term. Two terms can be combined into a smaller term then there is a saving in hardware. The same concept will be applied in graph method and later on there are methods called as computerized methods, implicant methods and all that. We will not see in those things because conceptually they are same, they are merely procedures. If you know how to do it conceptually you can learn the procedure any time depending on your requirement. 

So we will start with the map method of Boolean simplification today. It can also be called a graphical method but usually it is called a map method. What we have to do is to map the truth table on a graph. Look at the truth table there are 1s and 0s in the output and we want to combine all these 1s together to give the minimum possible solution. Now we will map it on a graph and see whether there is a possibility of combining those that?s all we are going to do. 

We are going to repeatedly use the same concept of Boolean algebra again and again. There is nothing like we are going to use a different set of equations or identities, it is the same set of equations or identities we are going to use but in a systematic way. 
So let us take the example; what is a map? A map is nothing but all the variables are present in a map in true form and complement form. In other words we will have a value corresponding to each input combination that is possible. Let us take an example of 3 variables. Let us say the variables are A, B, C, what are the eight combinations of A B C? They are A bar B bar C bar; A bar B bar C etc finally ABC. That means there are eight possible values. So we will now draw a graph with eight cells. This is how it is going to look like. You can draw it horizontally or vertically doesn?t matter. 

(Refer Slide Time 7:18)

 

I need eight cells in this map I call this a 3 variable map, eight cells corresponding to this A bar B bar C bar; A bar B bar C; A bar B C bar; A bar B C etc will be represented here. I will say on this vertical axis I will let A vary the true complement value, true value. this 0 here means A bar this cell will have a value, the value of this cell A is A bar, value of A for this cell is A bar and value for this cell and for the horizontal axis we will let B and C vary there are four possibilities of B and C varying such as B bar C bar, B bar C, B C bar, BC so that can be represented by 0 0, 0 1, 1 0, 1 1.

When I say 0 0 here for BC, A0 B0 C0 correspond to A bar B bar C bar that?s all. Here this will be A B bar C bar you don?t have to write it, it is the first time I am doing so I am writing the corresponding values in the input combinations, input combination I am writing in the cell but the cell is supposed to have that combination. Once you are familiar with this you don?t have to write it. Then the next will be 0 1 for B and C so this will be A bar B bar C, this will be A B bar C. So what will be the next value for BC? It is 1 0 or 1 1 but if we put 1 0 what will happen is I have to write A bar B C bar. But I would like to have this adjacency rule. Remember, this type of identity I am used to, repeatedly to combine to knock of a variable. 

For example, if we have A bar B bar C OR A bar B C then I can take this as A bar C and B or B bar and knock it of and write it as A bar C. that means I should only let one of these two variables change. Between B and C I should let only one of those variables change from cell to cell. From one cell to the next cell either in the horizontal direction or in the vertical direction if you let only one variable change and the other variable keeps its value then I will be able to combine it with a previous cell. 

(Refer Slide Time 10:08)

 

In this case when I say 0 1 and 1 0 B changes from 0 to 1, C changes from 1 to 0 both the variables B and C change at the same time that means it is not possible to combine them effectively. So the technique is then not to write here for 1 0 for BC write here as 1 1. That means I will let B change from 0 to 1 and C remains and I let C remain as 1. That means this will be A bar BC and this will be ABC. And finally the only other value which you have not used is 1 0 that means B is 1, C is 0, A bar B C bar A bar A B C bar. 



















(Refer Slide Time 11:53)

 

The advantage of this representation is between two adjacent cells either in this direction or in this direction only one of the variables changes from 0 to 1 or 1 to 0 the other variables remains same that means I can use this formula repeatedly. This formula identity A OR A bar is 1 can be used if two adjacent cells are same and both of them are one I can combine them to knock of the variable which varies from this to this and retain the other two variables which do not vary from (Refer Slide Time: 11:40) this cell to this cell. 

The same thing applies here also. here A only changes, B value C value remains same in all these cases and this adjacency work also backwards round its a wrapping it is something like a circular symmetry here so between this cell and this cell A bar B B bar C bar C bar that means B only varies, B is 0 here 1 here C is 0 0, A is 0 in both cases. And if I had four columns or four rows in the vertical direction then also I can apply rotational symmetry if I had two more rows this and this will be adjacent. 














(Refer Slide Time 12:30)

 

So in this map I will call each of them as a cell and the cells in the map which are adjacent to each other in horizontal direction or vertical direction will differ in only one variable and all other variables will be same these are called adjacent cells, differ in the value of only one variable.  

(Refer Slide Time 13:16)

 

Adjacency applies from end to end also that is what I am trying to say. I am trying to say that adjacency applies from end to end as if we are folding it around wrapping it around in a circular way. So what does it mean now? If I have values of output is 1 or true for this case and for this case that means the truth table will have a 1 in this cell as well as in this cell when I have a 1 and 1 in two adjacent cells of the truth table I can knock of the variable which is different from these two cells and have a simplified expression, that is what we did. For example, yesterday we said we had A bar B bar C bar AND A bar B bar C both of them are one in my truth table and I have written it as (Refer Slide Time: 14:32) so that is what we are going to use in a graphical method.
 
We are going to use the identity A plus A bar is equal to 1 repeatedly in the graphical method till we can identify the entire group of 1s till we can do it no more. Hence it is a more systematic way of doing it and you more or less certain at the end to be exhausted all the possibilities because it is a graphical representation. So let us map our original function which you have been talking about in the last couple of classes. This is how (Refer Slide Time: 15:15) you write the map you always write the map like this with all the cells and mark with 0s and 1s on the left hand side for this variable and 0s and 1s on the top for these variables then only the map is complete. This map is also called as Karnaugh Map. Karnaugh is the guy who probably invented this, it is named after him, they simply call it K? Map. You will see this K? Map mentioned in text books or Karnaugh Maps.

Let us apply that function in the truth table that we had originally for F is equal to A plus B C bar. Which are the entries of the truth table? It was 1 in the output. You remember ABC this was the truth table, this was 1 BC bar. This was the original truth table (Refer Slide Time: 17:04) we have been talking about in the last few classes, the examples.

(Refer Slide Time 17:25)

 

So there is a 1 corresponding to this row and all these four rows the output and for all other rows the output is 0. So the output was 0 for the first row, second row and the fourth row, 1 for third row, fifth sixth seventh and eighth rows but we don?t call it 1 to 8 we always call from 0 to 7, the reason is very simple, with 3 variables I can have eight values but if 0 has been included as one of the values I can go only from 0 to 7 or eight values. 

So when you have a number representation 0 is an essential thing I can?t have a number representation where I cannot represent 0. So with the binary number one with one digit or one bit of binary even though there are two values possible the one of them happens to be 0 or the other one happens to be 1 so I can only represent a maximum of 1 using a binary bit. 

We have two binary bits or two bits I can have four values but the first value is 0 so it is 0 1 2 3. 0 is 0 0, 1 is 0 1, 2 is 1 0, 3 is 1 1, I can?t represent four using two bits. Since it is going to be binary and we always have to have 0 as the one of the values in digital design or digital system or digital representation wherever digital things are involved we always start with 0 and not 1. So the first entry is always a 0 entry so that way I will call this zeroth row, first row, second row, third row, fourth row, fifth row, sixth row, seventh row and we also call these variations or combinations of the inputs each of the input combinations of a truth table are called min terms. So first min term is min term 0, second min term is min term 1 so there is a symbol for the min term a small ?m?. 

Already there is K? Map here so this is called min term 0, min term 1, min term 2, min term 3, min term 4, min term 5 so min term 0 to 7 are the eight min terms possible for with 3 inputs and when it comes to max terms we talked about max terms also yesterday we use a capital ?M?, a capital ?M? for max small ?m? for min. so I don?t even have to write this truth table. Of course this one is what we should get finally this is what we started with. But this is the truth table which we considered and said that this is same as this. We first do a circuit for this then you said that this circuit can represent a truth table of this type and then we proved yesterday using Boolean algebra that this table can be represented to this function.

Now my objective is to reduce this table again to this using Karnaugh Map. Yesterday we did it using Boolean algebra today we will do it using Karnaugh Map. So I don?t need this any more unless at the end to verify whether the result is right or wrong. This is what I should get. We will see whether we get that.

So I have the truth table and I have to represent it in Karnaugh Map, map it in a graphical representation in a K? Map and you don?t even need this truth table. Somebody is going to give you the truth table and then you are going to map it  So why waste time because you know what the truth table is all about all possible input combinations and the combinations for the input for which the output is 1 and this information is called the truth table. You list all the input combinations possibilities and also list those combinations for which the output is 1.





(Refer Slide Time 22:25)

 

Therefore instead of saying all these in such a big way can I not simply say this function F has output 1 for m2 m3 m4 m5 m6 m7 because you know what is m0 for 3 variables it has to be A bar B bar C bar or P bar Q bar R bar or whatever X bar Y bar Z bar whatever. It can be X Y Z, P Q R, alpha beta gamma, A B C, doesn?t matter. but as long as there are three variables, only these eight combinations are possible so what is the point in writing everything in a big table and say this is 1, this is 1 and this is 1 instead  I am saying this F is equal to min term 1 m2 min term m4 min term m5 min term m6 min term m7. For these min terms output is true or 1. 

Since it is a sum of product expression if you remember each of these product term I represent it by a sigma. So we now say my function is I will remove this now (Refer Slide Time: 22:30) the given function is F is equal to sigma m standing min terms instead of even having to say m m m repeatedly try to minimize having to repeatedly do the same thing over and over again out of laziness or whatever you want to call it out you want to say stationery or just more or less boring  just don?t have to keep on removing the same thing over and over again so what I am saying is sigma m means the sum of the products and what are the product terms involved or the min terms? It is 2, 4, 5, 6, 7. So if I give you the function like this F is equal to sigma m2 four five six seven you know the truth table and you know the entries in the truth table for which the outputs are 1 and the others are 0.








(Refer Slide Time 24:57)

 

So my job is to map this into the Karnaugh Map represent into this Karnaugh Map this truth table so I don?t need to give you this so from here it should be able to directly come to this you would directly be able to get this. 

Now, in order to help you in the beginning, later on you may drop this, you can write these min term numbers in the cells. This is min term number 0, 1, 2, 3, 4, 5 so that you won?t make a mistake in the beginning and then later on you know all that by experience. These are the min terms my job is to map or represent on this map the min terms for which the output is 1 or true these are 2 4 5 6 7. So this is the K map of the function given as this which can also be expressed as this or can be expressed as sum of products as A bar B C bar plus A B bar C bar plus plus plus five terms we wrote yesterday.
 
So this is the Karnaugh Map and this is the function how do you simplify it? Deduce it so that fewer literals are used and fewer terms are used in final implementation in the final representation. that is where adjacency rule comes in. you know the two adjacent cells differ in only one variable so you find a one in one variable one cell and one in the adjacent variable cell, adjacency works left to right, top to bottom, end to end not diagonally. Adjacency does not work diagonally you have to remember that. There is no adjacency diagonally. 

So anywhere I find in a 1 top to bottom or side to side I will try to combine these two and find out which is the variable which is appearing in one cell as a complement and the next cell as a true. In one cell it will appear as B bar and in the next cell it appears as B then B goes because of the A plus A bar is equal to 1 or B plus B bar is equal to 1 relationship. That is easy to identify for example these two cells A appears as 0 here, 1 here. When you take these two cells and connect it like this, this is equal to, later on you will be read it directly from the map. Now the first time I am going to write it as this is A bar B C bar this corresponds to B, (Refer Slide Time: 27:06) this corresponds to C bar and this corresponds to A bar. So you write it as A bar B B C bar and this corresponds to A B C bar. These two together can be written like this.

 (Refer Slide Time 28:47)

 

What is common between these two? B is common and C bar is common so B C bar is common so take BC bar using that distributive property say A plus A bar is 1 and since A plus A bar is 1 it is a known identity this is same as this. So these two cells can be merged or combined into a single term of BC bar. Each of the cells have three terms three variables I have knocked of one of the variables so two 3 variable terms have been reduced to one 2 variable terms that is the simplification procedure. 

There is nothing very great about it, all you have done is identified the adjacent cells where 1s are marked and have found out which of the variables was (constan?.28:35) these two cells which of the variables change between these two cells and the changing variable is removed, that is all. Hence you don?t need all these algebra because you know B is constant between these two, C bar is constant between these two, A goes from 0 to 1 so since A goes from 0 to 1 you can write this without A with B and C bar. So you don?t need this algebra I just wrote it for your convenience. 

Now let us extend this argument to these two and these two (Refer Slide Time: 29:15). These two will have A common, B common, C varying so I can write this as AB. Between these two A is common, B bar is common, C changes so these two if I write together it will be A B bar because A is common between these two B bar is common between these two and C changes from here to here which has to be knocked off. and between these two A is common, B is common in these two, C changes from here to here so C gets knocked off so this is AB. But again these two cells and these two cells adjacent here it is B bar, here it is B, A remains constant throughout so instead of doing it in two steps and instead of grouping two 1s each time and then combining them again with one more step I can group also four 1s at the same time. These two can be combined to as the one group in which it is A B bar OR AB which is equal to A. I don?t have to do it this way step by step but I just showed it to you how it works. But you don?t have to do it this way.
 
(Refer Slide Time 31:51)

 

All you have to do is see that A is constant throughout these four cells across the four cells A is common, B changes from 0 to 1 across, C changes from 0 to 1 1 to 0 so both these variables B and C or neither of these variables B and C remain constant throughout so they both get knocked off. So it is not necessary to knock off only one variable, you can knock off two variables, you can knock off three variables and in order to knock off three variables you need eight 1s in a group. 

Therefore if you have a more number of 1s in a group adjacent cells it is better for us because we are going to simplify better, our reduction is going to be more. That means without going through all these algebra all this background theory if I give you this same map now all I said was 1 1 1 1 1 I will simply do it combine this and combine this (Refer Slide Time: 32:08) this combination I will write it as A this combination I will write it as BC bar so my final function is the OR combination of this or this BC bar. This is the function we started with that means K? Map can also give you the simplification that the Boolean algebra gives. But here you know that I have exhausted all 1s, how do you know it is done? I have exhausted grouping all 1s no individual 1 stays out of course if it stays out you have to write it separately and we have also always considered the largest possible groups of 1. 






(Refer Slide Time 33:12)

 

There are four 1s possible plus here there is a group of two 1s possible so whereever possible you have taken the largest possible group in that particular group so there is no question of doing it better than this. So this way you are more confident of your final output compared to Boolean algebra where you might have or might not have used an identity which should have been used. there lies the difference between a Karnaugh Map method and the Boolean algebra but the Boolean algebra is what we have used finally A plus A bar is 1 is Boolean algebra. It is not as if some new technique I will not say new theory it is a technique, the procedure may be different but not the theory. And now you can extend this to four variables. Four variables will have sixteen cells, two variables here two variables vertically and two variables horizontally and you can do like that.

We will take an example of four variables. Simplify minimize using K? Map the function F I can now give the variables. For a change we will go from ABC P, Q, R, S, function of four variables P, Q, R, S which is true for the following min terms. I am going to write arbitrarily I am not having any particular function in mind. When you put sigma m that is the following min terms are having 1 as the output or true as the output and rest of the min terms are having 0 as the output that?s what we write. This is a sum of the product representation in min term form. 

So let us say 0 2 3 7 11 13 14 15 and so on. It is an arbitrary example. No specific system I have in mind no specific circuit I have in mind. so I have a function of PQRS four variables and if I write a truth table I will have sixteen rows and to this sixteen rows min terms min term number 0, min term number 2, 3, 7, 11, 13, 14, 15 I have true outputs or one output and other min terms namely 1, 4, 5, 6, 8, 9, 0, 12 I have 0 or false as outputs. For such a function I wanted to do a Karnaugh Map and minimize it, reading it by combining the ones as effectively as possible write the minimum possible expression minimum sum of product MSP not sum of product expression SOP is sum of product but this is non minimum. So it is a canonical sum of products which is the standard truth table representation then the sum of product is anything which is having some product relationship and minimum sum of product is what you cannot reduce further as a sum of product expression.
 
Let us do the Karnaugh Map, we will have four variables P, Q, R, S sixteen cells must be there, this is the K? Map of the 4 variable 0 0, 0 1 remember 1 1 and then 1 0 because the same argument we had earlier for BC and the horizontal scale we will now apply to PQ the vertical scale.

(Refer Slide Time 39:46)

 

I want only one variable to change from here to here so only one variable changes. If I had put 1 0 both the variables would have changed I don?t want that situation then they are no more adjacent. Two cells are defined to be adjacent only if they differ in one variable and if they differ in more than one variable then they are not adjacent according to the adjacency relationship. Even though physically you put them together they don?t become adjacent. So this is min term 0 1 2 3 min term 4 5 6 7 min term 8 will start here because there is 1 1 that comes later than 1 0 so 1 0 will have a min term 8 9 10 11 12 13 14 15. this is the 4 variable Karnaugh Map which is standard whether variables are A, B, C, D or P, Q, R, S or X, Y, Z, W or whatever alpha, beta, gamma, delta.
 
Now what are the min terms for which the output is true or 1 those have to be mapped on to this graph? These are 0 2 3 7 11 13 14 15. Later on when you start doing a few more of these exercises you will drop these min term numbers so this will become less cluttered from a clearer map. Now I put it purposely for you to get used to this so you can remove all these and later on you will not see those.

Now we have to combine them try to group them as many 1s as possible a in a given group but they should all be adjacent. I can straight away see a group of four 1s 1, 2, 3 etc. You always start with the largest possible 1s largest possible group and then come down, don?t start with the smallest number because sometimes the smaller group may get submerged into a larger group later on so start with a larger group.

The idea is to combine all the 1s but you can combine a 1 more than once. remember the Boolean algebra, yesterday when we tried to simplify the Boolean algebra we used the same time twice because A AND A is A, A OR A is A so I can use the same term twice no problem but I should not leave out anything everything should be included but it is alright to include a particular cell which is asserted as one more than once doesn?t harm us. In fact it will help us sometime. 

So first group of 1s is this (Refer Slide Time: 41:00). I will call this 1 because there is no space here I will write later on. then we have these two 1s, these two 1s, these two 1s and so on so there are four 1s available here and all of them are to be combined I can?t see this one being combined anyway other than this because all other adjacent cells are blank so this has to be combined this way so is the case here. here though I don?t have to combine in this way because this cell is adjacent to this cell because this is 0 0 0 0 this is 0 0 1 0, R changes from 0 to 1 between these two cells 0 and 2 R changes from 0 to 1 whereas PQ and S are remaining as 0 0 0. 
 
So cell number 0 and cell number 2 are adjacent even though they are physically not adjacent. That is what I am saying physical adjacency is different from logical adjacency we are talking about here. We are talking about logical adjacency. So that way I don?t have to mix this here since this is going to be combined this is going to be combined, (Refer Slide time: 42:25) this is not being combined anyway so I will combine these two so I will call this 2, I will call this 3 there are four terms.
 
There are now four terms of groups of 1s and each of them I have to write a sum of product expression then my final output F is sum of all these product expressions SOP minimum sum of product. So what is 1? 1 is this, variable P AND Q change all over so you have to write only this R AND S are 1 so RS. So 1 corresponds to RS, 1 is RS, 2 would be, PQ are 1 1 they remain as 1 1 here and here so they have to remain in the expression, here S is 1, here also S is 1 where R is 0 here R is 1 here so R changes from 0 to 1 between these two cells so R gets knocked off. R gets knocked off from this cell to this cell whereas S remains as 1 so 2 is nothing but PQS. For 3 it is the same argument PQ R remains 1 S changes from 1 to 0 S gets knocked off R remains so 3 is PQR. 
 
Finally the fourth one is PQR 0 0, R is 0 here R is 1 here R is 0 here R gets knocked off here S remains 0 so it is P bar Q bar S bar. That means my final expression is this RS plus PQS plus PQR plus P bar Q bar S bar. Each of these terms 1 2 3 4 which are product terms which combine to become sum of product later on is called a prime implicant. 






(Refer Slide Time 47:54)

 

An implicant is any group of 1s. Suppose I write a term I won?t do that, supposing I did between these two ones that means it is RS 1 1 P 1. So, if I write P RS P RS will mean these two cells cell number 11 and 15. Cell number 11 and 15 if I combine together I will write it as PRS. I will not do it because I am covering a larger group of 1s four 1s so there is no need to do this. But suppose I did it it?s called an implicant, it?s not a prime implicant. 

A prime implicant is a largest possible group of 1s in that particular context for that group, you cannot find a larger group. An implicant gets submerged into a prime implicant. A prime implicant is a largest possible group of 1s that you can find for a given group out of all the prime implicants. 

Any prime implicant which is essential for the final representation, I told you two things you have to make sure all 1s should be covered irrespective of the fact that 1s can be covered more than once. For example, this one has been covered 3 times this was covered along with this, this was covered along with this (Refer Slide Time: 47:15) so that is okay. But in each time we have included at least one 1 at least one cell which has not been combined earlier. When I wrote this number 2 term this one has been included new, when I wrote three terms I included this one new. 

I defined an implicant, I defined a prime implicant and now I am defining an essential prime implicant. In an essential prime implicant there will be at least one 1 or one cell which has not been covered in any other prime implicant. there should at least be one cell or one true value which has not been included in any other group so such a prime implicant is called essential prime implicant in this case all the four are essential prime implicants because this one and this one cannot be covered and these three 1s cannot be covered other than this group, this one will not be covered other than this, this one will not be covered other than, these two 1s will not be covered in any other way. So here all the four prime implicants are essential prime implicants. Sometimes occasionally we will get non essential prime implicant. 

(Refer Slide Time 49:27)

 

Supposing you have different ways of combining a 1 in two groups you can combine this way or that way both of them will lead to the same result or similar results. Such a group is called non essential prime implicant. That means there is a more than one way of combining a 1 which is not covered otherwise as a essential prime implicant. But one of them is essential otherwise that 1 will be left out. 

Suppose I have two different ways of combining a particular 1 I have exhausted all 1s in a map, all entries in a cell for which the output is true I have exhausted except 1 there is a 1 hanging out which I have not covered yet in any essential prime implicant or any prime implicant. Now I want to combine this 1 and I can find several possibilities or at least two possibilities but one of them may be required the other may not be, if I take this the other one is not required if I take the other one this is not required. So this is a non essential prime implicant. prime implicant is important it has to be covered but each of those two prime implicant which I will get by combining this one with two different ways are called non essential prime implicants so it is not necessary to include all non essential prime implicants for the final output but it is only necessary to include as many non essential prime implicants as required to cover all the ones in the map. Whereas essential prime implicants all of them should be covered in your final output. We will take an example of non essential prime implicant, how a particular one can be covered in different ways and how only one way may be required and all other ways may be redundant that will tell you more about a non essential prime implicant. We will see it in the next lecture. 

Digital Circuits and Systems
Prof. S. Srinivasan Department of Electrical Engineering
Indian Institute of Technology, Madras
 Lecture - 7 Logic Minimization using Karnaugh Maps  

In the last lecture we introduced you to the map method of Boolean simplification. we drew a Karnaugh Map which is a graphical representation of a truth table filled this graph with 1s corresponding to the cells for which whose min terms had a output true and 0s of course we didn?t mark 0s to avoid cluttering of the map. Wherever we did not mark 1 in the map the entry was a 0 which was purposely left out so that the map doesn?t get cluttered. 

The objective is to identify groups of 1s as large as possible of course satisfying the adjacency rule and remove or knock off as many variables as possible so that by repeatedly doing this we can get a simpler representation of a given Boolean function. So we look at a few more examples today some special cases and all that.
 
We will take an example of a map like this, four variables I will call these variables ABCD, want to say this map as 1s in the following cells, this is the pattern of 1s. That means this is a function this expresses the sum of the following min terms, this is min term number 2 so you will have to sort out from here 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15, so we take (2, 6, 7, 9, 13, 15) this is the map.
 
(Refer Slide Time 5:19)

 

Now the idea is to group the adjacent ones with as large groups as possible keeping in mind the group should be as large as possible. If you have a smaller group which can be totally submerged into a larger group we should not consider the smaller group and we have to make sure that all 1s are covered and we do not mind one being covered more than once these are the rules. Make as large groups as possible keeping in the mind the adjacency rule, make sure all 1s are covered, do not worry about combining a given 1 more than once. So in this map groups of two 1s are only possible 1 2 3 4 so I can say this because this one has to be covered any way, this is standing out separately. 

The most efficient way would probably be not covering anything more than once. You can cover 1 more than once if it can result in a smaller group. If something is not going to result in a smaller group then there is no point of covering 1 more than once. So in this case there are only two ones this is going to be a group, this is going to be a group, this is going to be a group all groups are having two 1s so there is no point in unnecessarily doing this and doing this. So this is how I will write this three groups of two 1s each and what would this be in terms of the product expression? F would be sum of these products 1 2 3 this would be AC barD plus then this will be BCD plus, this would be A bar C D bar 

(Refer Slide Time 8:26)

 

Now instead of doing this way suppose I marked it slightly differently. That means suppose I did it like this it is obviously not the most efficient way you can see that because there is a small map with few 1s but in general when you have a large map with large possible groups you may miss out and may do things like this. I brought this up to explain some of the definitions we gave in the last lecture. I talked about implicant, the prime implicant and an essential prime implicant. An implicant is any group of 1s and a prime implicant is the largest possible group of 1s in the given group of course that cannot be an essential prime implicant, a prime implicant is a group which cannot become part of another implicant. An essential prime implicant is one which I said if you remember has at least an entry of one not covered in any other prime implicant. So this way here (refer Slide Time: 9:30) this is the essential prime implicant I will call this 1 2 3, this is 1, 1 is an essential prime implicant because this one cannot be covered otherwise, 3 is an essential prime implicant because this cannot be covered otherwise. 

Now is 2 an essential prime implicant or not is the question? Do you think 2 is an essential prime implicant or not?

The way I draw it is an essential prime implicant because these two 1s cannot be covered anyway. But when I draw this map there are two ways of combining these two 1s. This is an essential prime implicant, this is an essential prime implicant (Refer Slide Time: 10:28), is this a prime implicant? What is a prime implicant? The largest group of 1s possible within that, it?s a largest group of 1s possible in that group. So all the four here I call this 1 2 3 4, here all the four are prime implicants, here all the three are prime implicants but one and three are clearly essential prime implicant, 2 is not an essential prime implicant it is a non essential prime implicant for the simple reason I can cover these two 1s in two other ways. So in this case again 1 is an essential prime implicant, 4 is an essential prime implicant so 2 is a non EPI.
 
But the reason that this one could have been combined with this I could have it small it is an essential prime implicant. I could have covered this to make another prime implicant. So this is the only way in which I can make prime implican otherwise that one gets left out only then it is an essential prime implicant. We are not talking about the most efficient way here remember that I am only talking about definitions. Just because it is an essential prime implicant it does not mean that it is the most efficient way of doing it. so these are non essential prime implicant, it is a non essential prime implicant because this one could have been combined with this to get another term, this is two in this case, this term could have been combined with this term to get another term 3 in this case so this is a non essential prime implicant (Refer Slide Time: 12:14) but the same argument 1 and 4 are EPI?s and 2 and 3 are non essential prime implicants. Having drawn in this case F is equal to 1 or 2 or 3. In this case F is 1 or 2 or 3 or 4 and all are two terms, two 1s all are two variables, a three variable term there are only three terms in this case, four terms in this case and it is very obvious that this is a less efficient simplification compared to this. 













(Refer Slide Time 13:39)

 

But the fact remains that there are some non essential prime implicants that has to come to the final expression in order to complete the expression. This is a very clear case of a non essential prime implicant inefficiently used. In this case a non essential prime implicant has been used efficiently because it was very clear and obvious apparent just looking into this map. 

Sometimes there may be two non essential prime implicants, each of them can lead to a final solution which is correct and both of them may have the same simplicity or complexity in which case you have to choose between 1 and 2 or one or the other of the essential prime implicant in which case the choice is not unique but in this case the choice is almost unique. I would not choose this against this if my aim is to reduce the logic which is again you have been proclaiming I will not go for this. But I will give you another example where I could have combined in two ways both of them resulting in a same simplified expression in terms of number of variables and number of terms involving a non essential prime implicant that has been an interesting case. So we will take another example.
 
For a change I will call it WXYZ and this is my map (Refer Slide Time: 14:59). So what is the map now? F is sigma M (0 2 3 5 7 8 10 11 14 15) these are the min terms for which the output is true for all the min term outputs. I just wrote the map and then wrote the min term. Normally it is the other way. Normally you are given the min terms for which the output is 1 from the truth table or from the word description of the problem. Either a word description of the problem or a truth table is given to you which will tell you what are the min terms for which the output is 1 and automatically the other outputs are 0. But in this case just to illustrate a point in terms of implicants, prime implicant, essential prime implicants, non essential prime implicants and so on I am just taking maps to give you examples so I have to first draw the map and then tell you what are the min terms which are true in this map.
 
Now what are the different ways of combining them? We have to again efficiently do it.
 
(Refer Slide Time 17:34)

 

You have to make smallest possible number of prime implicants and make a combination which is the minimum possible combination. So now this one, this one, this one, this one together form a map (Refer Slide Time: 16:50) group a prime implicant because they roll over top to bottom and left to right so I will call this first prime implicant.
 
I said the other day the adjacency, this cell is adjacent to this cell as well as to this cell, this cell is adjacent to this cell as well as to this cell, this is adjacent to this as well as this and so forth. Hence all the four cells are adjacent to each other, it is very similar to something like this or something like this. and this is in essential prime implicant because this one would have been left out otherwise or this one for that matter because I could have combined this some other way but not this, I could have combine this but not this (refer Slide Time: 17:50). So because of these two 1s we present this becomes an essential prime implicant and essential prime implicant has to necessarily find its place in the final expression. 

The debate is only about how many non essential prime implicants to be included to keep the function minimum and at the same time not omitting any one in the table that is the only thing will have to be concerned with. now this one again has to be combined there is no other way I could combine this one except this way otherwise this one gets left out completely so I will call this 2, one this is 2 now I have two options, I can combine these four into an essential prime implicant. In fact I should combine this way because this one would be left out otherwise of course I can always combine these two, these two are combining is not a solution because a prime implicant is one which absorbs smaller implicants so you put this one is not a solution because when I have four larger prime implicant I cannot put this one as an implicant I have to cover this. So this is an essential prime omplicant for the simple fact this one would not be covered otherwise so this will be number 3. Thus the only one that is left out is one. In order to complete my simplification I have an uncovered one and that one has to be included so this I can do it in two ways I can do it in this way I will call this 4 and these four 1s are adjacent to each other because this is adjacent to this and so forth or I could have combine these two 1s and these two 1s so either this way or this way these two 1s. 

(Refer Slide Time 21:03)

 

Now this one was what was left out remember, this min term number 3 was left out I had to include it in order to include it in a largest possible group of 1s I can do it this way or I can do it this way and this one I will call 5. Unlike in this case where we had an option which is obviously less efficient. We now an option in which one is essential prime implicant, II is essential prime implicant, III is essential prime implicant because of these individual things, IV and V are non essential prime implicants because essential prime implicant is 1 in which at least one unique 1 is covered in that group no other way it should be able to cover that one that is not the case with IV and V because this one can cover this way or this way so everyone of this 1 can be covered and all these other three 1s can be already taken care off. In this case all these have been taken care off except this one this has been taken care of, this has been taken care off, everything other than this has been taken care off so this one can be covered either this way or this way so when IV and V are two options of covering this min term represented by this III then it is not an essential prime implicant, IV and V are non essential prime implicants. 

Therefore I II III are EPI?s and IV and V are non EPIs. But it is enough one of IV or V is included because four and five both cover this one and this is the only one which has uncovered. After considering I II and III the only entry in the truth table which was not covered in our simplification was this entry which will be covered either by this or this. Both IV and V can cover this one so where is the need for both of them to be present and the choice is not easy because both are of same complexity, this is four ones this also is four ones. If I is 4 1s the other is 8 1s so the complexity is different so you know what to choose. If both have equal complexity where is anything to choose from? 

(Refer Slide Time 24:41)

 

So now I can write the final expression as I OR II OR III OR IV this is one option or this OR is English OR not the operator OR I OR II OR III OR IV, this explains to you a non essential prime implicants and its role in the final simplification. So I wanted to bring about the definitions of implicant, prime implicant, essential prime implicant and non essential prime implicant and the role of non essential prime implicant in simplification. It is not that they are trivial they can be ignored they are essential sometimes so you may have to include. But how many of them you will include and what are the non essential prime implicants you will include depends on the overall goal of minimum sum of products.

I don?t want to re write this now, you know each of these. We can complete this, I will have I II III IV but I II III IV are variables of or product terms with variables ABCD or in this case what WXYZ. So I II III IV and V are each product terms of variables WXYZ you write it and finally get the simplified minimum sum of product expression.

Now we can have a four variable map. What is meant by this? Let us do this for example. we started with simple gates and we drew the simple structure using gates and wrote down the expression and then said that write a truth table for that expression and we wrote the truth table found out the truth table had many more entries than the original circuit had so we tried to see why and we saw that the simplification of the truth table resulted in a smaller circuit that we started and we said simplification is possible using either Boolean algebra which you saw or by mapping method which you have seen so let us revisit that and see now. We will do the reverse now. This is the sum of product expression you have given. a system of four variables WXYZ having an output F circuit of system has the following Boolean functionality as a functional relationship between input and output given by this Boolean equation not identity Boolean expression this Boolean expression gives the relationship between F on one hand of the output and WXYZ on the other hand as inputs.

(Refer Slide Time 27:46)

 

What will it look like we will see because we have simplified this? For that I need to explain this 1 2 3 4 5. I have no reason to choose this or this so we will go with this. So let us quickly write what is 1. 1 is these four 1s, what are the expression terms of WXYZ? This is X bar Z bar so I is X bar Z bar, II is these two W bar XZ, III is this which is WY and IV I am going to take instead of V so IV would be YZ. So my expression is done X bar Z bar W bar XZ WY YZ these are gates with inputs X and Z of course inverted WXZ where W is inverted W and Y, Y and Z these are four AND gates, outputs of these four AND gates tied together by an OR gate that is, this is X again, W, Z second term, third term is WY and fourth term is YZ, Z has to come from here which is here. 















(Refer Slide Time 30:53)

 

So if you don?t want to lose track of these inputs you can write it one more time here, YZ, WY, this is ZW bar X, XW bar Z, this is W bar X bar Z bar all of them combined in an OR gate with four inputs. This is the function represented by this circuit whose Karnaugh Map is this and whose functional description is this. 

(Refer Slide Time 32:56)

 

Of course I can always write the truth table. The truth table is only an expansion of this, I will have to put WXYZ all the four combinations 0 0 0 0 to 1 1 1 1 and then put here finally 1 0. So it requires one 3 input AND gate, one 4 input OR gate, three 2 input AND gates and three inverters, this is inventory. You have to ask for these components in order to build a circuit and you can now associate with WXYZ some signals as we did in the example previously about some system which is to represent a particular condition WXYZ may be four parameters we are monitoring and on these incidence of parameters in this particular way will trigger an event at the output of this system that could be an example of the use of this.

So you go for a definition of the word description of the truth table and the Boolean relationship mapping and then simplification and then drawing the circuit and then of course you have to get the components, build it and test it. Now the variables XYZ we have used three or four WXYZ and IV or V you may have used, VI we may use, seven we may use and digital systems today are very complex. A system like a micro processor, a system like a controller, a system like a automotive system or a fuel injection or even very complex systems like missiles I already told you missiles and aircrafts and things like that so I don?t you can work with three variables four variables and three variables and four variables classroom exercises. 

What will happen if variables are more than four? We have already represented a two dimensional now it has to go for three dimensional. For a five variables what do we do? So let us say we have a five variables let us call these variables ABCDE.
 
(Refer Slide Time 34:58)

 

I can only represent sixteen cells in a four variable map two dimensional and five variables will have how many min terms? It will have 32, 2 power 5 so we need to have one variable. The variables we start listing them in a truth table will become starting with 0 0 0 0 0 0 0 0 0 1 and finally it will become (Refer Slide Time: 34:38) this is min term 0, min term 1, min term 31 or I told you that you will have to start always with 0 min term and go on till the last min term which is 2 power n minus 1, 5 is 2 power 5 is 32 minus 1 is equal to 31 so 0 to 31 will be min terms. So one way to do this would be draw two maps considering only four of these five variables each. You leave the A out because first sixteen entries of the truth table m15 would be 0 1 1 1 1, m16 would be 1 0 0 0 0 so these entries will have A is equal to 1, these entries will have A is equal to 0. First sixteen entries of the truth table will have A is equal to 0 and second sixteen will have A is equal to 1. So I will draw this map with variables BCDE always remembering A is equal to 0 in this map. Likewise I will do BCDE one more time always remembering A is equal to 1 in this map.
 
Now the min terms would be m0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 so whichever min term is one output you map it map in the corresponding cell either here or here if it is the min term corresponding to terms between 16 and 31 the 1 will up here so it will go in this part of the map. So you can map it the way you would map the four variables map graphically but while reading you have to be careful. The adjacency works between these two maps. The one here and the one here are considered adjacent (Refer Slide Time: 37:54) because the only variable different from these two maps this is B is equal to 0 C is equal to 0 D is equal to 0 E is equal to 0 and this is also B is equal to 0 C is equal to 0 D is equal to 0 E is equal to 0. If I have 1 here and a 1 here the variable A is 0 here, variable A is 1 here so these two cells are adjacent, the cell number 0 and 16 are adjacent. 

(Refer Slide Time 38:34)

 

Therefore the corresponding cells in this map and this map are adjacent that property has to be built in while reading the map that?s all. So I map the entire variable so we will use the same arbitrary thing, you will do this 0 2 and this for a change I will put here. Now these four 1s which you called prime implicant one essential prime implicant one here will appear here also in both the maps. 

So this I will call 1 including this, these two together are 1 (Refer Slide Time: 39:37). Now these four again I don?t know what we called it here we called it III but don?t worry about it, this and this are again are common between these two maps the same cells so I will call it II this and this. Now what is left out? 

These four are left out I could have combined this way or this way doesn?t matter I will combine this way but this is not common to this map 1 1 1 1 here unique to A is equal to 0 OR not to A is equal to 1. So I am going to call this III in which I will have to make A is equal to 0 in that. This one is unique to this map but not to this map. So this is III and these two 1s I will call it IV because this is not here, this one is unique not to the other map so V.

(Refer Slide Time 41:09)

 

So there are five prime implicants all are essential I made sure that is simple because it is an example, with five variables I wanted to drive home the point of how to simplify a five variable map so I made them essential prime implicants so you need not worry about non essential prime implicants or proper choice of that so we have five EPI?s 1 2 3 4 and 5, actually writing the minimum sum of product expression based on this is called reading the map. Somehow they call this reading the map so we should be able to read the map now, they use the term reading the map. 

After putting all these 1s and grouping them identifying them in groups you are writing the final expression and that operation is called reading the map. So now I have to read the map to get 1 2 3 4 5 and then put it together as one expression of F in terms of ABCD and E. already we have said that I was here this is C prime E prime and since this is common between A is equal to 0 A is equal to 1 so 1 is C prime E prime or C bar E bar want to call it C prime E prime C bar E bar or NOT C AND NOT E whatever, II is again common between these two maps that would be BD then comes the third map third EPI and the third EPI is this between these four cells which is DE. But this is not available here so I will have to include the information and it is only available in the A bar part of the map. I will make sure that you know it is in A bar part of the map and not A part of the map so I have to say A bar and B so III is A bar DE. And IV is again only this essential prime implicant which is B bar C B bar CE but you have to add A bar to that so it is A bar B bar CE but it is found in the A bar part of the map so it is A bar. And finally this fifth prime implicant this part A is equal to 1 part of the map which is BCE with A.
 
(Refer Slide Time 44:22)

 

So now my final expression if you want we can write it as F is equal to C bar E bar BD A bar DE A bar B bar CE and you can draw your gate structure or whatever it is. This is how you read a five variable map identify the common cells. Of course some people draw it side by side, some people draw it together left and right and so on. It is not a mathematical procedure or anything it is only for convenience whichever way you feel comfortable with you can do it. 

Now I can extend this to six variables. if I want six variables I want four maps each of sixteen cells I will have to say six variable map A bar B bar, A bar B, A B bar, and AB. So min terms 0 to 16, 16 to 31, 30 to 47, 48 to 64 and then you have to see adjacency see the adjacency between these adjacency between these, adjacency between all the four and all that and you can go on writing the expression and have unlimited fun all these checker games you play. But there is a limitation, why I am saying all these is because there is a limit beyond which after six how will you do? Of course you can always find a method of doing it and then it becomes inefficient. 

We started with the map method because of which simplicity an efficiency then we are reaching a point where the simplicity is lost it would become an ordeal so beyond six variable, five variables is most comfortable, four is good we would like to have a problem with four in the exam may be five manage, six is okay but seven and above it becomes cumbersome. 

After all this is a procedure what we have done is adjacency. Find 1s which are adjacent to each other when you represent in a graphical way. So it is always possible to write a computer program to find out the adjacent 1s in a truth table and keep on repeatedly doing it. The advantage or the problem whichever way you see it in the computers what you have to do is step by step. Combine two 1s at a time not more than two 1s at a time then it is too much to handle for computers. Put two 1s at a time and then two 1s at a time will become 1 1 then you say put two more so keep on giving it in steps you write a program algorithm they call it. So, algorithm is a step by step program. You write an algorithm for a program to systematically find out all the 1s in a truth table merge them to the best possible way and repeatedly do this. 

(Refer Slide Time 46:53)

 

Sometimes there may be several terms in which some redundancy may be there. The essential prime implicant and non essential prime implicant that the computer cannot resolve you know. After all the computer is what you program computer, it cannot become more intelligent than you are because you are the one who is feeding in the program in the computer. 

In a computer the program is limited by your intelligence cannot be more than your intelligence. So finally we may have intervened in some place and say we will list all essential prime implicants and non essential prime implicants and make a choice of the right combination that we have to do. Such a method is called a tabulation method as against the map method. We will not do that and I thought I should tell you. So the number of variables becomes extremely large so you go for what is known as the tabulation method. These are computer based methods. Of course you can also do it by hand to understand the algorithm. Like the same example of 31 cells or even 61 cells you can take for fun, 64 cells 0 to 63 or even 31, 0 to 31. Do it the way the computer will do it. Combine two two at a time and do it like that just to get an understanding of this method.

(Refer Slide Time 50:18)

 

I am not going to teach this in this class but it is available in many books, many books talk about this method called tabulation method. Some people call it prime implicant method. Some books call it prime implicant method; some books call it graphical method a tabulation method. You can do that to understand the concept behind this but these are all computer programs very easy to understand once you know how it works. So you can do a simple example of the same example we do in the class try to do it using this method so you will have an understanding of this program. We will stop here for today. 

Digital Circuits and Systems
Prof. S. Srinivasan Department of Electrical Engineering
Indian Institute of Technology Madras
Lecture - 8  Karnaugh Map Minimization using Maxterms

We have been taking about minimization of Boolean functions first by using Boolean algebra and then by map method by drawing a graphical representation of the truth table and then identifying the patterns of 1s and group them and reduce the variables in that process, number of variables as well as number of terms. 

If you remember we also talked about min terms and max terms. That is we can write an expression Boolean algebra either as sum of products or product of sums that is AND terms combined with an OR gate and OR terms combined with an AND gate. So one is called sum of products and the other is called product of sums because analogous to the algebra 1 looks like a series of product terms and sum them, the other looks like a series of sum terms you multiply these sum terms as a product. 

Sometimes what happens is when you draw a Karnaugh Map to simplify you find that there are more 1s than 0s. The idea is to minimize we said. The total number of terms should be as small as possible and the number of literals in each of these terms should be as few as possible. So when you have large groups of 1s it results in many prime implicants and essential prime implicants. If there are more 1s than 0s is it possible to use the 0s and get F bar complement of F expression. A 1 in the truth table says F is true the function is true and the 0 in the truth table says the function is false. So when you group 0s we can get an F bar expression just as we get F expression by grouping 1s and once I have F bar I have De Morgan?s Theorem to get an F. So, that is one approach some people use. That also depends on the type of gates you want. It all depends on whether you want a sum of product as the minimum expression or the product of sum as the minimum expression. So let us today see an example where we will use 0s to simplify the logic function. 

We will use our same familiar example from the last few classes. We will be using the function F is equal to A plus BC bar this has been our example. So when you do the Karnaugh Map for this if you remember (Refer Slide Time: 5:40) this is the K map where there is a one here one here one here one here one here if you look at a truth table you had one entry in the third row and last four rows. The first row second and fourth rows had 0 in the output and all other rows have 1 in the output. And if you map it this is what we got.





(Refer Slide Time 6:48)

 

What we did last time was to simplify this using 1 here and then here, of course this is a trivial example, even though there are large number of 1s if the pattern is good large groups of 1s together it will give you a very small sum of product expression because larger and larger groups give you smaller and smaller product terms, that way we had a nice example. In this example we had A for this and BC bar. But just to give you the concept of using 0s to simplify the expression I am going to feel these entries of the truth table which had output false with 0s I am going to use 0s to simplify my logic function. So if I group these 1s and write prime implicants I will get F expression, expression for the output F. 

If I now group these 0s and identify prime implicants or essential prime implicants I will get F bar is it not, whenever the function is not true there is a 0 entry in the truth table as well as in the Karnaugh Map. So now I am going to group these two 0s and these two 0s so I will call this one, prime implicant one, prime implicant two, F bar is sum of prime implicant 1 and sum of prime implicant 2, a combination of prime implicant 1 and prime implicant 2 when you say sum you mean really OR operation which is 1. This is A bar B bar correct and this is A bar C (Refer Slide time: 8:32), this is only F bar but we want F because the problem definition or the truth table given to you is to implement a function F which has the output asserted as true for the given combinations but what we got is F bar output not asserted or output asserted as 0 so we do not want this but we want a complement of this and you know how to get the complement.

It is by applying DeMorgans theorem on both sides we get F which is nothing but A OR B because the variable gets changed into complement where AND becomes OR, OR becomes AND, variable gets complemented and you can simplify this to the original F which is A plus BC bar because now if I do this this would become A plus AB plus AC bar plus BC bar and the view of the identity in the Boolean algebra if you remember A OR AB is A so this is redundant similarly A OR AC bar is also A, this compared with this gives you A so these two terms get knocked off so the result is A plus BC bar and this is what this is.
 
(Refer Slide Time 10:33)

 

There are a couple of points I want to make really; one is, smaller number of 1s grouping is easier only if they are randomly situated actually. When 1s are nicely grouped we may find a simplified expression of a minimum form. But if we had 1s and 0s spread in the random fashion as more 0s than 1s and more 1s than 0s then may be it?s a good idea to go for simplification using 0s.
 
The second thing is this is the expression for F without this simplification. This simplification I need to prove that this is same as this, I can stop here. This is the minimum product of sum. This is the sum of product expression (Refer Slide Time: 11:24) and this is the product of sum expression. So if you wanted the solution in product of sum expression it is here, I would use this expression the minimum product of sum this is a minimum sum of product. 

Just as you get a minimum sum of product expression using Karnaugh Map I will also get a minimum product of sum expression using Karnaugh Map using 0s. Where will I use that situation? I will use the situation where I want to have OR gates feeding into an AND gates because here each product term is an AND gate and the sum term represent an OR gate. Sum is equal to OR, sum is an OR operator because you put a plus we call it sum plus it is an OR operation and dot is an AND operation. Hence the sum term represents an OR gate and product term represents an AND gate. So if you want to have fewer OR gates and larger number of AND gates I will use the sum of product expression or if I have fewer AND gates and larger number of OR gates I will use this. 

Thus depending on the topology as they call it I will have either a sum of product expression or product of sum expression even if number of 0s more or less even without considering the number of 0s and 1s in the truth table or regardless of 0s or 1s distribution in the truth table or the Karnaugh Map we may sometime want to write an expression as a product of sum expression. In that case I will use this approach. I will group 0s together and get F bar and then F but you can do one more thing, you can skip this by reading judiciously because A OR B is corresponding to this you because this I can do it mentally. Writing A bar and B bar and taking its complement knocking of the bars here and removing this AND and putting an OR also can be done in my mind and I can see that whenever two 0s are together this is A bar and this is B bar I can write this as instead of A bar I will use A, I will use an OR symbol using B. That means I will read the map as if I would read a product term. 

(Refer Slide Time 14:49)

 

I will read a sum term as I would read a product term except that I will remember to complement each variable and remember to complement each operation. The AND operation will be written as OR operation and variables will be written as its complement. So without going through these two steps which is of course necessary but I am not doing something which is wrong but I am just trying to simplify my procedure visualize the procedure such that these two things are mentally done in your mind so you directly read the map as this. Let us take one more example to prove this point. This time we will have a four variable map sigma m number of min terms will form the sum 1, 3, 4, 5, 9, 11, 14, 15. 

This is the map for F (Refer Slide Time: 15:47). I can use any variable I will call them ABCD so the variable for which the min term min terms for which the output is 1 or true or 1 which is this, 3 which is this, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15 this is the distribution. So this is prime implicant one essential prime implicant isthese two, this one cannot be combined in any other way, this is the most efficient way of combining because this one has to be combined so this has to be there, this one has to be combined, I could have combined this in this way but this is not necessary because I have already taken this one into account and these four 1s form a prime implicant. 

Now this first term will be this which is B bar D OR this one A bar B C bar then this one ABC. Simple, you have done this earlier. There is no ambiguity here in terms of non essential prime implicants and all that. On the other hand, if I try other terms have to be put in this so you represent this as sum of product this is a product of sum so you will put a product which is pi, capital M for max terms and small m for min terms so what are the max terms that will be there? Whatever term is not here that will be a max term so there will be a 0, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13. 

(Refer Slide Time 19:29)

 

It so happened that I equally chose just not that, I wanted to have a large number of 1s and large number of 0s so it happened when I took this example that exactly there are eight 1s and eight 0s. So you could have proceeded either way proceeded using the sum of product way or product of sum way. If you had a specific reason to go for a product of sum because you wanted to use AND gate fitting to OR gate I will have do it using sum of products and if you are going to have OR gates fitting to AND gates I should go for product of sums. But if you are not given a choice like that if you are not given a condition constraint like that.
 
In this case there are eight 1s and eight 0s I can go either way. So I will now put the 0s here and I will draw another map here same map but in order to avoid cluttering I will redo it here 0 0 so I can group these 0s into groups of two 0s or four 0s or eight 0s as the case may be based on the case may be based on the adjacency rule and then try to read them. So these four 0s form a group, these two 0s form a group, prime implicant, these two form a group so there are only three terms and I can write F bar and then take a complement of that using De Morgan?s identity or De Morgan?s theorem and then write the product of sum form bar, as I told you just now a while ago I can directly read the map for product of sum expression by treating a variable as its complement so when you read it you read it as a complement. 

Any variable is read as its complement and an AND operator is read as an OR operator and vice versa. So these four 1s would be B bar D bar if you want to write it as a sum of product. Since I want to write it as a product of sum this will be B OR D. so this will be B OR D. you look at these four as you would do for 1. The only difference is this would be read as B D if you are grouping 1s. When you are grouping 0s B would be read as B bar, D would be read as D bar then AND would be read as an OR. Hence instead of B bar AND D bar I will read it as B OR D that?s it. That is a simple trick if you want to call it. It is not a trick really it is a procedure which is bypassing some of the logical steps. This is not as if it is a new concept or anything or it is not a derivation.

(Refer Slide Time 24:04)

 

If these two were 1s I would read it as B I would read it as A bar B C, read it as A OR B bar OR C bar and finally these two 1s if it is one then it will be read as ABC bar where it will be read as A bar B bar C, this is your minimum product of sum, this is min terms, this is max terms, this is 1s, this is 0s, this will use AND gate fitting into an OR gate for the final output and this will use OR gate fitting into an AND gate for the final output if both are identical. Your choice of using this or that or if you are given a constraint as use many AND gates and only one OR gate you will use this. 

If you are asked to do many OR gates and only one AND gate you will use this (Refer Slide Time: 24:47), if we can use many AND gates and only one OR gate then we will use this. Sometimes these restrictions are designed because of the availability of parts because of the matching of the other part of the circuitry you are designing because you may want to have an inventory of types of parts of the same type but in different designs or different implementations. There may be several reasons why you want to go for this and that. I also told you the other day how to do a four variable, five variable map, six variable map. At some length we have done a four variable map, and conceptually that is good enough. We talked about implicants, prime implicants, essential prime implicants, non essential prime implicants, how to use a non essential prime implicant properly and all that. We will have to now go to some examples of systems small 1s, we will design and think of some real examples. so far I have been giving you min terms and max term lists without any physical relationship, any physical correlation or anything, it is just arbitrary sum of products, arbitrary product of sums, arbitrary 0s and 1s in the expression or arbitrary 1s and 0s in the truth table.

Before we move on to some of the real life examples I want to give you one more concept which is a very simple concept it is called ?don?t care condition?. This is called ?don?t care state?. What is a ?don?t care state?? I have a truth table here, the eight rows or a map with eight cells, a map with sixteen cells or a truth table with sixteen rows and we defined for each of these rows or cells an output to be true or false asserted to be 1 or 0, that means you are very clear what you want the output to be for each of the input combinations because based on that condition you are designing a system or a circuit.

On the other hand I may have a system a circuit, I will define the output to be true for certain combinations of the inputs when it has to be false for certain other combinations of the input and there may be some combination which are not covered in both the list. 
I can give you a list of combinations in input, how many combinations are possible with three inputs? Eight combinations are possible, out of these eight combinations I will say definitely for certain combinations let us say for three combinations the output has to be true and for another three may be the output has to be false and then there are two combinations which are not defined means you may not define it for many reasons, these combinations may not occur in your system or these combinations may occur but you don?t worry too much about that it can be 1 or 0 the output can be true or false because it is not going to effect your process in anyway.

















 
(Refer Slide Time 29:50)

 

Hence there are certain combinations in any system any circuit, certain combinations input for which you will not define the inputs, the inputs are undefined, it need not be define for practical reasons, such a combination of inputs may not occur in practice or the practical reasons could be such a combination of inputs if it occurs I really don?t know I don?t really care what it is because that is not going to effect my processing in anyway. 
Whatever is the reason if you want to say there are certain combinations of inputs for which I do not care that is way it is called don?t care state, I do not care what the output is so such cases are called ?don?t care states?. 

I will give you a simple example. Suppose I want to count 4 using one hand where in one hand I will use only four fingers all the time and the fifth finger will not be used so I will say, supposing I show a 3 like this you know it is 3 or I put let us say how much I show like this, this is also 2 because these four are the fingers you will have to look at, I am not showing any sign or whatever. 

But supposing I put three and this thumb also out I will always tell you to look at my four fingers and determine the condition like 3 or 2 or 1, and this finger you don?t even look at but I am showing this thumb you don?t even look at but I may put it like this, like this but it doesn?t matter because this is not going to effect you because this is 1 or this is also 1, this is also 2 and like that I may have four inputs otherwise three inputs and certain combinations by four inputs is going to affect my output so I would be worried about those, if it happens I have to take some action and certain other combinations if it happens I don?t care that thing is going to happen I don?t have to take any action. So we can always say 0 we are only interested in certain combinations of the input giving a logical output 1. When that is the case and when any other combination is coming the output can be 0 then you are very safe. I don?t want a false output whenever I have a condition for which the output is required to be 1 I need an output to be 1. If there is a mistake in that I will be worried but for all other conditions I want the output to be 0 whether they occur or not that is one way of looking at it which is fair enough. 

I showed you eight combinations in which for three combinations the output has to be 1 I am concerned about this, and for three other combinations I say 0 the you don?t worry, in case I can combine all these 3 plus 2 is equal to 5 and say for all other five combinations I can have them and when I don?t care about the output what does it matter to you if the output is 0. So I can say for all other combinations other than these three I want for which I want 1 the output is 0 I can do that. That means I will have more 0s and less 1s. Or I can say since I don?t care about the output those three combinations for which I want the output to be 1 and those two combinations for which I don?t care what the output is all the five combinations always produce an output of 1 and I will make sure that the three combinations for which the output should not be 1 for those combinations the output will always be 0 that is also possible. It is a reasonable argument, either both are reasonable arguments. But if you are doing so I fix this don?t care condition the states for which you really do not worry about the outputs the condition for which you do not worry about the outputs you are fixing it as a 1 or a 0 and when you put a 1 and a map you have to cover it you have to enclose it write a term. 

On the other hand if you put a 0 my number of 1s in the map gets reduced and when the number of 1s in the map gets reduced my expression becomes more difficult my expression becomes more complex. Fewer once is longer, each term will have more literals if the number of 1s is more. So I would like to use these conditions for which I don?t worry about the output, it is an advantage. Whenever I like I will use them as 1 in order to simplify the hardware but I don?t have to produce a 1 so whenever it is not convenient to me I will ditch it and use it as a 0. The advantage of this is I can use this don?t care condition to simplify my hardware. For example, I have a group of three 1s you put an extra one and make a nice term so there is a ?don?t care state? and in one of those cells I will use it as a 1 to my advantage to reduce my hardware to reduce my term. 


On the other hand if I already completed all my 1s and there are some don?t cares strewn around I will not bother to cover them and write terms for it. So use it to your advantage. The don?t care states are used to reduce the logic, it is not necessary to use every one of them. 











(Refer Slide Time 35:20)

 

Whichever don?t care states are useful to introduction further either the number of terms or in a given term if you can reduce the number of variables we call them literals. I said ABC, AB bar, A bar B bar these are all literals, A bar B bar are all literals, each variable?s inner term is called a literal and each is a term. There are two terms with two literals each, three terms with two literals, three literals, three literals. So by using don?t care if you can reduce it further either the number of terms or a literal in any of those terms then I will use it to my advantage use it as a 1. Otherwise I will not purposely go and introduce an extra term to cover a don?t care. I don?t want to introduce a term in order to include my ?don?t care condition?, it is a waste. So the idea is always to reduce the hardware. 

The theme of this course as I said in the beginning is reduce hardware, hardware reduction will result in power saving, cost saving, size saving, space saving and everything. That is why we want efficient hardware but reliable hardware, we can?t knock it of arbitrarily and say reduce hardware. Usually fifty percent of the terms I have reduced the hardware but you will not get fifty percent of marks you will get 0 marks that is the problem. I see it as a digital course so whether you get a 0 mark it is a 1 mark so it is right or wrong? So, reduction at what cost? It is the reduction without losing the reliability of the circuit. So let us take an example of that class I can use the same thing and put some don?t cares. I will take for example the same sigma M, what is the output or 1, what are the terms for which the output is 1? It is 1, 3, 4, 5, 9, 11, 14, 15 I don?t want to change any of these but instead of making all other terms as 0s I will say may be 6, 7, 8, and 10 are don?t cares. How do I write it? It is d for don?t care some books use x, this d will be replaced in some books by x, some books by phi, some books by capital D so all the same don?t care.


 
(Refer Slide Time 38:11)

 

Don?t care terms are, arbitrarily I put that why not I put these four? It is 2, 6, 7, 8 just to show the effect. I don?t have an idea of what it is going to look like. From the list of 0s I am arbitrarily assuming these four terms need not to be really 0s they need not be 1s they need not be 0s of the output but they can be don?t cares, you don?t worry about whether the output is a 1 or 0 for these four conditions of input combinations. So my map gets modified with don?t care, this is the modified map modified K map with don?t care states.
 
What are the terms for which there is 1 to start with? These are 1s, these are 1s, these are 1s, and these are 1s. Now I am going to add 2, 6, 7, 8 when I do 2, 6, 7, 8 I don?t mark a 1 there. Remember, if I mark a 1 there when I try to simplify this map reduce this map I will make an effort to include every possible 1 that will be unnecessary waste of effort. So what I will do is I will have to use another symbol. if I put a 0 again I may ignore them, if I put a 0 I will ignore it, if I put a 1 I will necessarily have to include it so what I will do is use another symbol I can use d or x or phi whatever is less. So let me use d, this is 2 (Refer Slide time: 40:12), 6, 7, 8. These four ds I have included to indicate the ?don?t care conditions? of those four combinations of the input. these four combinations of input in the acquired output need not be 1 it need not be 0 they can be anything, they can be either 1 or 0 because that does not effect my circuit performance in anyway because I may not have those combinations of input at all to start with or even if it does occur doesn?t matter to me what happens.

If that is the case then how do I simplify? Now I will have more options, I would probably do this plus 1, 2 or need not even have it I can have these four and these four (Refer Slide Time: 41:28). So this is my 1, this is my 2, this is my 3, prime implicant 1 essential EPI 1, 2 and 3 essential prime implicants.
 
Now remember, look at this and see that this d has not been included, this d is has not been included so it is not mandatory. It is not necessary to include all ds. At the same time I use d to my advantage I use these two ds because they are advantageous and I am able to make a simpler grouping of these two ds. If I don?t have these two ds I have to use this as one prime implicant which will have three literals. Now I have a prime implicant with has only two literals that means I am knocking one of the inputs of my gate AND gate that is an advantage, it is a hardware saving. So this is the concept of don?t cares and how to use don?t cares.

Now let us write the expression. Once you have don?t cares then combine them we don?t have to keep them separate any more, you can just write the expression as if, you write a normal expression.
 
(Refer Slide Time 43:44)

 

So one would be A bar B plus two would be BC plus three would be B bar, this is B bar and D. this is what we got now including don?t care. Out of four don?t cares I will really use only two and I have not used the other two because these two is an advantage, you exploit them to reduce the hardware. But at the same time don?t feel obliged to include every don?t care. It is going to be a burden to include every don?t care because it is going to unnecessarily give you more terms which are not recommended. If I want to combine this d I have to put one more term which is not necessary. This one is already covered you put a d here I will have an extra term with three literals which is a waste one extra NAND gate, one extra AND gate with three inputs and that input has to fit into an OR gate that means OR gate input also has been increased by 1 so all those extra burden is not necessary, it is the same thing with these three.
 
Originally we had this expression, we now have that expression B bar D is same in both, these two terms have been introduced, each by one literal. These two AND gates will now have the modified form with only two inputs, here we have three inputs so that is the advantage in this hardware so I am having three AND gates fitting into an OR gate. I am not writing the values here you know that this is A bar so you have to come through A and inverter B B C D inverter so now extra two inverters have to be also included. This is the story of the don?t cares. 

So now we have exhausted all possibilities of simplification. Of course I have shown you several things we saw in an arbitrary fashion. What I mean is sort of arbitrary, the examples we took. We didn?t take any device except don?t cares I tried to justify A plus B bar, A plus BC bar, I said can have a combination but justifying after we do this circuit. But now we have to do it the other way. 

We have to have a system like any system you want to design what you want from that system for that system you write the truth table that is the design. you identify a physical device system that you want, how many inputs are there in the system, how many outputs are there in the system, what is the input output relationship you want and for the input output relationship you want you write the truth table and from the truth table you can either use Boolean algebra to simplify it or go to Karnaugh Map and simplify it and you can do it the sum of products way or the product of sum way depending on the type of hardware relationship you want to gain.

Therefore what you have to do is to take simple examples of logic functions, arithmetic functions. The one interesting thing is in this course we have always been talking about logic gates logic means decision, true or false or AND and OR etc. For example this function is true why this is called logic because this function is true if and only if both the inputs are true and for all other cases the output is false. So we think of it as a logical statement, logically we can make sense. 

OR gate is a logical gate. If at least one of the inputs is true the output is true or an NOR gate you will say the other way. NOR is complement of OR, only if both the inputs are 0 the output is 1 and in all other cases the output is 0. 

But then I said these are all digital systems, many times it is also computational intensive. You remember we talked about the computers as the basic building blocks anything can be thought of as a computer. So the basic thing in a computer is an arithmetic circuit. Logic also comes in occasionally but mostly arithmetic add, subtract, multiply, divide and so on.
 
We will see that later on in this course in subsequent lectures. We can also build arithmetic using logic. Actually they are called logic gates but we will use arithmetic gates like add circuit, subtract circuit and things like that using these logic blocks. Why is logic same as arithmetic because there are only two things. We are talking about binary variables a variable which has only two values 0 or 1 so it doesn?t matter if it is arithmetic or logic because when you have two inputs we have to add these two inputs but only one output is possible, the adder will have two inputs and one output let us say we have to add two binary numbers. Two binary numbers you are going to add I have two inputs and one output and each of these inputs can have only two values and output can also have two values. So, if both the inputs are 0 the output is 0 the sum of two 0s is 0 but if one of the input is 1 the output has to be 1, if one is a 1 and the other is 0 the output is 1 the sum is a 1. So sum is 0 if both the inputs are 0, sum is 1 if one of the input is 1. 

What will happen if sum is 1 in both the inputs? Then 1 1 is input both the inputs are 1 the sum of two 1s is 2 and I can?t represent 2 but I can represent 0 or 1 so output has to be 0. And you should also remember to include another output called carry output which will know that when both the inputs are 1 output will be 0 even though the output is 0 sum is 0 it results in a carry so we will have to know how to handle the carry. But that is the arithmetic part. What I am trying to say is this is a logic function basically, I will have to look at the two values of the input to determine output. If the two values of the input gives me the output so my logic gates can be used for my arithmetic operations.

So what we have done is the basic introduction to the logic gates, introduction to Boolean algebra, we talked about min terms max terms, sum of products, product of sum, Karnaugh Map simplification, don?t cares etc but then all of them will have to lead to the realization of things which we need.

Therefore in the subsequent classes we will take design example from combinational logic both logically and arithmetic how we can design and build. that means you have to first design and specify a circuit, specify the inputs and outputs and find what is the relationship between input and output, represent from my truth table and use the tools that you have learnt, Boolean algebra or Karnaugh Map with or without don?t cares, sum of products, product of sum, etc then finally come up with the simplification and that simplification will be drawn in terms of true gates and that gate circuit will work as an arithmetic circuit so the logic circuit will become an arithmetic circuit. We will see in subsequent lectures. 
	


Digital Circuits and Systems
Prof. S. Srinivasan
Department of Electrical Engineering
Indian Institute of Technology, Madras
Lecture # 18

(Refer Slide Time: 2:05)

 

In the last lecture we have been seeing about the flip-flops as against the latch. In the latch you store a bit 0 or 1, in flip-flop also you do that but a flip-flop has an additional control called clock. When the clock is high only then the data can be stored in the flip-flop and when the clock is low whatever has been stored will be retained even when there is a change in the input.
 
We saw the basic SR flip-flop and the D flip-flop wherein a single bit data can be stored with single input D data input by connecting S and R through an inverter. Then we talked about the condition of 1 1 being not permitted for an SR flip-flop and see whether we can do something about it. So we modified the input AND gate into a three input NAND gate and found that it is possible to have an operation corresponding to S is equal to 1 R is equal to 1 wherein the flip-flops output keeps changing constantly from 0 to 1 to 1 to 0 and 0 to 1 to 1 to 0 so forth as long as the clock is high. When the clock is low of course it retains its content as a memory state.
 
Now the very frequent change of the output with an SR flip-flop with S is equal to 1 R is equal to 1 with an input NAND gate is disturbing because we don?t want that type of behavior, it is called racing I said, racing is not a desirable behavior. On the other hand it is a nice idea to have an input condition with 1 1 where the output changes from the present state to the complementary state. If the state had the output of 1 you will like to have a 0 output and from 0 to 1 back and forth 1 and 0 0 to 1 provided it does only once in a clock period. So we were thinking about how to prevent this racing and one way to do it is to make a clock active period much much smaller, very small, smaller than the propagation delay of the flip-flop. This is not a practical solution. There are couple of other ways we can do it. One way is called the master slave concept. 

(Refer Slide Time 6:50)

 

So what we will basically have in a master slave operation?

The input gates remember this and this went to the two NAND gate combination (Refer Slide Time: 5:48) this is the basic structure we discussed in the last lecture and this came from here and this came from here. Instead of that what I am going to do is to extend this into one more stage of the same identical flip-flop and the output of this I will feed into the SR latch as we did earlier. This is corresponding to the clock input. Now instead of tying the output of these two input gates what I will now do is to take this all the way from here after this second stage (Refer Slide Time: 6:58) I am duplicating this into this except that I do not need three inputs I need only two input because I am going to give external input only once. These are the external inputs, this is the input from the clock, this is the feedback now output of this will be fed into this, this is the latch with part of this flip-flop. 

Now I will have an identical stage of flip-flops where the output of this will be fed into this, output of this will be fed into this and then I have this basic SR latch here. This output will go into this (Refer Slide Time: 7:46), I am taking the feedback all right from the output but not immediately but after one more stage, one more similar stage I put and then take the feedback. So this I will call Q and Q bar, these are intermediate outputs and this also will be clock but one thing I will do is I will not connect the clock as it is into this but I am going to invert my clock and then connect this.
 
So now I have more or less a condition of two flip-flops, the clock is common but one of them is fed directly and the other clock is fed through an inverter, these are the two external inputs which we call S and R earlier and the third input comes from the output stage not immediately but after one extra stage the second stage. You put a second stage and take the output of the second stage and feed it back into the input.
 
Now this will behave exactly like the feedback flip-flop like we discussed yesterday except that this output will change only once in a clock cycle I will tell you why. Now the clock has to be high for any normal operation the flip-flop that?s what we said. The function of the clock is to enable the output to change as per the inputs when the clock is high and not change the output when the clock is low whatever the input is. Now, if that is the case I am feeding a clock here but an invert of the clock here. The clock is high for this flip-flop and it is low for this flip-flop. 

So if we consider this as one flip-flop whose output is fed as input to the second flip-flop, I will call this second flip-flop (Refer Slide Time: 9:55) this flip-flop and this flip-flop are identical of course there is an extra input is there the feedback input so this gate is a two input gate and this gate is a three input gate that is one difference but that is because I want the feedback only once. But more importantly the difference between these two flip-flops is that one has the clock which is high and the other is low and vice versa. 

Therefore, when the clock is high for this flip-flop this flip-flop will change state but this feedback is not going to happen because feedback is from here and not from here so this is constantly changing and the racing condition is not going to happen. Only when the output is fed back into these two gates because of the property of these NAND gates the input keeps constantly changing and the output keeps constantly changing. This flip-flop has a clock low when this clock is high. So when this clock is high this clock is low and when this clock is low whatever is the input then, it is not going to affect the flip-flop because the output is going to stay the same in its previous state the memory state when the clock of a flip-flop is low.
















(Refer Slide Time: 11:15)

 

So when this flip-flop is enabled or the clock of this flip-flop is enabled the clock of this flip-flop is disabled. Any change that is going to occur is going to occur here, anytime it can happen but only when the clock has completely changed from high to low here which means it is low to high here. Whatever is the output here will now go into this so the output of this flip-flop goes to the input of this flip-flop and it will change the output of this flip-flop when the original clock is low. But at that time the feedback in the changed signal cannot affect this gate and the output of this gate cannot change now because at this time the clock is low again. So the output fed back into the input cannot affect the operation of the circuit until the clock changes into 1 again. That means I am preventing this continuous variation, the variation can only be once, when the clock is high any change that may happen in this flip-flop can only happen locally and that local change will be transmitted into this flip-flop only when the clock of this flip-flop changes into high at a time this is closed. So any change that may happen because of this change at the output will be fed back but will not be recognized until the clock changes back to 1 again to original clock.
 
So I have a two stage flip-flop basically where the 1 stage clock being high the other stage clock being low at a given time and after some time the first stage clock becomes low and second stage clock becomes high so that way I am isolating the fluctuations from the output or output changes will not be reflected in the changes in the input stage. Such a combination is called a master slave combination, this flip-flop is called a master flip-flop and this flip-flop is called slave flip-flop (Refer Slide time: 13:36). The slave can only take the master?s output and convert into its own output. But that can happen only when the clock is enabled for the slave, and if the clock slave is enabled then already the master clock is disabled. 

So the output changes in the slave flip-flop will not affect the master output until the clock of that flip-flop becomes high which is only when at the end of that period, for this clock it is at half period. that means we are now making sure that changing from Q to Q bar when S is equal to 1 R is equal to 1 may still happen but only once in the clock period, when the clock is high when this master clock is high. 

(Refer Slide Time 19:00)

 

Instead of this toggling like we saw, this is the clock, this is the master clock as a function of time, it moves from 0 to 1 master output originally it would have been like this that is because of the feedback. But now the feedback is not there. So, if it was 0 earlier it will become 1 and then it continues to be 1 and until again it becomes 1 at that time it will become 0. So this change over from 0 to 1 to 1 to 0 will happen but only once during a clock period.
 
So the output of the slave will be only this, this change will be reflected into the output only at the end of this clock period (Refer Slide Time: 15:37) so that will be during the positive edge, at this point the slave clock will be low, when the master clock is high slave clock is low so the change of the master cannot go to the slave, at this point the slave clock becomes high so when the slave clock becomes high only then the master output would be recognized by the slave so the slave clock would be working like this. I mean slave output will be delayed by this clock pulse period. So the output keeps changing from 1 to 0 also here in this case just as in the case of the previous circuit like we discussed in the last lecture. Constant toggling is not there but it changes only once in a clock period. This is a toggling mode really. As I said toggling is a controlled change, racing is an uncontrolled change, toggling is useful we will see that later on how it?s useful, racing is not useful, and racing is undesirable. 

That means I have eliminated now S is equal to 1 R is equal to 1 problem which we had the original SR flip-flop. In the original SR flip-flop 1 1 condition was not to be used because as because for certain unreliability undefined performance, uncertain performance we want to remove that but we ran into a racing problem and we solved the racing problem by putting an extra flip-flop so this is a master slave configuration, it can work for any type of flip-flop, for D flip-flop also you can have a master slave. SR I have now made it like this, you can have two flip-flops with one clock connected to the master clock and slave clock with face inversion such a configuration is called a master slave configuration. It doesn?t have to be for only SR flip-flop. That means this new flip-flop is tamed for S is equal to 1 R is equal to 1 condition so I will now give a new nomenclature because the SR flip-flop will always bring back the memories of 1 1 being not permitted so I don?t want to call it a modified SR flip-flop or anything so this SR flip-flop with the feedback and an extra stage to control the operation this whole configuration is called a JK flip-flop, I don?t know why it is called JK flip-flop.
 
JK flip-flop works like this; so instead of calling this S input I will call it J input same as S input except for the case of S is equal to 1 R is equal to 1 SR flip-flop and JK flip-flop are identical. JK flip-flop works exactly like SR flip-flop for the three cases 0 0 0 1 1 0 for 1 1 case SR flip-flop is not permitted but JK flip-flop is permitted with the toggling output its all where you stay. 

(Refer Slide Time: 26:05)

 

So SR flip-flop plus this additional toggling facility becomes a JK flip-flop so this is called J and this called K so J K Q Q bar and we will also put a clock here when the clock is 0 no matter what happens J and K, output is a memory state, when clock is 1 0 0 is memory state, 0 1 is the reset state that means 1 1 0 1 0 this is the reset this is set 1 1 1 so what is Q we don?t know until we know what Q was Q toggle means that the previous value of Q is complementary the present Q is the complement of the previous Q so you can write toggling mode you write Q bar so you can?t write Q is equal to Q bar it does not sort of looks odd so what I should write is at this clock pulse if it is nth clock pulse what is the value of Q is for n minus 1th clock pulse will become the value now. so I will call this n this will be the previous value Qn plus 1 would be Qn plus Qn complementary, Qn complementary becomes Qn plus 1 or Qn minus 1 complementary becomes Qn so this is the toggling mode, this is a sort of a flip-flop in which all the conditions are made, we do not have to worry about 0 1 1 being encountered in your circuit as inputs and toggling has its own use we will see it later, you design counters toggling property has used.
 
So now to summarize we have now seen an SR flip-flop of course it is sort of a latch we can store a bit of information and keep it there and tell you change it then we want to do it in a controlled way whenever we wanted it that means introduce a clock and say when the clock is high only the inputs should be recognized so it is a clocked SR flip-flop and then we said we want to put a simple data bit 1 or 0 and thought of why we need two inputs so we converted an SR flip-flop into D flip-flop so in the D flip-flop with the clock whatever data you put in gets stored and with clock 0 whatever you put in the data does not get in but it remains the same as what it was earlier. And we modified the SR flip-flop into an extra gate with the feedback extra input of the input gate with a feedback and we called it a JK flip-flop where for that condition of S is equal to 1 R is equal to 1 or in this case J is equal to 1 K is equal to 1 we had the output complementary to what was earlier in the previous clock cycle and in order to avoid racing we had to put two of this in a master slave mode or master slave configuration, so this is the JK master slave flip-flop they call it. 

In the D flip-flop also you can have a master slave operation. If we have two D flip-flops as one connected to the clock high and the other connected to the clock low at the same time and when you put one value here that value gets stored immediately when the clock is high. But then that D cannot transmit into the next flip-flop because the clock of that flip-flop is low. As the clock becomes low for the master flip-flop so it cannot take a new value. Hence the value stored in the flip-flop will go into the second flip-flop the slave flip-flop because the clock of that will still be high. So I can have the data stored in the second flip-flop when the clock is low instead of having to store data when the clock is high. It can happen only once because the master is now 0 clock and whatever change I make in the D input, if you want to make only one change in your data per clock cycle then this is the best way to do it. If you want to make only one change in the data storage in one clock cycle or in one clock period you put a master slave configuration. The master takes it and the slave will not be affected. And whatever happens in the master will be transmitted to the slave at the end of the half period when the clock becomes low from high and at that time the slave takes the output of the master whatever be the value. But any more change in the master cannot happen because the clock of the master has already become low.
 
So to avoid racing this JK concept can also be applied to a D flip-flop a master slave D flip-flop is also possible. I said there are two ways of making sure that the data changes only once in a clock period. One is to make sure that data changes when the clock is low and when the clock is high do not put the data that is one way and the other way is to have a master slave configuration. Whenever the data changes the output also changes but for only once. The second stage data changes when the clock goes from high to low. It is the same case in a D flip-flop you put a D value the master will take it during the clock high but then it will pass it on to the slave the clock goes from high to low that is a master slave D flip-flop. The master slave is a concept but it helps to avoid racing in the case of JK.
 
That means we have all the combinations. In D flip-flop it is just simply storing the data, in SR flip-flop it is sometimes but most probably SR flip-flop is no use because you want to simply store data you put a D flip-flop if you want more than that the toggling action you put a JK flip-flop. There is no need to have an SR flip-flop. Generally SR flip-flops are not used that much. They use D flip-flop just for data storage purposes keep it and store it and whenever you want get it back or if you want to do some other thing with a flip-flop like a toggling action which I said which will be used in counters then use a JK flip-flop. These are the two most popular flip-flops.
 
Sometimes I want only this toggling action. in that case what I should do is I will take a JK flip-flop, now whatever I draw here as JK is the whole thing, these two inputs and the clock is only available to me and output Q and Q bar at the master slave are only available, internal feedback, the internal inversion of the clock are those things that are not available to me in a block. When I buy a JK flip-flop I have a single hardware where there are two inputs for J and K  and one input for clock, one output for Q, and output for Q bar, the Q and Q bar outputs are from slave and JK inputs are into this master and the internal clock gets inverted for the slave.
 
Of course you need to give some power supply no circuit will work without powering up, we need voltage and ground. You need two terminals; one to give the voltage called Vcc or Vdd depending on whether it is a Bipolar transistor technology or CMOS technology and then ground.

(Refer Slide Time: 28:29)

 

So I am not talking about power source how are you going to power up them? I am only talking about signals, JK or signals, output as a signal, clock is the signal. You have to know the difference between the signals and the power source. Power source is required. For any active circuit we need a power source. We will not consider power source in this drawing. Usually we will have to put in addition to that Vcc and a ground and all that. So JK and clock and Q and Q bar. If I only want toggling action, I have an input, I have a clock period and I want an output which is always toggling back and forth at the data 1 per clock period then I don?t have to go through this SR flip-flop type of thing I can as well connect these two together and J is equal to 1 and K is equal to 1 I will call this T input T for toggle, toggle input, when T is 1 it toggles and T is 0 it is the memory state. When T is 0 it is 0 0, J is equal to 0 K is equal to 0 is a memory state, J is equal to 1 K is equal to 1 is toggle state that is why the input is called toggle input, when T is 1 it toggles and T is 0 it doesn?t toggle or it stays and of course clock is required.

(Refer Slide Time 31:40)

 

So what will be the truth table of this or characteristic table of a T flip-flop? Clock T 
Qn plus 1. When clock is 0 output remains the same no toggling action, and if clock is 0 it is the memory state always. For all flip-flops if clock is 0 it is a memory state, when clock is 1 and T is 0 again it is memory state. When clock is 1 high if I don?t give the toggle input which means it T is equal to 0 which means J is equal to 0 K is equal to 0 that means it is a memory state. When clock is 1 and T is 1 then this is Qn bar.
 
The previous value of Qn gets complemented of the new value, the next value of Qn is always the previous value complemented. So this is the toggle flip-flop the T flip-flop, sometimes you get a T flip-flop these are the two inputs that means I have to assume that internally it is a JK flip-flop where they have tied T and J and K. In the D flip-flop I said internally S and R are inverted. If there is an inverter between S and R then it?s called a D flip-flop, likewise this is called T flip-flop. That means there are totally four types of flip-flops we have seen; SR flip-flop with its own limitation of 1 1 condition, a D flip-flop where you can only put 0 data storage and not a toggling action and you put a JK flip-flop where it works for both the D flip-flop and a toggle flip-flop. So one JK flip-flop is equal to 1 SR flip-flop or one D flip-flop plus 1 T flip-flop and a T flip-flop only toggling happens. That means we can use any of these four flip-flops for the particular operation or performance of a circuit that we design. 

This extra hardware this slave hardware almost doubling the thing effort in terms of the number of gates hardware one of our goals what is one of our goals always been saying three things high speed, low power, low cost or small size so that means we are unnecessarily putting extra hardware. So, is there anyway where I can do the same changing only once in a clock period but not having to put an extra flip-flop duplicate an extra flip-flop? That is one reason why I may not used JK flip-flop sometimes. There is another reason why we may not used JK flip-flop. We said what is the fastest rate at which the clock can change? The fastest rate at which the clock can change is the time it takes for the propagation delay of the two flip-flops. 

Any flip-flop is a single flip-flop. How fast can I change the data and keep storing it or sending it out? At the rate the propagation delay is the time it takes for the data to travel. Of course in addition to propagation delay there are couple of things called set up time and hold time we will see this things a little later on in the course right now don?t worry about this terms there is a set up term, there is a hold term and the propagation delay. Let us bunch them all together for this discussion today and there is some delay involved. Within the delay I cannot change the input. That means if I clock it faster than that period corresponding to the delay then it is not fast enough to catch up. Any change in the input cannot catch up with the, the output cannot catch up with the changes in the input faster than the total delay of the flip-flop which includes propagation delay, setup time and hold time.
 
When that is the case of course in extreme cases only this is a problem. Most of the times in today?s technology the speed is so high we don?t have enough applications. There are very high speed applications where the speed is not really enough, that is the reason they go on improving the technology and inventing newer and newer circuits. That is because there is always a cutting edge technology cutting edge application. But in most of the applications today?s technology is so good where we don?t have to worry about all these things such as the propagation delay of the flip-flops. But still from a theoretical point of view you should know the limitations so the limit within the change of clock the limit at which the data can change is the period and if I try to change the clock faster than that then data cannot catch up with that. 

So if we now put two of them then there is going to be a slow down further. If the propagation of the flip-flop or the delay of the flip-flop that involves several things including the propagation delay then that is the limiting factor in my operation. There are conditions, applications, places where the delay of the flip-flop is the limiting speed it is not going to help me. If I had to put two of them it is going to reduce by factor two so I have to slow it down by factor of two and I am already worried about my cutting edge application where the speed is not enough. Now if I have a master slave configuration I need to have to do it at half the speed. 

There are always some extra things coming in here and there but approximately it is half this speed at which I can work a single flip-flop because it is two flip-flops two delays. That is one reason why we want to think of another scheme at the same time not allowing the racing, this is important. Racing is a very bad thing because you know want to have unpredictable performance. So without racing and without master slave is there anyway we can do it so that only once in a period once in a clock period the output can change. The second thing there is extra hardware I need. So there is a technique called edge triggered technique. 

We can make a little bit extra hardware it is not the whole lot of doubling the flip-flop type of thing but some modification in the given flip-flop can lead to a condition that once a change is made it will stay there for the entire duration of the clock and only when the next time the clock changes it will change again. This is where I want to define something called edge triggering and level triggering. 

When I said gate, it is an enabling function, gate has an enabling role to play, what did I say, when the gate is high clock is high rather clock is an enabling gate enabling function. Speaking about clock it is an enabling function, we said when clock is high flip-flop works normally and when the clock is low the flip-flop remains in a memory state.
 
Now within when the clock is high the flip-flop can change the output any number of times. I am not talking about master slave but the normal flip-flop a single flip-flop. If I want to avoid that what I should to do is that, the change in the flip-flop output should not be level sensitive, sensitive to the level of the flip-flop but it should be sensitive to the transition of the gate function. If the gate is high the clock is high, this is clock as the function of time (Refer Slide Time: 39:06) and this is t 0 1 and as long as the gate is high any change in the input will be reflected in the output. I am talking about the single flip-flop but not the master slave remember that. I am making a case for doing a non master slave flip-flop which will do only once in a clock cycle, non master slave flip-flop which will change the output only once in a clock period because I am going to save time delay as well as I am going to save some hardware so I am talking about that. 

Therefore when talking about a single flip-flop a non master slave operation when I have this, this is the period during which any change in the input will be reflected in the output. I don?t want this but I want the output to change for only once in that period based on what was the input at a given particular time. This is called level sensitive or level triggering. 









(Refer Slide Time 41:53)

 

On the other hand if I make my flip-flop whatever is the input at the time the input changes from 0 to 1 which is again the clock, the input can be anything here and the input can be anything here but it will recognize the input, it will monitor the input and it will sample the input this is the technical term known as sampling. The flip-flop will sample the input at the time of transition from 0 to 1 and correspondingly decide the output. Any change occurring within that clock period whether it is high or low will not be recognized so output will not change until the next clock transition occurs. Such an operation is called edge triggering operation. 

When I say once in a clock period only from 0 to 1 not from 1 to 0 or I can define from 1 to 0 as my reference point and not from 0 to 1 we should not do both the things because I want only one time a clock period I want one change in the output, the output should change once in a clock period, when that?s what I want I have to make it either sensitive to the rising edge that is going from 0 to 1 is called rising edge and this is called falling edge. Either the rising edge or the falling edge I can make a reference. There is no need that it has to be a rising edge. Some people call it as positive edge and negative edge. Even though all voltages are positive so we are talking about positive logic as I said 0 level is the 0V and 1 level is some volt like 5V or 3.3V.

When I say positive edge it means going from 0 to 1 and when I say negative edge it goes from 1 to 0. So I can make a flip-flop sensitive to my positive edge alone. Whatever input occurs whatever input happens to be there in the input terminals, whatever signal happens to be in the input terminals at the time of the positive edge transition that will determine the output for that clock period until the next positive edge occurs, that?s called positive edge triggered flip-flop. Likewise whatever input happens to be at the input terminals whatever signal happens to be at the input terminals at the time of a negative transition from 1 to 0 only those inputs will determine the output of that flip-flop for the entire duration of that clock period until the next negative edge occurs. Such a flip-flop is called a negative edge triggered flip-flop.

Therefore for example if the input keeps changing here, again here, again here this called positive edge (Refer Slide Time: 43:38) and on the other hand if the input keeps changing here clock 0 1 t all are functions of time and all these points are called negative edge points and all these points are called positive edge points. So if I design my flip-flop such that input changes will change the output based on of course the condition every time there is a positive transition occurring in clock such a flip-flop is called positive edge triggered flip-flop, input changes will set the outputs every time there is a negative edge occurring in the clock such a flip-flop is called negative edge flip-flop. There we have solved the problem of toggling because toggling can happen only when its level triggered. As long as the clock is high it keeps racing. We have solved the problem of racing because racing occurs when the clock is high and it keeps shuttling back and forth.

(Refer Slide Time: 44:05)

 

Since you can only change once there is no question of racing. So racing can be avoided by positive edge triggered flip-flop or edge triggered flip-flops plus we don?t have two flip-flops like a master slave. That means to that extern I can make it faster the whole flip-flop operation because there is only one delay I have [?.45:26] with but of course it doesn?t come free that you can?t just take a flip-flop and do it but you need to have some extra logic built into your original flip-flop. The original flip-flop as I said is the T flip-flop or a D flip-flop or a JK flip-flop but generally we do it for a D flip-flop.
 
In a D flip-flop because JK flip-flop is the master slave, most of time JK flip-flop is a master slave flip-flop because there are conditions of feedback and all those extra things. Generally JK flip-flops are master slave flip-flops and D flip-flops are edge triggered flip-flops. The reason is in JK flip-flop the toggling condition is more important they want to use it for toggling conditions and it is doing something meaningfully with toggling which has an application and such application need not to be very very fast really, it can be fast but need not be very very fast. This is a data storage application D flip-flop a data flip-flop as I said, you put a 1 and it stores, you put 0 and it stores and like to do it as fast as possible as a computer or something like that, an environment where memory has to be accessed very fast, the data has to be put in at a very fast rate and retrieved at a very fast rate. So they usually use edge triggered flip-flop or D flip-flops and master slave operation with JK flip-flop. This is not restricted but generally. You can have master slave D flip-flop no problem.
 
Now the input can change any time but it will be recognized at the given edge only and the output will change correspondingly. And that extra logic which is required to modify your D flip-flop, the original D flip-flop with the extra modification like some extra gates will block, what really happens is not a very great thing, it blocks the variation because of the nature in which the gates are connected. Once the variation occurs from 0 to 1 it remains at that time unless another transition occurs from 0 to1 so when we look at the circuit we can analyze the circuit and see how this change can occur only once during that clock period. That means the circuit is designed such that only a transition from 0 to 1 in the case of positive edge or 1 to 0 in the case of negative edge can change the inputs of the flip-flop. 

Finally the input with SR latch, do you remember that back to back connected NAND gate? It is always there in D flip-flop that is the core, we started with that core, back to back NAND latch, two NAND gates connected back to back. If the input doesn?t change for that then nothing can happen. Whether the clock is high or whether the clock is low any change that occurs in the input cannot affect the output as long as the input to those SR flip-flop does not change. In the case of using some extra logic when we need to have some extra gates it will prevent these changes that are occurring except in the case of 0 to 1 transition in the case of positive edge and 1 to 0 transition in the case of negative edge.

 I am leaving this as a reading exercise. Please go over some books standard text books in which they will tell you the configuration of edge triggered D latch edge triggered D flip-flop. There is an extra logic involved, please try to understand that logic, please try to first  locate that circuit and then understand the operation of that circuit and why the input changes from 0 to 1 and 1 to 0 which can only make a change, the clock changes from 0 to 1 and 1 to 0 can only change the output. That is because as I said it blocks the variation within that period, it blocks the variation to the input of that final latch and the final latch is the SR back to back NAND latch. That latch input should remain constant for that whole clock period whatever it happens elsewhere. Why it happens is that the way in which the logic is designed makes it possible.

I leave it as a reading  assignment to you, look at a standard text book in which they will tell you the concept of edge triggered flip-flops, give you a circuit diagram, look at the circuit diagram and understand the circuit diagram of how it works and also analyze why this is behaving the way it is. We have now seen four types of flip-flops as I said D flip-flop, SR flip-flop, T flip-flop, JK flip-flop and using them what we can do we will see in the next lecture. 

Digital Circuits and Systems
Prof. S. Srinivasan
Department of Electrical Engineering
Indian Institute of Technology, Madras
Lecture # 19

(Refer Slide Time: 2:05)

 

We have been talking about different types of flip-flops namely the D flip-flop, SR flip-flop, JK flip-flop and T flip-flop. We also talked about level triggering and edge triggering, we talked about master slave flip-flops. So today we will look at the behavior of some of these flip-flops, different types of triggering for easy and the waveforms I am using a D flip-flop because D flip-flop has only one input but if it is SR or JK we need to have two inputs. So in order to determine the output we need to consider two inputs at the same time. So since I thought I would explain the difference of behavior of the output of different types of flip-flops in terms of triggering, master slave, positive edge triggered, negative edge triggered I am using D flip-flop as an example. The same concept may be extended to the other types of flip-flops JK or SR or T. 

Now I am assuming a clock waveform, this (Refer Slide Time: 3:41) is the waveform of the clock 0 to 1 keeps going this is the clock period. Of course any flip-flop clock need not have, first of all they need not be the period of the clock from one positive edge to the next positive edge or from one negative edge to next negative edge it need not be uniform. Of course generally regular clock generation if you do using standard circuits you will always have uniform periods in general it doesn?t have to be.





(Refer Slide Time 4:15)

 

Likewise it doesn?t have to be equal, the level 0 and level 1 of the clocks need not be equal. Again, if you want to make them equal you can. You might have heard of this term duty cycle. A duty cycle is the time for which the clock period is on compared to the total period. The ratio of the on period of the clock or the high period for which the clock remains high to the total clock period is called duty cycle. Duty cycle can be half if you have positive and negative regions of the clock pulse equal in time interval otherwise it is the non fifty percent duty cycle. I have assumed an arbitrary clock but my only requirement it has to go from 0 to 1 back to 0 back to 1 back to 0 back to 1 so it is an arbitrary clock.

I am assuming that this clock is applied to different types of flip-flops, to D flip-flop of different triggering with different triggering mechanisms such as edge level triggered, edge triggered, positive edge triggered and negative edge triggered. So first I am applying it to the master slave flip-flop. In the master slave flip-flop first I would like to low, the master slave flip-flop is a level triggered flip-flop it is level sensitive, when the clock is high any change in the input D will change the output but when the clock is low of course changes in the input D will not affect the output. So if there are two flip-flops master and slave the master flip-flop is the simple level the sensitive flip-flop wherein when the clock is high this D is going to change the output. But since you are feeding it to the slave flip-flop whose clock is low and when the master slave clock is high the changes that happen will not be immediately reflected in the output of the slave that is the concept of master slave flip-flop.

So what is the change in the master output? Master output is the level sensitive output when the clock is high. This w is an arbitrary waveform of D (Refer Slide Time: 6:37) I said it is a good practice to change the data or any inputs of the flip-flop only when the clock is low but I have not adhered to that rule here I have given an arbitrary D which changes at random. So D remains 0 to start with becomes 1 somewhere here in the middle when the clock is low again goes low when this clock is low and the second time it goes high in the middle of the clock when the clock is high it remains high for a while goes low again somewhere when the clock is low then again it goes high and this time it goes low when the clock is high. so you have all types of things changing when the clock is low both from 0 to 1 and 1 to 0 changing from 0 to 1 when the clock is high changing from 1 to 0 when the clock is high I have put all the combinations possible so that we can analyze behavior of flip-flop completely. So in a master slave flip-flop first I am drawing the waveform corresponding to the master output which is going to be fed to this slave. So master is a level sensitive level triggered D flip-flop whose output will follow the input when the clock is high.

When the clock is low nothing happens, and here even though D changes to 1 nothing happens at the output because the clock is low. At this point the clock becomes high and the D is 1 so output has to become 1. The output remains one through out the period of the clock on and since it continues to be 1 here the change from 1 to 0 during the clock negative or clock being 0 will not be immediately recognized will not immediately reflect the output and this change from 1 to 0 all the D input when the clock is low will be reflected at the output of the flip-flop only when the clock becomes 1 again and that is the behavior of any flip-flop. When the clock is low the entire flip-flop behaved as they are in a memory state. So this 0 to 1 transition shows here in the next clock edge and next time the clock becomes high but immediately thereafter when the clock continues to be high the input changes from 0 to 1 so naturally the output also has to be change from 0 to 1. 
 
So the D flip-flop output in a level triggered mode is just you have to follow the input along with the clock high. If the clock is low you just stay put that is the easiest way to remember to do that. So this follows this continues to be 1, clock is low continues to be 1, clock is high continues to be 1, when the clock is low it goes to 0 but it not reflect at the output until the next clock happens, during the next clock period in the next clock on period so at this point in time this 0 to 1 transition will be reflected so this 0 to 1 transition is reflected here, this 0 to 1 transition is reflected here (Refer Slide Time: 10:05). And then in between it goes, this 1 to 0 transition reflects here, this 1 to 0 transition will reflect here when the clock becomes high again and since when the clock is high the input goes from 1 to 0 and the output also will become 1 to 0. This is the master output of a master slave D flip-flop or also the output of a level triggered D flip-flop. Both are same master and slave are both level triggered so we can call this either a Q output of a D flip-flop when the flip-flop works in the level triggered mode level sensitive. Level sensitive D flip-flop output or the master output of a master slave D flip-flop. 

Now in the case of master slave flip-flop this output of the master is fed to the slave as the input D at the slave and the output will change according to the clock of that slave flip-flop which is the inverse of the original clock. This clock inverted is the slave clock. So now again originally it is 0 actually. We started with 1 to 0 again 0 output initially and this change in the input which reflects the change in the output of the master will go into the slave only when the clock becomes 0. At this point in time the clock of the master becomes 0 and the clock of the slave becomes 1, the clock of the slave becomes 0 here and 1 here so this is a 0 to 1 transition of the clock for the slave so this change will come here.
 
Now again during this period this is on and once it is high s will this be seen now? Because now this is going from 1 to 0 of the output and can reflect the slave output only at this point only when the clock becomes 0. When the clock becomes 1 to 0 this change in the master output can reflect in the slave only at this point in time but before that what has happened is the master has become 1 again. So this change in the D in between is completely ignored. So at this point in time it was above to go to 0 but then it finds that it cannot go to 0 because the output of the master has already become 1 so it has to follow the master. 

So the output continues to be 1 and this output becomes 1 to 0 which will be reflected at the slave output at the next negative edge or when the clock goes from 1 to 0. So this gets reflected here (Refer Slide Time: 14:14). This change is ignored by the slave. Likewise it became 1 here when the clock was low so when the master clock became 1 the output became 1 and continued to be 1 for a while and then it got 0 but then this one could have been reflected in the slave at this point in time before which the master output has become 0 so there is nothing to follow. 

(Refer Slide Time: 15:26)

 

The slave follows the master output. The master was one at the beginning of the clock cycle had the 1 continued at the negative edge of the clock slave would have followed it. But before that master output has become 0 in between in the middle of the clock period so again this is ignored. Now this is interesting in one sense.

What we said was always change inputs when the clock is low but when the clock is high do not change inputs. Now automatically that is taking care of this. Only those inputs change which were made when the clock was low changed the output of the slave, this change happened when clock was high that is ignored by the slave, this change occurred when the clock was high ignored. That means this input change and this input change which are both of the value when the clock is 0 these are the ones which are reflected. So this is the slave output in which these temporary pulses these are called glitches, and momentarily the output goes from 0 to 1 back to 0 or 1 to 0 back to 1 these are called glitches which are undesirable but I want only flat waveform 0 1 0 1 like that. Any waveform to be of use should last for at least for one clock period. 

If you want to use it, if you want to use any output I need to have it at least for one clock period so that it can activate whatever mechanism or output devices which needs to activate. This is a narrow pulse very small portion fraction of the clock period which again is a narrow pulse. These two narrow pulses or glitches would have been eliminated in the master slave flip-flops. So, master slave flip-flop serves the purpose of frequent changes in the input affecting the master and not reflected in the output of the slave. It only makes the change once in a clock period. 

Originally we thought of master slave for avoiding racing. To avoid racing we thought of that because that is the same as this and in effect this is the same as this because there are two frequent changes within a clock period. Within the clock period being on there are too many changes in the output which we did not like so we avoided many changes in the output when the clock was high, and that is also the same thing here. So that design which was originally made to eliminate the changes in the output of the clock output of the flip-flop too frequently also helps us to ignore glitches. This is one operation, one option to have a master slave operation is to make sure that the output do not change frequently but they only change once in the clock period where any racing condition can be avoided. The other possibility is to use edge triggered flip-flop which is mentioned by me in the last lecture towards the end. I can have a mechanism or an extra hardware within my flip-flop which will make sure that once output transition takes place it will not happen again within the same clock period but it will only happen in the next clock period. 

You can let the output change during the clock changing from 0 to 1 which is called a positive edge transition or when the clock changes from 1 to 0 this is called negative edge transition. So one is called positive triggered flip-flop and the other is called negative edge triggered flip-flop. In a positive edge triggered flip-flop all you have to do is to look at the input at the time when the clock goes from 0 to 1 and whatever will be the output based on that input will be the output for the entire clock period of that clock period. You don?t have to worry about what happened in between until the next clock edge comes. It is the same thing in the case of a negative edge triggered flip-flop. 

Once there is a change the flip-flop looks at the input at the time when the clock transits from 1 to 0 and that will decide the output and that output remain same until the next negative edge comes. In between you don?t about worry about the changes that took place in the output. Therefore from the same clock period I have now drawn the positive edge triggered output. Had this been a positive edge triggered flip-flop instead of a master slave flip-flop, instead of a master slave flip-flop had it been a positive edge triggered flip-flop how will the output change? All you have do is to look at the positive edge, this is called positive edge (Refer Slide Time: 21:29) and find out the output at the positive edge and that input will be the output for the entire clock period. so at this point it is 0 so for one clock period it is 0, at this point it is 1 so for the next clock period it is 1, at this point it is 0 so this pulse is not going to be recognized so it has become 0, at this point it is 1 it is 1 here and at this point it is 0 so 0 and at this point it is 1 so 1 even though it doesn?t fall back to 0 it continues to be 1. So once it becomes 1 it continues to be 1 until the next positive edge comes. At each positive edge you look at the data and decide the output and that output remains until the next clock edge comes and again at the next clock edge look at the data and decide the output.
 
Now it is not the same as this but now at least here the output remains stationary for the entire clock period and in between there is no output change. In the positive edge trigger if you apply this D flip-flop it happens only like this (Refer Slide Time: 22:55). It changes for one clock period, one clock period, one clock period but change in the input of the clock even though it occurred in the middle of the D pulse middle of the clock it is recognized here. So that way it is different from the behavior of this. Even in positive edge triggered flip-flop we have to be careful not to change the input....., even though output will change now only you do not want to have this change in the input when the clock is high, you should be careful not to give input changes or not to change inputs when clock is high because it will result in affecting the output. 
 
Negative edge triggered flip-flop the same logic applies except that we now look at the negative edges and positive edges. What is a negative edge?
The negative edge is one which goes from 1 to 0 so this is a negative edge, this is the negative edge, negative edge, negative edge, negative edge and so on. In each of the negative edges you look at the input and decide the output. here it is 0 so the output is 0 for one clock period, (Refer Slide Time: 24:00) at this point it is 1 so 1 for one clock period and at this point it is 1 so 1 for one more clock period, at this point it is 1 so 1 for one more clock period, this point is 0 so 0 for one clock period, this point is 0 so 0 for one more clock period, this is 0 so 0 for one more clock period that is all.














(Refer Slide Time: 24:24)

 

Incuriously this is same as this. so a master slave flip-flop works like a negative edge triggered flip-flop so I have a choice now, I can have a master slave flip-flop, I can have a positive edge triggered flip-flop or I can have a negative edge triggered flip-flop, the waveforms are given. A waveform of the negative edge triggered flip-flop is identical to the slave waveform of a master slave flip-flop. If you want the waveform of a master slave flip-flop identical to the positive edge triggered I can do it by giving the negative of the clock to the master and regular clock to the slave. 

I now have a clock which I fed to the master, I inverted it and fed to the slave but instead I take the clock invert it and give to the master and then invert it again and give to the slave. That means the original clock is given to slave and inverted clock is given to the master then the behavior would be opposite. Therefore a master slave flip-flop will behave like a positive edge triggered flip-flop, so I can have any combination of the outputs or any combination of the behavior. Any behavior that you want can be achieved. 

So having talked about latch being a storage element a bit storage 1 or 0 and making sure that we need some timing or a control pulse to decide when the data will be stored we introduce the clock and we call the clocked latch a flip-flop and then we get SR flip-flop and we wanted a single input so we made D flip-flop and said we wanted to remove S is equal to 1 R is equal to 1 condition made it a JK flip-flop and we worried about racing and removed the racing by introducing master slave concept or a edge triggered concept and also had a T flip-flop where only toggling will happen and I also explained about the behavior in terms of waveforms and everything namely circuitry, symbols, characteristic tables and so on.
 
The next question is what do we do with all these flip-flops?
 
D flip-flop as I said is simply used for data storage. So we have a data and store a bit of information you give it to D and clock it and it will store it, it is available in the output and I want to change it you put another value of D and then clock it again.

(Refer Slide Time 30:20)

 

JK I said in addition to data storage of course data storage of JK will be put to two inputs 0 1 for 0 storage and 1 0 for one storage in addition you can also use it as a toggling mode.

So first let us look at that feature because data storage is a simple thing, I put a data clock it so it has a storage data. SR and JK I need to do the same thing except that data has to be 0 1 1 0 combination. So the one in which the feature is sort of different is the toggling feature. Let us see whether we can use a toggling feature. So let me draw a JK flip-flop, here after I will only use blocks, use a block and it is all inside, the circuitry. So let us say it is an edge triggered flip-flop or a master slave flip-flop it doesn?t matter, let me call it a negative edge triggered flip-flop or a master slave flip-flop because both are of the same behavior. 

By the way when you write the symbol let us say JK and put clock here let us assume it is a level triggered clock level triggered flip-flop. If you think it is edge triggered you have put an arrow like this a knife edge, it is a point, meets only one point in time at one instant time this is the symbol for edge triggering. If you put like this it is a positive edge triggering (Refer Slide Time: 29:10) so this is level triggering you put like this it is edge triggering positive edge triggering and you put like this an arrow with a bubble where bubble is always inversion wherever you see bubble that is why in inverter you have a bubble, NAND gate is a bubble, NOR gate is a bubble so bubble stands for inversion it?s a negative edge triggered flip-flop. These are symbols used. Of course you don?t have a separate symbol for master slave you put like this for master slave also because master slave behaves like a negative edge triggered flip-flop. So let me assume it is a master slave flip-flop or a negative edge triggered flip-flop and I put J is equal to 1 K is equal to 1 when J is equal to 1 K is equal to 1 what happens to the output? The output toggles, the present output is the complement of the past output. The output during this present clock cycle is the complement of the output during the previous clock cycle or the output of the next clock cycle is the complement of the output of the present clock cycle, this mode is called toggling mode. 

I am going to draw a clock waveform if it is a negative edge triggered or a master slave flip-flop it doesn?t matter. So I am giving this clock here to this input I am making J is equal to 1 and K is equal to 1 what is the 1? 1 is 5V or high level voltage, it can be 5, 3.5 or whatever voltage you choose in your technology. Now let us assume initially Q was 0 and at the negative edge the output will change, it will change to the complement of what it was. So it was 0 to start with, this is time access (Refer Slide Time: 32:40) and at this point in time it will become 1 1 input and the output changes to its complement and I am giving this clock input and the clock negative edge because of the negative edge, the original Q was 0 and at this point the Q becomes 1 and at this point it becomes 0 and this point it becomes 1. 

Now can you not see something in these two? As I mentioned earlier the period of a clock has the point from which you start from one point in the waveform and reach an identical point in the next cycle so here to here is the period, from here to here is the period, here to here is the period and in this case this is the period. For every two clock periods here this clock period is 1 so we have one period for every two clock period of the clock or it is positive for one whole clock period, but earlier the clock period was half positive half negative that is half 1 and half 0 now for the whole clock period it is 1, and for next whole period it is 0, and for next whole period it is 1 and so forth. So I am having an increase in the clock period by a factor of 2 or reduction in the frequency by factor of 2. So if you want to divide a clock frequency by a factor of 2 I can put it through the JK flip-flop and take the output of the Q. So basically a JK flip-flop is with J is equal to 1 K is equal to 1 or J is equal to 1 K is equal to 1 you want a special name for this then it is called toggled flip-flop. So instead of showing it as JK flip-flop you can say T is equal to 1 so when J is equal to 1 K is equal to 1 it is called T mode toggle mode. A toggle flip-flop is divided by two flip-flops.
 
Now if I take another flip-flop whose output is again J is equal to 1 K is equal to 1 and this clock period I am going to not give this clock but going to give this clock divide by two clock. If this clock is fc and this should be fc divided by 2. That fc by 2 would be fed to the clock by the second flip-flop so the output would be fc by 4 so we will call this Q1, call this Q2, Q2 will remain 0, here it will go 1, 0, this is my Q2. So every clock pulse period become half a period here so one clock period of this is equal to two clock period of this, now every clock period becomes half clock period here and I can go on dividing this further and further. So if I have a two flip-flops I get the output of fc by 4 circuit so if I have n flip-flops let us say P JK flip-flops with J is equal to 1 K is equal to 1 then divide the input clock by 2 power P. so here you have straight away got a use for the flip-flop. I want to divide a frequency a frequency divider, I have a large frequency I want to divide it for many reasons. Can you think of places where frequency has to be divided just it?s a very simple general knowledge question, just come up with some answers. Where will you need a frequency divider? watches is a good example, minutes has to be divided into seconds and seconds has to be divided into minutes and minutes into hours and hours into days and days has to be divided into weeks and so forth.

(Refer Slide Time: 39:40)

 
 
So one simple use of this flip-flop at least in the toggle mode is you keep on dividing the input clock original clock by a fraction of two every stage where p stages get divided by a factor of 2 power p. Now I don?t have a space to draw this waveform. supposing I have four JK flip-flops or negative edge triggered flip-flops JK all Js tied to 1, all Ks tied to 1 this is Q, Q, Q, Q I will call this QA QB QC QD so this will be Ja Ka Kb Jb Jc Kc Jd Qd (Refer Slide Time: 41:05) so this flip-flop is D flip-flop, C, B, and this is A. There are four flip-flops A B C D all negative edge triggered JK flip-flops and connecting the outputs like this. 

Let us look at only the 0s. When the first clock becomes 0 the output of this is 0 0 0 0 that is four 0s then this becomes 1 and this continues to be this (Refer Slide Time: 41:49). After this this becomes 1 0 0 0 when this 1 becomes 0 so the first flip-flop immediately the QD flip-flop for every clock period it goes from 0 to 1 1 to 0, 0 1, 0 1, 0 1, 0 1 like that. QC goes like 0 0, 1 1, 0 0, 1 1, 0 0, 1 1, 0 0, 1 1 because every two clock pulses of the QD will only make this one change. Now this will be again repeated and this will remain 0 for four clocks then become 1 and remain for more four clock pulses, this will remain for eight clock pulses 0 and another eight clock pulses 1. 






(Refer Slide Time 42:20)

 

So if you want to draw instead of drawing waveform of course since I don?t have space to draw waveform for sixteen clock cycles I will do it in binary. So supposing this clock is QA QB QC QD this is 0 1 0 1 0 1 0 1 0 1 0 1 (Refer Slide Time: 43:20) and this will be 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1????.

The value of QD during clock period let us call this clock period this is clock 0, clock 0 1 (Refer Slide Time: 44:10) we will all start with binary 0 1 2 3. So during clock period 0 all the outputs are 0, during clock period 1, during clock period 2 so during clock period 15 what it tells you? I have a circuitry to count the number of clock pulses. All I have to do is to find how many clock cycles have elapsed from 0. All I have to do is to look at the waveforms of the clock A B C D, if QA is 1, QB is 0, QC is 1, QD is 0 I know it is 1 0 1 0 which is the tenth clock pulse counting 0 as 1, starting from 0 actually it is the 11th clock pulse but we have to always number from 0 to 15 because there are only four bits. So this also can be used as a counter. they divide by two circuits, the divide by 2 power n circuit can be used as a 2 power n counter so this is 2 power 4 counter, using P flip-flops we can have 2 power P counter and when you say 2 power P counter we count from 0 to 2 power P minus 1. The 2 power P is 1 to 2 power P but we have to start with 0. 

So looking at the waveforms of the four outputs A B C D you know that it goes from 0 1 0 1 0 1 0 1??? Any combination of outputs you can look at and see that it is the fifteenth clock cycle, this is thirteenth clock cycle that means including this starting from 0 fourteen clock cycles, this is the thirteenth clock cycle if 0 is counted. If we start counting from 0, start the count from 1 and after that what will happen is after fifteenth it will become 0 0 0 0 so we cannot count beyond fifteen, with four flip-flops I can only have a 2 power 4 counter. If I try to give the sixteenth clock pulse what will happen is this will become 0 because this is 0 1 0 1 0 1 0 1 so this will be 0, 0 0 1 1 0 0 1 1 so 0 0 1 1 so next will be 0 (Refer Slide Time: 46:45), four 0s, four 1s, four 0s, four 1s, so this will be 0 and here it is eight 0s eight 1s so this will be 0s. So sixteenth clock pulse will revert it back to 0 0 0 0 again I start counting so it is called a Modulo Counter Modulo 16 Counter that means after 16 it is 0 or modulo 2 power n counter, modulo 2 power p counter. So if we have P flip-flops I can count any pulse starting from 0 to 2 power P minus 1 and if the next pulse comes 2 power Pth pulse comes all of the flip-flops will become 0 0 0 0 so I will have to start all over again. We have already seen two uses of these flip-flops. One is that you divide this 2 factor clock division like somebody said in watches you can use it and the other thing is use at counter. 

Hence, suppose I want to count the number of people in this room all I have to do is to put this counter at the door and the clock will be the one that would be generated by the person coming in as I said the clock need not be at the same period of duration or same duty cycle. So any time a person comes in the room there is a momentary going from 0 to 1 back to 0 that is your clock and I use this into my counter sequence so at any time I look at the pattern of the counters the waveform of the counters based on the combination of 0s and 1s in this counter I can say how many people have come to this room so this is the counter, basically a set of flip-flops will be used as a counter. 

It is a binary counter because we can only count binary values, you can make it decimal later on, we will see how to do that. 

(Refer Slide Time: 49:00)

 

This is a two binary counter, we will also see some other uses of this. Now the problem is I can terminate only when the number is 1 1 1 1. Suppose I want to count up to 10 and go back to 0 in a decimal counter that is I would like to count from 0 to 9 and back to 0 how do I convert this into a counter which can count from 0 to 9 and back to 0 or any other arbitrary value, suppose I want to count up to 12 I want to count dozens, I want to pack something by dozens, I have a product to be packaged I want to count 12 so how do I do it? After 12 it becomes 0 0 0 0 is it possible? So how do you make it count non 2 power n values and if you want to count up it is all right. But when people leave this room I want to know how many people have left this room so counting down also should be possible. So as people leave the room the count has to reduce by 1 so can we convert into an up counter and down counter, can we convert into a counter which is in count non 2 power n values etc we will see in the next lecture. 

	Digital Circuits and Systems
Prof. S. Srinivasan
Department of Electrical Engineering
Indian Institute of Technology Madras
Lecture # 20
Up/Down Counters

(Refer Slide Time: 1:07)

 

We were discussing the applications of flip-flops. In addition to being a storage element a flip-flop can also be used for division of the frequency by a factor of two each flip-flop divides the clock frequency by a factor of 2 and also can be used as a counter by stacking flip-flops serially by connecting series of flip-flops we can use it as a counter. We saw this in the last lecture. The counting depends on the number of counts or number of distinct states the counter has. We will depend on the number of flip-flops so there are n flip-flops the number of distinct states the counter can take is 2 power n so if we start the count with 0 it will go to 2 raised to n minus 1. You should also do a down counting. After all down counting and up counting is not very different because we know that Q and Q bar always complementary in any flip-flop. So when counting if you start the count with 0 0 0 0 let us say it is a three bit counter. 

Let us assume these three flip-flops have the outputs A B C as QA QB and QC so the count starts from 0 0 0 then 0 0 1 and 0 1 0 (Refer Slide Time: 3:55). Now if you look at the complementary outputs this would be 1 1 1, this would be 1 1 0??? so all you have to do is to use the same counter whatever counter we had for up counting but take the flip-flop states from the Q bar. 




(Refer Slide Time: 04:43)

 

So if you looked at Q bar instead of Q of the flip-flops you get a down counter. So I can have a 0 to 2 power n minus 1 counter using n flip-flops and 2 power n minus 1 to 0 counter also using the same n flip-flops depending on where I take the outputs from take the output from Q it becomes up counting (Q outputs up count) and Q bar output if you take it becomes down counting. So that is a very major use of a flip-flop, use flip-flops in a chain and for counting events.
 
Sometimes I may not want to count till the end of the last state that is possible within n bit counter we go from 0 to 2 n minus 1 and then go back to 0 after 2 n minus 1 count the flip-flop becomes 0 0 0 again. So I need to go through a full cycle the modulo as I said modulos the total number of states the counter has is called modulos. Suppose I want to terminate the count at a count which is less than maximum, if you want to terminate the count at the count which is less than maximum and go back to 0 I should be able to do it, example is the four bits we can have 0 to 15 but I may want to terminate with 9 that is 0 to 9 and start again with 0, there will be a decimal counter a decimal counter will come from 0 to 9 back to .Or for that matter I may want to start a count for a state which is greater than 0 I may want to start a counter for some reason 3 instead of 0 and then go out all the way up to 11 or 12 or whatever. 

So I may be able to start at any count or end at any count within the possible range. With four bits you can only go from 0 to 2 n minus 1, with four bits we can only go from 0 to 2 power 4 minus 1 which is 0 to 15 and in n flip we can only go from 0 to 2 power n minus 1 and within this range I may want to start any count and I may want to end any count and start all over again. How do you do that? By terminating the count and starting it again at any point there is some extra mechanism required. In any flip-flop whether it is a D flip-flop or a JK flip-flop I am talking about, let us take the JK flip-flop because that is what we have been using for these counters, clock it as 0 and this as 0 so it becomes a negative edge triggered with an arrow and a bubble. 
(Refer Slide Time: 8:30)

 

Q and Q bar is this and this is what we have been depicting as a flip-flop until now. Now I want to introduce two are inputs in this flip-flop. Of course there are two more inputs already which is the power supply and ground, no circuit will work without power supply and ground because these are active devices like transistors either Bipolar transistors or MOS transistors inside this. 

We have not gone into the circuit details but utmost we have gone into the gate level detail and not beyond that. Gates have active component like transistors and MOS devices. Let us not get into that but we need to power up those devices we need Vcc and ground or Vdd and ground depending on the nomenclature. Leaving those two inputs power supply and ground apart there are two more inputs defined for many of these flip-flops these are called preset and clear. 

This input is called PST stands for preset and CLR stands for clear (Refer Slide Time: 9:52) clear input and preset input. What does a preset input do? As we see there is a bubble here that means this is an inverted input. An input which activates the circuit when it is low is called active low input. Such inputs we draw with a bubble. An input which would be affective when you make it 0 is called active low. An input which will be active or which will activate the required thing when you put 1 on it?s called active high input. When you draw an input with the bubble it is called active low input. So the preset input when it becomes 0 what happens is it makes Q1 irrespective of the values of J and K and irrespective of the clock being positive, clock is 0 or 1. that means the preset input as called in electronic circuit parlance overrides all other inputs, PST is equal to 0 makes Q is equal to 1 irrespective of the value of J, K and clock at that instant of time and as long as preset is 0 output continues to be 1 and in between a clock may come and go, you may change J and K regardless of all that. Such an input is called an overriding input.
 
Likewise a clear input will make as the name suggests it clears the output means Q will become 0. These happen irrespective of JK and clock. So these two inputs are called as I said overriding inputs. So I need extra logic and to do that you can get into this little bit extra logic by regard to make sure that this has an overriding property of making the output 1 or 0 as the case may be. That means I can now write a table which is called preset clear table and preset clear Q, preset is 0, clear is 1, output is 1 and if preset is 1, clear is 0 and output is 0 and when preset is 1 and clear is 1 only then the flip-flop functions normally taking J and K as the inputs on the clock cycle. And at the clock cycle it goes past high or low all that will be determined and only when preset and clear are both made 1 they will allow influence on the normal functioning of the flip-flop. So the flip-flop acts normally as defined by the inputs and the clock. 

When you say normal the behavior depends on the values of the input J and K and the clock. And if both are 0 which is predominant to the other because each of them is a pre-overriding input and when both are 0 then we won?t know which one is overriding so one of those states is not permitted. Don?t try to do both clear and preset to 0. That means there is uncertainty. And I always tell you the uncertainty should be avoided on all cost in any design. Make sure that preset and clear are not made 0 at the same time.

(Refer Slide Time: 15:35)

 
 
Now this property is going to help me to start or count anywhere I like and end my count anywhere I like. Suppose I go from 0 to 2 power n minus 1 and at some intermediate point I want to terminate and make it 0 0 0 0 I can do that by detecting that point and clearing all the flip-flops at that point. Similarly I want to start the count other than 0 I detect the point at which I want that to happen and use my preset inputs to get the flip-flops in different values. So use preset and clear inputs to get the flip-flops to different values other than the normal sequence that is where you get an arbitrarily counter, it is not going to start arbitrarily and end arbitrarily but of course defined by you and I didn?t say it is random but it is arbitrarily that means you can decide what you want.
 
So let us take a simple example of a three bit counter and whether it is up or down it doesn?t matter because as I said all you have to do is to take Q or Q bar for up and down respectively. So the three bit counter will be three flip-flops all of them are JK one clock, this is Q and this is Q bar so I will call this A B C three counts, A is the most significant bit and C is the least significant bit of this, this would be QA this is QB this is QC or I want to call this as A B C.

(Refer Slide Time: 17:26)

 

So I have A B C normally I go 0 0 0, 0 0 1, 0 1 0, 0 1 1, 1 0 0, 1 0 1, 1 1 0, 1 1 1 or if I take the complements it will be 1 1 1, 1 1 0, so forth 0 0 0. I have just drawn the up counter you can draw the down counter by taking Q bars instead of Qs as I said now. Now let us say I want after 5, 0 that means I want count from 0 1 2 3 4 5 and back to 0. I don?t want the count 6 and 7 to go through for some reason but I want only 6 states to be counted. So all I have to do is to take this when 5 is reached clear all the flip-flops again by using the clear inputs. So all these flip-flops have clear inputs and preset inputs so I detect the count that I want to count and until that count reaches I will have to clear them. But I cannot clear it as soon as 5 is reached because if I clear it as soon as 5 is reached assuming there is no delay in the clearing operation I just reached 5 and it?s cleared that means I will go 0 1 2 3 4 completely done, 4 is completely done, 5 has just started but I want each count to at least last for one clock period so up to 0 1 2 3 4 as soon as 5 is reached assuming there is no delay in the process of preset clearing it will become 0 that means I will not have one full clock period for 5. So really I should start looking at 6, when 6 reaches if I want to terminate it at 5 I should wait for 6 and as soon as 6 reaches assuming there is no delay involved in the presetting process and in the clearing process as soon as count 6 is reached I clear all the flip-flops. Therefore it will go from 0 1 2 3 4 5 and even 5 will last for one time period of clock and the moment it becomes 6 immediately I will clear it. so there will be a small glitch, I referred to glitch in one of my previous lectures, a glitch is a very narrow variation of the output a very short duration output variation from either 0 to 1 back to 0 or 1 0 back to 1 a pulse of going from 0 to 1 back to 1, 0 to 1 back to 0 or 1 to 0 back to 1. It could be that there is a small glitch because of the small time delay involved in the clearing circuitry, there is a circuitry involved. If you neglect that the other alternative is for me to have clock count 5 only for a very narrow period which is not correct, I don?t want that I want full clock period for 5 also. 

So actually if you want to terminate at count 5 you clear it as soon as 6 reaches. How do you do that? I detect state 6 and use the state 6 to clear that. So state 6 is given by 1 1 0. This is count 6, count 6 is 1 1 0. If 1 1 0 is reached I should clear immediately all the three flip-flops. that means I should take this into an AND gate and 1 1 0 becomes 1 1 1 this is 0 when 1 1 0 is reached this is 0 (Refer Slide Time:: 21:42) so a three input NAND gate which will give 0 output when this becomes 1 1 0 or this becomes 1 1 1 and this is what I will connect to the clear inputs of the three flip-flops. 

(Refer Slide Time: 23:00)

 


So the clear inputs of this flip-flop?. and from where the A B C is coming from? They are coming from AC, in order to not clutter the drawing I put it here, this A B C are not different signals these are the outputs of the flip-flops, A is the output of this MSB flip-flop, this LSB flip-flop and this in between flip-flop. So assume the flip-flops A B C take the value 1 1 0 this becomes 0 so I would have a count 0 1 2 3 4 5 and momentary, momentary, momentary short duration count 6 which can be ignored as a glitch and then start all over again. If you do not want to start at 0 I connect it appropriately to preset and clear. Suppose I want to start with 3 so the second example is this (Refer Slide Time: 23:30) suppose I want to start at count 2 and yet end at count 6 I want counts 2 3 4 5 6 and back to 2 this is the cycle I want. I don?t want to count 0 and 1 and don?t want to count 7.

(Refer Slide Time: 27:30)

 


So again I will do the same thing. I will look at 6, 6 I have to complete I cannot detect when the flip-flop reaches the count of 6, I have to wait for count 7 to come up because 6 has to be completely allowed so when count 7 comes up which is 1 1 1 I detect that and not clear all the flip-flops in this case I will preset this flip-flop and clear these two flip-flops (Refer Slide Time: 24:27). So I will get the count 1 1 1 this is A B C this pulse will be used to clear A and C and preset B preset will become 1 so 2 will start and after that it will be 2 3 4 5 6 back to 2. 

Hence, by using this preset and the clear inputs I can start the count at any point and I can terminate the count at any other point, at any count we can start. And if you want to down count all you have to do is to look at Q bars instead of Qs so I have an up count, a down count and arbitrary starting point, arbitrary ending point and number of flip-flops as I said the number of counts, total maximum number of counts possible is 2 power n when n is the number of flip-flops since 0 has to be counted as one state or first count the maximum count you can reach is 2 power n minus 1. So this is how you count as I have already said counters are used to count people, to count events, count things, clock division is used all the flip-flops are very very useful circuits, in many applications you will find the use of flip-flops. We will see many more of them, do you any questions?
 
So in order to complete the drawing if you want to draw A B C this is my C B A Q I will not show the rest of the drawing of JK etc, you know what it is all Js are 1 Ks are 1. Now A B C when it reaches 0, 1 1 1 becomes 0 we count these two, this is clear and clear (Refer Slide Time: 27:15) and preset, this is my input clock, this is the counter which counts from 2 to 6. 

In any circuit there is a transient state, there is not even a guarantee that it is going to start with 0. When you switch on the flip-flop the first time arbitrarily the clock is applied arbitrarily the counter can reach where the first counter may be 1, second counter may be 0, third counter may be 1 or 1 1 0 it can be anything. The very first cycle of count you are not guaranteed of any starting value, it could all be 0, it could all be 1 or it could anything else but moment the second time that count reaches so there is a transient state, the circuit has to settle down, once the circuit settles down it does what you want. You never take into account the initial state after you switch on the power. The first time when you switch on the power there is no guarantee the flip-flop is going to start at 0 0 0, B may be 1, A and C may be 0 and so on. 

On the other hand 1 and 2 may be 0 and the other one may be 1 this is 0 0 1 or 1 0 0 so you have to go for 1 0 0, 1 0 1, 1 1 0, and when 1 1 0 comes it goes to 2 so that is the cycle. So the initial portion in linear circuit is called transients. You don?t talk about transient only with a steady state a stable state you analyze the circuit. In this case you can call it latency digital terminology digital parlance is called latency. Latency is the time you have to wait for the circuit to start working after you give the inputs. This is a very common word, latency is the time at which the circuit starts delivering the output after you switch on the power and after you give the inputs. So there is an in-built latency in any circuit.

(Refer Slide Time: 31:26)

 
 	
Now we have seen counters and we can design any counter we can and count up to 128 if you want to or 0 to 127 or anything else also. For example; think of a clock, somebody gave an example of a clock being divided by 2, example of a division of frequency. We have a very high crystal frequency, these clocks run on redundant crystal the watches the watch chips, let us call it watch. A watch chip an IC Integrated Circuit which is used in the watches it has this clock. This clock is derived from a very high frequency stable source called a crystal oscillator, there is a crystal. Generally it is easy to build crystals of very high frequencies, it is very difficult to get a crystal of 100 Hz, 10 KHz or something like that. 
Usually megahertz and several megahertz is the crystal frequency that is available which stable frequency. What do you mean by stable the frequency? The frequency will not drift. Some of the wrist watches you buy in some of the shops, bazaar you know what happens is you think it is a good watch and you buy for 25 rupees and the moment you start wearing it and the next morning you look at the watch it is already 9 O?clock in morning when it is 5 or 6 or the other way it is going slow and showing 2 O?clock. The reason is because the frequency is not stable it counts down, but then if the original crystal is not a stable frequency it will either lose time or gain time which you do not want. So this division by a factor of whatever required to make a clock. 

So I will give this as an exercise; assume a crystal clock of very high frequency megahertz, I want you to find out how many stages of counting is required so that I can have a count of seconds, minutes and hours not beyond that. I want an hour display, a minute display and second display in my clock. So the crystal frequency clock has to be brought down to the hours, brought down to the minutes I mean the other way very very high, you do several divisions to make it one cycle per second to count seconds then divide by sixty cycles per minute, divide by 24 divide by 60 minutes to make it one hour so I am not giving you a clock exact frequency because I want a whole number finally. So it is the multiple of the clock because 60 times 60 so 3600 seconds make an hour. So 60 minutes make an hour, 60 seconds make a minute so 3600 seconds make an hour. So make it 3.6 MHz I am having a 3.6 megahertz clock given to you, design a series of counters so that I can get my frequency divided at right numbers to have a count of seconds, count of minutes and count of hours. This is an exercise.

Now one disadvantage of this counter is, in these counters we feed a clock to the very first stage of the flip-flop, the output of the flip-flop is used as the clock for the second stage, the output of this flip-flop is used as the second stage for this clock and so on, the clock is passed from flip-flop to flip-flop. There is an inherent delay as I said. They also talked about small glitch. The moment I reset it it is not going to get reset that is going to be short time duration depending on this. once a one 1 0 whatever is reached here there is a small delay here and it takes its own time to become 1 1 1, it takes its own time to become 0 that 0 is applied here, here, here it has to activate the circuitry for clear to become 0 0 0 there is small amount of delay involved that is a short pulse as I said it is a glitch so you can ignore it.
 
Now each of these flip-flops has also the propagation delay. I told you the flip-flop have this initial stage, clocking stage and the next stage will be latching stage so there is a propagation delay involved in each of the flip-flops so I give this clock it takes a while a small amount of time though propagation delay time before the output changes that is fed into this and this is going to take its time before this is going to change (Refer Slide Time: 35:19) and this is going to be applied here, this is going to take its own time and this is going to change.




(Refer Slide Time: 37:40)
 
 

So let us go through this. supposing I have this count and I am applying the clock here the next count is this (Refer Slide Time: 35:40), this one has to become 0 first flip-flop C flip-flop has to become from 1 to 0, b flip-flop has to become from 1 to 0 and A flip-flop has to become from 0 to 1. I am feeding the clock to the C flip-flop as you can see there so it is going to take its own time for this to become 0 and after that delay only this flip-flop will go from 1 to 0 and after that delay only this 0 will go to this 1. So, from 0 1 1 to 1 0 0 to settle down it is going to take a final amount of time approximately equal to 3 into propagation delay of flip-flop we call Tp T subscript p as the propagation delay of the flip-flop, I want three propagation delays approximately, of course there are other things like reset, clear etc. 

Once you have a number you can always compute but there is a concept here. You should know there is a number you will have to look for. Once a number is given to you then you can make it approximate, after two nanoseconds by looking at the data sheet you find that it is not two nanoseconds but it is three nanoseconds but still it?s all right you have to do a computation but you should know there is something like that we have taken into account. So there is a delay in each flip-flop stage which affects the change and for more number of flip-flops there is a delay in counting so it becomes longer and longer. 










(Refer Slide Time: 44:15)

 

So if you have eight stages with 8 flip-flops what is the count I can reach? Flip-flop propagation delay: let us assume Tp to be the propagation delay of a single flip-flop so we have 8 flip-flops 2 power 8 as an example for 8 flip-flops delay is 8Tp so what is the count I can reach from 0 to 2 power n minus 1 where n is 8, 2 power 8 is 256, so for a count from 0 to 255 each count takes 8Tp to materialize. If I am 0 after 8Tp 1 comes and after 8Tp 2 comes and so forth reliably. Of course something can happen faster than the other. For example here to here (Refer Slide Time: 39:10) there is no change in this flip-flop so it is going to immediately come, there is no change, there is no question of propagation delay. It is not that each count is going to change only then. This I should allow for a maximum propagation delay of 8 times Tp in order for a count to be reliable.
 
Now talking of these clocks the watches from 3.6 MHz you have to count down to the second. One second is 1 Hz per one cycle per second which is one second and megahertz is 10 power 6 times 3.6 times so 3.6 million to 1 you will have to find out the number of flip-flop stages that is required. When that is the number of flip-flop stages required each count is going to take that much longer to materialize. Now if I run it at a speed which is faster than that speed so my clock period that is starting from one point in the clock and stopping exactly in the same point in the next clock cycle. 

If you take the positive edge of the clock then the time duration until the next positive edge comes is what is called the period. If I take the negative edge from one negative edge to the next negative edge is known as the clock period. So if this clock period is much much larger than 8TP then you are not worried, it is only a small amount of time, anyway it is going down to one clock period to settle down. The count is not going to change for one clock period. For every clock period the count is going to remain from 0 to 1 to 2 to 3 to 4 to 5, each of these counts is going to remain for one clock period. What if it takes 8TP to settle down? 8TP is the insignificant part of my whole clock period. But supposing I have the number of stages more, if n becomes large clock period may approximate the value of the propagation delays of the n flip-flops. Each flip-flop has a propagation delay of TP and n flip-flop stages will have n time TP and n is very large. So I can not run this counter at a speed faster than this NTP. Thus maximum clock period has to be less than NTP. If I run my counter faster than this before the count settles down the next count has to come. All counts are arbitrary then in that case reliability is not there. This is what I have been stressing all the time. You can not reliably say the count has reached from 0 to 1, 1 to 2, 2 to 3, 3 to 4 it keeps changing constantly because the clock keeps coming and sometimes it may be right depending on the number of transition sometimes may be wrong but we don?t know which is right and which is wrong. So I have to either use very small number of flip-flops there is a limitation or use extremely low frequency clock which is not always possible as I said the crystal oscillator stable oscillators. 

There has to be crystal and these are all only available in megahertz range. You cannot reduce the clock frequency for the reason of stability not always but sometimes it is possible or you want particular speed of counting, for my application I need to count this fast events keep coming the number of people I am going to count if people keep coming constantly or some small events some atomic events or something you keep counting at the rate at which it has come into account and I cannot say I can only count at this rate so please slow down I cannot say that. Wherever it is possible to slow down your event or increase the clock frequency or have less number of flip-flops there is no problem. But there may be situations where the events happen fast because you are ready to use a high frequency clock and the number of flip-flops used is also large because the count has to be reached with a very large value then this counter fails.
 
So this counter which is called a ripple counter suffers in the fact when the clock has to ripple through the flip-flops. Each flip-flop clock is the output of the previous clock. I give the clock to the original clock to the first flip-flop and the output of that flip-flop is given as the clock to the second flip-flop, and the output of second flip-flop is given as clock to third flip-flop, the clock doesn?t directly get into the flip-flops the clock that is given to you as a circuit in the crystal oscillator whatever I said that clock doesn?t directly go into different flip-flops it only goes to the first flip-flop and it has to ripple through like a wave in the ocean, it has go into this, into this, into this, into this and each stage it accumulates a delay because of the propagation delay of the flip-flop. So the clock accumulates delay and if the number of stages is larger than the events that is if the propagation delay is longer than the frequency of the events the distance between two events the time difference between two events then you lose track of the count. 

Ripple counter: The very name suggests it is a ripple which means that the clock is not directly applied to all the flip-flops but the clock is applied to the first flip-flop which ripples through different flip-flops to different stages. The ripple counter files if the number of stages are very large such that the total propagation delay is of the order of, I won?t say mathematically it should be larger, even in a practical electronic circuit when it approaches the order of this clock frequency clock period the total propagation delay approaches the order of the propagation delay it will fail to be a reliable circuit because you can never predict exact values. So I have to think of flip-flops being used as counters, usually a lot of things as I said, it can do a division by 2 you can count up count down start with any value end in any value and so on. Counting is one of the important things we do in many application systems but ripple counter has to be replaced by some other counter. So the improvement of this ripple counter is called a synchronous counter. A synchronous counter in principle is one which will take care of this problem. Ripple counter is suffers from the problem of too many stages in propagation delay affecting the total number of count you can use it for. 

On the other hand a synchronous counter is more practically used. In a synchronous counter all flip-flops receive the clock at the same time, there is no question of clock ripple through. The clock that is given be it a crystal clock or stable clock or whatever clock you design for the circuit is given to all the flip-flops so they are all clocked all the time but the change will depend on the previous count because if all the flip-flops are given in the clock and all the flip-flops change up and down then I can only count from 1 1 1 1 to 0 0 0 0 if all are toggle flip-flops so one state is all 1 1 1 1 and other states are all 0 0 0 0 then that is something I don?t want. I will be able to get all intermediate counts also. So we will see how to use flip-flops whose clocks are all tied together to the same clock that is the given clock is applied to all the flip-flops not to the first flip-flops alone but at the same time how to get a different count these are called synchronous counters we will see it in the next lecture.

(Refer Slide Time: 49:09)

 

Before that we can do a lot of work on these ripple counters. What I have given you is a flavor. 

Exercise on ripple counters: I would like you to design an up counter for 10 and down counter for 10so these are called decimal counters it goes from 0 to 9 or 9 to 0 and any other value you can also do by using these gates. I also gave you the watch example. These are the assignments on this ripple counters. But actually in watch we will not use a ripple counter. Finally we will say that because watch has so many stages you will see that it may not be worthwhile to do the ripple counter but we may have to use a synchronous counter. So we will talk about synchronous counter in the next lecture. 


Digital Circuits and Systems
Prof. Dr. S. Srinivasan
Department of Electrical Engineering
Indian Institute of Technology, Madras
Lecture #21
Shift Registers


(Refer Slide Time: 2:00)

 

We were discussing counters, use of flip-flops in counter design, up count and down count or counting from an arbitrary count to another arbitrary count or down from an arbitrary count to another arbitrary count. In all these cases we use what is known as a ripple configuration that is the output of a flip-flop drove the input of the next one, it was used as a clock for the next flip-flop. So in that we saw that the delay of the flip-flops play a role in how fast you can count. That?s not a very desirable thing because as the number of flip-flops increases or as the total count that you want to count increases the propagation delay of the repel counter increases linearly the number of flip-flops so there comes a point where the total delay of the time it takes for a count to stabilize to the next count is longer than the clock period. When that is the case then you can never have a stable count. 

We sort of wondered whether it is possible to have a counter which will be independent of the number of stages we need to count. That can happen only if the clock pulse is applied to all the flip-flops uniformly at the same time. Because any change in the output based on the input of the flip-flop can be triggered only after the clock goes high. So when the clock has to be active in order for the flip-flops to settle down in the output you need to supply the clock and if you do not want the number of stages of the flip-flops to decide the counting period the delay you need to apply the clock pulse to all the flip-flops at the same time. That means you are feeding the clock to the first flip-flop we have to feed the system clock the input clock to all the flip-flops at the same time. Then how do you control the currents, because once you put a j equal to one the k is equal to one you give a clock all flip-flops toggle. That means if all the flip-flops are 0s to start with they will become 1s after the next clock pulse so the flip-flops will go changing from 0 0 0 0 to 1 1 1 1 and so forth. We don't want that, we want to count in a binary sequence. So what we have to do is to look at the circuit of a counter we call this synchronous counters. The synchronous counter is the counter in which the clock is applied to all the flip-flops. So let us take a 3-bit to start with easy to handle in a classroom. I can have the same negative edge triggered or master slave configuration as we had earlier I will call this a b c this will be A, this will be B and this is C, Q Q bar so this will be A, B and C.

(Refer Slide Time: 6:30)

 

I want to apply the clock input to all the flip-flops so we put a 1 1 here let me write the counts. So let us say to start with we want to have 0 0 0 initial during the first clock period let us say after the first clock pulse. Let me now write the sequence I want, I want this sequence (Refer Slide Time: 7:49) this is my desired sequence natural binary sequence look at the flip flip-flop C this one; 0 1 0 1 0 1 0 1 so it needs to toggle at every clock pulse so there is no problem with this JK flip-flop because once you put J is equal to 1 and K is equal to 1 and give the clock pulse it is going to toggle. So I will not have any problem with this J is equal to 1 K is equal to 1 and I will get the desired sequence at the flip-flop C output. Here of course if I put JK 1 1 for the second flip-flop and B if I put 1 1 here this will also change so it will be 0 1 0 1 0 1 because I am giving the clock to all the flip-flops and I put a 1 1. So whenever I put a 1 1 in this toggle mode and as in the toggle mode when you give a clock the output compliments itself so from 0 0 it becomes 1 1 then 0 0 1 1 which I don't want but I want 0 0 0 1 1 0 1 1.



(Refer Slide Time: 9:45)

 

So instead of doing this what I will do is I can use this information that is when this becomes 1 when C is 1 at the next clock pulse B has to become 1. So instead of tying this C, J and K unconditionally to 1 1 we will connect it like this. Suppose I feed the output of c into the input of JB the second flip-flop input, and first this was 0 but even though the clock was there when this change state this would not change state because the output of c was 0 and that 0 was given here and a 0 and 0 so we will also put this character JK here both J and K I will give one value 0 0 so during the second pulse when this became 1 from 0 this does not become 1 from 0 because J and K are both 0 0 so 0 0 of the clock pulse applied remains same in the JK flip-flop. 

Now the next pulse appears after 0 0 1 by now JB and KB has been kept to 1 in the meanwhile after this pulse so when the next clock arrives at that time there will be a toggle mode here there will be a toggling operation in this flip-flop (Refer Slide Time: 10:55). This will toggle anyways because I have connected with JK 1 1 so it toggles with every clock pulse, this will toggle after this because J and K are 1. In the next clock pulse it will not toggle because this is 0 so for every other clock pulse only the J and K of the second flip-flop becomes 1 for every second pulse, for every alternate pulse J and K of the second flip-flop become 1 1 so the second flip-flop will toggle only once in two clock cycles. 

I am going to repeat this argument now. Third flip-flop I want to toggle only once in four clock cycles, I want this to be connected to 1 and remain one for every four clock periods, for four clock periods J and K of the third flip-flop will remain 0 and at that time there will be no change in the output for the third flip-flop the A flip-flop and for four clock pulses it remains 0 and for another four clock pulses it becomes 1. Now, when do you want the transition to happen? At the clock pulse after the count 1 1 was reached here. after the 1 1 was reached here I want this to change once but that as to remain again four times for four clock periods. So what I am going to do is to take these two into an AND gate. So when both B and C are 1 1 at the fourth clock pulse immediately thereafter JA and KA becomes one but the clock pulses have gone. We can only do it next time. So after that it will now become 1 1 and when it is 1 1 at the next clock pulse this will toggle. I can keep this going with this fourth position for 4-bit counter.

(Refer Slide Time: 14:06)

 

It is a 3-bit counter only 3-bits three positions are there. And here these three becoming 1 1 1 will make the fourth flip-flop toggle and remain the same because after that not all of them can become 1 at the same time. Again all of them will become 1 at the same time here then it will become 0 which is same as this so it will repeat. So when all the previous flip-flops have changed into 1 you want the toggling of the next flip-flop and that has remained for several clock cycles before the next change can happen. This is the concept of a synchronous counter wherein the clock is given to all the flip-flops and the change in the queue controlled by the outputs of the flip-flops. 

Earlier we tied J and K of all the flip-flops to 1 so every flip-flop toggled but then clock was delayed, the first flip-flop received the input clock and the system clock as they call it and the second flip-flop received a clock pulse which is half the frequency of the first, the third flip-flop received a clock pulse which was one fourth the frequency of the first and so forth. Therefore we divided the clock and by using the lower and lower frequency clocks we are able to get the toggling action slower and slower. The idea is that the first flip-flop has to toggle very very fast, the second flip-flop to toggle at a relatively slower rate this slower compared to this and so forth. Toggling is required but need to be controlled. Earlier we controlled it by means of a clock but now we are controlling it by means of the output of the flip-flops.

What is the advantage of this over the other one, synchronous and ripple counter? Repel counter by the way is also called a non synchronous counter asynchronous something which is not synchronous is asynchronous. So asynchronous counters or ripple counters are the ones where we use the clock of any given stage from the previous output. 

In the synchronous counter clocks are supplied to all of the flip-flops at the same time, the control of the toggling action is done by the outputs of the previous flip-flops. The advantage is going to take place only after the clock pulse has arrived because this would have settled down. For example, take the transition from this to this, as soon as this clock has arrived this would have settled down and for the entire duration of the clock this is going to remain as 1 1 so my J and K would have been fixed as 1 1 locked before my clock is due by this flip-flop, J and K will become 1 1 long before the clock comes. 

When the clock comes all it needs to take is the clock period delay so the delay of the flip-flop. So any flip-flop will change the output after one propagation delay. Earlier the second flip-flop will change the output after two propagation delays, third flip-flop will change the output after three propagation delays, fourth flip-flop will change the output after four propagation delays and so forth. That is why we found that it is not possible to carry on as a long chain because the total propagation delay should be less than the clock period. That condition is not there anymore. We have to make sure that the delay of each individual flip-flop is less than the clock period which is adequate. It can be amply supported or taken care of it should not be a problem. 

All systems use flip-flops and counting mode and most of them use this synchronous mode of counting. The only disadvantage is you need extra hardware AND gates. Actually you don't need to have three input AND gate because I have the output of this I have to take the output of this and put it in this so every time I put two input AND gate I take the output from the previous AND gate as 1. So if you want to continue this it will be like this. I don't have to go for three input AND gate or four input AND gate, two input AND gates will do for each stage. So we stop with the flip-flops the synchronous counters non synchronous counters asynchronous counters ripple counters. 

Basically flip-flops are used for counting starting at any counter and terminating at another counter all within that 2 power n minus 1 range. For n flip-flops we cannot have more than 2 power n states. So if I want to start from 0 it has to be 2 power n minus 1 within that I can start at any count and end at any counters either up or down and they can be synchronous or asynchronous all that we have already seen. So what is the major use of flip-flops other than counting? Counting is one thing of course. What is the original intention of starting sequential circuits here? I said we need some storage element to store a bit of information; the latch was a storage element. So now the main use of the flip-flops is in the design memory. Even though we talk about one bit flip-flop a flip-flop which can store one bit in practice we never have words of one bit. 

Usually a word is 4-bits 8-bits sixteen bits thirty-two bits like that. for example, if you take a code ASCII code I said translate your alphabets and numerals into binary code such a code is called ASCII code I said we have seven bits for that and we may have an extra bit for parity so 8-bit code. So I want to store that code corresponding to a particular alphabet. I need 8-bit eight flip-flops. So instead of building memories using single flip-flops we can also have circuits or devices sold in the market which can take several bits at the same time and store it so such a combination of flip-flops is called register. You may have seen this word being used in several digital books. Register is nothing but a bunch of flip-flops a group of flip-flops.

(Refer Slide Time: 22:05)

 
 
A 4-bit register for example will have four flip-flops let us say they are D flip-flops because I said mostly it is used for data storage and data storage as I said for a D flip-flop is good enough so you have put D D D and D with Qs as the output. Normally these flip-flops can be controlled by single clock. Internally there is a connector of course. As I said externally when we are looking at a device with 4-bits as a user you have only one clock to connect one power supply to connect so all these flip-flops need Vcc and ground or Vdd and ground or whatever it is the nomenclature for the supply voltage. Similarly when we say one clock pulse it can be edged triggered positive or negative or whatever it does not mean that these flip-flops do not require clock it?s all internally connected, the clock is connected like this. 

Suppose I only see one clock (Refer Slide Time: 24:00) so like that internally they will be connected. likewise here also I will show the clock here but don't think that only the first flip-flop gets a clock it is connected to all flip-flops so I can put any data here or if you want to put A B C we have been using A as the most significant bit and D as the least significant bit so when you put this data A should be the most significant bit. We can just use this this way. Now I can put this information and clock it, it will remain constant it will remain inside and also be available here when I want it I can delete it off, it is a memory. In order to get the inputs into the flip-flops and the register you need to put the data that has to be stored or the inputs, when you clock it these inputs get stored and they are available.
 
But the problem with this would be I need to keep the data constantly here because the clock keeps coming. You cannot design a clock for every little piece of hardware in your system you are designing a sub system you are designing, a clock is a common entity. Suppose I have a big digital system or a huge digital circuit there are several functional units and many of them require clock pulses for operation. So the clock is generated and distributed commonly to all these units. This clock may be at a frequency which is much faster than the rate at which I want to put the data and remove it. 

Suppose I want to put the data and then keep it for a while even when the clock keeps coming and going I don't want to disturb it, so only when I want to use it I will use it and then I will put another data that means I want another control independent of the clock. If I do not have that independent control when I clock it the data gets in and if the data doesn't remain here the data may be available for a short period and when it is available I have to store it, if it is going to be available forever then there is no need for storing it, why should I store something which is always available? 

(Refer Slide Time: 29:17)

 

You need this data but only when it comes you can store it but I don't want the storage to be removed by the next clock pulse because the data has been removed. Data as been removed means it would have taken other values which are non related, the arbitrary values where it can all be 0s, 1s or they can be 0s or 1s or any random combination and next clock pulse will overwrite my data, the next clock pulse will put this random junk thing into my flip-flops so my stored data gets corrupted as I call it, cleared, corrupted, erased or whatever term you want to use. 

Therefore I need another control in which I want to store the data when it is available at that time and other than that period the data will not be disturbed so I need a control called load control. Now I am going to make it in the internal circuit such that the clock will be applied when the load is?.. That is the data will be stored into the flip-flops only when the load is active and not immediately when the load is active but when the load is active and when the next clock pulse arrives so can do that way. Or I can say simply load will put the data in so I can have two more reserve operations. One is called asynchronous so again we have synchronous and asynchronous. 

Synchronous load means the load has to be high and the clock should be activated for it to store the data. Asynchronous means as soon as the load pulse arrives whatever data that is here will be stored irrespective of the clock pulse that is similar to the reset, preset, clear conditions we talked about. We can have a choice of synchronous load or asynchronous load. But the advantage is when the load is removed the store data is here inside. Even when the clock comes at a very fast rate much faster than the rate at which I want to read from this memory, for example I have a clock of one megahertz that is the clock period is one microsecond so every one microsecond we have an edge of the clock whereas I want to put the data here and keep it for hundred microseconds. If load was not there after the first microsecond the data will be there and after the second microsecond it will be removed by and rewritten by whatever is here at that time which may not be the original data, I might have removed, the data must have been there for a short period it just disappeared and A B C D has taken random values and after one microsecond my storage will be junked. So when I look at the data after hundred microseconds when I really need it I will find junk inside and not what I put. 

Now with the load I have the control. I can put this load at the time when this data was available and remove this load pulse and then the clock may come and go but then this data cannot enter inside, the new junk value cannot enter in. Even though you don't have the original values they have been removed arbitrary random values that a b c d assumed do not get into the flip-flops until another load pulse comes. So after reading the data after another microsecond I can put one more load pulse and capture one more set of data. Likewise I want to clear a flip-flop that also is possible so I can have one more control called clear. Clear also can be synchronous or asynchronous the same concept, clear removes the data, clear makes the data 0, 0 0 0 0. 

Thus I have this independent control and anytime I want to remove the data or make it as 0s I can use a clear input automatically irrespective of what is there on A B C D and all the flip-flops will assume 0s. Again that can be done with the clock pulse or independent of the clock pulse. If it is done independent of the clock pulse it is called asynchronous but when it is done along with the clock pulse where the clear will work only with the clock edge and without that it will not work that?s called synchronous clearing. 

As soon as the clear pulse is given if the flip-flops change to 0 0 0 0 independent of the clock pulse if it?s 0 or 1 or an edge then you call it asynchronous clear. So in short I have these registers which are bunches or groups of flip-flops which has several things, I can put the data in and keep it as long as I want and take it of read it of and use it I can again use the same data I can have a data which is stored and read it of again and again that?s also possible because as long as I do not load new data in the data is going to remain and this is not going to go once you read of, there is nothing wrong in using these values that?s all. When you read of a value it does not mean that the data is destroyed, it is not destructive. Or I want to change the value I put a new set of value load it and if I want the data to be 0s I will clear it. These are all very convenient control inputs which will be used in your circuit when you design larger systems. We will see how to use some of these things in our subsequent lectures where we will use some of those designs using these counters. 

Thus data storage is the major application of flip-flops and counting is one of the applications. Data storage is the major application, division by factor of 2 is another application but data storage is a major application and usually D flip-flops are used for that because you need only one input data and the data can be manipulated by use of clear and the time at which data is put and cleared which is controlled by two inputs called data and clear in addition to the clock which is universal for the whole system and that clock may not be the rate at which we want to put in the data or clear the data.

If it is the same of course you don't need all this but it is generally not true because I may have different adjustments in different places in my system, not all registers get cleared at the same time as frequently as the clock arrives some of them may have to store data for a longer time, some of them may have to store data for a shorter time and none of them may be able to store the data, clear the data at a rate which the clock arrives so the clock frequency is desired by so many other factors. 

Therefore we don't want to get into it because the speed of the system will decide the clock frequency, this is only for a short duration may be for a nanosecond or a microsecond the data will be available or useful so that is of no use as good as not being stored. If you have a data which is going to be cleared immediately what is the point in storing it. A variation of this register is called a Shift Register. these are inputs which are applied to all the flip-flops at the same time, clock supplied to all the flip-flops at the same time, load applied to all the flip-flops at the same time, clear applied to all the flip-flops at the same time, and the outputs are available parallely.
 
On the other hand if I have a operation where I have a first D flip-flop and the output Q is fed into the second flip-flop and the output Q is fed into the third flip-flop and an output Q is fed into the fourth flip-flop you can have any number of flip-flops, I am just giving you four as an example. And of course I clock them synchronous, hereafter until I specifically say it is asynchronous or repel counter we will use synchronous counter where the clock is applied to all the flip-flops at the same time. 










(Refer Slide Time: 38:05)

 

When we need to use a repel counter specifically I will tell you it?s an asynchronous counter or a repel counter. So this is my clock, and instead of putting the data simultaneously in all these flip-flops now I am connecting the output of the first flip-flop into the input of the second flip-flop, output of the second flip-flop to the input of the third and so forth. Now whatever data I put after every clock pulse that data will shift to the next flip-flop. Suppose initially I put a data I call this initial data A B C D and because this is connected here, this is connected here, this connected here, this one will go here (Refer Slide Time: 38:33) then after first clock pulse, whatever I give as the value I will call this input value IN so this IN will come here. It is a new value and this 0 will be bumped off gone (Refer Slide Time: 39:00).


















(Refer Slide Time: 39:50)

 

After the second clock pulse this would have moved here, this would become 1, this would become 0 and what we have here will be IN2 second input whatever it was and after third it is IN3, IN2, IN1 and 1 and so forth. I keep shifting the data from one flip-flop to the next flip-flop, to the next flip-flop, to the next flip-flop, to the next flip-flop and so on. Such an arrangement of flip-flops is called a Shift Register because it shifts, it?s a register in the sense it shows data but it keeps shifting the data from flip-flop to flip-flop to flip-flop to flip-flop it?s a Shift Register. So again I can draw this as one block even though we don't have to show all this inside so it is a 4-bit Shift Register. 

The SR stands for Shift Register in this case. I will not show individual connections and the output of this. I have put the data here, this input is called serial in. The four flip-flops have outputs QA QB QC QD and four inputs called DA DB DC DD. Now QD is also the serial output. I have now various combinations I can load a value of DA DB DC DD all of them at the same time and then start shifting. Shifting is always from one flip-flop to the next flip-flop. But the way in which I load the flip-flops can be one at a time, serially I can put one at a time, initially I can clear all the flip-flops and I don't have to even clear the flip-flops. I start pushing in data one after the other it will go and get loaded whatever way it is. Or at the same time I want to put the all flip-flops at the same time of different values so I can have the option of serial load parallel load or serial input parallel input. Likewise I can redraw the flip-flops QA QB QC QD all at the same time or I can look for the output at serial output last output. So I can have a serial out and parallel out. Then you have a clock which is common to all of the flip-flops as I said in the case of registers.






(Refer Slide Time: 42:30)

 

So when I put parallel data in how do I get them into the flip-flops? I get them by loading so I need a load which is common to all the flip-flops I can have a clear also which is common to all. So I may have all these features in Shift Register. I can clear all the flip-flops and make them 0 to start with. I can load a new set of values by putting A B C D different values and loading it on by using load. And after clearing or loading if I start the clock then during every clock pulse the clock will shift the output from one position to the next that is the main operation it will do and any point in time you can freeze what you have and read off the values parallely or you want to read serially you have to keep applying clock till you get all the bits out. that means I have four different combinations of operations, I can have serial in, serial out, flip-flops, serial in serial out, serial in parallel out, parallel in serial out, parallel in parallel out these are four combinations are possible.
















(Refer Slide Time: 44:27)


 

I will give input serially take output serially one bit at a time. This operation is a minor operation that is I will keep loading and it gets the output. Whatever I put here comes out here after a delay of the number of clock pulses equal to the number of flip-flops in this case four clock pulses. Whatever data I keep giving here that keeps coming out here after a delay of four clock pulses. So, four is only an arbitrary number I don't have a 4-bit Shift Registers, I can have 8-bit Shift Register or I can have any number. Usually four and eight are available as a product as an IC in the market. So either use a 4-bit Shift Register or 8-bit Shift Register. Hence after four clock pulses or eight clock pulses as the case may be whatever you put comes out so this can be used as a delay element, that?s all.
 
Suppose you want the data to come but then the same data as to go out after a particular delay I can use this serial in serial out mode. Number of the delay is equal to number of flip-flops times the clock period. If there are four flip-flops then it is four clock pulses delay, four clock periods, eight flip-flops eight clock periods delay. Serial in parallel out is when you have the serial input data or I want to take it parallely it is called serial to parallel conversion. What happens is in some applications I have a serial input data coming in but I have to wait for the whole bit. 

For example, let us assume ASCII code 8-bits, I have an 8-bit Shift Register I get an ASCII code from some other device unfortunately that device can only transmit one bit at a time, unfortunately that device which is supplying the ASCII that keyboard is only a serial connection so the 8-bits of the ASCII including the parity bit keep coming like one bit for every clock period but I cannot process this until I know what ASCII code it is, I cannot process until the ASCII code is completely built then I can store it or do whatever with it. This is an application where serial input parallel output parallel output is required for processing whereas serial input is the limitation of the device like a telephone modem. You know that in a telephone you have the dial up modem, the data comes serially because you have a pair of lines, the telephone has a pair of lines you use it in your computer, it is the limitation in your telephone line not the generation of data, I want to send a mail to you, my computer can also give you a parallel output your computer can also process in parallel but in between the medium is serial, telephone line. Therefore I have to convert my parallel data into serial mode data and send it to you that is what my modem does and your modem gets it back into parallel. So these two things are covered; serial input parallel output and parallel input serial output, examples are modems. 

Finally this parallel in parallel out is similar to the register wherein I want to put in the data and take it out that?s all, I load it I take it. If you disable the load it will remain as long as you require so this is same as the register operation, shift has no meaning in this. If you want to put the data and take it out as it is where is the question of shifting it there is no need for shifting. My Shift Register becomes a normal register operation in this mode. It?s a very very powerful device as I said it can be used for many things such as for storing, for delaying, for converting parallel data into serial, converting serial into parallel and I only talked about shifting to the right. 

By a proper connection the output of this flip-flop can be connected to the input of this flip-flop, the output of this can be connected to input of this and the output of this can be connected to this, is it not possible? The output of this I connect to this output of this connected to this and the output of this is connected to this (refer Slide Time: 49:58).

Suppose you are taking output of this and connecting to this, output of this and connect it to this output of this and connect to this then this becomes a left shift flip-flop. So I can have a Shift Left Shift Register and Shift Right Shift Register. So a Shift Register can have a serial input as data input, parallel data input, serial data output, parallel data output it can shift left, shift right. 

You can buy an appropriate Shift Register you can buy a shift left 4-bit Shift Register with serial input and serial output or you can have a register which does not need a shifting. You have got all these features you don't which one you will use, I want shift left feature, shift right feature, clearing feature, loading feature, serial in feature, serial out feature, parallel in feature and parallel out feature so all of them I want but I don't know which one I will use either a 8-bit Shift Registers or 4-bit Shift Registers such Shift Registers are called Universal Shift Registers because you can do all things that you want to but of course not all of them at the same time but you have to configure it for one particular operation either a shift left operation or a shift right operation or parallel load and serial out, serial in parallel out or whatever. These are available in market commercially but you should know what is inside. Inside it is after all nothing so I have reduced the width of all these registers, counters and all that you have. There are two chapters in your book of flip-flops, registers, counters so it is a basic storage element of a latch connected to a clock and you can use flip-flops in so many different ways to get all those different things similar to what we did with gates, in gates we had so many other applications we called them adders, you called them parity generators, parity checkers and all that. 

Digital Circuits and Systems
Prof. S. Srinivasan
Department of Electrical Engineering
Indian Institute of Technology, Madras
Lecture # 22
Application of Shift Registers

(Refer Slide Time: 2:03)

 

Today we will see some of the applications of Shift Registers. We talked about flip-flops, counters and registers. Registers are group of flip-flops in which you can store data. Then we said the registers can have a shifting feature so that once you put a data you can shift that data either to the left or the right and these are called Shift Registers. There are some other applications, of course we saw applications of flip-flops in counters, likewise an application for registers the most prominent applications of registers in the memory storage, to use them as storage elements. Shift Registers are sometimes used for other applications. I thought we will see some of those applications today, the Shift Register applications. 

Let us for example take a 4-bit Shift Register with a shift right feature, so it?s a 4-bit shift right Shift Register. Let us assume this is serial in parallel out that means you can put the data serial in parallel out does not mean you cannot put parallel data, parallel input also will be there with a load in feature otherwise normally data is put through serial. So this will have the data in the clock of course clock either positive edge or negative edge doesn?t matter, the input is called serial I SI serial input and the clock will shift the bits. We should also have load and clear features because we want to start with a pattern that also you can do by putting the data one at a time and shifting it that is one way of loading and the other way of loading is to give parallel inputs and then give all the bits at the same time. So these are parallel output these are Q all these are A B C D so it is QA QB QC QD and D so DA DB DC DD. 
(Refer Slide Time: 5:53)

 

First you put a pattern in this load it of course you want to clear it later on you can do clearing, then you clock it and as you clock it the bits get shifted as one position to the right that?s why it?s called Shift Register to the right. So what I am going to do is to take the output of this and this into an Exclusive OR gate and feed it as the input. So every time I clock it this bit goes here, this bit goes here, this bit goes here, and the Exclusive OR of these two gates is loaded as a fresh input. So, as you clock it this will go on. So let us assume that initially I am able to load a pattern of 1 0 0 0 initial pattern but you can assume anything, I am just assuming this. 

So to start with I load 1 0 0 0 then at the next clock pulse at first clock pulse what will happen is this 1 gets here, this 0 gets here, this 0 gets here (Refer Slide time: 7:40) and a new bit will be added to the input which will go into QA and since this is the Exclusive OR of C and D what will be the Exclusive OR of C and D? It is 0 so that 0 will get into this position. Therefore again I shift it after the second clock pulse and this will become 0 1 0, this also 0, and after third clock pulse one fourth clock pulse, fifth clock pulse and what will be the new bit, it is 0 again, 1 Exclusive OR of these two so all you have to do is to shift these three bits here and get the Exclusive OR of this here (Refer Slide Time: 8:43). Now after this this will be 1 0 1 0 0 1 0 1 1 0 1 1 1 1 0 1 1 1 1 1 then it will be 1 1 1 0 I will write here after this it will be 0 1 1 1 0 then 0 0 1 0 1 0 0 0 which is this.









(Refer Slide Time: 10:05) 

 

So by just putting one initial pattern, this is only an arbitrary pattern it doesn?t have to be 1 0 0 0, you can put any other pattern. And again shifting every time the uplift clock pulse the bits get shifted one bit position to the right and a new bit is added to the left then again is shifted and so forth. So what happens is how many different patterns are here? This is the starting pattern so 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 patterns again it repeats. So, after the first clock second clock third clock fourth fifth sixth seventh eighth ninth tenth eleven twelve thirteenth clock fifteenth clock and this is 0 so fifteen clock pulses so the frequency of repetition is fifteen clock pulses or fifteen clock durations. After fifteenth clock pulse the original pattern is restored. 

Now there are only sixteen possibilities with four bits so I get all the four except one, I don't get 0 0 0 0 if I get 0 0 0 0 what will happen is it will keep repeating so I should not put a 0 0 0 0 to start with because when you put 0 0 0 0 it gets shifted to 0 0 0 0 again it gets shifted to 0 0 0 0. So, if you leave 0 0 0 0 so you load anything other than 0 0 0 0 I get all the other fifteen patterns and then it gets repeated. Such a circuit is called a pseudo random noise generator. It need not be necessarily noise but it can be pattern you can call it pseudo random generator. 

What I mean is suppose you want to have a verification pattern you put a bit pattern which is accepted and for that bit pattern you know the sequence that has to come so you can know whether there is any error in the transmission. If you agree on the initial pattern both at the sending and receiving end for this given pattern you know the sequence of these patterns I think you call it pseudo random sequence generator which can also be used for generation of noise so if you want put it this way. So the advantage of this is I can check the transmission over a period of time so I agree on the initial pattern both at the receiver?s and sender?s side and then start sending data and as I receive data I check with this and if there is a change that means there is something happening to the transmission. 
Why it is called random is because the pattern can be also kept secret in the sense even though all the fifteen patterns will come all the fifteen words all the fifteen different patterns will arise the sequence in which they will come depends on the initial pattern, if the initial pattern is different then you will have a different sequence so again it is fifteen. So it is not completely random and after fifteen it will be repeated so that way it is pseudo random. 

Pseudo random means semi-random it?s not completely random. You know that fifteen patterns are going to come and if you know the initial pattern you can guess the other patterns so that?s why it?s called pseudo random. But if you have this pattern that is given as a test pattern I can use it for testing. I can give the initial pattern and send it and test whether I am receiving the other things in the same order. It is one of the important applications of a Shift Register, pseudo random sequence generator. 

And I can now have different values as I said the starting value so that the patterns will be repeated but not in the same sequence or I can tap instead of here I can do here I can do here (Refer Slide Time: 14:56) I can take this, this and this and Exclusive OR of three inputs I can do, I can do all sorts of variations I can get different sequences and different patterns so I can have a simple test design one is for testing the system and the other is for establishing the reliability of the communication between two points. If the initial test gets through the other side properly then you know that the channel is well established and you can start sending the transmission. This is one of the important applications of Shift Register.

(Refer Slide Time: 16:30)

 

We will talk about another application of Shift Register and just for the purpose of explanation I am going to put them as three different flip-flops. Let us have JK flip-flops. So I will call these flip-flops A B C and these are clocked together, I will not show the clock separately because they are the same thing, I am just showing this drawing or I can show it separately also doesn?t matter. What I am going to do is to connect this j to this Q bar and K so you have three JK flip-flops output of first JK goes to second JK, output of second JK goes to third JK and output of third JK goes to input of first JK with a twist Q and Q bar. This is a Shift Register in the sense that the output of this gets shifted into this, for every clock pulse this output goes into this, this output goes into this, that?s why it?s called a Shift Register. 

(Refer Slide Time: 20:20)


 

Now, after the first pulse because the C which is 0s C bar which is 1 is connected to J where J becomes 1 and K becomes 0 after the first clock pulse. I put 0 0 0 I shift it, one clock pulse shifts this 0 into this, this 0 into this, this 0 not back into this but this 0 is connected here in this one. So after the thing the next time the pattern will be 1 0 0. After second clock pulse it will be 1 1 0, third clock pulse it will be 1 1 1 and fourth clock pulse it will be 0 1 1, fifth clock pulse it will be 0 0 1 and for sixth clock pulse it is 0 0 0 which is the same as the original. So, in six cycles of clock I get the pattern 0 0 0, 1 0 0, 1 1 0, 1 1 1, 0 1 1, 0 0 1. Now if you draw the waveforms for this how is it going to look like? 

I will draw the waveforms here. Here it is clock clock clock clock, this is 0 of the first clock pulse, (Refer Slide Time: 21:10) second clock pulse, third clock pulse, 0 and this is clock time axis. 








(Refer Slide Time: 21:30)

 

Now if we look at this we can see that initially it is 0 0 0 then A becomes high for three clock pulses and low for three clock pulses and high for three clock pulses and low for three clock pulses it repeats. Similarly for B it remains 0 for first two clock pulses then three and then next three clock pulses 0, next three clock pulses 1 and so forth it repeats. C becomes 0 to start with and for first three clock pulses it remains 0, second three clock pulses 1 then again 0 then again 1. So when you draw this for A B C pattern A would be 0 then becomes 1 remains 1 for three clock pulses and then remains 0 for the rest of the period. this is the output A I will not show the timing separately in the time axis B would be first two clock pulses will remain 0 then next three clock pulses will be 1, C would be 0 for first three clock pulses and 1 for the next three clock pulses. 


















 (Refer Slide Time: 23:20)

 

Therefore I am dividing this clock by, what is the frequency of this compared to this? Time period of this is six times less, for example (Refer Slide Time: 23:50) this period is equal to six periods of this clock, the period of this clock is one sixth or I can put eight four flip-flops will become eight so the period of this clock is n times the period of the original clock where n is twice the number of flip-flops so I should say 2n. The period of this clock is 2n times the period of the original clock where n is the number of flip-flops that you use for this. That is one thing which you can always get by a division. But more importantly if you want to use this as a separate clock of different phases there is always a phase difference of this much, one third of a clock period, one third of a clock period between this and this, this and this and between this and this (Refer Slide Time: 24:50). I can get a clock period it?s called multi-phase clock or multiple phase. 

















(Refer Slide Time: 26:10)

 

So I have the clock period which is 2n times the system clock period we will call this system clock and there is a phase difference between two successive waveforms of one original clock period between successive clocks. Sometimes it is useful so I want to have some lights going in a sequence. Suppose I turn on lights and turn off lights using this, this light will be on at this point and it will stay on for three clock periods and then it will become off, this light will be turned on (Refer Slide Time: 26: 25) after a delay from this light again it will stay so before that it will go, so first this will light up then this will light up, then this will light up and this will go and this will go and this will go.

Therefore it is some sort of an application like that where you need multiple phases, it?s called multi phase clock, you can use it for some system. This is also called a counter. Basically what you do in a counter? Counter will give you a clock pulse divide the clock by a factor of 2 by every flip-flop frequency is divided by 2 in every flip-flop stage so the same similar thing here. This is also a counter but the only thing is the output of this counter we twist and then connect it. In a counter the output of 1 goes to the next, output of second goes to the third, output of third goes to fourth and output of fourth goes back to 1. And without twisting it if I do you can take it as an assignment exercise you connect Q back to J and Q bar J back to K. 

Of course you put a 0 0 0 nothing will happen and anything other than 0 0 0 you put and see how it is, it?s a Shift Register basically that?s all, 1 0 0, 0 1 0 then 0 0 1, 1 0 0 so it will only repeat it is a Shift Register. That?s called ring counter a counter wherein we use the output of the last flip-flop back to the input of the first flip-flop is called a ring counter or recirculating Shift Register they call it, you circulate again and again in the same pattern. But this counter is slightly different from the ring counter it?s called twisted pair ring counter. 


(Refer Slide Time: 29:40)

 

So we have recirculating Shift Registers, ring counter, recirculating Shift Register is same as the ring counter in the sense I have this flip-flops (Refer Slide Time: 29:12) serial output is fed as serial in, put a pattern and keep circulating it that?s what will happen in a ring counter. Put a pattern and connect it back even if it is a D flip-flop for that matter, you don't need to use JK. If you want you can use JK too. But this Shift Register which uses twisting of the output back into the input is called twisted ring counter. 

What we have seen is twisted ring counter used for multiple phase clock generation and the period of the clock will be one sixth of the period of the original clock with a phase difference of one clock period between two phases. This counter is also called a Johnson counter. Again it?s used commonly for multiple phase generation. If you want to have lights turning on and turning off in a particular sequence you can do this, this is one example. 

Now, if I don't want this phase to be of this duration one period of clock but I want only one clock period with different phases, that is I want a clock to be on, I want one pulse to be on for this period, one period another clock to be on for this period as we have six periods and suppose I want pulses like this (Refer Slide Time: 31:19), what I am saying is take the same light example, this light is on at this point in time and remains on for three clock periods and then switches off, this light is on after the next clock period but remains on for three more clock periods and so forth. I have three lights turned on, this turns on, this turns on and I can have them on for half the clock period and for other half clock period it starts disappearing and then becomes like this.





(Refer Slide Time: 32:00)

 

Instead since I want six phases I should have six LEDs or six lights which will be turned on each only for one original clock period. That means I want something to be on for this period alone and off for the rest of the period. It can be a motor, it can be a light, it can be something which you want to just activate for this clock period, another only for this clock period, another only for this clock period, this, this, and this so from these waveforms I should be able to generate these waveforms easily because if you look at this A B C we can also write as we started with 0 0 0 then we made it 1 0 0, 1 1 0, 1 1 1, 0 1 1, 0 0 1 and back to 0.

(Refer Slide Time: 33:35)

 

Suppose I take the complements also at the same time so each of these flip-flops have Q and Q bars so I can call this A B C this as A bar B bar C bar so similar to A B C I can draw waveforms for A bar B bar C bar which will again have the same on period for three clock pulses, off period for three clock pulses but that will be complemented to the corresponding clock, A bar will be complemented to A so inverse of A, B bar will be inverse of B and C bar will be inverse of C so again on for three clock period off for three clock period total clock period being six times the original clock period. Now I can see the pattern such that I want something to be on only for one clock period, now you can look at this for example, if you take B bar and C bar or 1 only for the first clock pulse, let us call this the first clock period second third four five six (Refer Slide Time: 35:08).

Suppose I say A bar or B bar C bar, B bar C bar is 1 only for this clock period, there is a change here, you can have A bar B bar AB bar, the first clock period will be on, A bar C bar and not B so A bar C bar is on only for these two clock periods, for this clock period A and A C bar only for this clock period only for this clock period is on high, another change here A B bar, what is third one? B C bar and fourth one will be A C will be there A C will be on only for this, this one would be A bar B and A bar B here I think it is the complement of this, this will be B bar C most probably B bar C complement operations. 

Hence, now all I have to do is to get the complement of these waveforms A B C A bar B bar C bar and then use AND gates so in that case the first clock period is on A bar C bar of course I am not showing C bar, I am not showing A bar B bar C bar you can imagine that, it will be the opposite of this (Refer Slide Time: 38:32) and this will be A bar, this will be B bar, this will be C bar. So these waveforms can be clubbed to form A bar C bar here A B bar, B C bar, A C, A bar B, B bar C so I have now variety of choices. I can either have three phase clock with the same period of six times the original clock period so I can have a light on overlapping, three lights on, first light will be on, second light will be on after sometime, third light will be on after sometime and then the first light will be off, second light will be off, third light will be off so you can have this kind of a display.
















(Refer Slide Time: 40:00)

 

If I want to have only a light on for this period first light and then it will go on and second light will be on and it should go and the third light should be on so there are six lights it should be on for one clock period each of the original clock then again it will repeat. Thus all these applications are possible by Johnson's counter or twisted ring counter which is a basic modification of the Shift Register as I said because Shift Register basically is the output of one stage fetched into the second stage and shifted to the left or the right depending on the sequence.

The other two applications we started the other day was the parallel to serial converter. Suppose the serial data is coming I am giving examples of data coming through telephone lines in bit form and I want to assemble it as words serial to parallel conversion or you have the computer generated data which is available as parallel data bytes or words and you want transmit it through a telephone line you have to shift it serially and send it. So other applications are then parallel to serial converter and serial to parallel converter. 

So, Shift Register is a very very important building block of a sequential system or any digital system. these are all building blocks of digital circuits, first we saw combinational building blocks, gates, adders and all that, we saw sequential building blocks flip-flops and using flip-flops we saw how to build counters and how to build registers, how to build Shift Registers. Shift Register is a very frequently used component in many digital systems. 

I have given you some applications today like the pseudo random sequence generator, the Johnson's counter and then the parallel to serial and serial to parallel and things like that as we talked about the other day. So with this we are more or less completing the discussion of the basic building blocks. We have to talk of some other building blocks in combinational domain, multiplexers and all that. What I have to do now is to talk of systems. 
We will use multiplexers, decoders and other combinational building blocks which are not basic building blocks like gates. Gates are the basic building blocks in combinational, flip-flops are the basic building blocks of sequential but I took a flip-flops application and developed counters and registers and Shift Registers like we did in the case of gates we took the basic building blocks of gates and developed adders, subtracters and all that. So now a whole lots of things can be added, these are basically built using the basic building blocks, combinational basic building blocks are gates and sequential building blocks or basic building blocks are flip-flops so now we can use all these things to build subsystems or second order type of complexity and then using them you have to build systems. So we have to get into the act of how to define a system to synthesize it, how to build it. Before that we will just deviate for a minute and stay here now. 

Why did I now start from gates and finished gates and then instead of doing the other things like multiplexers and decoders and other programmable arrays which are all combination of building blocks switched to sequential in order to give you all the basic building blocks in both combinational and sequential basic tiles like a LEGO block I told you basic tiles are there it?s up to you to play with them and then build castles. Now, why did I do that is because technologically these are all of the same complexity. 

Generally we define systems as small scale ICs, all these are Integrated Circuits that is made of silicon but then built as one single circuit, a gate, even gate is an Integrated Circuit in the sense gate is not a component; the basic component of a gate is a transistor may be. a field of a transistor MOSFET as they call it Met??. Semiconductor Filed Effect Transistor or BJT Bipolar Junction Transistor, sometimes you may use extra components like resistors occasionally capacitors. So, using all these things you build a basic building block which is an Integrated Circuit because all these things are integrated, the circuit is integrated in a small single piece of silicon crystal in which you etch this by lots of means. 

Etching is a very crude term today, earlier it was done by chemical process but today we have so much precision required in all these things, we have lithography using lasers, using electron beam, molecular beam and all that, lithography, so that you can precisely cut. Even in surgery earlier people used to cut open and then do the surgery and then stitch back but today everything is done by precision beams, laser beams and so forth. Likewise in a building block also we have transistors and gates and things like that because the technology has grown very very precisely they are put together in different places and formed in a single circuit these are called Integrated Circuits.
 
Now, general Integrated Circuits are any circuit in which several components are both active and passive. Active components are transistors, diodes, FETs etc and passive components are resistors, capacitors, and inductors. 

Of course active (( )) are easy to make but passive (( )) are little more difficult, resistance is ok, capacitors are little more difficult both in terms of the size and the precision values and inductors are even more difficult. But we will see all those things later on as how they build all these things. But these integrated components Integrated Circuits are classified into small scale Integrated Circuits, medium scale Integrated Circuits, large scale Integrated Circuits and very large scale Integrated Circuits. 

A small scale Integrated Circuit is a circuit in which you have about ten gates in one circuit. A gate is an equivalent function and don't think a gate has to necessarily be a gate in the sense, I told you, a gate will have a few transistors and a couple of resistors. So, if you think of that as a basic building block like five transistors or two transistors or something in that order as one unit of gate you call it a gate function. It is actually not a gate as per say but it?s a gate function and up to ten gate functions in a single circuit is called Integrated Circuit, these are all approximately.

(Refer Slide Time: 47:45)

 

Any circuit which can do an equivalent function of ten gates or up to ten gates like the AND gates, OR gates, suppose you draw a simple combinational logic circuit system few gates here and there equivalent of that ten gates so up to that we call them as small scale integration and then from 10 to 100 approximately these are approximately thumb rules nobody defines this, these are not numbers like Planck?s constant or something or anything but it is just to give you the idea of complexity. Somebody gives a circuit you say how many gates are there in that circuit, you give me a circuit and ask me how many gates I say thousand gates but it doesn't mean thousand gates you put, it means that this circuit will do the things which can be done by about thousand gates that?s what we mean. From 100 to 1000 it?s called LSI and beyond 1000 it is called VLSI but of course today people use ULSI but I don?t believe in all that Ultra Large Scale Integrated Circuit but then anything big falls between VLSI and ULSI and all that. Somebody says beyond 100,000 it is ULSI and all that it?s all individual?s opinion. 

So this is basically a structure and why I finished all these basic building blocks and combinational or sequential is because whatever you have done up to now can be generally classified as small scale circuits. When you put more of this gates the functional complexity increases and they become medium scale Integrated Circuits and then you put more and more of them then it becomes large scale Integrated Circuits. So we have now understood the basic building blocks bricks and we will use those bricks to build the subsystems which are medium scale like multiplexers and other things and in the case of 4-bit full adder which may be qualified to be a MSI, similarly a 4-bit Shift Register or 8-bit Shift Register may qualify to become a MSI. then we will do MSI functions and then how to use them directly instead of gate every time because if you are giving a very very large circuit like a microprocessor you can design you cannot go to the gate level and design because a microprocessor may have 300,000 gates or 100,000 gates like that so I can?t give you a circuit diagram with 100,000 gates connected to them, it is mind boggling so you have to think of higher levels of abstractions it?s called level of abstraction, higher level of abstraction. I will talk about MSI being directly used, LSI being directly used to get VLSI and all that. 

So starting from next lecture using these building blocks of both combinational and sequential we will see how to build systems which are meaningful in sense of system design. We have basically smaller systems to start with and later on probably we will do one or two bigger systems. Just to get you some ideas we will start with small circuits. 


Digital Circuits and Systems
Prof. S. Srinivasan
Department of Electrical Engineering
Indian Institute of Technology, Madras
Lecture # 22
Application of Shift Registers

(Refer Slide Time: 2:03)

 

Today we will see some of the applications of Shift Registers. We talked about flip-flops, counters and registers. Registers are group of flip-flops in which you can store data. Then we said the registers can have a shifting feature so that once you put a data you can shift that data either to the left or the right and these are called Shift Registers. There are some other applications, of course we saw applications of flip-flops in counters, likewise an application for registers the most prominent applications of registers in the memory storage, to use them as storage elements. Shift Registers are sometimes used for other applications. I thought we will see some of those applications today, the Shift Register applications. 

Let us for example take a 4-bit Shift Register with a shift right feature, so it?s a 4-bit shift right Shift Register. Let us assume this is serial in parallel out that means you can put the data serial in parallel out does not mean you cannot put parallel data, parallel input also will be there with a load in feature otherwise normally data is put through serial. So this will have the data in the clock of course clock either positive edge or negative edge doesn?t matter, the input is called serial I SI serial input and the clock will shift the bits. We should also have load and clear features because we want to start with a pattern that also you can do by putting the data one at a time and shifting it that is one way of loading and the other way of loading is to give parallel inputs and then give all the bits at the same time. So these are parallel output these are Q all these are A B C D so it is QA QB QC QD and D so DA DB DC DD. 
(Refer Slide Time: 5:53)

 

First you put a pattern in this load it of course you want to clear it later on you can do clearing, then you clock it and as you clock it the bits get shifted as one position to the right that?s why it?s called Shift Register to the right. So what I am going to do is to take the output of this and this into an Exclusive OR gate and feed it as the input. So every time I clock it this bit goes here, this bit goes here, this bit goes here, and the Exclusive OR of these two gates is loaded as a fresh input. So, as you clock it this will go on. So let us assume that initially I am able to load a pattern of 1 0 0 0 initial pattern but you can assume anything, I am just assuming this. 

So to start with I load 1 0 0 0 then at the next clock pulse at first clock pulse what will happen is this 1 gets here, this 0 gets here, this 0 gets here (Refer Slide time: 7:40) and a new bit will be added to the input which will go into QA and since this is the Exclusive OR of C and D what will be the Exclusive OR of C and D? It is 0 so that 0 will get into this position. Therefore again I shift it after the second clock pulse and this will become 0 1 0, this also 0, and after third clock pulse one fourth clock pulse, fifth clock pulse and what will be the new bit, it is 0 again, 1 Exclusive OR of these two so all you have to do is to shift these three bits here and get the Exclusive OR of this here (Refer Slide Time: 8:43). Now after this this will be 1 0 1 0 0 1 0 1 1 0 1 1 1 1 0 1 1 1 1 1 then it will be 1 1 1 0 I will write here after this it will be 0 1 1 1 0 then 0 0 1 0 1 0 0 0 which is this.









(Refer Slide Time: 10:05) 

 

So by just putting one initial pattern, this is only an arbitrary pattern it doesn?t have to be 1 0 0 0, you can put any other pattern. And again shifting every time the uplift clock pulse the bits get shifted one bit position to the right and a new bit is added to the left then again is shifted and so forth. So what happens is how many different patterns are here? This is the starting pattern so 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 patterns again it repeats. So, after the first clock second clock third clock fourth fifth sixth seventh eighth ninth tenth eleven twelve thirteenth clock fifteenth clock and this is 0 so fifteen clock pulses so the frequency of repetition is fifteen clock pulses or fifteen clock durations. After fifteenth clock pulse the original pattern is restored. 

Now there are only sixteen possibilities with four bits so I get all the four except one, I don't get 0 0 0 0 if I get 0 0 0 0 what will happen is it will keep repeating so I should not put a 0 0 0 0 to start with because when you put 0 0 0 0 it gets shifted to 0 0 0 0 again it gets shifted to 0 0 0 0. So, if you leave 0 0 0 0 so you load anything other than 0 0 0 0 I get all the other fifteen patterns and then it gets repeated. Such a circuit is called a pseudo random noise generator. It need not be necessarily noise but it can be pattern you can call it pseudo random generator. 

What I mean is suppose you want to have a verification pattern you put a bit pattern which is accepted and for that bit pattern you know the sequence that has to come so you can know whether there is any error in the transmission. If you agree on the initial pattern both at the sending and receiving end for this given pattern you know the sequence of these patterns I think you call it pseudo random sequence generator which can also be used for generation of noise so if you want put it this way. So the advantage of this is I can check the transmission over a period of time so I agree on the initial pattern both at the receiver?s and sender?s side and then start sending data and as I receive data I check with this and if there is a change that means there is something happening to the transmission. 
Why it is called random is because the pattern can be also kept secret in the sense even though all the fifteen patterns will come all the fifteen words all the fifteen different patterns will arise the sequence in which they will come depends on the initial pattern, if the initial pattern is different then you will have a different sequence so again it is fifteen. So it is not completely random and after fifteen it will be repeated so that way it is pseudo random. 

Pseudo random means semi-random it?s not completely random. You know that fifteen patterns are going to come and if you know the initial pattern you can guess the other patterns so that?s why it?s called pseudo random. But if you have this pattern that is given as a test pattern I can use it for testing. I can give the initial pattern and send it and test whether I am receiving the other things in the same order. It is one of the important applications of a Shift Register, pseudo random sequence generator. 

And I can now have different values as I said the starting value so that the patterns will be repeated but not in the same sequence or I can tap instead of here I can do here I can do here (Refer Slide Time: 14:56) I can take this, this and this and Exclusive OR of three inputs I can do, I can do all sorts of variations I can get different sequences and different patterns so I can have a simple test design one is for testing the system and the other is for establishing the reliability of the communication between two points. If the initial test gets through the other side properly then you know that the channel is well established and you can start sending the transmission. This is one of the important applications of Shift Register.

(Refer Slide Time: 16:30)

 

We will talk about another application of Shift Register and just for the purpose of explanation I am going to put them as three different flip-flops. Let us have JK flip-flops. So I will call these flip-flops A B C and these are clocked together, I will not show the clock separately because they are the same thing, I am just showing this drawing or I can show it separately also doesn?t matter. What I am going to do is to connect this j to this Q bar and K so you have three JK flip-flops output of first JK goes to second JK, output of second JK goes to third JK and output of third JK goes to input of first JK with a twist Q and Q bar. This is a Shift Register in the sense that the output of this gets shifted into this, for every clock pulse this output goes into this, this output goes into this, that?s why it?s called a Shift Register. 

(Refer Slide Time: 20:20)


 

Now, after the first pulse because the C which is 0s C bar which is 1 is connected to J where J becomes 1 and K becomes 0 after the first clock pulse. I put 0 0 0 I shift it, one clock pulse shifts this 0 into this, this 0 into this, this 0 not back into this but this 0 is connected here in this one. So after the thing the next time the pattern will be 1 0 0. After second clock pulse it will be 1 1 0, third clock pulse it will be 1 1 1 and fourth clock pulse it will be 0 1 1, fifth clock pulse it will be 0 0 1 and for sixth clock pulse it is 0 0 0 which is the same as the original. So, in six cycles of clock I get the pattern 0 0 0, 1 0 0, 1 1 0, 1 1 1, 0 1 1, 0 0 1. Now if you draw the waveforms for this how is it going to look like? 

I will draw the waveforms here. Here it is clock clock clock clock, this is 0 of the first clock pulse, (Refer Slide Time: 21:10) second clock pulse, third clock pulse, 0 and this is clock time axis. 








(Refer Slide Time: 21:30)

 

Now if we look at this we can see that initially it is 0 0 0 then A becomes high for three clock pulses and low for three clock pulses and high for three clock pulses and low for three clock pulses it repeats. Similarly for B it remains 0 for first two clock pulses then three and then next three clock pulses 0, next three clock pulses 1 and so forth it repeats. C becomes 0 to start with and for first three clock pulses it remains 0, second three clock pulses 1 then again 0 then again 1. So when you draw this for A B C pattern A would be 0 then becomes 1 remains 1 for three clock pulses and then remains 0 for the rest of the period. this is the output A I will not show the timing separately in the time axis B would be first two clock pulses will remain 0 then next three clock pulses will be 1, C would be 0 for first three clock pulses and 1 for the next three clock pulses. 


















 (Refer Slide Time: 23:20)

 

Therefore I am dividing this clock by, what is the frequency of this compared to this? Time period of this is six times less, for example (Refer Slide Time: 23:50) this period is equal to six periods of this clock, the period of this clock is one sixth or I can put eight four flip-flops will become eight so the period of this clock is n times the period of the original clock where n is twice the number of flip-flops so I should say 2n. The period of this clock is 2n times the period of the original clock where n is the number of flip-flops that you use for this. That is one thing which you can always get by a division. But more importantly if you want to use this as a separate clock of different phases there is always a phase difference of this much, one third of a clock period, one third of a clock period between this and this, this and this and between this and this (Refer Slide Time: 24:50). I can get a clock period it?s called multi-phase clock or multiple phase. 

















(Refer Slide Time: 26:10)

 

So I have the clock period which is 2n times the system clock period we will call this system clock and there is a phase difference between two successive waveforms of one original clock period between successive clocks. Sometimes it is useful so I want to have some lights going in a sequence. Suppose I turn on lights and turn off lights using this, this light will be on at this point and it will stay on for three clock periods and then it will become off, this light will be turned on (Refer Slide Time: 26: 25) after a delay from this light again it will stay so before that it will go, so first this will light up then this will light up, then this will light up and this will go and this will go and this will go.

Therefore it is some sort of an application like that where you need multiple phases, it?s called multi phase clock, you can use it for some system. This is also called a counter. Basically what you do in a counter? Counter will give you a clock pulse divide the clock by a factor of 2 by every flip-flop frequency is divided by 2 in every flip-flop stage so the same similar thing here. This is also a counter but the only thing is the output of this counter we twist and then connect it. In a counter the output of 1 goes to the next, output of second goes to the third, output of third goes to fourth and output of fourth goes back to 1. And without twisting it if I do you can take it as an assignment exercise you connect Q back to J and Q bar J back to K. 

Of course you put a 0 0 0 nothing will happen and anything other than 0 0 0 you put and see how it is, it?s a Shift Register basically that?s all, 1 0 0, 0 1 0 then 0 0 1, 1 0 0 so it will only repeat it is a Shift Register. That?s called ring counter a counter wherein we use the output of the last flip-flop back to the input of the first flip-flop is called a ring counter or recirculating Shift Register they call it, you circulate again and again in the same pattern. But this counter is slightly different from the ring counter it?s called twisted pair ring counter. 


(Refer Slide Time: 29:40)

 

So we have recirculating Shift Registers, ring counter, recirculating Shift Register is same as the ring counter in the sense I have this flip-flops (Refer Slide Time: 29:12) serial output is fed as serial in, put a pattern and keep circulating it that?s what will happen in a ring counter. Put a pattern and connect it back even if it is a D flip-flop for that matter, you don't need to use JK. If you want you can use JK too. But this Shift Register which uses twisting of the output back into the input is called twisted ring counter. 

What we have seen is twisted ring counter used for multiple phase clock generation and the period of the clock will be one sixth of the period of the original clock with a phase difference of one clock period between two phases. This counter is also called a Johnson counter. Again it?s used commonly for multiple phase generation. If you want to have lights turning on and turning off in a particular sequence you can do this, this is one example. 

Now, if I don't want this phase to be of this duration one period of clock but I want only one clock period with different phases, that is I want a clock to be on, I want one pulse to be on for this period, one period another clock to be on for this period as we have six periods and suppose I want pulses like this (Refer Slide Time: 31:19), what I am saying is take the same light example, this light is on at this point in time and remains on for three clock periods and then switches off, this light is on after the next clock period but remains on for three more clock periods and so forth. I have three lights turned on, this turns on, this turns on and I can have them on for half the clock period and for other half clock period it starts disappearing and then becomes like this.





(Refer Slide Time: 32:00)

 

Instead since I want six phases I should have six LEDs or six lights which will be turned on each only for one original clock period. That means I want something to be on for this period alone and off for the rest of the period. It can be a motor, it can be a light, it can be something which you want to just activate for this clock period, another only for this clock period, another only for this clock period, this, this, and this so from these waveforms I should be able to generate these waveforms easily because if you look at this A B C we can also write as we started with 0 0 0 then we made it 1 0 0, 1 1 0, 1 1 1, 0 1 1, 0 0 1 and back to 0.

(Refer Slide Time: 33:35)

 

Suppose I take the complements also at the same time so each of these flip-flops have Q and Q bars so I can call this A B C this as A bar B bar C bar so similar to A B C I can draw waveforms for A bar B bar C bar which will again have the same on period for three clock pulses, off period for three clock pulses but that will be complemented to the corresponding clock, A bar will be complemented to A so inverse of A, B bar will be inverse of B and C bar will be inverse of C so again on for three clock period off for three clock period total clock period being six times the original clock period. Now I can see the pattern such that I want something to be on only for one clock period, now you can look at this for example, if you take B bar and C bar or 1 only for the first clock pulse, let us call this the first clock period second third four five six (Refer Slide Time: 35:08).

Suppose I say A bar or B bar C bar, B bar C bar is 1 only for this clock period, there is a change here, you can have A bar B bar AB bar, the first clock period will be on, A bar C bar and not B so A bar C bar is on only for these two clock periods, for this clock period A and A C bar only for this clock period only for this clock period is on high, another change here A B bar, what is third one? B C bar and fourth one will be A C will be there A C will be on only for this, this one would be A bar B and A bar B here I think it is the complement of this, this will be B bar C most probably B bar C complement operations. 

Hence, now all I have to do is to get the complement of these waveforms A B C A bar B bar C bar and then use AND gates so in that case the first clock period is on A bar C bar of course I am not showing C bar, I am not showing A bar B bar C bar you can imagine that, it will be the opposite of this (Refer Slide Time: 38:32) and this will be A bar, this will be B bar, this will be C bar. So these waveforms can be clubbed to form A bar C bar here A B bar, B C bar, A C, A bar B, B bar C so I have now variety of choices. I can either have three phase clock with the same period of six times the original clock period so I can have a light on overlapping, three lights on, first light will be on, second light will be on after sometime, third light will be on after sometime and then the first light will be off, second light will be off, third light will be off so you can have this kind of a display.
















(Refer Slide Time: 40:00)

 

If I want to have only a light on for this period first light and then it will go on and second light will be on and it should go and the third light should be on so there are six lights it should be on for one clock period each of the original clock then again it will repeat. Thus all these applications are possible by Johnson's counter or twisted ring counter which is a basic modification of the Shift Register as I said because Shift Register basically is the output of one stage fetched into the second stage and shifted to the left or the right depending on the sequence.

The other two applications we started the other day was the parallel to serial converter. Suppose the serial data is coming I am giving examples of data coming through telephone lines in bit form and I want to assemble it as words serial to parallel conversion or you have the computer generated data which is available as parallel data bytes or words and you want transmit it through a telephone line you have to shift it serially and send it. So other applications are then parallel to serial converter and serial to parallel converter. 

So, Shift Register is a very very important building block of a sequential system or any digital system. these are all building blocks of digital circuits, first we saw combinational building blocks, gates, adders and all that, we saw sequential building blocks flip-flops and using flip-flops we saw how to build counters and how to build registers, how to build Shift Registers. Shift Register is a very frequently used component in many digital systems. 

I have given you some applications today like the pseudo random sequence generator, the Johnson's counter and then the parallel to serial and serial to parallel and things like that as we talked about the other day. So with this we are more or less completing the discussion of the basic building blocks. We have to talk of some other building blocks in combinational domain, multiplexers and all that. What I have to do now is to talk of systems. 
We will use multiplexers, decoders and other combinational building blocks which are not basic building blocks like gates. Gates are the basic building blocks in combinational, flip-flops are the basic building blocks of sequential but I took a flip-flops application and developed counters and registers and Shift Registers like we did in the case of gates we took the basic building blocks of gates and developed adders, subtracters and all that. So now a whole lots of things can be added, these are basically built using the basic building blocks, combinational basic building blocks are gates and sequential building blocks or basic building blocks are flip-flops so now we can use all these things to build subsystems or second order type of complexity and then using them you have to build systems. So we have to get into the act of how to define a system to synthesize it, how to build it. Before that we will just deviate for a minute and stay here now. 

Why did I now start from gates and finished gates and then instead of doing the other things like multiplexers and decoders and other programmable arrays which are all combination of building blocks switched to sequential in order to give you all the basic building blocks in both combinational and sequential basic tiles like a LEGO block I told you basic tiles are there it?s up to you to play with them and then build castles. Now, why did I do that is because technologically these are all of the same complexity. 

Generally we define systems as small scale ICs, all these are Integrated Circuits that is made of silicon but then built as one single circuit, a gate, even gate is an Integrated Circuit in the sense gate is not a component; the basic component of a gate is a transistor may be. a field of a transistor MOSFET as they call it Met??. Semiconductor Filed Effect Transistor or BJT Bipolar Junction Transistor, sometimes you may use extra components like resistors occasionally capacitors. So, using all these things you build a basic building block which is an Integrated Circuit because all these things are integrated, the circuit is integrated in a small single piece of silicon crystal in which you etch this by lots of means. 

Etching is a very crude term today, earlier it was done by chemical process but today we have so much precision required in all these things, we have lithography using lasers, using electron beam, molecular beam and all that, lithography, so that you can precisely cut. Even in surgery earlier people used to cut open and then do the surgery and then stitch back but today everything is done by precision beams, laser beams and so forth. Likewise in a building block also we have transistors and gates and things like that because the technology has grown very very precisely they are put together in different places and formed in a single circuit these are called Integrated Circuits.
 
Now, general Integrated Circuits are any circuit in which several components are both active and passive. Active components are transistors, diodes, FETs etc and passive components are resistors, capacitors, and inductors. 

Of course active (( )) are easy to make but passive (( )) are little more difficult, resistance is ok, capacitors are little more difficult both in terms of the size and the precision values and inductors are even more difficult. But we will see all those things later on as how they build all these things. But these integrated components Integrated Circuits are classified into small scale Integrated Circuits, medium scale Integrated Circuits, large scale Integrated Circuits and very large scale Integrated Circuits. 

A small scale Integrated Circuit is a circuit in which you have about ten gates in one circuit. A gate is an equivalent function and don't think a gate has to necessarily be a gate in the sense, I told you, a gate will have a few transistors and a couple of resistors. So, if you think of that as a basic building block like five transistors or two transistors or something in that order as one unit of gate you call it a gate function. It is actually not a gate as per say but it?s a gate function and up to ten gate functions in a single circuit is called Integrated Circuit, these are all approximately.

(Refer Slide Time: 47:45)

 

Any circuit which can do an equivalent function of ten gates or up to ten gates like the AND gates, OR gates, suppose you draw a simple combinational logic circuit system few gates here and there equivalent of that ten gates so up to that we call them as small scale integration and then from 10 to 100 approximately these are approximately thumb rules nobody defines this, these are not numbers like Planck?s constant or something or anything but it is just to give you the idea of complexity. Somebody gives a circuit you say how many gates are there in that circuit, you give me a circuit and ask me how many gates I say thousand gates but it doesn't mean thousand gates you put, it means that this circuit will do the things which can be done by about thousand gates that?s what we mean. From 100 to 1000 it?s called LSI and beyond 1000 it is called VLSI but of course today people use ULSI but I don?t believe in all that Ultra Large Scale Integrated Circuit but then anything big falls between VLSI and ULSI and all that. Somebody says beyond 100,000 it is ULSI and all that it?s all individual?s opinion. 

So this is basically a structure and why I finished all these basic building blocks and combinational or sequential is because whatever you have done up to now can be generally classified as small scale circuits. When you put more of this gates the functional complexity increases and they become medium scale Integrated Circuits and then you put more and more of them then it becomes large scale Integrated Circuits. So we have now understood the basic building blocks bricks and we will use those bricks to build the subsystems which are medium scale like multiplexers and other things and in the case of 4-bit full adder which may be qualified to be a MSI, similarly a 4-bit Shift Register or 8-bit Shift Register may qualify to become a MSI. then we will do MSI functions and then how to use them directly instead of gate every time because if you are giving a very very large circuit like a microprocessor you can design you cannot go to the gate level and design because a microprocessor may have 300,000 gates or 100,000 gates like that so I can?t give you a circuit diagram with 100,000 gates connected to them, it is mind boggling so you have to think of higher levels of abstractions it?s called level of abstraction, higher level of abstraction. I will talk about MSI being directly used, LSI being directly used to get VLSI and all that. 

So starting from next lecture using these building blocks of both combinational and sequential we will see how to build systems which are meaningful in sense of system design. We have basically smaller systems to start with and later on probably we will do one or two bigger systems. Just to get you some ideas we will start with small circuits. 



Digital Circuits and Systems
Prof. S. Srinivasan
Department of Electrical Engineering
Indian Institute of Technology, Madras
Lecture - 30
Encoders and Decoders

(Refer Slide Time: 1:45)


 

So in the last lecture two lectures we talked about multiplexers in detail and how to use them as building blocks or functional units in designing a combinational logic. Today we will see another circuit which is MSI which is a decoder so first we will see what an encoder is and then a decoder, encoders and decoders. 

As the name suggests it one codes the various combinations into a smaller number of bits and the other expands it back. So an encoder for example suppose I had eight inputs 8 to 3 encoder assuming only one of the inputs is active, it could be active high or active low at a given time all we have to know is which of these eight inputs is active so you need only three bits for that. By combination of these three bits you can determine which is the active input and all others are inactive at that given time. So this is the process of encoding. Encoding reduces the possibilities or the number of inputs required from 8 to 3 for example or sixteen to four. So compressing the data from different possibilities into a smaller number of bits is the process of encoding. In this case we will have eight inputs let us call this I0 I1 and I2 etc I7 and you will have three outputs we will call them O0 O1 O2 this is MSB and this is LSB. 

Of course if more than one input can be high at the same time then what happens in which case we talk of priority? 
If more than one input is active at a given time then we don't know how to determine the output but there can be some rules we can build some rules into that. We will not talk about that, I am just going to tell you about the type of MSI which are available. 

So, for example if I5 is at high and all other inputs are low the output would be 1 0 1. This process is called encoding. My question is as I said if more than one input is high what will happen to the output? We can have a procedure or a rule for this. One scheme is called priority encoding. I can say the input with the highest binary value could be recognized or the input of the lowest binary value is a recognizer. You can say priority goes from I0 to I7 that means if I0 and I1 are both active I0 will be coded and I1 would be ignored. This is one scheme. You make the rule and then build the circuit accordingly.
 
Or I can say lowest order. I can say higher inputs have priority that means supposing I5 and I6, if along with I5 I6 is also active high I can say I6 should be recognized and not I5, then the output will not be 1 0 1 but it will be 1 1 0. Anyway this is called encoding process of reducing the number of bits into smaller number of bits without any loss of data. In the reverse of this the complimentary operation is called the decoding operation. So this is an 8 to 3 encoder (Refer Slide Time: 6:11) so we will have a 3 to 8 decoder so I can put this here straight away so three possibilities are there and any combination of this can happen because there will be eight different outputs so the corresponding output will be high and all others should be low. So I can have again I0 I1 I2 lowest order and these are the highest order bits and then I can have O0 O1 O2 O7. Now this 1 0 1 goes there as 1 0 1 making O5 high and all others low. This is the decoding operation. This is the encoding operation and the decoding operation.

(Refer Slide Time: 7:12)


 

Why do we need this? 
I have eight possibilities as the inputs and eight possibilities are required as the output and I don't want to run eight lines from inputs to outputs because one of these lines will be active high at any given time and others will not be. So instead of running eight lines and finding out which is active high I can send three lines with a code a coded information into that and then at the output will decode it at the receiving end we will decode that three bits to find out which input exactly was high here at the sending side. This is compression data, data is compressed. Eight lines instead of running because of the length requirement we can do it with three bits, three lines will do the job. And if there is a priority scheme here it doesn?t really affect this here because here it is an expansion scheme so three is expanded into eight so whatever is the combination will be expanded accordingly. 

Here of course there may be problem with more than one input being high so in that case we will have a priority scheme by then. In such a case it is called a priority encoder, either a normal encoder or a priority encoder. The priority encoder will have a priority scheme built in saying when more than one input is high which of those inputs will be recognized and coded at the output. 
 
Now how is it going to help us in our combinational logic design? It is just as multiplexers helped us to design combinational logic without going to the gate design. Because after all inside you can build these gates, we can draw a truth table, can you not? Can I not make a truth table out of this?
 
ABC are the three inputs or I0 I1 I2 are the three inputs, O0 to O7 are eight outputs so I can draw a truth table and 0 0 0 combination will make O0 high and all others low so I can have a gate realization for this, likewise I can have a gate realization for this so all are gates finally. Basically they are all AND OR inverter. I told you long ago that AND OR inverter is a sort of universal combination by which any circuit can be recognized and can be designed so the same thing applies to the encoder and decoder.
 
Or if we don't want AND OR combination we can have NAND gates universal gates or any other combination of gates that you want to work with. So what is the advantage of using this? Now we have this scheme of so many equivalent gate functions may be about ten to fifteen or twenty depending on the number of inputs number of outputs and priority schemes built or not somewhere between 10 to 20 or 10 to 30 gates will be there so when you compress it and make it as a single IC and make it available to you putting in one IC chip then it becomes a Medium Scale Integrated circuit MSI.
 
Our aim in the last few lectures has been to use these Medium Scale integrated circuit components in the design of combinational circuits. So we have to see how this hardware encoder and decoder will be used in combinational logic design. Let us say design a combinational logic using Decoder. This is a very straightforward procedure here because even in multiplexer of course the mapping procedure was very clear but it is not even that here it is a straightforward case. Because when you have three inputs and eight possibilities this is similar to the truth table is it not. That means all possible min terms are generated. The question is one of them will be high and all others will be low. 
but in general though when you have three inputs and eight outputs it?s equivalent to a truth table with three inputs and eight outputs and each of this output being a min term and if you know which are the min terms that are high for that particular combination of the hardware then I can combine them all together and make a circuit out of it. It?s as simple as that.

Suppose I want to realize a function f sigma F(A, B, C) A being A, B and C you will have to be always clear with which is MSB and which is LSB. Here I am considering this as the MSB and this as LSB (Refer Slide Time: 12:10). So, when you map it I should connect A to this, b to this and c to this so that?s why I am writing in this fashion F(A, B, C) it will be equal to sigma let us say arbitrary or whatever you want or use the full adder (1, 2, 4, 7) is the sum of the full adder. You have seen full adder so many times 1-bit full adder min terms which are high for the full adder sums are min terms (1, 2, 4, 7) so we will realize a full adder and that?s what we did with multiplexer to start with,  we will do the same thing with decoder.

So all you have to do is to get my three inputs this is Cin, here this is A, this is B, this will be Cin in that order I am writing so the same order should be mapped and output will be m min terms and I will call this I0, I will call this m0 which is same as I0, here these are Is equivalent to the min terms so I will put I0 inside and m's outside, this is m0, this is m1 etc and this is m7.

(Refer Slide Time: 13:50)

 

 Now in order to get a full adder I need to combine m1 m2 m4 m7 into an OR gate. So I take m1 m2 m4 m7 this is my f this is the sum of the full adder, a simple scheme of realizing a combinational logic using a 3 to 8 decoder. This is a 3 to 8 decoder. This will the only function I can realize if I have one more function using the same min terms I can also get it. Suppose I want a carry also in this can I use the same decoder for this? Of course I can. So my carry would be I will call this F1 or Fsum, F carry out of ABC in or if I remember it was 3, 5, 6, 7 sigma that is Fco (A, B, Cin) is equal to sigma m(3, 5, 6, 7) these are the min terms for which the output is 1 for the carry so I can combine them this now requires m3 m5 m6 m7 so m3 would be here I3 m5 I6, m3 m5 m6 m7. So we will have to take m3 m5 m6 and m7 put it in OR gate and this is my Fco carry out f sum Fs.

(Refer Slide Time: 16:28)

 

So there is one 3 to 8 decoder and two gates and we are able to realize a full adder so that is the MSI concept Medium Scale Integrated circuit replacing the bunch of gates. It may not be most efficient way as I said, it?s a mapping process. In the mapping process you have two problems. One is that mapping itself may not be efficient because the hardware availability is limited and you have to get the best possible way of doing it. The second limitation is that not always there will be a straight cut method for doing it. As I said the other day it?s a heuristic method sort of an intuitive method. We have to identify the hardware availability and the input requirements and try to match it so there may be an error in that.

Even if you do software for this software may not always do it the optional way. So we may use some extra hardware in that process because of that or there may be also be extra hardware required because there is no one to one correspondence or everything that I want to realize I may not have an equivalent MSI. But still it is worth it because the number of gates is drastically reduced in terms of, the number of ICs is drastically reduced saving space or whatever power, cost, size and so on. The same is repeated there, the parameters we were stressing on right from beginning in this course.

Of course I am giving you a bare bone sort of a approach in the problem. There are some practical issues here. We are building most of the things conceptually, we are not getting into circuit details. Of course as I said that is not required if you are going to use a logic design or you know what the input output specification is. But even in a logic design you should know a few things for example you should know how much voltage you should apply, should you apply 250V or 10Kv or 5V or 3.3V. Of course you will get different data sheets but you should know what order of voltage you are looking at, what are the current levels and so on. Suppose you buy an LED to indicate your output, what type of LED, what type of current is available and whether an LED can go with that so these are the things you should know of course, a little bit of the gate level electrical specifications as we call them. 

Even though it?s all logical and we are not getting to the physical design which is the next level where you replace this logic by components which are available we are not getting into that because of the background is not adequate in terms of the electronics but there are certain things. One of the things is there is always an enabled class in all of these things, whether it is a decoder, encoder or a multiplexer it will always be a signal called enable signal, I will introduce it here because it?s all same in many ICs but I thought sometimes I should tell all these things to you before you get out of this course like this preset and clear there are extra signals in flip-flops. For a logical design or a simple analysis understanding of the flip-flop you don't need to know it but then I introduced it.

(Refer Slide Time: 19:45)

 
 
Likewise here I want to introduce a signal called the enable signal. ?Enable? usually is a negative signal the active low. Whenever you put a bubble or a signal it means the signal is active when it is low and when it is high it is not active. Whenever you don't put a bubble signal is active when it is high and not active when it is low. There is an enable signal here and this has to be tied to ground if this circuit will work (Refer Slide Time: 20:19) and this represents ground in electronic circuits or this is 0V. That means if enable is low whatever we said about this decoder encoder is true. If enable is high if I do not connect the enable to ground properly then whatever you give here will not reflect in the output, the output will not behave as expected in the truth table, this is true of many ICs multiplexer as an enable signal, encoders have enable signals, decoders have enable signals and sometimes more than one enable signal. These are signals that are required for controlling.
 
I may have a circuit and a board and a system, I may have this IC and a circuit but I may not want that to be active at a given time, I want it to be active at some other time so how do I control that, I cannot just pull it out whenever I want to put it in and whenever I do not want I pull it out, it?s not possible to physically remove the IC and put it back. Suppose you want that IC not to affect the rest of your operation you don't want an IC there at that time you have to pull it out and you want it there you put it in but it?s the electrical equivalence of removing and putting it back.
 
When enable is low it?s equivalent to keeping it there and when enable is high it is equivalent to removing it so that it is not there. So electrically it is not there physically you may have inserted the IC in a socket but electrically it?s not there electrically you can ignore it. Such things are required very much because many designs are complex designs where several ICs have to co-exist and certain operations requires certain paths and at that time the other circuits should not come in the way so how do you control it is by these things. 

And, there may be more than one enable. When you say enable if you want to be very clear and if you don't know all these and since you don't have the circuit diagram so every time you are talking about a decoder you cannot draw a circuit and show enable as a bubble so what you say is simply say enable bar so people understand. When you say a circuit as an enable bar which means I should make it 0 for it to be normally active, a normal operation so enable 0 is a normal operation and enable 1 is abnormal operation it?s an electrical open circuit. 

I have to define a term here and since I have not defined a term here I am not able to write it it?s called tri-state operation output tri-states. Again these are some compulsions. As you go and I have to introduce a new term I can?t keep postponing these things. The output is tri-stated. Here I can say that the output impedance is very high, output high impedance, output impedance high, output high impedance state. High impedance means impedance such that it is as high that you can ignore it. All of you have gone through electric magnetic circuits course so you know what it is. High impedance means physically if we put hundred mega ohms it is just as if it?s equivalent to open circuit for practical reasons. of course mathematicians may argue that it?s not 0 it?s not open but we are engineers not mathematicians so we have to be practical. When you do something you will have to do the practical implementations.

Therefore high impedance means the output is as if it?s disconnected from the rest of the set. Like you sit in the class and disconnect yourself from what is happening thinking about something else so that is exactly what high impedance state is. You are physically present mentally off many times it happens right? I do it when I go to some meetings which is boring but I have to be there because I am required to be there, it happens to everybody. The only thing is I wish that it doesn?t happen too often in this course. That is exactly high impedance.
 
So we have a function called tri-state gate function which is what will be put in output for these operations. But there can be more than one enable so this is only one enable. In a practical decoder like 3 to 8 decoder generally there are three enables G1, G2A and G2B where G2A and G2B are active low and G1 is active high. So, if this circuit works normally, this is a practical 3 to 8 decoder, I can give you the IC number if you want to this is 74138, it is not necessary to remember numbers. In fact I am not even sure it?s 128 or 138 but I think it?s 138. 

Now this particular IC which is three inputs eight outputs has three enables that means for a circuit normal operation G1 should be high, G2A and G2B should be low only then the circuit is a normal operation. Why do you need three? As I said sometimes the control signals I want to control it I may have to control it from different times of view from different ways so I can use these three combinations. But only when all the three occur as required only then there is normal operation but the rest of the time otherwise outputs are tri-stated, otherwise outputs are high impedance states, outputs are in Z state. Instead of writing every time high impedance state capitalize Z and put it as Z state. Z state means high impedance state for digital circuits, this is an accepted nomenclature.

(Refer Slide Time: 27:41)

 

When you say Z state it means a high impedance state, accepted nomenclature will be digital. I wish I remembered whether it?s 128, 138 but it?s ok let us assume 138 for now. Please check up may be 128. The outputs are not active high. One other practical note on this IC is that the outputs are active low, so instead of getting O0 O1 O2 how many are there? 1 2 3 4 5 6 7 I will probably put the enables here it doesn?t matter, enable does not have to be at the bottom because it?s all on in what way it is, it?s only a representation of circuitry in the book, you can write it here also; G1 G2A G2B, this is I0 I1 I2 (Refer Slide Time: 28:57) and this is LSB, MSB. O2, O3, O4, O5, O6, O7 and these are active low outputs as well.

(Refer Slide Time: 31:00)
 
 

That means if a particular combination occurs the combination occurs after enable is properly connected of course. So we are assuming this is 1, this is 0 and this is 0 and I have properly connected the enables. If this is my only IC and it?s not required to be controlled by any other event in the circuitry I can directly connect it to ground and power supply. These are control signals but it does not mean that it always has to be controlled. Whenever we need to control they are available to you. If you do not want to control and you always permanently want this normal operation then there is no problem make 1 0 0 connected to high, connected to low, the power supply connected to low it will work always normally so that is possible, it?s not an excluded operation.

Anyway having done that suppose I give 1 0 1 or 1 1 0 O6 should be active high and all others should be active low. But because we have bars on the outputs if you want you can even put a bubble on the output, the bar and bubble are redundant, bubble is only when you draw whereas when you are writing and when you are looking at the data sheet you will see these signals I0 I1 I2 and O0 O1 O2 so you need a bar for that. So O6 will be low and all others will be high. Normally it will be the other way. When I say active high outputs O6 should be high and all others should be low so this is a practical decoder which is available, there are three enables, three inputs, eight outputs are active low. So if I want now to use this practical decoder in my adder circuit can I do that?

I have connected these four into OR gate to get sum, connected these into another OR gate to get carry (Refer Slide Time: 31:14) assuming these were active high but now I have learnt from the data sheet that these outputs are not active high but they are active low so they are active low outputs.

How do you change this design? I use NAND gates. What we want is, sum is m1 m2 m4 m7 but what is available is only m1 bar m2 bar m6 bar and m7 bar so we will see what S bar is. So S bar would be m1 bar m2 bar m4 bar m7 bar but you want inverse of that you want sum so sum is NAND. So connect this (Refer Slide Time: 32:40) 1, 2, 4 and 7 into a NAND gate we get sum for full adder if I connect my A B and Cin of the full adder of the inputs. Likewise I can connect this through NAND gate m5 m6 m7 another NAND gate m3 m5 m6 and carry out so carry output is m3 m5 m6 etc. 

Some of these practical things you should know that?s why I thought I will introduce this. when we look at a circuit logically you may be right conceptually you may be right but then it will not work because you are assuming the outputs to be active high but they are really active low or you did not know there was an enable which has not been properly connected or you did not get the proper power supply voltage in ground, you should know which pin has to be given power supply and which pin has to be given ground. So all these things you should know.

(Refer Slide Time: 34:18)

 

Of course you can look through the data sheet but you should know there are a few things you should look for. You don't have to remember the details but you should know to look for something. Without knowing that there is something to look for then how will you look for them so that is why you look for this? Coming back to the tri-stating what do you mean by tri-stating and how it will be active high. Suddenly we say it?s active because we know only two things an input or output can be low or high where low means 0 high means 1 for positive logic, 0V and 5V, 0V and 3.3V, 0V and 4.2V or whatever but now suddenly I am introducing a third concept called the output can be 0 or 1 or a high impedance state. So what is a high impedance state? These are called tri-state gate the tri-state meaning there are three states tri-state gates.




(Refer Slide Time: 38:36)

 

The tri-state gates have three states. The signals of tri-state gates are three states; low, high and high impedance. So this is 0, this is 1, this is Z. There is a third state and that is why it is called a tri-state. Actually this tri-state was long ago coined by National Semiconductors a major semiconductor manufacturer and they patented it and the term was patented so other combinations should not use this term tri-state but they have to say three state buffers. I think now it must be sufficiently long and the patent must have expired so probably can use it. So you will find in text books freely tri-states whereas when you look at company literature and some other company other than National you will always be careful to write three state buffers because somebody can go to court and file a patent violation case against the user. Tri-state is as if the tri-status because the word was coined by National Semiconductors long long ago and it is history now.

So what you mean by this? I have an input and output so let us take a simple inverter, input is A and the output is A bar so this is the two state gate where A is 0 A bar is 1 so you know the truth table of this inverter F is equal to A bar, all of you know this. Now we are introducing a third concept where the output can be either 1 0 or Z. How do you know or how do you control this? When you want output to be of high impendence how you make it high impendence so I need some other extra input for that. So I have a third input called enable input that is where the enable concept came.

So this is true if enable is 0 so now this truth table becomes true or normal operation only when enable is 0 and if enable is 1 which is high like as I said enable is usually an active high it is not a rule, you may find a circuit in which enable is high so don't always assume, you look at the data sheet always. Before you use an IC practically you have to look at the data sheet. today everything is available in the web, you can go to the website of that particular manufacturer search that IC you are looking for that fellow give you the data sheet in fact there will be so much details which will confuse you so you have to look for what you want.
 
On the other hand, if enable is high so the opposite of it is disable now if A is 0 or 1 the output is??, doesn?t matter what the input is the output is always high state. Now this is a very important development in the digital hardware. Conceptually there is nothing here but hardware there is a third feature so now if I put all these inverters or any other gates this is only an inverter I gave as an example, the same thing can apply to any gate. You can have an AND gate with an enable in principle of course, it may or may not be there as a component so if that enable is low AND gate works as AND gate and if enable is high whatever inputs you give the AND gate does not give the AND output but it gives you a high impedance output. That is what I said just now in decoder. It can also be there in encoder, it can be in multiplexer, it can be anywhere.

What is the idea?

Now in all these ICs there is something present like that, some other gate and I am connecting them all to a destination. These are different sources of data or control functions or whatever and this will now go to another circuit here. I want this combination but at one time there will be only be one source of data. So, at a given time I would like the output here to be determining this gate only and this should not interfere. That means this output will be inverse of this and this should be this (Refer Slide Time: 40:25). At some other time I want this output to be inverse of this and this should be this. So I may have different sources of data or different connections in a circuit all feeding to a same input, input of a same gate and I want only one of those inputs to be effective at that time so that the output will be determined accordingly in my circuit description. I can do it when I want and when I don't want it I can remove this ICs. As I said that?s not a good solution, not a practical solution. 
 
If I don't do that what will happen is even though this is high or low, all of them have to be high or low, if this is high and all of them are low where low is 0V that means practically ground. So I am trying to push this high voltage into this so at that time this is low and then this gets grounded, this also gets grounded. So whenever I try to pull this up using the output of this because this is high these two gates will put it down to 0 these are the problems. So if I have the Z feature built into all of these, all are tri-state gates, now all these gates are tri-state gates (Refer Slide Time: 41:58) then I don?t have any problem. So I will control the circuit such that when the output of this has to be the input of this I will make sure these two outputs are of high impedance which has no effect practically on the operation of this circuit.









(Refer Slide Time: 42:36)

 
 
When I want this output to be the input of this circuit I will control these two outputs to be high impedance so that these two circuits will not have any effect on the output of that circuit which means electrically you are disconnecting it but physically you are not. So this is also built in many circuits. The enable inputs is a very common feature in multiplexers all ICs especially MSI and LSIs. Because these MSI LSI will sit on what is called a bus, this is called a bus (Refer Slide Time: 43:06). We generally refer to a bus as a vehicle that transports lot of things at the same time, many people can join in the bus and then go likewise here a bus refers to something where many signals can join and go. So the common bus is there. All these outputs feed into a common bus but the input will be used in only one of those common signals which are useful to the input so I have to disconnect the other inputs from the bus but physically disconnecting is not possible so I electrically disconnect it. The other inputs are not required at a given time.

Therefore when you have bus operations of these ICs especially MSI and LSI as they go more and more complex in design we will use all of these in our design because it is very complex and all of them coexist. At the same time only a few of them will have functions at a given time their roles and the rest of them will be, it is like somebody asking somebody else to shut up, lot of people are there and only one person is allowed to talk so what happens here is something similar to that.

Now we have practically covered lot of grounds in the case of MSI LSI the basic concept of MSI based design as against gate based design. The advantage is that there is a simple hardware which can replace the tons of gates with all the attendant advantages in terms of the cost, size, power consumption and everything, the speed of operations and performance. The best match may not be possible either because of the non-availability of the hardware feature or because of the dubitation of the design procedure but still it is worth it but it?s better than the other suggestions.

Then we talked about MUX and decoder which are two major components in MSI in design of these things and we talked about how to map a given hardware, a given Karnaugh Map into this hardware. We talked about how active low and active high outputs are possible and we talked about enable feature and how enable feature controls the operation. What happens when the circuit is disabled? It goes to the high impedance state the high Z state and this is the idea behind that. 

The next step we will take is towards LSIs Large Scale Integrated circuits and they will have to be programmable as I said because when you have larger and larger circuits it should be more and more useful. I cannot make a simple circuit which is mappable or non-mappable so I just throw it and get another circuit. When I make a Large Scale Integrated circuit it should be available for many operations so they become programmable. 

We will talk about it but before that I want to mention that MSI is not restricted to only combinational logic circuits, these are combinational logic building blocks, multiplexers and decoders. But you think of a counter a 4-bit full adder MSI, if I can make one 4-bit full adder one IC in each full adder you have about how many gates? You have two Exclusive OR gates for add and four gates for the carry and all that and if you add this is what will happen is you will get something like 24 or 25 gates it qualifies for an MSI.
 
So functionally small scale integrated circuits can do but then put them together it becomes an MSI. The same way a counter can be or a register can be a MSI. Even though a flip-flop will be a Small Scale Integrated circuit because it only has couple of gates or at the most four to five gates including clock. When you put flip-flops together to make a 4-bit register or 4-bit counter they become an MSI. 

So we have now used MSIs without our knowledge, 4-bit full adders we have used in our design, 4-bit full adders are adder subtracters and all that type of things, we talked counters and registers, shift registers these are all MSI circuits they are also MSI based design. Of course we can also use them in some other ways we will see it later on.first let me finish the programmable aspect of combinational logics Large Scale Integrated circuits the programmable devices called PLDs where PLD stands for Programmable Logic Device. So in the next lecture we will start talking about PLDs Programmable Logic Devices. But later on we will come back to revisit the MSI sequential circuits, how they can be used in roles which we are not familiar with. Now we know how to use it in as a counter register but you can also use it for implementing the sequential logic, we will see that later. 
 


	
