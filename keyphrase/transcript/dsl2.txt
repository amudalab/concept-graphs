Data Structures and Algorithms Dr. Naveen Garg Department of Computer Science and Engineering Indian Institute of Technology, Delhi Lecture   2 Stacks Let us see about stacks. We will mainly see about stacks, besides we will talk about abstract data types, interfaces, exceptions, how stacks are implemented in java and application to the analysis of time series. We will also talk about growable stacks, which do a little bit of amortized analysis and then we will talk about stacks in java virtual machine.  What is an abstract data type  It is basically a specification of the instances and the set of axioms that define the semantics of the operations on those instances. What does it all mean  You know the data types like integer, real numbers and so on. You can understand the notion of addition and that is the same way as you add 2 integers in mathematics. Similarly we will define data types and certain operations on those data types. Those operations would be defined through an interface which basically gives us the signature of the operation that is the parameters that operation requires and so on. We will also specify the results of those operations through a set of axioms. Just as in the case of integers, you know the sum of 2 integers as defined in mathematics. For example if you add a variable of type A and another variable of type B. If you sum them up, then the answer will be of type variable as you would know it from your mathematics class. We will be clear if we see an example. The operations that you have been talking about are essentially of three kinds. One would be just a constructor operation which is as same as the constructor method in java. Using this method you can create an instance of that particular data type. When you are talking about sophisticated data types, this method has to do a lot of work Access functions are the functions which let us to access elements of the data type and manipulation procedure would let us to manipulate or modify the data type. Why are we talking about data types  Data types help us to identify the requirements for the building blocks of our algorithmic procedure. It provides a language which will help us to talk at a higher level of abstraction. As just as we are talking in terms of adding up of integers or in terms of stacks or queues or any of the advanced data type. They encapsulate the data structure like how the data is organized and the algorithms that work on that data structures. Also they help us to separate the issues of correctness and efficiency. We will see more of this as we see the example of data types. Let me start by giving a simple example of the data type and that is a dynamic set. A set is defined as a collection of objects. Suppose we also had operations, which would let us modify that collection of objects, which means add or remove an object of that collection. Such a set we would call it as a dynamic set. (Refer Slide Time: 4:47) We call it as dynamic, because we are changing the set which is the collection of objects. We will create data types for such dynamic sets. What are the kinds of methods that you have in a dynamic set  You would have a method to create a dynamic set, which would be a method new. There would be a method insert, to insert an element in to a dynamic set. S is the dynamic set and this method has two parameters let us say, the set s and the element. The result is an instance of the set itself which gives a new set, another set and also includes the element v in it. Similarly the delete method removes the element v from the set S. These are the two methods for updating the set. New method is for creating or constructing the set and IsIn is one of the access methods. All of it is telling us whether the element is in the set or not. The return value is of type Boolean. If v is in the set then it is true otherwise false. Axioms are the one which define how the operations should behave. We can write axioms in the following form. When I create a new set and if the set is empty then the answer should be always false, no matter what v is. If I have a dynamic set S and I insert an element v in it. Then the resulting set which has v in it should be true.If I have a set S and when I insert u in it, then the resulting set has u in it. Then if I where to ask whether v is in the resulting set, I will know that only if v was in the previous set S. Thus the answer to this operation IsIn (Delete(S, u), v), should be the same as the answer to this operation IsIn(S, v), provided v is different from u. IsIn (Delete(S, u), v) = IsIn(S, v), if v   u Suppose I have a set S and I delete v from it. If I ask whether v is in the resulting set, then the answer should be false. These are some basic axioms that define the nature of these operations and also the functionality of these operations. Still we did not specify how to do these operations or we did not talk about an algorithm or any procedure. At the least we have talked about the code for implementing the dynamic set. When you are talking about abstract data types, we are interested in more of the specification. That is what the instances would be like and what are the operations permitted on those instances, and the axioms that govern those operations. (Refer Slide Time: 6:46) Some simple abstract data type that you may be familiar with is queue, but we will be doing it later. Let us see about stacks. (Refer Slide Time: 8:52) What is the stack  It is the collection of elements but this collection follows the last-infirst-out principle. What does it mean  It means that the element which is inserted last would be removed first. If I insert an element and then I remove an element from this collection. Then the element that would be removed was the one which was inserted at the last. The operation of inserting an element is called pushing onto the stack and the operation of removing an element is called popping off the stack. (Refer Slide Time: 9:10) Some of you might have seen this kind of toys. It has a collection of elements for instance may be stack of trays in your mess. What you do is when you put a tray, you put it on the top and when you remove it you would always remove the one which is at the top. When you remove or pop of an element, it is always the one which you inserted at the last. We are going to define the abstract data type that is supported by four methods which are the key methods. The  new  is a method to create a stack. In the push method when I specify an element o it adds this element to the abstract data type. It inserts an object o on to the top of the stack. (Refer Slide Time: 9:52) Pop takes stack as the parameter and it does not take any parameter other than abstract data type. When I say pop the stack, it just removes the top element from the stack. If the stack is empty, they should flag an error stating that the stack is empty. The top operation returns the top element, it does not remove it and that is how it differs from the pop. Pop operation removes that element but the top tell us only about the top element. Again if the stack is empty then top does not make any sense, it should flag an error. (Refer Slide Time: 10:22) We can also have some support methods which will help us do these operations. Size is one such method. Size tells us about how many elements are there in the stack and isEmpty tell us whether the stack is empty or not. The 6 methods that we saw are push, pop, new, top, size and isEmpty. These are all the methods and hope you all understood about what these methods are doing. (Refer Slide Time: 11:34) Axiom governs the behavior of these methods. If S is the stack, when I push an element on to S and then when I pop it, I should get back S. While doing a top operation, when I push an element on to a stack and then when I do a top operation I should get v, because v would be the top element of the stack. So far we have defined about the stack abstract data type, the methods and 2 axioms. Axioms may not be complete but this is what the axioms would look like. How do we translate abstract data type into code  We need 2 constructs for that and they are the interfaces and exceptions. What is an interface  An interface is a way to declare about what a class has to do and what are the various methods associated with the class. It does not tell us about how those methods are done. That would be a part of the implementation of that interface or a class. For an interface we just right down the various names of the methods and the parameters it is going to take. In fact we do not even specify the names of parameter, we just have to specify the types of the parameter. When we write a class for an interface, we will actually provide the code for those various methods. I might specify an interface for a stack and I am going to ask you to write the classes for that interface. Different people will write different classes to implement the interface in a completely different ways. I can still use your classes or any implementation of the interface, in a program that I have written, provided that must meet the interface specification which I have given to you. All I need to know is that the implementation meets the specification so that I can use that in the coding of my own program. It helps us to separate the implementation from the specification and that is why it is a very useful programming technique.  Let us see about how a stack implementation looks like in java. Java has a built-in stack data structure but nevertheless we will define a stack interface. We just define the various methods that are going to be a part of this interface. There is one method called size, in which I need to specify the types of the parameters and the return type of the method. I have not specified how these methods are implemented. This is just an interface. In an interface we need to know the types of the parameter. When I am pushing, it takes a parameter of type object. Object is the generic type in java and all objects are derived from this type. The method isEmpty returns boolean. It just tells us whether the stack is empty or not. The top gives you the top element in the stack and it returns an object. It throws StackEmptyException, if this stack is empty then top () method should somehow signal that the stack is empty. We are going to do that using the notion of exceptions. Void means it does not return any object or any value. It does not return a stack but it is a method which is executed on this stack and it modifies the stack. Thus stack cannot be considered as a parameter. What is an exception  Exceptions are the mechanisms to handle errors. When we have an error or when we reach some exceptional condition or an exceptional case in the execution of program, we throw an exception. The term used in java is throw. (Refer Slide Time: 18:07) As soon as an exception is thrown, the flow of control moves from the current method to the point where the method was called. The idea essentially is that, when an exception occurs you delegate the responsibility of handling that exceptional case, to the procedure which called that particular method. You will be clear, if you see an example. I have two methods, one is an eat pizza method which throws a stomachache exception, also there is some dotted code. If you eat too much of pizza, then there is a problem and you throw StomachAcheException. The procedure public void eatPizza () throws was called in the method eatpizza (), which is inside the stimulate meeting procedure. When this StomachAcheException is thrown, the flow of control will come to TA.eatPizza (). Thus when this StomachAcheException is thrown, we will exist this method eatpizza () and go to TA.eatpizza ().  In the coding after { } there are bunches of other statements that would not be executed. The flow of control would interrupt the dotted point and would reach TA.eatpizza (). There is also a notion of try and catch blocks. When the exception is thrown what happens to the variable that we have modified  It depends upon the procedure call, think as if we are returning from this procedure StomachAcheException or a method. If those are local variables then you do not want to see them. If they are global variables and if it is modified in the if-loop, then those modifications are carried over to the TA.eatpizza () method. There is something called as a try and a catch block. If you think that there could be possible exception in this (TA.eatpizza ()) method, then you enclose the method within a try block. Start it with a try, open a bracket, and then include the method which you are calling and close it with a bracket. If there was no exception raised in TA.eatpizza () method or this particular exception StomachAcheException did not get raised in this method, then we will just skip the catch block, then go on to the statement, after the catch block. If an exception was raised in this (TA.eatpizza ()) method, because this method might raise many exceptions. If this (StomachAcheException) exception was raised in the method, then we would come in to the catch block and execute the statements. If the method raises an exception, then if that exception is caught through a catch block, then we would execute the statements which are written inside the catch block. Any kind of statements can be written inside the catch block, not necessarily System.out.exception  What would happen, if I did not write the catch block  This procedure simulate meeting, would throw the exception to the point from where its parent procedure was called. When StomachAcheException throws an exception, the TA.eatpizza () method would also throw an exception, then the control will go to procedure from where simulate meeting is called. It is fine if it catches the exception at that point, if not it will throw an exception to the high level procedure and finally your procedure will stop with your exception appearing at your console.  In this manner it is getting propagated all the way up to, where your procedure stops and the exception is shown to the user. System.out.println is just the method to print the statement.  An exception is really a java class in which I am creating an object or an instance for this class. Then I am initializing that instance with any parameter and I can specify some set of parameters in the statement given below. StomachAcheException ( Ouch ); StomachAcheException itself is a class and for this class, I am creating an object by making a call to the statement. StomachAcheException ( Ouch ); When the catch statement is caught, e in that statement would get assigned to the object that is created by StomachAcheException ( Ouch ) statement. The try and catch block would come together. If the method were not enclosed between try and catch, then the exception would just get propagate upwards in the procedural hierarchy. StomachAcheException would throw an exception and the calling procedure of simulate Meeting would throw an exception, till it is caught at some point. If not it reaches the console. What does the name of the class followed by brackets and some parameters written would signify in java  For example: StomachAcheException ( Ouch ); In java it signifies, that you are creating an object for this class and you are invoking the constructor method with  Ouch  as the parameters. The try and catch block are a method for listening exceptions and catching them. As I mentioned before, a catch block can contain anything. It does not mean that it should have only system.out.println, it can also throw an exception in turn.  It also helps us to exit from the program when an exception occurs. If you throw an exception in any method, then you need to add a throws class next to the method name. When we wrote the method eatPizza () we had, throws StomachAcheException. A method can throw more than one exception. In java everything is really an object. StomachAcheException is the name of the class. Public class StomachAcheException extends And the statement given below is the constructor method for the class. Thus the name of the constructor method is the same as the class name. Public StomachAcheException (string err) The constructor method takes a single parameter, which is a string. Super means that it is calling the super class with the same parameter.Again as I mentioned before, if you never catch an exception it will propagate upwards, along with the chain of method calls, till it reaches the console. Since the stomach ache exception is extending a run time exception, it will call the constructor method for the run time exception.  If a particular method throws more than one exception, then you will have to specify all those exceptions which it throws, next to the method name. Even in the try block you can have many catch statements. First we can catch one particular exception followed by some other exception and so on. Look at your java book for more details.  Let us look at the stacks. We had created the interface for our stack. We are going to implement the methods and there are many ways of implementing a stack. First we are going to implement using an array. Let us say the maximum size of our stack is N and I am going to have an array of n elements of the stack. I am going to have a variable t, which will tell about the location of the top element of the stack. The variable t gives the index of the top element in the array S. The first element will be at location 0 and then when I push another element it will move to the next location and so on. (Refer Slide Time: 29:43) I have actually listed out an entire implementation for our stack interface. My implementation is called array stack because I am using an array to implement the stack. The statement mentioned below says that I am implementing the stack interface. Public class ArrayStack implements Stack Implement stack means, it is implementing the stack interface that we provided. I have set with a default capacity for the stack which is 1024, otherwise the capacity of the stack would be in the variable N. Final is just specifying that the value of capacity is always a constant and it can never be changed. (Refer Slide Time: 30:48) S is an array which is going to hold the elements of the stack. Thus S is an array of object and t is the index of the top element. Initially t =-1, because there is nothing inside the t. t=0 means the top element is in the location 0 and when the stack is empty t =-1. Public ArrayStack () Public ArrayStack (int cap) The above two statements are the constructor methods. If you do not specify anything or if you just call the array stack without any parameters, then I am going to create a stack whose capacity is 1024. If you call array stack with some number let us say 37, then I am going to create a stack of size 37. What should size do  Size should just return how many elements are there in my stack. If t is the index of the top element, then t+1 elements are there because we just started from zero. The stack is empty if t =-1 that is t
