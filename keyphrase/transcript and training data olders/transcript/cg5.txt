okay we have basically talking about clipping right so we covered polygon point clipping and then we talked about line clipping right so today we are going to talk about polygon clipping right so let me just give you the kinds of polygons which (Refer Slide time 1:21 min)



which actually are interested to us right so basically we are looking at simple polygon right so what do i mean by simple polygon its basically a planner set of a ordered points let say V one V two V three to Vn right and i do not want lines to grasp for the polygon right and also i do not want any whole in that polygon so thats what i call it as a simple polygon right here you see the example so this is a example of a simple polygon it could be convex it could be non convex right so the restriction we are passing here is that we should not have a line crossing right just the weight is happening here V one V two V three V four and there is a crossing of the line and there should not be any whole here right so given that i consider a simple polygon and the reason iam interested in a polygon because they are area primitives where i can define primitives filling area right and one thing if we are talking about is that can we extend the notion of clipping for the line right to the polygon if you just consider just the polygon to be defined as collection of lines each of the edge being aligned then all i need to do is process the line of the polygon right one by one and do the line clipping right lets see whether we can extends these idea so just to further illustrate a difference between convex and non convex (Refer Slide time 3:30 min)



that we have earlier also seen so there is this convex polygon where if i join two points with in the region right the line is inside that region thats what i mean by convex polygon where as a non convex or concave sometimes referred as if i joints two points which are inside the polygon right the line joining these two points may not be inside the polygon right this is non convex so now lets try to see what is the restriction for the time being we want to impose on the given polygon we are interested in to clip right and the window against which we are going to perform this clipping right as for as the given polygon is concerned we are taking a simple polygon convex or non convex right whereas there is a restriction to the window which we want to use it for clipping (Refer Slide time 4:52 min)



right we would actually work on a window which is convex right so we have this restriction and the window must be convex but the polygon could be convex or not right here is the example here we have this window just for the simplicity i have consider here the window to be just a rectangular region right which is convex and here you see a polygon which is non convex right where as here i have the polygon which is the triangle its a convex problem right what are we trying to do as a process of clipping we are interested in getting this portion of the polygon and this portion of the polygon inside the window and reject or discard the rest right similarly iam interested in getting this part of the polygon to be declared inside the window and chop of the rest right thats what i mean by clipping polygon against this way (Refer Slide time 6:10 min)



right that is basically what is shown here right so after the process of clipping i got this is the result for this polygon right similarly for the second case where i consider triangle to be clipped the result is this right so now looking back to what we have done in the case of line clipping can you suggest an algorithm to do this so you know what the operation is right what is happening right what is the result which we are expecting so is there a suggestion towards an algorithm which could use what we have seen in line clipping i see okay see remember one thing that for instance sires back algorithm or lanbask algorithm basically got an exception that its a convex window right the non convexity of the window was sort of a special case which was always treated in a similar way right we always had the clipping against the convex region right so what this convexity gives you a some sort of a notion of each edge of the convex window to be a sort of a clipper right deciding whether it is inside or one side of that edge or not that is what i mean by saying it a clipper so may be we can apply a similar concept where the edge of the window acts like a clipper right and then we perform that operation of clipping right considering each edge of the window so therefore each edge acts as a clipper right so let me just demonstrate here an example so i consider let say a non convex polygon (Refer Slide time 8:36 min)


	 
to be clipped against this rectangular window right this is an example now what i do is now i consider one of the edges of the window to be a clipper clipper means i apply the clipping against that edge right and i have this notion defined to the edge that which is inside and which is outside in a very similar fashion as we are saying in the case of line clipping right so thats what i mean (Refer Slide time 9:13 min)



so i define this clipper right which is the right edge may be left as you see it on the screen right so this is my clipper now what i do is i basically take this polygon use this as my clipper and discard whatever is outside this right so this portion is the outside potion of this clipper and this portion is the inside portion of the clipper right so basically i chop of right just slice it by this clipper the polygon right and this is what i get as a result right this is my resulting polygon after having clipped against the edge now i can apply this operation in succession for all edges from the window right thats what will happen (Refer Slide time 10:19 min)



 i take that an input whatever was given after the first clipper and apply again this edge now right this chops of this part of the polygon and so on right (Refer Slide time 10:36 min)



that chops of the left part of the polygon and this is the top edge(Refer Slide time 10:43 min)



right so at the end of this considering each edge of the window as a clipper at the end of this full operation i get this polygon which is the clipped polygon right and thats what i need right so now lets try to see what i illustrated you through this diagram as an approach (Refer Slide time 11:11 min)



so what iam try to do as an algorithm right so what i said is that i consider polygon to be clipped given as series of points right ordered points taken in a one particular order as V one V two to Vn right and a polygon edge is basically a pair define between vi vi plus one right and since polygon is the close figure right i need to consider the last as to be vn v one so there is a rapper up right from the sequence i have the points right so now what iam saying is that process all the polygon edges right in succession against the window edge so what it does basically if i consider V one V two Vn as the polygon the input polygon and the respective pairs of this Vis defining the edges what i get is a new set of points define by W one W two to W n which gives me the new polygon right and then I repeat this process against the next window edge right when i have exhausted all the window i just whatever i get is my resulting polygon right so what are we basically doing here we are trying to output certain number of points right as a process of clipping each edge of the polygon against a window edge right so in fact because what we are doing is basically create a new set of points which are referred here as Ws right there are just the new set of points so if we try to see actually there happens four cases and before i take about those four cases which would (Refer Slide time 13:43 min)



output zero point one point or two point right after performing a clipping of an edge of the polygon against the window edge right actually happen to recovered by four cases so if i do a case analysis of those four cases i would know what points are going to be given as output which will then be included in my series of points of w s to define a new polygon right so let say i consider s which is given as Vi to be the starting vertex of the polygon edge right and this s could have been previously analyzed right this could have been analyzed in the previous iterations right but for the current edge s is iam considering as vi right and p is which is the next point for the edge pair vi plus one is the ending point or ending vertex of the intersection now i define i which may result from the polygon edge and window edge intersection and there could be a intersection of this polygon edge with the window edge and as a result i may get point of intersection which i define as i so this i should not be confuse with the subscript i here and this is a point of intersection okay and then what iam going to have this point wj which i will declare as the output from the case analysis iam going to perform right and at the end the collection of this w s will form the polygon of my interest right now lets try to see each of this four cases right which would intend give me either no output right zero point or one output or two output right two points for the output okay (Refer Slide time 16:22 min)



now let us see the case one so case one i define it as remember polygon is basically as a cyclic kind of a shape right it is a close shape so let say i have a case where the polygon edge is entirely inside the window edge right so what do you i mean here by this let say this is my window edge drawn in blue right and i have this notion of what is inside and what is outside with respect to this window edge right and now considering this edge which is given as S P that is my polygon edge in question right so having S as the start point and P as the end point right and this edge could actually be related to the rest of the polygon in some fashion right so now what we are going to look at is just analyze these two end points S and P for this particular polygon edge right so if i observe that the polygon edge is entirely on inside side of the window edge that means this is the situation right then i output P right so P is the next word test of the resulting polygon meaning i assign P to the Wj right and iam increment j in the series of the points which iam going to use for defining why output polygon right so in this case i have the output given as P only one output right when both this two points are inside the window edge the next case is (Refer Slide time 18:28 min)



when i see that polygon edge crosses window edge going out right going out means it has actually going from inside to outside right so this is the sinerio i have this edge S P which is going from inside to outside right so clearly when i cross the window edge is going to have an intersection with the window edge right so i find out this point of intersection i right and that is what my output is right i output i so therefore i assign this i to the W j and i increment j right so in this case also i get one output for the point which is i right now the next case is (Refer Slide time 19:38 min)



at the polygon edge is entirely outside the window edge right so S and P happen to be outside the window edge then i give no output that means no point is given as output for the polygon right so the last case which is left is this (Refer Slide time 20:07 min)



when the polygon edge crosses window edge going in that means i have this edge from outside to inside that means S is outside the window edge and P is inside the window edge right thus is the sinerio i have so clearly i have a point of intersection of this edge with the window edge right which is given by i again then in this case i would output this i and P these are two output now i have right i output i and P as the two vertices of the polygon so that basically means that assign i to Wj P to Wj plus one and j is incremented by two right so now lets try to see this on an example and in that will give you a better picture right so all we are saying is that when i when i make this polygon as a collection of my vertices Wi s right then how do you i give the sequence of this points right so right i always have a definition of my polygon right i go in order basically right is just not collection of a sorted points if i go in an order of this points i get a polygon thus the whole exercise we are trying to address okay let me take this example by the way this algorithm which iam trying to explain is called as sutherland hodgman algorithm okay where we consider the window to be convex and polygon to be any polygon any simple polygon okay so now i take an example here (Refer Slide time 22:23 min)



so now i take an example here where i consider a non convex polygon right S one S two S three S four S five these are the vertices of the polygon and again i consider the window to be a rectangular region right so remember this has no restriction to be a rectangular it could be any convex region right because the way we are performing the operation of inside outside doesnt really restrict as to have a rectangular region right as long as we have the region to be convex fine now so what i said is that let say S one is the point to start right that is the first point i have in that definition of my polygon right and all we are trying to do here is do this clipping for each of the window edges right and we analyze this cases four of them and output appropriately the points to be considered as the polygon for the next iteration right thats what we are trying to do so gives this as a input polygon let see how it proceed (Refer Slide time 23:44 min)


and i  consider let say this is my first clipper the top edge of the window right this is my first clipping now so what will happen is that if i consider from S one to S two right i go from outside to inside right totally inside because iam not considering with respect to the window right iam basically considering with respect to the edge so this remember this outside inside operation is with respect to that window right so i go from S one to S two which are both inside right so when i have inside to inside i output t which will be S two then i go from S two to S three again both happen to be inside the window edge right then i output S three i go from S three to S four right i go from inside to outside and i find a point of intersection which is i one right so i output i one when i go from S four to S five both happen to be outside the window edge i output nothing right and then and then i go from S five to S one i find the point of intersection is i two right so i output i two and S one right what do i get us the resulting (Refer Slide time 25:23 min)



polygon is this so i just change the S to t now and basically change the suffixes right this becomes t one t two t three t four t five right so this becomes my polygon for the next window edge to be consider right now what happens just respect to this window edge all the points are inside right so if i start from t one to t two i will output t two t two to t three i will output t three and so on right so that is (Refer Slide time 26:07 min)



what i will get as a sequence u so one again i change from t to u and change the respective suffixes right you want to u two u three and u four and u five right again if i consider this window edge right all points are inside therefore nothing really changes with respect to this vertices except that the numbering changes the enumeration changes right so when i say u one to u two will be given as the output so i will start from here right so now thats what happens i (Refer Slide time 26:49 min)



get the output as V one V two V three V four V five right now this is my last window edge right here some interesting things are happening so i start from V one to V two right which is from inside to outside i find the point of intersection i three right so when i go from inside to outside i basically output i three right when i go from V two to V three both are outside i output nothing i go from V three to V four which is from outside to inside right i find this point of intersection as i four right and i output i four and V four right and when i go from V four to V five again i go from inside to outside i find this point of intersection i five and i output i five when i go from V five to V one i go from outside to inside find the point of intersection as i six and i output i six and V one and that complete the whole all the points right so at the end of these i get my polygon as this (Refer Slide time 28:22 min)



right W one W two W three W four W five W six and that is my resulting clipped polygon right is this clear the algorithm is fairly straight forward right and the idea which we actually has used in the case of the line clipping is being reused it right so this inside outside thing now one may say that you know this is not really a good polygon for various reasons right because if i consider one single polygon where i have this these two point lying on the same points this sort of a degeneration right particular it can cause problem when i do the shading of the polygon right 

so there is also a modification to this algorithm where in instead of having output given as this as a single polygon sequence of W points they have the notion of segmenting the polygons right where in actually you get this as one polygon and this as another polygon right so there is a fragmentation but that fragmentation is actually requires much more book keeping right in order to able to define this fragments right right we will look at that algorithm when we talk about hidden surface elimination because that is inconjection with hidden surface elimination and the algorithm is given by weiler and athreton to modify this southern sutherland hodgman algorithm where you do not have degenerate polygon right so that we will see later on okay now that since we have been talking about polygon right lets try to see how do we draw this polygons right we have basically looked at drawing algorithms for lines drawing algorithm for circle ellipse right but we havent really looked at drawing of a polygon well one may say that polygon drawing basically a line drawing because if i just define polygon to be a sustains set of connected points through this edges then all iam saying is that consider each edge and do a plot of each edge right using line drawing right but i then do not get the feeling of that polygon to be an area right because i need to fill that with some color or with some other display attributes right so a so you like to see some sort of a drawing algorithm where i can fill this polygon with some color right okay so and just a collection of line drawing doing the polygon edges for drawing is actually also known as some sort of a wire frame display of the polygon right here we are trying to address the polygon display using filling right so thats what we call it as the scan conversion of the polygon right each of the pixels of the polygon are basically getting converted into some value right so now polygon scan conversion (Refer Slide time 32:32 min)



as i said is basically for drawing polygons using filling right now if i consider a simplest polygon which is triangular right here actually you see the examples of filled polygons so this is a filled triangle now if i if iam able to let say design an algorithm for filling it a triangle right then i can actually use that even for that other polygons because i can decompose a polygon into set of times so thats what is shown here irrespective whether a polygon is convex or non convex right then i can just replicate my triangle filling algorithm right so lets try to see this if iam interested only in the filling algorithm for a triangle okay what are you trying to say here (Refer Slide time 33:37 min)



you trying to say that here is the pixel right here is the pixel which is inside the triangle and if i figure out that this pixel is inside then i can assign the desired attributes of color or any other display attribute to this pixel right so the question iam basically asking is whether this pixel is inside that triangle or not right in other words is a matter of doing a containment test of points or the pixels right so whatever is contain in the triangle i just give the necessary attributes of this plane right so now the question of whether a point is inside or outside a triangle can be well taken care of by what we have seen earlier right if i define let say these normal to this these edges of the triangle right then its a matter of inside outside of this edges and if i get the answer that with respect to all the edges it terms out to be inside then i know that the point is inside the triangle right therefore i can give the color to that pixel and if i find that point it is outside the triangle i just discard it right but clearly that has a problem of i cannot start with all pixels in this screen (question) right so what what he is saying is that you basically bound your area right by considering the minmax of the points of the triangle and then so create a virtual window around it right and do the scan conversion of that window is that what you suggesting right yah so thats what preciously you are going to look at so basically we are looking at some sort of a extend (Refer Slide time 36:06 min)



right which is defined around that triangle right and this sort of also explode the fact that this scans scans are horizontal right so we go let say one scan line by one scan line right and then so we sort of exploit this property right which is in some sense a coherence along the scan line right because if i find that a two extremes of that scan line happen to be inside the triangle then all the point which are spanned with that scan line can be colored so right what it turn what in turn it means that if i find out an extend here which i define it as xl for a particular scan line so when i referred to scan line its a basically a horizontal line with respect to the window which iam trying to scan convert around this triangle right so for this particular scan line i find out this xl and xr right which could be just the intersection of this scan line with respect to this edge and this edge right and then once i find out this xl and xr then all the points here can be colored so this is particularly useful when i just need to assign a one color to all the points right 

so now another thing is that so one scan line i can cover like this right so the next question is i go to the next scan line what do i mean be next scan line means go vertically down right so from here i come to this scan line somewhere right now one may say that find out the point of intersection explicitly with respect to this edge and the other edge this edge and do the same thing that could turn out to be an expansive thing so what we can do is we can exploid the knowledge of the edge slope right the edge slope can actually give me the next point here right remember we have actually used that knowledge while doing line drawing bresenharms or midpoing algorithm that preciously what it does right so i actually get the next point for the next scan line right using the slope of this edge similarly i can get this point using the slope of this edge right and once i have this two extremes the rest is done right the only thing is that this particular point i will need to change the edge right so here i was considering this edge right now it basically between this edge and this edge but that is also simple right all iam doing is going scan by scan finding out the two extremes in the horizontal span right and fill them and for the next horizontal span i use the information from edge slopes right how do we get the first scan line yah so that is the initial computation  which you will have to do so may be the best thing is us he was suggesting at get a window around this right which is like finding out the minmax of this area right

so thats gives you the window you start at the top of the window right now the question is well one one thing for the general polygon is to use this triangle filling algorithm by decomposing that polygon into various triangle right and apply to each of those triangle but let say can we design an algorithm for a general polygon simple polygon general simple polygon convex or non convex see the the the question which we are trying to answer is always the containment so right let me close the problem here (Refer Slide time 41:29 min)



i have now this polygon right which is non convex polygon and this is let say the current scan line in question right and all iam trying to answer the question is what are the pixels intercepted by this pixels by this scan line or inside this polygon the moment i answer that question i have my filling algorithm right so now given this sinerio can i device some algorithm saying that what are the points which are inside the polygon and what are the point outside the polygon okay so you basically do all checks right thats what that you are suggesting may be that can be avoided so let say iam able to find this points of intersections right this point of intersection of the this scan line with the edges are known to me right now so what we are here observe here is that this part is to be filled this part is not to be filled this part is to be filled right (question) right right in some sense basically it is actually a parity check right what we are saying is that if i find the segments so all we are saying is that find out the segments right this is one segment this is another segment this is another segment right right so if i do a parity check then all iam saying is that if the segment is odd fill it the segment is even dont fill it simple right so that even holds when i have a convex reason doesnt say anything because iam going to get only one thats odd right but does it work always (Refer Slide time 44:26 min)



what happens here so there are special cases right because if i just apply the same parity check then iam going to display only this part and not this right okay now what happens here (Refer Slide time 44:58 min)



so let say i go back to this and i actually give you a modification to the algorithm that in such situation you duplicate this point right duplicate this point means i have basically virtually added a segment there right so then what will happen is this will become one this is second right there i dont draw that and this becomes third and i draw that right so what iam suggesting is that whenever you have the intersection with a vertex for the polygon duplicated well does it work always what happens here so this is duplicated i dont plot at this point but i plot this this not inside it doesnt quite work yah there has to be some topological issue here right is not just that i duplicate the vertex right so one way i can look at is that if the vertex in question is either a minimum or a maximum vertex of the incident edges on that point then i duplicate right and if yah let let me repeated so let go back to this case right so here this vertex is a minimum vertex right minimum in terms of when i say y of that is minimum with respect to the two instant edges at this point this and this right

so here i duplicate here what happens is that there are this edge and this edge right for this case it is the minimum for this case it is the maximum therefore i do not duplicate right is that okay so when it intersects to a vertex of the polygon i need to do this extra checking right but the rest of this is just the same right i just label the segments to be drawn or not to be drawn right okay now there is a another sort of a way to look at the filling problem right what are we trying to do basically when we fill the polygon we basically look at the pixels which are inside a polygon right and if i can some percents some way grow that point using the neighborhood information around that point and ask that question to the neighbors right and propagate that then also i will do the filling right and the propagation is basically constrain by the boundary line boundary edges of the region right so there is a (Refer Slide time 49:07 min)



there is an example where i have a let say this polygon and the black points are showing basically the boundary of the polygon right i get this seat which is plotted here as the pink point here right so once i establish at this point is inside then i consider the neighborhood of this point right so neighborhood could be in different ways here iam talking about the left and the right neighbor the bottom and the top neighbor or the low and the up neighbor right so this is sort of we call it as four neighbors of the point and you can also consider eight neighbor if you consider the diagonal pixels around right so all iam trying to so is get these neighbors and ask this question whether it is inside or outside 

right and then in tern get the neighbors for these points and just keep growing right so those of you who have done image processing must have seen a similar thing right its a pixel aggregation or a region  growing which is used for segmentation right because there what we are doing is this boundary is actually given by certain futures of the image or the segment right and within that boundary everything is homogenous similar right so those pixel attributes within that segment are very similar right all iam trying to do there is find out the connected pixel to the seat right and keep growing that region till i hit the boundary is preciously that right so so see again we can actually use certain information from the pixel itself for instance if i found out this pixel is inside right and so the the explicit check which i will do for the inside outside right i may actually restrict to only part of the boundaries not all the edges of the boundary right so i can actually add more information to the point knowing that where this point is right so computationally yes may be more costly what we have done earlier but this shows you a different way of thinking actually doing a filling right but a in a different thought thats a different thought right okay lets stop here and next time we will look at some other issues which where there in the rendering pipeline so what we have done is basically the extreme end of the rendering pipeline right which is the raster graphics and the clipping then we will go now for the further steps in the pipeline which are transformations another issues right thank you

Transcriptor name: Karthick.D
Proof reader name:

