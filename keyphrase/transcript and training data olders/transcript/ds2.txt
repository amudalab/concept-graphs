





todays class we will talking about stacks um

mainly about stacks besides that we will also we talking about abstract data types interfaces and exceptions how stacks are implemented in java 
application one application to the analysis of time series  will talk about global stacks do little bit of mortise analysis and then talk about stacks in java virtual machines 





okay whats an abstract data type 
so its basically a specification of what the instances are and 

what are the set of axioms that define this semantics of the operations on those instances 
so what do i mean all of these 
so you know data types for instances you know integer this right and you know real numbers and so on 
so when we talk of two integers and we say addition so you understand the notion of addition that's the same way as you add two integers in math right 
so here similarly we ill define 



data types in this course and we will define certain operations on those data types 
and those operations would be defined through what is called an interface 


which is basically giving us what is called the signature of the operation what are the parameters that the operation required and so on 
and then we will also specify what are the results of those operations through a set of axioms 


yeah just as in the case of integers you know the sum of two integers is as this is defined in math 
so a plus b if you add n variable of type a n variable of type b and you sum them up then you get the same answer as you would you know in in your in your mathematic class 
so we ill see an example all of this perhaps that will clearer then the kind of operations that you have been talking about

are essentially of three kind its one would be just a constructor operation
so this is the same as the constructor method in java right 

you can using this method using this operation you can create an instance of that particular data type yeah 
when your talking about sophisticated data types this method will have to do lot of work 
access functions 
functions which let us access elements of the data type and manipulation procedure which would let us manipulate or modify the data type yeah 


so why we are talking about data types here 
data types help us identify what are the requirements 
what are the building blocks of our algorithmic procedure and what are the requirements out of those building blocks 
its provides a language which will help us talk at higher level of  abstraction right 



we can talk in terms of just we talking of in terms of integer adding to integers we can talk in terms of may be stacks or queues or any of the advanced data type that would be discuss in this course 
they encapsulate the data structure which is how the data is organized and the algorithms that work on that data structures they encapsulate that right 
and they help us separate the issues of correctness and efficiency

and we will see more of this as as i show you the example of data types 
so let me give you start by giving  a simple example  of the data type that's a dynamic set yeah 
so you know a set as as defined in in your high school classes right
it's a collection of objects and suppose we also add operations which would let us modify that collection of  objects which means add an object to the collection remove an object to that collection 
so such a set we would called dynamic set 




dynamic because we are changing the set right we are changing the collection of objects and we will create data types for such dynamic sets right 
so what are the kind of methods you would

have an dynamic set 
so you would have method to create dynamic set that would be a method new that would be the methods the new 
they would be a method insert to insert an element in to dynamic set 
so s is the dynamic set and this method has two parameters
let say the set s and the element and it gives as the result  an instance of the set itself it gives as result 
a new set another set which now includes the element v in it 
similarly this gives removes the element v from the set s right
so these are two methods for updating the set 
this is the method for creating constructing in the set and this is the method one of the access method 
all it is telling us is whether this element is in the set or not 
so the result of this method the return value is of type Boolean 
if v is in the set then its say true otherwise false 
okay 




and i say about talked about axioms which define the which tell us how these operations should behave 
we could write axioms in the following form right
so when i create a new set and i ask you is we in the new set 
when i create a new set its empty is nothing in the set right 
so the answer to the should always be false 
no matter what v is yeah 
if i have a dynamic set s and i insert an element v in it 
now this resulting set has v in it 
so if i asked whether this set has v in it 
then the answer should um to be true 
if i have a set s and i insert u in it 
then this resulting set now has u in it 
now if i have to ask whether v is in the set 
then what can i say 
v is in this in this resulting set if an only v was in the previous set 
was in the set  s  
so the answer to this operation should be the same as the answer to this operation yeah provided v is different from u yeah 
suppose i have a set s and i  delete v from it and now i asked you whether in this resulting set is present then the answer should be false yeah 
so these are some basic axioms that you can define which tell how the these operations should what is the nature of these operations what is the behavior functionality of these operations 
yeah here we are not yet specified yet how we are going to do these operations 
we are not talked about of an algorithm procedure any such thing 
least of all we talked of any code for how we are going to implement the dynamic set right
when you talking abstract data types we are not interested in we are interested in more of this specification
what the instances would be like and what would be  the operations would be permitted on those instances 
what would be the what would be the axioms that govern those operations that dictate that tell us what the operations are doing okay




some simple abstract data type that your perhaps familiar with  are queues 
i don't know whether you know  queues but we will be doing later in the course stacks and stacks is what we will be doing today



okay so skip to stacks then 
so what is the stack its again the collection of elements but now this collection follows what is called the last in first out principle what this means is that the element which is inserted last would be the first to be removed 
if i insert an element and then i say remove an element from this collection then the element that would be removed was the one which was inserted the last 
so the operation of inserting an element is called pushing in the operation of removing an element is also called popping the stack 



right and 

some of you might have seen this kind of  toys
so this just has collection of elements so this could also be for instance stack of trays in your in your mess 
so what you would do when you put a stack a tray put it on the top and when you remove it 




you would always remove the one which is at the top so when you remove an element when you pop of an element is always the one which you insert at the last yeah 
okay so this abstract data type we are going to define it 

using it is supported with this four methods 
these are the key methods 
so new is a method to create a stack push 
when i specify an element o push adds this element o to this abstract data type 
it inserts object o on to the top of the stack 
pop pop is not taking any parameter other than abstract data type right 
it just taking the stack as the parameter and says when i say pop the stack it just says remove the  top element from the stack 
if the stack is empty then they should flag an error 
they should say that the stack is empty okay 
the top operation returns the top element 
it does not remove it 
that's how it differs from push um that's how it differ from pop pop also removes that element top only tell us the top element yeah again if the stack is empty then top doesnt not making any sense 
so it should flag an error 



we can also have some support methods that which well help us do these operation 
so size is one such method 
so size tells me how many elements there in the stack and is empty tells me whether the stack is empty or not yeah 
so everyone understand what six methods are so we talked of push pop new top size and is empty yeah 
so these are the methods understand what these methods are doing and these are the axioms which govern behavior of these methods right 
so if s is the stack when push an element on to s and then a pop there is a stack what should i get the element that i have pushed no um okay
when i pop i should get back s okay if i do a top operation now when i push an element we on to a stack and do a top i should get v because v would be the top element of the stack 


so this is  far as the abstract data type 
so we have define 




what the stack abstract data type we have define the methods we define two axioms may be they are not complete but this this axioms would look like yeah 
now suppose we want to translate that into code what do we do 
how do we translate abstract data type into code

so for that we need  two construct many of  might be familiar with this already machine of interfaces and exceptions right 
and so what is an interface an interface is a way to declare what a class is to do what are the various methods asscoaited with the class 
it doesn't tell us how those methods are done right that would be part of the implementation of that interface implementation of that class 
right
so for an interface we just slight down the various names of the methods and the parameters of those methods going to be take 
in fact we don't even specify the  names of parameter we just specify the types of parameter yeah 
when we write a class for an that interface we will actually provide the code for those various methods right
i might specify an interface for for an stack 




i am going to do that in a short while yeah and i am going to ask you to write implement that interface right write the classes for that interface 
so two of you could write different classes you know you might implement the interface in completely different ways 
but i can still use your classes your implementation provided the meet the specification provide the meet the interface specification i have given you yeah 
and i can use that use your classes in a program that i have written or i can use any class any implementation of that interface in a program that i have written provided that implementation stick to that interface 
so all i need to know is that this implementation meets this specification meets the interface i can use that my in my coding in my own program 
so it helps us separate the implementation from the specification that's why its very useful programming technique 





so lets see what is stack implementation look like in java right 
so java has a built in stack data structure but nevertheless we will define a stack interface here 
and  as i said we just define the various method that are going to be part of these interface 
so there is one method called size all i need to do is specify the types of the parameters and the return type of the method and stuff like that yeah nothing more 
i am not specified i have not given here  how this methods are actually implemented this is just an interface  so your question is whether in an interface we need to know the type of   
so we need to know the types of the parameter yes as you see here 
so when i am pushing it takes a parameter of type object right 
object is this generic type in java 
all objects are derived from this type okay 
for instance the method is empty returns boolean right 
just tells us whether stack is empty or not  
recall the top gives you the top element in the stack so it returns an it returns an object and we also have this some through stack empty exception 
so we said if this stack is empty then this method should some how signal that right 
and we are going to do that using the notion of exceptions and  i come to that in  a 
minute





okay what is an exception exception is an another 
void means it doesn't um return it doesn't return any any object or any value  right 
so it doesn't it doesn't return a stack it is it is a method which is executed on this stack 
it modifies the stack [ basically don't consider stack as a parameter
you don't consider stack as a parameter here exactly 





okay exceptions are mechanisms to handle errors 
so when we have an error 
so when we reach some exceptional




conditional or exceptional case  in the execution of program we throw 
so the java term is throw with throw an exception 
so as soon as an exception is thrown the flow of control moves from 

the current method to the method to the point where the method was called okay 
ill soon show an example of this 
the idea essentially is that when an exception occurs when something exceptional happens you delegate the responsibility of handling that exceptional case upwards 
you delegate responsibility of handling that problem of that error to the procedure which called this particular method okay 





you see my example of that will be clear okay 
i have two methods here one is an eat pizza method which throws a stomachache exception right 
so there is some code here there some dot coded here 
so if you ate too much pizza then there is a problem and so you throw stomachache exception 
this procedure eatpizza was called here in the stimulate meeting procedure 
so here i called this method eatpizza yeah 
so when this exception is thrown the flow of control come to this point yeah okay 
so when this exception is thrown we will exist this method eatpizza and go to this point  



 not it would not executed if there were question is if there were other statement after this and there are other statements here 
i am not sure all the statement these dot dot dot means there are bunch of statements 
they would not executed 
the flow of control would interrupt this point and would now reach here okay 
there is also a notion of try and catch blocks    
so it depends your question is that when a  exception is thrown what happens to the variable that we have modified here right 

now again it depends upon its like a procedure call right when you return from a procedure think of it you returning from this procedure here and returning from this method 
so if those variables locals variables then you don't see them here 
if there were global variables then if there were modified here those modification get carried away over at this point right 
there is something called a try and a catch block here 
so if you thought that there could be possible exception in this method then you enclose the method within a try block 
so try bracket whatever whatever method you calling those bracket 
if there was no exception that was raised in here or if this exception if this particular exception did not get raised in this method then we will just skip this catch block and go on to the statement after the catch block which means something here 
but if an exception was raised in this method in particular this this exception was raised in this method  because this method might raise many exceptions right 
if this exception was raised in this method then we would come in to this catch block and execute the statements 
let you follow them what i am trying to say right 




if the method raises an exception then if that exception is getting caught here through a catch block then we would do whatever is return in this um execute whatever statements 
return here what are the statements return here you could have any kind of  you don't necessary to have system a dot out exception  



so here is the slide here we have right to explain in this  yeah 
so your question is if i did not write this catch block at all 
if i didn't not write this catch block what would have happen 
so what would have happen then is that this procedure simulate meeting now would throw the exception to its parent procedure wherever it was getting called from 
so when this thrown an exception this will also throw an exception 
the control will go to where simulate meeting was called from if that that point i am catching this 




exception fine if not it will throw an exception to the high level procedure so on and finally you procedure will stop with your exception finally appearing at your console 
right  in this manner keep getting propagated up all the way till your procedure stops and the exception is then shown to the user 

this is just the method to print out the statement 
oh so an exception can um an exception so we will see that at next slide 
an exception is really a 


java class right and by doing this i am creating an object of 

and i am creating an instance of this class and i am initializing that instance with any parameter that might be specified here 
so i can specify some set of parameters here right
so stomachache exception itself is a class and i am creating an object by um making this call creating an object of this class  um yeah when i when this is caught this e would get assign um the object that is created by this statement 



 now again it will be moved up to the calling procedure  yeah
so actually yeah if if it was not enclosed in a try 
25.13
so this try and catch come together right
if you had not enclosed in a try at all then it would you know that exception would just get propagate upward move upward in the in the procedural hierarchyright 
so if this you know there was an a this exception was thrown then this procedure would throw an exception an its calling procedure would throw an exception till it get caught at some point 
if it does not reach the console  




that signifies creating an object 

so your question is name of the class followed by brackets and some parameters written here what is the signifying java 
in java that signifies that your creating an object of this kind of this class your invoking the constructor method  for this class with these as the parameters 


okay 


i have just put down on side the try and catch block are a method of listening for exceptions catching them 
so as a mention before catch block contain anything it does not have a system dot out dot printline  
it can also threw an exception in turn  



but it can also do other things to help you gracefully exit from the program when an exception has happen 
so if you throw an exception in any method then you need to add a throws class when next to the method name 
as we did on one of the previous slides right when
we wrote the method epizza we had throws this exception  yes proc a method can more than one exception  
i come to that on this point slide right 
so when you defining a stomachache exception what is the stomach 
so in java everything is really an object right 
so stomach ache exception here is the name of the class okay and this is the constructor method for the  class right recall the name of the constructor  method is the same as the name of the class 
so that the constructor method here is taking a single parameter which is the string yeah and what does super mean 
 its calling the super class with this same  with this parameter 

so  again i mention before if you never catch an exception it will propagate upwards along the chain of methods called till it reaches the console 
any questions it calls the constructor of parent class 






the class from which class this classes is getting derived 

the since the stomach ache exception is a extending run time exception it will called the constructor method for the run time exception 




i think i am going to pass that question because that it seems that you need to understand little bit more java  before right 
so will not take this question here yeah  yes
so if particular methods throw more than one exception

then you will have to specify all those various exceptions it can throw next to the name of the method yeah 
and then even in the try block you can have many catch statement 
we can have catch this exception followed by catch some other exception followed by catch third exception and so on
we need to look at your java book for these things 



so now we get back to our stacks so we had created the interface for us stack 
yeah now we are going to implement methods and they can be many ways of implementing a stack and the first we are going to discuss here 
is using in array 
so i am going to have an array lets say the maximum size of our stack is capital n 
so i am going to have an array of an n elements 
this is going to contain in the element this array is going to hold the elements would stack and i am going to have variable t which will tell me were the top element of the stack  yeah 
so t gives me the index of the top element in the array s 
so the first element will come at location zero when i push another element it will come here push another element will come here and so on 



so here i have actually listed out an entire implementation for for our stack interface
so my implementation is called array stack because i am using n array to implement the stack 
and this statement says that implementing the stack interface is by saying array stack implement stack  




by implement stack means it is in implementing the stack interface we provide earlier 
and i  set a default capacity for this stack which is let say thousand twenty four otherwise the capacity of the stack would be

in this variable n  final is just specifying this is a constant which is value never can be changed right 





s is declared to be s is that array which is going to hold the elements of stack 

so s is an array of an object and t is the index of the top element   
so t is the initially minus one because there is nothing inside right t equals zero means 




the top element is that location zero 
when the stack is empty t is minus one right 
and these are two constructor methods if you don't specify anything 

if you just call array stack without any parameters then i am going to create a stack whose capacity are thousand twenty four and if you call array stack with some number lets say thirty seven then i am going to create a stack of size thirty seven 



okay now given this the method should be very easy right
so what should size is do so size should return how many elements are their in my stack 
so if t is the index of the top element then how many elements are there t plus one because we just started from zero 
so if you want to know whether the stack is empty the stack is empty if t is minus one less than zero  
so if t is less than zero then stack is empty 
so if t is less than zero procedure here this method could return true otherwise it would return false if i want to push an object in to the stack i am trying to push this object in to the stack 
then if the size of the stack already equals n then i should throw a stack full exception else i should first increment t and then put the object at the new location incremented location yes 
this is  first increment then put the object at that location




i have to give you the top element of the stack 
so what should i do should check the stack is empty or not 
if the stack is empty then i throw a stack empty exception

as this recall that if the stack is empty then the flow of control would exit from here right 
so if the stack is not empty then i just return the top element of the stack 
if i want to pop the stack then once again i check if the top element is empty as so stack is empty 
if the stack is not empty then i let say the top element in location element 
i decrement t because i am removing the top element and lets say i set the what was t earlier index at that location i set a null i dereference it right because earlier at the top location n at location t at location number t there was lets say t was thirty seven initially right 
so at location thirty seven i had an object 
so i need to remove that object and i need to decrement t two thirty six i am doing that here 
and then i return the top element pop returns the top element also 




 yes so i recall 

i said stack empty exception is a class and i am creating an object of this type class i am creating an instance of this class so i need to do this new 



  and you can also do that so he is saying why should we necessarily dereference it that you can also do that but its best to you know to actually deference so that you can remove those objects you can get rid of those objects right otherwise they will lie in your memory 
 yes  yeah  
i do not think i even understand your question okay but i think what your trying to say is okay 

let me clarify what this here is t is just an integer okay and it is a private member of this class private because no one else needs to know about t and s is an array of objects and s t can therefore then access the  tth element of this array  will take your question later than yeah ill continue 





so about the array implementation its very simple all the operations were taking constant time none of the operations required time propositional to the virtual depend upon the number of elements in the array in this stack at that point right 
so each of those methods take order one time 

the problem however is that we have working with an upper bound on the size of the stack right 
so this upper bound was either we took the default value which is  thousand twenty four in our example or it was specified at the time of creation of stack
why this is a problem you know we do not know quite often before hand whats size stack we should have 




we might allocate a very large size stack in which case it might be waste of memory 

or we might allocate very small stack in which case we might not be able to run our procedure to completion because we would soon run we will soon have a stack full exception right 
so stack empty exception is the requirement of the interface 
why do i say this because the top and the pop methods are not defined if this stack is full the stack is empty





so it is a requirement of the interface really 
but a stack full exception is a artifact of this implementation 

if had some other way implementation perhaps then i would never may be get 




never have to even raise a stack full exception and we will see an example of this 
we will see how we can implement the stack 
so that we never have to make a stack full exception so that we can always grow the stack when need to be you have a question you have a question okay 
so will look at an application of stacks very quickly um

we have the stock prices for we have the daily stock prices of lets say particular stock 
so i give you the price on day zero the price on day one the price on day two three four five six so on 
this span s sub i of a stock price on day i is defined as the maximum number of consecutives days that the price of the stock has been less than or equal to its price on day i right
so this example would make it clear 
so the span so s five is this span of this stock price on day five and it is equal to the maximum number of days that the price of this  stock has been less than or equal to this price yeah 
so four days the price of this stock was less than or equal to this days price and so the span of um the span of stock price on day five equals four  inclusive of kind
this should make clear right we are counting one two three four and for here instance for days six is one two three four five six
for all others this is one this is one this is two 





right so how can you compute this span so i give you the stock prices in say array p

so p is an array of numbers 
i give you the stock prices in this array and i want to compute this span in an array s right
so what is that your going to do 
so do to compute s sub i what your going to do is your going to look at the price of the stock on day i look at the price of the stock on day i minus one i minus two i minus three and so on right 
so k the index k will start from zero and keep going down and you will keep going down till the price of the stock on day i minus k is less than the price of the stock on day i 
the moment you find  a case such that the price of stock on day i minus k is actually more than the price day i you stop you stop this loop right 
otherwise you keep decrementing incrementing k 
so if this quantity is less than your increment k else you say done is true done will help us exist repeat until the loop 
they will exit repeat until loop if done is true or if k equals i which means that you have reach day zero right 
and what will be the span then span then will be determine by the value of k because k enters what is the span stock price on day i
so s of i gets the value k yeah
so this would be one way of implementing this doing this thing computing this span 
how much time does this take 
we can see on that slide is n squared should i take an square time
why should it take n square time  
[ we are repeatedly comparing um]
exactly so this loop could in the worst case go all the way from  so how many times this loop can be executed in the worst case  i times [ i times] right and i is varying itself zero from n minus one 
once again we have the same summation as we saw in the last class 
this is executed i times i is going from zero through n minus one 
so the total number of times this might get executed one of this statement might get executed might be n square n square by two 
yeah so the running time of this algorithm is big oh of n square in the worst case 





so question is can we do some better yeah and quite likely we can which is why we are talking of stacks 

so we can use a stack to do something better
so recall that to compute the span we need to know the closet day preceding i on which the stock prices greater than price on day i yeah that's what we need to know 
in this example i need to know for day five i need to know the closest day preceding day five on which the stock price is more than the price of day five this is the price on day five 
so on day one it was more yeah 
so first day five um the span would be one two three four 
so i am going to call this quantity h of i what is h of i h of i is the um this quantity closet day preceding i on which the price is greater than the price on day i yeah 
so who can tell me what is h of three h of three is two h of two is one h of one is zero h of zero is minus one conventionally lets defined in that way 
h of four is three h of five is one and h of six is zero 
once you computed these h h how can you determine  s sub i span
this span is then just given by 
so what is span of five then span for the price on day five is five minus one four yeah 
so if we can compute h these h quantity we can compute what this span is these very easily 








how do we compute the h quantities
suppose these were the prices that were i given you on days one through six 
i have not told you price on the day seven is okay 
but can h of seven b one 
i have not told you h what the price on day seven is but what h of seven definition of h seven is the closest tape preceding seven on which thus stock price is larger than price on day seven 
but that take cannot be one at all because the price on day two is larger than the price one 
similarly that day cannot be three or four yeah what are the possible values that h of seven can take  two five and six
these are the only possible values that h seven can take 
i don't know what take seven is 
these are the only values it take yeah 




so we will store these indices  so we will store these indices two five six array in a stack 
two will be bottom stack five will be the above of that six will be top 
yeah 
not to determine seven what do i need to do ill first compare the price on day seven with price on day six suppose the price on day seven is less than the price on day six then what is the h of seven 
six but if the price on day seven was larger than price on day six then i will compare with  price on day five 
if it is larger than price on day five then i will compare it with two 
if it is larger than two then it is minus one then h of one is minus one 



so suppose this is the price on day seven

this new bar i have drawn it 
so now its more than the price day six so what is the h of seven then  five right 
so h of seven now become is five 
so the first price larger than the price on day seven in these in this comparison gives me h of seven 
but now once i know h of seven i should update my stack what should my stack contain now 
earlier it contain the this two five and six what it should contain now  two five and seven 
is it clear because for eight now h of eight h of eight can never be six i should get rid of six by seven right 
so you can see that stack would be the right way to do the these things 





and lets look at the procedure which does this now 
so let d is going to be the stack of my 
okay it is initially empty and what i am going to do when i get a certain price i am going to compare that price with the price on the top of the stack 
if it is less than if it is less than the price on the top of the stack then what happen recall the previous lecture 
if it is less than the price of the top of the stack on the top of the stack that two five and six 
if this bar less than the six  then it is just what is there on the top then we are done 
right 
the index on the top of the stack will give my h value right 
if it is more than the top of the stack the the price on the top of the stack then i will pop of 
in will remove the top of the stack because i need to compare with the next one and why can i pop up because i will not  need that quantity any more later 




as you recall from previous slide 
since this was more than this i can actually get rid of this because the next time in the stack 

i don't need this at all yeah we are going to use this pop 
so we are going to go around this loop till either done becomes true 
when done becomes true means i have found a price which is larger than the current days price 
but if done never becomes true and the stack becomes empty then what do what happens stack becomes empty  h is minus one exactly that being said if when i exit this loop the stack is empty then h should be  minus one else what is h 
h is the top value stack yes and once i know h compute s of i and i keep this and ill push i back in now yeah
we call in the previous slide when i got this seven i now push seven n for my next computation great 
how much time this take now why should taken may this loop execute whole lot of times this while loop might be execute a lot of times so why should this take n time 
 is the worst case n square or the worst case n here 




[student : n square]  how many elements do we pushed on the stack 

[ one ] one no in all how many pushed on to the stack 
each element is pushed once 
so in all we have pushing at most n elements stack 
if there are any elements begin with 
every time this loop is executed yeah pop of elements yes or no 
so how many times this loop executed over all 
um at most n times 
every time the loop executes we are removing an element from the stack 
so if the total number of elements ever pushed on the stack was n 
then how can pop up more than n elements from the stack
so that means that the total number of times loop executes not more than else right
how many times do these statements execute they all most n times because this is part of a for loop 
this execute exactly n times exactly execute so whats the total number of total time you will take 
order n not n square  
i hear some of you still saying n square  
i am saying total number of times this loop executes over all iteration put together know more than n because every time the loop execute  every time we grow this loop move an element stack and never we pushed n elements total total number of elements pushed on the stack is that most okay  




 
good question i don't seem to k is  it should be h
this case should be h thank you okay
so i said one problem with our stack implementation so far was that we had to give maximum size for this stack yeah
suppose we 

so now we are going to look at an implementation in which the stack grow if it ever gets fulled right
however we are going to do that if the size of the stack so now we are pushing an elemnt the size of the stack is n then i create an new array of length f of n will come to what f of n is 
i create a new array i copy all the elements of my original stack s in to a and then i rename as s 
so this becomes my new slide 
so now i have a new stack which is f of n elements in it f of n locations in it which is capacity of f of n 
f of n will be larger than n for a and so we had increase the size of the stack okay 
and i increment and do regular thing i do for a push i increment the top counter and i put the new object i am trying to push top location 
so the question is how should we what should we chosen f of n is right 
so there are two strategies  that one could adopt one could either have a tight strategy for growth strategy 
we always increment the size of the array by some constant c 
we just increment additive increment and in the growth strategy we double the size of the stack     



and we want to compare these two strategies  
you want to see which of these strategies is better strategy 

so we are going to think of push is as of two kinds one is regular push 
in a regular push push you just there was space in the stack and you just push the element 
so it takes one unit of time 
a special push is one in which the stack is already full and you have to create a larger stack 



and copy the elements form the earlier stack stack to this larger stack and then push the element 
so you created a stack of size of f of n

that cause f of n unit 
you copied the n element that cause n units and then you pushed that one more element that cause one more unit 
so the total cost of this special push operation be f of n plus n plus one okay 
so lets see lets see how how the tight strategy which is where we incrementing the size of the stack by c unit 
c now its example c taken to be four how this behaves right 
initially i started with the stack of size and the array of size zero 
when the first element came to push that was a then i create a stack of size four right and i push this first element n
so the total cost was four plus one 
when the second element came i don't need to enlarge my stack because have space yeah 
so it just cost me one unit 
it's a regular push 
this is also regular push 
this is also a regular push 
so the all  cost one unit each 
now this is special push because when i am not trying to push e 
this stack is already so i need to create an array of size eight 
i need to copy this four elements then i need to push one 
so the total cost becomes cost becomes eight plus four plus one 
so these are all three next regular pushes then once again when i fill this ill create an array of size twelve now why because c is four 
so iam incrementing the size of the array by four four units every time 
so in create an array of size twelve 
i copy this eight elements then i push one more element twelve plus eight plus one and so on finally have this thing
so i am going to call this one when size of the array was four going to call phase one size of the array is eight phase so on right 
lets see what is the total cost that been curved in the procedure 





okay so there is a small problem here this pound is a multiplication operator some think of this multiply right 
so in phase i the size of the array is c in to yeah in phase it is c in phase two c three is three c so on 
so the size of the array seen to i 
so what is the total cost of a's i 
at the beginning of phase i i first create an array of size seen 
then i copy the previous array then i copy the elements of the previous array 
look at this example 
i first create an array of size eight 
i copy the previous four elements 
so i  copy c into i minus one elements is the cost of copying the element in to the new array 
then i then i will do c more pushes in to this in this phase 
total of c more pushes in this phase right before the array gets fulled 
c is the total cost of the four regular pushes i have been doing
c pushes and the total cost is seen to i minus one c which is two times c i 
this is the cost of phase i 
in each phase i am doing c pushes right
if i am doing if i have to do total of n pushes then how many faces i do need n by c phases and total cost of n by phases would be two c times one plus two plus three up to n by c because the cost of ith phase is two c i and what is this quantity this sum roughly n square by c square times two c so it becomes this is approximately so i this is not t this is approximately n order square c 
this equal to order of n square c 



right this is far as the tight strategy concerned  yeah  we could also take creation under one right 
in which case the analysis would change slightly right 
for the purposes analysis i am  just taking it as you know if you creating an array of size something 
you taking that much as the cost 
okay let me quickly through growth strategy we are running out of time here 
so in the growth strategy i start with an array of size zero 

if i get the first element create an array of size one 
when i am trying to push an element i would double this array 
so i create an array size two push this element when i am try to push the element 
i double this array create an array of size two size four and push   this element and i have space 
this is the regular push ill pushing d when i am try to push the fifth element i will double the size of array again right
so i create an array of size eight copy these element and then push the fifth element and so on right 
once again we analyze the cost one is the cost of creating the array you don't have to copy anything 
one is cost push anything 
here we created an array of cost two we copied one element one was the cost of pushing 
we created an array of size four
two was the cost of copying one was the cost pushing the elements c here was the regular push so on and on 
and once again we define a face as when the cost of when the size of the array was one call it as face zero it is two we call it as phase one 
when it was phase  four we call it phase when it was eight we call it as phase three so on  
so as you can see in phase it the array has size two to the i phase three it has size eight phase four it has size sixteen so on 
so in the phase i since it is the size two to the i i spent two to the i i units of time creating the array 
then i have to copy elements of the previous array right 
so two to the i minus one elements of the previous array 
they have to be copied 
so how many elements left after copied to the two tminus one
they have to be pushed in in this phase two to the i minus one cost of pushing in the i minus one elements 
so the total cost of phase i is two to the i two to the plus one 
if we do n push all how many phases we would have we would have log in phases right
because the way the size it is 




the array is going 
so the total cost of n pushes is going to be two pushes four plus eight and so on up to the two log n plus one which sum up this four n 
so the total cost of n pushes four n here and what was in the tight strategy [n square by c] n square by c 
so this is earlier by this strategy right 
with this we are going to stop discussion about stacks 
next class we will discuss queues and linked lists stop here then    

