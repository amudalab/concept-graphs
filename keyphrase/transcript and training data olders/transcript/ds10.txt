Lecture-10

Today we are going to be talking about quick sort [um] this is the second sorting algorithm we are discussing in the series of lectures the first one was insertion sort for which we had argued a worst case running time of order n squared so today the quick sort algorithm we are going to look at is also going to have a worst case running time of order n squared but we will argue that on an average in expectation it takes only about n log n time and it is a quick algorithm in practice it is very fast with very small constants

The another property of this algorithm is that its in place sorting algorithm what is an in place sorting algorithm an algorithm is called in place sort in place if you don't require any additional memory to do the sorting rite so we will assume that the numbers are given in an array the n numbers are given in an array we will not need any additional memory for one or two more variables but we will not need any additional memory to do the sorting so that's called place sorting and that's typically [um] you know good thing to have because you know its space is at a premium especially when you are trying to sort a large collection of numbers 


[2:20]
So [um] this algorithm falls into [um] into a paradine which is called divide and conquer ok  am not going to be saying too much about this [um] at this point because we are going to be seeing a lot of divide and conquer algorithms in the course in this course [um] at a very high level the idea behind divide and conquer is the following that you are given a certain problem that you want to solve you divide the problem up into two or more pieces you solve the problem for those smaller pieces ok 

So that would be the divide step would be in the in the case of quick sort it would be that will partition our array will take the array which has chose the n numbers and partitioned it break it up into two parts one is we will call the lower part and the other we will call the higher part the property of the lower part and the higher part would be that every element in the lower part every number in the lower part would be less than every number in the higher part ok 

What's how does this help us if we do such a partition well if I sort the lower part now and I sort the higher part and I put all elements of the lower part first and follow it up with all elements of the higher part then the entire thing is sorted rite I sorted the lower part  is sorted the higher part every elements here is less than the elements in the higher part ya so the entire thing is sorted so that is the combining part and in this case it is trivial because nothing needs to be done but quite often in divide and conquer algorithm you have to do something to do the combine and we will see examples of these later so we will go one step at a time   we will understand first how this partition is done ok  




[4:25]

So [um] we we will give a algorithm to do the partitioning which will be a linear time procedure so the partitioning is done along around what is called a pivot element ok I will take one of these elements as a pivot and everything which is smaller than the pivot will be lower half  lower part of the array and everything which is larger than the pivot will be the larger part ok so for instance in this example am going to so this is the procedure to the partitioning [um] its takes us parameters the array a and p comma r are the limits of the array rite p here refers to this location and r refers to this location this could be part of  a larger array ya this just says that this partitions the sub array from p to r 

Ok and we will see what it will do at the end of the procedure ya so I am going to take a r a r would be this element x I will put it into x which means x is going to be my pivot element t.k so x would contain ten and now what is this doing this is i is getting the value p minus one so I is assigned to something before p so this is p and this is r location this location is r and this location is p ya and I  is getting p minus one and j is getting r plus one and so which means I and j are just before and after we end [um] we start in the end of  the array the sub array that we are interested in

And now we are just going to go through this lop while true which means we just  continue going through this loop till you break out to the loop  and what is this doing this is saying repeat j is j minus one until aj is less than or equal to k so we are looking at this index and we are saying keep decrementing it till I reach a location which is less than or equal to which is less than or equal to what was x the pivot ten so keep decrementing it so decrement j till I reach a locations which has counting less than or equal to ten so already I reached such a location so I stopped decrementing tk 


Now I go to the next loop where am incrementing I till I reach a locations which is greater than or equal to ten so already I reached a location which is greater than or equal to ten tk now what am I going to do recall that I want everything in the left part to be less than ten and everything in the right part to be more than ten so these are in some sense called prints because this more than ten and it is in the left part and this less than or equal to ten and its in the right part so we will try to sort that and that's what we will do  here  exchange ai aj means just sort these contents rite is ort these contents 

So blue I will denote everything which is part of the left part and orange would be everything which is part of the right part so everything in the left part would be less than or equal to ten which is my pivot element and everything in the right part which is the orange part will be greater than ten greater than or equal to ten ya good 

And no we will continue this so I is recall I is here at this point and j is here and so once again I am going to keep decrementing j till I find an element which is what do I have to find an element which is smaller than ten so I found one already and I keep
 Incrementing I till I found  find an element which is larger than ten so that actually I will find rite here and once again I will stop these things ya I stopped them and I continue with j so j will keep moving till I find something which is smaller than ten so I actually I found immediately one which is smaller than ten at this location and it will keep moving till I find an element which is larger than ten so this is not larger so actually I will head up till this location nineteen and I will once again swap eight and nineteen ya I swap eight and nineteen and I get this this is already smaller so this is also marked blue this is 

Now j would continue decrementing till I find something which is smaller than ten j is searching for something which is smaller than ten so it will come here it will come to this position rite this is the first element which is smaller than ten so it comes here and I will continue incrementing till I find something which is larger than ten so it comes here and now I and j have crossed each other so which means our job is done ya as you can see so that's what if I is less than j then you do an exchange if I is more than j which means they crossed each other then you exit return the procedure and what are we returning we are returning the value of j which tells us what are the which are the two what is the boundary of the two halves 

So this is my left half my left half is from p to j and my right half is from [stud:………] 
j plus one to r because am only returning j and not I rite j plus one to r is my right half  is everyone ok with this how much time dos this procedure takes [stud: order n] order n is this clear that its taking order n time and no more because I am [ speaks Hindi ] at every step we are decrementing j so how many times can j be decremented utmost ten times the size of the array ya and how many times can I be incremented at utmost the size of the array so this loop is done 

utmost n times this loop is done utmost n times and every time we increment or decrement we might have to do one exchange in the worst case so in this is also never be done more than n times rite questions someone is trying to say something no ok 

ya it's a simple way so why do we do it in this manner you could also have done  it in a slightly different manner rite after all we are taking the pivot and saying compare every element with the pivot and put everything which is smaller in the first few locations and everything which is larger in the next few locations rite nit if you try to do it some other way you will require more memory yes rite one way you could do is take one element at a time put it in some other array and copy that array back into this place rite that would be one way of doing it 

but that will take more memory so we want it to do it in in place as in keep all the elements in this array not take any additional memory space ok we can do this partitioning in in place that is no additional memory and in linear time ya the best purse [stud: ……………….. b group inside by taking order order n and wait] ya ok no so I am saying lets look at this repeat until loop over all the while loops let me just look at this one statement total number of times is this is executed not in one run of the mean one iteration of the while loop but all while lops put together how many times is this statement executed utmost n times because I can decrement only utmost n times 
[Stud: ……………….. particular for each file rite so in this possible that every while loop……] no that's not possible ya because for a certain while for a certain run of the while loop for one particular run of the while loop I might decrement it say three times 

Then for the next one I might decrement it another five times and so on and on but the sum over all will not be more than n because [stud: ……the sum should be……….] utmost n that's all am interested in rite the total number of times this step is executed and this step is executed and this is executed and this is all the way 







[12:30]

Good this is now my complete quick sort algorithm I did my partitioning rite so i have to do quick sort on lets say this array rite array a between limits p and r rite when I do a initial call for quick sort I will do one to length of a whatever is the length of a rite so in in general this is would be the thing so p to r now I need to do it only of p is less than r if p equals r then there is nothing to be done or if p is more than r then again it doesn't make any sense so if p is less than r then i do something what do I do I first find the partition of this part p to r rite I invoke the previous procedure a p comma r what does it do it rearranges the part of the array between p and r such that everything which is less than the pivot is in the initial part of the sub array and everything which is more than the pivot is in the later half later part of the sub array 

And what does it return it returns the demarcating lines have to say rite so the lower half is going from p to q  and the upper half or the larger half is going from q plus one to r so now I need to sort the lower half and the upper half separately so I recursively invoke quick sort on the lower half  Which is going from p to q  and on the larger half which is going from q plus one to r [stud: sir what is while to means]  while to just means just keep doing the while loop forever rite you are asking about the previous where do you stop where does this while loop stops [stud:……………] it will never it stops when you return out of this its like an exit out of this while loop like a break statement you come across break statement so rite 

So when this condition is met that I is more than j then you will come to return j and go out of this entire partition procedure itself rite so which means that you also go out of the while loop [stud:…………… replace sorting algorithm but …………… ] it will take so when we call this recursively ya when you call quick sort this recursively so note that I don't have to copy the array a rite it's the same array that keeps getting used ya the only thing that would perhaps you know we might have to create more copies of the variables 

Actually we would only be creating additional copies of these local these parameters that we are passing rite but that is space that is created on this track ok so ya so we are ignoring this you are rite but we are not you know taking any additional memory for the variab for the elements that we have they are all sitting in a single array [stud:…………… sir in quick sort is in the …………. Any random number than a fixed number] we are coming to all of that rite what element should be partitioned around what should be our pivot element we come to that in a minute  

But every one understands quick sort you took a pivot element you partitioned the array around the pivot element and you said ok let me sort this left half let me sort this right half and then I am done rite then how do solve the left and right half repeatedly you have the same procedure ok and since we have a notion of  a left half and a right half  therefore we need to write a quick sort procedure in this manner rite because this will now will specify the limits of the sub array that you are sorting p comma r ya ok good 




[16:23]

Ok so lets now try and analyze how much time does quick sort takes we only seen that the partition procedure takes order n times linear time but we don't know  how much time  quick sort takes  so the time taken by quick sort will depend upon how this split is happening what do you mean by that how many elements end up in the left half and how many elements I should not say left half but left part rite so how many elements end up in the left part and  how many elements end up in the right part ya that's what we should find out and that will determine how much time  quick sort is taking lets see why 



[17:00]

So if at every point suppose the following was happening rite that every point we actually were dividing the array up in to two equal halves ya which means that i started off with n elements this here rite [speaks Hindi] somehow or you know lucky I was or whatever it was my pivot was such that it was the median lets say which means that half the elements were less half were more so half elements ended up in the left half and  half elements ended up in the right part then when I did a quick sort on this again I was lucky again I picked a pivot such that it divided up the thing in to two parts 

And when I did my quick sort on this again I was lucky i it happened that it just divided up in to two parts equal parts and so on and on so suppose I was lucky at every step so then how much time am I taking rite lets see how much time did I take to divide this array up into two parts n by two and n by two n times the size of this array yes we saw the partition procedure took n time order n time how much time did I take to divide this array of size n by two  into two parts n by four and n by four [stud:…………] n by two n by two here and n by two here so that it becomes n 

Then to divide this sort into two parts n by eight and n by eight I again took n by four here n by four here n by four and n by four and so that's also n so in effect in each level of this tree that I have drawn in this manner am taking order n time ya to do the partition and how many levels are there in this tree of mine [stud : log n ] log n because eventually you will end up with one and there would be log n such levels rite so the total time taken is order n log n if I am lucky but I am not lucky I am naveen rite which means that so I  [stud: excuse me sir in this sort we are using the…… and the partitioning takes ……. Put that in it takes [um] big go of n] can you also so why I write theta of n and not o of n who can tell me 
 

Can you also say that the partition will take at least [um] at least omega n time will at least take n time yes because when did we say we would stop when our i and j would inter change so I has to go at least till some part and j has to go so the total number of  times I will increase I or decrease j is at least ten rite total number of  times I will increase I I am not that number of  times I will increase I is at least half I am not n by two may be I increased I only n by four times but then I mean it means I decrease j at least three n by four times so the sum is at least ten ya so I at least need n times so which means I need utmost m times I need at least n times so the exact time is really some constant time some theta of n and so I can actually send the quality good so what happens in general if you are not lucky what happens 





[20:31]

So what is the worst case [stud: n squared……………….] rite rite when we partition [speaks Hindi] rite once I gets one element the other side gets n minus one elements rite we could have such a situation t n plus t n minus one so this is again I am writing the recurrence relation time to quick sort n elements equals the time to partition that is the very first step of our quick sort procedure plus the second step  of our quick sort procedure was quick sort the left part lets say the left part has one element in it so t one plus the time to quick sort the right part which was lets say n minus one elements it's a t n minus one so this is our recurrence and lets solve this recurrence in exactly the same manner that we did earlier [speaks Hindi] rite so t one I am assuming as zero so this is just t n minus one plus theta of n wait if you have one element there is nothing to be done its sorted 

So this is just t n minus one plus theta of n now what is t n minus one it is t n minus two plus theta of n minus two [stud: n minus one ] n minus one sorry so t n minus two plus theta of n minus one and t n minus two is t n minus three plus theta of n minus two and so on and on so it eventually becomes theta of k k going from one through n ya [stud:…….] not clear [stud:…………………..]  lets make it clear what is this ok what all I am saying here is this is then equal to t of n minus two plus theta of n minus one plus theta of n which is t n minus three plus theta of n minus two plus this term which is equal to t n minus four plus theta of n minus three plus this entire thing and so on and on that's all you will get so this is what you get which is basically theta of n squared 

Ya n squared k going from one through n sum of k is just n squared that's why you get theta of n squared rite if this theta is bothering you just replace it by c some constant times n ok is this clear to everyone so this would be the worst case rite so the best case is when you do half and half split and the worst case is you know it's a very simple skewed split split 



[23:46] 

So this is what the worst case look like pictorially n divided into one in n minus one n minus one divided into one in n minus two n minus two divided into one in n minus three and so on and on and what will be the height of this tree now [stud:………..]  rite in each step this you are taking time n again you are taking time n n minus one n minus two and so on all the way down to one so that's makes it n squared 

 



[24:16]


Rite when does the worst case appear so suppose we were doing a following scheme rite we were saying let me take the last element as the pivot always that's what we get to begin with let me take the last element as the pivot rite so if my input is sorted already lets say in increasing order can I took the last element as the pivot so what how many elements will be in my lower half lower part [stud:………..]  n minus one elements in my lower part and only one element in my upper part because there is no element larger than the last element rite and once again to sort the lower part I took the last element as the pivot so once again it will get divided in this manner rite 



so the worst case would happen when the input is already sorted in ascending order or in descending order even in descending order you will take n squared time yes or no 
[stud: yes]  because when it is in descending order you took the last element as the pivot it's the smallest element [speaks Hindi] there will be one element in right half wil have all the n minus one elements in it ya and you keep doing this and this what will happen 



Rite similar kind of a thing happened in insertion sort if you remember insertion sort may we said the worst case would happen when it is when it is in descending order rite because if you recall in insertion sort we were taking an element and figuring out the best place to put that element and we would go from the end to find the best place so if it is sorted in decreasing order then the best place is always the front of the array so you will have to go all the way to the front of the array at every step rite and so its again  one plus two plus three plus four and so on all the way up to n so you will get again the same n squared 


But in insertion sort if the array was sorted in increasing order then how much time do you take [stud:………..]   Then it's the best case because you don't have to move back anymore rite it's already every element is in the rite place so its just takes constant amount of time ok that's the comparison with insertion sort but here both whether its sorted increasing sorted decreasing you might end up with something like an n squared time ya so worst case seems to app occur more often 


[26:35]

Lets continue with with this analysis rite we saw [speaks Hindi] if this split was half an half at every step then we are lucky rite and we get n log n time now suppose it was not half and half but it was [um] one tenth nine tenth that is ten percent of the elements end up on one side and ninety percent of the elements change out now suppose this was happening at every stage rite you will not call this lucky rite because its not half and half but its still good which is what we will argue now rite 

At the first stage this is what happens n by ten elements on one side and nine nine by ten elements on the other side how much time do I take to do this partition n time then this n by ten got divided into one tenth on one side and nine tenth on the other side one tenth means n by hundred on one side and nine tenth of this is nine n by hundred on the other side and this nine n by ten n also gets divided into nine n by ten on one side and nine tenths of this guy which is n t one by hundred n on this side how much time did it take to partition this into this and this [stud: n by ten]   n by ten number of elements and so for this the total time for this is still n 

So similarly the total time for every level were continued to be n but now how many levels do I have [stud:………..]   Let's figure out What the right num so look at lets just look at the largest number we have as we go down one level at a time rite because the largest number is the one which will which we want that all the numbers go down to one so the largest number is the one which we have to say it goes down to a one rite so at this route we have n the largest number at this step will be nine n by ten because the other number is smaller now what will be the largest number at this step now it will be in the nine tenths of this guy which will be the largest one so that will be a t one by hundred n 


the largest at the next step would be the nine tenths of this guy [speaks Hindi] that will be the largest guy at this step which will be this and so on and on so the largest number at every level is decreasing by a factor of nine by ten how many times can I decrease before it gets down to one utmost to the log of n now to the base ten by nine because it is decrementing by a factor of nine tens at every step ya when it was decreasing decrementing by half at every step we were saying log n base two so if we just work out the map it will be log n to the base ten by nine rite which is order log n it just some constant its different constant times  log n now 

So once again the height is order log n and so the total time taken is order n log n because at each level we are taking a total time of n and number of levels is log n now yes 
[Stud: sir moving the left t……….] ya but so what even better rite this is we have only providing an upper bound 

 

[29:56]

Ya ok so even if this split was in this strange manner one tenth and nine tenth or any constant fraction there is nothing sacrosanct  one tenth  nine tenth could have said one thirty seventh and what [Stud:………….] thirty six by thirty seven rite even that is ok no problem even then we will be able to  order argue log n yes there is nothing spectacular or special about one by ten rite the important thing is we are saying a constant fraction of numbers go on one side a constant fraction of numbers go on one side we cant afford to say only one number go on one side that becomes bad for this 




When only one number go on one side or only two numbers go on one side then we will end up taking n squared time but if we say a constant fraction one tenth or one hundredth or one thousandth or one millionth the height would still be log n yes ok so we will do a formal analysis from starting from the next slide but just to give you a little more motivation on this so suppose we were to alternate the lucky and unlucky cases even then you can prove a log n depth rite 

So what was our unlucky case one and n minus one then what was the lucky case n minus one divided into two n minus one by two and n minus one by two rite how many operations did I take here to split n and how many operations did I take here to split [Stud:…………n plus one .] n minus one rite so in total I took two n minus one operation here and after two n minus one operations or comparisons I managed to split it into n minus one by two and n minus one by two and one with two n minus one 

So now I can again do in the same tree rite I will get a recurrence like this so you don't have to I can think of it as this now that with theta n or in particular two n comparisons I managed to split it into n minus one by two on one side and lets say n minus one by two plus one on the other side actually I managed to a three way split rite because the one is coming here rite so once again we will have a depth of only log n and I took two n in each step so its two n times log n such thing rite 

 We will not worry too much about this lets try and prove lets try and do this formally rite so it seems that for many many scenarios we will get a log n we want to argue that this really is the case that we expect a time now I am using the word expected time expected time is n log n no not sorry expected time is I still need to say a little bit more before I get to expected time 




[32:51]

So what is the best thing to do we want so we said we will be lucky when we always partition half and half  best thing to do would be to find a median element rite as the pivot pick the median as the pivot and that will break up my array into two equal parts and that would be great how do I find a median element [Stud:…………] sort the numbers and then find the median element [Stud: laugh ] ya that would be one strategy except the sorting that  is what we are trying to do I the first place ya so finding median element is not straight forward you will see a procedure for doing it in your next algorithms course  
[Stud: ……..some what close to the median by dividing the array into some odd number of small array then find the then sorting these ……rite small arrays ………and sort them then …………now I repeat this to get one number  that it is close to the median and we will take log n times ……..] rite you can actually compute a median element in linear time but it is fairly a involved procedure which you will learn later 

For now what you will do is since you want t to find the median element and you cant find the median element you will just pick a random element and declare that ok so that will give me so what we are going to do is we are just going to pick a random element as our pivot ok so we said we don't want top pick  a specific element as the pivot why because if I said I always want to pick the last element as the pivot then if my sequence is lets say  in decreasing order or increasing order then  am struck I will struck with an n square running time 

So I will just pick a random element as the pivot ok so we are going to look at so this what we call a randomized algorithm what's a randomized algorithm an algorithm which is basically making some kind of random choices rite and and we will analyze what this algorithm does we will analyze the running time of this algorithm in a minute 

 

[35:14]

So this is what randomized quick sort is so we will assume all elements are distinct we partition around a random element a pivot is a random element and so the random element we just pick any element at random rite with the same probability so what kind of splits we can get we can get all kinds of different splits if I have n elements I can get a split of one n n minus one I can get a split of two n n minus two and so on and on and what will be the probability of these splits  will all be equal rite 

We will all be the probability one over n you understand why they would all be equal [stud: because it's random element] because its random element each element can be picked with equal probability rite so if I pick the f five n elements and I pick the tens smallest element then I will get a nine versus n minus ten split or a ten versus n minus ten split rite but what is the probability of picking the tens smallest element its one by n because I could have picked any element rite so I don't know what I am picking the tens smallest element I as likely as the eleven smallest element which is as likely as the twelve smallest element rite the probability of each one of them is the same 

We will see more examples of randomization in this course rite and it will you will see it as a useful tool for designing algorithms



 






[36:44]

So this is what our randomized quick sort now going to look like ok so we are only going to modify the randomize the partition procedure and call it randomized partition instead rite once again we are trying to partition the a array a between p and r the sub array between locations p and r now what do I do i begin by finding  so what is random p comma r do random  p comma r generates a random number between p and r ok lets say that number is I  between p and r means including p and r lets say that number is I and now we are just going to exchange I and the last element why am I doing this because this partition procedure if you recall was taking the last element as the pivot 

Now I want t to put my pivot at the last location so I just exchange this I just exchange the pivot element with the last location and then I call my partition procedure the same partition procedure as before so this becomes my randomized partition procedure and what does quick sort do now randomized quick sort it just instead of calling partition it calls randomized partition the rest is the same ya so you understand what it is 

So since our choice of pivot is crucial and we don't know really how to choose the pivot we just pick a random elements as the pivot and let [Stud: …………………..] no it would not be a random choice ok so what is the difference between a random choice here so he has a very good question he says if I partition it around the last element why is that not a random choice that's not a random choice because if I give you a specific input which is lets say increasing order than on that input you are going to take n squared time rite if you partition around the last element 

Now in randomized quick sort we are not partitioning around the last element we are picking a random element to partition when I pick a random element to partition then given the same sorted sequence as input you are not gong to take n squared time in fact how much time are you going to take [Stud: …………………..] we don't know how much time we are going to take ya that's interesting thing why would why don't we know how much time we are going to take [Stud: …………………..] we don't know what the pivots are going to be they are randomly selected rite 

So it might happen that today you run the algorithm and it take some time and tomorrow  you run the same algorithm and it takes a different time ya yes or no because it depends upon what random numbers are selected and those random numbers selected decide the pivot and the pivot as you seen is the crucial in deciding how much time we are taking because if that pivot was a nice one which was splitting the things roughly evenly and if its going to take less time and if the pivots were turning out to be bad ones fairly skewed then I am going to take more time ya so we are going to see all of that 

So now so if you don't know how much time the algorithm is going to take and its going to take some time today and some time tomorrow then what do we analyze what is that we can say [Stud: …………………..] the average time rite all expected what what is also called expected time rite so average over what are we doing now what is the average we are doing over [Stud: ………………….all possible inputs.] 
So are we averaging over all possible inputs [Stud: ………………….] over all possible what [Stud: ………………….] sequence of random numbers is generated in some sense rite so the way to think of it is fix an input you are not going to change the input we will run the algorithm today and tomorrow and day after and so on till the end of this course rite and then you are going to compute the time and take the average and that will be the our expected time for sorting that specific input sequence ya ok 





[41:00]

So let t n denote the expected number of comparisons required by quick sort rite t n so again t n is a function of n the time required the number of comparisons required to sort  n numbers will depend upon the depend upon how many numbers you have depend upon it now lets recall what what quick sort does quick sort first partitions if it has to partition n numbers no matter what the pivot is its always going to require the same number of comparisons its always going to require no more than n minus one comparisons rite you can think of the partition process as every number is compared against the pivot yes every number is compared once against the pivot and then all those that are less than the pivot are put on one side  all those that are more than pivot are put on the other side so w always require n minus one comparisons 

Every number has to be compared against the pivot rite because we otherwise will not be able to decide whether it goes in the left side or right side so this is the part which is the partition rite depending upon what the pivot was if the pivot was the ith  smallest element yes if the pivot was the ith  smallest element then on one side how many elements am I going to get [Stud: I minus one ] I minus one lets say I get I minus one on one side and n minus I on the other side and the ith element is already lets leave it at the right place 

Ok so now I have to quick sort those I minus one elements I have to quick sort those n minus I elements how much expected time am I taking to quick sort those I minus n one elements [Stud: t of I minus one] t of I minus one this is the expected time I take to quick sort these and this is the expected time I take to quick sort the n minus I elements so I will take this much amount of time in all 

But what is I here I is the the ith I was the fact that the pivot was the ith smallest element that happens with the probability of one over n so I am going to take this much time with the probability of one over n rite I am going to take this much time with the probability of one over n I ma going to take time t seven minus one plus t n minus  seven plus n minus one with the probability of one over n I am going to take time thirteen minus one plus t n minus  thirteen plus n minus one again with the probability of one over n and so on and on rite 

So the expected time taken is is basically then the sum rite this quantity summed over all choices of shall we replace I by the j here so the I this I is the same as this j here and each one of them is picked with the probability of one over n rite this how you compute expectations expectations of so for instance just to give you an examples those who are forgetting your expectations I roll a dice what is the expected value I see how does one compute this each one of the outcomes are equally likely each occurs with the probability of one over six I see one over one with the probability of one over six two with the probability of one over six three with the probability of one over six all of that 

So the expectation is one over six times one plus one over six times two  plus one over six times three and so on and on rite whatever value we get that's  the expected value you would see ya everyone with me on this some doubt what should I repeat what did I just say anyone what did I just say throw a dice rite throw a dice rite so what are the possible values we get one two three four five six each appears its an unloaded dice so each appears with the same probability ya ok 

Now what is the expected value what is the expected value so expectation is defined as so what is the random variable random variable is the number that comes so the random variable is the number on the dice rite this random variable lets call it x this random variables takes six different values each value take the probability of one over six ya probability x equals I equals one by six I between one and six ok now what is the expectation expectation think of the expectation as the following 

You keep throwing this dice and keep recording the outcome keep doing this forever and then just take the average ya ok so how many suppose you throw this dice one billion times rite now how many times are you going to see a one [Stud: ………………….] one billion by six times rite this what probability means the probability that it is one by six rite 

If you do the experiment sufficiently many times the this fraction of the times you are going to see this particular outcome [speaks Hindi] so ……… times your outcome was one if I am looking at the sum of the outcomes this will be one sum how many times do you see a two [Stud: ………………….] how many times do you see a three and so on rite so let me just complete this ya which is exactly the same as saying one by six into one rite this quantity here what is this quantity this is just the probability of the event in that x I equals one ya so this is one by six or I could even have written it as  probability the random variable takes the value one times this one which is the value of the random variable plus the probability ten by nine by six is the probability that it takes the random variable ten by nine by six by ten by nine is just the probability that it takes the value two 

So probability x equals two into two and so on and on probability x equals six into six ya so that's what expectation is one way of thinking of expectation is if a certain random variable is taking a set of discrete values then you just compute the value of the the probability with which it takes the value times the value summed over all the possible choices is the expectation of the random variable yes ok 




So lets revert to our slides ya this is going to be taking this value with the probability of one over n ya rite and so we have done just the probability times the value summed over  
 all the possible choices which is j going from one through n rite and I have just done again as j varies from one through n this quantity varies from t zero to t n minus one and this quantity also varies from t n minus one to zero would be zero which means every term t zero to t n minus one appears twice so I can write this part of the sum as this and this n minus one we are summing it n times and then dividing t by n and so its just plus n minus one separately and this is a recurrence we saw in the last class ya 



[49:45]

Because the recurrence for the expected number of comparisons required to insert a randomly chosen permutation of n elements in a binary search tree there should be a in a binary search tree some variable ya 

And what did we prove in the last class we solved this recurrence and we showed the solution is n log n hence expected number of comparisons required by randomized quick sort is n log n the same recurrence ya we solved it before we were just using that fact any questions till this point 


[50:41]

ya this was this is the analysis which we did and [um]  this is the expected number of comparisons required by quick sort so lets quickly summarize what is the time taken by quick sort worst case time was we said n squared best case time was n log n we dint prove it formally why it should be n log n and why it cant be less but intuitively you can understand  that the best thing happens when the two are roughly equal rite and then then  we argued with it take n log n rite and the expected is once again n log n and this behavior is similar to what we also in the last class 

ya when I am trying to insert n elements into a binary search tree rite what is the worst case time [stud:…………..] n squared it happens when my sequence is sorted what is the best case time n log n again there and that was you know if the first element I was inserting was roughly the median and the second element I was inserting was n by four rite so on and on and the expected time was n log n ok the crucial difference between what we are doing today and what we did in the last class 






ok what ok so this is something I have already said but lets just recap what  we have done today is that the running time of quick sort depends upon the numbers that are getting generated rite if the same random numbers were generated rite the running time would be the same for a given input ok so the same thing I said I give you I fix an input the running time could be some value today it could be some value tomorrow because the random numbers  generated could be different what we done is we taken expectations over these different  random numbers that have been generated by saying that today we will compute what the value is tomorrow we will compute what the value is so on and take the average we are essentially we are doing this for one fixed input and we said if I fix an input and I compute this value it turns out to be n log n rite that's what we did 

and no way we used the fact that what the input was really cant you think of it no matter what the input is your expected time is turning out to be n log n yes ya so some how this is actually what some of the slides are saying before when we said we would take a specific element as the pivot lets say the last element as the pivot we saw that the running time would depend upon what input was given to us if the input was sorted we would take n squared times but if the input was such that the last element was the median element then once again we would get this half and half split and so on and on 

so you could you know if I have taken a specific element as the pivot always then my running time would depend upon what the input sequence was what the input order was but I got that got around that somehow rite I said let me randomly pick my pivot element and now what has happened the running time doesn't really depend upon my input is it depends upon what the random number choice is which in expectation is will give me a running time of only n log n [stud:……………………………………… so how does that make things if better we don't make any fix element……………………………] the aggregate time is independent upon the input how does no so what we are trying to say here is that when we say it is independent upon the input no matter what  input we adversely gives is take you are trying to may be beat my algorithm  

you want my algorithm to take as much time as possible so the point here is that you cannot come up with any sequence such sequence rite no matter what sequence you come up what sequence of numbers you come up my algorithm will take a time which in expectation is n log n which quit often will turn out to be n log n [stud:…………………… I want to work somewhere so there nobody is going to……………. We have to make an algorithm…………. Particular kind of input may be…………….. if you look at this quantity that you want to make it independent of the input then this kind we are making a random……….for that kind of input…] 

if we knew what kinds of inputs we were getting then perhaps it makes sense to design the algorithm for those kind of inputs but this is not what we are doing here because we don't we are not designing the algorithm for a specific input sequence or specific times of input we are saying we want to be able to consider all possible inputs and in doing that we want an algorithm which really doesn't depend upon what the input is be aware it is independent of that ok




[56:27]

now what did we do in the last class for binary search tree and I want to make this difference very clear and this is the last slide so just listen carefully on this one for a binary search tree we were doing an average over what so we said take a particular input sequence and it is going to take a specific amount of time whether you run it today or you run it tomorrow its going to take the same amount of time that was not a randomized algorithm it was a very specific algorithm there were no random choices being made if you take the same amount of time no matter when you run it but if took a different input sequence it would take a different amount of time and if I took a third input sequence it would take a third different amount of time and so on and on 

and there what we were doing was you say lets take the average over all input sequences over all possible n factorial different permutations rite we took the average over all of them and then we got n log n rite you understand the difference the recurrence is the same but there is a vast difference between these two things that we have done one was what you call an average case analysis rite we looked at all possible inputs that can be there of numbers one through n there are n factorial different permutations so there are n factorial different inputs possible we looked at all of them we took that we computed the time taken by the algorithm for each one of those inputs and took the average rite 

today on the other hand ours was a randomized algorithm our algorithm was taking different times depending upon what the what the random numbers were and today we were taking the average over the random numbers that were getting generated and not over the inputs the input was fixed t.k 


With that I am going to end today's lecture we saw quick sort and we did the analyze the the expected time analysis for randomized quick sort 




--------------------------------------/




 
